<html>
<head>
<title>On automating everything — Cloud Container Provisioning on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动化一切AWS上的云容器供应</h1>
<blockquote>原文：<a href="https://itnext.io/on-automating-everything-cloud-container-provisioning-on-aws-ae88db5efad3?source=collection_archive---------5-----------------------#2019-09-11">https://itnext.io/on-automating-everything-cloud-container-provisioning-on-aws-ae88db5efad3?source=collection_archive---------5-----------------------#2019-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c1b3585abdc968b983db53a86b933ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kmXc3rshix_M48_d"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张家瑜</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><div class=""/><p id="2484" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们谈谈如何应用持续部署和集成(CI/CD)来将一些服务上线GitOps方式。简而言之，我们喜欢向Git提交新特性，并通过微服务将这些特性立即推送给用户。面向开发人员的命令行如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9a55" class="lk ll jg lg b gy lm ln l lo lp">git commit -am "add new feature X for product Y" \<br/>  &amp;&amp; git push</span></pre><p id="bb6e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在输入上面的代码行之后，一个管道就开始了，东西被测试和(重新)部署(<a class="ae jd" href="https://martinfowler.com/bliki/BlueGreenDeployment.html" rel="noopener ugc nofollow" target="_blank">蓝绿色</a>风格)，之后最终用户消费更新的服务。在Git中，版本回滚简单地通过恢复到以前的版本来工作，服务相应地改变回来。</p><p id="e897" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文主要是关于在应用infra-as-code本身之前将自动化部分放置到位——为寻找更快部署平台的方法这一永无止境的渴望服务。最后，我们创建了一个平台，将Dockerfiles转换为在AWS Fargate上运行的服务。</p><h1 id="759c" class="lq ll jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">低维护运营成本</h1><p id="eacb" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">现代基础设施工作包括服务和管理无数平台，按需即时交付。这意味着——更重要的是——自动化。</p><p id="294b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从补充这个<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/docker-makefile-x-ops-sharing-infra-as-code-parts-ea6fa0d22946"> Docker &amp; Makefile </a>部分开始，将基础架构作为代码推送到公共云平台。这些是最终应该完成工作的一行程序:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="98ea" class="lk ll jg lg b gy lm ln l lo lp"># Make-Git: create a build repository<br/>make git url=${GIT_URL_NEW_PLATFORM}</span><span id="73d8" class="lk ll jg lg b gy ms ln l lo lp"># Make-Infra: deploy the infrastructure<br/>make infra</span></pre><p id="b396" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不包括评论，那是两行代码。第一个是Make-Git，用于在新的部署对象中提取代码部分。第二个——Make-Infra——处理部署本身。</p><p id="c7df" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，所有代码都可以在Github上获得。本文的最后一节提供了到存储库的链接(Dockerfile到Fargate)。</p><h2 id="d3c3" class="lk ll jg bd lr mt mu dn lv mv mw dp lz ko mx my md ks mz na mh kw nb nc ml nd bi translated">制造Git</h2><p id="86b3" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Make-Git有助于在新项目中重用现有的代码片段。该工具是GIT-子树和-子模块的包装器。我们在一个地方维护单独的代码部分，并在需要时加入。</p><figure class="lb lc ld le gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/4f3cfe6907b84bfb1476b64a9d024a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*TFTvyuuZI0Zp0QmU4DfZ1A.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图1: Make-Git</figcaption></figure><p id="c015" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Make-Git(图1)基于. gitmodules中的配置，将现有的——可重用的——部分引入到一个新的平台中。</p><p id="78f9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Make-Git是一个Python模块，通过<a class="ae jd" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank"> PyPi </a>安装:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9511" class="lk ll jg lg b gy lm ln l lo lp">python3 -m pip install makegit</span></pre><p id="bc09" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一行没必要抄。该模块是由Dockerfile添加的，将在本文的最后一章演示。Makefile中的条目:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0597" class="lk ll jg lg b gy lm ln l lo lp">git:<br/>     $(RUN_DOCK) "GIT_URL=\"$(URL)\" makegit"</span></pre><p id="92f9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那个git目标触发了这个~/。容器运行时的别名功能:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="08e0" class="lk ll jg lg b gy lm ln l lo lp"># compressed for readability purposes<br/>function __makegit(){<br/>    ...<br/>    python3 -m makegit --url "${GIT_URL}"<br/>    ...<br/>    return $return_code<br/>}<br/>alias makegit='__makegit'</span></pre><p id="d8bb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该设置允许在容器内部运行Python3模块，从那里收集所需的GIT存储库。</p><p id="b7ab" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用~/。别名文件我们可以在前后添加代码，甚至可以使用特殊字符——引号、管道和重定向——众所周知，这些字符在Makefile中很难转义。</p><h2 id="4540" class="lk ll jg bd lr mt mu dn lv mv mw dp lz ko mx my md ks mz na mh kw nb nc ml nd bi translated">通过提交部署基础架构— VIM用户奖励</h2><p id="a958" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我逐渐习惯了持续提交和推送代码——每隔几分钟到10分钟——以获得微小增量的即时反馈。如果你是VIM用户，你可能会喜欢这个~/。vimrc片段:</p><figure class="lb lc ld le gt is"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">~/.vimrc代码片段</figcaption></figure><p id="eafd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">键入<em class="nh">:P</em>——抱歉，没有双关语的意思——提交并推送代码，或者键入<em class="nh"> :W </em>仅提交代码。这是针对VIM的，但是每个<a class="ae jd" href="https://en.wikipedia.org/wiki/Integrated_development_environment" rel="noopener ugc nofollow" target="_blank"> IDE </a>都应该能够运行类似的功能——可以随意从~/中复制。vimrc片段有选择地。</p><h2 id="0b43" class="lk ll jg bd lr mt mu dn lv mv mw dp lz ko mx my md ks mz na mh kw nb nc ml nd bi translated">制造基础设施</h2><p id="00e6" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">作为代码的基础部分是用Terraform编写的，因为我有现成的代码——它只需要我做出有限的贡献。使用Terraform的好理由是:</p><ul class=""><li id="1ca7" class="ni nj jg kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated"><strong class="kf jh">集成:</strong>一个连接所有相关云提供商的代码库。</li><li id="6cde" class="ni nj jg kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">记录:可用的蓝图有助于启动新项目。</li><li id="1000" class="ni nj jg kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><strong class="kf jh">可配置</strong> <a class="ae jd" href="https://www.terraform.io/docs/state/remote.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">远程状态</strong> </a> <strong class="kf jh"> : </strong>这有助于处理共享项目。</li></ul><p id="3a4b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">免责声明。如果你只使用AWS，CloudFormation可以说是一个更好的选择——它的自动回滚和深度AWS集成是最棒的。我将在下一篇文章中分享CloudFormation版本，在这篇文章中，我坚持使用Terraform。</p><p id="34e9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在生产设置中，Terraform要求在运行实际的部署代码之前，首先设置和检索状态。多亏了一些Python自动化和Makefile的魔力，我们把它们都压缩到了一个调用中。</p><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/96b67778363fcd78b96ac7eaf2d3c1e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aV6UCub6E7Vk_Q-i9z-myg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图2:制造基础设施</figcaption></figure><p id="3237" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图2中的制造基础示意图。通过Makefile调用Python模块RemoteState来设置Terraform状态材料(1)，然后使用普通的Terraform构建命令来部署infra (2)。</p><h2 id="c36e" class="lk ll jg bd lr mt mu dn lv mv mw dp lz ko mx my md ks mz na mh kw nb nc ml nd bi translated">关于Terraform远程状态</h2><p id="ee8f" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在企业环境中，Terraform通常由一个或多个团队使用，以确保应用安全操作<a class="ae jd" href="https://medium.com/@jessgreb01/how-to-terraform-locking-state-in-s3-2dc9a5665cb6" rel="noopener">远程状态&amp;锁定</a>。</p><ul class=""><li id="c3ef" class="ni nj jg kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated"><strong class="kf jh">远程状态</strong>。Terraform将服务id和端点等基础细节写入状态文件<a class="ae jd" href="https://www.terraform.io/docs/state/" rel="noopener ugc nofollow" target="_blank">中。将此文件存储在远程位置，提供了关于已部署基础架构的单一真实来源—存储在S3。</a></li><li id="1f74" class="ni nj jg kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><strong class="kf jh">锁定</strong>。一次只能运行一个更新过程。我们通过在数据库(存储在DynamoDB中)中设置一个锁条目来实现这一点。</li></ul><p id="ef3a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个常见的问题是，不正确的后端文件很容易导致错误状态，这很难进行故障排除和恢复。为了解决这个问题，RemoteState模块自动创建了这个文件。</p><h2 id="46a2" class="lk ll jg bd lr mt mu dn lv mv mw dp lz ko mx my md ks mz na mh kw nb nc ml nd bi translated">在远程状态—模块上</h2><p id="6956" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">远程状态模块创建:</p><ul class=""><li id="33cd" class="ni nj jg kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated">AWS上的DynamoDB和S3零件，如果这些零件尚不存在。</li><li id="062e" class="ni nj jg kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">供Terraform使用的后端文件— terraform/backend-auto.tf</li></ul><p id="6cfc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该模块从当前的GIT存储库中获取信息——由Make-Git提取。AWS键和区域信息从缺省的~/中加载。AWS/凭据和~/。aws/config文件(<a class="ae jd" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html" rel="noopener ugc nofollow" target="_blank">见AWS CLI说明</a>)。</p><p id="70ef" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将安装RemoteState模块:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="db08" class="lk ll jg lg b gy lm ln l lo lp">python3 -m pip install remotestate</span></pre><p id="bc5a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与Make-Git类似，这个一行程序包含在docker文件中。Makefile中的条目:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a43d" class="lk ll jg lg b gy lm ln l lo lp">remote:<br/>        $(RUN_DOCK) "remotestate"</span></pre><p id="2928" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">~/中的包装函数。别名:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="828b" class="lk ll jg lg b gy lm ln l lo lp"># compressed for readability purposes<br/>function __remotestate(){<br/>    ...<br/>    cd "${PROJECT_PATH}" &amp;&amp; \<br/>        python3 -m remotestate --git "build/buildrepo"<br/>    ...<br/>    return $return_code<br/>}<br/>alias remotestate='__remotestate'</span></pre><p id="58c6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RemoteState期望在“build/buildrepo”目录中有一个GIT存储库，由Make-Git在前面的章节中创建，以检索在。git/config。RemoteState从URL自动导出DynamoDB表和S3桶的名称，在下一节中，我们将解释这是如何工作的</p><h2 id="11c8" class="lk ll jg bd lr mt mu dn lv mv mw dp lz ko mx my md ks mz na mh kw nb nc ml nd bi translated">RemoteState:命名方案</h2><p id="6f0b" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">RemoteState负责根据GIT存储库URL的输入来命名DynamoDB表和S3桶。假设使用以下URL:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f737" class="lk ll jg lg b gy lm ln l lo lp">GIT_URL = <a class="ae jd" href="https://github.com/LINKIT-Group/aws-cicd-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/LINKIT-Group/aws-cicd-demo</a></span></pre><p id="cc65" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可以分解为以下几个部分:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b051" class="lk ll jg lg b gy lm ln l lo lp"># composed from ${GIT_URL}<br/>GIT_HOST = github.com<br/>GIT_ORGANISATION = LINKIT-Group<br/>GIT_REPO_NAME = aws-cicd-demo<br/>GIT_URI = ${GIT_HOST}/${GIT_ORGANISATION}/${GIT_REPO_NAME}</span><span id="9090" class="lk ll jg lg b gy ms ln l lo lp"># defaults -- optionally retrieved from ${GIT_URL}<br/>GIT_BRANCH = master</span></pre><p id="8c86" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该信息用于创建DynamoDB和S3的名称。所有字符都是小写的:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8c97" class="lk ll jg lg b gy lm ln l lo lp"># note that one set of DynamoDB tables is created to hold all repositories within one group (GIT_ORGANISATION).</span><span id="2e2a" class="lk ll jg lg b gy ms ln l lo lp"># DynamoDB Table base name -- not a Table itself<br/>DYNAMO_TABLE_NAME = terraform.${GIT_HOST}.${GIT_ORGANISATION}</span><span id="b2f2" class="lk ll jg lg b gy ms ln l lo lp"># table for locking<br/>DYNAMO_TABLE_NAME_LOCK = ${DYNAMO_TABLE_NAME}.lock</span><span id="b590" class="lk ll jg lg b gy ms ln l lo lp"># table to store key=${GIT_URI}, value=${S3_BUCKET_NAME} -pairs<br/>DYNAMO_TABLE_NAME_LOCK = ${DYNAMO_TABLE_NAME}.s3</span><span id="873f" class="lk ll jg lg b gy ms ln l lo lp"># Python Code example<br/>import time<br/>def time_string():<br/>   """Return current time in micro-second (usec) as a string"""<br/>   return str(round(time.time()*10**6))</span><span id="e08a" class="lk ll jg lg b gy ms ln l lo lp">CREATION_TIME_MICROSEC = time_string()<br/># Bucketname must be globally unique--why we add the microseconds.</span><span id="2f1f" class="lk ll jg lg b gy ms ln l lo lp">S3_BUCKET_NAME = ${DYNAMO_TABLE_NAME}-${CREATION_TIME_MICROSEC}</span></pre><h2 id="2b8e" class="lk ll jg bd lr mt mu dn lv mv mw dp lz ko mx my md ks mz na mh kw nb nc ml nd bi translated">Terraform故障排除</h2><p id="98ef" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">要运行Terraform，Makefile中有以下几行:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5d02" class="lk ll jg lg b gy lm ln l lo lp">infra:<br/>        $(RUN_DOCK) "remotestate"<br/>        $(RUN_DOCK) "terraform init \<br/>        &amp;&amp; terraform plan \<br/>        &amp;&amp; terraform apply -auto-approve \<br/>        &amp;&amp; terraform output"<br/>destroy:<br/>        $(RUN_DOCK) "terraform destroy -auto-approve"</span></pre><p id="9bc9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很好，但是用于管理或排除部署的基础设施故障的所有其他Terraform命令又如何呢？按如下方式输入容器:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9b02" class="lk ll jg lg b gy lm ln l lo lp">make shell</span></pre><p id="30b0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进入容器后，您可以直接键入单独的Terraform命令来排除故障和修复问题。</p><h2 id="1a9c" class="lk ll jg bd lr mt mu dn lv mv mw dp lz ko mx my md ks mz na mh kw nb nc ml nd bi translated">低维护运营:总结</h2><p id="7ffd" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">团队成员现在可以通过应用Make-Git来获取GIT存储库，并使用Make-Infra创建基础设施。</p><p id="d2f8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个过程的主要优点是团队成员不需要处理内部配置，在降低风险的同时加速交付。不用说，一切都是自动化的。</p><h1 id="7452" class="lq ll jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">码头文件到法盖特</h1><p id="af84" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">前面几节是关于高效地创建和部署新平台的。在这一部分，是时候交付承诺的CI/CD平台了。</p><p id="3fd5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">附加先决条件</strong></p><ul class=""><li id="3c64" class="ni nj jg kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated">AWS账户——这可以通过<a class="ae jd" href="https://aws.amazon.com/free" rel="noopener ugc nofollow" target="_blank">免费</a>获得。</li><li id="7729" class="ni nj jg kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">码头工人。安装说明:<a class="ae jd" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce" rel="noopener ugc nofollow" target="_blank"> Ubuntu </a>或者<a class="ae jd" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank"> Mac </a>。</li><li id="7ae0" class="ni nj jg kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">能够在您的主机系统上运行“<a class="ae jd" href="https://www.tutorialspoint.com/unix_commands/make.htm" rel="noopener ugc nofollow" target="_blank"> make </a>”。大多数Unix、Linux和Mac系统默认都有这个——在Windows上，我推荐Ubuntu VM。</li></ul><p id="949a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我推荐使用一个干净的AWS账号或者一个专用的测试区域来玩。我还假设你有一些使用AWS的经验，并了解我们正在建设什么。</p><h2 id="65ad" class="lk ll jg bd lr mt mu dn lv mv mw dp lz ko mx my md ks mz na mh kw nb nc ml nd bi translated">AWS上用于无服务器容器的构建管道</h2><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/f9045053905c998b3bf262de192d8610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGHuN7_ljlFbm_qprFYIrw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图AWS中的CI/CD + ECS</figcaption></figure><p id="90ee" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您的系统已经准备好—参见上面的先决条件列表—以下代码行部署该平台:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1dbd" class="lk ll jg lg b gy lm ln l lo lp"># retrieve deploytools, this repository holds MakeGit and MakeInfra<br/>git clone <a class="ae jd" href="https://github.com/LINKIT-Group/deploytools.git" rel="noopener ugc nofollow" target="_blank">https://github.com/LINKIT-Group/deploytools</a><br/>cd deploytools</span><span id="ac21" class="lk ll jg lg b gy ms ln l lo lp"># collect the code to deploy our demo<br/># code is put in the build/ directory<br/>make git url=https://github.com/linkit-group/aws-cicd-demo</span><span id="ffbc" class="lk ll jg lg b gy ms ln l lo lp"># deploy the demo<br/># note: ensure ~/.aws is setup properly!<br/>make infra</span></pre><p id="0706" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建基础设施大约需要5分钟——刚好够喝一杯咖啡、茶或吃点点心。如果一切顺利，您应该会在控制台上看到以下Terraform输出:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b152" class="lk ll jg lg b gy lm ln l lo lp"># Apply complete! Resources: 47 added, 0 changed, 0 destroyed.</span></pre><p id="4858" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意AWS法案正在运行。大约一天几美元。</p><p id="e944" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是时候访问应用程序了。登录AWS控制台，进入EC2 -&gt; Loadbalancers，这里你会发现一个应用负载平衡器:“app-demo-backend-test-alb”。单击它，打开“描述”选项卡，复制“DNS名称”下的值，并将其粘贴到浏览器窗口中。</p><p id="6e37" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该从应用程序负载平衡器那里得到以下错误消息:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8600" class="lk ll jg lg b gy lm ln l lo lp">503 Service Temporarily Unavailable</span></pre><p id="61f6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您得到这个错误消息是因为还没有应用程序。我们只创建了构建平台，等待我们推送应用代码。</p><h2 id="fc60" class="lk ll jg bd lr mt mu dn lv mv mw dp lz ko mx my md ks mz na mh kw nb nc ml nd bi translated">推送应用程序代码</h2><p id="8839" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">是时候和开发者换帽子了。让我们安装一个Nginx容器，向世界问好。我们克隆<a class="ae jd" href="https://github.com/LINKIT-Group/nginx-docker-helloworld.git" rel="noopener ugc nofollow" target="_blank">这个存储库</a>，将内容复制/粘贴到CodeCommit存储库中，并通过提交和推送进行部署。</p><p id="54d9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过浏览到AWS控制台-&gt; CodeCommit来检索${CODECOMMIT_URL}。应该有一个名为“app-${random-chars}”的存储库，单击它并转到“克隆URL”。选择“克隆SSH”并复制字符串。</p><p id="fcf6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这是您第一次克隆CodeCommit存储库，您会得到一个拒绝访问的错误。首先，按照这些<a class="ae jd" href="https://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-ssh-unixes.html?icmpid=docs_acc_console_connect_np" rel="noopener ugc nofollow" target="_blank">指令</a>设置一个SSH密钥(步骤3)。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="774d" class="lk ll jg lg b gy lm ln l lo lp"># clone CodeCommit repository -- first time its empty<br/>git clone ${CODECOMMIT_URL}</span><span id="5b20" class="lk ll jg lg b gy ms ln l lo lp"># clone nginx demo code<br/>git clone <a class="ae jd" href="https://github.com/LINKIT-Group/nginx-docker-helloworld.git" rel="noopener ugc nofollow" target="_blank">https://github.com/LINKIT-Group/nginx-docker-helloworld</a></span><span id="6a0b" class="lk ll jg lg b gy ms ln l lo lp"># copy/ paste to CodeCommit repo<br/>cp nginx-docker-helloworld/* ${CODECOMMIT_REPO}/</span><span id="0f53" class="lk ll jg lg b gy ms ln l lo lp"># commit and push -- this will trigger a container deployment<br/>cd ${CODECOMMIT_REPO}<br/>git add *<br/>git commit -am "add feature X for product Y"<br/>git push</span></pre><p id="18bf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是休息放松的时候了。您可以通过浏览AWS控制台-&gt; CodePipeLine来查看流程，并刷新指向容器的URL。</p><p id="e493" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您收到“Hello world”消息，它会按设计工作，我们就完成了。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="62f4" class="lk ll jg lg b gy lm ln l lo lp"># delete the platform<br/>make destroy</span><span id="6a43" class="lk ll jg lg b gy ms ln l lo lp"># note this will not clean up the S3 bucket and DynamoDB table used by Terraform backend. These must be deleted separately if no longer needed.</span></pre><h1 id="a343" class="lq ll jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">开始的结束</h1><p id="9b69" class="pw-post-body-paragraph kd ke jg kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我希望已经证明您可以停止使用EC2-instances进行简单的服务。您是否注意到ECS-Fargate也不插入EC2？—这些是无服务器容器。</p><p id="7699" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是看看我们能在多大程度上扩展它，并开始节省管理大型容器集群的时间——不再有笨重的EC2实例！</p><p id="9de1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对我来说，另一项工作是用纯CloudFormation替换所有的Terraform代码，并切换到Lambda-only以实现自动化粘合。</p><p id="d7e2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望在以后的文章中分享其中之一(或两者)。</p><p id="bf8c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>