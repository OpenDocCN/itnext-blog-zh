<html>
<head>
<title>A 10-Minute Introduction to Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10分钟的Scala介绍</h1>
<blockquote>原文：<a href="https://itnext.io/a-10-minute-introduction-to-scala-d1fed19eb74c?source=collection_archive---------0-----------------------#2018-10-30">https://itnext.io/a-10-minute-introduction-to-scala-d1fed19eb74c?source=collection_archive---------0-----------------------#2018-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/301a3bc0b146095d9cb7eb73078953e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFgSZTYpRbyxfti-ouAbtA.png"/></div></div></figure><p id="e6d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scala是Martin Odersky在2004年发布的一种编程语言。它提供了对函数式编程的支持，设计简洁，并编译成Java字节码，这样Scala应用程序就可以在Java虚拟机(JVM)上执行。</p><p id="cf44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看这种语言的核心特征。</p><h1 id="a27f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">你好世界</h1><p id="1fe9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先，让我们看看如何在Scala中实现hello world:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ac1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们定义了一个包含一个<code class="fe mf mg mh mi b">main</code>方法的<code class="fe mf mg mh mi b">HelloWorld</code>对象。这个方法接受一个数组<code class="fe mf mg mh mi b">String</code>作为输入。</p><p id="d17d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，我们调用了方法<code class="fe mf mg mh mi b">println</code>，它将一个对象作为输入，在控制台中打印一些东西。</p><p id="14e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同时，<code class="fe mf mg mh mi b">HelloWorld</code>也是<code class="fe mf mg mh mi b">io.teivah.helloworld</code>套餐的一部分。</p><h1 id="b652" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">价值观念</h1><p id="4583" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们可以使用关键字<code class="fe mf mg mh mi b">val</code>来命名表达式的结果。在以下示例中，两个表达式都是定义值的有效方式:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="f69e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类型是可选的。在这个例子中，<code class="fe mf mg mh mi b">v1</code>和<code class="fe mf mg mh mi b">v2</code>都是字符串类型。</p><p id="4dc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scala编译器无需显式声明就可以推断出值的类型。这就是所谓的类型推断。</p><p id="dc16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scala中的一个值是<strong class="ka ir">不可变的</strong>。这意味着，下面的代码将无法编译:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="5f3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但同样重要的是，可以使用关键字<code class="fe mf mg mh mi b">lazy</code>对一个值进行<strong class="ka ir">延迟</strong>求值:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d915" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，<code class="fe mf mg mh mi b">context</code>将不会在其声明期间进行计算，而是在其第一次调用期间进行计算。</p><h1 id="577e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">变量</h1><p id="4378" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">变量是一个<strong class="ka ir">可变</strong>值。它是用关键字<code class="fe mf mg mh mi b">var</code>声明的。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ec39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像值一样，类型是可选的。然而，一个变量不能被懒惰地评估。</p><p id="7527" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，Scala是一种静态类型语言。例如，当我们试图将一个<code class="fe mf mg mh mi b">Int</code>映射到一个已经定义为<code class="fe mf mg mh mi b">String</code>的变量时，下面的代码是无效的:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="9f40" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">阻碍</h1><p id="075f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在Scala中，我们可以通过用<code class="fe mf mg mh mi b">{}</code>包围表达式来组合它们。让我们考虑将一个对象作为输入的<code class="fe mf mg mh mi b">println()</code>函数。以下两个表达式相似:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="f36c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，对于第二个<code class="fe mf mg mh mi b">println</code>，最后一个表达式(<code class="fe mf mg mh mi b">i + 2</code>)是整个程序块的结果。</p><p id="d8c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们像<code class="fe mf mg mh mi b">println</code>一样调用一个只有一个参数的函数时，我们也可以省略括号:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="c601" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">基本类型</h1><p id="38f2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Scala被认为是纯粹的面向对象语言，因为每个值都是一个对象。因此，Scala中没有原语(比如Java <code class="fe mf mg mh mi b">int</code>)。</p><p id="449c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scala中有8种基本类型:</p><ul class=""><li id="5308" class="mj mk iq ka b kb kc kf kg kj ml kn mm kr mn kv mo mp mq mr bi translated"><code class="fe mf mg mh mi b">Byte</code></li><li id="0b7a" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><code class="fe mf mg mh mi b">Short</code></li><li id="e668" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><code class="fe mf mg mh mi b">Int</code></li><li id="b2c9" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><code class="fe mf mg mh mi b">Long</code></li><li id="4bd9" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><code class="fe mf mg mh mi b">Float</code></li><li id="2763" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><code class="fe mf mg mh mi b">Double</code></li><li id="ac33" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><code class="fe mf mg mh mi b">Char</code></li><li id="cabd" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><code class="fe mf mg mh mi b">Boolean</code></li></ul><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/df3938a6c113b354a90eb805c98aaf2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*alJoXkE9qPh2cjQah2e-tg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">Scala类型层次结构</figcaption></figure><p id="8756" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个基本的Scala类型都继承自<code class="fe mf mg mh mi b">AnyVal</code>。另一方面，<code class="fe mf mg mh mi b">AnyRef</code>是<code class="fe mf mg mh mi b">java.lang.Object</code>的别名。最后，<code class="fe mf mg mh mi b">AnyVal</code>和<code class="fe mf mg mh mi b">AnyRef</code>都继承自<code class="fe mf mg mh mi b">Any</code>。</p><h1 id="1945" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">字符串插值</h1><p id="f15a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Scala提供了一种优雅的方式将变量/值引用直接嵌入到处理过的字符串中。举一个具体的例子:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="895d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是通过引号前的<code class="fe mf mg mh mi b">s</code> <strong class="ka ir">插入符</strong>实现的。否则，它会打印<code class="fe mf mg mh mi b">Hello $name!</code>。</p><p id="9aaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scala提供的插值器很少，但它是一种可定制的机制。例如，我们可以创建自己的插值器来处理JSON转换，如下所示:<code class="fe mf mg mh mi b">println(json"{name: $name}")</code>。</p><h1 id="c35c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">数组和列表</h1><p id="a3e9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Scala也将数组作为一个对象来处理:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ff37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里要强调两件事。</p><p id="d969" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，设置元素的方式。我们使用语法<code class="fe mf mg mh mi b">a(0)</code>，而不是像在许多语言中那样使用<code class="fe mf mg mh mi b">a[0]</code>。这是一个语法上的好处，如果一个对象是一个函数，我们可以像调用<strong class="ka ir">一样调用它。在幕后，编译器正在调用一个默认的方法<code class="fe mf mg mh mi b">apply()</code>，它接受一个输入(在我们的例子中是一个<code class="fe mf mg mh mi b">Int</code>)使之成为可能。</strong></p><p id="829d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，尽管在这个例子中被声明为<code class="fe mf mg mh mi b">val</code>，但是<code class="fe mf mg mh mi b">Array</code>对象是可变的，所以我们可以改变索引0和1的值。<code class="fe mf mg mh mi b">val</code>只是强制不变异<strong class="ka ir">引用</strong>，而不是对应的对象。</p><p id="b9a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数组也可以这样初始化:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="abb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个表达和上面类似。而且，因为是用5和2初始化的，编译器推断<code class="fe mf mg mh mi b">a</code>为<code class="fe mf mg mh mi b">Array[Int]</code>。</p><p id="366c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要管理多维数组:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="0d80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码创建了一个二维数组，并将第一个元素初始化为5。</p><p id="1335" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scala标准库由许多不同的数据结构组成。其中之一就是<strong class="ka ir">不可变</strong>T0:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="5d83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与<code class="fe mf mg mh mi b">Array</code>相比，在初始化<code class="fe mf mg mh mi b">List</code>后修改索引会导致编译错误。</p><h1 id="2cd3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">地图</h1><p id="7f52" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">地图可以这样初始化:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="2178" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe mf mg mh mi b">-&gt;</code>操作符将一个颜色键与其对应的十六进制值相关联。</p><p id="0a23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mf mg mh mi b">Map</code>是一种<strong class="ka ir">不可变的</strong>数据结构。添加一个元素意味着创建另一个<code class="fe mf mg mh mi b">Map</code>:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="fe6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同时，元素不能被修改。在我们需要可变结构的情况下，我们可以使用<code class="fe mf mg mh mi b">scala.collection.mutable.Map</code>:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3bdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们变异了<em class="nc"> AK </em>键。</p><h1 id="57dd" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">方法/功能:基础</h1><p id="04fa" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们必须区分方法和函数。一个方法是一个函数，它是一个类、特征或对象的成员。</p><p id="2eb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个基本的方法示例:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="6880" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们用关键字<code class="fe mf mg mh mi b">def</code>定义了一个<code class="fe mf mg mh mi b">add</code>方法。它将两个<code class="fe mf mg mh mi b">Int</code>作为输入，并返回一个<code class="fe mf mg mh mi b">Int</code>。两个输入都是<strong class="ka ir">不可变的</strong>(就像它们被声明为<code class="fe mf mg mh mi b">val</code>一样被管理)。</p><p id="aa6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mf mg mh mi b">return</code>关键字是可选的。该方法将自动返回最后一个表达式。而且值得一提的是，在Scala中(相比Java)，<code class="fe mf mg mh mi b">return</code>退出的是<strong class="ka ir">当前方法</strong>，而不是当前块。</p><p id="af0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后要补充的是，<strong class="ka ir">返回类型是可选的</strong>。Scala编译器也能够推断出它。然而，为了代码的可维护性，显式设置它可能是一个好的选择。</p><p id="7ff4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，没有输出的方法可以写成两种方式:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="a7a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以像这样返回多个输出:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="88e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使我们不必将一组输出包装在一个特定的对象中。</p><p id="3ef6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个要提到的句法糖。让我们考虑一个没有参数的<code class="fe mf mg mh mi b">bar</code>方法。我们可以用两种方式调用这个方法:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="c94d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最佳实践是仅当<code class="fe mf mg mh mi b">bar</code>引入副作用时才保留括号。否则，我们像第二个表达式那样调用<code class="fe mf mg mh mi b">bar</code>。</p><p id="82e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，Scala允许我们指出一个方法参数可以重复<strong class="ka ir"/>。就像在Java中一样，这个可重复的参数必须是最后一个参数:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="f49d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们迭代每个<code class="fe mf mg mh mi b">args</code>元素，并返回一个聚合和。</p><p id="f1d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但同样重要的是，我们还可以定义默认参数值:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="f6cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在没有为<code class="fe mf mg mh mi b">x</code>提供值的情况下调用<code class="fe mf mg mh mi b">default</code>有两种方式。</p><p id="ec94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，使用<code class="fe mf mg mh mi b">_</code>操作符:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="b66a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，使用如下命名参数:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="a55b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">方法/功能:高级</h1><h2 id="fa7e" class="nd kx iq bd ky ne nf dn lc ng nh dp lg kj ni nj lk kn nk nl lo kr nm nn ls no bi translated">嵌套方法</h2><p id="29dd" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在Scala中，我们可以<strong class="ka ir">嵌套方法定义</strong>。让我们考虑下面的例子:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="209d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，<code class="fe mf mg mh mi b">mergesort2</code>方法仅由<code class="fe mf mg mh mi b">mergesort1</code>使用。为了限制它的访问，我们可以决定设置它<code class="fe mf mg mh mi b">private</code>(稍后我们将看到不同的可见性级别)。</p><p id="24e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在Scala中，我们也可以像这样将第二个方法嵌套到第一个方法中:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3367" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mf mg mh mi b">mergesort2</code>仅在<code class="fe mf mg mh mi b">mergesort1</code>范围内可用。</p><h2 id="6336" class="nd kx iq bd ky ne nf dn lc ng nh dp lg kj ni nj lk kn nk nl lo kr nm nn ls no bi translated">高阶函数</h2><p id="f6d5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">高阶函数<strong class="ka ir">将一个函数作为参数，或者返回一个函数作为结果</strong>。作为将函数作为参数的方法的示例:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="35dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mf mg mh mi b">f</code>是一个将<code class="fe mf mg mh mi b">Int</code>作为输入并返回<code class="fe mf mg mh mi b">Int</code>的函数。在我们的例子中，<code class="fe mf mg mh mi b">foo</code>通过将<code class="fe mf mg mh mi b">i</code>传递给<code class="fe mf mg mh mi b">f</code>来将执行委托给它。</p><h2 id="1de0" class="nd kx iq bd ky ne nf dn lc ng nh dp lg kj ni nj lk kn nk nl lo kr nm nn ls no bi translated">函数文字</h2><p id="4ddc" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Scala被认为是一种函数式语言，因为每个函数都是一个值。这意味着我们可以用这样的函数字面语法来表达一个函数:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="80a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mf mg mh mi b">increment</code>是一个类型为<code class="fe mf mg mh mi b">Int =&gt; Int</code>的函数(Scala编译器可能已经推断出来了)。对于每个整数<code class="fe mf mg mh mi b">x</code>，它返回<code class="fe mf mg mh mi b">x + 1</code>。</p><p id="490a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们再看一次前面的例子，我们可以将<code class="fe mf mg mh mi b">increment</code>传递给<code class="fe mf mg mh mi b">foo</code>:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="1cb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以管理所谓的匿名函数:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e8e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个参数是一个没有名字的函数。</p><h2 id="f70c" class="nd kx iq bd ky ne nf dn lc ng nh dp lg kj ni nj lk kn nk nl lo kr nm nn ls no bi translated">关闭</h2><p id="745a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">函数文字中的闭包，其中<strong class="ka ir">依赖于</strong>在此函数外声明的一个或多个变量/值的值。</p><p id="9c64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个简单的例子:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="6557" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，<code class="fe mf mg mh mi b">foo</code>依赖于<code class="fe mf mg mh mi b">foo</code>之外声明的<code class="fe mf mg mh mi b">Pi</code>。</p><h2 id="4793" class="nd kx iq bd ky ne nf dn lc ng nh dp lg kj ni nj lk kn nk nl lo kr nm nn ls no bi translated">部分功能</h2><p id="d58c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们考虑下面的方法来计算距离和时间的速度:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="8a53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scala允许我们通过使用强制输入的子集调用<strong class="ka ir">来部分应用</strong> <code class="fe mf mg mh mi b">speed</code>:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d40e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，在这个例子中，<code class="fe mf mg mh mi b">speed</code>的参数都没有默认值。所以为了调用它，我们需要填充所有的参数。</p><p id="7cd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，<code class="fe mf mg mh mi b">partialSpeed</code>是一个类型为<code class="fe mf mg mh mi b">Float =&gt; Float</code>的函数。</p><p id="e6bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，和我们调用<code class="fe mf mg mh mi b">increment</code>一样，我们可以这样调用<code class="fe mf mg mh mi b">partialSpeed</code>:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h2 id="276e" class="nd kx iq bd ky ne nf dn lc ng nh dp lg kj ni nj lk kn nk nl lo kr nm nn ls no bi translated">Currying</h2><p id="7ef5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一个方法可以定义多个参数列表:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="102e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法的作用与以下方法完全相同:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="8319" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，调用<code class="fe mf mg mh mi b">multiply</code>的方式不同:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="6e05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像方法签名所要求的那样，我们用两个参数列表来调用它。那么，如果我们只用一个参数列表调用<code class="fe mf mg mh mi b">multiply</code>会怎么样？</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="5345" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们部分地应用了<code class="fe mf mg mh mi b">multiply</code>，作为回报，它给了我们一个<code class="fe mf mg mh mi b">Int =&gt; Int</code>函数。</p><p id="fda1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有哪些<strong class="ka ir">好处</strong>？让我们考虑一个在特定上下文中发送消息的函数:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="a730" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们努力使这个函数变得纯粹。我们让它作为<code class="fe mf mg mh mi b">send</code>函数的一个参数，而不是依赖于外部上下文。</p><p id="8cbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在每次调用<code class="fe mf mg mh mi b">send</code>时都必须传递这个上下文，这可能有点乏味。或者一个函数不需要知道上下文。</p><p id="40b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一种解决方案可能是部分应用具有预定义上下文的<code class="fe mf mg mh mi b">send</code>并管理<code class="fe mf mg mh mi b">Array[Byte] =&gt; Unit</code>功能。</p><p id="4c1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个解决方案是将<code class="fe mf mg mh mi b">send</code>做成<code class="fe mf mg mh mi b">context</code>参数<code class="fe mf mg mh mi b">implicit</code>这样:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ac6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种情况下怎么调用<code class="fe mf mg mh mi b">send</code>？我们可以在调用<code class="fe mf mg mh mi b">send</code>之前定义一个<code class="fe mf mg mh mi b">implicit</code>上下文:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="f224" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关键字<code class="fe mf mg mh mi b">implicit</code>意味着对于每个管理隐式<code class="fe mf mg mh mi b">Context</code>参数的函数，我们甚至不需要传递它。Scala编译器会自动映射它。</p><p id="5226" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，<code class="fe mf mg mh mi b">send</code>将<code class="fe mf mg mh mi b">Context</code>对象作为潜在的隐式对象进行管理(我们也可以决定显式传递它)。所以，我们可以简单地用第一个参数列表调用<code class="fe mf mg mh mi b">send</code>。</p><h1 id="c489" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">班级</h1><p id="efab" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Scala中的类与Java中的类似:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="4c1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于语法行1，<code class="fe mf mg mh mi b">Point</code>暴露了一个默认的<code class="fe mf mg mh mi b">(Int, Int)</code>构造函数。同时，<code class="fe mf mg mh mi b">x</code>和<code class="fe mf mg mh mi b">y</code>是班上的两个成员。</p><p id="51a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个类也可以包含一组方法，就像前面例子中的<code class="fe mf mg mh mi b">move</code>。</p><p id="2bbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以用关键字<code class="fe mf mg mh mi b">new</code>实例化<code class="fe mf mg mh mi b">Point</code>:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="1fcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个类可以是抽象的，这意味着它不能被实例化。</p><h1 id="a4bb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">案例类别</h1><p id="8dc1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">案例类是一种特殊的类。如果你熟悉DDD(域驱动设计)，case类就是一个<strong class="ka ir">值对象</strong>。</p><p id="d7c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，case类是<strong class="ka ir">不可变的</strong>:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3542" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mf mg mh mi b">x</code>和<code class="fe mf mg mh mi b">y</code>的值不能改变。</p><p id="6107" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">case类必须在没有<code class="fe mf mg mh mi b">new</code>的情况下实例化:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e2d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">案例类(与常规类相比)通过值(而不是引用)进行比较:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="1ada" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">目标</h1><p id="10de" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Scala中的一个对象是一个<strong class="ka ir">单例</strong>:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="89c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对象是用<code class="fe mf mg mh mi b">object</code>关键字(👏).</p><h1 id="c5f6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">特征</h1><p id="5383" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">特征在某种程度上类似于Java接口。它们用于<strong class="ka ir">共享类之间的接口以及字段</strong>。举个例子:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d74e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">trait方法也可以有一个默认的实现。</p><p id="0c29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">特征不能被实例化，但是它们可以被类和对象扩展。</p><h1 id="bd02" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">能见度</h1><p id="c8b0" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在Scala中，默认情况下，类/对象/特征的每个成员都是公共的。还有另外两个访问修饰符:</p><ul class=""><li id="3c22" class="mj mk iq ka b kb kc kf kg kj ml kn mm kr mn kv mo mp mq mr bi translated"><code class="fe mf mg mh mi b">protected</code>:成员只能从子类中访问</li><li id="333c" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><code class="fe mf mg mh mi b">private</code>:成员只能从当前类/对象中访问</li></ul><p id="1f3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们还可以通过指定应用限制的包，以更细粒度的方式来限制访问。</p><p id="4ec7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们考虑一个<code class="fe mf mg mh mi b">bar</code>包中的<code class="fe mf mg mh mi b">Foo</code>类。如果我们想让一个方法只在<code class="fe mf mg mh mi b">bar</code>之外私有，我们可以这样做:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="7041" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">无商标消费品</h1><p id="71fe" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">泛型也是Scala提供的一个特性:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="6a11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要实例化泛型类:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="8c5c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如果-否则</h1><p id="8eb5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Scala中的If-else语法与其他几种语言相似:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3c25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在Scala中，if-else语句也是一个表达式。这意味着我们可以，比如，像这样定义方法:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="15cf" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">环</h1><p id="05f3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一个基本循环可以这样实现:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d97a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mf mg mh mi b">to</code>表示包含0到10，而<code class="fe mf mg mh mi b">until</code>表示不包含0到10。</p><p id="ea5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以循环两个元素:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="96b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，我们遍历了所有可能的元组组合:</p><pre class="lz ma mb mc gt np mi nq nr aw ns bi"><span id="0621" class="nd kx iq mi b gy nt nu l nv nw">a=0, b=0<br/>a=0, b=1<br/>a=0, b=2<br/>a=1, b=0<br/>a=1, b=1<br/>a=1, b=2</span></pre><p id="f81d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以在for中包含条件。让我们考虑以下元素列表:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="832f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们需要迭代<code class="fe mf mg mh mi b">list</code>的每个元素，并且只考虑偶数，我们可以这样做:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="a278" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，Scala为理解提供了所谓的<strong class="ka ir">来创建形式为<code class="fe mf mg mh mi b">for() yield element</code>的元素序列。举个例子:</strong></p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="4929" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们通过迭代每个元素创建了一个偶数整数的集合，如果它是偶数，那么<em class="nc">产生</em>。结果，<code class="fe mf mg mh mi b">sub</code>将被推断为一个整数序列(一个<code class="fe mf mg mh mi b">Seq</code>对象，<code class="fe mf mg mh mi b">List</code>的父对象)。</p><p id="d595" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与if-else语句一样，for也是一个表达式。所以我们也可以这样定义方法:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="f545" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">模式匹配</h1><p id="e7aa" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">模式匹配是一种根据给定模式检查值的机制。它是Java <code class="fe mf mg mh mi b">switch</code>语句的增强版本。</p><p id="d67d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们考虑一个简单的将整数转换成字符串的函数:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e28c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scala增加了一点语法上的好处，以这种方式实现了一个等价的东西:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="b9b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们删除了<code class="fe mf mg mh mi b">return</code>语句。然后，<code class="fe mf mg mh mi b">matchB</code>函数变成了一个模式匹配器，因为我们删除了函数定义后的block语句。</p><p id="840a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了一些糖还有别的吗？模式匹配是对case类的一个很好的补充。让我们考虑一个取自<a class="ae nx" href="https://docs.scala-lang.org/tour/pattern-matching.html" rel="noopener ugc nofollow" target="_blank"> Scala文档</a>的例子。</p><p id="f9bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望根据通知类型返回一个<code class="fe mf mg mh mi b">String</code>。我们定义了一个抽象类<code class="fe mf mg mh mi b">Notification</code>和两个案例类<code class="fe mf mg mh mi b">Email</code>和<code class="fe mf mg mh mi b">SMS</code>:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d0b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Scala中，最优雅的方式是在通知上使用<strong class="ka ir">模式匹配</strong>:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="b9f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种机制允许我们对给定的<code class="fe mf mg mh mi b">notification</code>进行<strong class="ka ir">造型</strong>并自动解析我们感兴趣的参数。例如，在电子邮件的情况下，也许我们对显示<code class="fe mf mg mh mi b">body</code>不感兴趣，所以我们简单地用<code class="fe mf mg mh mi b">_</code>关键字省略它。</p><h1 id="7b2a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">例外</h1><p id="e578" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们考虑一个具体的用例，我们需要从一个给定的文件中打印出字节数。为了执行I/O操作，我们将使用<code class="fe mf mg mh mi b">java.io.FileReader</code>，它可能会抛出异常。</p><p id="4cd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您是Java开发人员，最常用的方法是使用try/catch语句:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="6e35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二种实现方式有点类似于Java <code class="fe mf mg mh mi b">Optional</code>。提醒一下，<code class="fe mf mg mh mi b">Optional</code>是Java 8中为可选值引入的容器。</p><p id="3a6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Scala中，<code class="fe mf mg mh mi b">Try</code>是成功或失败的容器。这是一个抽象类，由两个案例类<code class="fe mf mg mh mi b">Success</code>和<code class="fe mf mg mh mi b">Failure</code>扩展。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="fd7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先在一个<code class="fe mf mg mh mi b">Try</code>调用中包装一个新<code class="fe mf mg mh mi b">FileReader</code>的创建。我们通过调用<code class="fe mf mg mh mi b">read</code>方法，使用映射将最终的<code class="fe mf mg mh mi b">FileReader</code>转换为<code class="fe mf mg mh mi b">Int</code>。结果，我们得到一个<code class="fe mf mg mh mi b">Try[Int]</code>。</p><p id="333b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以使用模式匹配来确定<code class="fe mf mg mh mi b">tried</code>的类型。</p><h1 id="2245" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">隐式转换</h1><p id="2316" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们分析下面的例子:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="5b30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们定义了两个案例类<code class="fe mf mg mh mi b">Foo</code>和<code class="fe mf mg mh mi b">Bar</code>。</p><p id="d35b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同时，一个对象<code class="fe mf mg mh mi b">Consumer</code>公开了一个带参数<code class="fe mf mg mh mi b">Foo</code>的<code class="fe mf mg mh mi b">consume</code>方法。</p><p id="9fee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mf mg mh mi b">Test</code>中，我们调用<code class="fe mf mg mh mi b">Consumer.consume()</code>但是<strong class="ka ir">不是按照方法签名的要求带</strong> <code class="fe mf mg mh mi b">Foo</code>而是带<code class="fe mf mg mh mi b">Bar</code>。这怎么可能？</p><p id="45c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Scala中，我们可以定义两个类之间的隐式转换。在最后一个例子中，我们只需要描述如何将一个<code class="fe mf mg mh mi b">Bar</code>转换成一个<code class="fe mf mg mh mi b">Foo</code>:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d2fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这个方法<code class="fe mf mg mh mi b">barToFoo</code>被导入，Scala编译器将确保我们可以用<strong class="ka ir">调用<code class="fe mf mg mh mi b">consumer</code>或者</strong>一个<code class="fe mf mg mh mi b">Foo</code>或者一个<code class="fe mf mg mh mi b">Bar</code>。</p><h1 id="50d0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">并发</h1><p id="1275" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了处理并发，Scala最初基于<a class="ae nx" href="https://en.wikipedia.org/wiki/Actor_model" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">角色模型</strong> </a>。Scala提供了<code class="fe mf mg mh mi b">scala.actors</code>库。然而，从Scala 2.10开始，这个库就被弃用，取而代之的是<a class="ae nx" href="https://doc.akka.io/docs/akka/current/index-actors.html?language=scala" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Akka actors </strong> </a>。</p><p id="ac08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Akka是一组用于实现并发和分布式应用程序的库。尽管如此，我们也只能在单个过程的规模上使用Akka。</p><p id="b849" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主要思想是将actors作为并发计算的<strong class="ka ir">原语来管理。一个参与者可以向其他参与者发送消息，接收消息并对消息做出反应，还可以产生新的参与者。</strong></p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/47c6748d3a2a4faf5fa387b990624209.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*2ztFnUcVqB4xZJwSejwbFA.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">行动者系统内通信示例</figcaption></figure><p id="fa17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像CSP(Communicating Sequential Processes)等其他并发计算模型一样，关键是通过消息进行<strong class="ka ir">的通信，而不是在不同线程之间共享内存。</strong></p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e0d12607156f9a1cfbc2477aa10f2db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*u_qpqprQ3GnvtM1TxVyL8Q.jpeg"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">学分:baloocartoons.com</figcaption></figure><p id="514f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scala是一种非常优雅的语言。然而，与其他语言如Go相比，学习曲线并不小。作为初学者，阅读现有的Scala代码可能有些困难。但是一旦你开始掌握它，开发一个应用程序可以以一种非常有效的方式完成。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="ac0d" class="kw kx iq bd ky kz oh lb lc ld oi lf lg lh oj lj lk ll ok ln lo lp ol lr ls lt bi translated">进一步阅读</h1><div class="om on gp gr oo op"><a href="https://docs.scala-lang.org/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd ir gy z fp ou fr fs ov fu fw ip bi translated">文档| Scala文档</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">在电脑上安装Scala，开始写一些Scala代码吧！</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">docs.scala-lang.org</p></div></div></div></a></div><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/b6578984dc018c44134738b9e16e76e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ni3QlYv1zjIZfJkxFYTzmA.png"/></div></div></figure><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/ec9b9710329661db6caf375f69308521.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*8kh8D7Gu7uPHxI0aaqGrZA.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">在推特上关注我<a class="ae nx" href="https://twitter.com/teivah" rel="noopener ugc nofollow" target="_blank">@泰瓦</a></figcaption></figure></div></div>    
</body>
</html>