<html>
<head>
<title>Create your own circular progress bar using skiasharp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用skiasharp创建你自己的圆形进度条</h1>
<blockquote>原文：<a href="https://itnext.io/create-your-own-circular-progress-bar-using-skiasharp-7c3f5616a754?source=collection_archive---------2-----------------------#2020-06-01">https://itnext.io/create-your-own-circular-progress-bar-using-skiasharp-7c3f5616a754?source=collection_archive---------2-----------------------#2020-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/04a21281825db9c0647790ad380942eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/0*inFutBUF_4qOdkmv.png"/></div></figure><p id="ac9d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">圆形进度条是一个非常受欢迎的控件，设计师喜欢在移动应用程序中使用，同样受欢迎的是，它不是所有移动平台(IOS、Android和windows)的官方SDK的一部分。</p><p id="5436" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我们将在不到10分钟的时间内实现我们自己的跨平台循环进度条:D相信我，在我们完成之后，你会爱上数学。</p><h1 id="d59b" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">步骤1:安装SkiaSharp NuGet包</h1><p id="e010" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在你所有的解决方案中安装NuGet包。视图.表格项目</p><p id="3a7f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">https://www.nuget.org/packages/SkiaSharp.Views.Forms<a class="ae lv" href="https://www.nuget.org/packages/SkiaSharp.Views.Forms/" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="cf08" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">步骤2:初始化skia视图画布</h1><p id="ce3a" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在xaml中添加画布视图</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e8f7" class="mf kt iq mb b gy mg mh l mi mj">&lt;forms:SKCanvasView x:Name="SkCanvasView" <br/>HeightRequest="500" <br/>WidthRequest="500" <br/>VerticalOptions="FillAndExpand" <br/>HorizontalOptions="FillAndExpand" /&gt;</span></pre><p id="a123" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们创建一个类“ProgressDrawer”这个类将负责绘制和维护我们的进度条</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a355" class="mf kt iq mb b gy mg mh l mi mj">public class ProgressDrawer<br/>    {<br/>        private readonly SKCanvasView _canvas;<br/>        public ProgressDrawer(SKCanvasView canvas)<br/>        {<br/>            _canvas = canvas;<br/>        }<br/>    }</span></pre><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/140fdd1cf0ed13b3a01f2b03971615d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmGTbzYAC5gkvUwpgNKDOQ.png"/></div></div></figure><p id="52b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">基本上，循环过程由两部分组成</p><p id="ac5a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 1-代表完整进度条的背景圆圈</strong></p><p id="bcc0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 2-当前进度值的弧线(红色)</strong></p><p id="c07b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我们需要在我们的类中有两个方法，一个用于圆，一个用于弧</p><p id="b76c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我们的ProgressDrawer类看起来像</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="69c1" class="mf kt iq mb b gy mg mh l mi mj">public class ProgressDrawer<br/>    {<br/>        private readonly SKCanvasView _canvas;</span><span id="fd2e" class="mf kt iq mb b gy mp mh l mi mj">public ProgressDrawer(SKCanvasView canvas)<br/>        {<br/>            _canvas = canvas;<br/>        }</span><span id="e438" class="mf kt iq mb b gy mp mh l mi mj">public void DrawCircle(int radius, SKPoint center, float strokewidth, SKColor color)<br/>        {<br/>        }</span><span id="3a00" class="mf kt iq mb b gy mp mh l mi mj">public void DrawPercentage(Circle circle, Func&lt;float&gt; progress, float strokewidth, SKColor color)<br/>        {<br/>        }</span><span id="1fb1" class="mf kt iq mb b gy mp mh l mi mj">    }</span></pre><h1 id="779b" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">第三步:画圈法</h1><p id="53ec" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">画一个圆只需要圆心和半径，现在，我们假设我们的圆心是(0，0)</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="eff3" class="mf kt iq mb b gy mg mh l mi mj">public void DrawCircle(int radius, SKPoint center, float strokewidth,SKColor color)<br/>    {<br/>      _canvas.PaintSurface += (sender, args) =&gt;<br/>         {<br/>           args.Surface.Canvas.DrawCircle(center, radius,<br/>           new SKPaint() {<br/>                          StrokeWidth = strokewidth,<br/>                          Color = color,    <br/>                          IsStroke = true});<br/>          };         <br/>     }</span></pre><p id="2a18" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Skiasharp canvas只能在1处理程序PaintSurface事件中绘制，因此我们添加了一个处理程序，它使用使用<a class="ae lv" href="https://docs.microsoft.com/en-us/dotnet/api/skiasharp.skcanvas.drawcircle?view=skiasharp-1.68.1" rel="noopener ugc nofollow" target="_blank"> SKCanvas绘制静态圆来绘制圆。画圆</a>法。</p><p id="997b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了更好的代码质量和以后的使用，让我们创建一个包含半径和中心点属性的圆类</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e6dd" class="mf kt iq mb b gy mg mh l mi mj">public class Circle<br/>    {   <br/>        public SKPoint Center { get;}<br/>        public  float Redius { get;}<br/>        public Circle(float redius, SKPoint center)<br/>        {<br/>            Redius = redius;<br/>            Center = center;<br/>        }<br/>     <br/>    }</span></pre><p id="3bd7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们重构我们的Draw Circle方法来使用Circle类</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0dac" class="mf kt iq mb b gy mg mh l mi mj">public void DrawCircle(Circle circle, float strokewidth, SKColor color)<br/>        {<br/>            _canvas.PaintSurface += (sender, args) =&gt;<br/>            {<br/>                args.Surface.Canvas.DrawCircle(circle.Center,  circle.Redius,<br/>                    new SKPaint()<br/>                    {<br/>                        StrokeWidth = strokewidth,<br/>                        Color = color,<br/>                        IsStroke = true<br/>                    });<br/>            };<br/>        }</span></pre><h1 id="e194" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">第四步:画圆弧法</h1><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4b54" class="mf kt iq mb b gy mg mh l mi mj">void DrawPercentage(Circle circle,Func&lt;float&gt; progress, float strokewidth, SKColor color)</span></pre><p id="997a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如所料，绘制圆弧方法需要知道背景圆和进度值。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mq"><img src="../Images/6f6b65346ffeceba641956bbf0315e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JLRFZl2_4FCXw3Uk.png"/></div></div></figure><p id="08b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与圆不同，圆弧绘制稍微复杂一点，所以我们需要外接矩形、起始角度和扫描角度。</p><p id="22b8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">很可能包围矩形只是一个正方形的高度和宽度等于背景圆的直径。</p><h2 id="cd42" class="mf kt iq bd ku mr ms dn ky mt mu dp lc kf mv mw lg kj mx my lk kn mz na lo nb bi translated">1-封闭矩形</h2><p id="627d" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">所以我们可以简单地在circle类中添加一个Rect属性</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5ef1" class="mf kt iq mb b gy mg mh l mi mj">public SKRect Rect =&gt; <br/>                    new SKRect(<br/>                                Center.X-Redius,<br/>                                Center.Y-Redius,<br/>                                Center.X+Redius,<br/>                                Center.Y+Redius);</span></pre><h2 id="8d87" class="mf kt iq bd ku mr ms dn ky mt mu dp lc kf mv mw lg kj mx my lk kn mz na lo nb bi translated">双起始角度</h2><p id="bc28" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">对于起始角度，由于我们想从垂直位置(12点钟)开始，它应该是90度，但因为skiasharp角度是顺时针方向，所以我们需要将角度翻转到270度。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nc"><img src="../Images/c5233a0c2e50a7d3eae5816aeb117040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sV0PR48d0KkkAj8y.png"/></div></div></figure><h2 id="d803" class="mf kt iq bd ku mr ms dn ky mt mu dp lc kf mv mw lg kj mx my lk kn mz na lo nb bi translated">3-扫描角度</h2><p id="bc66" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">扫描角度是弧的起点和终点之间的角度，因此我们只需要将属于区间[0，100]的进度值映射到一个从0到360的角度。</p><p id="b575" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最简单的方法就是使用这个等式</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/66b46f54b7e6d60179350acbeed1896b.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/0*3LbmTQ8c3-SBFmPt"/></div></figure><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="aa9c" class="mf kt iq mb b gy mg mh l mi mj">var angle = progress * 3.6f;</span></pre><p id="5185" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在把这些放在一起，我们画圆弧的方法就是</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4b78" class="mf kt iq mb b gy mg mh l mi mj">public void DrawArc(Circle circle,Func&lt;float&gt; progress, float strokewidth, SKColor color)<br/>        {<br/>            _canvas.PaintSurface += (sender, args) =&gt;<br/>            {<br/>                var angle = progress.Invoke() * 3.6f;<br/>                args.Surface.Canvas.DrawArc(circle.Rect, 270, angle, false,<br/>                    new SKPaint() {StrokeWidth = strokewidth, Color = color, IsStroke = true});<br/>            };<br/>        }</span></pre><p id="fd87" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们使用Func <float>来表示进度，而不是将其作为一个值，因为进度值会不断变化，这个draw方法只被调用一次来设置事件处理程序(我相信它应该被重命名为SetupArcDrawing)</float></p><h1 id="e895" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">设置4:重构代码</strong></h1><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c1be" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这听起来有点有趣，但实际上不需要订阅PrintSurface事件两次，我们只需要订阅一次并绘制圆和弧。</p><p id="a2dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">中心点位置通常相对于画布大小，画布大小信息仅在PrintSurface事件中可用，因此正确的唯一方法是将位置计算作为circle类中的一个函数，并在每次print surface事件触发时计算位置，顺便说一下，这将使我们的进度免费响应。</p><blockquote class="ng nh ni"><p id="da06" class="ju jv nj jw b jx jy jz ka kb kc kd ke nk kg kh ki nl kk kl km nm ko kp kq kr ij bi translated">请考虑将此类设置为可处置的，并取消订阅事件处理程序。</p></blockquote><h1 id="67b4" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">设置5:创建依赖项属性并开始使用控件</h1><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b755" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们完成了，您可以像xaml中的任何其他控件一样使用CircularProgressView。</p><h1 id="0c5c" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">第六步:跟着我</h1><p id="33bf" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">请在媒体和推特上关注我</p><div class="nn no gp gr np nq"><a href="https://twitter.com/MCC_Ahmed" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">艾哈迈德·福阿德</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">艾哈迈德·福阿德的最新推文(@MCC_Ahmed)。我是PlanRadar的一名软件工程师，目前住在维也纳…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">twitter.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe js nq"/></div></div></a></div><p id="ca53" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你想支持我，请在ko-fi.com与我分享你的咖啡</p><div class="nn no gp gr np nq"><a href="https://ko-fi.com/ahmedfouad" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">给艾哈迈德·福阿德买杯咖啡。ko-fi.com/ahmedfouad</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">我是PlanRadar的一名软件工程师，目前住在奥地利的维也纳。我的兴趣范围从技术到网络…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">ko-fi.com</p></div></div><div class="nz l"><div class="of l ob oc od nz oe js nq"/></div></div></a></div><p id="2437" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如需推荐，请阅读丹尼尔·希夫曼的《Cod的本质》一书，无论你的编码水平如何，这本书都会帮助你用简单的方法解决复杂的编码问题。</p></div></div>    
</body>
</html>