<html>
<head>
<title>Writing Lighter, Faster JavaScript Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更轻、更快的JavaScript函数</h1>
<blockquote>原文：<a href="https://itnext.io/writing-lighter-faster-functions-c631739af349?source=collection_archive---------3-----------------------#2018-10-04">https://itnext.io/writing-lighter-faster-functions-c631739af349?source=collection_archive---------3-----------------------#2018-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8c254d2615b6dbf6a2210817713a7e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2aIjr7P7EMuca97_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@rodolfomarques?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">鲁道夫·马克斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的“橙色纸杯蛋糕”</figcaption></figure><p id="c901" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谈到JavaScript性能，实际上只有三种改进策略:</p><ol class=""><li id="7a36" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">少做</li><li id="9d2b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">少做一点</li><li id="fd7b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">快点做</li></ol><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="fcc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文主要关注第二个策略，减少做事的频率。</p><p id="1baf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的函数<code class="fe lv lw lx ly b">isStooge</code>中，有一个在函数体<code class="fe lv lw lx ly b">STOOGES</code>中创建的不变对象。</p><pre class="lp lq lr ls gt lz ly ma mb aw mc bi"><span id="74a9" class="md me iq ly b gy mf mg l mh mi">function isStooge(name) {<br/>  const STOOGES = ['Larry', 'Curly', 'Moe'];<br/>  return STOOGES.includes(name);<br/>};</span><span id="ab01" class="md me iq ly b gy mj mg l mh mi">isStooge('Moe');<br/>isStooge('Joe');<br/>isStooge('Larry');<br/>isStooge('Barry');<br/>isStooge('Curly');<br/>isStooge('Burly');</span></pre><p id="3908" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然它是一个小对象，但每次函数运行时都会创建<em class="mk">。这意味着每次调用时，该函数都会为一个三项数组重新分配内存，使用一次，然后将其留给垃圾收集。这不是内存泄漏，但仍然是不必要的开销。对于静态值，最好是声明一次，每次需要时只引用一次。一个简单的方法是在函数之外作为一个全局变量。这通常是不好的建议。这里有一些更好的选择！</em></p><h2 id="1317" class="md me iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">在一次关闭中</h2><p id="bd2c" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">变量应该在靠近使用点的地方声明，你不能比在闭包里声明得更靠近(但仍然在函数体之外)。变量将只被实例化一次，引用将在函数内部使用。</p><pre class="lp lq lr ls gt lz ly ma mb aw mc bi"><span id="09d6" class="md me iq ly b gy mf mg l mh mi">const isStooge = (function() {<br/>  const STOOGES = ['Larry', 'Curly', 'Moe'];<br/>  return (name) =&gt; STOOGES.includes(name);<br/>})();</span><span id="9972" class="md me iq ly b gy mj mg l mh mi">isStooge('Moe');<br/>isStooge('Joe');<br/>isStooge('Larry');<br/>isStooge('Barry');<br/>isStooge('Curly');<br/>isStooge('Burly');</span></pre><h2 id="c0d6" class="md me iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">在模块中</h2><p id="4346" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">如果您可以拥有在闭包中声明变量的所有好处，而不使用复杂的语法，会怎么样？你可以！ES6模块本质上为其中所有未导出的内容创建了一个闭包。即使您使用Babel而不是原生的ES6模块，您仍然会得到一个闭包。</p><pre class="lp lq lr ls gt lz ly ma mb aw mc bi"><span id="981c" class="md me iq ly b gy mf mg l mh mi">// stooge.js<br/>const STOOGES = ['Larry', 'Curly', 'Moe'];</span><span id="1c44" class="md me iq ly b gy mj mg l mh mi">export function isStooge(name) {<br/>  return STOOGES.includes(name);<br/>};</span><span id="e66b" class="md me iq ly b gy mj mg l mh mi">// stoogeChecker.js<br/>import { isStooge } from './stooge';</span><span id="60c3" class="md me iq ly b gy mj mg l mh mi">isStooge('Moe');<br/>isStooge('Joe');<br/>isStooge('Larry');<br/>isStooge('Barry');<br/>isStooge('Curly');<br/>isStooge('Burly');</span></pre><h2 id="f33c" class="md me iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">在函数的一个属性中</h2><p id="8889" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">如果你的函数只被实例化一次(比如我们的<code class="fe lv lw lx ly b">isStooge</code>函数)，那么你可以把变量附加到它上面，并在函数内部引用那个属性。这是可能的，因为函数在JavaScript中仍然是对象。</p><pre class="lp lq lr ls gt lz ly ma mb aw mc bi"><span id="7468" class="md me iq ly b gy mf mg l mh mi">function isStooge(name) {<br/>  return isStooge.STOOGES.includes(name);<br/>}<br/>isStooge.STOOGES = ['Larry', 'Curly', 'Moe'];</span><span id="a1f4" class="md me iq ly b gy mj mg l mh mi">isStooge('Moe');<br/>isStooge('Joe');<br/>isStooge('Larry');<br/>isStooge('Barry');<br/>isStooge('Curly');<br/>isStooge('Burly');</span></pre><p id="fc3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果函数本身将被实例化多次，您可以将变量附加到函数的<code class="fe lv lw lx ly b">prototype</code>以防止它被重新实例化。</p><h2 id="9a73" class="md me iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">在类静态属性中</h2><p id="2660" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">类语法允许声明<code class="fe lv lw lx ly b">static</code>属性，这些属性可以通过<code class="fe lv lw lx ly b">this</code>(如果函数也是<code class="fe lv lw lx ly b">static</code>)或通过类名(下面的<code class="fe lv lw lx ly b">StoogeChecker</code>)在类的函数中引用。</p><pre class="lp lq lr ls gt lz ly ma mb aw mc bi"><span id="d067" class="md me iq ly b gy mf mg l mh mi">class StoogeChecker {<br/>  static STOOGES = ['Larry', 'Curly', 'Moe']<br/>  static isStooge(name) {<br/>    return this.STOOGES.includes(name);<br/>  }<br/>}</span><span id="9be9" class="md me iq ly b gy mj mg l mh mi">StoogeChecker.isStooge('Moe');<br/>StoogeChecker.isStooge('Joe');<br/>StoogeChecker.isStooge('Larry');<br/>StoogeChecker.isStooge('Barry');<br/>StoogeChecker.isStooge('Curly');<br/>StoogeChecker.isStooge('Burly');</span></pre><p id="70d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个方法与前面的方法有很大的不同，因为变量和函数都是更大的<code class="fe lv lw lx ly b">StoogeChecker</code>类对象的一部分。不过，在使用React组件时，这种模式确实很方便，这也是包含它的原因。还要注意，每次实例化类时，在<code class="fe lv lw lx ly b">constructor</code>方法中创建的任何变量都将被重新创建。因此，最好将这些变量声明为<code class="fe lv lw lx ly b">static</code>——盟友。</p><h2 id="0ae0" class="md me iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">结论</h2><p id="2267" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">声明不变变量最有用的模式是在ES6模块中。语法是如此容易理解和预测，它几乎是令人厌烦的。虽然严格遵循这种模式可能不会带来显著的性能提升，但这仍然是一个很好的实践。</p></div></div>    
</body>
</html>