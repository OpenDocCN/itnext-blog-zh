<html>
<head>
<title>Angular 9/8 Tutorial: Build a Web App with HttpClient and RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular 9/8教程:用HttpClient和RxJS构建Web App</h1>
<blockquote>原文：<a href="https://itnext.io/angular-9-8-tutorial-build-a-web-app-with-httpclient-and-rxjs-d76a262297b?source=collection_archive---------0-----------------------#2019-12-05">https://itnext.io/angular-9-8-tutorial-build-a-web-app-with-httpclient-and-rxjs-d76a262297b?source=collection_archive---------0-----------------------#2019-12-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5f01b62435034fb5cf18a8af08a757a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwQuUm_2nklcYZqq58m3xg.jpeg"/></div></div></figure><p id="7194" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇Angular 9教程中，我们将学习构建一个Angular 9示例应用程序，经历从创建/模拟REST API、搭建一个新项目、设置基本API，到最终构建最终应用程序并将其部署到云的所有必要步骤。</p><ul class=""><li id="1ed5" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">我们将通过示例了解如何发送带有URL查询字符串和参数的GET请求，以及如何在Angular 9/8应用程序中使用<code class="fe li lj lk ll b">Httplient</code>获取和使用JSON数据来处理来自REST API服务器的HTTP响应，如何使用RxJS <code class="fe li lj lk ll b">throwError()</code>和<code class="fe li lj lk ll b">catchError()</code>操作符对HTTP错误进行错误处理，如何在较差的网络连接中重试失败的HTTP请求，以及如何使用RxJS <code class="fe li lj lk ll b">retry()</code>和<code class="fe li lj lk ll b">takeUntil()</code>操作符取消未决的请求，最后如何使用最新的Angular 8.3+特性将应用程序部署到Firebase主机。</li><li id="8ea7" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">我们还将了解如何使用Angular services和RxJS Observables，以及如何在我们的项目中设置Angular Material，并使用材质设计组件设计UI。</li><li id="1764" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">我们将了解如何使用Angular 8.3+中的新特性<code class="fe li lj lk ll b">ng deploy</code>来轻松地从命令行将您的Angular 9应用程序部署到Firebase主机。</li></ul><p id="2e06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Angular 9目前是RC版本，带有各种<a class="ae lr" href="https://www.techiediaries.com/angular-features" rel="noopener ugc nofollow" target="_blank">新功能</a>和改进，特别是新的Ivy渲染器。</p><p id="c683" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本教程现已更新至最新的Angular 9版本。</p><blockquote class="ls lt lu"><p id="57f2" class="kb kc lv kd b ke kf kg kh ki kj kk kl lw kn ko kp lx kr ks kt ly kv kw kx ky im bi translated"><strong class="kd iu">注意</strong>:请注意我们使用的是HttpClient，它是HTTP客户端API的改进版本，从Angular版本<a class="ae lr" href="https://github.com/angular/angular/blob/master/CHANGELOG.md#430-rc0-2017-07-08" rel="noopener ugc nofollow" target="_blank"> 4.3.0-rc.0 </a>开始提供。旧的HTTP客户端在Angular 9中不可用。</p></blockquote><p id="5c03" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本教程中，您还可以了解如何将HttpClient与Angular 9结合使用，以构建一个从第三方REST API <a class="ae lr" href="https://www.techiediaries.com/angular-tutorial-example-rest-api-httpclient-get-ngfor" rel="noopener ugc nofollow" target="_blank">获取JSON数据的新闻应用程序。</a></p><p id="2068" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个循序渐进的Angular 9教程中，我们将会看到一个实际的例子，展示如何使用从<code class="fe li lj lk ll b">@angular/common/http</code>包中获得的HttpClient，使用<code class="fe li lj lk ll b">get()</code>方法发出HTTP GET请求。</p><p id="ca43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将介绍:mid_content 143</p><ul class=""><li id="f6a3" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">如何创建一个假的完整的工作JSON REST API，</li><li id="79a3" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">如何安装Angular CLI v9，</li><li id="7bc0" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">如何使用Angular CLI创建Angular 9项目，</li><li id="b269" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">如何设置有角度的材料，并使用材料设计来设计您的应用程序，</li><li id="2d79" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">如何创建角度组件，它们之间的路由和导航，</li><li id="b5dd" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">如何创建和注入角度服务，</li><li id="cfac" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">如何使用HttpClient向服务器发送HTTP GET请求，</li><li id="3001" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">如何使用HttpParams类在您的HttpRequest中添加URL查询字符串，</li><li id="333d" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">如何订阅和退订HttpClient返回的RxJS Observables，</li><li id="f881" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">如何使用<code class="fe li lj lk ll b">throwError()</code>和<code class="fe li lj lk ll b">catchError()</code>操作符处理HTTP错误，</li><li id="4695" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">如何使用RxJS <code class="fe li lj lk ll b">retry()</code>操作符重试失败的HTTP请求，</li><li id="c938" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">当请求被取消时，如何使用<code class="fe li lj lk ll b">takeUntil()</code>操作符取消订阅从HttpClient方法返回的RxJS观察值，</li><li id="9ae1" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">如何使用Angular 8.3+提供的新的<code class="fe li lj lk ll b">ng deploy</code>命令为生产构建应用程序并将其部署到Firebase主机</li></ul><p id="df5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本Angular 9教程的步骤如下:</p><ul class=""><li id="36b9" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">步骤1 —设置Angular CLI v9</li><li id="fc09" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤2 —初始化一个新的Angular 9示例项目</li><li id="47d5" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤3——设置一个(假的)JSON REST API</li><li id="4f49" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤4——在我们的示例项目中设置Angular HttpClient v9</li><li id="fad8" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤5-创建角度9组件</li><li id="299a" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤6-添加角度9布线</li><li id="2e43" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤7——用角度材质v9设计用户界面</li><li id="958f" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤8——用Angular HttpClient v9使用JSON REST API</li><li id="9f56" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤9 —使用RxJS <code class="fe li lj lk ll b">catchError()</code> &amp; <code class="fe li lj lk ll b">HttpClient</code>添加HTTP错误处理</li><li id="0451" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤10 —使用RxJS <code class="fe li lj lk ll b">retry()</code> &amp; <code class="fe li lj lk ll b">HttpClient</code>重试失败的HTTP请求</li><li id="03b4" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤11 —用RxJS <code class="fe li lj lk ll b">takeUntil()</code>取消订阅HttpClient Observables</li><li id="cfb4" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤12 —向HttpClient get()方法添加URL查询参数</li><li id="e61f" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤13 —用Angular HttpClient v9获得完整的HTTP响应</li><li id="0f5a" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤14 —用Angular HttpClient v9请求类型化的HTTP响应</li><li id="ddac" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">步骤15——构建Angular 9应用程序并将其部署到Firebase主机</li></ul><p id="d578" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从介绍Angular HttpClient、它的特性以及为什么使用它开始。</p><h1 id="5065" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">什么是Angular HttpClient？</h1><p id="fdd9" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">使用像Angular这样的框架构建的前端应用程序通过REST APIs(基于HTTP协议)使用<code class="fe li lj lk ll b">XMLHttpRequest</code>接口或<code class="fe li lj lk ll b">fetch()</code> API与后端服务器通信。</p><p id="188b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Angular HttpClient使用了支持现代和传统浏览器的<code class="fe li lj lk ll b">XMLHttpRequest</code>接口。</p><p id="4eaf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">HttpClient可以从<code class="fe li lj lk ll b">@angular/common/http</code>包中获得，它有一个简化的API接口和强大的特性，比如易测试性、类型化的请求和响应对象、请求和响应拦截器、具有RxJS可观察性的反应式API和简化的错误处理。</p><h1 id="40a6" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">为什么是Angular HttpClient？</h1><p id="c224" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">内置服务为Angular开发者提供了许多优势:</p><ul class=""><li id="9d0f" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">HttpClient使得发送和处理HTTP请求和响应变得很容易，</li><li id="c34d" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">HttpClient有许多用于实现测试单元的内置特性，</li><li id="272d" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">HttpClient使用RxJS Observables来处理异步操作，而不是承诺，这简化了常见的web开发任务，例如</li><li id="368c" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">HTTP请求的概念，</li><li id="ad7b" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">-监听下载和上传操作的进度，</li><li id="29e5" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">-简单的错误处理，</li><li id="765a" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">-重试失败的HTTP请求等。</li></ul><p id="49c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在介绍完HttpClient之后，让我们继续构建我们的示例应用程序，从成功完成Angular 9教程所需的先决条件开始。</p><h1 id="4243" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">先决条件</h1><p id="9b64" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在开始之前，您需要一些先决条件:</p><ul class=""><li id="9b3c" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">打字稿的基础知识。特别是熟悉面向对象的概念，如类型脚本类和装饰器。</li><li id="54dd" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">安装了<strong class="kd iu">节点10+ </strong>和<strong class="kd iu"> NPM 6+ </strong>的本地开发机。Angular CLI像当今大多数前端工具一样需要节点。你可以直接进入<a class="ae lr" href="https://nodejs.org/downloads" rel="noopener ugc nofollow" target="_blank">官网</a>的下载页面，为你的操作系统下载二进制文件。您还可以参考特定的系统说明，了解如何使用软件包管理器安装节点。不过推荐的方法是使用<a class="ae lr" href="https://github.com/nvm-sh/nvm" rel="noopener ugc nofollow" target="_blank">NVM</a>——节点版本管理器——一个POSIX兼容的bash脚本来管理多个活动的Node.js版本。</li></ul><blockquote class="ls lt lu"><p id="cba4" class="kb kc lv kd b ke kf kg kh ki kj kk kl lw kn ko kp lx kr ks kt ly kv kw kx ky im bi translated"><strong class="kd iu">注意</strong>:如果你不想为Angular开发安装一个本地环境，但是仍然想尝试本教程中的代码，你可以使用<a class="ae lr" href="https://stackblitz.com/" rel="noopener ugc nofollow" target="_blank"> Stackblitz </a>，一个用于前端开发的在线IDE，你可以用它来创建一个与Angular CLI兼容的Angular项目。</p></blockquote><p id="aae2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您已经具备了前面的先决条件，那么您已经为我们的Angular 9教程的下一步做好了准备，该教程将通过示例教您如何使用Angular HttpClient发送HTTP GET请求来获取JSON数据，以及各种RxJS操作符，如<code class="fe li lj lk ll b">catchError()</code>、<code class="fe li lj lk ll b">tap()</code>、<code class="fe li lj lk ll b">retry()</code>和<code class="fe li lj lk ll b">takeUntil()</code>，以实现高级功能，如错误处理、重试失败的HTTP请求和取消挂起的请求。</p><p id="74b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们教程的第一步，我们将看到如何安装Angular CLI 9并从头开始创建一个示例项目。</p><h1 id="3ea2" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤1 —设置Angular CLI v9</h1><p id="c48a" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这一步中，我们将安装最新的Angular CLI 9版本(在撰写本教程时)。</p><blockquote class="ls lt lu"><p id="053a" class="kb kc lv kd b ke kf kg kh ki kj kk kl lw kn ko kp lx kr ks kt ly kv kw kx ky im bi translated"><strong class="kd iu">注</strong>:这些指令对角度8也有效。</p></blockquote><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/72b19956d14f4eb88c594305ab1bfa7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*Wkl0c7myC1B44jhM"/></div></figure><p id="a1b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lr" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>是用于初始化和使用Angular项目的官方工具。要安装它，请打开一个新的命令行界面并运行以下命令:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="c745" class="nl ma it ll b gy nm nn l no np">$ npm install -g @angular/cli@next</span></pre><p id="c454" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在撰写本教程时，<strong class="kd iu"> angular/cli v9.0.0-rc.2 </strong>将安装在您的系统上。</p><p id="4b0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，在Angular 9正式发布之前，你需要使用<code class="fe li lj lk ll b">@next</code>标签来安装最新的预发布版本。</p><p id="4eb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您运行<code class="fe li lj lk ll b">ng version</code>命令，您应该得到类似的输出:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="ffe9" class="nl ma it ll b gy nm nn l no np">Angular CLI: 9.0.0-rc.2<br/>Node: 10.16.3<br/>OS: win32 ia32<br/>Angular:<br/>...</span><span id="795d" class="nl ma it ll b gy nq nn l no np">Package                      Version<br/>------------------------------------------------------<br/>@angular-devkit/architect    0.900.0-rc.2<br/>@angular-devkit/core         9.0.0-rc.2<br/>@angular-devkit/schematics   9.0.0-rc.2<br/>@schematics/angular          9.0.0-rc.2<br/>@schematics/update           0.900.0-rc.2<br/>rxjs                         6.5.3</span></pre><p id="ee22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步，我们将学习如何从命令行初始化一个新的示例项目。</p><h1 id="6761" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤2 —初始化一个新的Angular 9示例项目</h1><p id="9125" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这一步中，我们将继续创建我们的示例项目。回到您的命令行界面，运行以下命令:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="a33d" class="nl ma it ll b gy nm nn l no np">$ cd ~<br/>$ ng new angular-httpclient-example</span></pre><p id="74aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CLI将询问您几个问题—如果<strong class="kd iu">您想要添加角度路由？</strong>键入<strong class="kd iu"> y </strong>表示是，键入<strong class="kd iu">表示您希望使用哪种样式表格式？</strong>选择<strong class="kd iu"> CSS </strong>。</p><p id="dec1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将指示CLI在我们的项目中自动设置路由，因此我们只需要为我们的组件添加路由，以便在我们的应用程序中实现导航。</p><p id="4974" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您在项目的文件夹中运行<code class="fe li lj lk ll b">ng version</code>命令，您应该会得到类似的输出:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="ee43" class="nl ma it ll b gy nm nn l no np">Angular CLI: 9.0.0-rc.2<br/>Node: 10.16.3<br/>OS: win32 ia32<br/>Angular: &lt;error&gt;<br/>... animations, cli, common, compiler, compiler-cli, core, forms<br/>... language-service, platform-browser, platform-browser-dynamic<br/>... router</span><span id="c5cf" class="nl ma it ll b gy nq nn l no np">Package                         Version<br/>---------------------------------------------------------<br/>@angular-devkit/architect       0.900.0-rc.2 (cli-only)<br/>@angular-devkit/build-angular   &lt;error&gt;<br/>@angular-devkit/core            9.0.0-rc.2 (cli-only)<br/>@angular-devkit/schematics      9.0.0-rc.2 (cli-only)<br/>@schematics/angular             9.0.0-rc.2 (cli-only)<br/>@schematics/update              0.900.0-rc.2 (cli-only)<br/>rxjs                            6.5.3 (cli-only)<br/>typescript                      3.6</span></pre><p id="d241" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，导航到您的项目文件夹，并使用以下命令运行本地开发服务器:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="f165" class="nl ma it ll b gy nm nn l no np">$ cd angular-httpclient-example<br/>$ ng serve</span></pre><p id="9d8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本地开发服务器将开始监听<code class="fe li lj lk ll b"><a class="ae lr" href="http://localhost:4200/" rel="noopener ugc nofollow" target="_blank">http://localhost:4200/</a></code>地址。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/3906e579a7738eeb61d6ee6d70bc0baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P1Gt57hcPwAhUXXR"/></div></div></figure><p id="091f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开您的网络浏览器，导航至<code class="fe li lj lk ll b"><a class="ae lr" href="http://localhost:4200/" rel="noopener ugc nofollow" target="_blank">http://localhost:4200/</a></code>地址，查看您的应用启动并运行。这是此时的截图:</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/3c97474b2dc812cd75ecc6e417fb9a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CO8ZxcXfzJ_U1Abm"/></div></div></figure><p id="5c89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您应该让开发服务器保持运行，并启动一个新的命令行界面来运行后续步骤的CLI命令。</p><p id="0f61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步，我们将学习如何创建一个假的JSON REST API，我们将在我们的Angular示例应用程序中使用它。</p><h1 id="97bf" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤3——设置一个(假的)JSON REST API</h1><p id="f5ec" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在继续开发我们的Angular应用程序之前，我们需要准备一个JSON REST API，我们可以使用<code class="fe li lj lk ll b">HttpClient</code>来使用它。</p><p id="3352" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还可以从第三方REST API服务器上消费或获取JSON数据，但是在本例中，我们选择创建一个假的REST API。查看这个<a class="ae lr" href="https://www.techiediaries.com/angular-tutorial-example-rest-api-httpclient-get-ngfor" rel="noopener ugc nofollow" target="_blank">教程</a>中真实的REST API示例。就Angular而言，消费假的或者真的REST APIs没有区别。</p><p id="90b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，您可以使用外部API服务，创建一个真正的REST API服务器，或者使用<code class="fe li lj lk ll b">json-server</code>创建一个假的API。在这个例子中，我们将使用最后一种方法。</p><p id="7d29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，转向一个新的命令行界面，从在您的项目中安装来自npm的<code class="fe li lj lk ll b">json-server</code>开始:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="e12e" class="nl ma it ll b gy nm nn l no np">$ cd ~/angular-httpclient-example<br/>$ npm install --save json-server</span></pre><p id="29ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，在Angular项目的根文件夹中创建一个<code class="fe li lj lk ll b">server</code>文件夹:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="5dc9" class="nl ma it ll b gy nm nn l no np">$ mkdir server<br/>$ cd server</span></pre><p id="038f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe li lj lk ll b">server</code>文件夹中，创建一个<code class="fe li lj lk ll b">database.json</code>文件，并添加以下JSON对象:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="6ad1" class="nl ma it ll b gy nm nn l no np">{<br/>    "products": []<br/>}</span></pre><p id="8bb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个JSON文件将作为REST API服务器的数据库。您可以简单地添加一些由REST API提供服务的数据，或者使用<a class="ae lr" href="https://github.com/marak/Faker.js/" rel="noopener ugc nofollow" target="_blank"> Faker.js </a>自动生成大量真实的假数据。</p><p id="8961" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到命令行，从<code class="fe li lj lk ll b">server</code>文件夹返回，使用以下命令从npm安装<code class="fe li lj lk ll b">Faker.js</code>:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="feb1" class="nl ma it ll b gy nm nn l no np">$ cd ..<br/>$ npm install faker --save</span></pre><p id="b6c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在创建该示例时，将安装<strong class="kd iu"> faker v4.1.0 </strong>。</p><p id="e482" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，创建一个<code class="fe li lj lk ll b">generate.js</code>文件并添加以下代码:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="f22d" class="nl ma it ll b gy nm nn l no np">var faker = require('faker');</span><span id="9ebd" class="nl ma it ll b gy nq nn l no np">var database = { products: []};</span><span id="192c" class="nl ma it ll b gy nq nn l no np">for (var i = 1; i&lt;= 300; i++) {<br/>  database.products.push({<br/>    id: i,<br/>    name: faker.commerce.productName(),<br/>    description: faker.lorem.sentences(),<br/>    price: faker.commerce.price(),<br/>    imageUrl: "<a class="ae lr" href="https://source.unsplash.com/1600x900/?product" rel="noopener ugc nofollow" target="_blank">https://source.unsplash.com/1600x900/?product</a>",<br/>    quantity: faker.random.number()<br/>  });<br/>}</span><span id="898d" class="nl ma it ll b gy nq nn l no np">console.log(JSON.stringify(database));</span></pre><p id="1f9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先导入faker，接下来我们用一个空数组为产品定义一个对象。接下来，我们进入循环的<em class="lv">来创建<em class="lv"> 300 </em>假条目，使用类似<code class="fe li lj lk ll b">faker.commerce.productName()</code>的faker方法来生成产品名称。<a class="ae lr" href="https://github.com/marak/Faker.js/#api-methods" rel="noopener ugc nofollow" target="_blank">检查所有可用的方法</a>。最后，我们将数据库对象转换为字符串，并将其记录到标准输出中。</em></p><p id="4aeb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，将<code class="fe li lj lk ll b">generate</code>和<code class="fe li lj lk ll b">server</code>脚本添加到<code class="fe li lj lk ll b">package.json</code>文件中:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="b29a" class="nl ma it ll b gy nm nn l no np">"scripts": {<br/>    "ng": "ng",<br/>    "start": "ng serve",<br/>    "build": "ng build",<br/>    "test": "ng test",<br/>    "lint": "ng lint",<br/>    "e2e": "ng e2e",<br/>    "generate": "node ./server/generate.js &gt; ./server/database.json",<br/>    "server": "json-server --watch ./server/database.json"<br/>  },</span></pre><p id="982c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，回到您的命令行界面，使用以下命令运行生成脚本:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="247a" class="nl ma it ll b gy nm nn l no np">$ npm run generate</span></pre><p id="30c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，通过执行以下命令运行REST API服务器:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="dbdb" class="nl ma it ll b gy nm nn l no np">$ npm run server</span></pre><p id="9571" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您可以像任何典型的REST API服务器一样向服务器发送HTTP请求。您的服务器将可以从<code class="fe li lj lk ll b"><a class="ae lr" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/</a></code>地址访问。</p><p id="0833" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些是我们将能够通过JSON REST API服务器使用的API端点:</p><ul class=""><li id="4a39" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe li lj lk ll b">GET /products</code>为了得到产品，</li><li id="6c36" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><code class="fe li lj lk ll b">GET /products/&lt;id&gt;</code>通过id获取单个产品，</li><li id="4f99" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><code class="fe li lj lk ll b">POST /products</code>为了创造一种新产品，</li><li id="d74f" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><code class="fe li lj lk ll b">PUT /products/&lt;id&gt;</code>按id更新产品，</li><li id="498e" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><code class="fe li lj lk ll b">PATCH /products/&lt;id&gt;</code>通过id部分更新产品，</li><li id="cb2f" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><code class="fe li lj lk ll b">DELETE /products/&lt;id&gt;</code>用于按id删除产品。</li></ul><p id="9ad8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用<code class="fe li lj lk ll b">_page</code>和<code class="fe li lj lk ll b">_limit</code>参数来获取分页数据。在<code class="fe li lj lk ll b">Link</code>标题中，您将获得<code class="fe li lj lk ll b">first</code>、<code class="fe li lj lk ll b">prev</code>、<code class="fe li lj lk ll b">next</code>和<code class="fe li lj lk ll b">last</code>链接。</p><p id="3d35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如:</p><p id="117e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe li lj lk ll b">GET /products?_page=1</code>用于获取第一页数据，<code class="fe li lj lk ll b">GET /products?_page=1&amp;_limit=5</code>用于获取第一页数据的前五个产品。</p><blockquote class="ls lt lu"><p id="af33" class="kb kc lv kd b ke kf kg kh ki kj kk kl lw kn ko kp lx kr ks kt ly kv kw kx ky im bi translated"><strong class="kd iu">注</strong>:您可以使用其他功能，如过滤、排序和排序。更多信息，请查看<a class="ae lr" href="https://github.com/typicode/json-server" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></blockquote><p id="367b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让JSON REST API服务器保持运行，并打开一个新的命令行界面来输入接下来步骤的命令。</p><p id="726c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为我们所做工作的总结——我们安装了Angular CLI并初始化了一个基于最新Angular 9版本的新项目。然后，我们使用<code class="fe li lj lk ll b">json-server</code>基于一个JSON文件创建了一个REST API。在Angular 9教程的下一步，我们将学习如何在Angular 9项目中设置<code class="fe li lj lk ll b">HttpClient</code>。</p><h1 id="1030" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤4 —在我们的示例项目中设置Angular 9 HttpClient</h1><p id="b586" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这一步中，我们将继续设置我们示例中的<code class="fe li lj lk ll b">HttpClient</code>模块。</p><p id="a603" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe li lj lk ll b">HttpClient</code>存在于一个独立的Angular模块中，所以我们需要在使用它之前将其导入到我们的主应用模块中。</p><p id="4e10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用代码编辑器或IDE打开示例项目。我将使用Visual Studio代码。</p><p id="5e93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，打开<code class="fe li lj lk ll b">src/app/app.module.ts</code>文件，导入<code class="fe li lj lk ll b"><a class="ae lr" href="https://angular.io/api/common/http/HttpClientModule#description" rel="noopener ugc nofollow" target="_blank">HttpClientModule</a></code>并添加到模块的<code class="fe li lj lk ll b">imports</code>数组中，如下所示:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="5969" class="nl ma it ll b gy nm nn l no np">import { BrowserModule } from '@angular/platform-browser';<br/>import { NgModule } from '@angular/core';</span><span id="3146" class="nl ma it ll b gy nq nn l no np">import { AppRoutingModule } from './app-routing.module';<br/>import { AppComponent } from './app.component';<br/>import { HttpClientModule } from '@angular/common/http';</span><span id="f8b9" class="nl ma it ll b gy nq nn l no np">@NgModule({<br/>  declarations: [<br/>    AppComponent,<br/>  ],<br/>  imports: [<br/>    BrowserModule,<br/>    AppRoutingModule,<br/>    HttpClientModule<br/>  ],<br/>  providers: [],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule { }</span></pre><p id="c0c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是全部，我们现在准备在我们的项目中使用<code class="fe li lj lk ll b">HttpClient</code>服务，但是在此之前，我们需要创建几个组件home和about组件。这是我们下一步要学的。</p><h1 id="1922" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤5-创建角度9组件</h1><p id="b376" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这一步中，我们将继续创建控制应用程序UI的角度组件。</p><p id="77bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到新的命令行界面，运行以下命令:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="ad2f" class="nl ma it ll b gy nm nn l no np">$ cd ~/angular-httpclient-example<br/>$ ng generate component home</span></pre><p id="9171" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是该命令的输出:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="6016" class="nl ma it ll b gy nm nn l no np">CREATE src/app/home/home.component.html (19 bytes)<br/>CREATE src/app/home/home.component.spec.ts (614 bytes)<br/>CREATE src/app/home/home.component.ts (261 bytes)<br/>CREATE src/app/home/home.component.css (0 bytes)<br/>UPDATE src/app/app.module.ts (467 bytes)</span></pre><p id="15aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CLI为组件创建了四个文件，并将其添加到<code class="fe li lj lk ll b">src/app/app.module.ts</code>文件中的<code class="fe li lj lk ll b">declarations</code>数组。</p><p id="5b12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们使用以下命令创建about组件:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="5c46" class="nl ma it ll b gy nm nn l no np">$ ng generate component about</span></pre><p id="0349" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，打开<code class="fe li lj lk ll b">src/app/about/about.component.html</code>并添加以下代码:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="dacd" class="nl ma it ll b gy nm nn l no np">&lt;p style="padding: 13px;"&gt;<br/>An Angular 9 example application that demonstrates how to use HttpClient to consume REST APIs<br/>&lt;/p&gt;</span></pre><p id="d175" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将在下面的步骤中更新home组件。</p><p id="a509" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Angular 9教程的下一步，我们将把这些组件添加到路由器中。</p><h1 id="48b2" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤6-添加角度9布线</h1><p id="c2ad" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这一步中，我们将继续向示例中添加路由。</p><p id="1c22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回到由Angular CLI为路由配置自动创建的<code class="fe li lj lk ll b">src/app/app-routing.module.ts</code>文件，导入组件，然后添加路由，如下所示:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="3fb6" class="nl ma it ll b gy nm nn l no np">import { NgModule } from '@angular/core';<br/>import { Routes, RouterModule } from '@angular/router';<br/>import { HomeComponent } from './home/home.component';<br/>import { AboutComponent } from './about/about.component';<br/></span><span id="7faf" class="nl ma it ll b gy nq nn l no np">const routes: Routes = [<br/>  { path: '', redirectTo: 'home', pathMatch: 'full'},<br/>  { path: 'home', component: HomeComponent },<br/>  { path: 'about', component: AboutComponent },<br/>];</span><span id="18de" class="nl ma it ll b gy nq nn l no np">@NgModule({<br/>  imports: [RouterModule.forRoot(routes)],<br/>  exports: [RouterModule]<br/>})<br/>export class AppRoutingModule { }</span></pre><p id="5bad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先导入了home和about组件，接下来我们添加了三个路由，包括一个用于将空路径重定向到home组件的路由，因此当用户访问应用程序时，他们将被重定向到主页。</p><p id="e21c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在示例的下一步，我们将在项目中设置Angular材质来设计我们的UI。</p><h1 id="71f3" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤7——用角度材质v9设计用户界面</h1><p id="31d9" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在Angular 9教程的这一步，我们将继续把Angular材质添加到我们的项目中，并设计我们的应用程序UI。</p><p id="b81f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lr" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular Material </a>提供材质设计组件，允许开发者创建专业的ui。现在，使用Angular CLI v7+的新<code class="fe li lj lk ll b">ng add</code>命令，在我们的项目中设置角度材质变得更加容易。</p><p id="c873" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到命令行界面，从项目的根目录运行以下命令:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="be95" class="nl ma it ll b gy nm nn l no np">$ ng add @angular/material</span></pre><p id="13c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你将被要求选择一个主题，选择<strong class="kd iu">靛蓝/粉色</strong>。</p><p id="ae7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于其他选项— <strong class="kd iu">设置HammerJS进行手势识别？</strong>和<strong class="kd iu">为有角度的素材设置浏览器动画？</strong>只需在键盘上按<strong class="kd iu">回车</strong>即可选择默认答案。</p><p id="c689" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，打开<code class="fe li lj lk ll b">src/styles.css</code>文件并添加一个主题:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="31b7" class="nl ma it ll b gy nm nn l no np">@import "~@angular/material/prebuilt-themes/indigo-pink.css";</span></pre><p id="e6e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个角材料组件都有一个单独的模块，您需要在使用该组件之前导入该模块。打开<code class="fe li lj lk ll b">src/app/app.module.ts</code>文件并添加以下导入:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="5e18" class="nl ma it ll b gy nm nn l no np">import { MatToolbarModule,<br/>  MatIconModule,<br/>  MatCardModule,<br/>  MatButtonModule,<br/>  MatProgressSpinnerModule } from '@angular/material';</span></pre><p id="2f41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们导入了以下模块:</p><ul class=""><li id="f64f" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae lr" href="https://material.angular.io/components/toolbar/overview" rel="noopener ugc nofollow" target="_blank"> MatToolbar </a>为标题、标题或动作提供一个容器。</li><li id="dfdc" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><a class="ae lr" href="https://material.angular.io/components/card/overview" rel="noopener ugc nofollow" target="_blank"> MatCard </a>为单个主题的上下文中的文本、照片和动作提供内容容器。</li><li id="d9c1" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><a class="ae lr" href="https://material.angular.io/components/button/overview" rel="noopener ugc nofollow" target="_blank"> MatButton </a>提供原生<code class="fe li lj lk ll b">&lt;button&gt;</code>或<code class="fe li lj lk ll b">&lt;a&gt;</code>元素，增强了材料设计风格和油墨波纹。</li><li id="610b" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><a class="ae lr" href="https://material.angular.io/components/progress-spinner/overview" rel="noopener ugc nofollow" target="_blank"> MatProgressSpinner </a>提供进度和活动的循环指示器。</li></ul><p id="c4bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，您需要将这些模块包含在<code class="fe li lj lk ll b">imports</code>数组中:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="c84c" class="nl ma it ll b gy nm nn l no np">@NgModule({<br/>  declarations: [<br/>    AppComponent,<br/>    HomeComponent,<br/>    AboutComponent<br/>  ],<br/>  imports: [<br/>    BrowserModule,<br/>    AppRoutingModule,<br/>    HttpClientModule,<br/>    BrowserAnimationsModule,<br/>    MatToolbarModule,<br/>    MatIconModule,<br/>    MatButtonModule,<br/>    MatCardModule,<br/>    MatProgressSpinnerModule<br/>  ],<br/>  providers: [],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule { }</span></pre><p id="e50a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，打开<code class="fe li lj lk ll b">src/app/app.component.html</code>文件并按如下方式更新它:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="ec8c" class="nl ma it ll b gy nm nn l no np">&lt;mat-toolbar color="primary"&gt;<br/>  &lt;h1&gt;<br/>    ngStore <br/>  &lt;/h1&gt;<br/>  &lt;button mat-button routerLink="/"&gt;Home&lt;/button&gt;<br/>  &lt;button mat-button routerLink="/about"&gt;About&lt;/button&gt;</span><span id="f7b6" class="nl ma it ll b gy nq nn l no np">&lt;/mat-toolbar&gt;</span><span id="e3a4" class="nl ma it ll b gy nq nn l no np">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span></pre><p id="6d50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建了应用程序的外壳，其中包含一个顶栏，顶栏上有两个导航按钮，分别指向home和about组件。</p><p id="c1b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总结一下我们到目前为止所做的工作——我们已经在项目中设置了HttpClient和Angular Material v9，创建了home和about组件并配置了路由，最后添加了应用程序的外壳，其中包含一个带有导航的顶栏。</p><p id="b10a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在教程的下一步，我们将学习如何使用<code class="fe li lj lk ll b">HttpClient</code> v9从REST API服务器获取JSON数据。</p><h1 id="8695" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤8——使用Angular HttpClient 9使用JSON REST API</h1><p id="ce53" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这一步中，我们将继续在示例应用程序中使用来自REST API服务器的JSON数据。</p><p id="99b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要创建一个Angular服务来封装处理来自REST API服务器的数据的代码。</p><p id="f82a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">服务是一个单体，可以由其他服务和组件使用角度依赖注入来注入。</p><blockquote class="ls lt lu"><p id="909e" class="kb kc lv kd b ke kf kg kh ki kj kk kl lw kn ko kp lx kr ks kt ly kv kw kx ky im bi translated">在软件工程中，依赖注入是一种由一个对象提供另一个对象的依赖的技术。<a class="ae lr" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="a8f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们生成一个与JSON REST API接口的Angular服务。回到您的命令行界面，运行以下命令:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="189c" class="nl ma it ll b gy nm nn l no np">$ ng generate service data</span></pre><p id="21cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，打开<code class="fe li lj lk ll b">src/app/data.service.ts</code>文件，导入并注入<code class="fe li lj lk ll b">HttpClient</code>，如下:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="0464" class="nl ma it ll b gy nm nn l no np">import { Injectable } from '@angular/core';<br/>import { HttpClient } from '@angular/common/http';</span><span id="5702" class="nl ma it ll b gy nq nn l no np">@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class DataService {</span><span id="1cb1" class="nl ma it ll b gy nq nn l no np">  private REST_API_SERVER = "<a class="ae lr" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>";</span><span id="8b63" class="nl ma it ll b gy nq nn l no np">  constructor(private httpClient: HttpClient) { }<br/>}</span></pre><p id="907b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将<code class="fe li lj lk ll b">HttpClient</code>服务作为私有<code class="fe li lj lk ll b">httpClient</code>实例导入和注入。我们还定义了保存REST API服务器地址的<code class="fe li lj lk ll b">REST_API_SERVER</code>变量。</p><p id="0311" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，添加一个向REST API端点发送GET请求以检索JSON数据的<code class="fe li lj lk ll b">sendGetRequest()</code>方法:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="8224" class="nl ma it ll b gy nm nn l no np">import { Injectable } from '@angular/core';<br/>import { HttpClient } from '@angular/common/http';</span><span id="e3a9" class="nl ma it ll b gy nq nn l no np">@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class DataService {</span><span id="d1a8" class="nl ma it ll b gy nq nn l no np">  private REST_API_SERVER = "<a class="ae lr" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>";</span><span id="454a" class="nl ma it ll b gy nq nn l no np">  constructor(private httpClient: HttpClient) { }</span><span id="1dff" class="nl ma it ll b gy nq nn l no np">  public sendGetRequest(){<br/>    return this.httpClient.get(this.REST_API_SERVER);<br/>  }<br/>}</span></pre><p id="2c73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该方法简单地调用<code class="fe li lj lk ll b">HttpClient</code>的<code class="fe li lj lk ll b">get()</code>方法向REST API服务器发送GET请求。</p><p id="38eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们现在需要在我们的home组件中使用这个服务。打开<code class="fe li lj lk ll b">src/app/home/home.component.ts</code>文件，导入并注入数据服务，如下所示:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="92ea" class="nl ma it ll b gy nm nn l no np">import { Component, OnInit } from '@angular/core';<br/>import { DataService } from '../data.service';</span><span id="06ef" class="nl ma it ll b gy nq nn l no np">@Component({<br/>  selector: 'app-home',<br/>  templateUrl: './home.component.html',<br/>  styleUrls: ['./home.component.css']<br/>})<br/>export class HomeComponent implements OnInit {</span><span id="f9ac" class="nl ma it ll b gy nq nn l no np">  products = [];</span><span id="b961" class="nl ma it ll b gy nq nn l no np">  constructor(private dataService: DataService) { }</span><span id="79de" class="nl ma it ll b gy nq nn l no np">  ngOnInit() {</span><span id="2e9f" class="nl ma it ll b gy nq nn l no np">    this.dataService.sendGetRequest().subscribe((data: any[])=&gt;{<br/>      console.log(data);<br/>      this.products = data;<br/>    })  <br/>  }</span><span id="a7ea" class="nl ma it ll b gy nq nn l no np">}</span></pre><p id="0bcc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过组件构造函数将<code class="fe li lj lk ll b">DataService</code>作为私有<code class="fe li lj lk ll b">dataService</code>实例导入并注入。</p><p id="0a56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们定义了一个<code class="fe li lj lk ll b">products</code>变量，并调用服务的<code class="fe li lj lk ll b">sendGetRequest()</code>方法从JSON REST API服务器获取数据。</p><p id="9f1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于<code class="fe li lj lk ll b">sendGetRequest()</code>方法返回了<code class="fe li lj lk ll b">HttpClient.get()</code>方法的返回值，这是一个RxJS可观察对象，我们订阅了返回的可观察对象来实际发送HTTP GET请求并处理HTTP响应。</p><p id="48e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当接收到数据时，我们将其添加到<code class="fe li lj lk ll b">products</code>数组中。</p><p id="6760" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，打开<code class="fe li lj lk ll b">src/app/home/home.component.html</code>文件并更新如下:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="7d6e" class="nl ma it ll b gy nm nn l no np">&lt;div style="padding: 13px;"&gt;<br/>    &lt;mat-spinner *ngIf="products.length === 0"&gt;&lt;/mat-spinner&gt;</span><span id="5ac4" class="nl ma it ll b gy nq nn l no np">    &lt;mat-card *ngFor="let product of products" style="margin-top:10px;"&gt;<br/>        &lt;mat-card-header&gt;<br/>            &lt;mat-card-title&gt;{{product.name}}&lt;/mat-card-title&gt;<br/>            &lt;mat-card-subtitle&gt;{{product.price}} $/ {{product.quantity}}<br/>            &lt;/mat-card-subtitle&gt;<br/>        &lt;/mat-card-header&gt;<br/>        &lt;mat-card-content&gt;<br/>            &lt;p&gt;<br/>                {{product.description}}<br/>            &lt;/p&gt;<br/>            &lt;img style="height:100%; width: 100%;" src="{{ product.imageUrl }}" /&gt;<br/>        &lt;/mat-card-content&gt;<br/>        &lt;mat-card-actions&gt;<br/>      &lt;button mat-button&gt; Buy product&lt;/button&gt;<br/>    &lt;/mat-card-actions&gt;<br/>    &lt;/mat-card&gt;<br/>&lt;/div&gt;</span></pre><p id="94f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当<code class="fe li lj lk ll b">products</code>数组的长度等于零时，即在没有从REST API服务器接收到数据之前，我们使用了<code class="fe li lj lk ll b">&lt;mat-spinner&gt;</code>组件来显示加载微调器。</p><p id="c1d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们对<code class="fe li lj lk ll b">products</code>数组进行迭代，并使用一个物料卡片来显示每个产品的<code class="fe li lj lk ll b">name</code>、<code class="fe li lj lk ll b">price</code>、<code class="fe li lj lk ll b">quantity</code>、<code class="fe li lj lk ll b">description</code>和<code class="fe li lj lk ll b">image</code>。</p><p id="e04e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是获取JSON数据后的主页截图:</p><p id="5bda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将了解如何向我们的服务添加错误处理。</p><h1 id="9215" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤9 —使用RxJS <code class="fe li lj lk ll b">catchError()</code> &amp; <code class="fe li lj lk ll b">HttpClient</code>添加HTTP错误处理</h1><p id="9b8f" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这一步中，我们将继续在示例应用程序中添加错误处理。</p><p id="de33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Angular的HttpClient方法可以很容易地与RxJS的<code class="fe li lj lk ll b">catchError()</code>操作符一起使用，因为它们通过用于捕捉和处理错误的<code class="fe li lj lk ll b">pipe()</code>方法返回可观测量。我们只需要定义一个方法来处理服务中的错误。</p><p id="45c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">前端应用程序中有两种错误:</p><ul class=""><li id="e9c2" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">客户端错误，如网络问题和JavaScript语法和类型错误。这些错误返回<code class="fe li lj lk ll b">ErrorEvent</code>对象。</li><li id="b6b2" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">服务器端错误，如服务器中的代码错误和数据库访问错误。这些错误返回HTTP错误响应。</li></ul><p id="2cc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们只需要检查错误是否是<code class="fe li lj lk ll b">ErrorEvent</code>的实例，以获取错误的类型，这样我们就可以适当地处理它。</p><p id="de29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们看看这个例子。打开<code class="fe li lj lk ll b">src/app/data.service.ts</code>文件并相应地更新它:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="5057" class="nl ma it ll b gy nm nn l no np">import { Injectable } from '@angular/core';<br/>import { HttpClient, HttpErrorResponse } from "@angular/common/http";</span><span id="0466" class="nl ma it ll b gy nq nn l no np">import {  throwError } from 'rxjs';<br/>import { retry, catchError } from 'rxjs/operators';<br/></span><span id="d585" class="nl ma it ll b gy nq nn l no np">@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class DataService {</span><span id="163a" class="nl ma it ll b gy nq nn l no np">  private REST_API_SERVER = "<a class="ae lr" href="http://localhost:3000/products" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/products</a>";</span><span id="c0dc" class="nl ma it ll b gy nq nn l no np">  constructor(private httpClient: HttpClient) { }</span><span id="90ce" class="nl ma it ll b gy nq nn l no np">  handleError(error: HttpErrorResponse) {<br/>    let errorMessage = 'Unknown error!';<br/>    if (error.error instanceof ErrorEvent) {<br/>      // Client-side errors<br/>      errorMessage = `Error: ${error.error.message}`;<br/>    } else {<br/>      // Server-side errors<br/>      errorMessage = `Error Code: ${error.status}\nMessage: ${error.message}`;<br/>    }<br/>    window.alert(errorMessage);<br/>    return throwError(errorMessage);<br/>  }</span><span id="cade" class="nl ma it ll b gy nq nn l no np">  public sendGetRequest(){<br/>    return this.httpClient.get(this.REST_API_SERVER).pipe(catchError(this.handleError));<br/>  }<br/>}</span></pre><p id="cff5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所看到的，这需要为你的应用程序中的每个服务完成，这对于我们的例子来说很好，因为它只包含一个服务，但是一旦你的应用程序开始增加许多服务，这些服务都可能抛出错误，你需要使用更好的解决方案，而不是对每个服务使用容易出错的<code class="fe li lj lk ll b">handleError</code>方法。一种解决方案是使用<a class="ae lr" href="https://angular.io/guide/http#http-interceptors" rel="noopener ugc nofollow" target="_blank"> HttpClient拦截器</a>在Angular应用程序中全局处理错误。</p><p id="8944" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是服务器不可访问时控制台上出现错误的屏幕截图:</p><p id="7806" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下一步中，我们将看到如何通过自动重试发送失败的HTTP请求来改进我们的数据服务。</p><h1 id="f0f2" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤10 —使用RxJS <code class="fe li lj lk ll b">retry()</code> &amp; <code class="fe li lj lk ll b">HttpClient</code>重试失败的HTTP请求</h1><p id="b185" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在Angular 9教程的这一步中，我们将看到如何使用RxJS的<code class="fe li lj lk ll b">retry()</code>操作符和HttpClient来自动重新订阅返回的可观察对象，这将导致重新发送失败的HTTP请求。</p><p id="8fea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在许多情况下，错误是暂时的，是由于糟糕的网络条件造成的，所以只要再试一次，错误就会自动消失。例如，在移动设备中，网络中断是频繁的，因此如果用户再次尝试，他们可能会得到成功的响应。让我们看看如何在我们的示例应用程序中自动重试，而不是让用户手动重试。</p><p id="3839" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RxJS库提供了几个重试操作符。其中一个是<code class="fe li lj lk ll b">retry()</code>操作符，它允许你自动重新订阅一个RxJS可观察值指定的次数。重新订阅从HttpClient方法返回的Observable具有将HTTP请求重新发送到服务器的效果，因此用户不需要重复操作或重新加载应用程序。</p><p id="4fbe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用RxJS <code class="fe li lj lk ll b">retry()</code>操作符，方法是在错误处理程序之前将它(使用<code class="fe li lj lk ll b">pipe()</code>方法)管道化到从HttpClient方法返回的可观察对象上。</p><p id="7da0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">转到<code class="fe li lj lk ll b">src/app/data.service.ts</code>文件并导入<code class="fe li lj lk ll b">retry()</code>操作符:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="7325" class="nl ma it ll b gy nm nn l no np">import { retry, catchError } from 'rxjs/operators';</span></pre><p id="b1b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来更新<code class="fe li lj lk ll b">sendGetRequest()</code>方法，如下所示:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="3aa7" class="nl ma it ll b gy nm nn l no np">public sendGetRequest(){<br/>    return this.httpClient.get(this.REST_API_SERVER).pipe(retry(3), catchError(this.handleError));<br/>  }</span></pre><p id="2ba7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将重试发送失败的HTTP请求三次。</p><p id="28e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步，我们将在示例home组件中看到如何取消订阅RxJS Observables。</p><h1 id="81f1" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">第11步—使用RxJS <code class="fe li lj lk ll b">takeUntil()</code>取消订阅HttpClient Observables</h1><p id="6cad" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在Angular 9教程的这一步中，我们将了解为什么我们需要以及如何使用<code class="fe li lj lk ll b">takeUntil()</code>操作符来取消订阅代码中的可观测量。</p><p id="9fe7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，您需要取消订阅由<code class="fe li lj lk ll b">HttpClient</code>方法返回的可观测量吗？</p><p id="398b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常，您需要手动取消订阅Angular组件中任何订阅的RxJS Observables，以避免内存泄漏，但是在HttpClient的情况下，这是由Angular在收到HTTP响应时通过取消订阅自动处理的。但是，在某些情况下，您需要手动取消订阅，例如，当用户即将离开组件时，取消待定的请求。</p><p id="aacc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以简单地从组件的<code class="fe li lj lk ll b">ngOnDestroy()</code>生命周期方法中的<code class="fe li lj lk ll b">subscribe()</code>方法返回的<code class="fe li lj lk ll b">Subscription</code>对象中调用<code class="fe li lj lk ll b">unsubscribe()</code>方法来取消订阅可观察对象。</p><p id="bfc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe li lj lk ll b">takeUntil()</code>操作符还有一个更好的方法来取消订阅或完成Observables。</p><p id="d208" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lr" href="https://rxjs.dev/api/operators/takeUntil" rel="noopener ugc nofollow" target="_blank"> takeUntil() </a>操作符发出由源可观察对象发出的值，直到通知者可观察对象发出一个值。</p><p id="943b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看当组件被销毁时，如何使用这个操作符来完成可观测量。</p><p id="387a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查看<a class="ae lr" href="https://stackoverflow.com/questions/46068908/how-to-cancel-unsubscribe-all-pending-http-requests-angular-4" rel="noopener ugc nofollow" target="_blank">如何取消/取消订阅所有待定HTTP请求angular 4+ </a>。</p><p id="6360" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开<code class="fe li lj lk ll b">src/app/home/home.component.ts</code>文件，并按如下方式更新:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="f9f2" class="nl ma it ll b gy nm nn l no np">import { Component, OnInit, OnDestroy } from '@angular/core';<br/>import { DataService } from '../data.service';<br/>import {  takeUntil } from 'rxjs/operators';<br/>import { Subject } from 'rxjs';</span><span id="3700" class="nl ma it ll b gy nq nn l no np">@Component({<br/>  selector: 'app-home',<br/>  templateUrl: './home.component.html',<br/>  styleUrls: ['./home.component.css']<br/>})<br/>export class HomeComponent implements OnInit, OnDestroy {</span><span id="19f6" class="nl ma it ll b gy nq nn l no np">  products = [];<br/>  destroy$: Subject&lt;boolean&gt; = new Subject&lt;boolean&gt;();</span><span id="7bc8" class="nl ma it ll b gy nq nn l no np">  constructor(private dataService: DataService) { }</span><span id="68ec" class="nl ma it ll b gy nq nn l no np">  ngOnInit() {</span><span id="01eb" class="nl ma it ll b gy nq nn l no np">    this.dataService.sendGetRequest().pipe(takeUntil(this.destroy$)).subscribe((data: any[])=&gt;{<br/>      console.log(data);<br/>      this.products = data;<br/>    })  <br/>  }<br/>  ngOnDestroy() {<br/>    this.destroy$.next(true);<br/>    // Unsubscribe from the subject<br/>    this.destroy$.unsubscribe();<br/>  }</span><span id="3c72" class="nl ma it ll b gy nq nn l no np">}</span></pre><p id="ca3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先导入了<code class="fe li lj lk ll b">OnDestroy</code>接口、<code class="fe li lj lk ll b">Subject</code>和<code class="fe li lj lk ll b">takeUntil()</code>操作符。接下来，我们实现了<code class="fe li lj lk ll b">OnDestroy</code>接口，并向组件添加了<code class="fe li lj lk ll b">ngOnDestroy()</code>生命周期挂钩。</p><p id="99d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建了一个<code class="fe li lj lk ll b">Subject</code>的实例，它可以发出布尔值(在这个例子中，值的类型并不重要)，这些值将被用作<code class="fe li lj lk ll b">takeUntil()</code>操作符的通知符。</p><p id="7f56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，在<code class="fe li lj lk ll b">ngOnInit()</code>生命周期挂钩中，我们调用了数据服务的<code class="fe li lj lk ll b">sendGetRequest()</code>并调用了返回的可观察对象的<code class="fe li lj lk ll b">pipe()</code>方法来传输<code class="fe li lj lk ll b">takeUnitl()</code>操作符，并最终订阅了组合的可观察对象。在<code class="fe li lj lk ll b">subscribe()</code>方法的主体中，我们添加了将获取的HTTP响应数据放入<code class="fe li lj lk ll b">products</code>数组的逻辑。</p><p id="053e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe li lj lk ll b">takeUntil()</code>操作符允许被通知的可观察对象发出值，直到一个值从通知者可观察对象发出。</p><p id="63fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当Angular销毁一个组件时，它调用<code class="fe li lj lk ll b">ngOnDestroy()</code>生命周期方法，在我们的例子中，它调用<code class="fe li lj lk ll b">next()</code>方法来发出一个值，这样RxJS就完成了所有订阅的可观测量。</p><p id="f91d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样。在这一步中，我们添加了取消任何未决HTTP请求的逻辑，方法是取消订阅返回的Observable，以防用户在收到HTTP响应之前决定离开组件。</p><p id="c22c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们Angular 9教程的下一步，我们将看到如何通过<code class="fe li lj lk ll b">HttpClient</code>的<code class="fe li lj lk ll b">get()</code>方法使用URL查询参数。</p><h1 id="93f3" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤12 —向HttpClient get()方法添加URL查询参数</h1><p id="d5c2" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这一步中，我们将开始在示例应用程序中添加实现分页的逻辑。我们将看到如何通过<code class="fe li lj lk ll b"><a class="ae lr" href="https://angular.io/guide/http#use-fromstring-to-create-httpparams" rel="noopener ugc nofollow" target="_blank">fromString</a></code> <a class="ae lr" href="https://angular.io/guide/http#use-fromstring-to-create-httpparams" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe li lj lk ll b"><a class="ae lr" href="https://angular.io/guide/http#use-fromstring-to-create-httpparams" rel="noopener ugc nofollow" target="_blank">HttpParams</a></code>使用URL查询参数，为JSON REST API服务器的<code class="fe li lj lk ll b">/products</code>端点的<code class="fe li lj lk ll b">_page</code>和<code class="fe li lj lk ll b">_limit</code>参数提供适当的值，以获取分页数据。</p><p id="ee83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开<code class="fe li lj lk ll b">src/app/data.service.ts</code>文件，开始为<code class="fe li lj lk ll b">HttpParams</code>添加以下导入:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="c633" class="nl ma it ll b gy nm nn l no np">import { HttpClient, HttpErrorResponse, HttpParams } from "@angular/common/http";</span></pre><p id="56b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，更新<code class="fe li lj lk ll b">sendGetRequest()</code>方法，如下所示:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="ab35" class="nl ma it ll b gy nm nn l no np">public sendGetRequest(){<br/>    // Add safe, URL encoded_page parameter <br/>    const options = { params: new HttpParams({fromString: "_page=1&amp;_limit=20"}) };<br/>    return this.httpClient.get(this.REST_API_SERVER, options).pipe(retry(3), catchError(this.handleError));<br/>  }</span></pre><p id="7680" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<code class="fe li lj lk ll b">HttpParams</code>和<code class="fe li lj lk ll b">fromString</code>从<code class="fe li lj lk ll b">_page=1&amp;_limit=20</code>字符串创建HTTP查询参数。这告诉to返回20个产品的第一页。</p><p id="4e0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在将使用<code class="fe li lj lk ll b">sendGetRequest()</code>来检索第一页数据。收到的HTTP响应将包含一个链接头，其中包含有关数据页面的第一个、上一个、下一个和最后一个链接的信息。</p><p id="6489" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在链接头你会得到第一个，上一个，下一个和最后一个链接。在下一步中，我们将看到如何通过解析完整的HTTP响应来提取这些分页链接。</p><h1 id="8288" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤13 —用Angular HttpClient 9获得完整的HTTP响应</h1><p id="e910" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这个步骤中，我们将实现从JSON REST API服务器接收的HTTP响应中包含的链接头中检索分页信息的逻辑。</p><p id="6181" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，HttpClient只提供响应体，但是在我们的例子中，我们需要解析分页链接的链接头，所以我们需要使用<code class="fe li lj lk ll b">observe</code>选项告诉<code class="fe li lj lk ll b">HttpClient</code>我们想要完整的<code class="fe li lj lk ll b"><a class="ae lr" href="https://angular.io/api/common/http/HttpResponse" rel="noopener ugc nofollow" target="_blank">HttpResponse</a></code>。</p><blockquote class="ls lt lu"><p id="9638" class="kb kc lv kd b ke kf kg kh ki kj kk kl lw kn ko kp lx kr ks kt ly kv kw kx ky im bi translated">HTTP中的链接头允许服务器将感兴趣的客户机指向另一个资源，该资源包含关于所请求资源的元数据。<a class="ae lr" href="https://www.w3.org/wiki/LinkHeader" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="e7dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">转到src/app/data.service.ts文件，导入RxJS <code class="fe li lj lk ll b">tap()</code>操作符:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="0385" class="nl ma it ll b gy nm nn l no np">import { retry, catchError, tap } from 'rxjs/operators';</span></pre><p id="41bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，定义以下字符串变量:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="495c" class="nl ma it ll b gy nm nn l no np">public first: string = "";<br/>  public prev: string = "";<br/>  public next: string = "";<br/>  public last: string = "";</span></pre><p id="199a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，定义解析链接头的<code class="fe li lj lk ll b">parseLinkHeader()</code>方法，并相应地填充前面的变量:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="9a94" class="nl ma it ll b gy nm nn l no np">parseLinkHeader(header) {<br/>    if (header.length == 0) {<br/>      return ;<br/>    }</span><span id="ad44" class="nl ma it ll b gy nq nn l no np">    let parts = header.split(',');<br/>    var links = {};<br/>    parts.forEach( p =&gt; {<br/>      let section = p.split(';');<br/>      var url = section[0].replace(/&lt;(.*)&gt;/, '$1').trim();<br/>      var name = section[1].replace(/rel="(.*)"/, '$1').trim();<br/>      links[name] = url;</span><span id="e6cc" class="nl ma it ll b gy nq nn l no np">    });</span><span id="e3c7" class="nl ma it ll b gy nq nn l no np">    this.first  = links["first"];<br/>    this.last   = links["last"];<br/>    this.prev   = links["prev"];<br/>    this.next   = links["next"]; <br/>  }</span></pre><p id="0a10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，更新<code class="fe li lj lk ll b">sendGetRequest()</code>如下:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="26c4" class="nl ma it ll b gy nm nn l no np">public sendGetRequest(){<br/>    // Add safe, URL encoded _page and _limit parameters </span><span id="6d99" class="nl ma it ll b gy nq nn l no np">    return this.httpClient.get(this.REST_API_SERVER, {  params: new HttpParams({fromString: "_page=1&amp;_limit=20"}), observe: "response"}).pipe(retry(3), catchError(this.handleError), tap(res =&gt; {<br/>      console.log(res.headers.get('Link'));<br/>      this.parseLinkHeader(res.headers.get('Link'));<br/>    }));<br/>  }</span></pre><p id="6862" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在<code class="fe li lj lk ll b">get()</code>方法的options参数中添加了带有<code class="fe li lj lk ll b">response</code>值的<code class="fe li lj lk ll b">observe</code>选项，这样我们就可以得到带有报头的完整HTTP响应。接下来，我们使用RxJS <code class="fe li lj lk ll b">tap()</code>操作符解析链接头，然后返回最终的可观察值。</p><p id="cf54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于<code class="fe li lj lk ll b">sendGetRequest()</code>现在返回一个带有完整HTTP响应的可观察对象，我们需要更新home组件，因此打开<code class="fe li lj lk ll b">src/app/home/home.component.ts</code>文件并导入<code class="fe li lj lk ll b">HttpResponse</code>,如下所示:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="0bd9" class="nl ma it ll b gy nm nn l no np">import { HttpResponse } from '@angular/common/http';</span></pre><p id="c6b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，更新<code class="fe li lj lk ll b">subscribe()</code>方法，如下所示:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="0a42" class="nl ma it ll b gy nm nn l no np">ngOnInit() {</span><span id="3f1a" class="nl ma it ll b gy nq nn l no np">    this.dataService.sendGetRequest().pipe(takeUntil(this.destroy$)).subscribe((res: HttpResponse&lt;any&gt;)=&gt;{<br/>      console.log(res);<br/>      this.products = res.body;<br/>    })  <br/>  }</span></pre><p id="dd33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以从接收到的HTTP响应的<code class="fe li lj lk ll b">body</code>对象中访问数据。</p><p id="6b45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，返回src/app/data.service.ts文件并添加以下方法:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="1c19" class="nl ma it ll b gy nm nn l no np">public sendGetRequestToUrl(url: string){<br/>    return this.httpClient.get(url, { observe: "response"}).pipe(retry(3), catchError(this.handleError), tap(res =&gt; {<br/>      console.log(res.headers.get('Link'));<br/>      this.parseLinkHeader(res.headers.get('Link'));</span><span id="c952" class="nl ma it ll b gy nq nn l no np">    }));<br/>  }</span></pre><p id="5014" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个方法类似于<code class="fe li lj lk ll b">sendGetRequest()</code>，除了它接受我们需要发送HTTP GET请求的URL。</p><p id="a63f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回到<code class="fe li lj lk ll b">src/app/home/home.component.ts</code>文件并添加定义以下方法:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="07fd" class="nl ma it ll b gy nm nn l no np">public firstPage() {<br/>    this.products = [];<br/>    this.dataService.sendGetRequestToUrl(this.dataService.first).pipe(takeUntil(this.destroy$)).subscribe((res: HttpResponse&lt;any&gt;) =&gt; {<br/>      console.log(res);<br/>      this.products = res.body;<br/>    })<br/>  }<br/>  public previousPage() {</span><span id="d7ac" class="nl ma it ll b gy nq nn l no np">    if (this.dataService.prev !== undefined &amp;&amp; this.dataService.prev !== '') {<br/>      this.products = [];<br/>      this.dataService.sendGetRequestToUrl(this.dataService.prev).pipe(takeUntil(this.destroy$)).subscribe((res: HttpResponse&lt;any&gt;) =&gt; {<br/>        console.log(res);<br/>        this.products = res.body;<br/>      })<br/>    }</span><span id="cb11" class="nl ma it ll b gy nq nn l no np">  }<br/>  public nextPage() {<br/>    if (this.dataService.next !== undefined &amp;&amp; this.dataService.next !== '') {<br/>      this.products = [];<br/>      this.dataService.sendGetRequestToUrl(this.dataService.next).pipe(takeUntil(this.destroy$)).subscribe((res: HttpResponse&lt;any&gt;) =&gt; {<br/>        console.log(res);<br/>        this.products = res.body;<br/>      })<br/>    }<br/>  }<br/>  public lastPage() {<br/>    this.products = [];<br/>    this.dataService.sendGetRequestToUrl(this.dataService.last).pipe(takeUntil(this.destroy$)).subscribe((res: HttpResponse&lt;any&gt;) =&gt; {<br/>      console.log(res);<br/>      this.products = res.body;<br/>    })<br/>  }</span></pre><p id="b6d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，添加打开<code class="fe li lj lk ll b">src/app/home/home.component.html</code>文件并更新模板，如下所示:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="d221" class="nl ma it ll b gy nm nn l no np">&lt;div style="padding: 13px;"&gt;<br/>    &lt;mat-spinner *ngIf="products.length === 0"&gt;&lt;/mat-spinner&gt;</span><span id="c2e5" class="nl ma it ll b gy nq nn l no np">    &lt;mat-card *ngFor="let product of products" style="margin-top:10px;"&gt;<br/>        &lt;mat-card-header&gt;<br/>            &lt;mat-card-title&gt;#{{product.id}} {{product.name}}&lt;/mat-card-title&gt;<br/>            &lt;mat-card-subtitle&gt;{{product.price}} $/ {{product.quantity}}<br/>            &lt;/mat-card-subtitle&gt;<br/>        &lt;/mat-card-header&gt;<br/>        &lt;mat-card-content&gt;<br/>            &lt;p&gt;<br/>                {{product.description}}<br/>            &lt;/p&gt;<br/>            &lt;img style="height:100%; width: 100%;" src="{{ product.imageUrl }}" /&gt;<br/>        &lt;/mat-card-content&gt;<br/>        &lt;mat-card-actions&gt;<br/>      &lt;button mat-button&gt; Buy product&lt;/button&gt;<br/>    &lt;/mat-card-actions&gt;<br/>    &lt;/mat-card&gt;</span><span id="dbdc" class="nl ma it ll b gy nq nn l no np">&lt;/div&gt;<br/>&lt;div&gt;<br/>    &lt;button (click) ="firstPage()" mat-button&gt; First&lt;/button&gt;<br/>    &lt;button (click) ="previousPage()" mat-button&gt; Previous&lt;/button&gt;<br/>    &lt;button (click) ="nextPage()" mat-button&gt; Next&lt;/button&gt;<br/>    &lt;button (click) ="lastPage()" mat-button&gt; Last&lt;/button&gt;<br/>&lt;/div&gt;</span></pre><p id="de77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们应用程序的屏幕截图:</p><h1 id="f68f" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤14 —用Angular HttpClient 9请求类型化的HTTP响应</h1><p id="74c8" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这一步中，我们将看到如何在我们的示例应用程序中使用类型化的HTTP响应。</p><p id="c432" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Angular HttpClient允许您在请求对象中指定响应对象的类型，这使得使用响应更加容易和直接。这也支持编译时的类型断言。</p><p id="047f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从使用具有所需属性的TypeScript接口定义一个自定义类型开始。</p><p id="7a75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到命令行界面，从项目的根目录运行以下命令:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="6283" class="nl ma it ll b gy nm nn l no np">$ ng generate interface  product</span></pre><p id="0a25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，打开<code class="fe li lj lk ll b">src/app/product.ts</code>文件，更新如下:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="8736" class="nl ma it ll b gy nm nn l no np">export interface Product {<br/>    id: number;<br/>    name: string;<br/>    description: string;<br/>    price: number;<br/>    quantity: number;<br/>    imageUrl: string;<br/>}</span></pre><p id="fb17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，将<code class="fe li lj lk ll b">Product</code>接口指定为数据服务中<code class="fe li lj lk ll b">HttpClient.get()</code>调用的类型参数。回到<code class="fe li lj lk ll b">src/app/data.service.ts</code>文件，导入<code class="fe li lj lk ll b">Product</code>接口:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="9c0a" class="nl ma it ll b gy nm nn l no np">import { Product } from './product';</span></pre><p id="0bee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="5de3" class="nl ma it ll b gy nm nn l no np">public sendGetRequest(){</span><span id="a08c" class="nl ma it ll b gy nq nn l no np">    return this.httpClient.get&lt;Product[]&gt;(this.REST_API_SERVER, {  params: new HttpParams({fromString: "_page=1&amp;_limit=20"}), observe: "response"}).pipe(retry(3), catchError(this.handleError), tap(res =&gt; {<br/>      console.log(res.headers.get('Link'));<br/>      this.parseLinkHeader(res.headers.get('Link'));</span><span id="63ee" class="nl ma it ll b gy nq nn l no np">    }));<br/>  }</span><span id="7942" class="nl ma it ll b gy nq nn l no np">  public sendGetRequestToUrl(url: string){<br/>    return this.httpClient.get&lt;Product[]&gt;(url, { observe: "response"}).pipe(retry(3), catchError(this.handleError), tap(res =&gt; {<br/>      console.log(res.headers.get('Link'));<br/>      this.parseLinkHeader(res.headers.get('Link'));</span><span id="fd24" class="nl ma it ll b gy nq nn l no np">    }));<br/>  }</span></pre><p id="85a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，打开<code class="fe li lj lk ll b">src/app/home/home.component.ts</code>文件，导入<code class="fe li lj lk ll b">Product</code>接口:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="a303" class="nl ma it ll b gy nm nn l no np">import { Product } from '../product';</span></pre><p id="91d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，按如下方式更改<code class="fe li lj lk ll b">products</code>数组的类型:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="3449" class="nl ma it ll b gy nm nn l no np">export class HomeComponent implements OnInit, OnDestroy {</span><span id="2dbf" class="nl ma it ll b gy nq nn l no np">  products: Product[] = [];</span></pre><p id="592b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来更改<code class="fe li lj lk ll b">sendGetRequest()</code>调用中HTTP响应的类型:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="ed93" class="nl ma it ll b gy nm nn l no np">ngOnInit() {</span><span id="ee19" class="nl ma it ll b gy nq nn l no np">    this.dataService.sendGetRequest().pipe(takeUntil(this.destroy$)).subscribe((res: HttpResponse&lt;Product[]&gt;) =&gt; {<br/>      console.log(res);<br/>      this.products = res.body;<br/>    })<br/>  }</span></pre><p id="e69c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还需要对其他<code class="fe li lj lk ll b">firstPage()</code>、<code class="fe li lj lk ll b">previousPage()</code>、<code class="fe li lj lk ll b">nextPage()</code>和<code class="fe li lj lk ll b">lastPage()</code>方法进行同样的操作。</p><h1 id="423f" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤15——构建Angular 9应用程序并将其部署到Firebase主机</h1><p id="5ca2" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这一步中，我们将了解如何使用Angular 8.3+中可用的ng deploy命令构建示例应用程序并将其部署到Firebase主机。</p><p id="5111" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将只看到如何在没有假JSON服务器的情况下部署前端应用程序。</p><p id="383b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Angular CLI 8.3+引入了一个新的<code class="fe li lj lk ll b">ng deploy</code>命令，使得使用与您的项目相关联的部署CLI构建器来部署您的Angular应用程序比以前更加容易。有许多第三方构建者为不同的平台实现部署功能。您可以通过运行<code class="fe li lj lk ll b">ng add</code>命令将它们添加到您的项目中。</p><p id="ecad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加一个部署包后，它将自动更新您的工作空间配置(即<code class="fe li lj lk ll b">angular.json</code>文件),为所选项目添加一个部署部分。然后您可以使用<code class="fe li lj lk ll b">ng deploy</code>命令来部署这个项目。</p><p id="c565" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们通过将我们的项目部署到Firebase hosting来看看这个例子。</p><p id="b495" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到您的命令行界面，确保您位于Angular项目的根文件夹中，并运行以下命令:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="55d5" class="nl ma it ll b gy nm nn l no np">$ ng add @angular/fire</span></pre><p id="9011" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将为您的项目添加Firebase部署功能。</p><p id="0c99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该命令还将通过添加以下部分来更新我们项目的<code class="fe li lj lk ll b">package.json</code>:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="72b3" class="nl ma it ll b gy nm nn l no np">"deploy": {<br/>          "builder": "@angular/fire:deploy",<br/>          "options": {}<br/>        }</span></pre><p id="acc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CLI将提示您<strong class="kd iu">在此粘贴授权代码:</strong>并将打开您的默认web浏览器，要求您授予Firebase CLI权限以管理您的Firebase帐户:</p><p id="e0c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在您使用与您的Firebase帐户关联的Google帐户登录后，您将获得授权代码:</p><p id="ce91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来会提示:<strong class="kd iu">请选择一个项目:(使用箭头键或键入进行搜索)</strong>。您之前应该已经创建了一个Firebase项目。</p><p id="3ce0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CLI将创建<code class="fe li lj lk ll b">firebase.json</code>和<code class="fe li lj lk ll b">.firebaserc</code>文件并相应地更新<code class="fe li lj lk ll b">angular.json</code>文件。</p><p id="a7b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，使用以下命令将您的应用程序部署到Firebase:</p><pre class="nd ne nf ng gt nh ll ni nj aw nk bi"><span id="404f" class="nl ma it ll b gy nm nn l no np">$ ng deploy</span></pre><p id="fdfe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该命令将生成应用程序的优化版本(相当于<code class="fe li lj lk ll b">ng deploy --prod</code>命令)，它将生产资产上传到Firebase主机。</p><h1 id="40c0" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">结论</h1><p id="fe5e" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在这篇Angular 9教程中，我们使用最新版本构建了一个完整的Angular应用程序示例。</p><p id="0251" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为一个总结，我们已经通过示例特别了解了如何使用<code class="fe li lj lk ll b">HttpClient.get()</code>方法设置<code class="fe li lj lk ll b">HttpClient</code>并发送带有参数的HTTP GET请求，如何使用RxJS <code class="fe li lj lk ll b">throwError()</code>和<code class="fe li lj lk ll b">catchError()</code>操作符处理HTTP错误，使用<code class="fe li lj lk ll b">takeUntil()</code>操作符取消订阅RxJS观察到的已取消的HTTP请求，并使用<code class="fe li lj lk ll b">retry()</code>操作符重试失败的请求，以及最后如何使用Angular 8.3+中最新的<code class="fe li lj lk ll b">ng deploy</code>特性将我们的应用程序部署到Firebase主机。</p><h1 id="8577" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">关于作者</h1><p id="13a3" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated"><a class="ae lr" href="https://www.techiediaries.com/author/ahmed/" rel="noopener ugc nofollow" target="_blank"> Ahmed Bouchefra </a>是一名拥有5年以上经验的web开发人员和技术作者，拥有软件开发工程学位。你可以点击上面的链接雇佣他，或者通过他的<a class="ae lr" href="https://www.linkedin.com/in/mr-ahmed/" rel="noopener ugc nofollow" target="_blank"> LinkedIn账户</a>联系他。他为行业领先的网站撰写技术内容，如SitePoint、Smashing、DigitalOcean、RealPython、freeCodeCamp、JScrambler、Pusher和Auth0。他还合著了多本关于现代网络开发的书籍，你可以从<a class="ae lr" href="https://www.amazon.com/Ahmed-Bouchefra/e/B07J1XYKT4?ref=dbs_a_def_rwt_hsch_vu00_taft_p1_i0" rel="noopener ugc nofollow" target="_blank">亚马逊</a>或<a class="ae lr" href="https://leanpub.com/u/ahmedbouchefra" rel="noopener ugc nofollow" target="_blank"> Leanpub </a>找到</p><ul class=""><li id="40e8" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae lr" href="https://www.ahmedbouchefra.com/" rel="noopener ugc nofollow" target="_blank">网站</a></li><li id="c957" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><a class="ae lr" href="https://twitter.com/ahmedbouchefra" rel="noopener ugc nofollow" target="_blank">推特</a></li><li id="f89e" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><a class="ae lr" href="https://www.linkedin.com/in/mr-ahmed/" rel="noopener ugc nofollow" target="_blank">领英</a></li><li id="2574" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><a class="ae lr" href="https://github.com/techiediaries" rel="noopener ugc nofollow" target="_blank"> GitHub </a></li></ul><p id="fce2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lv">原载于2019年12月5日</em><a class="ae lr" href="https://www.techiediaries.com/angular-tutorial" rel="noopener ugc nofollow" target="_blank"><em class="lv">https://www.techiediaries.com</em></a>T22。</p></div></div>    
</body>
</html>