<html>
<head>
<title>Modern C++ in Advent of Code: Day4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++代码的出现:第4天</h1>
<blockquote>原文：<a href="https://itnext.io/modern-c-in-advent-of-code-day4-14bee3fd1609?source=collection_archive---------2-----------------------#2021-12-04">https://itnext.io/modern-c-in-advent-of-code-day4-14bee3fd1609?source=collection_archive---------2-----------------------#2021-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是代码问世的第四天。今天，我们将设计一些漂亮的数据结构。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/6bc5fbdbb2a7ff8db4bc4f2d665d8f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcd32avzLfEYUb-GismcfA.png"/></div></div></figure><p id="bd31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，请先尝试解决问题，然后再看解决方案。对于这个系列的所有文章，<a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">看看这个列表</a>。</p><h1 id="493e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第四天:第一部分和第二部分</h1><p id="a680" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">是的，今天会有点短，只是因为第一部分的解和第二部分几乎一样。</p><p id="8d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我们玩宾果游戏，目标是选出首先获胜的宾果棋盘(最后是第二部分)。我们在输入的第一行得到一个抽签数字的列表，然后是一个宾果板序列。每个棋盘由一个5x5的数字网格组成。例如:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="6451" class="mg kz iq mc b gy mh mi l mj mk">1, 2, 3, 4, 5</span><span id="3c4f" class="mg kz iq mc b gy ml mi l mj mk"> 1  2  3  4  5<br/> 6  7  8  9 10<br/>11 12 13 14 15<br/>16 17 18 19 20<br/>21 22 23 24 25</span></pre><p id="0f8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">五个数字被抽出后，该棋盘立即获胜(第一行将被填充)。</p><p id="e9cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在阅读了描述之后，您的第一反应可能是将板保存在内存中，并在每次抽取后检查受影响的行或列是否被填充。然而，我们可以通过聪明地设计我们的数据结构来简化这一切。</p><p id="85b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">填充一行或一列意味着什么？每行和每列都有五个数字。如果我们填充一个，未填充的数字的计数将正好减少一。当我们到达零时，我们知道该行/列被填充。所以我们需要跟踪的是每行和每列的空缺职位的数量。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="24ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个计数是不够的，因为我们还需要知道在绘制数字时要更新哪些列和行。我们需要一张从一个数字到它的位置的地图。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="cef7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们必须跟踪未标记数字的总和，因为我们的目标是返回棋盘上未标记数字的总和乘以最后抽取的数字。所有这些加在一起就是我们的国家。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b1d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设计好数据结构后，我们现在需要实现解决方案的两个阶段。首先，读取输入并将其存储在我们的数据结构中，其次，处理平局并检测获胜状态。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6a64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于测试，我们使用一个简单的例子，只有一块板和来自AoC的测试输入。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ff77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何解析输入并将数据存储在状态数据结构中:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a08f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们期望一系列的网格，每个网格由25个数字组成。我们在输入结束时停止读取(第7行)。然而，我们在读取时可能会遇到错误，所以我们想在这种情况下抛出一个异常(第8–9行)。</p><p id="4329" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们读取了一个数字，我们需要存储它在数字到行和列的映射中的位置。注意，<code class="fe mo mp mq mc b">insert</code>只会在键(数字)不存在的情况下修改映射，并返回一个迭代器到现有的或刚刚插入的元素。</p><p id="8967" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们每块板子有五行五列，我们一行一行的读数字。因此行位置是<code class="fe mo mp mq mc b">board_id*(5+5) + i/5</code>，列位置是<code class="fe mo mp mq mc b">board_id*(5+5) + i%5</code>。在读取整个棋盘之后，我们初始化每行和每列的未标记项目的计数(第19行)以及每个棋盘上的初始和(我们存储sum*2，原因将在下一节解释)。</p><p id="b7e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着输入解析的完成和数据结构的构建，我们可以计算出哪个棋盘会先赢。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="297e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们减少棋盘的总数，因为我们标记了这个数字(第9行)。这也是<code class="fe mo mp mq mc b">sum*2</code>发挥作用的地方。请记住，我们已经记录了这个数字的列和行位置。因此，我们将有效地减少总和两次(一次用于列，一次用于行)。</p><p id="fbcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调整总和后，我们减少给定列或行(第13行)中未标记数字的数量，如果我们达到零，我们就知道这个棋盘刚刚赢了。因为我们只是处理收到的抽签数字，所以我们知道这是第一个获胜的棋盘。</p><p id="f0b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将此调整到今天问题的第二部分很简单:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e41f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们跟踪哪些棋盘赢了(通过使用一个<code class="fe mo mp mq mc b">unordered_set</code>来避免重复检测)，并且只有在赢了的棋盘的数量等于棋盘的总数时才返回(第17行)。否则，代码与第1部分的解决方案相同。</p><p id="e257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后要讨论的是主函数(这是针对第2部分的):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="5b0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先读取输入的第一行，其中包含抽取的数字，然后使用已经呈现的<code class="fe mo mp mq mc b">operator&gt;&gt;</code>重载解析棋盘。</p><p id="6f8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天的快速解决方案到此结束。我认为，这很好地展示了良好的数据结构设计的重要性。</p><h1 id="a439" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">链接和技术说明</h1><p id="659c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">每日解决方案存储库位于:<a class="ae kl" href="https://github.com/HappyCerberus/moderncpp-aoc-2021" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/moderncpp-aoc-2021</a>。</p><p id="6dd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">看看这个列表，里面有关于《代号</a>出现的其他日子的文章。</p><p id="6974" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请不要忘记亲自尝试<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">降临码</a>。</p><h1 id="5b75" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="390f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="1ea2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在<a class="ae kl" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae kl" href="https://www.linkedin.com/in/simontoth" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>