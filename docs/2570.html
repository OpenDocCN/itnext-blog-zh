<html>
<head>
<title>Painless JSON with Kotlin and jackson</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林和杰克逊的无痛JSON</h1>
<blockquote>原文：<a href="https://itnext.io/painless-json-with-kotlin-and-jackson-fc6d66fbf94a?source=collection_archive---------5-----------------------#2019-06-16">https://itnext.io/painless-json-with-kotlin-and-jackson-fc6d66fbf94a?source=collection_archive---------5-----------------------#2019-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="582b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">似乎许多提供REST API的后端最终被美化成代理，将JSON从一个地方转移到另一个地方。如果你想让这些后端尽可能简单，这一点尤其正确(<a class="ae kl" href="https://microservices.io/patterns/microservices.html" rel="noopener ugc nofollow" target="_blank">微服务</a>有人知道吗？).因此，拥有好的工具来解析和生成JSON可以对保持代码整洁和紧凑产生很大的影响。我想说说我用<a class="ae kl" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">科特林</a>和<a class="ae kl" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank">杰克逊</a>做这个的经历。</p><p id="75b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我记得在过去，用Java处理JSON非常痛苦，因为必须编写大量代码来映射对象。事实上，这也是我最初使用Ruby的原因。事情发生了很大的变化(向好的方面！)从此。如今使用<em class="km"> Kotlin </em>和<em class="km"> Jackson </em>你可以用最少的努力来处理JSON。<em class="km">杰克逊</em>是一个非常强大的图书馆，但是你很容易迷路。如果用它来解析一堆具有不同需求的类的例子，加上一些代码来把它集成到你的工作流中。在这种情况下，我将使用<a class="ae kl" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank">跳靴</a>。</p><h1 id="e4ed" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">序列化/反序列化</h1><p id="a88a" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们将使用<a class="ae kl" href="https://kotlinlang.org/docs/reference/data-classes.html" rel="noopener ugc nofollow" target="_blank">数据类</a>来表示将从JSON转换成的实体。它们相当于使用<em class="km"> Lombok </em>中的<a class="ae kl" href="https://projectlombok.org/features/Value" rel="noopener ugc nofollow" target="_blank"> @Value </a>注释，并具有该语言的一流支持。它们是不可改变的(耶！)，并且有开箱即用的<code class="fe lq lr ls lt b">equals</code>和<code class="fe lq lr ls lt b">toString</code>之类的便利方法。</p><p id="b59e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用一个<a class="ae kl" href="https://fasterxml.github.io/jackson-databind/javadoc/2.7/com/fasterxml/jackson/databind/ObjectMapper.html" rel="noopener ugc nofollow" target="_blank">对象映射器</a>来进行解析，尽管这可以在<em class="km"> SpringBoot </em>中配置为大部分自动完成，我将在后面展示。我有一个<code class="fe lq lr ls lt b">User</code>实体，它有两个字段，我想把它们转换成JSON，然后再转换回来。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="4d7f" class="mc ko iq lt b gy md me l mf mg">data class User(val id: String, val age: Int) </span><span id="c540" class="mc ko iq lt b gy mh me l mf mg">fun User.toJson(): String = ObjectMapper().writeValueAsString(this) fun String.toUser(): User = ObjectMapper().readValue(this)</span></pre><p id="9785" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于简单的情况，只要定义数据类就足够了，只要你有<a class="ae kl" href="https://github.com/FasterXML/jackson-module-kotlin" rel="noopener ugc nofollow" target="_blank">右模块</a>。不过，您可以在此基础上做一些额外的配置。其中许多可以用注释来控制，注释可以使代码更加紧凑。它们也可以让你的代码变得不可维护，所以不要滥用它们。</p><h2 id="047b" class="mc ko iq bd kp mi mj dn kt mk ml dp kx jy mm mn lb kc mo mp lf kg mq mr lj ms bi translated">可空性</h2><p id="80b8" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">如果有些字段是可选的，您可以提供默认值以防它们不存在</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="c7bf" class="mc ko iq lt b gy md me l mf mg">data class User(val id: String = "")</span></pre><p id="8417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者允许它们成为<code class="fe lq lr ls lt b">null</code></p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="4713" class="mc ko iq lt b gy md me l mf mg">data class User(val id: String?)</span></pre><p id="52f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不做任何事情会导致解析失败，并出现一个异常，实际上我发现这是一件好事。</p><h2 id="a216" class="mc ko iq bd kp mi mj dn kt mk ml dp kx jy mm mn lb kc mo mp lf kg mq mr lj ms bi translated">错认假频伪信号</h2><p id="28bf" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">如果您从使用不同属性名称的不同来源解析您的对象，但是仍然希望保持一个<em class="km">规范的</em>表示，<code class="fe lq lr ls lt b">@JsonAlias</code>是您的朋友。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="9837" class="mc ko iq lt b gy md me l mf mg">data class User(   <br/>  @JsonAlias("userId")   <br/>  val id: String <br/>)</span></pre><p id="e72a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将正确地解析如下内容</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="c432" class="mc ko iq lt b gy md me l mf mg">{   <br/>  "userId": "123" <br/>}</span></pre><h2 id="335e" class="mc ko iq bd kp mi mj dn kt mk ml dp kx jy mm mn lb kc mo mp lf kg mq mr lj ms bi translated">忽略属性</h2><p id="cead" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">也许您正在解析一个包含大量您不需要的字段的对象。如果你不打算在你的代码中使用它，你真的应该避免添加它们，因为这会使你更难理解什么是需要的，什么是不需要的。<code class="fe lq lr ls lt b">@JsonIgnoreProperties</code>可用于此。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="8657" class="mc ko iq lt b gy md me l mf mg">@JsonIgnoreProperties(ignoreUnknown = true) <br/>data class User(val id: String)</span></pre><h2 id="213c" class="mc ko iq bd kp mi mj dn kt mk ml dp kx jy mm mn lb kc mo mp lf kg mq mr lj ms bi translated">不同的表现</h2><p id="d382" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">如果您的后端充当代理，您将从某个地方读取数据并将其传递给客户端。在这种情况下，您可能希望跳过序列化中的一些字段，以便为您的客户端提供他们需要的字段。您可以通过自定义访问来实现这一点。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="4cab" class="mc ko iq lt b gy md me l mf mg">data class User(   <br/>  val id: String = "",   <br/>  @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)   <br/>  val age: Int<br/>)</span></pre><p id="6044" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个对象的序列化将不包含<code class="fe lq lr ls lt b">age</code>，但是它在我们的代码中是可用的。然而，这种方法不能很好地扩展。如果您发现同一个实体有两种不同的表示，并且添加了大量的注释以便只使用一个类，那么最好将它分成两个不同的类，并为一个类提供一个方法。</p><p id="bf9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这强调了重要的一点。你不需要对所有的事情都使用注释和隐式转换，也许在某些地方使用专用的转换器更具可读性，如果你想给这个过程附加一些逻辑的话就更是如此。</p><h2 id="d34d" class="mc ko iq bd kp mi mj dn kt mk ml dp kx jy mm mn lb kc mo mp lf kg mq mr lj ms bi translated">如果你想要更多…</h2><p id="4272" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">这只是可能做到的事情的一小部分。您可以真正控制序列化/反序列化过程的每个方面。如果你想知道其他选择，看看这篇文章。</p><h1 id="26a6" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">远离无类型字符串</h1><p id="5c36" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">在JSON中，您倾向于使用字符串来表示许多实体。任何id类型，比如用户id，或者语言代码。我更喜欢在我的代码中将它们映射到专用类。我见过许多错误，其中使用了错误的实体，而编译器可以直接阻止这种错误。以一个<code class="fe lq lr ls lt b">UserId</code>为例，我喜欢这样建模:</p><ul class=""><li id="7d08" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">它应该是一个不可变的数据类</li><li id="1460" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">它不应该强制改变JSON的结构(即没有嵌套)</li><li id="a122" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">序列化/反序列化应该开箱即用</li></ul><figure class="lu lv lw lx gt nh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="dea5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用一个数据类，我们得到了一个代表这个实体的不可变对象。我们能做的相对较少。在这种情况下，我们甚至不想访问内部字段。我们将直接比较实例，如果我们需要获得一个字符串表示，我们将通过<code class="fe lq lr ls lt b">toString</code>方法来完成。</p><p id="f2bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">序列化通过<code class="fe lq lr ls lt b">@JsonValue</code>注释进行，在这里我们直接使用值。如果我们修改我们之前一直使用的<code class="fe lq lr ls lt b">User</code>类，它看起来会像这样。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="44bf" class="mc ko iq lt b gy md me l mf mg">data class User(val id: UserId, val age: Int)</span></pre><p id="1dc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该类将被序列化为这个JSON</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="9538" class="mc ko iq lt b gy md me l mf mg">{   <br/>  "id": "123",   <br/>  "age": 20 <br/>}</span></pre><p id="55b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这符合大多数客户端(特别是前端)对这种结构的预期，而不会牺牲后端的任何安全性。</p><p id="bce2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反序列化会自动发生。然而，我喜欢定义一个静态构造函数(使用<code class="fe lq lr ls lt b">@JvmStatic</code>和<code class="fe lq lr ls lt b">@JsonCreator</code>注释),这样我就可以在生成实例之前处理输入。这有助于确保我们的模型处于一致的状态。</p><p id="cd6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从Kotlin 1.3开始，引入了一个叫做<a class="ae kl" href="https://kotlinlang.org/docs/reference/inline-classes.html" rel="noopener ugc nofollow" target="_blank">内联类</a>的新概念，这可能更适合这个用例。从16/06/19开始，Jackson在嵌套对象中很难正确地反序列化它，所以到目前为止我还不能用它替换我的数据类。Github 中有一个<a class="ae kl" href="https://github.com/FasterXML/jackson-module-kotlin/issues/199" rel="noopener ugc nofollow" target="_blank">未解决的问题需要关注。</a></p><h1 id="79f1" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">SpringBoot集成</h1><p id="a803" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">这是拼图的最后一块。我们可以手动使用一个<code class="fe lq lr ls lt b">ObjectMapper</code>并显式地转换事物。如果它自己发生，事情就简单多了。好消息是，除了添加<a class="ae kl" href="https://github.com/FasterXML/jackson-module-kotlin" rel="noopener ugc nofollow" target="_blank"> jackson-module-kotlin </a>作为依赖项之外，这里没有太多事情要做:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="0cea" class="mc ko iq lt b gy md me l mf mg">implementation("com.fasterxml.jackson.module:jackson-module-kotlin:${jacksonVersion}")</span></pre><p id="8076" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你使用的都是最新版本，那就足够了。如果spring魔术不是自己发生的(spring做了很多我不太懂的魔术)，你可以手动做。您可以使用一个<code class="fe lq lr ls lt b">@Configuration</code>以便您的控制器可以自动映射到JSON和从JSON映射。</p><figure class="lu lv lw lx gt nh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="55f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您向另一个服务发出REST请求，您可以构建一个自定义的<code class="fe lq lr ls lt b">RestTemplate</code>来做同样的事情:</p><figure class="lu lv lw lx gt nh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ac50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，所有这些都应该通过将库添加到类路径中来实现。如果由于某种原因不工作，使用这个作为后备。此外，该模板可以扩展为使用基本url、接收环境变量(例如包括keystore)或自动向请求添加某些头。</p><h2 id="49a0" class="mc ko iq bd kp mi mj dn kt mk ml dp kx jy mm mn lb kc mo mp lf kg mq mr lj ms bi translated">PathVariables不是JSON</h2><p id="3fb8" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">现在我们已经深入到自动化JSON映射中，我开始变得雄心勃勃。如上所述，我们不再使用普通字符串，而是使用适当的域类。假设你有一条像<code class="fe lq lr ls lt b">GET /users/:userId</code>这样的路线。控制器应该是这样的:</p><figure class="lu lv lw lx gt nh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6953" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您向这个路由发出请求，<code class="fe lq lr ls lt b">userId</code>将被自动解析，但是我们的自定义<code class="fe lq lr ls lt b">create</code>方法不会被调用，因为这是一个URL，而不是JSON。我们走到这一步并不是为了再次手动解析字符串。让我们通过使用自定义转换器来解决这个问题。</p><figure class="lu lv lw lx gt nh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="35ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。现在我们可以确定，在请求流的任何一点上，这些讨厌的字符串都不会在我们的应用程序中流动。</p><h1 id="58a6" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">摘要</h1><p id="934c" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">Jackson是一个非常强大的库，老实说，你可以用所有的注释来过度使用它。但是，如果您明智地使用它们，使用JSON会变得非常容易，同时在这个过程中保持很好的类型安全性。对于测试，这与使用WireMock 的<a class="ae kl" href="https://hceris.com/recording-apis-with-wiremock/" rel="noopener ugc nofollow" target="_blank">记录的API配合得非常好。</a></p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="3ec0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">原载于2019年6月16日</em><a class="ae kl" href="https://hceris.com/painless-json-with-kotlin-and-jackson/" rel="noopener ugc nofollow" target="_blank"><em class="km">https://hceris.com</em></a><em class="km">。</em></p></div></div>    
</body>
</html>