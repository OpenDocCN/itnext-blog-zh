<html>
<head>
<title>Reverse Engineer Docker Images Into Dockerfiles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Docker图像反向工程为Docker文件</h1>
<blockquote>原文：<a href="https://itnext.io/reverse-engineer-docker-images-into-dockerfiles-453d3d21d896?source=collection_archive---------0-----------------------#2022-07-09">https://itnext.io/reverse-engineer-docker-images-into-dockerfiles-453d3d21d896?source=collection_archive---------0-----------------------#2022-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="13fd" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">码头深水潜水</h2><div class=""/><div class=""><h2 id="5d67" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过检查docker映像存储数据的内部机制，对Docker映像进行逆向工程</h2></div><h1 id="a6cf" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="844f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这个故事中，我们将通过查看Docker映像如何存储数据，如何使用工具查看映像的不同方面，以及如何创建像<a class="ae mf" href="https://github.com/mrhavens/Dedockify" rel="noopener ugc nofollow" target="_blank"> Dedockify </a>这样的使用Python Docker APIs创建Docker文件的工具，来对Docker映像进行逆向工程。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/16dd201afc4399f1b64db06ef42584ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDBgxfHbh46xkDtPYHDwtA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae mf" href="https://github.com/mrhavens/Dedockify" rel="noopener ugc nofollow" target="_blank">去神秘化</a>插图作者<a class="ae mf" href="https://markhavens.us" rel="noopener ugc nofollow" target="_blank">作者</a>。</figcaption></figure><h1 id="2e7b" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">介绍</h1><p id="3205" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">随着像<a class="ae mf" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>和<a class="ae mf" href="https://treescale.com" rel="noopener ugc nofollow" target="_blank"> TreeScale </a>这样的公共Docker注册表越来越受欢迎，管理员和开发人员下载未知实体创建的图像变得越来越常见。很多时候，便利战胜了感知的风险。在某些情况下，当Docker图像公开时，它要么直接在清单中、在git存储库中提供，要么通过相关链接提供。更常见的是，不提供docker文件。在docker文件可用的情况下，我们很难保证预构建的映像与docker文件相关，或者甚至可以安全使用。</p><p id="e817" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">也许你不关心安全漏洞。也许你想更新你最喜欢的一张图片，这样它就可以在最新版本的Ubuntu上运行了。或者，您可能会不可控制地被迫发布一个稍微优化一点的映像，因为有一个针对另一个发行版的编译器，它更适合在编译时生成二进制文件。</p><p id="1f70" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">不管是什么原因，都有恢复映像docker文件的选项。Docker图像不是黑盒。重建Dockerfile文件所需的大部分信息都可以检索到。通过查看Docker映像内部并检查其内部结构，我们将能够从任意预构建的容器中重建Docker文件。</p><p id="6509" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">在这个故事中，我们将展示如何使用两个工具从图像中重建Docker文件:<a class="ae mf" href="https://github.com/mrhavens/Dedockify" rel="noopener ugc nofollow" target="_blank"> Dedockify </a>，一个为这个故事提供的定制Python脚本，和<a class="ae mf" href="https://github.com/wagoodman/dive" rel="noopener ugc nofollow" target="_blank"> Dive </a>，一个Docker图像探索工具。所用的基本工艺流程如下。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nb"><img src="../Images/e65b23904ff6090b2bd4ca1bde8ecf18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqfrJEWl_hfks1U09PF-uQ.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">使用<a class="ae mf" href="https://github.com/mrhavens/Dedockify" rel="noopener ugc nofollow" target="_blank"> Dedockify </a>的基本流程。作者<a class="ae mf" href="https://markhavens.us" rel="noopener ugc nofollow" target="_blank">插图</a>。</figcaption></figure><h1 id="ac39" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">使用潜水</h1><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/dffdc5ff88a73e952b059b4214b66933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*wW77SZTEJC2RcCvZ1cyW2A.gif"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">作者<a class="ae mf" href="https://markhavens.us" rel="noopener ugc nofollow" target="_blank">的潜水演示剪辑</a>。</figcaption></figure><p id="729a" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">为了快速理解图像是如何构成的，我们将使用Dive学习一些高级的和可能不熟悉的Docker概念。Dive工具检查Docker图像的每一层。</p><p id="edda" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">让我们创建一个简单、易于遵循的<code class="fe nd ne nf ng b">Dockerfile</code>来进行测试。</p><p id="bfc1" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">将这段代码直接放入一个空目录中:</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="befa" class="nl ks it ng b gy nm nn l no np">cat &gt; Dockerfile &lt;&lt; EOF ; touch testfile1 testfile2 testfile3<br/>FROM scratch<br/>COPY testfile1 /<br/>COPY testfile2 /<br/>COPY testfile3 /<br/>EOF</span></pre><p id="ed74" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">通过输入上面的内容并按回车键，我们刚刚创建了一个新的<em class="nq"> Dockerfile </em>并在同一个目录中填充了三个零字节测试文件。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="8663" class="nl ks it ng b gy nm nn l no np">$ ls<br/>Dockerfile  testfile1  testfile2  testfile3</span></pre><p id="8451" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">现在，让我们使用这个Dockerfile文件构建一个图像，并将其标记为<code class="fe nd ne nf ng b">example1</code>。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="0321" class="nl ks it ng b gy nm nn l no np">docker build . -t example1</span></pre><p id="28df" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">构建<code class="fe nd ne nf ng b">example1</code>映像应该产生以下输出:</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="b19a" class="nl ks it ng b gy nm nn l no np">Sending build context to Docker daemon  3.584kB<br/>Step 1/4 : FROM scratch<br/> ---&gt;<br/>Step 2/4 : COPY testfile1 /<br/> ---&gt; a9cc49948e40<br/>Step 3/4 : COPY testfile2 /<br/> ---&gt; 84acff3a5554<br/>Step 4/4 : COPY testfile3 /<br/> ---&gt; 374e0127c1bc<br/>Successfully built 374e0127c1bc<br/>Successfully tagged example1:latest</span></pre><p id="4a0b" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">下面的零字节<code class="fe nd ne nf ng b">example1</code>图像现在应该是可用的:</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="e928" class="nl ks it ng b gy nm nn l no np">$ docker images<br/>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br/>example1            latest              374e0127c1bc        31 seconds ago      0B</span></pre><p id="d342" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">请注意，由于没有二进制数据，这个图像将不起作用。我们只是用它作为一个简化的例子，说明如何在Docker图像中查看图层。</p><p id="1723" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">我们可以从图像的大小看出这里没有源图像。我们没有使用源图像，而是使用了<code class="fe nd ne nf ng b">scratch</code>,它指示Docker使用一个零字节的空白图像作为源图像。然后，我们通过复制三个额外的零字节测试文件来修改空白图像，然后将这些更改标记为<code class="fe nd ne nf ng b">example1</code>。</p><p id="09a2" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">现在，让我们用潜水来探索我们的新形象。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="9ef9" class="nl ks it ng b gy nm nn l no np">docker run --rm -it \<br/>    -v /var/run/docker.sock:/var/run/docker.sock \<br/>    wagoodman/dive:latest example1</span></pre><p id="7a4e" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">执行上面的命令应该会自动从Docker Hub拉<code class="fe nd ne nf ng b">wagoodman/dive</code>，并产生Dive的抛光接口的输出。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="8465" class="nl ks it ng b gy nm nn l no np">Unable to find image 'wagoodman/dive:latest' locally<br/>latest: Pulling from wagoodman/dive<br/>89d9c30c1d48: Pull complete<br/>5ac8ae86f99b: Pull complete<br/>f10575f61141: Pull complete<br/>Digest: sha256:2d3be9e9362ecdcb04bf3afdd402a785b877e3bcca3d2fc6e10a83d99ce0955f<br/>Status: Downloaded newer image for wagoodman/dive:latest<br/>Image Source: docker://example-image<br/>Fetching image... (this can take a while for large images)<br/>Analyzing image...<br/>Building cache...</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nr"><img src="../Images/0ce0672ea8c3064a05686c89e44d8937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8B7nGXa_3WLvtKEESB_5w.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae mf" href="https://markhavens.us" rel="noopener ugc nofollow" target="_blank">作者</a>潜水截图。</figcaption></figure><p id="6004" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">滚动列表中图像的三个层，在右侧显示的树中找到三个文件。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ns"><img src="../Images/c206224f2980a18c49ca609f6c712511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lj2P_hLSVXC95kKu1_ZtMw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae mf" href="https://markhavens.us" rel="noopener ugc nofollow" target="_blank">作者</a>的潜水截图。</figcaption></figure><p id="cc4e" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">当我们滚动每一层时，我们可以看到右边的内容发生了变化。当每个文件被复制到一个空白的Docker <code class="fe nd ne nf ng b">scratch</code>图像时，它被记录为一个新层。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ns"><img src="../Images/e58e7969e001da710e5357cf4baea379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32wyP2999CHiOkzQXORwcA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae mf" href="https://markhavens.us" rel="noopener ugc nofollow" target="_blank">作者</a>的潜水截图。</figcaption></figure><p id="0512" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">还要注意，我们可以看到用于生成每一层的命令。我们还可以看到源文件和被更新文件的哈希值。</p><p id="f5c7" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">如果我们注意到<code class="fe nd ne nf ng b">Command:</code>部分中的项目，我们应该看到以下内容:</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="a0d9" class="nl ks it ng b gy nm nn l no np">#(nop) COPY file:e3c862873fa89cbf2870e2afb7f411d5367d37a4aea01f2620f7314d3370edcc in /<br/>#(nop) COPY file:2a949ad55eee33f6191c82c4554fe83e069d84e9d9d8802f5584c34e79e5622c in /<br/>#(nop) COPY file:aa717ff85b39d3ed034eed42bc1186230cfca081010d9dde956468decdf8bf20 in /</span></pre><p id="a858" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">每个命令都提供了对Dockerfile文件中用于生成图像的原始命令的深入了解。但是，原始文件名会丢失。恢复这些信息的唯一方法似乎是观察目标文件系统的变化，或者根据其他细节进行推断。稍后将详细介绍。</p><h1 id="b89a" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">码头工人历史</h1><p id="0382" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">除了像<em class="nq"> dive </em>这样的第三方工具之外，我们立即可用的工具是<code class="fe nd ne nf ng b">docker history</code>。如果我们在我们的<code class="fe nd ne nf ng b">example1 </code>图像上使用<code class="fe nd ne nf ng b">docker history</code>命令，我们可以查看我们在docker文件中用来创建该图像的条目。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="be17" class="nl ks it ng b gy nm nn l no np">docker history example1</span></pre><p id="c2df" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">因此，我们应该得到以下结果:</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="6825" class="nl ks it ng b gy nm nn l no np">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT<br/>374e0127c1bc        25 minutes ago      /bin/sh -c #(nop) COPY file:aa717ff85b39d3ed…   0B<br/>84acff3a5554        25 minutes ago      /bin/sh -c #(nop) COPY file:2a949ad55eee33f6…   0B<br/>a9cc49948e40        25 minutes ago      /bin/sh -c #(nop) COPY file:e3c862873fa89cbf…   0B</span></pre><p id="3f98" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">请注意，<code class="fe nd ne nf ng b">CREATED BY</code>列中的所有内容都被截断了。这些是通过Bourne shell传递的Dockerfile指令。这些信息对于重新创建我们的docker文件可能是有用的，虽然它在这里被截断了，但是我们也可以通过使用<code class="fe nd ne nf ng b">no-trunc</code>选项来查看全部内容:</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="d0a7" class="nl ks it ng b gy nm nn l no np">$ docker history example1 --no-trunc<br/>IMAGE                                                                     CREATED             CREATED BY                                                                                           SIZE                COMMENT<br/>sha256:374e0127c1bc51bca9330c01a9956be163850162f3c9f3be0340bb142bc57d81   29 minutes ago      /bin/sh -c #(nop) COPY file:aa717ff85b39d3ed034eed42bc1186230cfca081010d9dde956468decdf8bf20 in /    0B<br/>sha256:84acff3a5554aea9a3a98549286347dd466d46db6aa7c2e13bb77f0012490cef   29 minutes ago      /bin/sh -c #(nop) COPY file:2a949ad55eee33f6191c82c4554fe83e069d84e9d9d8802f5584c34e79e5622c in /    0B<br/>sha256:a9cc49948e40d15166b06dab42ea0e388f9905dfdddee7092f9f291d481467fc   29 minutes ago      /bin/sh -c #(nop) COPY file:e3c862873fa89cbf2870e2afb7f411d5367d37a4aea01f2620f7314d3370edcc in /    0B</span></pre><p id="8599" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">虽然这有一些有用的数据，但从命令行解析可能是一个挑战。我们也可以使用<code class="fe nd ne nf ng b">docker inspect</code>。然而，在这个故事中，我们将重点关注使用Python的Docker引擎API。</p><h1 id="c5cb" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">为Python使用Docker引擎API</h1><p id="ddc5" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Docker为Docker引擎API 发布了一个<a class="ae mf" href="https://docker-py.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Python库，允许从Python内部完全控制Docker。在下面的例子中，我们可以通过运行下面的Python 3代码来恢复与使用<code class="fe nd ne nf ng b">docker history</code>类似的信息:</a></p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="148c" class="nl ks it ng b gy nm nn l no np">#!/usr/bin/python3<br/><br/>import docker<br/><br/>cli = docker.APIClient(base_url='unix://var/run/docker.sock')<br/>print (cli.history('example1'))</span></pre><p id="60ef" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">这将产生如下所示的输出:</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="b05e" class="nl ks it ng b gy nm nn l no np">[{'Comment': '', 'Created': 1583008507, 'CreatedBy': '/bin/sh -c #(nop) COPY file:aa717ff85b39d3ed034eed42bc1186230cfca081010d9dde956468decdf8bf20 in / ', 'Id': 'sha256:374e0127c1bc51bca9330c01a9956be163850162f3c9f3be0340bb142bc57d81', 'Size': 0, 'Tags': ['example:latest']}, {'Comment': '', 'Created': 1583008507, 'CreatedBy': '/bin/sh -c #(nop) COPY file:2a949ad55eee33f6191c82c4554fe83e069d84e9d9d8802f5584c34e79e5622c in / ', 'Id': 'sha256:84acff3a5554aea9a3a98549286347dd466d46db6aa7c2e13bb77f0012490cef', 'Size': 0, 'Tags': None}, {'Comment': '', 'Created': 1583008507, 'CreatedBy': '/bin/sh -c #(nop) COPY file:e3c862873fa89cbf2870e2afb7f411d5367d37a4aea01f2620f7314d3370edcc in / ', 'Id': 'sha256:a9cc49948e40d15166b06dab42ea0e388f9905dfdddee7092f9f291d481467fc', 'Size': 0, 'Tags': None}]</span></pre><p id="225a" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">查看输出，我们可以看到，重建Dockerfile的大部分只是解析所有相关数据并反转条目的问题。但是正如我们前面看到的，我们还注意到在<code class="fe nd ne nf ng b">COPY</code>指令中有一些散列条目。如前所述，这里的散列条目表示从层外部使用的文件名。这些信息不能直接恢复。然而，正如我们在Dive中看到的，当我们搜索对层所做的更改时，我们可以推断出这些名称。有时也可能推断出原始复制指令包含目标文件名作为目的地的情况。在其他情况下，文件名可能并不重要，允许我们使用任意文件名。在其他情况下，虽然更难评估，但我们可以推断出系统中其他地方反向引用的文件名，例如支持脚本或配置文件等依赖项。但无论如何，搜索层间所有变化是最可靠的。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nt"><img src="../Images/c10068ab2edec66c5441cb93a6fbe388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SM6dy51xzT4okiefh4yJmQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae mf" href="https://github.com/mrhavens/Dedockify" rel="noopener ugc nofollow" target="_blank"> Dedockify </a> logo作者<a class="ae mf" href="https://markhavens.us" rel="noopener ugc nofollow" target="_blank">作者</a>。</figcaption></figure><h1 id="ac23" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated"><a class="ae mf" href="https://github.com/mrhavens/Dedockify" rel="noopener ugc nofollow" target="_blank">去时钟化</a></h1><p id="0866" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们更进一步。为了帮助将该图像逆向工程为order文件，我们需要解析所有内容并将其重新格式化为可读的形式。请注意，为了这个故事的目的，下面的Python 3代码已经可用，可以从GitHub上的<a class="ae mf" href="https://github.com/mrhavens/Dedockify" rel="noopener ugc nofollow" target="_blank"> Dedockify </a>库获得。感谢<a class="ae mf" href="https://github.com/LanikSJ" rel="noopener ugc nofollow" target="_blank"> LanikSJ </a>所有<a class="ae mf" href="https://github.com/LanikSJ/dfimage" rel="noopener ugc nofollow" target="_blank">伟大的原创基础和编码</a>。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="9d68" class="nl ks it ng b gy nm nn l no np">from sys import argv<br/>import docker<br/><br/>class ImageNotFound(Exception):<br/>    pass<br/><br/>class MainObj:<br/>    def __init__(self):<br/>        super(MainObj, self).__init__()<br/>        self.commands = []<br/>        self.cli = docker.APIClient(base_url='unix://var/run/docker.sock')<br/>        self._get_image(argv[-1])<br/>        self.hist = self.cli.history(self.img['RepoTags'][0])<br/>        self._parse_history()<br/>        self.commands.reverse()<br/>        self._print_commands()<br/><br/>    def _print_commands(self):<br/>        for i in self.commands:<br/>            print(i)<br/><br/>    def _get_image(self, img_hash):<br/>        images = self.cli.images()<br/>        for i in images:<br/>            if img_hash in i['Id']:<br/>                self.img = i<br/>                return<br/>        raise ImageNotFound("Image {} not found\n".format(img_hash))<br/><br/>    def _insert_step(self, step):<br/>        if "#(nop)" in step:<br/>            to_add = step.split("#(nop) ")[1]<br/>        else:<br/>            to_add = ("RUN {}".format(step))<br/>        to_add = to_add.replace("&amp;&amp;", "\\\n    &amp;&amp;")<br/>        self.commands.append(to_add.strip(' '))<br/><br/>    def _parse_history(self, rec=False):<br/>        first_tag = False<br/>        actual_tag = False<br/>        for i in self.hist:<br/>            if i['Tags']:<br/>                actual_tag = i['Tags'][0]<br/>                if first_tag and not rec:<br/>                    break<br/>                first_tag = True<br/>            self._insert_step(i['CreatedBy'])<br/>        if not rec:<br/>            self.commands.append("FROM {}".format(actual_tag))<br/><br/>__main__ = MainObj()</span></pre><h1 id="d9a3" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">初始Dockerfile文件生成</h1><p id="1660" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果您已经做到了这一步，那么您应该有两个图像:<code class="fe nd ne nf ng b">wagoodman/dive</code>和我们自定义的<code class="fe nd ne nf ng b">example1</code>图像。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="0671" class="nl ks it ng b gy nm nn l no np">$ docker images<br/>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br/>example1            latest              374e0127c1bc        42 minutes ago      0B<br/>wagoodman/dive      latest              4d9ce0be7689        2 weeks ago         83.6MB</span></pre><p id="c98b" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">对我们的<code class="fe nd ne nf ng b">example1</code>映像运行这段代码，最终会产生以下结果:</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="5e98" class="nl ks it ng b gy nm nn l no np">$ python3 dedockify.py 374e0127c1bc<br/>FROM example1:latest<br/>COPY file:e3c862873fa89cbf2870e2afb7f411d5367d37a4aea01f2620f7314d3370edcc in /<br/>COPY file:2a949ad55eee33f6191c82c4554fe83e069d84e9d9d8802f5584c34e79e5622c in /<br/>COPY file:aa717ff85b39d3ed034eed42bc1186230cfca081010d9dde956468decdf8bf20 in /</span></pre><p id="907d" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">我们已经提取了几乎与之前用Dive探索图像时观察到的相同的信息。请注意<code class="fe nd ne nf ng b">FROM</code>指令向我们显示了<code class="fe nd ne nf ng b">example1:latest</code>而不是<code class="fe nd ne nf ng b">scratch</code>。在这种情况下，我们的代码对基本图像做了一个技术上不正确的假设。</p><p id="2a70" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">作为比较，让我们对我们的<code class="fe nd ne nf ng b">wagoodman/dive</code>图像做同样的事情。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="65b9" class="nl ks it ng b gy nm nn l no np">$ python3 dedockify.py 4d9ce0be7689<br/>FROM wagoodman/dive:latest<br/>ADD file:fe1f09249227e2da2089afb4d07e16cbf832eeb804120074acd2b8192876cd28 in /<br/>CMD ["/bin/sh"]<br/>ARG DOCKER_CLI_VERSION=<br/>RUN |1 DOCKER_CLI_VERSION=19.03.1 /bin/sh -c wget -O- https://download.docker.com/linux/static/stable/x86_64/docker-${DOCKER_CLI_VERSION}.tgz |     tar -xzf - docker/docker --strip-component=1 \<br/>    &amp;&amp;     mv docker /usr/local/bin<br/>COPY file:8385774b036879eb290175cc42a388877142f8abf1342382c4d0496b6a659034 in /usr/local/bin/<br/>ENTRYPOINT ["/usr/local/bin/dive"]</span></pre><p id="1a77" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">与我们的<code class="fe nd ne nf ng b">example1</code>图片相比，这显示了更多的多样性。我们注意到<code class="fe nd ne nf ng b">ADD</code>指令就在<code class="fe nd ne nf ng b">FROM</code>指令之前。我们的代码又做出了错误的假设。我们不知道<code class="fe nd ne nf ng b">ADD</code>指令增加了什么。然而，我们可以直观地假设，我们并不确切知道基础图像是什么。<code class="fe nd ne nf ng b">ADD</code>指令可以用来将本地<code class="fe nd ne nf ng b">tar</code>文件提取到根目录中。有可能它使用这种方法加载另一个基础映像。</p><h1 id="6b0f" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated"><a class="ae mf" href="https://github.com/mrhavens/Dedockify" rel="noopener ugc nofollow" target="_blank">去毛刺</a>限制测试</h1><p id="2d6b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们通过创建一个例子<code class="fe nd ne nf ng b">Dockerfile</code>来进行实验，在这个例子中，我们显式地定义了基本图像。正如我们前面所做的，在一个空目录中，直接从命令行运行下面的代码片段。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="d61c" class="nl ks it ng b gy nm nn l no np">cat &gt; Dockerfile &lt;&lt; EOF ; touch testfile1 testfile2 testfile3<br/>FROM ubuntu:latest<br/>RUN mkdir testdir1<br/>COPY testfile1 /testdir1<br/>RUN mkdir testdir2<br/>COPY testfile2 /testdir2<br/>RUN mkdir testdir3<br/>COPY testfile3 /testdir3<br/>EOF</span></pre><p id="6622" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">现在，执行一个构建，将我们的新图像标记为<code class="fe nd ne nf ng b">example2</code>。这将创建一个与之前相似的图像，除了不使用<code class="fe nd ne nf ng b">scratch</code>而是使用<code class="fe nd ne nf ng b">ubuntu:latest</code>作为基础图像。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="d7e2" class="nl ks it ng b gy nm nn l no np">$ docker build . -t example2<br/>Sending build context to Docker daemon  3.584kB<br/>Step 1/7 : FROM ubuntu:latest<br/> ---&gt; 72300a873c2c<br/>Step 2/7 : RUN mkdir testdir1<br/> ---&gt; Using cache<br/> ---&gt; 4110037ae26d<br/>Step 3/7 : COPY testfile1 /testdir1<br/> ---&gt; Using cache<br/> ---&gt; e4adf6dc5677<br/>Step 4/7 : RUN mkdir testdir2<br/> ---&gt; Using cache<br/> ---&gt; 22d301b39a57<br/>Step 5/7 : COPY testfile2 /testdir2<br/> ---&gt; Using cache<br/> ---&gt; f60e5f378e13<br/>Step 6/7 : RUN mkdir testdir3<br/> ---&gt; Using cache<br/> ---&gt; cec486378382<br/>Step 7/7 : COPY testfile3 /testdir3<br/> ---&gt; Using cache<br/> ---&gt; 05651f084d67<br/>Successfully built 05651f084d67<br/>Successfully tagged example2:latest</span></pre><p id="e269" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">因为我们现在有一个稍微复杂一点的<code class="fe nd ne nf ng b">Dockerfile</code>要重建，而且我们有了生成这个图像的精确的<code class="fe nd ne nf ng b">Dockerfile</code>，我们可以做一个比较。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="5b8f" class="nl ks it ng b gy nm nn l no np">$ docker images<br/>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br/>example2            latest              05651f084d67        2 minutes ago       64.2MB<br/>example1            latest              374e0127c1bc        1 hour ago          0B<br/>ubuntu              latest              72300a873c2c        9 days ago          64.2MB<br/>wagoodman/dive      latest              4d9ce0be7689        3 weeks ago         83.6MB</span></pre><p id="38e9" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">让我们从Python脚本中生成输出。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="d427" class="nl ks it ng b gy nm nn l no np">$ python3 dedockify.py 05651f084d67<br/>FROM ubuntu:latest<br/>RUN /bin/sh -c mkdir testdir1<br/>COPY file:cc4f6e89a1bc3e3c361a1c6de5acc64d3bac297f0b99aa75af737981a19bc9d6 in /testdir1<br/>RUN /bin/sh -c mkdir testdir2<br/>COPY file:a04cdcdf5fd077a994fe5427a04f6b9a52288af02dad44bb1f8025ecf209b339 in /testdir2<br/>RUN /bin/sh -c mkdir testdir3<br/>COPY file:2ed8ccde7cd97bc95ca15f0ec24ec447484a8761fa901df6032742e8f1a2a191 in /testdir3</span></pre><p id="c212" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">这与最初的<code class="fe nd ne nf ng b">Dockerfile</code>非常吻合。这次没有<code class="fe nd ne nf ng b">ADD</code>指令，<code class="fe nd ne nf ng b">FROM</code>指令是正确的。假设我们的基础映像是在原始的<code class="fe nd ne nf ng b">Dockerfile</code>中定义的，并且它避免使用<code class="fe nd ne nf ng b">scratch</code>或者避免使用<code class="fe nd ne nf ng b">ADD</code>指令从<code class="fe nd ne nf ng b">tar</code>文件创建基础映像，我们应该能够以一定的精度重建<code class="fe nd ne nf ng b">Dockerfile</code>。然而，我们仍然不知道被复制的原始文件的名称。</p><h1 id="6bbb" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">盲目自由式文件重建</h1><p id="87c6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，让我们尝试使用我们已经讨论过的工具，以正确的方式对Docker容器进行逆向工程。我们将使用的容器是根据上面的例子修改的。我们之前的<code class="fe nd ne nf ng b">Dockerfile</code>已经被修改成了<code class="fe nd ne nf ng b">example3</code>。通过添加一个小的二进制文件，图像变得实用了。汇编源代码在<a class="ae mf" href="https://github.com/mrhavens/Dedockify" rel="noopener ugc nofollow" target="_blank"> Dedockify GitHub库</a>中的<a class="ae mf" href="https://github.com/mrhavens/Dedockify/tree/master/examples/example3/hello.s" rel="noopener ugc nofollow" target="_blank">处</a>可用。由于这个图像很小，我们不需要构建或拖动它。我们可以用下面的代码片段将整个容器复制并粘贴到我们的Docker环境中，来展示我们的命令行技能。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="7397" class="nl ks it ng b gy nm nn l no np">uudecode &lt;&lt; EOF | zcat | docker load<br/>begin-base64 600 -<br/>H4sICMicXV4AA2V4YW1wbGUzLnRhcgDtXVtvG8cVVnp56UN/QJ/YDQokgETN<br/>zJkrgTykjgsbDSzDURMkshDM5YzFhiJVkkpiCELzH/pP+tYfkf/UsxRNXdxI<br/>spe7lqv5IJF7PTM7Z87MmY9nZxgL2qG1DkN2nkXmtTecQwYrMMfsBHgXgFuV<br/>eXLCI5c26sxdNHQsie2Nm8GYZEYp+l7g6vdim4MWBrgyBjaY4MbIjZ66hezG<br/>OJ7N/ZSyMp1M5tddd9P5qw/3noA11f+XD5998XjnybVpcMa0lNfoH67oHxiI<br/>jV4nhXjP9c/7701WC1pAY/v/+2wyvimNG+zfgLpi/0KbYv+d4KQapmpQNa0G<br/>1WZ15Kc4npMsr7JUjGGMyLUzPEXJc1RCWqFkTtoEL5TgEaLSKlmOiXHnUSlK<br/>jYsQSFacop9jnTHuDNtinP52GRss/r6pL5iM5344xum3tJWHL6rBSfVoMpuP<br/>/SHSXXTFZ5NDuuB8/28znJ5tfTqf+3jwxTwNx9Ug+9EMLxybHM9fP4jT6erg<br/>7vzlanvnCMeX5Sz2dsYRV0cejr+vBuPj0WizenCYXm0+PvQvlhn7cjI6PsTZ<br/>qzNfTabfDccvPhsuc/twPJ++PJoM66I9u2Jn/Ofj4Wgl6nMfcLS8/XSzmtBm<br/>NRqOj3+sTm+h/8b2P/IvcdqvbeiX07je/uXr/h9oZor9dwF/dHQbF74R3sz/<br/>F1RfuKbLi//fAWr993846C/+J0f/aCONRR9/g/4vbXNQShb7LygoKGgTTDkP<br/>1tiEUvkgJajgnTZRA0pAplFqZ1m02hqXjc4+aaVTztx4pzywfvPxH7X1V/0/<br/>oZgu7X8XOKn8NB4M5xjnx9N6ROIPk5ZnI6y7P67aq55+uvvok+3j2XR7NIl+<br/>tD0Lw/Hgwv5q9/zEYuNslz6q/f85MJsd0CBVD4SHEDhGkM4LDIqHQN4JjU5s<br/>5NqiJguRAr3nKpgICoRhyLNiCgHQOLxhfLdN7teVMd7e4uD2AY5Gkzpv14/2<br/>VuPgegyvDA3aOATr5cJkJUs0tMsRacytE6MsGZnp/piCEMaiijHmJJOIihvN<br/>bh5WX0zh/7kqkA5od3t2QI+yFenjw4/Gk6OPe7Wqnuw++/rpzuMnu7295xdU<br/>9bzar29/X6rPyenpRZZFMMG2GGwxsStgoPhAQF8KrZ1grqZb0iR+R5Xie5zO<br/>hpPxgpbpM+hrOnUwnM0nU1LY3sm1AnnfOXCgDDPfnDM834aX9XOclXZvK/aW<br/>Jf3VzrO/fvb4WW97jjPS95RXp5vXyxd9Qd0MSCnsLeQ/2Hn6dS8PRzgAIbLL<br/>TiBEJ9Ej8hRZEmCURW6CcTaD8+h18BhtdsrJIFDGmBigS6w3HPfqTNbCeO8W<br/>2SQjVBK4lW9RDOIW8hUZv+PG8XdWDOI2xWA4mYGkKvYWxQC3kO+YdMYxod5Z<br/>McDNxQB9Zpkg38iJNymG2uxvFi005+RJwRsVQAAIkmURmaF+gwUXvAZjApis<br/>tWaSJyWFoAaKOS1DFJrKR0omQSSNVvO6ABaNz20e/mITc0MOe9c1vJsVHh7N<br/>X3674CKrwXx6jKf7l6jQzar233Ld8lXzl0d1E724eFY3bsOcvx2mWd14Lttt<br/>riUXQXJAZFJn5MLriMHJTA6yT44zHZjHQJ2qZM5watCpBeeevFdMdANJXUkC<br/>7ZMxjCq7TI6cbW+zUkEpqj/RMrBeWInCUuFqj3QZTxays9RrBNT+XBJDh2Qw<br/>wQkfqXcAqjZK5RA5SNIJzywKSTKTMGiYjkoknwJjzgVg1vBwLilYbbwhFzsz<br/>LYTTwqNgRiMEZhMYK7zztZ9gmHUZap8/0WOROCXRenUhT1Q8IlhltBbOihhR<br/>ZhOtoucgwVRolD3DkqprS6bHZzlbmxMNOBJGRYVxLsmDcSGZJBkTjkdlEtW3<br/>IKj4nA0oUJHDYgP5MZQ3qjHKZCrDqJSylvwZhAtPF5PRMfJEt4I0kjvms/Qq<br/>U4VVnp6O6jD3PJpaujKcLqJqaNF5TlrR5lxS5jQ2IfVRv22MAhbInjAaiNIp<br/>zkSGCAacVmAj0IPWDVoKPFCjQMXi0VX7p7eh4N8phI70kElxeg7vhJIKZYpa<br/>qOy9J9Vpck3Qkx2I2qOMIUrSQ46GKrzkqHRb8R+cF/63CzTWfyvxH8LI8vtP<br/>JyjxH/cbje1/DfEfWvDX4j8YL/bfBZbxH02rQYnZ6DBmY51obP/txH8oUX7/<br/>7QSv+LU2g0DezP/nVF+EBij+fxdY6b/FIJC6PN4s/kOqWv/F/gsKCgrag2Jg<br/>EIxFl3RyIWQB2bjkDIiYFeTIUuLJy6SNNUG4wKPl3GeXEgSfWuL/BNTxv6X/<br/>bx+N9d/O+18gVen/u0Dh/+43Gtt/K+9/gWDF/jvBkv9rWg0uvf/lBSZQEqIi<br/>YUoB50E7iU4JFD4ESbcok5Kq6SWbIWjFpbFSCOmUYaxwiR1yiY3tvxX+T3JR<br/>3v/sBK8Cy+4O/yfO+L/y/lcnWOn/rvF/hf8vKCgoaBXGQgwYvEKWwNmY0euo<br/>As/cks/mFGMgBI+BfD7jaJtrHaMnhx1ZMAF9a/M/6dL/d4HG+m9r/qfS/3eC<br/>wv/dbzS2/7bmfyr23wmW/F/TanCR/7PKBZAyeI7SuGDqd0Y9ahVYZj6nJFFq<br/>pZS2UieBDAC05HRxNBKE06nwfx3yf43tv6X5n3iJ/+0Er96ovHP8X/H/O8FK<br/>/3eN/yu//xUUFBS0iqbOekv8nzSs9P9doLH+23n/V4ky/1cnKPzf/UZj+2+H<br/>/wNd7L8TLPm/NXB2K/5vDbGEhf/riv9rbP/t8H/Ayvt/naDE/xX9L/S/mrxv<br/>/Wnc7P9f1P+C/5OyxP8WFBQUtIqmizW1Ff9X+v9u0Fj/Lc3/Z4r/3wkK/3e/<br/>0dj+W4r/K/P/dIMl/7eGNRtX/N8aYgkL/9cV/9fY/lua/0+xYv9doMT/Ff0v<br/>9L9atWL9abwV/1fi/wsKCgpaRdPJetqK/6vX/y39f/torP+W4v94+f2vExT+<br/>736jsf23FP+niv13glf8X/M5+1b8X1lL5H3i/5rafzv8n9Bl/a9OcPfW/1jy<br/>f8X/7wQr/a/WMF5/Gm/F/xX+v6CgoKBVJPK8tUkQIUjIXCXMBoJj0oPO3Btu<br/>jJc86SyRWaFFDOhQ8QxKJ8uya2n9D6bK+h+doLH+25n/j/My/0cnKPzf/UZj<br/>+2/O/wmQr63/a0r8TzdY8n9Nq8FF/o+xoB1a6zBk51lkXpMADhmswByzE+Bd<br/>AG5V5skJj1zaSKm4aOhYEpf4P8EE22KwxcSugIHiAwF9KbR2grlLRGCdsKrf<br/>XuUQrJe25hYlS5SRHDFpoxNDACOzDxhToCpmUcUYc5JJRMWNZjfzihdTuGsc<br/>41719NPdR59sH8+m26NJ9KPtWRiOBxf2V7vnJxYbZ7v0Ue0vScq9qt7dnh3Q<br/>o2xF+vjwo/Hk6ONezUc+2X329dOdx092e3vPq21/dLR9gKPR5Hm1X9/+itic<br/>HXih9EB4CIFjBOm8wKB4CIxMnRkbubaokRoGgd5zFUwEBcIw5FkxRbpC4/AG<br/>frRO/gpHunchT3WGfoEtPTk93azSJH5Hqv4ep7PhZLxgm/sM+vqsItx9Wnmd<br/>Kr/MS9919S3Jbj+NB8M5xvnxtM61P0y6tst3uJ72+4bG/X9z/l+9Pv4DXd7/<br/>6Qa1sbWdxhuP/znXqsT/doJVY9tiGrX9X6t/Y67w/9SPlPF/J/jnw8//8sFq<br/>78Fvf7Xx640/0Hf9/xs68h9OG//+/c8//am38cHGv37+6VFdWTZ7P0ymo/TH<br/>3727jBcUFBQUNMKhHw8zzub9W/B4b4sb/H8O0lzyBemIEuX9n06wd1I9WFId<br/>FVPOgzU2oVQ+SAkqeKdN1IASaKiPUrsFr2aNy0Znn8hNTzlz453ywBZ1iIbf<br/>z/BosutfzOrRPP7oD49GCIORryNM6iH95/WIcXGyaaTg+eCTUl1fJBsJW9+y<br/>uCRsfXPskbD1LdhRl9na3v4lYU1530vC1sdLVPun+8VP/SVMyVZnw/lkOsRZ<br/>W2nc9PsvB7ja/pNBlPa/C5ysWuia61420mv4Pej0tNhcQUFBwV3GfwHMszUX<br/>AMIAAA==<br/>====<br/>EOF</span></pre><p id="4967" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">直接从命令行运行一切将加载<code class="fe nd ne nf ng b">example3:latest</code>。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="552f" class="nl ks it ng b gy nm nn l no np">$ docker images<br/>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br/>example3            latest              059a3878de45        5 minutes ago       63B</span></pre><p id="c532" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">现在，让我们尝试重新创建<code class="fe nd ne nf ng b">Dockerfile</code>。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="d125" class="nl ks it ng b gy nm nn l no np">$ python3 dedockify.py 059a3878de45<br/>FROM example3:latest<br/>WORKDIR /testdir1<br/>COPY file:322f9f92e3c94eaee1dc0d23758e17b798f39aea6baec8f9594b2e4ccd03e9d0 in testfile1<br/>WORKDIR /testdir2<br/>COPY file:322f9f92e3c94eaee1dc0d23758e17b798f39aea6baec8f9594b2e4ccd03e9d0 in testfile2<br/>WORKDIR /testdir3<br/>COPY file:322f9f92e3c94eaee1dc0d23758e17b798f39aea6baec8f9594b2e4ccd03e9d0 in testfile3<br/>WORKDIR /app<br/>COPY file:b33b40f2c07ced0b9ba6377b37f666041d542205e0964bc26dc0440432d6e861 in hello<br/>ENTRYPOINT ["/app/hello"]</span></pre><p id="1be4" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">这给了我们一个工作的基础。由于<code class="fe nd ne nf ng b">example3:latest</code>是该图像的名称，我们可以从上下文中假设它使用了“scratch”。现在，我们需要查看哪些文件被复制到了<code class="fe nd ne nf ng b">/testdir1</code>、<code class="fe nd ne nf ng b">/testdir2</code>、<code class="fe nd ne nf ng b">/testdir3</code>和<code class="fe nd ne nf ng b">/app</code>中。让我们对Dive运行这个映像，看看我们将如何恢复丢失的数据。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="9241" class="nl ks it ng b gy nm nn l no np">docker run --rm -it \<br/>    -v /var/run/docker.sock:/var/run/docker.sock \<br/>    wagoodman/dive:latest example3:latest</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nu"><img src="../Images/0f87740b81d9600a1d4c6e289fb589ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKpKfpnizBMcn3cPkBJE-g.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae mf" href="https://markhavens.us" rel="noopener ugc nofollow" target="_blank">作者</a>的潜水截图。</figcaption></figure><p id="08a0" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">如果您向下滚动到最后一层，您将能够看到所有缺失的数据填充在右侧的树中。每个目录都复制了名为<code class="fe nd ne nf ng b">testfile1</code>、<code class="fe nd ne nf ng b">testfile2</code>和<code class="fe nd ne nf ng b">testfile3</code>的零字节文件。在最后一个版本中，一个名为<code class="fe nd ne nf ng b">hello</code>的63字节文件被复制到了<code class="fe nd ne nf ng b">/app</code>目录中。</p><p id="2fbe" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">现在，让我们找回那些文件！似乎没有办法直接从映像中复制文件，所以我们需要首先创建一个容器。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="eb77" class="nl ks it ng b gy nm nn l no np">$ docker run -td example3:latest<br/>6fdca182a128df7a76e618931c85a67e14a73adc69ad23782bc9a5dc29420a27</span></pre><p id="708e" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">现在，让我们使用从下面的Dive中恢复的路径和文件名将我们需要的文件从容器复制到主机。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="9956" class="nl ks it ng b gy nm nn l no np">/testdir1/testfile1<br/>/testdir2/testfile2<br/>/testdir3/testfile3<br/>/app/hello</span></pre><p id="79e7" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">我们可能首先检查我们的容器是否还在运行。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="4935" class="nl ks it ng b gy nm nn l no np">$ docker ps<br/>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br/>6fdca182a128        example3:latest     "/app/hello"        2 minutes ago       Up 2 minutes                            wizardly_lamport</span></pre><p id="fc1b" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">如果容器由于某种原因没有运行，那也没什么。我们可以验证它的状态，看它是否已停止。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="efe0" class="nl ks it ng b gy nm nn l no np">$ docker container ls -a</span></pre><p id="0fd3" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">我们也可以查看日志。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="d9f6" class="nl ks it ng b gy nm nn l no np">$ docker logs 6fdca182a128<br/>Hello, world!</span></pre><p id="812e" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">它似乎正在运行一个持久的<code class="fe nd ne nf ng b">Hello, world!</code>程序。实际上，在这种情况下，<code class="fe nd ne nf ng b">Hello, world!</code>程序并没有被设计成持久的。在Docker版本<code class="fe nd ne nf ng b">19.03.6</code>中，可能有一个错误阻止了应用程序正常终止。这暂时是可以接受的。容器可以是活动的或停止的；应用程序不需要持久化来恢复我们需要的任何数据。任何状态的容器只需要从我们提取数据的源图像中生成。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="b052" class="nl ks it ng b gy nm nn l no np">docker cp 6fdca182a128:/testdir1/testfile1 .<br/>docker cp 6fdca182a128:/testdir2/testfile2 .<br/>docker cp 6fdca182a128:/testdir3/testfile3 .<br/>docker cp 6fdca182a128:/app/hello .</span></pre><p id="d1b9" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">通过运行恢复的可执行文件来验证其行为，我们应该看到以下内容:</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="8eef" class="nl ks it ng b gy nm nn l no np">$ ./hello<br/>Hello, world!</span></pre><p id="a366" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">使用我们之前生成的<code class="fe nd ne nf ng b">Dockerfile</code>,我们可以更新它以包含所有新的细节。这包括将<code class="fe nd ne nf ng b">FROM</code>指令更新为<code class="fe nd ne nf ng b">scratch</code>，以及我们在使用Dive进行探索时发现的所有文件名。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="62a1" class="nl ks it ng b gy nm nn l no np">FROM scratch<br/>WORKDIR /testdir1<br/>COPY testfile1 .<br/>WORKDIR /testdir2<br/>COPY testfile2 .<br/>WORKDIR /testdir3<br/>COPY testfile3 .<br/>WORKDIR /app<br/>COPY hello .<br/>ENTRYPOINT ["/app/hello"]</span></pre><p id="d99b" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">同样，将所有文件合并到一个共享文件夹中，我们准备运行我们的逆向工程<code class="fe nd ne nf ng b">Dockerfile</code>。</p><p id="ac7c" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">首先，我们构建容器。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="b1a4" class="nl ks it ng b gy nm nn l no np">$ docker build . -t example3:recovered<br/>Sending build context to Docker daemon  4.608kB<br/>Step 1/10 : FROM scratch<br/> ---&gt;<br/>Step 2/10 : WORKDIR /testdir1<br/> ---&gt; Running in 5e8e47505ca6<br/>Removing intermediate container 5e8e47505ca6<br/> ---&gt; d30a2f002626<br/>Step 3/10 : COPY testfile1 .<br/> ---&gt; 4ac46077a588<br/>Step 4/10 : WORKDIR /testdir2<br/> ---&gt; Running in 8c48189da985<br/>Removing intermediate container 8c48189da985<br/> ---&gt; 7c7d90bc2219<br/>Step 5/10 : COPY testfile2 .<br/> ---&gt; 5b40d33100e1<br/>Step 6/10 : WORKDIR /testdir3<br/> ---&gt; Running in 4ccd634a04db<br/>Removing intermediate container 4ccd634a04db<br/> ---&gt; f89fdda8f059<br/>Step 7/10 : COPY testfile3 .<br/> ---&gt; 9542f614200d<br/>Step 8/10 : WORKDIR /app<br/> ---&gt; Running in 7614b0fdba42<br/>Removing intermediate container 7614b0fdba42<br/> ---&gt; 6d686935a791<br/>Step 9/10 : COPY hello .<br/> ---&gt; cd4baca758dd<br/>Step 10/10 : ENTRYPOINT ["/app/hello"]<br/> ---&gt; Running in 28a1ca58b27f<br/>Removing intermediate container 28a1ca58b27f<br/> ---&gt; 35dfd9240a2e<br/>Successfully built 35dfd9240a2e<br/>Successfully tagged example3:recovered</span></pre><p id="84a7" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">然后，我们运行它。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="a8c7" class="nl ks it ng b gy nm nn l no np">$ docker run --name recovered -dt example3:recovered<br/>0f696bf500267a996339b522cf584e010434103fe82497df2c1fa58a9c548f20<br/>$ docker logs recovered<br/>Hello, world!</span></pre><p id="a2e8" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">现在，为了进一步验证，让我们再次用Dive检查各层。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="920f" class="nl ks it ng b gy nm nn l no np">docker run --rm -it \<br/>    -v /var/run/docker.sock:/var/run/docker.sock \<br/>    wagoodman/dive:latest example3:recovered</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nv"><img src="../Images/fe20e983fd7cd78fdc73cbd8aa6560d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ooXaJsAUXr1D-p0UJSUrqg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae mf" href="https://markhavens.us" rel="noopener ugc nofollow" target="_blank">作者</a>的潜水截图。</figcaption></figure><p id="f251" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">此图像显示了与原始文件相同的文件。并排比较这两个图像，它们都显示它们是匹配的。两者显示相同的文件大小。两者的功能完全相同。</p><p id="c5d6" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">这里是用来生成原始<code class="fe nd ne nf ng b">example3</code>图像的原始<code class="fe nd ne nf ng b">Dockerfile</code>。</p><pre class="mh mi mj mk gt nh ng ni nj aw nk bi"><span id="994b" class="nl ks it ng b gy nm nn l no np">FROM alpine:3.9.2<br/>RUN apk add --no-cache nasm<br/>WORKDIR /app<br/>COPY hello.s /app/hello.s<br/>RUN touch testfile &amp;&amp; nasm -f bin -o hello hello.s &amp;&amp; chmod +x hello<br/><br/>FROM scratch<br/>WORKDIR /testdir1<br/>COPY --from=0 /app/testfile testfile1<br/>WORKDIR /testdir2<br/>COPY --from=0 /app/testfile testfile2<br/>WORKDIR /testdir3<br/>COPY --from=0 /app/testfile testfile3<br/>WORKDIR /app<br/>COPY --from=0 /app/hello hello<br/>ENTRYPOINT ["/app/hello"]```</span></pre><p id="7d7b" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">我们可以看到，虽然我们不能完美地重建它，但我们可以近似地重建它。没有办法重建像这样使用多阶段构建的docker文件。这些信息根本就不存在。我们唯一的选择是重建我们实际拥有的图像的docker文件。如果我们有早期构建阶段的映像，我们可以为每个映像复制一个docker文件，但是在这种情况下，我们只有最终的构建。但是不管怎样，我们仍然成功地从Docker图像中复制了一个有用的<code class="fe nd ne nf ng b">Dockerfile</code>。</p><h1 id="fa5a" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">未来的工作</h1><p id="c569" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">通过使用与Dive类似的方法，我们应该能够更新<a class="ae mf" href="https://github.com/mrhavens/Dedockify" rel="noopener ugc nofollow" target="_blank"> Dedockify </a>源代码，以自动跨越每一层，从而恢复所有有用的文件信息。此外，该程序可以更新，以便能够自动从容器中恢复文件并将它们存储在本地，同时还可以自动对<code class="fe nd ne nf ng b">Dockerfile</code>进行适当的更新。最后，该程序也可以更新，以便能够很容易地推断，如果基层是使用一个空的<code class="fe nd ne nf ng b">scratch</code>图像，或其他东西。通过对恢复的<code class="fe nd ne nf ng b">Dockerfile</code>语法进行一些额外的更改，<a class="ae mf" href="https://github.com/mrhavens/Dedockify" rel="noopener ugc nofollow" target="_blank"> Dedockify </a>可能会被更新，以在大多数情况下完全自动地将Docker映像反向工程为功能性的<code class="fe nd ne nf ng b">Dockerfile</code>。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="e7fa" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated"><em class="nq">作为Medium上的一名作者，</em> <a class="ae mf" href="https://mark-havens.medium.com/membership" rel="noopener"> <em class="nq">我邀请你成为会员</em> </a> <em class="nq">并获得我的故事集，以及成千上万其他天才作家写的故事。你的会员费直接支持我和你阅读的其他作家，并让你完全接触媒体上的每一个故事。</em></p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><figure class="mh mi mj mk gt ml gh gi paragraph-image"><a href="https://www.buymeacoffee.com/markrhavens"><div class="gh gi od"><img src="../Images/b9f343021730b934fc9b512529e7588b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4ajjFwLjKin4nxFuxFhkQ.png"/></div></a><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">如果你喜欢这篇文章，像你这样的粉丝再给我一杯咖啡，肯定会鼓励我再写一篇这样的文章。顺便来看看，打个招呼，让我知道你对可能想读的话题的想法。你可能是我需要写一些更棒的东西的灵感火花！</figcaption></figure></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="f092" class="kr ks it bd kt ku oe kw kx ky of la lb ki og kj ld kl oh km lf ko oi kp lh li bi translated">更新:2022年7月11日</h1><p id="e201" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在2020年疫情爆发时，我提出并被委托撰写上述的穿越。由 <a class="ae mf" href="https://appfleet.com/" rel="noopener ugc nofollow" target="_blank"> <em class="nq"> Appfleet </em> </a> <em class="nq">发布，并于2020年5月25日作为Appfleet博客</em>  <em class="nq">发布</em> <a class="ae mf" href="https://appfleet.com/blog/reverse-engineer-docker-images-into-dockerfiles-with-dedockify/" rel="noopener ugc nofollow" target="_blank"> <em class="nq">。</em> </a><a class="ae mf" href="https://havdevops.com/Reverse-Engineer-Docker-Images-into-Dockerfiles/" rel="noopener ugc nofollow" target="_blank"> <em class="nq">此Docker逆向工程文章的一个版本</em> </a> <em class="nq">也可以在</em> <a class="ae mf" href="https://havdevops.com" rel="noopener ugc nofollow" target="_blank"> <em class="nq">我的HavDevOps博客</em> </a> <em class="nq">上找到。我将上面更新的故事发布到Medium，只做了微小的编辑和格式更改。如果有人发现错误需要我的注意，请不吝赐教。</em></p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="03a2" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated"><a class="ae mf" href="https://markhavens.us/" rel="noopener ugc nofollow" target="_blank"> <em class="nq">马克·海文斯</em> </a> <em class="nq">是美国最大的全志愿者创客空间</em> <a class="ae mf" href="https://dallasmakercommunity.org/" rel="noopener ugc nofollow" target="_blank"> <em class="nq">达拉斯创客社区</em> </a> <em class="nq"> (DMC)的创始人兼执行董事，这是一个非营利性组织，旨在引导</em> <a class="ae mf" href="https://dallasmakerspace.org/" rel="noopener ugc nofollow" target="_blank"> <em class="nq">达拉斯创客空间</em> </a> <em class="nq">。DMC继续改革努力，为北德克萨斯州其他以创客为中心的组织提供以创客为中心的营销和创客空间领导力教育。</em></p></div></div>    
</body>
</html>