<html>
<head>
<title>Enforcing Semantic Versioning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实施语义版本控制</h1>
<blockquote>原文：<a href="https://itnext.io/enforcing-semantic-versioning-fcad774db7f0?source=collection_archive---------5-----------------------#2019-04-02">https://itnext.io/enforcing-semantic-versioning-fcad774db7f0?source=collection_archive---------5-----------------------#2019-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b7758efbb03d4ca76781443e6a70c451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCFSb0B46JWcokbtSlQPcw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://www.pexels.com/@rawpixel" rel="noopener ugc nofollow" target="_blank">rawpixel.com</a>发自<a class="ae kf" href="https://www.pexels.com/photo/two-person-shaking-each-others-hands-872957/" rel="noopener ugc nofollow" target="_blank">Pexels.com</a></figcaption></figure><blockquote class="kg kh ki"><p id="0cd4" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">合同<em class="it">名词</em>/ˇk ntrakt/</p><p id="b5e5" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">书面或口头协议，尤指关于雇佣、销售或租赁的协议，旨在通过法律强制执行。</p></blockquote><p id="35c8" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">大多数开发人员都熟悉<a class="ae kf" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a>的概念。当您从一个版本的代码更改到另一个版本的代码时，这是一个很好的方式，可以快速方便地通知用户会发生什么。本协议是您和您的消费者之间的合同。</p><p id="bed7" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">作为一名优秀的库开发人员，您同意:</p><ul class=""><li id="9050" class="ll lm it km b kn ko kr ks li ln lj lo lk lp lh lq lr ls lt bi translated">为你的代码提供合理的支持</li><li id="36c5" class="ll lm it km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">通知用户代码中的更改</li><li id="f23c" class="ll lm it km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">保持现有工作代码正常工作*</li></ul><p id="efdd" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">(*)库是变化的，有时不得不以不兼容的方式变化。这个决定不应该轻易做出。图书馆将通过遵循这些规则来培养善意。</p><p id="5c7a" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">我不介意库以不兼容的方式改变。我理解总是支持遗留代码的危险。我不能原谅的是图书馆对我撒谎。重大变更必须伴有重大版本号变更。</p><p id="1330" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">不管出于什么原因，一些开发人员对增加版本号犹豫不决。他们担心通过改变主要版本人们不会升级。他们没有意识到的是，在不改变版本的情况下破坏兼容性，必然会给他们的消费者带来更多的痛苦，而不是更少。</p><p id="601b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">不要害怕发布大量的主要版本。看看Chrome，我最后一次检查是在76版。</p><p id="a4ca" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">我也意识到没有人是完美的，我们都会犯错。我们都做过一些我们认为是向后兼容的改变，但实际上不是。</p><p id="bbb0" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">以这个Java变化为例:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9391" class="mi mj it me b gy mk ml l mm mn">&lt;     public static final String ID = "myID";<br/>---<br/>&gt;     public static final String ID = "myID2";</span></pre><p id="8202" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">这是向后兼容吗？大多数开发人员会不假思索地说是。事实上，它是兼容的API。不过，难道是<strong class="km iu">不是</strong> ABI兼容的。</p><p id="9cb5" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">Java <em class="kl">内嵌编译代码中的常量</em>。这意味着没有重新编译的旧代码将继续使用旧的<strong class="km iu">值，而不是新的值。</strong></p><p id="a521" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">分析一个API的向后兼容性并不是一项简单的任务。这通常需要开发人员熟练掌握语言的细节。即便如此，错误还是会发生。</p><p id="26ef" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">如果我们有办法在我们的API上实施语义版本规则就好了。</p><ul class=""><li id="bf9f" class="ll lm it km b kn ko kr ks li ln lj lo lk lp lh lq lr ls lt bi translated">需要时强制修改库，不允许开发者撒谎</li><li id="1088" class="ll lm it km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">确保总是以相同的方式检查所有向后兼容性规则</li><li id="8278" class="ll lm it km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">以可重复的方式快速完成这项工作，如果违反了规则，就中断构建</li></ul><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/5bf0d5ed9ac1fd1041314822799ccb01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sI03rFHDEkZttdKX43RDag.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自<a class="ae kf" href="https://www.pexels.com/photo/person-holding-black-pen-1109541/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kf" href="https://www.pexels.com/@lexovertoom?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Lex摄影</a></figcaption></figure><h1 id="88fb" class="mp mj it bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">工具作业</h1><p id="7ca0" class="pw-post-body-paragraph kj kk it km b kn nm kp kq kr nn kt ku li no kx ky lj np lb lc lk nq lf lg lh im bi translated">不正确的语义版本已经成为我们办公室的一个长期问题。我们需要一个自动化的解决方案来集成到我们的工作流程中。我们是一家利用Maven作为构建工具的Java商店。所以我去寻找一个可以集成到我们构建过程中的Maven插件。当我什么也没找到时，我很惊讶。我确实找到了一些命令行工具:</p><ul class=""><li id="93f9" class="ll lm it km b kn ko kr ks li ln lj lo lk lp lh lq lr ls lt bi translated"><a class="ae kf" href="https://github.com/lvc/japi-compliance-checker" rel="noopener ugc nofollow" target="_blank"> JAPICC </a></li><li id="ccf6" class="ll lm it km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated">Eclipse(仅用户界面)</li><li id="6d71" class="ll lm it km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated"><a class="ae kf" href="http://lvc.github.io/pkgdiff/" rel="noopener ugc nofollow" target="_blank"> PkgDiff </a></li><li id="884a" class="ll lm it km b kn lu kr lv li lw lj lx lk ly lh lq lr ls lt bi translated"><a class="ae kf" href="http://clirr.sourceforge.net/" rel="noopener ugc nofollow" target="_blank"> Clirr </a></li></ul><p id="e211" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">虽然Clirr提供了一个maven插件，但它似乎也是不活跃的，自2005年以来一直没有更新。PkgDiff是一个更通用的工具，它不显示类中的变化，也不确定变化是否向后兼容。</p><p id="e118" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">Eclipse实际上有一个基于Java的工具，用于在RCP应用程序中对OSGi包进行版本控制。它在Eclipse内部工作得很好，但在外部几乎不可能使用。尤其是在单个库上。</p><p id="0671" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">jap ICC—Java API Compliance Checker是一个相对活跃的perl脚本，最高支持Java 9。它产生了一个非常容易阅读的API和ABI兼容性报告。唯一真正的缺点是它是用perl编写的，而且没有可用的maven插件。</p><p id="294b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">直到现在…</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/2fd506ecfdc675b0be0fba5a96f873e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wf_GuI1Z5MYTOsweHeOwxw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://www.pexels.com/@chaikong2511?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Somchai Kongkamsri </a>从<a class="ae kf" href="https://www.pexels.com/photo/police-army-commando-special-task-force-20258/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</figcaption></figure><h1 id="7a87" class="mp mj it bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">如何使用</h1><p id="4532" class="pw-post-body-paragraph kj kk it km b kn nm kp kq kr nn kt ku li no kx ky lj np lb lc lk nq lf lg lh im bi translated">介绍<a class="ae kf" href="https://github.com/efenglu/japicc-plugin" rel="noopener ugc nofollow" target="_blank"> Maven JAPICC插件</a>。这个插件允许你在你的java项目上实施语义版本规则。</p><p id="a359" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">先决条件:</p><ol class=""><li id="aa47" class="ll lm it km b kn ko kr ks li ln lj lo lk lp lh ns lr ls lt bi translated">以前的工件必须可以通过Maven仓库获得</li><li id="6ca9" class="ll lm it km b kn lu kr lv li lw lj lx lk ly lh ns lr ls lt bi translated">构建环境必须安装Perl</li></ol><p id="a8f9" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">设置您的pom以启用插件:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2bce" class="mi mj it me b gy mk ml l mm mn">&lt;<strong class="me iu">plugin</strong>&gt;<br/>    &lt;<strong class="me iu">groupId</strong>&gt;io.github.efenglu.japicc&lt;/<strong class="me iu">groupId</strong>&gt;<br/>    &lt;<strong class="me iu">artifactId</strong>&gt;japicc-plugin&lt;/<strong class="me iu">artifactId</strong>&gt;<br/>    &lt;<strong class="me iu">version</strong>&gt;1.0.1&lt;/<strong class="me iu">version</strong>&gt;<br/>    &lt;<strong class="me iu">executions</strong>&gt;<br/>        &lt;<strong class="me iu">execution</strong>&gt;<br/>            &lt;<strong class="me iu">goals</strong>&gt;<br/>                &lt;<strong class="me iu">goal</strong>&gt;check&lt;/<strong class="me iu">goal</strong>&gt;<br/>            &lt;/<strong class="me iu">goals</strong>&gt;<br/>            &lt;<strong class="me iu">phase</strong>&gt;verify&lt;/<strong class="me iu">phase</strong>&gt;<br/>        &lt;/<strong class="me iu">execution</strong>&gt;<br/>    &lt;/<strong class="me iu">executions</strong>&gt;<br/>&lt;/<strong class="me iu">plugin</strong>&gt;</span></pre><p id="077f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">该插件将尝试在相同的主要系列中查找以前的构建工件。</p><p id="c4c0" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">例如，如果你正在开发版本2 . 4 . 3-快照，那么插件将检查2.4.2或它在Maven repo中找到的任何版本。这可能意味着版本2.4.1或2.4.0。</p><p id="7a04" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">如果它找不到以前的版本，它将认为这是一系列中的第一个版本，并跳过执行。</p><p id="dc57" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">默认情况下，该插件基本上忽略了<em class="kl"> micro </em>版本号，只是试图找到最新的版本号。例如，如果您将版本设置为2.4.5-SNAPSHOT，并且您的最后一个发布工件是2.4.2，那么插件会将当前的构建jar与版本2.4.2进行比较。</p><h1 id="fd36" class="mp mj it bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">它是如何工作的</h1><p id="5e41" class="pw-post-body-paragraph kj kk it km b kn nm kp kq kr nn kt ku li no kx ky lj np lb lc lk nq lf lg lh im bi translated">maven插件包含原始JAPICC Perl脚本的副本。当插件被调用时，它将:</p><ol class=""><li id="c193" class="ll lm it km b kn ko kr ks li ln lj lo lk lp lh ns lr ls lt bi translated">将先前发布的工件下载到您的本地maven存储库中</li><li id="1a8e" class="ll lm it km b kn lu kr lv li lw lj lx lk ly lh ns lr ls lt bi translated">将它与目标目录中构建的工件进行比较</li></ol><p id="40f3" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">该插件假设perl安装在/usr/bin/perl的典型位置。这可以在配置中更改。</p><p id="0887" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">你<strong class="km iu">不</strong>需要安装JAPICC。该插件会将工具和所有相关文件“安装”到一个临时位置。</p><p id="e6e8" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">根据perl脚本的返回代码，插件要么让构建失败，要么让构建通过。如果脚本失败，插件将输出报告的位置，并使构建失败。</p><p id="bc4b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">失败的报告看起来是这样的:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/826f71ca93547cd61e45f83d3a7c9b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hragcMvLGJ23OIOW7JLHWw.png"/></div></div></figure><h1 id="6076" class="mp mj it bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">后续步骤</h1><p id="2aa8" class="pw-post-body-paragraph kj kk it km b kn nm kp kq kr nn kt ku li no kx ky lj np lb lc lk nq lf lg lh im bi translated">如果能把perl脚本翻译成Java来消除对Perl的依赖，那就太好了。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="9d86" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">在以下位置签出插件源代码:</p><div class="ob oc gp gr od oe"><a href="https://github.com/efenglu/japicc-plugin" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">efenglu/jap ICC-插件</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">一个增强Java语义版本控制的Maven插件</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os jz oe"/></div></div></a></div></div></div>    
</body>
</html>