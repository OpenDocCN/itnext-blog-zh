<html>
<head>
<title>Clean architectures: Your benefits of using view controllers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净的架构:使用视图控制器的好处</h1>
<blockquote>原文：<a href="https://itnext.io/clean-architectures-your-benefits-of-using-view-controllers-7ce6b00f0ad5?source=collection_archive---------2-----------------------#2022-01-31">https://itnext.io/clean-architectures-your-benefits-of-using-view-controllers-7ce6b00f0ad5?source=collection_archive---------2-----------------------#2022-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b2df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视图控制器提供了一种简单明了的方法来将业务逻辑从组件中分离出来。</p><h1 id="8584" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">内容</h1><ol class=""><li id="5b88" class="lj lk iq jp b jq ll ju lm jy ln kc lo kg lp kk lq lr ls lt bi translated">演示应用程序</li><li id="42d8" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">没有视图控制器的演示主视图</li><li id="156b" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">使用视图控制器演示主视图</li><li id="0ef5" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">视图控制器逻辑</li><li id="f96a" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">摘要</li></ol><h1 id="0bf2" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.演示应用程序</h1><p id="ef54" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">演示应用程序相当简单，在我的上一篇文章中有所介绍:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/intercepting-component-state-to-ensure-smooth-animated-transitions-4facd46414dd"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">截取组件状态以确保平滑的动画转换</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">剧透:这篇文章中的全部代码可以直接在你的浏览器中运行(不需要任何编译)</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">itnext.io</p></div></div><div class="mv l"><div class="mw l mx my mz mv na nb mm"/></div></div></a></div><p id="5737" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您对内部业务逻辑感到好奇，请随意深入研究这一点。但是，并不要求遵循这篇文章。</p><h1 id="76ab" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">2.没有视图控制器的演示主视图</h1><p id="3540" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">让我们先看看不使用视图控制器的MainContainer实现:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="nc mi l"/></div></figure><p id="b03c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们愿意，我们可以在类的<code class="fe nd ne nf ng b">construct()</code>方法中设置我们的配置。由于<code class="fe nd ne nf ng b">getConfig()</code>是一个静态方法，我们无法访问它内部的<code class="fe nd ne nf ng b">this</code>指针。在构造(or)中，我们现在可以将事件侦听器直接映射到该范围内的方法。</p><p id="4bdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种技术本身可以很好地创建组件，但是一旦我们创建了一个应用程序，我们就希望在我们的视图和业务相关逻辑之间有一个清晰的分离。</p><h1 id="b9ae" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">3.使用视图控制器演示主视图</h1><p id="266d" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">让我们在添加了视图控制器之后再来看一下同一个视图:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="nc mi l"/></div></figure><p id="38e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们导入了一个新的视图控制器类，并简单地将模块添加为控制器配置。</p><p id="2287" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用字符串(方法的名称)替换了所有的事件侦听器。因为我们移除了<code class="fe nd ne nf ng b">items</code>定义中所有出现的<code class="fe nd ne nf ng b">this</code>指针，现在我们可以将它直接移到静态<code class="fe nd ne nf ng b">getConfig()</code>方法中。</p><p id="b141" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视图控制器是可选的，这意味着:并不是每个视图都需要一个视图控制器。</p><p id="decc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">框架会将基于字符串的方法名与实现它的父树中最近的视图控制器进行匹配。</p><p id="ad1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">提示</strong>:你应该总是尽量在组件(和控制器)树的底层定义你的实现。但是，您可以向上移动逻辑，以防减少冗余(意思是:如果同级控制器包含相同的逻辑，请将其向上移动)。</p><p id="0ed3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">提示2 </strong>:我们还在组合中添加了参考配置。这些可以从父链中的任何视图控制器中访问。这是让它们保持独特的一个好理由。</p><h1 id="9f8c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">4.视图控制器逻辑</h1><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="nc mi l"/></div></figure><p id="aa16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逻辑本身的工作等同于不使用视图控制器的实现。</p><p id="b465" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在使用<code class="fe nd ne nf ng b">this.getReference()</code>来访问组件，而不是手动使用组件查询。</p><p id="3284" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有了业务逻辑和视图定义的清晰分离。</p><h1 id="7d6d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">5.摘要</h1><p id="9073" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">为了在框架层次上创建复杂的组件，我尽量避免使用视图控制器。即使它变得像日历实现一样复杂:<a class="ae nh" href="https://github.com/neomjs/neo/tree/dev/src/calendar" rel="noopener ugc nofollow" target="_blank"> src/calendar </a></p><p id="54fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于创建应用程序，我真的很喜欢使用它们:<a class="ae nh" href="https://github.com/neomjs/neo/tree/dev/apps/covid" rel="noopener ugc nofollow" target="_blank">应用程序/covid </a></p><p id="f9dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视图控制器可以很容易地与可选的视图模型(状态提供者)相结合，这使得它们更加强大。请给我一个提示，如果你想读更多关于这方面的内容。</p><p id="072b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我谈论事件时，我指的不是基于DOM的事件，而是自定义的<strong class="jp ir">可观察的</strong>实现。</p><p id="9f49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于基于neo的范围，您的应用程序和组件存在于应用程序工作器中，遵循“应用程序工作器是主要参与者”的设计模式:</p><div class="mj mk gp gr ml mm"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">GitHub - neomjs/neo:应用工人驱动的前端框架</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序。不需要照顾一个…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">github.com</p></div></div><div class="mv l"><div class="ni l mx my mz mv na nb mm"/></div></div></a></div><p id="7737" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问候&amp;快乐编码，<br/>托拜厄斯</p><p id="bb31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预览图像:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/eea2d2f97631d64843b59d64fb9f9095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iagWjGsprh-0RezZZRHFNw.png"/></div></div></figure></div></div>    
</body>
</html>