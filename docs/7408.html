<html>
<head>
<title>Native Form Validation Of Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件的本机形式验证</h1>
<blockquote>原文：<a href="https://itnext.io/native-form-validation-of-web-components-a599e85176c7?source=collection_archive---------2-----------------------#2022-09-14">https://itnext.io/native-form-validation-of-web-components-a599e85176c7?source=collection_archive---------2-----------------------#2022-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b575" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单、自然的表单验证指南</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5dca7c2697090214e7e2305da704eedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GtHl-mVCPwK5enSF"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@olloweb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">通讯社跟随</a>于<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="a2b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的上一篇文章“Web组件现在可以成为本地表单元素”中，我解释了如何使用<code class="fe lf lg lh li b">ElementInternals</code>对象让Web组件像其他本地表单元素一样参与表单。</p><p id="04d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我将解释如何使用本机平台轻松验证这些自定义表单控件</p><h1 id="411d" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">原生形式验证</h1><p id="20f3" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">在web上使用表单的一个关键部分是验证:检查用户提供的输入是否是我们期望的，如果不是，则向用户显示反馈。</p><p id="cbd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，当您提供自定义表单控件时，它应该像任何本机表单控件一样参与此表单验证。</p><p id="9f08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然有很多库可以实现这一点，但是native platform已经提供了验证表单所需的所有工具。</p><h1 id="5185" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">限制</h1><p id="ec2c" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">要验证一个表单，首先需要定义一个表单控件是有效还是无效。换句话说，你需要为控件设置约束<em class="mm">。</em></p><p id="8719" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，您可以定义一个字段是否是必需的，或者它的数据是否应该是某种类型或者有一个最大长度。</p><p id="2fa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">若要设置这些约束，可以在表单控件上设置下列验证属性:</p><p id="95b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">- <code class="fe lf lg lh li b">required</code>:指定字段是否必须填写<br/> - <code class="fe lf lg lh li b">minlength</code>和<code class="fe lf lg lh li b">maxlength</code>:指定字段文本的最小和最大长度<br/> - <code class="fe lf lg lh li b">min</code>和<code class="fe lf lg lh li b">max</code>:指定字段的最小和最大数值<br/> - <code class="fe lf lg lh li b">type</code>:指定字段的数据是否需要特定类型(数字、文本、URL、电子邮件等)。)<br/> - <code class="fe lf lg lh li b">pattern</code>:指定字段数据必须遵循的模式的正则表达式</p><p id="30cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下示例显示了一个必需的输入，该输入采用文本类型的数据，长度应在5到20个字符之间，并且仅由字母组成:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="ef7e" class="mr lk it li b gy ms mt l mu mv">&lt;input <br/>  type=”text”<br/>  required<br/>  minlength=”5"<br/>  maxlength=”20"<br/>  pattern=”[a-zA-Z]+”&gt;</span></pre><p id="d34f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要确定一个字段是否满足其所有的验证约束，您可以检查其返回一个<code class="fe lf lg lh li b">ValidityState</code>对象的<code class="fe lf lg lh li b">validity</code>属性。</p><p id="4928" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<code class="fe lf lg lh li b">ValidityState</code>对象有一个<code class="fe lf lg lh li b">valid</code>属性，指示该字段是否满足其所有验证约束(<code class="fe lf lg lh li b">true</code>或<code class="fe lf lg lh li b">false</code>)。</p><p id="451f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他属性也是布尔值，指示字段不能用值“真”验证的原因:</p><p id="e606" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">- <code class="fe lf lg lh li b">valueMissing</code> : <code class="fe lf lg lh li b">true</code>当字段有<code class="fe lf lg lh li b">required</code>属性但没有值<br/> - <code class="fe lf lg lh li b">typeMismatch</code> : <code class="fe lf lg lh li b">true</code>当数据的语法不正确时， 例如当<code class="fe lf lg lh li b">type</code>为<code class="fe lf lg lh li b">email</code>但值不是有效的电子邮件地址<br/> - <code class="fe lf lg lh li b">tooShort</code> : <code class="fe lf lg lh li b">true</code>当字段具有<code class="fe lf lg lh li b">minlength</code>属性且数据长度小于该属性的值<br/> - <code class="fe lf lg lh li b">tooLong</code> : <code class="fe lf lg lh li b">true</code>当字段具有<code class="fe lf lg lh li b">maxlength</code>属性且数据长度大于该属性的值<br/> - <code class="fe lf lg lh li b">rangeUnderflow</code> : <code class="fe lf lg lh li b">true</code>当字段具有<code class="fe lf lg lh li b">min</code>属性且 当字段具有<code class="fe lf lg lh li b">max</code>属性时，该字段的数值小于该属性<br/> - <code class="fe lf lg lh li b">rangeOverflow</code> : <code class="fe lf lg lh li b">true</code>的值；当字段具有<code class="fe lf lg lh li b">pattern</code>属性时，该字段的数值大于该属性<br/> - <code class="fe lf lg lh li b">patternMismatch</code> : <code class="fe lf lg lh li b">true</code>的值，但当使用<code class="fe lf lg lh li b">setCustomValidity</code>设置自定义错误信息时，该字段的数据不遵循此模式<br/> - <code class="fe lf lg lh li b">customError</code> : <code class="fe lf lg lh li b">true</code></p><p id="17e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当字段无效时，它将抛出一个<code class="fe lf lg lh li b">invalid</code>事件，并被CSS <code class="fe lf lg lh li b">:invalid</code>伪类选中。</p><p id="65a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，您可以用它给字段添加红色边框和红色文本:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="76fa" class="mr lk it li b gy ms mt l mu mv">input:invalid {<br/>  border:1px solid red;<br/>  color: red;<br/>}</span></pre><h1 id="ff9a" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">验证错误消息</h1><p id="96d0" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">有了一些约束，现在当提交表单时，表单输入将被验证，浏览器将显示一个默认的错误消息。</p><p id="9344" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，当具有“必填”属性的字段没有值并且表单被提交时，在Chrome和Safari中显示以下消息:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/66d697a3cf1b28142abcfd151e976eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*1aMwTqvw8PyN1PNRXnM0sw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Chrome中的本机验证错误消息</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/b2961521ec3f40c23ff9ea6bceb92787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*mCHOna-88E5tV05L7ohYag.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Safari中的本机验证错误信息</figcaption></figure><p id="a166" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">错误消息的文本和样式在不同的浏览器中是不一致的，但是幸运的是，您可以同时更改这两者。</p><p id="e022" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要更改错误消息的文本，您可以使用字段的<code class="fe lf lg lh li b">setCustomValidity()</code>方法，该方法将错误消息作为唯一的参数:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="36f3" class="mr lk it li b gy ms mt l mu mv">const form = document.querySelector(‘form’);<br/>const field = form.elements[0];</span><span id="8768" class="mr lk it li b gy mx mt l mu mv">field.setCustomValidity(‘You forgot to fill in this field.’);</span></pre><p id="b710" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，错误消息将显示您指定的文本:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d186b235155da406faa123498630afb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*rc6KfrignM_yy6-UfgWPDQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Chrome中的自定义验证错误消息</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/919d51e581f958c423e1c49992cc41bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*wh4Deq4nuNkFzXDfd3y03w.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Safari中的自定验证错误信息</figcaption></figure><h1 id="431b" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><code class="fe lf lg lh li b">invalid"</code>事件</h1><p id="ee44" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">要显示您的自定义错误消息，您可以挂钩到<code class="fe lf lg lh li b">invalid</code>事件，该事件在表单提交时为每个无效的表单元素触发。</p><p id="a9d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，如果您不需要自定义错误信息，并且对浏览器提供的默认错误信息感到满意，则不需要设置此事件处理程序。</p><p id="cd79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提交表单时，将自动验证定义了约束的表单域，并为任何无效的表单域显示默认的错误消息。</p><p id="b4e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从编写该事件的处理程序开始:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="2d6b" class="mr lk it li b gy ms mt l mu mv">const invalidHandler = (e) =&gt; {<br/>  const field = e.target;<br/>  const validState = field.validity;</span><span id="3898" class="mr lk it li b gy mx mt l mu mv"> if(!validState.valid) {<br/>   field.setCustomValidity(‘This field is not valid.’);<br/> }<br/>};</span></pre><p id="c7e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，消息“此字段无效”有点太普通，没有告诉用户<em class="mm">为什么</em>字段无效，但是我们可以改变它。</p><p id="cd68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回想一下，如果定义了适当的约束，字段的<code class="fe lf lg lh li b">ValidityState</code>对象包含字段无效的原因。</p><p id="61e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用它来确定字段无效的原因，并显示正确的错误消息:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="e207" class="mr lk it li b gy ms mt l mu mv">const invalidHandler = (e) =&gt; {<br/>  const field = e.target;<br/>  const validState = field.validity;</span><span id="5ccb" class="mr lk it li b gy mx mt l mu mv">  // all possible error messages<br/>  const errorMessages = {<br/>    valueMissing: ‘This field is required’,<br/>    tooShort: ‘This value is too short’,<br/>    tooLong: ‘This value is too long’,</span><span id="549e" class="mr lk it li b gy mx mt l mu mv">    …<br/>  };</span><span id="51b8" class="mr lk it li b gy mx mt l mu mv">  if(!validState.valid) {<br/>    // loop through the error reasons<br/>    for(let state in validState) {<br/>      // find the first error reason with value “true”<br/>      if(validState[state]) {<br/>        // select the correct message for the error<br/>        const errorMessage = errorMessages[state];<br/>        field.setCustomValidity(errorMessage);<br/>      }<br/>    }<br/>  }<br/>};</span></pre><p id="153c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，可能的错误信息存储在<code class="fe lf lg lh li b">errorMessages</code>对象中。</p><p id="d86a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们遍历存储在<code class="fe lf lg lh li b">validState</code>变量中的字段的<code class="fe lf lg lh li b">validity</code>属性中的错误原因。</p><p id="8a0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当用值<code class="fe lf lg lh li b">true</code>找到原因时，选择并显示错误信息。</p><p id="b594" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这样做是可行的，但它将验证逻辑与现在硬编码到其中的错误消息紧密耦合在一起。</p><p id="da9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更好的解决方案是将可能的错误信息存储在属性中。这样，可以在表单控件本身上指定消息，并且验证逻辑仍然是通用的。</p><p id="dfc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，您可以将错误消息存储在<code class="fe lf lg lh li b">data</code>属性中。</p><p id="5dfb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">required</code>字段的<em class="mm">缺少</em>值的错误消息可以存储在<code class="fe lf lg lh li b">data-valueMissing</code>属性中，因此可以像前面的例子一样选择正确的消息:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="47a7" class="mr lk it li b gy ms mt l mu mv">&lt;input<br/>  type=”text”<br/>  required<br/>  data-valuemissing=”This field is required”&gt;</span></pre><p id="028c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后选择正确的错误消息，如下所示:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="c9d1" class="mr lk it li b gy ms mt l mu mv">const invalidHandler = (e) =&gt; {<br/>  const field = e.target;<br/>  const validState = field.validity;</span><span id="42e0" class="mr lk it li b gy mx mt l mu mv">  if(!validState.valid) {<br/>    // loop through the error reasons<br/>    for(let state in validState) {<br/>      // get the attribute name of the message for this error reason<br/>      const attr = `data-${state.toString()}`;</span><span id="20b7" class="mr lk it li b gy mx mt l mu mv">      // if this error reason has the value “true”<br/>      if(validState[state]) { <br/>        // get the error message from the attribute is it's present,<br/>        // otherwise get the native error message<br/>        const errorMessage = field.hasAttribute(attr) ?<br/>          field.getAttribute(attr) : field.validationMessage;<br/>        field.setCustomValidity(errorMessage);</span><span id="3b7a" class="mr lk it li b gy mx mt l mu mv">        break;<br/>      }<br/>    }<br/>  }<br/>};</span></pre><p id="bbf1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，您可以为其他表单控件指定不同的错误信息:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="3bad" class="mr lk it li b gy ms mt l mu mv">&lt;input <br/>  type=”number” <br/>  name=”age” <br/>  min=”18" <br/>  max=”40" <br/>  required<br/>  data-valuemissing=”Please fill in your age”<br/>  data-rangeunderflow=”You must be at least 18 years old”<br/>  data-rangeoverflow=”The maximum allowed age is 40"<br/>&gt;</span></pre><p id="67a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，该行:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="07cf" class="mr lk it li b gy ms mt l mu mv">const attr = `data-${state.toString()}` </span></pre><p id="ada4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构造类似于<code class="fe lf lg lh li b">data-valueMissing</code>(骆驼大小写)的属性名，而属性本身是<code class="fe lf lg lh li b">data-valuemissing</code>(小写)。</p><p id="1264" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为属性不区分大小写，所以两者都可以。</p><p id="44fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在唯一剩下的事情就是为每个无效的表单字段调用<code class="fe lf lg lh li b">invalidHandler</code>函数。</p><p id="5a2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以通过获取表单的<code class="fe lf lg lh li b">elements</code>属性中的所有表单字段并循环遍历它们以在每个字段上设置一个<code class="fe lf lg lh li b">invalid</code>事件处理程序来实现这一点。</p><p id="ede7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您首先将<code class="fe lf lg lh li b">elements</code>转换成一个数组，那么您可以用<code class="fe lf lg lh li b">forEach</code>遍历它:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="6931" class="mr lk it li b gy ms mt l mu mv">const form = document.querySelector(‘form’);</span><span id="a803" class="mr lk it li b gy mx mt l mu mv">// convert to an array<br/>const fields = […form.elements];</span><span id="03dd" class="mr lk it li b gy mx mt l mu mv">fields.forEach(field =&gt; <br/>  field.addEventListener(‘invalid’, invalidHandler));</span></pre><p id="b267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在将为每个无效的表单域调用事件处理程序，显示相应的错误消息。</p><h1 id="0778" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">验证Web组件</h1><p id="c122" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">为了与您的定制元素一起工作，您需要将<code class="fe lf lg lh li b">ElementInternals</code>对象附加到它，并添加以下方法:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="712d" class="mr lk it li b gy ms mt l mu mv">constructor() {<br/>  super();<br/>  this.#internals = this.attachInternals();<br/>}</span><span id="3c45" class="mr lk it li b gy mx mt l mu mv">// add the following methods to make your Custom Element participate // in form validation<br/>get validity() {<br/>  return this.internals.validity;<br/>}</span><span id="d47e" class="mr lk it li b gy mx mt l mu mv">get validationMessage() {<br/>  return this.internals.validationMessage;<br/>}</span><span id="596e" class="mr lk it li b gy mx mt l mu mv">get willValidate() {<br/>  return this.internals.willValidate;<br/>}</span><span id="bc9b" class="mr lk it li b gy mx mt l mu mv">checkValidity() {<br/>  return this.internals.checkValidity();<br/>}</span><span id="4af6" class="mr lk it li b gy mx mt l mu mv">reportValidity() {<br/>  return this.internals.reportValidity();<br/>}</span></pre><p id="5c02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要这些方法来确保您的自定义元素可以参与表单验证。</p><p id="9555" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，这不会导致您的自定义元素被报告为无效。</p><p id="68d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将需要使用<code class="fe lf lg lh li b">ElementInternals</code>对象的<code class="fe lf lg lh li b">setValidity</code>方法来明确指出您的元素是有效还是无效。</p><p id="306f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们假设我们有一个带有以下阴影DOM的自定义元素:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="4f3f" class="mr lk it li b gy ms mt l mu mv">&lt;style&gt;<br/>  :host {<br/>    display: inline-block;<br/>  }</span><span id="17d6" class="mr lk it li b gy mx mt l mu mv">  input {<br/>    padding: 5px;<br/>  }<br/>&lt;/style&gt;</span><span id="1ee4" class="mr lk it li b gy mx mt l mu mv">&lt;input type=”text”&gt;</span></pre><p id="5797" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为您的定制元素内部有一个<code class="fe lf lg lh li b">&lt;input&gt;</code>元素，所以您的元素的有效性来自内部<code class="fe lf lg lh li b">&lt;input&gt;</code>的有效性。</p><p id="cb92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着您需要在两种情况下将您的自定义元素的有效性设置为内部<code class="fe lf lg lh li b">&lt;input&gt;</code>的有效性:</p><p id="1651" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-当您的自定义元素第一次添加到页面<br/>时-每当内部<code class="fe lf lg lh li b">&lt;input&gt;</code>的值改变时</p><p id="4f8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您的元素在<code class="fe lf lg lh li b">connectedCallback</code>生命周期方法中添加到页面时，以及当<code class="fe lf lg lh li b">&lt;input&gt;</code>的值在<code class="fe lf lg lh li b">change</code>事件处理程序中发生变化时，您可以设置有效性。</p><p id="c47b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以为此编写一个<code class="fe lf lg lh li b">validateInput()</code>方法，它与我们之前编写的<code class="fe lf lg lh li b">invalidHandler</code>非常相似:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="c9f6" class="mr lk it li b gy ms mt l mu mv">validateInput() {<br/>  // get the validity of the internal &lt;input&gt; that is stored in the <br/>  // property `#inputNode`<br/>  const validState = this.#inputNode.validity;<br/><br/>  this.invalid = !this.pristine &amp;&amp; !validState.valid;<br/><br/>  // if the input is invalid, show the correct error<br/>  if(!validState.valid) {<br/>    // loop through the error reasons<br/>    for(let state in validState) {<br/><br/>      // get the name of the data attribute that holds the <br/>      // error message<br/>      const attr = `data-${state.toString()}`;<br/><br/>      // if there is an error<br/>      if(validState[state]) {<br/>        this.validationError = state.toString();<br/><br/>        // get either the custom of native error message<br/>        const errorMessage = this.hasAttribute(attr) ? this.getAttribute(attr) : this.#inputNode.validationMessage;<br/><br/>        // set the validity error reason and the corresponding <br/>        // message<br/>        this.#internals.setValidity({[this.validationError]: true}, errorMessage);<br/>      }<br/>    }<br/>  }<br/>  else {<br/>    this.#internals.setValidity({});<br/>  }<br/>}</span></pre><p id="10e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们检查内部<code class="fe lf lg lh li b">&lt;input&gt;</code>的有效性，如果无效，我们检查在<code class="fe lf lg lh li b">data</code>属性中是否定义了相应的错误消息。</p><p id="5410" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果发现错误，将使用正确的错误原因和相应的错误消息来设置自定义元素的有效性。</p><p id="0e5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，只有在内部<code class="fe lf lg lh li b">&lt;input&gt;</code>上设置了任何约束条件(<code class="fe lf lg lh li b">required</code>、<code class="fe lf lg lh li b">min</code>、<code class="fe lf lg lh li b">max</code>等)时，内部<code class="fe lf lg lh li b">&lt;input&gt;</code>的有效性才会被设置。)</p><p id="8a2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这些约束是在定制元素本身上设置的，所以它们也需要在<code class="fe lf lg lh li b">&lt;input&gt;</code>上设置。</p><p id="ee14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以通过从您的定制元素中获取每个属性并将它们设置为内部<code class="fe lf lg lh li b">&lt;input&gt;</code>的属性来实现这一点。</p><p id="1f1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们用我们需要的属性名创建一个数组，并对它们进行循环。</p><p id="6560" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于内部的<code class="fe lf lg lh li b">&lt;input&gt;</code>也需要自定义元素中的<code class="fe lf lg lh li b">value</code>、<code class="fe lf lg lh li b">type</code>和<code class="fe lf lg lh li b">placeholder</code>，我们也将添加它们:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="eb50" class="mr lk it li b gy ms mt l mu mv">[<br/>  ‘type’,<br/>  ‘value’,<br/>  ‘placeholder’,<br/>  'autocomplete',<br/>  ‘required’,<br/>  ‘min’,<br/>  ‘max’,<br/>  ‘minlength’,<br/>  ‘maxlength’,<br/>  ‘pattern’<br/>].forEach((attr) =&gt; {<br/>    // ‘required’ is a boolean attribute without a value so we use <br/>    // ‘hasAttribute’<br/>    const attrValue = attr === ‘required’ ? <br/>      this.hasAttribute(attr) : this.getAttribute(attr);</span><span id="2da0" class="mr lk it li b gy mx mt l mu mv">    if(attrValue !== null) {<br/>      this.input[attr] = attrValue;<br/>    }<br/>  });</span></pre><p id="2f49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在唯一剩下的事情就是在<code class="fe lf lg lh li b">connectedCallback</code>内部调用<code class="fe lf lg lh li b">this.validateInput()</code>以及在内部<code class="fe lf lg lh li b">&lt;input&gt;</code>的<code class="fe lf lg lh li b">change</code>事件处理程序内部调用。</p><p id="d7d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们把这些放在一起:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="a590" class="mr lk it li b gy ms mt l mu mv">class FormInput extends HTMLElement {<br/>  static formAssociated = true;</span><span id="a099" class="mr lk it li b gy mx mt l mu mv">  constructor() {<br/>    super();<br/>    this.internals = this.attachInternals();</span><span id="c114" class="mr lk it li b gy mx mt l mu mv">    const shadowRoot = this.attachShadow({mode: ‘open’});</span><span id="9e37" class="mr lk it li b gy mx mt l mu mv">    shadowRoot.innerHTML = `<br/>      &lt;style&gt;<br/>        :host {<br/>          display: inline-block;<br/>        }</span><span id="62bc" class="mr lk it li b gy mx mt l mu mv">        input {<br/>          display: block;<br/>          padding: 5px;<br/>        }<br/>      &lt;/style&gt;</span><span id="72a3" class="mr lk it li b gy mx mt l mu mv">      &lt;input type=”text”&gt;<br/>    `;<br/>    }</span><span id="d0cf" class="mr lk it li b gy mx mt l mu mv">  connectedCallback() {<br/>    this.input = this.shadowRoot.querySelector(‘input’);</span><span id="0c5b" class="mr lk it li b gy mx mt l mu mv">// set the required properties (constraints) on the internal <br/>    // &lt;input&gt;<br/>    [<br/>      'type’,<br/>      ‘value’,<br/>      ‘placeholder’,<br/>      ‘required’,<br/>      ‘min’,<br/>      ‘max’,<br/>      ‘minLength’, // &lt;-- camelCase!<br/>      ‘maxLength’, // &lt;-- camelCase!<br/>      ‘pattern’<br/>    ].forEach((attr) =&gt; {<br/>        const attrValue = attr === ‘required’ ?          <br/>          this.hasAttribute(attr) : this.getAttribute(attr);</span><span id="d349" class="mr lk it li b gy mx mt l mu mv">          this.input[attr] = attrValue;<br/>       });</span><span id="f7ab" class="mr lk it li b gy mx mt l mu mv">    this.input.addEventListener(‘change’, (e) =&gt; {<br/>       // we also want to dispatch a `change` event from <br/>       // our custom element<br/>       const clone = new e.constructor(e.type, e);<br/>       this.dispatchEvent(clone);</span><span id="29b6" class="mr lk it li b gy mx mt l mu mv">       // set the element’s validity whenever the value of the <br/>       // &lt;input&gt; changes<br/>       this.validateInput();<br/>    });</span><span id="8986" class="mr lk it li b gy mx mt l mu mv">    this.addEventListener(‘focus’, () =&gt; this.input.focus());</span><span id="3be1" class="mr lk it li b gy mx mt l mu mv">    if (!this.hasAttribute(‘tabindex’)) {<br/>      this.setAttribute(‘tabindex’, ‘0’);<br/>    }</span><span id="7c32" class="mr lk it li b gy mx mt l mu mv">    // set the initial validity of the component<br/>    this.validateInput();<br/>  }</span><span id="103b" class="mr lk it li b gy mx mt l mu mv">  get value() {<br/>    return this.input.value;<br/>  }</span><span id="441a" class="mr lk it li b gy mx mt l mu mv">  set value(value) {<br/>    this.input.value = value;<br/>    this.internals.setFormValue(value);<br/>  }</span><span id="13a4" class="mr lk it li b gy mx mt l mu mv">  get form() {<br/>    return this.internals.form;<br/>  }<br/> <br/>  get name() {<br/>    return this.getAttribute(‘name’);<br/>  }<br/> <br/>  get type() {<br/>    return this.localName;<br/>  }</span><span id="2b93" class="mr lk it li b gy mx mt l mu mv">  get validity() {<br/>    return this.internals.validity;<br/>  }</span><span id="70f0" class="mr lk it li b gy mx mt l mu mv">  get validationMessage() {<br/>    return this.internals.validationMessage;<br/>  }</span><span id="e418" class="mr lk it li b gy mx mt l mu mv">  get willValidate() {<br/>    return this.internals.willValidate;<br/>  }</span><span id="915b" class="mr lk it li b gy mx mt l mu mv">  checkValidity() {<br/>    return this.internals.checkValidity();<br/>  }</span><span id="43cd" class="mr lk it li b gy mx mt l mu mv">  reportValidity() {<br/>    return this.internals.reportValidity();<br/>  }</span><span id="4c79" class="mr lk it li b gy mx mt l mu mv">  validateInput() {<br/>    // get the validity of the internal &lt;input&gt;<br/>    const validState = this.input.validity;</span><span id="a6c7" class="mr lk it li b gy mx mt l mu mv">    // if the input is invalid, show the correct error<br/>    if(!validState.valid) {<br/>      // loop through the error reasons<br/>      for(let state in validState) {</span><span id="c90c" class="mr lk it li b gy mx mt l mu mv">        // get the name of the data attribute that holds the <br/>        //error message<br/>        const attr = `data-${state.toString()}`;</span><span id="f6da" class="mr lk it li b gy mx mt l mu mv">        // if there is an error and corresponding attribute holding <br/>        // the message<br/>        if(validState[state]) {<br/>          this.validationError = state.toString();<br/> <br/>          // get the correct error message<br/>          const errorMessage = this.hasAttribute(attr) ? <br/>            this.getAttribute(attr) : this.input.validationMessage;</span><span id="1607" class="mr lk it li b gy mx mt l mu mv">          // set the validity error reason and the corresponding <br/>          // message<br/>          this.internals.setValidity(<br/>            {[this.validationError]: true},    <br/>            errorMessage<br/>          );<br/>        }<br/>      }<br/>   }<br/>   else {<br/>     this.internals.setValidity({});<br/>   }<br/> }<br/>}</span></pre><h1 id="1b94" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">自定义错误信息的样式</h1><p id="ead0" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">正如您之前看到的，每个浏览器的本机错误消息的样式是不同的，不幸的是，没有办法使用CSS来样式化这些错误消息。</p><p id="ffae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，您可以使用相同的本机验证逻辑以自定义样式显示错误信息。</p><p id="dbcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着不会显示本机错误消息，但相同的错误文本将显示为您选择的HTML元素。</p><p id="0185" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了防止显示本地错误消息，您需要调用由您的定制元素抛出的<code class="fe lf lg lh li b">invalid</code>事件的<code class="fe lf lg lh li b">preventDefault()</code>方法。</p><p id="38e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以通过简单地在自己的定制元素中设置一个<code class="fe lf lg lh li b">invalid</code>事件处理程序来做到这一点:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="7ab8" class="mr lk it li b gy ms mt l mu mv">this.addEventListener('invalid', (e) =&gt; {<br/>  this.invalid = true;<br/><br/>  // when a custom error needs to be displayed, prevent the native <br/>  // error from showing<br/>  if(this.customErrorDisplay) {<br/>    e.preventDefault();<br/>  }<br/>});</span></pre><p id="14dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还需要能够设置是否想要显示自定义错误。您可以通过设置一个属性来做到这一点，例如<code class="fe lf lg lh li b">custom-error-display</code>，并读取该属性以确定属性<code class="fe lf lg lh li b">this.customErrorDisplay</code>的值，该属性在前面的示例中使用:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="6c0e" class="mr lk it li b gy ms mt l mu mv">get customErrorDisplay() {<br/>  return this.hasAttribute('custom-error-display');<br/>}</span></pre><p id="52bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，本地错误消息将不会显示，但是字段的有效性仍然被设置，错误消息本身将出现在字段的<code class="fe lf lg lh li b">validationMessage</code>属性中。</p><p id="9f73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您可以使用该属性的值(错误消息)，将它放入一个HTML元素中，如<code class="fe lf lg lh li b">&lt;div&gt;</code>或<code class="fe lf lg lh li b">&lt;span&gt;</code>，并在您想要的任何地方显示它。</p><p id="f8b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您可以将任何CSS应用到您想要的这个元素，并且您有一个完全可样式化的错误消息。</p><p id="52e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的例子中，创建了一个带有<code class="fe lf lg lh li b">class</code>“错误消息”的<code class="fe lf lg lh li b">&lt;div&gt;</code>，并在其<code class="fe lf lg lh li b">textContent</code>属性上设置了<code class="fe lf lg lh li b">field.validationMessage</code>。</p><p id="3ec8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<code class="fe lf lg lh li b">&lt;div&gt;</code>将被附加到字段的<code class="fe lf lg lh li b">parentNode</code>上。</p><p id="8226" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这假设每个表单字段都被包装在另一个<code class="fe lf lg lh li b">&lt;div&gt;</code>中，所以字段和错误消息将在同一个<code class="fe lf lg lh li b">&lt;div&gt;</code>中。</p><p id="33e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您可以随意放置错误消息。</p><p id="851e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当出现错误时，生成的HTML将如下所示:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="fd3e" class="mr lk it li b gy ms mt l mu mv">&lt;div class=”container”&gt;<br/>  &lt;input type=”text” required&gt;<br/>  &lt;div class=”error-message”&gt;This field is required&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="8b26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果当字段有效时，错误只是被隐藏，则不需要在每次表单无效时追加错误消息。</p><p id="6634" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该代码可以检查错误消息是否存在，如果不存在，它将被追加。</p><p id="64a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果是，则<code class="fe lf lg lh li b">&lt;div&gt;</code>的<code class="fe lf lg lh li b">textContent</code>将被设置为错误信息并显示出来。</p><p id="445c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，错误消息会有<code class="fe lf lg lh li b">display: none</code>所以它是隐藏的，当一个字段是<code class="fe lf lg lh li b">invalid</code>时，你可以添加一个属性<code class="fe lf lg lh li b">invalid</code>到它，并添加CSS使错误消息只有在字段有这个属性时才可见:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="7dfd" class="mr lk it li b gy ms mt l mu mv">.error-message {<br/>  display: none;<br/>}</span><span id="fe1c" class="mr lk it li b gy mx mt l mu mv">input[invalid] ~ .error-message {<br/>  display: block;<br/>}</span></pre><p id="9711" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里使用通用兄弟组合符<code class="fe lf lg lh li b">~</code>来选择<code class="fe lf lg lh li b">.error-message</code>，它是<code class="fe lf lg lh li b">input</code>的兄弟，但仅当它具有<code class="fe lf lg lh li b">invalid</code>属性时。</p><p id="2e82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过为<code class="fe lf lg lh li b">invalid</code>创建一个负责此事的设置器，只需设置<code class="fe lf lg lh li b">this.invalid</code>即可设置或删除该属性:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="058b" class="mr lk it li b gy ms mt l mu mv">set invalid(isInvalid) {<br/>  isInvalid &amp;&amp; this.customErrorDisplay ? <br/>    this.setAttribute('invalid', '') : <br/>    this.removeAttribute('invalid');<br/>}</span></pre><p id="7508" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">获取错误消息是消费代码的责任。这段代码可以挂钩到<code class="fe lf lg lh li b">invalid</code>事件，从组件<code class="fe lf lg lh li b">validationMessage</code>属性中获取错误消息:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="26b2" class="mr lk it li b gy ms mt l mu mv">&lt;label&gt;<br/>  Input</span><span id="0337" class="mr lk it li b gy mx mt l mu mv">  &lt;form-input<br/>    required<br/>    data-valuemissing="This field is required!"&gt;<br/>  &lt;/form-input&gt;</span><span id="29c8" class="mr lk it li b gy mx mt l mu mv">  &lt;div class="error-message"&gt;&lt;/div&gt;<br/>&lt;/label&gt;</span><span id="7021" class="mr lk it li b gy mx mt l mu mv">const input = document.querySelector('form-input');<br/>const errorMessage = document.querySelector('.error-message');<br/><br/>input.addEventListener('invalid', (e) =&gt; {<br/>  errorMessage.textContent = input.validationMessage;<br/>})</span></pre><h1 id="e10c" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">何时验证？</h1><p id="515d" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">最后一个要解决的问题是在<code class="fe lf lg lh li b">constructor</code>中调用<code class="fe lf lg lh li b">validateInput()</code>来立即设置组件的有效性。</p><p id="f079" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也可以将<code class="fe lf lg lh li b">invalid</code>属性设置为<code class="fe lf lg lh li b">true</code>，从而设置<code class="fe lf lg lh li b">invalid</code>属性。</p><p id="bb7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您表示想要显示自定义错误消息(通过<code class="fe lf lg lh li b">custom-error-display</code>属性),这将导致自定义错误消息在用户与输入交互之前显示。</p><p id="221c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显然这不是你想要的。</p><p id="2951" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以向组件添加一个<code class="fe lf lg lh li b">pristine</code>属性来防止这种情况。该属性最初被设置为<code class="fe lf lg lh li b">true</code>，只有当<code class="fe lf lg lh li b">input</code>无效且<code class="fe lf lg lh li b">this.pristine</code>为假时(例如，用户与组件交互)，才使用该属性将<code class="fe lf lg lh li b">this.invalid</code>设置为<code class="fe lf lg lh li b">true</code>。</p><p id="d82b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mm">何时</em> <code class="fe lf lg lh li b">pristine</code>将被设置为<code class="fe lf lg lh li b">false</code>取决于<em class="mm">何时</em>您想要验证输入并在适用时显示错误。</p><p id="f090" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想在组件的值改变时验证组件，那么应该在<code class="fe lf lg lh li b">change</code>事件处理程序中将<code class="fe lf lg lh li b">pristine</code>设置为<code class="fe lf lg lh li b">false</code>。</p><p id="b338" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您只想在表单提交后显示一个错误，那么应该在<code class="fe lf lg lh li b">invalid</code>事件处理程序中将<code class="fe lf lg lh li b">pristine</code>设置为<code class="fe lf lg lh li b">false</code>，因为只有在表单提交时才会触发。</p><p id="04d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第二种情况下，当表单提交后组件的值发生变化时，组件也将被验证。</p><p id="fab5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很好，因为每当显示错误消息时，您不希望它只是在表单再次提交后才消失，而是在组件不再无效时立即消失。</p><p id="34b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了表明每当组件的值改变时都要验证组件，可以引入一个类似于<code class="fe lf lg lh li b">validate-on-change</code>的属性，例如:</p><pre class="kp kq kr ks gt mn li mo mp aw mq bi"><span id="fe29" class="mr lk it li b gy ms mt l mu mv">&lt;form-input<br/>  validate-on-change<br/>  ...<br/>  &gt;<br/>&lt;/form-input&gt;</span></pre><p id="b0a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是完整的工作示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="8d87" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="969d" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">与表单关联自定义元素使开发人员能够构建所有类型的自定义表单控件，这些控件可以像本机表单元素一样工作，并可以使用本机表单验证来验证。</p><p id="6b3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对<code class="fe lf lg lh li b">ElementInternals</code>的支持尚未登陆Safari，但已经被<a class="ae le" href="https://t.co/3xKqqkrqqG" rel="noopener ugc nofollow" target="_blank">合并到Webkit </a>中。</p><p id="caf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Twitter上关注我，在那里我写了现代网络能做什么，PWAs，和网络组件。</p></div></div>    
</body>
</html>