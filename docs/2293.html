<html>
<head>
<title>Explained: Futures in Rust for Web Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释:Rust在Web开发中的未来</h1>
<blockquote>原文：<a href="https://itnext.io/explained-rust-futures-for-web-development-b1d0632490e7?source=collection_archive---------1-----------------------#2019-05-02">https://itnext.io/explained-rust-futures-for-web-development-b1d0632490e7?source=collection_archive---------1-----------------------#2019-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2722" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">正如我在上一篇文章</em>  <em class="ki">中解释的那样，期货是异步环境的一部分。我们需要语法、类型和运行时来以非阻塞的方式运行代码。期货是Rust异步故事的典型部分。</em></h2></div><h1 id="5032" class="kk kl it bd km kn ko kp kq kr ks kt ku jz kv ka kw kc kx kd ky kf kz kg la lb bi translated">两种观点</h1><p id="b090" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果你来自NodeJS，Rust的未来没有多大意义。在NodeJS中，一切都是异步发生的。因此，为了让你能够说“嘿，我真的需要等待这个GET HTTP调用的答案”，你把<code class="fe ly lz ma mb b">.then()</code>放在了<code class="fe ly lz ma mb b">Promise</code>上，这样你就可以确保当HTTP调用结束时，你只是执行了<code class="fe ly lz ma mb b">.then()</code>中的代码。</p><p id="80d6" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">在Rust中，默认情况下，一切都是阻塞和同步的，所以你可能会问自己:“为什么要为复杂性而烦恼，这正是我最初想要的！”</p><p id="95e0" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">Rust是一种系统编程语言。因此，要在Rust中编写应用程序，您必须始终身兼两职。“系统Hat"(⛑”和“程序员帽”(🎩).系统Hat(⛑)让你从机器的角度考虑什么是最好的🎩)负责软件的语法和编写方式。</p><p id="9849" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">如果你来自NodeJS，系统是由Googles V8运行时负责的，所以你可以专注于语法。在Rust中，你可以从crates那里得到帮助，尽管你需要自己做出某些决定。</p><p id="261b" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">这就是我们为什么要使用期货的原因。因此，您需要在应用程序中将Futures作为一种类型来处理，然后确保使用运行时来实际执行它们。如果你在消费期货(例如当你使用的一个箱子返回一个<code class="fe ly lz ma mb b">Future</code>)，你必须理解数据来自哪里。在这种情况下，需要程序员帽<strong class="le iu">和</strong>系统帽。</p><h1 id="90ec" class="kk kl it bd km kn ko kp kq kr ks kt ku jz kv ka kw kc kx kd ky kf kz kg la lb bi translated"><code class="fe ly lz ma mb b">Future</code>究竟是什么？🎩</h1><p id="0c2a" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">Rust中的一个<code class="fe ly lz ma mb b">Future</code>实际上是一个<code class="fe ly lz ma mb b">trait</code>，如果你想实现它，看起来是这样的:</p><pre class="mh mi mj mk gt ml mb mm mn aw mo bi"><span id="00b0" class="mp kl it mb b gy mq mr l ms mt">trait Future {<br/>    type Item;<br/>    type Error;</span><span id="85eb" class="mp kl it mb b gy mu mr l ms mt">    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt;;<br/>}</span></pre><p id="847c" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated"><code class="fe ly lz ma mb b">poll</code>方法很重要。这将从你的运行时得到调用，并将返回<code class="fe ly lz ma mb b"><a class="ae kj" href="https://docs.rs/futures/0.1/futures/enum.Async.html" rel="noopener ugc nofollow" target="_blank">Async::Ready</a></code> <a class="ae kj" href="https://docs.rs/futures/0.1/futures/enum.Async.html" rel="noopener ugc nofollow" target="_blank">或</a> <code class="fe ly lz ma mb b"><a class="ae kj" href="https://docs.rs/futures/0.1/futures/enum.Async.html" rel="noopener ugc nofollow" target="_blank">Async::NotReady</a></code>。</p><p id="820d" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">如果您想从远程位置或文件系统获取不同的杂志期，您可以为此创建并返回自己的<code class="fe ly lz ma mb b">Future</code>:</p><pre class="mh mi mj mk gt ml mb mm mn aw mo bi"><span id="6039" class="mp kl it mb b gy mq mr l ms mt">struct Magazine {<br/>    issues: Vec&lt;u8&gt;<br/>}</span></pre><p id="0cb0" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">还有<code class="fe ly lz ma mb b">impl</code>上面的<code class="fe ly lz ma mb b">Future</code>特质:</p><pre class="mh mi mj mk gt ml mb mm mn aw mo bi"><span id="a295" class="mp kl it mb b gy mq mr l ms mt">impl Future for Magazine {<br/>    // here we return a single byte<br/>    type Item = u8;<br/>    type Error = io::Error;</span><span id="40f5" class="mp kl it mb b gy mu mr l ms mt">    // this method is getting called from the runtime. Everytime we can read<br/>    // a byte into the buffer, we return `Async::Ready`<br/>    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {<br/>        let mut buffer = [0;1];<br/>        match self.0.poll_read(&amp;mut buf) {<br/>            Ok(Async::Ready(_num_bytes_read)) =&gt; Ok(Async::Ready(buffer[0])),<br/>            Ok(Async::NotReady) =&gt; Ok(Async::NotReady),<br/>            Err(e) =&gt; Err(e)<br/>        }<br/>    }<br/>}</span></pre><p id="9e15" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">运行时会用你请求的信息填充缓冲区，一旦缓冲区满了，<code class="fe ly lz ma mb b">Future</code>就会返回<code class="fe ly lz ma mb b">Async::Ready</code>。</p><p id="64f9" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">这就是铁锈中的一个<code class="fe ly lz ma mb b">Future</code>的基本精髓。</p><h1 id="da21" class="kk kl it bd km kn ko kp kq kr ks kt ku jz kv ka kw kc kx kd ky kf kz kg la lb bi translated">什么时候使用期货？🎩</h1><blockquote class="mv mw mx"><p id="cfe2" class="lc ld my le b lf mc ju lh li md jx lk mz me ln lo na mf lr ls nb mg lv lw lx im bi translated"><em class="it">为一个类型实现</em> <code class="fe ly lz ma mb b"><em class="it">Future</em></code> <em class="it"> trait是你告诉机器“嘿，这可能要花点时间，在执行这部分代码时考虑一下”的方式。</em></p></blockquote><p id="3d27" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">Rust是一种同步语言。所有的事情都是一行一行地发生，并且一直等到每个结果都被处理完。这不是一个问题，除非你想做需要更长时间处理的任务。</p><p id="c10d" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">如果你用Rust创建一个微服务，你需要为一些数据获取另外三个微服务，然后你合并数据并把它写入数据库，这是一个你想考虑使用Futures的用例。</p><h1 id="1001" class="kk kl it bd km kn ko kp kq kr ks kt ku jz kv ka kw kc kx kd ky kf kz kg la lb bi translated">为什么使用期货可以节省时间？⛑</h1><p id="fa68" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在我们的测试场景中，比方说，每个HTTP调用可能需要1分钟。现在，不是等待3分钟来完成所有的调用，而是希望并行运行它们，这样您仍然只需等待1分钟而不是3分钟。</p><p id="7b03" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">因此，您创建了三个方法，每个方法返回一个<code class="fe ly lz ma mb b">Future</code>，收集它们，然后将它们传递给运行时(例如，通过<code class="fe ly lz ma mb b">tokio::run</code>传递给tokio)。</p><h1 id="f87c" class="kk kl it bd km kn ko kp kq kr ks kt ku jz kv ka kw kc kx kd ky kf kz kg la lb bi translated">期货怎么用？🎩 + ⛑</h1><p id="4ed5" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果板条箱返回一个<code class="fe ly lz ma mb b">Future</code>，一旦<code class="fe ly lz ma mb b">Future</code>准备好，您可以使用<code class="fe ly lz ma mb b"><a class="ae kj" href="https://docs.rs/futures/0.1.26/futures/future/struct.AndThen.html" rel="noopener ugc nofollow" target="_blank">.and_then()</a></code>处理结果。在<code class="fe ly lz ma mb b">Future</code>上使用<code class="fe ly lz ma mb b"><a class="ae kj" href="https://docs.rs/futures/0.1.26/futures/future/struct.Map.html" rel="noopener ugc nofollow" target="_blank">.map()</a></code>可以改变<code class="fe ly lz ma mb b">Future</code>的类型。</p><p id="d4e0" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">在异步Rust世界中，我们必须处理不同类型的数据。例如，我们不是使用字符串和数字，而是处理值流。您很可能会处理流。</p><p id="74c5" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">一个<code class="fe ly lz ma mb b">Stream</code>是一个未来的延伸。未来是关于产生一个单一的值，而<code class="fe ly lz ma mb b">Stream</code>是产生值，只要它们存在。</p><ul class=""><li id="be1d" class="nc nd it le b lf mc li md ll ne lp nf lt ng lx nh ni nj nk bi translated"><a class="ae kj" href="https://docs.rs/futures/0.1.26/futures/stream/index.html" rel="noopener ugc nofollow" target="_blank">流</a>:一个<code class="fe ly lz ma mb b">Stream</code>就像一个<code class="fe ly lz ma mb b">Future</code>一样，是一个你可以在一个类型上<code class="fe ly lz ma mb b">impl</code>的特征。这允许您迭代返回值(即<code class="fe ly lz ma mb b">Some(_)</code>或<code class="fe ly lz ma mb b">None</code>)。</li><li id="d9e5" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated"><a class="ae kj" href="https://docs.rs/futures/0.1.26/futures/sink/index.html" rel="noopener ugc nofollow" target="_blank">接收器</a>:用于连续(以异步方式)将数据写入套接字或文件系统</li></ul><p id="86ee" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">所以流是用来读数据的，接收器是用来写数据的。在我们的网络生态系统中有两种类型的流:</p><ul class=""><li id="9b6e" class="nc nd it le b lf mc li md ll ne lp nf lt ng lx nh ni nj nk bi translated">字节流(如HTTP主体或TCP流)</li><li id="ed37" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">消息流(如WebSocket帧或UDP数据包)，其中每个消息都有固定的大小</li></ul><h1 id="45e4" class="kk kl it bd km kn ko kp kq kr ks kt ku jz kv ka kw kc kx kd ky kf kz kg la lb bi translated">代码示例</h1><p id="4fbf" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们看一个用例，您正在使用的板条箱返回一个<code class="fe ly lz ma mb b">Future</code>。在做HTTP调用的时候，<code class="fe ly lz ma mb b">reqwest</code>就是一个很好的例子。在从<code class="fe ly lz ma mb b">reqwest</code>返回的<code class="fe ly lz ma mb b">Future</code>上，您可以使用<code class="fe ly lz ma mb b">.and_then()</code>来处理结果(🎩):</p><pre class="mh mi mj mk gt ml mb mm mn aw mo bi"><span id="4b7a" class="mp kl it mb b gy mq mr l ms mt">// We have to use "r#" before "async" because "async" is a reserved keyword.<br/>use reqwest::r#async::Client;</span><span id="40e9" class="mp kl it mb b gy mu mr l ms mt">// The return type has to be `Future&lt;Item=(), Error=()&gt;` to be able<br/>// to use `tokio::run`. <br/>// If it has a different type, you have to use `tokio::block_on`<br/>fn fetch_data() -&gt; impl Future&lt;Item=(), Error=()&gt; {<br/>    Client::new()<br/>        .get(url)<br/>        .send()<br/>        .and_then(|res| {<br/>            res.into_body().concat2()<br/>        })<br/>        .map_err(|err| println!("request error: {}", err))<br/>        .map(|body| {<br/>            // here you can use the body to write it to a file<br/>            // or return it via Ok()<br/>            // If you return it via for example Ok(users)<br/>            // then you need to adjust the return type in impl Future&lt;Item=TYPE<br/>            // Examples can be found here: <br/>            // https://github.com/gruberb/futures_playground</span><span id="2c12" class="mp kl it mb b gy mu mr l ms mt">            // For now, lets just turn the body into a Vector<br/>            let v = body.to_vec();<br/>        })<br/>}</span></pre><p id="7fe4" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">一旦你创建了返回一个<code class="fe ly lz ma mb b">Future</code> ( <code class="fe ly lz ma mb b">fetch_data()</code>)，<strong class="le iu">的方法，你必须把它传递给一个运行时</strong>，比如tokio (⛑):</p><pre class="mh mi mj mk gt ml mb mm mn aw mo bi"><span id="b8d1" class="mp kl it mb b gy mq mr l ms mt">tokio::run(fetch_data());</span></pre><h1 id="31dc" class="kk kl it bd km kn ko kp kq kr ks kt ku jz kv ka kw kc kx kd ky kf kz kg la lb bi translated">高级概述</h1><ol class=""><li id="7b77" class="nc nd it le b lf lg li lj ll nq lp nr lt ns lx nt ni nj nk bi translated">您从外部板条箱收到一个<code class="fe ly lz ma mb b">Future</code></li><li id="0249" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nt ni nj nk bi translated">一个<code class="fe ly lz ma mb b">Future</code>很可能返回一个<code class="fe ly lz ma mb b">Stream</code>值，所以你必须将这个<code class="fe ly lz ma mb b">Stream</code>形成一个你可以同步处理的类型(比如一个向量或者字符串)</li><li id="5c63" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nt ni nj nk bi translated">您通过<code class="fe ly lz ma mb b">-&gt; impl Future&lt;Item=(), Error=()&gt;</code>从一个方法中返回整个未来，其中大括号<code class="fe ly lz ma mb b">()</code>是您想要返回的实际类型的占位符</li><li id="e909" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nt ni nj nk bi translated">您通过<code class="fe ly lz ma mb b">tokio::run(method())</code>将方法传递给运行时，如tokio</li><li id="22b0" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nt ni nj nk bi translated"><code class="fe ly lz ma mb b">run</code>调用将启动运行时，设置所需的资源，然后将这个未来放在一个线程池中，并开始轮询您的未来</li><li id="2ed5" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nt ni nj nk bi translated">然后，它会尝试将工作传递给操作系统</li><li id="9709" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nt ni nj nk bi translated">每次运行时轮询你的<code class="fe ly lz ma mb b">Future</code>，如果你的<code class="fe ly lz ma mb b">Future</code>正在等待的底层I/O资源没有准备好，它将返回<code class="fe ly lz ma mb b">NotReady​</code>。运行时看到这个<code class="fe ly lz ma mb b">NotReady​</code>返回值并让你的<code class="fe ly lz ma mb b">Future</code>休眠</li><li id="3b81" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nt ni nj nk bi translated">一旦来自底层I/O资源的事件到来，运行时将检查该I/O资源是否与您的<code class="fe ly lz ma mb b">Future</code>相关联，并再次开始轮询。这一次，您的<code class="fe ly lz ma mb b">Future</code>将能够返回一个带有值的<code class="fe ly lz ma mb b">Ready</code>，因为底层I/O资源已经提供了一个值</li><li id="aa7d" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nt ni nj nk bi translated">然后，运行时会将<code class="fe ly lz ma mb b">Future</code>的状态设置为就绪，并处理代码的<code class="fe ly lz ma mb b">.and_then()</code>部分</li></ol><p id="3e45" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">与NodeJS不同的是，<code class="fe ly lz ma mb b">Future</code>是通过<code class="fe ly lz ma mb b">tokio::run</code>而不是之前执行的。在Node中，只要你写了一个<code class="fe ly lz ma mb b">Promise</code>，对象就会被立即返回。</p><h1 id="9a05" class="kk kl it bd km kn ko kp kq kr ks kt ku jz kv ka kw kc kx kd ky kf kz kg la lb bi translated">期货有什么不一样或者难的？⛑</h1><p id="007a" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们看一下上面的例子:</p><ul class=""><li id="ce54" class="nc nd it le b lf mc li md ll ne lp nf lt ng lx nh ni nj nk bi translated">我们用我们的请求<code class="fe ly lz ma mb b">Client::new()</code>和<code class="fe ly lz ma mb b">.send()</code>创建一个新的客户端</li><li id="215d" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">我们会得到一个<code class="fe ly lz ma mb b"><a class="ae kj" href="https://github.com/seanmonstar/reqwest/blob/master/src/async_impl/response.rs#L24" rel="noopener ugc nofollow" target="_blank">Response</a></code>回来:</li></ul><pre class="mh mi mj mk gt ml mb mm mn aw mo bi"><span id="e415" class="mp kl it mb b gy mq mr l ms mt">pub struct Response {<br/>    status: StatusCode,<br/>    headers: HeaderMap,<br/>    url: Box&lt;Url&gt;,<br/>    body: Decoder,<br/>    ...<br/>}</span></pre><ul class=""><li id="48ea" class="nc nd it le b lf mc li md ll ne lp nf lt ng lx nh ni nj nk bi translated">机身本身就是一个解码器，可以通过<code class="fe ly lz ma mb b"><a class="ae kj" href="https://github.com/seanmonstar/reqwest/blob/master/src/async_impl/response.rs#L113" rel="noopener ugc nofollow" target="_blank">.into_body()</a></code>变成一个<code class="fe ly lz ma mb b">Body</code>。</li><li id="ef4c" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated"><code class="fe ly lz ma mb b">Body</code>本身<a class="ae kj" href="https://github.com/seanmonstar/reqwest/blob/master/src/async_impl/decoder.rs#L155" rel="noopener ugc nofollow" target="_blank">实现</a>一个<a class="ae kj" href="https://docs.rs/futures/0.1.26/futures/stream/trait.Stream.html" rel="noopener ugc nofollow" target="_blank">流</a>(如前所述)。</li><li id="f46e" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">现在我们可以从Rust的Futures API中找到答案:我们可以通过<code class="fe ly lz ma mb b"><a class="ae kj" href="https://docs.rs/futures/0.1.26/futures/stream/struct.Concat2.html" rel="noopener ugc nofollow" target="_blank">.concat2()</a></code>将一个字节流转换成一个条目</li></ul><pre class="mh mi mj mk gt ml mb mm mn aw mo bi"><span id="cb82" class="mp kl it mb b gy mq mr l ms mt">...<br/>        .and_then(|res| {<br/>            res.into_body().concat2()<br/>        })<br/>...</span></pre><ul class=""><li id="39fc" class="nc nd it le b lf mc li md ll ne lp nf lt ng lx nh ni nj nk bi translated">我们将<code class="fe ly lz ma mb b">.map()</code>部分中的这一项作为<code class="fe ly lz ma mb b">body</code></li><li id="67ec" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">在你的代码编辑器的帮助下，你会发现这个<code class="fe ly lz ma mb b">body</code>实际上是一个<code class="fe ly lz ma mb b"><a class="ae kj" href="https://github.com/hyperium/hyper/blob/master/src/body/chunk.rs" rel="noopener ugc nofollow" target="_blank">Chunk</a></code>，从库<code class="fe ly lz ma mb b"><a class="ae kj" href="https://github.com/hyperium/hyper" rel="noopener ugc nofollow" target="_blank">Hyper</a></code>返回</li><li id="b10d" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">我们现在可以把这个<code class="fe ly lz ma mb b">Chunk</code>变成一个<code class="fe ly lz ma mb b"><a class="ae kj" href="https://doc.rust-lang.org/std/vec/struct.Vec.html" rel="noopener ugc nofollow" target="_blank">Vector</a></code></li></ul><pre class="mh mi mj mk gt ml mb mm mn aw mo bi"><span id="e395" class="mp kl it mb b gy mq mr l ms mt">...<br/>        .map(|body| {<br/>            let v = body.to_vec();<br/>            // do whatever with v<br/>        })<br/>...</span></pre><p id="85ee" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">从那时起，我们回到了“正常的”铁锈地带，可以忘记刚刚发生的事情🙃。</p><blockquote class="mv mw mx"><p id="7430" class="lc ld my le b lf mc ju lh li md jx lk mz me ln lo na mf lr ls nb mg lv lw lx im bi translated"><em class="it">你可以在这个</em> <a class="ae kj" href="https://github.com/gruberb/futures_playground" rel="noopener ugc nofollow" target="_blank"> <em class="it"> GitHub资源库</em> </a> <em class="it">中找到完整的例子。在那里我接收到一个</em> <code class="fe ly lz ma mb b"><em class="it">JSON</em></code> <em class="it">并把它写到一个文件中。</em></p></blockquote><p id="5da6" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">这也是为什么一开始处理期货如此艰难的原因之一。你必须考虑比NodeJS更低的层次。此外，<code class="fe ly lz ma mb b">async/await</code>语法<a class="ae kj" href="https://internals.rust-lang.org/t/await-syntax-discussion-summary/9914" rel="noopener ugc nofollow" target="_blank">还不是最终的</a>，这导致了更多的锅炉代码。</p><p id="0390" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">这些心理步骤有助于你在处理期货交易时不迷失方向:</p><ol class=""><li id="68b7" class="nc nd it le b lf mc li md ll ne lp nf lt ng lx nt ni nj nk bi translated">我从这个库中得到的返回类型或值是什么？</li><li id="566c" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nt ni nj nk bi translated">我如何访问这个响应的值的<code class="fe ly lz ma mb b">Stream</code>?</li><li id="ca9d" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nt ni nj nk bi translated">当我通过<code class="fe ly lz ma mb b">.concat2()</code>收集所有值时，库将把这个<code class="fe ly lz ma mb b">Stream</code>变成什么？</li><li id="d248" class="nc nd it le b lf nl li nm ll nn lp no lt np lx nt ni nj nk bi translated">我如何将这种新类型转换成Vector或另一种Rust std格式，以便可以将其传递给同步方法？</li></ol><figure class="mh mi mj mk gt nv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/a1af3570fda438757f4b661f7781cf11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*Qfu4N4ZIhqrzqCLs.png"/></div></figure><p id="ba22" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">基本上，你总是想弄清楚如何访问值流，收集它们，然后处理结果对象。</p><h1 id="0143" class="kk kl it bd km kn ko kp kq kr ks kt ku jz kv ka kw kc kx kd ky kf kz kg la lb bi translated">如何执行多个<code class="fe ly lz ma mb b">Future</code>？🎩</h1><p id="87a3" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一般来说，你想把你的值收集成<code class="fe ly lz ma mb b">Streams</code>，这样对于你从<code class="fe ly lz ma mb b">Stream</code>中得到的每一项，你可以派生出一个新的<code class="fe ly lz ma mb b">Future</code>来处理它。</p><p id="f558" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">Rust Futures API有一个名为<code class="fe ly lz ma mb b"><a class="ae kj" href="https://docs.rs/futures/0.1.26/futures/stream/futures_unordered/struct.FuturesUnordered.html" rel="noopener ugc nofollow" target="_blank">FuturesUnordered</a></code>的方法，您可以使用它来添加多个<code class="fe ly lz ma mb b">Future</code>:</p><pre class="mh mi mj mk gt ml mb mm mn aw mo bi"><span id="57f2" class="mp kl it mb b gy mq mr l ms mt">use futures::stream::futures_unordered::FuturesUnordered;<br/>use hyper::{client::ResponseFuture, Client};</span><span id="dfac" class="mp kl it mb b gy mu mr l ms mt">fn setup_requests() -&gt; FuturesUnordered&lt;ResponseFuture&gt; {<br/>    let mut list_of_futures = FuturesUnordered::new();</span><span id="9bbb" class="mp kl it mb b gy mu mr l ms mt">    let client = Client::new();</span><span id="a7c6" class="mp kl it mb b gy mu mr l ms mt">    let first = client.get(URL);<br/>    list_of_futures.push(first);</span><span id="78bf" class="mp kl it mb b gy mu mr l ms mt">    let second = client.get(URL);<br/>    list_of_futures.push(second);</span><span id="49f1" class="mp kl it mb b gy mu mr l ms mt">    list_of_futures<br/>}</span></pre><p id="96ee" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">在这个例子中，我们使用<code class="fe ly lz ma mb b"><a class="ae kj" href="https://github.com/hyperium/hyper" rel="noopener ugc nofollow" target="_blank">hyper</a></code>进行HTTP调用。你可以在Github 上找到剩下的代码<a class="ae kj" href="https://github.com/chicagohaskell/async-futures-talk/blob/master/rustlb/examples/multi-http/src/main.rs" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5817" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">如果您使用的是<code class="fe ly lz ma mb b">reqwest</code>，语法看起来会略有不同。这里你<code class="fe ly lz ma mb b">.join()</code>多个请求，并作为“一个未来”返回。</p><pre class="mh mi mj mk gt ml mb mm mn aw mo bi"><span id="96df" class="mp kl it mb b gy mq mr l ms mt">fn fetch() -&gt; impl Future&lt;Item=(), Error=()&gt; {<br/>    let client = Client::new();</span><span id="d0bf" class="mp kl it mb b gy mu mr l ms mt">    let json = |mut res : Response | {<br/>        res.json::&lt;STRUCT_TYPE&gt;()<br/>    };</span><span id="d779" class="mp kl it mb b gy mu mr l ms mt">    let request1 =<br/>        client<br/>            .get(URL)<br/>            .send()<br/>            .and_then(json);</span><span id="be16" class="mp kl it mb b gy mu mr l ms mt">    let request2 =<br/>        client<br/>            .get(URL)<br/>            .send()<br/>            .and_then(json);</span><span id="384d" class="mp kl it mb b gy mu mr l ms mt">    request1.join(request2)<br/>        .map(|(res1, res2)|{<br/>            println!("{:?}", res1);<br/>            println!("{:?}", res2);<br/>        })<br/>        .map_err(|err| {<br/>            println!("stdout error: {}", err);<br/>        })<br/>}</span></pre><p id="18f5" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">完整代码也可以在<a class="ae kj" href="https://github.com/seanmonstar/reqwest/blob/master/examples/async_multiple_requests.rs" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h1 id="01ce" class="kk kl it bd km kn ko kp kq kr ks kt ku jz kv ka kw kc kx kd ky kf kz kg la lb bi translated">期货的未来如何？🎩 + ⛑</h1><p id="379c" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">期货价格稳定在1.37，大约在6月份。语法和运行时也有变化，这将有助于减少您必须编写的代码量，以便将这个值流从<code class="fe ly lz ma mb b">Future</code>中取出并转换成同步Rust格式。</p><p id="b73d" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">您还可以使用<code class="fe ly lz ma mb b"><a class="ae kj" href="https://github.com/rustasync/runtime" rel="noopener ugc nofollow" target="_blank">Runtime</a></code> crate，它可以为您节省几乎所有的样板代码。尽管经历上述过程有助于你更深层次地理解未来。</p><h1 id="deda" class="kk kl it bd km kn ko kp kq kr ks kt ku jz kv ka kw kc kx kd ky kf kz kg la lb bi translated">摘要</h1><p id="8d73" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果您执行异步操作，比如从操作系统获取文件或向远程服务器发出HTTP请求，那么Futures允许您以非阻塞的方式处理返回值。</p><p id="12ef" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">如果它是同步的，您将不得不阻塞正在运行操作的线程，并等待结果，直到您继续。为了以异步方式实现这一点，我们有一个运行时，它自己创建线程，并承担未来。当操作系统向运行时返回值时，它将填充<code class="fe ly lz ma mb b">Future</code>中的值。</p><p id="8900" class="pw-post-body-paragraph lc ld it le b lf mc ju lh li md jx lk ll me ln lo lp mf lr ls lt mg lv lw lx im bi translated">一旦<code class="fe ly lz ma mb b">Future</code>完成，运行时设置<code class="fe ly lz ma mb b">Async::Ready</code>，代码的<code class="fe ly lz ma mb b">.and_then()</code>部分将被执行。</p></div></div>    
</body>
</html>