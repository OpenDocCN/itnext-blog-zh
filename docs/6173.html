<html>
<head>
<title>Running and Writing Gatekeeper Policies in Kubernetes — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes中运行和编写网守策略—第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/running-gatekeeper-in-kubernetes-and-writing-policies-part-1-fcc83eba93e3?source=collection_archive---------2-----------------------#2021-09-07">https://itnext.io/running-gatekeeper-in-kubernetes-and-writing-policies-part-1-fcc83eba93e3?source=collection_archive---------2-----------------------#2021-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="2ef8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">系列概述</h1><p id="a4e2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">本系列文章考察了一个自以为是的Kubernetes网关守护设备策略生态系统，包括什么是网关守护设备，为什么使用网关守护设备，编写和测试策略，将策略部署到本地Kubernetes集群，以及如何使它们对用户可见。本系列的所有代码都位于这个GitHub存储库中:</p><div class="lj lk gp gr ll lm"><a href="https://github.com/sebradloff/k8s-gatekeeper-policies-example" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd ir gy z fp lr fr fs ls fu fw ip bi translated">GitHub-sebradloff/k8s-网关守护设备-策略-示例</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">在GitHub上创建一个帐户，为sebradloff/k8s-gate keeper-policies-example开发做出贡献。</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">github.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma mb lm"/></div></div></a></div><p id="62d2" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><a class="ae mh" href="https://medium.com/@sebradloff/running-gatekeeper-in-kubernetes-and-writing-policies-part-1-fcc83eba93e3" rel="noopener"> <strong class="kn ir">第1部分:网守组件和架构概述</strong> </a></p><p id="f1d1" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><a class="ae mh" href="https://medium.com/@sebradloff/running-and-writing-gatekeeper-policies-in-kubernetes-part-2-1c49c1c683b2" rel="noopener"> <strong class="kn ir">第2部分:为本地集群安装网关守护设备，并迭代策略</strong> </a></p><h1 id="0059" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">第1部分概述</h1><p id="92bb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本帖中，我们将介绍什么是网关守护设备，为什么您可能需要它，一个示例策略，网关守护设备基础架构，以及如何实施策略。在阅读完本文后，我希望您能够决定是否要了解更多关于Gatekeeper的信息，以确定它在您的组织中是否有一席之地。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/54f267758de3671bac2491301f477493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3RiKE6sOqesAqFjbb1RSA.jpeg"/></div></div></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="ef91" class="jn jo iq bd jp jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk bi translated">什么是看门人？</h1><p id="ff13" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Gatekeeper是Kubernetes对开放策略代理<a class="ae mh" href="https://www.openpolicyagent.org/docs/latest/" rel="noopener ugc nofollow" target="_blank">(OPA)的具体实现，作为一个</a><a class="ae mh" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/" rel="noopener ugc nofollow" target="_blank">验证准入webhook </a>运行。Gatekeeper是一个工具，使您能够在Kubernetes资源上审计和执行策略。这些政策是用一种叫做rego的语言编写的。</p><h1 id="8a79" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">为什么需要看门人？</h1><p id="e45f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">每个Kubernetes资源上都有大量必需和可选的参数。当许多团队编写自己的Kubernetes资源时，每个团队如何配置这些资源肯定会有分歧。Gatekeeper可以拒绝创建或更新任何不符合我们策略的资源，从而帮助我们在整个集群中实施资源标准。</p><p id="128a" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">虽然我们可以编写策略来控制任何Kubernetes资源的任何配置选项，但大多数策略应该集中在以下目标上:</p><ul class=""><li id="4b7e" class="nf ng iq kn b ko mc ks md kw nh la ni le nj li nk nl nm nn bi translated"><strong class="kn ir">资源所有权</strong>:我们想要跟踪特定团队的每个资源的所有权。所有权可以在名称空间级别确定，假设一个团队拥有名称空间中的所有资源或每个资源上的一个标签。</li><li id="b5a1" class="nf ng iq kn b ko no ks np kw nq la nr le ns li nk nl nm nn bi translated"><strong class="kn ir">资源请求和限制</strong>:我们希望确保所有容器都有资源请求和限制，以避免“<a class="ae mh" href="https://thenewstack.io/kubernetes-performance-troublespots-airbnbs-take/" rel="noopener ugc nofollow" target="_blank">噪音邻居问题</a>”</li><li id="0c16" class="nf ng iq kn b ko no ks np kw nq la nr le ns li nk nl nm nn bi translated"><strong class="kn ir">集群范围的资源配置含义</strong>:例如，我们希望在API网关策略中使用nginx-ingress实施一个标准，其中只有一个入口资源可以处理对<code class="fe nt nu nv nw b">/api/${resource}</code>的请求，以确保没有其他入口可以为该资源提供流量。</li><li id="02ae" class="nf ng iq kn b ko no ks np kw nq la nr le ns li nk nl nm nn bi translated"><strong class="kn ir">安全性</strong>:我们希望确保没有容器以root用户身份运行，除非在我们策略中定义的允许列表上。</li><li id="d50d" class="nf ng iq kn b ko no ks np kw nq la nr le ns li nk nl nm nn bi translated"><strong class="kn ir">最佳实践</strong>:例如，我们需要就绪性和活性探测来帮助确保流量不会到达没有准备好的容器，并且当容器进入不可恢复状态时会重新启动。</li></ul><h1 id="6473" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">如何使用网关守护设备编写和实施策略</h1><p id="39fc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Gatekeeper项目引入了三个<a class="ae mh" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank"> Kubernetes定制资源定义</a>(CRDs)；<a class="ae mh" href="https://github.com/open-policy-agent/frameworks/blob/4f80ac172ddffad377f88986a162242dcf772eb6/constraint/README.md#what-is-a-constraint" rel="noopener ugc nofollow" target="_blank">约束</a>、<a class="ae mh" href="https://github.com/open-policy-agent/frameworks/blob/4f80ac172ddffad377f88986a162242dcf772eb6/constraint/README.md#what-is-a-constraint-template" rel="noopener ugc nofollow" target="_blank">约束模板</a>和<a class="ae mh" href="https://github.com/open-policy-agent/gatekeeper/blob/b468cf25dd7c5fd2b5918fe3ff47e003db930de2/website/docs/sync.md" rel="noopener ugc nofollow" target="_blank">配置</a>。ConstraintTemplate是在<a class="ae mh" href="https://github.com/open-policy-agent/frameworks" rel="noopener ugc nofollow" target="_blank">开放策略代理/框架库</a>中定义的，而约束实际上不是CRD，而是描述ConstraintTemplate创建的CRD的概念。让我们定义这些术语，看看每个术语的例子，并理解它们是如何相互作用的。</p><h2 id="29dc" class="nx jo iq bd jp ny nz dn jt oa ob dp jx kw oc od kb la oe of kf le og oh kj oi bi translated">约束模板</h2><blockquote class="oj ok ol"><p id="0e67" class="kl km om kn b ko mc kq kr ks md ku kv on me ky kz oo mf lc ld op mg lg lh li ij bi translated">约束模板允许人们声明新的约束。他们可以提供预期的输入参数和执行其意图所必需的底层减压阀。</p></blockquote><pre class="mj mk ml mm gt oq nw or os aw ot bi"><span id="4979" class="nx jo iq nw b gy ou ov l ow ox"># Pulled from <a class="ae mh" href="https://github.com/open-policy-agent/frameworks/blob/4f80ac172ddffad377f88986a162242dcf772eb6/constraint/README.md#what-is-a-constraint-template" rel="noopener ugc nofollow" target="_blank">https://github.com/open-policy-agent/frameworks/blob/4f80ac172ddffad377f88986a162242dcf772eb6/constraint/README.md#what-is-a-constraint-template</a></span><span id="50f3" class="nx jo iq nw b gy oy ov l ow ox">apiVersion: gatekeeper.sh/v1beta1<br/>kind: ConstraintTemplate<br/>metadata:<br/>  name: foosystemrequiredlabels<br/>spec:<br/>  crd:<br/>    spec:<br/>      names:<br/>        kind: FooSystemRequiredLabel<br/>      validation:<br/>        # Schema for the `parameters` field<br/>        openAPIV3Schema:<br/>          properties:<br/>            labels:<br/>              type: array<br/>              items: string<br/>  targets:<br/>    - target: admission.k8s.gatekeeper.sh<br/>      libs:<br/>        - |<br/>          package lib.helpers<br/>          <br/>          make_message(missing) = msg {<br/>            msg := sprintf("you must provide labels: %v", [missing])<br/>          }<br/>          <br/>      rego: |<br/>        package foosystemrequiredlabels<br/>        <br/>        import data.lib.helpers<br/>      <br/>        violation[{"msg": msg, "details": {"missing_labels": missing}}] {<br/>           provided := {label | input.request.object.metadata.labels[label]}<br/>           required := {label | label := input.parameters.labels[_]}<br/>           missing := required - provided<br/>           count(missing) &gt; 0<br/>           msg := helpers.make_message(missing)<br/>        }</span></pre><p id="2eb2" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">让我们分解上面的约束模板:</p><ul class=""><li id="d187" class="nf ng iq kn b ko mc ks md kw nh la ni le nj li nk nl nm nn bi translated"><strong class="kn ir"> crd: </strong>定义了<code class="fe nt nu nv nw b">FooSystemRequiredLabel</code>类约束的crd规范，它应该有一个标签数组作为输入。</li><li id="242d" class="nf ng iq kn b ko no ks np kw nq la nr le ns li nk nl nm nn bi translated"><strong class="kn ir">目标:</strong>定义约束适用于哪个目标。</li><li id="b2d3" class="nf ng iq kn b ko no ks np kw nq la nr le ns li nk nl nm nn bi translated"><strong class="kn ir"> libs: </strong>要导入到我们的rego策略中的库所在的位置。libs中的所有包都必须以<code class="fe nt nu nv nw b">lib</code>作为前缀，比如<code class="fe nt nu nv nw b">lib.&lt;name&gt;</code>。</li><li id="9254" class="nf ng iq kn b ko no ks np kw nq la nr le ns li nk nl nm nn bi translated"><strong class="kn ir"> rego: </strong>我们写保单rego的地方。</li></ul><p id="4f2f" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">关于约束的rego语义的OPA框架文档是有益的。整个rego块被认为是一个<a class="ae mh" href="https://www.openpolicyagent.org/docs/latest/policy-language/#modules" rel="noopener ugc nofollow" target="_blank">模块</a>。让我们看一下上面模块的每一行。</p><pre class="mj mk ml mm gt oq nw or os aw ot bi"><span id="ee38" class="nx jo iq nw b gy ou ov l ow ox"><strong class="nw ir"># Defines the package name of the module</strong><br/>package foosystemrequiredlabels        </span><span id="ee2e" class="nx jo iq nw b gy oy ov l ow ox"><strong class="nw ir"># Imports the package lib.helpers defined in the libs section<br/></strong>import data.lib.helpers</span><span id="2d98" class="nx jo iq nw b gy oy ov l ow ox"><strong class="nw ir"># Defining the violation rule. The violation rule schema must be followed for it to be considered a valid ConstraintTemplate, which is {"msg": string, "details" set}</strong></span><span id="2300" class="nx jo iq nw b gy oy ov l ow ox">violation[{"msg": msg, "details": {"missing_labels": missing}}] {</span><span id="c383" class="nx jo iq nw b gy oy ov l ow ox"><strong class="nw ir"># 'provided' variable is a set with all the labels from the object currently being evaluated by gatekeeper</strong></span><span id="f4a6" class="nx jo iq nw b gy oy ov l ow ox">    provided := {label | input.request.object.metadata.labels[label]}</span><span id="ad97" class="nx jo iq nw b gy oy ov l ow ox"><strong class="nw ir"> # 'required' variable is a set with all the labels from the Constraint parameters</strong>    <br/>    required := {label | label := input.parameters.labels[_]}</span><span id="2a39" class="nx jo iq nw b gy oy ov l ow ox"><strong class="nw ir"># 'missing' variable is a set the difference in value between required and provided</strong><br/>    missing := required - provided</span><span id="37f1" class="nx jo iq nw b gy oy ov l ow ox"><strong class="nw ir"># if there are more than zero values in the set 'missing' evaluate to true<br/></strong>    count(missing) &gt; 0</span><span id="43bc" class="nx jo iq nw b gy oy ov l ow ox"><strong class="nw ir"># 'msg' variable is declared. The value is the return of the 'make_message' rule in the lib.helpers package</strong><br/>    msg := helpers.make_message(missing)<br/>}</span></pre><p id="0266" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">现在让我们来理解约束CRD，以及它是如何适应的。</p><h2 id="5fe9" class="nx jo iq bd jp ny nz dn jt oa ob dp jx kw oc od kb la oe of kf le og oh kj oi bi translated">限制</h2><blockquote class="oj ok ol"><p id="9450" class="kl km om kn b ko mc kq kr ks md ku kv on me ky kz oo mf lc ld op mg lg lh li ij bi translated">约束是一个声明，它的作者希望系统满足一组给定的需求。</p></blockquote><pre class="mj mk ml mm gt oq nw or os aw ot bi"><span id="26db" class="nx jo iq nw b gy ou ov l ow ox"># Pulled from <a class="ae mh" href="https://github.com/open-policy-agent/frameworks/blob/4f80ac172ddffad377f88986a162242dcf772eb6/constraint/README.md#what-is-a-constraint" rel="noopener ugc nofollow" target="_blank">https://github.com/open-policy-agent/frameworks/blob/4f80ac172ddffad377f88986a162242dcf772eb6/constraint/README.md#what-is-a-constraint</a></span><span id="c529" class="nx jo iq nw b gy oy ov l ow ox">apiVersion: constraints.gatekeeper.sh/v1beta1<br/>kind: FooSystemRequiredLabel<br/>metadata:<br/>  name: require-billing-label<br/>spec:<br/>  match:<br/>   scope: Namespaced<br/>   namespaces: ["expensive"]<br/>  parameters:<br/>    labels: ["billing"]</span></pre><p id="4a57" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">这种资源属于<code class="fe nt nu nv nw b">FooSystemRequiredLabel</code>类，命名为<code class="fe nt nu nv nw b">require-billing-label</code>。我们看到CRD <code class="fe nt nu nv nw b">FooSystemRequiredLabel</code>是在我们名为<code class="fe nt nu nv nw b">foosystemrequiredlabels</code>的约束模板中定义的。这个资源特别会寻找所有作用于名称空间<code class="fe nt nu nv nw b">expensive</code>的资源，并提取标签<code class="fe nt nu nv nw b">billing</code>及其在所有这些资源上的值。</p><p id="34ea" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">属性为我们提供了几种不同的方法来选择我们的策略要评估的资源。我建议阅读<a class="ae mh" href="https://github.com/open-policy-agent/gatekeeper/blob/b468cf25dd7c5fd2b5918fe3ff47e003db930de2/website/docs/howto.md#constraints" rel="noopener ugc nofollow" target="_blank">这部分的关守文档，以了解匹配选项</a>。</p><p id="2d7d" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">我喜欢把ConstraintTemplate看作一个函数定义，而约束决定调用函数的参数。在我们的示例中，定义的ConstraintExample函数是策略(我们的rego)，函数参数是CRD规范(输入参数是标签)。约束是定义策略将检查的输入对象以及特定的标签参数。</p><h2 id="db03" class="nx jo iq bd jp ny nz dn jt oa ob dp jx kw oc od kb la oe of kf le og oh kj oi bi translated">配置</h2><blockquote class="oj ok ol"><p id="316f" class="kl km om kn b ko mc kq kr ks md ku kv on me ky kz oo mf lc ld op mg lg lh li ij bi translated">除了被测试的对象之外，如果不能访问更多的状态，有些约束是不可能编写的。配置允许将数据同步到OPA中。</p></blockquote><pre class="mj mk ml mm gt oq nw or os aw ot bi"><span id="952f" class="nx jo iq nw b gy ou ov l ow ox"># Pulled from <a class="ae mh" href="https://github.com/open-policy-agent/gatekeeper/blob/b468cf25dd7c5fd2b5918fe3ff47e003db930de2/website/docs/sync.md" rel="noopener ugc nofollow" target="_blank">https://github.com/open-policy-agent/gatekeeper/blob/b468cf25dd7c5fd2b5918fe3ff47e003db930de2/website/docs/sync.md</a></span><span id="9760" class="nx jo iq nw b gy oy ov l ow ox">apiVersion: config.gatekeeper.sh/v1alpha1<br/>kind: Config<br/>metadata:<br/>  name: config<br/>  namespace: "gatekeeper-system"<br/>spec:<br/>  sync:<br/>    syncOnly:<br/>      - group: ""<br/>        version: "v1"<br/>        kind: "Namespace"<br/>      - group: ""<br/>        version: "v1"<br/>        kind: "Pod"</span></pre><p id="c980" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">重要的是要注意这个CRD仍然在阿尔法。配置很简单，类似于约束。在<code class="fe nt nu nv nw b">spec.sync.syncOnly</code>下指定您想要在策略中查询的Kubernetes资源。在第三篇文章中，我们将研究一个利用配置数据的策略。我们不会讨论数据是如何通过审计过程同步到OPA中的，但是你可以在<a class="ae mh" href="https://github.com/open-policy-agent/gatekeeper/blob/b468cf25dd7c5fd2b5918fe3ff47e003db930de2/website/docs/audit.md" rel="noopener ugc nofollow" target="_blank"> Gatekeeper文档</a>中了解更多信息。</p><h1 id="effa" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">高级网关守护设备基础设施</h1><p id="bb45" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们快速浏览一下网关守护设备基础架构设置并应用我们的示例策略，这样我们就可以根据我们的策略评估任何新创建或更新的资源。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oz"><img src="../Images/e04ecd25f19646b4862023c941af7bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6G4AdXFKhvTF7Ak00AWk7Q.jpeg"/></div></div><figcaption class="pa pb gj gh gi pc pd bd b be z dk translated">网守基础设施</figcaption></figure><ol class=""><li id="61a7" class="nf ng iq kn b ko mc ks md kw nh la ni le nj li pe nl nm nn bi translated">CustomResourceDefinitions将应用于群集。我们此时最感兴趣的CRD是ConstraintTemplate。</li><li id="a5ae" class="nf ng iq kn b ko no ks np kw nq la nr le ns li pe nl nm nn bi translated">网关守护设备RBAC配置(Role，ClusterRole，ClusterRoleBinding Service account)服务和部署已应用于群集。</li><li id="445f" class="nf ng iq kn b ko no ks np kw nq la nr le ns li pe nl nm nn bi translated">名为gate keeper-validating-web hook-configuration的ValidatingWebhookConfiguration已应用于群集。这个webhook是Kubernetes的另一个<a class="ae mh" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" rel="noopener ugc nofollow" target="_blank">准入控制器</a>，它将所有创建或更新的资源发送给Gatekeeper服务进行评估，以确定该资源是否应该被持久化到集群中。</li><li id="fd54" class="nf ng iq kn b ko no ks np kw nq la nr le ns li pe nl nm nn bi translated">我们之前讨论过的ConstraintTemplate，名为<strong class="kn ir"> foosystemrequiredlabels </strong>，被应用到集群中。</li><li id="ca9d" class="nf ng iq kn b ko no ks np kw nq la nr le ns li pe nl nm nn bi translated">网关守护设备内部的OPA进程监视集群中的所有ConstraintTemplates。一旦OPA检测到新的ConstraintTemplate，它就评估它的有效性。如果ConstraintTemplate有效，CRD规范中描述的新定制资源将在集群中可用。</li><li id="d500" class="nf ng iq kn b ko no ks np kw nq la nr le ns li pe nl nm nn bi translated">我们前面提到的名为<strong class="kn ir"> require-billing-label </strong>的<strong class="kn ir"> FooSystemRequiredLabel </strong>类型的约束被应用到集群。只有当OPA在前面的步骤中创建了CRD，我们才能成功地应用它。</li><li id="a2e4" class="nf ng iq kn b ko no ks np kw nq la nr le ns li pe nl nm nn bi translated">Gatekeeper部署中的OPA进程监视集群中ConstraintTemplates中定义的所有约束。一旦约束被验证，在约束范围中定义的所有新创建或更新的资源都应该由在相应的ConstraintTemplate中定义的策略来评估。</li></ol><p id="fdf4" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">这里有几个移动的部分，但是一旦你完成了初始设置(步骤1到3)，你要做的大部分改变包括编写策略(步骤4到7)，这实际上只是应用约束模板和约束。</p><p id="9e7d" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">现在我们已经了解了网守基础设施的高级设置，让我们回顾一下Kubernetes资源因未能遵守我们的策略而被拒绝的流程。</p><h1 id="50c8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Kubernetes资源流被拒绝</h1><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi pf"><img src="../Images/a443c250d7f3f5c5a695ee2dcdde27b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*YUM46qqw0iBo5-bCDGIJHQ.jpeg"/></div></div><figcaption class="pa pb gj gh gi pc pd bd b be z dk translated">Kubernetes资源在网守生态系统中的流动</figcaption></figure><ol class=""><li id="c53f" class="nf ng iq kn b ko mc ks md kw nh la ni le nj li pe nl nm nn bi translated">开发人员将名为<strong class="kn ir"> diamond </strong>的部署应用到昂贵的名称空间。正如我们的<strong class="kn ir"> require-billing-label </strong>中所定义的，我们的策略应该在昂贵的名称空间中创建的任何资源上运行，并提取名为billing的标签。</li><li id="7e62" class="nf ng iq kn b ko no ks np kw nq la nr le ns li pe nl nm nn bi translated">apiserver将请求转发给准入控制器。</li><li id="1f42" class="nf ng iq kn b ko no ks np kw nq la nr le ns li pe nl nm nn bi translated">准入控制器将通过集群上的所有其他准入控制器运行，包括将请求转发给网守服务。</li><li id="6115" class="nf ng iq kn b ko no ks np kw nq la nr le ns li pe nl nm nn bi translated">OPA流程将评估Gatekeeper服务中的请求，以确定它是否匹配任何约束。如果匹配，Gatekeeper将根据相应的策略(ConstraintTemplate)评估所请求的资源。在本例中，名为<strong class="kn ir"> require-billing-label </strong>的<strong class="kn ir"> FooSystemRequiredLabel </strong>类型的约束将根据<strong class="kn ir">foosystemrequired labels</strong>策略匹配并评估部署<strong class="kn ir">菱形</strong>。资源要么未通过策略评估并返回违规消息，要么未通过策略评估并保留到群集。在这种情况下，让我们假设资源没有通过策略评估，因为它缺少计费标签。</li><li id="ae95" class="nf ng iq kn b ko no ks np kw nq la nr le ns li pe nl nm nn bi translated">网关守护设备以拒绝来自集群的资源的决定来响应准入控制器，并且部署不会持续到集群。</li><li id="188a" class="nf ng iq kn b ko no ks np kw nq la nr le ns li pe nl nm nn bi translated">apiserver用作为策略的一部分定义的错误消息来响应用户。</li></ol><p id="954e" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">以上是评估新创建或更改的资源的基本数据流。有一些有用的工具，我们将在以后的章节中讨论如何调试被拒绝的资源，以及Gatekeeper如何处理集群上已经存在的违反策略的资源。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="de9b" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">在下一篇<a class="ae mh" href="https://medium.com/@sebradloff/running-and-writing-gatekeeper-policies-in-kubernetes-part-2-1c49c1c683b2" rel="noopener">文章</a>中，我们将建立一个本地Kubernetes集群并安装网守基础设施。我们将反复编写和测试策略，然后将这些策略应用到我们的本地集群，并观察资源被拒绝和接受。</p></div></div>    
</body>
</html>