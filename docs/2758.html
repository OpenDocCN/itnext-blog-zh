<html>
<head>
<title>Var, Let &amp; Const: JavaScript ES6 Feature Series (Pt 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Var，Let &amp; Const: JavaScript ES6特性系列(第1部分)</h1>
<blockquote>原文：<a href="https://itnext.io/var-let-const-javascript-es6-feature-series-pt-1-fa603567809e?source=collection_archive---------2-----------------------#2019-07-28">https://itnext.io/var-let-const-javascript-es6-feature-series-pt-1-fa603567809e?source=collection_archive---------2-----------------------#2019-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="841f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">让我们从头开始…</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/760087da8bd112730fabff4efd137aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlWDHB6xgx89Co7c5eJuAQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">苏珊·霍尔特·辛普森在<a class="ae lb" href="https://unsplash.com/search/photos/building-blocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="c5a8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="3334" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi ma translated">这些帖子背后的灵感很简单:对于很多开发人员来说，JavaScript是一个谜——或者至少是不太了解。</p><p id="43a6" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">再加上ES6，以及ECMAScript委员会现在计划每年发布的更新，有很多信息需要及时了解。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">抱歉，我控制不了自己——我从遇见你妈妈的时候就爱上了巴尼。</figcaption></figure><p id="1fc4" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">我想提供一些关于我经常使用的JavaScript ES6特性的帖子，供开发人员参考。</p><p id="b6d9" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">我们的目标是让这些文章简短、深入地解释该语言的各种改进(以及如何使用它们)，我希望这些文章能启发您使用JS编写一些真正酷的东西。谁知道呢，在这个过程中你可能会学到一些新东西。😄</p><blockquote class="mq"><p id="d9e3" class="mr ms iq bd mt mu mv mw mx my mz lz dk translated">对于我的第一篇文章，从<code class="fe na nb nc nd b">var</code>、<code class="fe na nb nc nd b">let</code>和<code class="fe na nb nc nd b">const</code>开始是有意义的:JavaScript的构建块。</p></blockquote><h1 id="776e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk bi translated">定义变量</h1><p id="eec9" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe na nb nc nd b"><a class="ae lb" href="https://en.wikipedia.org/wiki/JavaScript_syntax#Variables" rel="noopener ugc nofollow" target="_blank">var</a></code>是最初的JavaScript语法:用OG的方式声明一个变量，并可选地将其初始化为一个值。在ES6成为一种语言之前，它就已经存在了。</p><p id="1560" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">在JavaScript中，变量没有预定义或附加的类型，这意味着任何值都可以存储在任何变量中。一些例子:</p><h2 id="d268" class="nh jo iq bd jp ni nj dn jt nk nl dp jx ln nm nn kb lr no np kf lv nq nr kj ns bi translated"><strong class="ak">给变量赋值</strong></h2><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="feba" class="nh jo iq nd b gy nx ny l nz oa">var one = 1; // the integer 1 has just been assigned to the variable one</span><span id="0413" class="nh jo iq nd b gy ob ny l nz oa">var two = 'two'; // the string 'two' has been assigned to the variable two</span><span id="a3b5" class="nh jo iq nd b gy ob ny l nz oa">var paige = {<br/>  gender: female,<br/>  hairColor: red,<br/>  eyeColor: blue<br/>};<br/>// the object containing a person's traits has been assigned to the variable paige</span></pre><p id="83e4" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">上面所有的<code class="fe na nb nc nd b">var</code>都是JavaScript允许将任何值赋给任何变量的有效例子，不像Java这样的强类型语言，Java(直到最近)要求所有变量在编译前声明和类型化。</p><p id="e34f" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">关于<code class="fe na nb nc nd b">var</code>要知道的另一件事是，不管它是全局作用域还是局部作用域，这些变量都可以随意重新声明和更新。看看这个完美的例子。</p><h2 id="1c60" class="nh jo iq bd jp ni nj dn jt nk nl dp jx ln nm nn kb lr no np kf lv nq nr kj ns bi translated"><strong class="ak">重用不同值类型的相同变量</strong></h2><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="6efa" class="nh jo iq nd b gy nx ny l nz oa">var greet = ‘Hello there’;</span><span id="78ad" class="nh jo iq nd b gy ob ny l nz oa">console.log(greet); // prints: ‘Hello there’</span><span id="67cc" class="nh jo iq nd b gy ob ny l nz oa">greet = true</span><span id="e512" class="nh jo iq nd b gy ob ny l nz oa">console.log(greet); // prints: true</span><span id="3da0" class="nh jo iq nd b gy ob ny l nz oa">greet = 11;</span><span id="85f6" class="nh jo iq nd b gy ob ny l nz oa">console.log(greet); // prints: 11</span><span id="77ec" class="nh jo iq nd b gy ob ny l nz oa">greet = welcome = (name) =&gt; { <br/>  return `Hi ${name}. Welcome!`<br/>};</span><span id="5df1" class="nh jo iq nd b gy ob ny l nz oa">console.log(greet("Paige")); // prints "Hi Paige. Welcome!"</span></pre><p id="5403" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">尽管我重用了现有的变量<code class="fe na nb nc nd b">greet</code>，JavaScript没有抛出任何错误，不管变量是字符串、布尔值、整数——见鬼，甚至是函数。</p><h2 id="194e" class="nh jo iq bd jp ni nj dn jt nk nl dp jx ln nm nn kb lr no np kf lv nq nr kj ns bi translated">变量声明、词法范围和提升</h2><p id="c18d" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在使用<code class="fe na nb nc nd b">var</code>时，有一些事情需要注意(这已经让很多开发人员犯了错误，包括我自己)。这些类型的变量是“词汇作用域”的，并且受制于所谓的“提升”</p><p id="c5df" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">这在执行中意味着一个<code class="fe na nb nc nd b">var</code>类型的变量，不管它是在代码块中的什么地方定义的，都将在代码执行前被拉到其作用域的顶部。例如，如果你写了几行JavaScript，然后声明了<code class="fe na nb nc nd b">var tree = 'elm';</code>，在运行时，在后台，<code class="fe na nb nc nd b">var tree</code>将被“提升”到它被定义的作用域的顶部。</p><p id="cb7a" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">它可能直到几行之后才被赋值给<code class="fe na nb nc nd b">'elm'</code>的值，但是根据JavaScript引擎，这个变量将会存在。这里有一个例子来说明这是如何工作的，以及它可能意味着什么。</p><p id="0c7f" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">JavaScript中的变量声明与变量赋值</strong></p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="a1d1" class="nh jo iq nd b gy nx ny l nz oa">var greeter; // the JS engine knows greeter is a variable, but it doesn't know what value greeter has</span><span id="bd27" class="nh jo iq nd b gy ob ny l nz oa">console.log(greeter); // currently, greeter prints: undefined</span><span id="2082" class="nh jo iq nd b gy ob ny l nz oa">greeter = “say hello”; // now, greeter's been assigned to the value 'say hello'</span><span id="8b98" class="nh jo iq nd b gy ob ny l nz oa">console.log(greeter); // prints: 'say hello'</span></pre><p id="3104" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">词法范围在这里也发挥了作用。不要太深入JavaScript中词法范围的细节(因为那是一篇完整的<em class="oc"> other </em>博客文章)，单词“词法”指的是这样一个事实，词法范围使用变量在源代码中声明的位置来确定该变量在哪里可用。</p><p id="2a26" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">这可以归结为，如果一个变量是在全局范围内创建的，它就被提升到全局范围的顶部，如果这个变量是在一个函数内创建的，它就被提升到函数的顶部，以此类推。</p><p id="fed1" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">下面是JavaScript引擎运行时变量提升和词法作用域的例子。</p><p id="500a" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">基于词法范围的变量提升</strong></p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="3748" class="nh jo iq nd b gy nx ny l nz oa">var something; // declaration is hoisted to the top of the global scope</span><span id="18a0" class="nh jo iq nd b gy ob ny l nz oa">console.log(something); // prints: undefined</span><span id="604a" class="nh jo iq nd b gy ob ny l nz oa">function doAnotherThing() {<br/>  var anotherThing; // declaration is hoisted to the top of the function's lexical scope but not immediately assigned a value</span><span id="1bae" class="nh jo iq nd b gy ob ny l nz oa">  var thisOneThing = 'a defined value'; // this variable is hoisted and then immediately defined</span><span id="7bb4" class="nh jo iq nd b gy ob ny l nz oa">  function useAnotherThing(anotherThing) {<br/>    console.log(`The value of another thing: ${anotherThing}`);<br/>  }</span><span id="c08a" class="nh jo iq nd b gy ob ny l nz oa">  function useThisOneThing(thisOneThing) {<br/>    console.log(`The value of this one thing: ${thisOneThing}`)<br/>  }</span><span id="06f9" class="nh jo iq nd b gy ob ny l nz oa">  useAnotherThing(anotherThing); // prints: "The value of another thing: undefined" because the variable wasn't assigned a value until AFTER the function useAnotherThing() ran</span><span id="13bf" class="nh jo iq nd b gy ob ny l nz oa">  anotherThing = 'an undefined value'; // finally the variable, initialized earlier, is assigned a value</span><span id="bd1b" class="nh jo iq nd b gy ob ny l nz oa">  useThisOneThing(thisOneThing); // prints: "The value of this one thing: a defined value" because the variable was assigned a value before the function useThisOneThing() ran<br/>}</span><span id="b58d" class="nh jo iq nd b gy ob ny l nz oa">something = 'that thing';</span><span id="da44" class="nh jo iq nd b gy ob ny l nz oa">console.log(something); // prints: "that thing"</span><span id="0491" class="nh jo iq nd b gy ob ny l nz oa">console.log(doAnotherThing()); // see printouts above next to inner functions</span></pre><p id="1ecb" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">在上面的例子中，我展示了变量<code class="fe na nb nc nd b">something</code>和<code class="fe na nb nc nd b">anotherThing</code>在被声明后没有被立即赋值，当<code class="fe na nb nc nd b">console.log()</code>被调用时它们是<code class="fe na nb nc nd b">undefined</code>。一旦它们的值在脚本中被进一步设置，并且再次调用<code class="fe na nb nc nd b">console.log()</code>，它们就将它们的值打印到控制台。</p><p id="34bb" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">然而，变量<code class="fe na nb nc nd b">thisOneThing</code>在初始化后立即被初始化并赋值，这意味着当使用它的函数<code class="fe na nb nc nd b">useThisOneThing()</code>运行时(这也是JavaScript <a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>工作的一个例子)，它打印出字符串<code class="fe na nb nc nd b">“The value of this one thing: a defined value.”</code></p><p id="3a5a" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">关于<code class="fe na nb nc nd b">var</code>和它是如何工作的，我想这就足够了。还有上百万的其他教程也在讨论这个问题。现在，让我们来看看令人兴奋的新ES6变量语法，以及这些类型的变量有什么不同。</p><h1 id="c203" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">让</h1><p id="cb10" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe na nb nc nd b"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="noopener ugc nofollow" target="_blank">let</a></code>最终确定，并随着2015年ES6的发布正式引入广泛使用。在引入的两个新变量类型中，它是一对变量中更灵活和短暂的。</p><h2 id="877e" class="nh jo iq bd jp ni nj dn jt nk nl dp jx ln nm nn kb lr no np kf lv nq nr kj ns bi translated">让我们来看看Var的相似之处</h2><p id="e1fd" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">虽然<code class="fe na nb nc nd b">let</code>是一个全新的变量类型，但它确实与<code class="fe na nb nc nd b">var</code>有一些共同之处。例如:</p><ul class=""><li id="5eb3" class="od oe iq le b lf mj lj mk ln of lr og lv oh lz oi oj ok ol bi translated">当<code class="fe na nb nc nd b">let</code>被初始化时，可以选择在初始化时给它赋值，</li><li id="0f15" class="od oe iq le b lf om lj on ln oo lr op lv oq lz oi oj ok ol bi translated"><code class="fe na nb nc nd b">let</code>也是一种变量类型，可以在运行时变异和/或重新分配给不同的数据类型。</li></ul><p id="5fff" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">相似之处也就到此为止了。</p><h2 id="af19" class="nh jo iq bd jp ni nj dn jt nk nl dp jx ln nm nn kb lr no np kf lv nq nr kj ns bi translated">让我们分歧到<code class="fe na nb nc nd b">Var</code></h2><p id="1f2b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">好了，这就是有趣的地方，<code class="fe na nb nc nd b">let</code>开始与<code class="fe na nb nc nd b">var</code>不同。</p><h2 id="5373" class="nh jo iq bd jp ni nj dn jt nk nl dp jx ln nm nn kb lr no np kf lv nq nr kj ns bi translated"><strong class="ak">块范围&amp;变量声明和赋值</strong></h2><p id="2395" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe na nb nc nd b">let</code>是语句范围内的块，或使用它的表达式，不像<code class="fe na nb nc nd b">var</code>，它定义一个全局变量，或局部变量到整个函数，而不管块的范围。</p><p id="3453" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">底线:<code class="fe na nb nc nd b">let</code>存在于(通常)由像so <code class="fe na nb nc nd b">{}</code>这样的花括号定义的代码块中。</p><p id="31d3" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">另外，<code class="fe na nb nc nd b">let</code>的值可以更新，但不能重新声明为同一作用域内的新变量，而<code class="fe na nb nc nd b">var</code>类型的变量可以。下面有一个例子展示了<code class="fe na nb nc nd b">let</code>和<code class="fe na nb nc nd b">var</code>的区别。</p><p id="fb86" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">基于块范围</strong>的 <code class="fe na nb nc nd b"><strong class="le ir">let</strong></code> <strong class="le ir">的有效赋值</strong></p><p id="59cd" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">下面是一个在同一个文件中使用关键字<code class="fe na nb nc nd b">let</code>给变量<code class="fe na nb nc nd b">greeting</code>赋值的有效例子，但是在不同的块范围内。</p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="2aab" class="nh jo iq nd b gy nx ny l nz oa">let greeting = “say Hi”; // one variable declared in the global scope</span><span id="e2fa" class="nh jo iq nd b gy ob ny l nz oa">if (true) {<br/>  let greeting = “say Hello instead”; // another variable of the same name declared within this inner, block scope</span><span id="3893" class="nh jo iq nd b gy ob ny l nz oa">  console.log(greeting); // prints: ”say Hello instead”<br/>}</span><span id="54fb" class="nh jo iq nd b gy ob ny l nz oa">console.log(greeting); // prints: ”say Hi”</span></pre><p id="4d4e" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">由于块范围</strong>，无效的 <code class="fe na nb nc nd b"><strong class="le ir">let</strong></code> <strong class="le ir">赋值</strong></p><p id="6d9a" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">由于这个<code class="fe na nb nc nd b">let greeting</code>变量在全局范围内被赋值，它不能被重新声明并在相同的范围内被重新赋值。如果出现这种情况，它会在控制台中抛出一个<code class="fe na nb nc nd b">SyntaxError</code>。</p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="81ed" class="nh jo iq nd b gy nx ny l nz oa">let greeting = “say Hi”;</span><span id="4d6f" class="nh jo iq nd b gy ob ny l nz oa">let greeting = “say Hello instead”; //SyntaxError: Identifier ‘greeting’ has already been declared</span></pre><p id="88e4" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">用<code class="fe na nb nc nd b">var</code>做同样的事情不会产生这样的错误。</p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="ab95" class="nh jo iq nd b gy nx ny l nz oa">var fruit = "banana";</span><span id="9059" class="nh jo iq nd b gy ob ny l nz oa">console.log(fruit);  // prints: "banana"</span><span id="adb3" class="nh jo iq nd b gy ob ny l nz oa">var fruit = "pear";</span><span id="8d17" class="nh jo iq nd b gy ob ny l nz oa">console.log(fruit); // prints: "pear"</span></pre><h2 id="fca8" class="nh jo iq bd jp ni nj dn jt nk nl dp jx ln nm nn kb lr no np kf lv nq nr kj ns bi translated"><strong class="ak">可变提升(或无提升)和全局对象</strong></h2><p id="2cd0" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">吊装不适用于<code class="fe na nb nc nd b">let</code>。与<code class="fe na nb nc nd b">var</code>不同的是，<code class="fe na nb nc nd b">let</code>类型的变量在解析器对其定义求值之前不会被初始化为<code class="fe na nb nc nd b">undefined</code> <em class="oc">。</em></p><p id="22da" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">如果你试图在代码的初始化部分之前使用一个<code class="fe na nb nc nd b">let</code>变量，你会得到一个<code class="fe na nb nc nd b">ReferenceError</code>抛出。</p><p id="08ae" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">引用</strong> <code class="fe na nb nc nd b"><strong class="le ir">let</strong></code> <strong class="le ir">的错误，因为它在解析</strong>之前被调用</p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="cb2b" class="nh jo iq nd b gy nx ny l nz oa">console.log('test 0', test)</span><span id="aa71" class="nh jo iq nd b gy ob ny l nz oa">let test; // prints: ReferenceError: test is not defined</span></pre><p id="b379" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">在程序和函数的顶层，<code class="fe na nb nc nd b">let</code>与<code class="fe na nb nc nd b">var</code>不同，当在最顶层作用域中声明时，也不在全局<code class="fe na nb nc nd b">window</code>对象上创建属性。这不一定是一件坏事，这意味着对全局名称空间的污染更少，我们都可以从中受益，但这也意味着您不能使用经常被误解的<code class="fe na nb nc nd b">this</code>属性来访问上述全局变量。</p><p id="af81" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">没有带有</strong>和<code class="fe na nb nc nd b"><strong class="le ir">let</strong></code>的全局对象属性</p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="1cbd" class="nh jo iq nd b gy nx ny l nz oa">var x = 'global';</span><span id="a619" class="nh jo iq nd b gy ob ny l nz oa">let y = 'global';</span><span id="09ec" class="nh jo iq nd b gy ob ny l nz oa">console.log(this.x); // prints: "global"</span><span id="992b" class="nh jo iq nd b gy ob ny l nz oa">console.log(this.y); // prints: undefined</span></pre><p id="cc2e" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">好了，我认为关于<code class="fe na nb nc nd b">let</code>已经足够了，是时候转向更严格、更不可变的变量类型<code class="fe na nb nc nd b">const</code>了。</p><h1 id="6685" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">常数</h1><p id="43f8" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe na nb nc nd b"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank">const</a></code>出现在与2015年<code class="fe na nb nc nd b">let</code>相同的ES6版本中。但是<code class="fe na nb nc nd b">let</code>提供了更大的灵活性和更少的永久性变量，<code class="fe na nb nc nd b">const</code>提供了更多的刚性和永久性。</p><p id="f941" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">到目前为止，它也是三种变量类型中最不同的一种。</p><h2 id="a5d5" class="nh jo iq bd jp ni nj dn jt nk nl dp jx ln nm nn kb lr no np kf lv nq nr kj ns bi translated">Const的定义特征</h2><p id="f0b0" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这个变量声明与let共享一些东西。</p><ul class=""><li id="3184" class="od oe iq le b lf mj lj mk ln of lr og lv oh lz oi oj ok ol bi translated"><code class="fe na nb nc nd b">const</code>也是一样，仅限于块范围界定，</li><li id="97ba" class="od oe iq le b lf om lj on ln oo lr op lv oq lz oi oj ok ol bi translated">当在全局范围内创建时，它不会在<code class="fe na nb nc nd b">window</code>对象上创建属性，</li><li id="3ffe" class="od oe iq le b lf om lj on ln oo lr op lv oq lz oi oj ok ol bi translated">当它被声明时，它也必须被赋予一个值，</li><li id="cd8f" class="od oe iq le b lf om lj on ln oo lr op lv oq lz oi oj ok ol bi translated">并且在运行时不会被提升。</li></ul><h2 id="3e18" class="nh jo iq bd jp ni nj dn jt nk nl dp jx ln nm nn kb lr no np kf lv nq nr kj ns bi translated">块作用域</h2><p id="d06d" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Const和<code class="fe na nb nc nd b">let</code>有相同类型的块作用域，但是一旦<code class="fe na nb nc nd b">const</code>被用来声明一个变量，这个值就不能通过重新赋值或者在这个作用域内重新声明来改变。</p><p id="93cd" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><code class="fe na nb nc nd b"><strong class="le ir">const</strong></code>T20【重新分配类型错误】并重新声明同一范围内的语法错误</p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="1a9c" class="nh jo iq nd b gy nx ny l nz oa">const pet = "dog";</span><span id="d92d" class="nh jo iq nd b gy ob ny l nz oa">console.log(pet);  // prints: "dog"</span><span id="0308" class="nh jo iq nd b gy ob ny l nz oa">pet = "cat"; // TypeError: Assignment to constant variable</span><span id="8cfe" class="nh jo iq nd b gy ob ny l nz oa">console.log(pet);</span><span id="4cd0" class="nh jo iq nd b gy ob ny l nz oa">const person = "Sean";</span><span id="ed0f" class="nh jo iq nd b gy ob ny l nz oa">const person = "George"; // SyntaxError: Identifier 'person' has already been declared</span></pre><p id="9679" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">将现有的<code class="fe na nb nc nd b">pet</code>变量指向不同的值或者试图在相同的范围内重新声明<code class="fe na nb nc nd b">person</code>都会导致控制台出错。</p><p id="e5b0" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">但是考虑到块范围，下面的例子没有任何问题。</p><p id="5ce3" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">使用</strong>T5对变量进行有效块范围界定</p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="86ae" class="nh jo iq nd b gy nx ny l nz oa">const pet = "dog";</span><span id="617f" class="nh jo iq nd b gy ob ny l nz oa">console.log(pet);  // prints: "dog"</span><span id="05e7" class="nh jo iq nd b gy ob ny l nz oa">if (true) {<br/>  const pet = "cat"; // TypeError: Assignment to constant variable<br/>  console.log(pet);  // prints: "cat"<br/>}</span><span id="2ae6" class="nh jo iq nd b gy ob ny l nz oa">const person = "Sean";</span><span id="8fec" class="nh jo iq nd b gy ob ny l nz oa">console.log(person); // prints: "Sean"</span><span id="8cf2" class="nh jo iq nd b gy ob ny l nz oa">function meet() { <br/>  const person = "George"; <br/>  console.log(`Meet ${person}`);<br/>}</span><span id="cf1e" class="nh jo iq nd b gy ob ny l nz oa">console.log(meet()); // prints: "Meet George"</span></pre><h2 id="0e87" class="nh jo iq bd jp ni nj dn jt nk nl dp jx ln nm nn kb lr no np kf lv nq nr kj ns bi translated">不变性(某种程度上)</h2><p id="f090" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe na nb nc nd b">const</code>创建一个对值的只读<em class="oc">引用。尽管这个声明的警告是值本身是可变的，但是<code class="fe na nb nc nd b">const</code>一旦被赋值，就不能被重新赋值。</em></p><p id="4224" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">如果<code class="fe na nb nc nd b">const</code>被分配给一个对象，该对象内的属性仍然可以被更新和改变。</p><p id="853d" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><code class="fe na nb nc nd b"><strong class="le ir">const</strong></code> <strong class="le ir">对可更新对象的引用</strong></p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="adc6" class="nh jo iq nd b gy nx ny l nz oa">const greeting = {<br/>  message: ‘Hello there’,<br/>  person: ‘Paige’<br/>};</span><span id="59a1" class="nh jo iq nd b gy ob ny l nz oa">console.log(greeting); // prints: { message: ‘Hello there’, person: ‘Paige’ }</span><span id="fa16" class="nh jo iq nd b gy ob ny l nz oa">greeting.message = ‘Hi there’;</span><span id="73b1" class="nh jo iq nd b gy ob ny l nz oa">console.log(greeting); // prints: { message: ‘Hi there’, person: ‘Paige’ }</span></pre><h2 id="588a" class="nh jo iq bd jp ni nj dn jt nk nl dp jx ln nm nn kb lr no np kf lv nq nr kj ns bi translated">同时声明、初始化且无全局对象</h2><p id="29be" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">像<code class="fe na nb nc nd b">const</code>这样的全局常量<strong class="le ir">而不是</strong>会成为<code class="fe na nb nc nd b">window</code>对象的属性，不像<code class="fe na nb nc nd b">var</code>变量。常数的初始值设定项也是必需的；也就是说，您必须在声明它的同一个语句中指定它的值(这是有意义的，因为它以后不能更改)。</p><p id="8b5c" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><code class="fe na nb nc nd b"><strong class="le ir">const</strong></code> <strong class="le ir">不会用对象属性污染全局范围</strong></p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="ce59" class="nh jo iq nd b gy nx ny l nz oa">var x = 'global';</span><span id="8503" class="nh jo iq nd b gy ob ny l nz oa">const y = 'global';</span><span id="2a93" class="nh jo iq nd b gy ob ny l nz oa">console.log(this.x); // prints: "global"</span><span id="3896" class="nh jo iq nd b gy ob ny l nz oa">console.log(this.y); // prints: undefined</span></pre><p id="9297" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">如果<code class="fe na nb nc nd b">const</code>在初始化时没有赋值，它将抛出一个<code class="fe na nb nc nd b">SyntaxError</code>。同样，如果一个脚本试图在解析器到达变量之前调用它，它将抛出一个ReferenceError，就像<code class="fe na nb nc nd b">let</code>一样，因为<code class="fe na nb nc nd b">const</code>不需要提升，并且在赋值之前不能设置为<code class="fe na nb nc nd b">undefined</code>。</p><p id="c899" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">声明前调用变量或赋值初始化时出错</strong></p><pre class="km kn ko kp gt nt nd nu nv aw nw bi"><span id="23a3" class="nh jo iq nd b gy nx ny l nz oa">console.log(fruitTree); // ReferenceError: fruitTree is not defined</span><span id="eba1" class="nh jo iq nd b gy ob ny l nz oa">const fruitTree = "fig tree";</span><span id="d741" class="nh jo iq nd b gy ob ny l nz oa">const tree; // SyntaxError: Missing initializer in const declaration</span></pre><p id="9a7b" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">这也是关于<code class="fe na nb nc nd b">const</code>的所有信息。</p><h1 id="3797" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="c3c1" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">JavaScript语言已经存在了20多年，甚至ES6在2015年就已经问世，但即使如此，关于它仍然有很多误解和知识差距。</p><p id="86f5" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">本系列文章的目的是消除这些误解，让您更好地理解JavaScript，并介绍一些您可能每天都在使用但没有完全掌握其细微差别的ES6语法。</p><p id="6c2d" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">因为JavaScript中的一切都是围绕变量构建的，所以从<code class="fe na nb nc nd b">var</code>、<code class="fe na nb nc nd b">let</code>和<code class="fe na nb nc nd b">const</code>开始似乎是一个合适的地方。</p><p id="c4e2" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">过几周再来看看，我会写更多关于JavaScript和ES6或其他与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="71e5" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">感谢阅读，我希望你学到了一些关于JS最基本的构建模块的新东西:不起眼的变量。如果你觉得有帮助，请与你的朋友分享！</p><p id="8f18" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">如果你喜欢读这篇文章，你可能也会喜欢我的其他博客:</strong></p><ul class=""><li id="6784" class="od oe iq le b lf mj lj mk ln of lr og lv oh lz oi oj ok ol bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-international-methods-b70a2de09d92"> JavaScript国际方法</a></li><li id="f099" class="od oe iq le b lf om lj on ln oo lr op lv oq lz oi oj ok ol bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/using-es6-to-destructure-nested-objects-in-javascript-avoid-undefined-errors-that-break-your-code-612ae67913e9">使用ES6在JavaScript &amp;中析构深度嵌套的对象，避免未定义的错误破坏你的代码</a></li><li id="c9d4" class="od oe iq le b lf om lj on ln oo lr op lv oq lz oi oj ok ol bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascripts-async-await-versus-promise-the-great-debate-6308cb2e10b3"> JavaScript的异步/等待与承诺:大辩论</a></li></ul></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><p id="a3ef" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">参考资料和更多资源:</strong></p><ul class=""><li id="f8d2" class="od oe iq le b lf mj lj mk ln of lr og lv oh lz oi oj ok ol bi translated">Var，MDN Docs:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Statements/var</a></li><li id="79d7" class="od oe iq le b lf om lj on ln oo lr op lv oq lz oi oj ok ol bi translated">Let，MDN Docs:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Statements/let</a></li><li id="f85b" class="od oe iq le b lf om lj on ln oo lr op lv oq lz oi oj ok ol bi translated">Const，MDN Docs:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Statements/const</a></li><li id="7db8" class="od oe iq le b lf om lj on ln oo lr op lv oq lz oi oj ok ol bi translated">JavaScript语法，维基百科:<a class="ae lb" href="https://en.wikipedia.org/wiki/JavaScript_syntax" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/JavaScript_syntax</a></li></ul></div></div>    
</body>
</html>