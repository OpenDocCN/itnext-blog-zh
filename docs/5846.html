<html>
<head>
<title>CSS nth- Selectors Variable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSS第n个选择器变量</h1>
<blockquote>原文：<a href="https://itnext.io/css-nth-selectors-variable-502eccae2e03?source=collection_archive---------1-----------------------#2021-06-09">https://itnext.io/css-nth-selectors-variable-502eccae2e03?source=collection_archive---------1-----------------------#2021-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c2a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让CSS第n个选择器在Web组件中可变的实用技巧。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e5611da620d00fef17e3437e9e00cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCYvMc19HUEZEmZylGOoGg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@mariogogh?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马里奥·高</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="da29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用CSS变量，至少当我在2021年6月写这几行的时候，在媒体查询或选择器中是不支持的，例如<code class="fe lv lw lx ly b">:nth-child(var(--my-variable))</code>不起作用。</p><p id="b424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有点不幸，但并非无法解决。在最近的一些开发中，我通过将DOM中的<code class="fe lv lw lx ly b">style</code>元素注入到我的Web组件中，绕过了这个限制，以便在<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>中动画化代码块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="04f1" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">介绍</h1><p id="05ce" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">严格来说，下面的技巧并不局限于Web组件，可能也适用于任何元素。我只是到目前为止只使用了这种技术😜。</p><p id="cec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将首先在一个普通组件的帮助下展示这个想法，然后用同样的方法结束这篇文章，但是用一个<a class="ae ky" href="https://stenciljs.com/" rel="noopener ugc nofollow" target="_blank"> StencilJS </a>功能组件实现。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="8c9f" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">教程的目标</h1><p id="9876" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们将开发一个Web组件来呈现一个<code class="fe lv lw lx ly b">&lt;ul/&gt;</code>列表，并可以动画显示其条目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/d94f022601f0492ed99d6281c0e8f1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*V_biZYrvRQsoYUdph7U_qQ.gif"/></div></figure><p id="3d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦加载了组件，就不会在DOM中添加或删除任何语义元素。动画将通过修改<code class="fe lv lw lx ly b">style</code>来实现，更准确地说是通过在选中的<code class="fe lv lw lx ly b">li:nth-child(n)</code>上应用不同的样式。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3141" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">香草JS</h1><p id="e1cd" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">为了展示这个想法，我们创建了一个<code class="fe lv lw lx ly b">index.html</code>页面。它消耗了我们将要开发的普通组件。我们还添加了一个<code class="fe lv lw lx ly b">button</code>来触发动画。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="8c2e" class="nk mj it ly b gy nl nm l nn no">&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;script type="module" src="./my-component.js"&gt;&lt;/script&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;my-component&gt;&lt;/my-component&gt;<br/><br/>        &lt;button&gt;Next&lt;/button&gt;<br/><br/>        &lt;script&gt;<br/>            document<br/>              .querySelector('button')<br/>              .addEventListener(<br/>                 'click', <br/>                 () =&gt; document.querySelector('my-component').next()<br/>              );<br/>        &lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="a1b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个名为<code class="fe lv lw lx ly b">my-component.js</code>的单独文件中，我们创建了Web组件。此时没有任何动画。我们声明<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">打开</a>以便能够访问阴影DOM(通过<code class="fe lv lw lx ly b">shadowRoot</code>，我们创建一个样式来隐藏所有的<code class="fe lv lw lx ly b">li</code>并定义<code class="fe lv lw lx ly b">transition</code>。最后，我们添加<code class="fe lv lw lx ly b">ul</code>列表及其子列表<code class="fe lv lw lx ly b">li</code>。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="3fee" class="nk mj it ly b gy nl nm l nn no">class MyComponent extends HTMLElement {<br/><br/>    constructor() {<br/>        super();<br/><br/>        this.attachShadow({mode: 'open'});<br/><br/>        const style = this.initStyle();<br/>        const ul = this.initElement();<br/><br/>        this.shadowRoot.appendChild(style);<br/>        this.shadowRoot.appendChild(ul);<br/>    }<br/><br/>    connectedCallback() {<br/>        this.className = 'hydrated';<br/>    }<br/><br/>    next() {<br/>        // TODO in next chapter<br/>    }<br/><br/>    initStyle() {<br/>        const style = document.createElement('style');<br/><br/>        style.innerHTML = `<br/>          :host {<br/>            display: block;<br/>          }<br/>          <br/>          li {<br/>            opacity: 0;<br/>            transition: opacity 0.5s ease-out;<br/>          }<br/>        `;<br/><br/>        return style;<br/>    }<br/><br/>    initElement() {<br/>        const ul = document.createElement('ul');<br/><br/>        const li1 = document.createElement('li');<br/>        li1.innerHTML = 'Spine';<br/><br/>        const li2 = document.createElement('li');<br/>        li2.innerHTML = 'Cowboy';<br/><br/>        const li3 = document.createElement('li');<br/>        li3.innerHTML = 'Shelving';<br/><br/>        ul.append(li1, li2, li3);<br/><br/>        return ul;<br/>    }<br/>}<br/><br/>customElements.define('my-component', MyComponent);</span></pre><p id="35b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，如果我们在浏览器(<code class="fe lv lw lx ly b">npx serve .</code>)中打开我们的示例，我们应该会发现一个组件，它有一个隐藏的内容和一个还没有生效的按钮。没什么可看的，但这是个开始😁。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/05d7089145c13916ba916fd4e5922b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ODDEgNnoHmsbGwgIPuT5zA.png"/></div></div></figure><p id="3922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了开发动画，我们必须跟踪显示的<code class="fe lv lw lx ly b">li</code>，这就是为什么我们给组件添加一个状态(<code class="fe lv lw lx ly b">index</code>)。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="e618" class="nk mj it ly b gy nl nm l nn no">class MyComponent extends HTMLElement {</span><span id="625c" class="nk mj it ly b gy nq nm l nn no">    index = 0;<br/>    <br/>    constructor() {</span><span id="bb21" class="nk mj it ly b gy nq nm l nn no">...</span></pre><p id="d4f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了它，我们可以实现<code class="fe lv lw lx ly b">next()</code>方法，这个方法是从我们之前在HTML页面中添加的按钮调用的。</p><blockquote class="nr ns nt"><p id="8cfa" class="kz la nu lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">不是我最漂亮的代码。让我们承认它只是一个演示目的😅。</p></blockquote><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="6de1" class="nk mj it ly b gy nl nm l nn no">next() {<br/>    this.index = this.index === 3 ? 1 : this.index + 1;<br/><br/>    const selector = `<br/>      li:nth-child(${this.index}) {<br/>        opacity: 1;<br/>      }<br/>    `;<br/><br/>    let style = this.shadowRoot.querySelector('style#animation');<br/><br/>    if (style) {<br/>        style.innerHTML = selector;<br/>        return;<br/>    }<br/><br/>    style = document.createElement('style');<br/>    style.setAttribute('id', 'animation');<br/><br/>    style.innerHTML = selector;<br/><br/>    this.shadowRoot.appendChild(style);<br/>}</span></pre><p id="0be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那里发生了什么事？</p><p id="6f53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它首先设置要显示的下一个<code class="fe lv lw lx ly b">index</code>、<code class="fe lv lw lx ly b">li</code>，并创建一个CSS <code class="fe lv lw lx ly b">selector</code>来应用<code class="fe lv lw lx ly b">opacity</code>样式。简而言之，这取代了我们不能使用的CSS变量。</p><p id="f268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们检查Web组件的阴影内容是否已经包含了一个应用动画的专用样式。如果是，我们用新的值选择器更新样式，如果不是，我们创建一个新的样式标签。</p><p id="fd4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次调用该方法时，都会应用一个新的<code class="fe lv lw lx ly b">style</code>，因此会显示另一个<code class="fe lv lw lx ly b">li:nth-child(n)</code>。</p><p id="1ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们再次打开我们的浏览器尝试一下，在点击我们的按钮<code class="fe lv lw lx ly b">next</code>时项目应该是动画的，如果我们进一步观察检查器中的组件，我们应该注意到隐藏的<code class="fe lv lw lx ly b">style</code>元素在每次方法调用时都发生了变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/146ca3b0fc46ac46870f4e19a6a1f797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G76KWZf9do9aBnCo2rtLdw.png"/></div></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="8638" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">StencilJS</h1><p id="7508" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">让我们用同样的例子来增加乐趣，但是使用一个<a class="ae ky" href="https://stenciljs.com/" rel="noopener ugc nofollow" target="_blank"> StencilJS </a>功能组件🤙。</p><blockquote class="nr ns nt"><p id="6d09" class="kz la nu lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">您可以使用命令行<code class="fe lv lw lx ly b">npm init stencil</code>启动一个新项目</p></blockquote><p id="76ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们正在开发完全相同的组件，所以我们可以复制以前的HTML内容(声明组件，并在项目的<code class="fe lv lw lx ly b">./src/index.html</code>中添加一个<code class="fe lv lw lx ly b">button</code>),只有一点小小的不同，方法<code class="fe lv lw lx ly b">next()</code>必须声明，并用async-await调用。这是一个要求—模板的最佳实践，组件的公共方法必须是<code class="fe lv lw lx ly b">async</code>。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="b3fa" class="nk mj it ly b gy nl nm l nn no">&lt;!DOCTYPE html&gt;<br/>&lt;html dir="ltr" lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8" /&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0" /&gt;<br/>    &lt;title&gt;Stencil Component Starter&lt;/title&gt;<br/><br/>    &lt;script type="module" src="/build/demo-stencil.esm.js"&gt;&lt;/script&gt;<br/>    &lt;script nomodule src="/build/demo-stencil.js"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;</span><span id="0e4f" class="nk mj it ly b gy nq nm l nn no">  &lt;!-- Same code as in previous chapter --&gt;</span><span id="9396" class="nk mj it ly b gy nq nm l nn no">  &lt;my-component&gt;&lt;/my-component&gt;<br/><br/>  &lt;button&gt;Next&lt;/button&gt;<br/><br/>  &lt;script&gt;<br/>    document.querySelector('button')<br/>       .addEventListener(<br/>          'click', <br/>          async () =&gt; await document<br/>                             .querySelector('my-component').next()<br/>            );<br/>  &lt;/script&gt;</span><span id="3073" class="nk mj it ly b gy nq nm l nn no">  &lt;!-- Same code as in previous chapter --&gt;</span><span id="e25f" class="nk mj it ly b gy nq nm l nn no">  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="6602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以重复前面的步骤，首先创建一个组件，它除了呈现一个<code class="fe lv lw lx ly b">ul</code>列表和隐藏项目<code class="fe lv lw lx ly b">li</code>之外什么也不做。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="2760" class="nk mj it ly b gy nl nm l nn no">import { Component, h } from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'my-component',<br/>  styles: `:host {<br/>      display: block;<br/>    }<br/><br/>    li {<br/>      opacity: 0;<br/>      transition: opacity 0.5s ease-out;<br/>    }<br/>  `,<br/>  shadow: true,<br/>})<br/>export class MyComponent {<br/>  render() {<br/>    return &lt;ul&gt;<br/>      &lt;li&gt;Spine&lt;/li&gt;<br/>      &lt;li&gt;Cowboy&lt;/li&gt;<br/>      &lt;li&gt;Shelving&lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  }<br/>}</span></pre><p id="9aa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过测试组件(<code class="fe lv lw lx ly b">npm run start</code>)，我们也应该得到相同的结果😉。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/a967627fb10908760ba9ad7d6bd1cc47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qw2VVn0rZlENtjlYY9Yp1Q.png"/></div></div></figure><p id="aa1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了跟踪要突出显示的<code class="fe lv lw lx ly b">li</code>，我们需要一个状态和函数<code class="fe lv lw lx ly b">state</code>。我们将两者都添加到我们的组件中。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="a303" class="nk mj it ly b gy nl nm l nn no">@State()<br/>private index: number = 0;<br/><br/>@Method()<br/>async next() {<br/>  this.index = this.index === 3 ? 1 : this.index + 1;<br/>}</span></pre><p id="1f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与普通组件相比，因为我们使用了一个简化开发的捆绑器，所以我们不需要自己负责重新渲染。对<code class="fe lv lw lx ly b">state</code>的每次修改都会触发一次重新渲染，最终更新那些必须更新的节点(并且只更新那些必须更新的节点)。</p><p id="ab26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，我们必须实现CSS选择器变量。出于这样的目的，如前所述，我们将使用一个功能组件。它可能与类组件一起工作，但是我觉得函数组件更适合这项工作。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="9b58" class="nk mj it ly b gy nl nm l nn no">const Animate: FunctionalComponent&lt;{index: number;}&gt; = ({index}) =&gt; {<br/>  return (<br/>    &lt;style&gt;{`<br/>    li:nth-child(${index}) {<br/>      opacity: 1;<br/>    }<br/>  `}&lt;/style&gt;<br/>  );<br/>};</span></pre><p id="b393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该组件为我们作为参数传递的值(我们的<code class="fe lv lw lx ly b">state</code>)呈现一个<code class="fe lv lw lx ly b">style</code>元素。</p><p id="fbf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们必须使用功能组件，并将其绑定到我们的状态值。这样，每当它的值改变时，它将被重新呈现。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="6f19" class="nk mj it ly b gy nl nm l nn no">render() {<br/>  return &lt;Host&gt;<br/>    &lt;Animate index={this.index}&gt;&lt;/Animate&gt;<br/>    &lt;ul&gt;<br/>      &lt;li&gt;Spine&lt;/li&gt;<br/>      &lt;li&gt;Cowboy&lt;/li&gt;<br/>      &lt;li&gt;Shelving&lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  &lt;/Host&gt;<br/>}</span></pre><p id="e6e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经完成了，我们能够复制相同的组件🥳.</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/4e13a7374a70d5cb9bda98930bc2d540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*9DoGPKFedgsKnVMQp5wWIg.gif"/></div></figure><p id="49b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单个代码块中的上述组件:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="2624" class="nk mj it ly b gy nl nm l nn no">import { Component, FunctionalComponent, h, Host, Method, State } from '@stencil/core';<br/><br/>const Animate: FunctionalComponent&lt;{index: number;}&gt; = ({index}) =&gt; {<br/>  return (<br/>    &lt;style&gt;{`<br/>    li:nth-child(${index}) {<br/>      opacity: 1;<br/>    }<br/>  `}&lt;/style&gt;<br/>  );<br/>};<br/><br/>@Component({<br/>  tag: 'my-component',<br/>  styles: `:host {<br/>      display: block;<br/>    }<br/><br/>    li {<br/>      opacity: 0;<br/>      transition: opacity 0.5s ease-out;<br/>    }<br/>  `,<br/>  shadow: true,<br/>})<br/>export class MyComponent {<br/><br/>  @State()<br/>  private index: number = 0;<br/><br/>  @Method()<br/>  async next() {<br/>    this.index = this.index === 3 ? 1 : this.index + 1;<br/>  }<br/><br/>  render() {<br/>    return &lt;Host&gt;<br/>      &lt;Animate index={this.index}&gt;&lt;/Animate&gt;<br/>      &lt;ul&gt;<br/>        &lt;li&gt;Spine&lt;/li&gt;<br/>        &lt;li&gt;Cowboy&lt;/li&gt;<br/>        &lt;li&gt;Shelving&lt;/li&gt;<br/>      &lt;/ul&gt;<br/>    &lt;/Host&gt;<br/>  }<br/>}</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d34f" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">摘要</h1><p id="2bac" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">老实说，我不确定这篇文章是否会找到读者，也不认为它有一天会对某个人有用，但是，我喜欢用这个技巧😜。此外，为了演示的目的，用普通的JS或Stencil开发同样的代码也很有趣。</p><p id="c186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到无限和更远的地方！</p><p id="18e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大卫</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="9caf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以通过<a class="ae ky" href="https://twitter.com/daviddalbusco" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或我的<a class="ae ky" href="https://daviddalbusco.com/" rel="noopener ugc nofollow" target="_blank">网站</a>联系我。</p><p id="0762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为您的下一个演示，尝试一下<a class="ae ky" href="https://deckdeckgo.com/" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://deckdeckgo.com"><div class="gh gi oa"><img src="../Images/69b0d343c3513ad1c22907adecf84a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JhaczOFbeFh32v19.png"/></div></a></figure></div></div>    
</body>
</html>