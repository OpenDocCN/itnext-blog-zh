<html>
<head>
<title>Python &amp; GraphQL. Tips, tricks and performance improvements.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python &amp; GraphQL。提示、技巧和性能改进。</h1>
<blockquote>原文：<a href="https://itnext.io/python-graphql-tips-tricks-and-performance-improvements-beede1f4adb6?source=collection_archive---------1-----------------------#2019-01-23">https://itnext.io/python-graphql-tips-tricks-and-performance-improvements-beede1f4adb6?source=collection_archive---------1-----------------------#2019-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/164238f897d81991202189a72ce794cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44fWs3WIpBbQqVjJxj6zvA.png"/></div></div></figure><p id="67ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近我用GraphQL完成了另一个后端，但现在是在Python上。在这篇文章中，我想告诉你我所面临的所有困难和可能影响表现的狭窄地方。</p><p id="d117" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">技术栈:<a class="ae kw" href="https://graphene-python.org/" rel="noopener ugc nofollow" target="_blank">石墨烯</a> + <a class="ae kw" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank">烧瓶</a>和<a class="ae kw" href="https://github.com/graphql-python/graphene-sqlalchemy" rel="noopener ugc nofollow" target="_blank"> sqlalchemy </a>集成。这里有一段<code class="fe kx ky kz la b">requirements.txt</code>:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="9b8e" class="lj lk iq la b gy ll lm l ln lo">graphene<br/>graphene_sqlalchemy<br/>flask<br/>flask-graphql<br/>flask-sqlalchemy<br/>flask-cors<br/>injector<br/>flask-injector</span></pre><p id="4aa0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这允许我将数据库实体直接映射到GraphQL。</p><p id="6e5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来是这样的:</p><p id="1617" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模型。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="656d" class="lj lk iq la b gy ll lm l ln lo">class Color(db.Model):<br/>  """color table"""<br/>  __tablename__ = 'colors'<br/><br/>  color_id = Column(BigInteger().with_variant(sqlite.INTEGER(), 'sqlite'), primary_key=True)<br/>  color_name = Column(String(50), nullable=False)<br/>  color_r = Column(SmallInteger)<br/>  color_g = Column(SmallInteger)<br/>  color_b = Column(SmallInteger)</span></pre><p id="8448" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">节点。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="ffda" class="lj lk iq la b gy ll lm l ln lo">class ColorNode(SQLAlchemyObjectType):<br/>  class Meta:<br/>    model = colours.Color<br/>    interfaces = (relay.Node,)<br/><br/>  color_id = graphene.Field(BigInt)</span></pre><p id="9d62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切都简单美好。</p><p id="160e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是有什么问题呢？</p><h1 id="814e" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">烧瓶环境。</h1><p id="8fee" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">在写这篇文章的时候，我无法将我的上下文发送到GraphQL。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="3c1a" class="lj lk iq la b gy ll lm l ln lo">app.add_url_rule('/graphql',<br/>                 view_func=GraphQLView.as_view('graphql',<br/>                 schema=schema.schema,<br/>                 graphiql=True,<br/>                 context_value={'session': db.session})<br/>                 )</span></pre><p id="0b15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这东西对我不起作用，因为视图在<a class="ae kw" href="https://github.com/graphql-python/flask-graphql" rel="noopener ugc nofollow" target="_blank"> flask-graphql </a>集成中被flask request取代。</p><p id="81ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也许现在这个问题已经解决了，但是我必须子类化GrqphQLView来保存上下文:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="0fee" class="lj lk iq la b gy ll lm l ln lo">class ContexedView(GraphQLView):<br/>  context_value = None<br/><br/>  def get_context(self):<br/>    context = super().get_context()<br/>    if self.context_value:<br/>      for k, v in self.context_value.items():<br/>        setattr(context, k, v)<br/>    return context</span></pre><h1 id="1a0f" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">CORS支持</h1><p id="22e3" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">总是我忘记补充的东西:)</p><p id="3599" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于Python Flask，只需在需求中添加<a class="ae kw" href="https://flask-cors.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> flask-cors </a>，并通过<code class="fe kx ky kz la b">CORS(app)</code>在create_app方法中设置它。仅此而已。</p><h1 id="2426" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Bigint类型</h1><p id="85b5" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我必须创建自己的bigint类型，因为我在数据库中使用它作为一些列的主键。当我尝试发送int类型时，出现了石墨烯错误。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="7411" class="lj lk iq la b gy ll lm l ln lo">class BigInt(Scalar):<br/>  @staticmethod<br/>  def serialize(num):<br/>    return num<br/><br/>  @staticmethod<br/>  def parse_literal(node):<br/>    if isinstance(node, ast.StringValue) or isinstance(node, ast.IntValue):<br/>      return int(node.value)<br/><br/>  @staticmethod<br/>  def parse_value(value):<br/>    return int(value)</span></pre><h1 id="bf42" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">复合主键</h1><p id="f874" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">此外，graphene_sqlalchemy不支持开箱即用的复合主键。我有一个带有(Int，Int，Date)主键的表。为了通过Relay的节点接口按id进行解析，我必须覆盖get_node方法:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="7d1e" class="lj lk iq la b gy ll lm l ln lo">@classmethod<br/>def get_node(cls, info, id):<br/>  import datetime<br/>  return super().get_node(info, eval(id))</span></pre><p id="1505" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">datetime</code> import和<code class="fe kx ky kz la b">eval</code>在这里非常重要，因为没有它们，日期字段将只是一个字符串，在查询数据库时什么都不会起作用。</p><h1 id="b04b" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">授权突变</h1><p id="613f" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">为查询授权真的很容易，我所需要的就是添加查看器对象并编写<code class="fe kx ky kz la b">get_token</code>和<code class="fe kx ky kz la b">get_by_token</code>方法，就像我以前在java中多次做的那样。</p><p id="2c1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是突变被称为绕过<code class="fe kx ky kz la b">Viewer</code>，这是GraphQL的天性。</p><p id="22e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不想在每个变异的头中添加授权代码，因为这会导致代码重复，这有点危险，因为我可能会因为忘记添加这些代码而创建一个后门。</p><p id="9bef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我有子类突变和重新实现它是这样的<code class="fe kx ky kz la b">mutate_and_get_payload</code>:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="1fdc" class="lj lk iq la b gy ll lm l ln lo">class AuthorizedMutation(relay.ClientIDMutation):<br/>  class Meta:<br/>    abstract = True<br/><br/>  @classmethod<br/>  @abstractmethod<br/>  def mutate_authorized(cls, root, info, **kwargs):<br/>    pass<br/><br/>  @classmethod<br/>  def mutate_and_get_payload(cls, root, info, **kwargs):<br/>    # authorize user using info.context.headers.get('Authorization')<br/>    return cls.mutate_authorized(root, info, **kwargs)</span></pre><p id="185f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的所有突变都继承了<code class="fe kx ky kz la b">AuthorizedMutation</code>的子类，并在<code class="fe kx ky kz la b">mutate_authorized</code>中实现了它们的业务逻辑。仅当用户被授权时才调用它。</p><h1 id="debf" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">可排序和可过滤的连接</h1><p id="47b1" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">为了让我的数据通过query in connection自动排序(将排序选项添加到模式中)，我必须子类化relay的connection并实现get_query方法(它在graphene_sqlalchemy中被调用)。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="2e09" class="lj lk iq la b gy ll lm l ln lo">class SortedRelayConnection(relay.Connection):<br/>  class Meta:<br/>    abstract = True<br/><br/>  @classmethod<br/>  def get_query(cls, info, **kwargs):<br/>    return SQLAlchemyConnectionField.get_query(cls._meta.node._meta.model, info, **kwargs)</span></pre><p id="a885" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我决定在每个字段上添加动态过滤。也具有扩展模式。</p><p id="ce06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开箱即用的石墨烯做不到这一点，所以我不得不再加一个<a class="ae kw" href="https://github.com/graphql-python/graphene-sqlalchemy/pull/164" rel="noopener ugc nofollow" target="_blank"> PR </a>和子类连接一次:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="0ebd" class="lj lk iq la b gy ll lm l ln lo">class FilteredRelayConnection(relay.Connection):<br/>  class Meta:<br/>    abstract = True<br/><br/>  @classmethod<br/>  def get_query(cls, info, **kwargs):<br/>    return FilterableConnectionField.get_query(cls._meta.node._meta.model, info, **kwargs)</span></pre><p id="f629" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">《T2》是在哪里被引入PR的。</p><h1 id="5b92" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">哨兵中间件</h1><p id="7a56" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我们使用sentry作为错误通知系统，很难让它与石墨烯一起工作。Sentry有很好的烧瓶集成，但石墨烯的问题是——它会吞掉异常，并在响应中将它们作为错误返回。</p><p id="a7b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不得不使用我自己的中间件:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="700a" class="lj lk iq la b gy ll lm l ln lo">class SentryMiddleware(object):<br/><br/>  def __init__(self, sentry) -&gt; None:<br/>    self.sentry = sentry<br/><br/>  def resolve(self, next, root, info, **args):<br/>    promise = next(root, info, **args)<br/>    if promise.is_rejected:<br/>      promise.catch(self.log_and_return)<br/>    return promise<br/><br/>  def log_and_return(self, e):<br/>    try:<br/>      raise e<br/>    except Exception:<br/>      traceback.print_exc()<br/>      if self.sentry.is_configured:<br/>      if not issubclass(type(e), NotImportantUserError):<br/>        self.sentry.captureException()<br/>    return e</span></pre><p id="dbaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它在GraphQL路由创建中注册:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="438d" class="lj lk iq la b gy ll lm l ln lo">app.add_url_rule('/graphql',<br/>                 view_func=ContexedView.as_view('graphql',<br/>                 schema=schema.schema,<br/>                 graphiql=True,<br/>                 context_value={'session': db.session},<br/>                 middleware=[SentryMiddleware(sentry)]<br/>                )</span></pre><h1 id="9b64" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">低绩效与关系</h1><p id="6c42" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">一切都很好，测试是绿色的，我很高兴，直到我的应用程序进入开发环境，有了大量的数据。一切都超级慢。</p><p id="8e53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题出在sqlalchemy的关系上。他们因<a class="ae kw" href="https://docs.sqlalchemy.org/en/latest/orm/loading_relationships.html" rel="noopener ugc nofollow" target="_blank">默认</a>而懒惰。</p><p id="2324" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">意思是——如果你有一个有3个关系的图:主人-&gt;宠物-&gt;食物，并且查询它们，第一个查询将接收所有主人(<code class="fe kx ky kz la b">select * from masters`</code>)。你收到了20个。然后，对于每个主节点，将会有查询(<code class="fe kx ky kz la b">select * from pets where master_id = ?</code>)。20个查询。最后，基于宠物返回的N个食物查询。</p><p id="5c90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在这里的建议是——如果你有复杂的关系和大量的数据(我正在为大数据世界写后端)，你必须让所有的关系都变得热切。查询本身会更难，但它只有一个，大大减少了响应时间。</p><h1 id="47f0" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">自定义查询的性能改进</h1><p id="3b96" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">在我让我的关键关系变得热切(不是所有关系，我必须研究前端应用程序，以了解他们查询什么以及如何查询)之后，一切都工作得更快了，但还不够。我看着生成的查询，有点害怕——它们太可怕了！我必须为一些节点编写自己的优化查询。</p><p id="66ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果我有一个有几个<code class="fe kx ky kz la b">OrderColorDistributions</code>的<code class="fe kx ky kz la b">PlanMonthly</code>实体，每个实体有一个<code class="fe kx ky kz la b">Order</code>。</p><p id="d18c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以使用子查询来限制数据(记住，我正在为大数据编写后端)，并用现有数据填充关系(无论如何，我在查询中有这些数据，所以没有必要使用ORM生成的急切连接)。这将有助于请求。</p><p id="a2bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">步骤:</p><ol class=""><li id="b3ce" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated">标记子查询<code class="fe kx ky kz la b">with_labels=True</code></li></ol><p id="1467" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.使用root(对于此请求)实体作为返回实体:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="563a" class="lj lk iq la b gy ll lm l ln lo">Order.query \<br/>  .filter(&lt;low level filtering here&gt;) \<br/>  .join(&lt;join another table, which you can use later&gt;) \<br/>  .join(ocr_query, Order.order_id == ocr_query.c.order_color_distribution_order_id) \<br/>  .join(date_limit_query,<br/>        and_(ocr_query.c.order_color_distribution_color_id == date_limit_query.c.plans_monthly_color_id,<br/>             ocr_query.c.order_color_distribution_date == date_limit_query.c.plans_monthly_date,<br/>             &lt;another table joined previously&gt; == date_limit_query.c.plans_monthly_group_id))</span></pre><p id="8f99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.在所有一级关系上使用contains_eager。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="7060" class="lj lk iq la b gy ll lm l ln lo">query = query.options(contains_eager(Order.color_distributions, alias=ocr_query))</span></pre><p id="eb85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.如果你有第二层关系(<code class="fe kx ky kz la b">Order</code>-&gt;-<code class="fe kx ky kz la b">OrderColorDistribution</code>-&gt;-<code class="fe kx ky kz la b">PlanMonthly</code>)链<code class="fe kx ky kz la b">contains_eager</code>:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="531d" class="lj lk iq la b gy ll lm l ln lo">query = query.options(contains_eager(Order.color_distributions, alias=ocr_query)<br/>             .contains_eager(OrderColorDistribution.plan, alias=date_limit_query))</span></pre><h1 id="0fd6" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">减少对数据库的调用次数</h1><p id="5c43" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">除了数据呈现层，我还有我的服务层，它对GraphQL一无所知。我不打算在这里介绍它，因为我不喜欢高耦合。</p><p id="a253" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是每项服务都需要提取几个月的数据。为了只使用一次所有的数据并在所有的服务中使用它们，我使用了带有<code class="fe kx ky kz la b">@request</code>作用域的injector。记住这个作用域，它是你在GraphQL中的朋友。</p><p id="274c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它像单例一样工作，但是只在对<code class="fe kx ky kz la b">/graphql</code>的一个请求中。在我的连接中，我只是用通过GraphQL查询找到的计划填充它(包括来自前端的所有自定义过滤器和范围):</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="b6d0" class="lj lk iq la b gy ll lm l ln lo">app.injector.get(FutureMonthCache).set_months(found)</span></pre><p id="b206" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在所有需要访问这些数据的服务中，我只使用这个缓存:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="4a3a" class="lj lk iq la b gy ll lm l ln lo">@inject<br/>def __init__(self,<br/>             prediction_service: PredictionService,<br/>             price_calculator: PriceCalculator,<br/>             future_month_cache: FutureMonthCache) -&gt; None:<br/>  super().__init__(future_month_cache)<br/>  self._prediction_service = prediction_service<br/>  self._price_calculator = price_calculator</span></pre><p id="0881" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一件好事是——我所有的服务，操作数据和形成请求，也有<code class="fe kx ky kz la b">@request</code>作用域，所以我不需要计算每个月的预测。我从缓存中取出它们，进行一次查询并存储结果。此外，一个服务可以依赖其他服务的计算数据。请求范围在这里很有帮助，因为它允许我只计算所有数据一次。</p><p id="fde8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在节点端，我通过解析器调用我的请求范围服务:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="8cfd" class="lj lk iq la b gy ll lm l ln lo">def resolve_predicted_pieces(self, _info):<br/>  return app.injector.get(PredictionCalculator).get_original_future_value(self)</span></pre><p id="3100" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有在GraphQL查询中指定了predicted_pieces时，它才允许我运行繁重的计算。</p><h1 id="a391" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">总结</h1><p id="c07e" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这就是我所面临的所有困难。我没有尝试过websocket订阅，但是根据我所了解的情况，我可以说Python的GraphQL比Java的更灵活。因为Python本身的灵活性。但是如果我打算在高负载后端工作，我宁愿不使用GraphQL，因为它更难优化。</p></div></div>    
</body>
</html>