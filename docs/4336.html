<html>
<head>
<title>.NET Core and BitBucket Pipelines!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。NET Core和BitBucket管道！</h1>
<blockquote>原文：<a href="https://itnext.io/net-core-and-bitbucket-pipelines-9e8cb86b1dd6?source=collection_archive---------0-----------------------#2020-06-10">https://itnext.io/net-core-and-bitbucket-pipelines-9e8cb86b1dd6?source=collection_archive---------0-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="abf4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">CI/CD渠道故事</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/ad555f6ed98b168671e07cb1126a91f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*LXVPic7-MlTpx0f8j42C-Q.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">构建—测试—缓存</figcaption></figure><p id="d36e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在一个团队中工作，BitBucket是我们的git仓库。BitBucket中的CI/CD与市场上的其他竞争对手如Azure DevOps、GitLab、GitHub几乎相同。在这篇文章中，我解释了如何为。网芯。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="2888" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">步骤1:准备好您的管道！</h2><ol class=""><li id="deaf" class="mq mr it kw b kx ms la mt ld mu lh mv ll mw lp mx my mz na bi translated">创建您的BitBucket repo，并将最新版本的代码放入其中</li><li id="aafa" class="mq mr it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated">创建您的管道:(从左侧菜单中选择管道，然后选择。从右边的下拉列表中选择核心网)</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/4bfd24cc96b929f988d3f6df6faebdb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61CJXCSaYQ3XlOuiiI2rGQ.png"/></div></div></figure><p id="9065" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认的bitbucket-pipelines.yml类似于下面的YAML代码:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="5af4" class="lx ly it nm b gy nq nr l ns nt"># Only use spaces to indent your .yml configuration.<br/># -----<br/># You can specify a custom docker image from Docker Hub as your build environment.<br/>image: microsoft/dotnet:sdk</span><span id="7915" class="lx ly it nm b gy nu nr l ns nt">pipelines:<br/>  default:<br/>    - step:<br/>        caches:<br/>          - dotnetcore<br/>        script: # Modify the commands below to build your repository.<br/>          - export PROJECT_NAME=yourProjectName<br/>          - export TEST_NAME=yourTestName<br/>          - dotnet restore<br/>          - dotnet build $PROJECT_NAME<br/>          - dotnet test $TEST_NAME</span></pre><p id="550f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">BitBucket管道非常简洁，因为它为每个构建使用了docker容器。来支持。网芯3.1把docker镜像改成<code class="fe nv nw nx nm b">mcr.microsoft.com/dotnet/core/sdk:3.1</code>。</p><p id="508f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="ny">💡从</em> <a class="ae nz" href="https://hub.docker.com/_/microsoft-dotnet-core" rel="noopener ugc nofollow" target="_blank"> <em class="ny">官方微软docker hub页面</em> </a> <em class="ny">获取所有docker图片列表。</em></p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d91d" class="lx ly it nm b gy nq nr l ns nt"># Only use spaces to indent your .yml configuration.<br/># -----<br/># You can specify a custom docker image from Docker Hub as your build environment.<br/>image: <!-- -->mcr.microsoft.com/dotnet/core/sdk:3.1</span><span id="87d0" class="lx ly it nm b gy nu nr l ns nt">pipelines:<br/>  default:<br/>    - step:<br/>        caches:<br/>          - dotnetcore<br/>        script: <br/>          - export SOLUTION_NAME=MyProject          <br/>          - export CONFIGURATION=Release<br/>          - dotnet restore SOLUTION_NAME.sln<br/>          - dotnet build --no-restore $SOLUTION_NAME.sln --configuration $CONFIGURATION<br/>          - dotnet test --no-build $SOLUTION_NAME.sln</span></pre><ul class=""><li id="cbb4" class="mq mr it kw b kx ky la lb ld oa lh ob ll oc lp od my mz na bi translated">将管道<strong class="kw iu"> docker图像</strong>更改为<strong class="kw iu">。网芯SDK 3.1 </strong>。</li><li id="da65" class="mq mr it kw b kx nb la nc ld nd lh ne ll nf lp od my mz na bi translated">创建一个名为<strong class="kw iu"> SOLUTION_NAME </strong>的变量，并将MyProject值赋给它。</li><li id="b169" class="mq mr it kw b kx nb la nc ld nd lh ne ll nf lp od my mz na bi translated">使用<strong class="kw iu"> SOLUTION_NAME变量</strong>执行<strong class="kw iu"> restore，build，test </strong>命令。</li></ul><p id="b34b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">管道很小，但是它完成了CI部分的工作。这个管道令人兴奋的部分之一是缓存部分；第一次构建可能需要一段时间来获取SDK映像或恢复Nuget包，但由于缓存部分，接下来的构建将会很快。</p><p id="b1bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管这个管道运行测试，但是您看不到它们的细节，因为您需要以<a class="ae nz" href="https://llg.cubic.org/docs/junit/" rel="noopener ugc nofollow" target="_blank"> JUNIT </a>格式记录结果。例如，请看下图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oe"><img src="../Images/c5d2212e72244d16a6b0d7b235b545e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oEfl4yvND7QQGAdjx_FU1g.png"/></div></div></figure><p id="4db7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它构建并运行测试，一切正常，但是我看不到它通过了多少测试！</p><h2 id="5483" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">步骤2:点网测试和JUnit格式</h2><p id="385e" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld of lf lg lh og lj lk ll oh ln lo lp im bi translated">Dotnet test命令有一个选项，用于确定测试结果的输出文件格式。尽管如此，它不支持内置格式的JUnit，但是您可以安装第三方记录器来启用JUnit格式的dotnet测试命令日志。</p><p id="8c3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最好的伐木工之一是T21的JUnitTestLogger项目。快速将它安装到您的测试项目中。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="bb52" class="lx ly it nm b gy nq nr l ns nt"># As an example for my own project<br/>cd ./Web.Tests<br/>dotnet add package JUnitTestLogger --version 1.1.0</span></pre><h2 id="324f" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">步骤3:更改管道来生成日志！</h2><p id="2b2f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld of lf lg lh og lj lk ll oh ln lo lp im bi translated">每个位桶管道的最后一部分是拆卸步骤。在该部分中，BitBucket在以下名为<strong class="kw iu">【test-results，failsafe-reports，test-reports，surefire-reports】</strong>的目录中查找日志文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oi"><img src="../Images/3e4a70c2267725b5759ec06fdfa1296e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hnBCHJaWVAdIbrlFeI-9A.png"/></div></div></figure><p id="c454" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要为输出测试日志定义一个新的变量，如下所示:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="c375" class="lx ly it nm b gy nq nr l ns nt">REPORTS_REL_PATH=./test-reports/build_${BITBUCKET_BUILD_NUMBER}</span></pre><p id="8226" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="ny">💡</em> <code class="fe nv nw nx nm b"><em class="ny">${BITBUCKET_BUILD_NUMBER} </em></code> <em class="ny">是</em> <a class="ae nz" href="https://confluence.atlassian.com/bitbucket/variables-in-pipelines-794502608.html" rel="noopener ugc nofollow" target="_blank"> <em class="ny">中的一个，内置变量</em> </a> <em class="ny">在每条管道中。</em></p><p id="9526" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们只需要将这个参数传递给dotnet test命令，生成JUnit XML格式的测试结果，并存储在<code class="fe nv nw nx nm b">test-reports</code>目录中。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3b14" class="lx ly it nm b gy nq nr l ns nt">— test-adapter-path:. — logger:”junit;LogFilePath=$REPORTS_REL_PATH/junit.xml”</span></pre><p id="49a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更改后的YAML文件:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4fca" class="lx ly it nm b gy nq nr l ns nt"># Only use spaces to indent your .yml configuration.<br/># -----<br/># You can specify a custom docker image from Docker Hub as your build environment.<br/>image: mcr.microsoft.com/dotnet/core/sdk:3.1<br/>pipelines:<br/>  default:<br/>    - step:<br/>        caches:<br/>          - dotnetcore<br/>        script: <br/>          - export SOLUTION_NAME=MyProject          <br/>          - export CONFIGURATION=Release<br/>          - export REPORTS_REL_PATH=./test-reports/build_${BITBUCKET_BUILD_NUMBER}<br/>          - export REPORTS_PATH=./${PROJECT_NAME}/test-reports/build_${BITBUCKET_BUILD_NUMBER}    <br/>          - dotnet restore SOLUTION_NAME.sln<br/>          - dotnet build --no-restore $SOLUTION_NAME.sln --configuration $CONFIGURATION<br/>          - dotnet test --no-build $SOLUTION_NAME.sln --test-adapter-path:. --logger:"junit;LogFilePath=$REPORTS_REL_PATH/junit.xml"</span></pre><p id="e3b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于这一改变，您可以看到通过测试的数量，如果有任何测试失败，您可以访问失败的详细信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oj"><img src="../Images/c237b584580ce51e33a0b029cac189a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BErY_S80FHfqDkNrWwMLYw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">失败和成功测试的样本</figcaption></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="09eb" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">最后一步，但可能不是最后一步:发布人工制品</h2><p id="fdf6" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld of lf lg lh og lj lk ll oh ln lo lp im bi translated">使用“点网发布”命令发布点网项目很容易。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="06c6" class="lx ly it nm b gy nq nr l ns nt">dotnet publish --configuration $CONFIGURATION  --no-build ./Web/Web.csproj -o ./publish</span></pre><p id="e57d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该命令将web应用程序发布到发布目录中。现在我们需要告诉BitBucket管道来保存这些人工制品。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="6da6" class="lx ly it nm b gy nq nr l ns nt">artifacts:<br/> - publish/**</span></pre><p id="0e46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最终的YAML文件:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="06f2" class="lx ly it nm b gy nq nr l ns nt"># Only use spaces to indent your .yml configuration.<br/># -----<br/># You can specify a custom docker image from Docker Hub as your build environment.<br/>image: mcr.microsoft.com/dotnet/core/sdk:3.1<br/>pipelines:<br/>  default:<br/>    - step:<br/>        caches:<br/>          - dotnetcore<br/>        script: <br/>          - export SOLUTION_NAME=MyProject          <br/>          - export CONFIGURATION=Release<br/>    - export WEB_PROJECT_NAME=Web<br/>          - export REPORTS_REL_PATH=./test-reports/build_${BITBUCKET_BUILD_NUMBER}  <br/>          - dotnet restore SOLUTION_NAME.sln<br/>          - dotnet build --no-restore $SOLUTION_NAME.sln --configuration $CONFIGURATION<br/>          - dotnet test --no-build $SOLUTION_NAME.sln --test-adapter-path:. --logger:"junit;LogFilePath=$REPORTS_REL_PATH/junit.xml"<br/>          - dotnet publish --configuration $CONFIGURATION --no-build ./Web/${WEB_PROJECT_NAME}.csproj -o ./publish<br/>        artifacts: <br/>          - ./publish/**</span></pre><p id="0634" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，在每个管道作业之后，您可以访问管道结果中的artefacts选项卡，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ok"><img src="../Images/4594bdf6f6c7931da357fe88b579c55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1f5vEV6Y0nLr2FOXzGEgIg.png"/></div></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="a9f9" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">下一步是什么？</h2><p id="2368" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld of lf lg lh og lj lk ll oh ln lo lp im bi translated">您几乎已经为进一步的步骤做好了一切准备，比如集成测试和<a class="ae nz" href="https://confluence.atlassian.com/bitbucket/using-artifacts-in-steps-935389074.html" rel="noopener ugc nofollow" target="_blank">使用工件进行部署</a>。</p><p id="d90b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">祝您集成和部署顺利。</p></div></div>    
</body>
</html>