<html>
<head>
<title>User Authentication with Guardian for Phoenix 1.3 Web Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Guardian for Phoenix 1.3 Web应用程序进行用户认证</h1>
<blockquote>原文：<a href="https://itnext.io/user-authentication-with-guardian-for-phoenix-1-3-web-apps-e2064cac0ec1?source=collection_archive---------0-----------------------#2018-02-19">https://itnext.io/user-authentication-with-guardian-for-phoenix-1-3-web-apps-e2064cac0ec1?source=collection_archive---------0-----------------------#2018-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/39af1bc2b52a3a3f6912330d66598b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fKwrhnrmi_7SRVFclnbmg.jpeg"/></div></div></figure><p id="affa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fuser-authentication-with-guardian-for-phoenix-1–3-web-apps-e2064cac0ec1" rel="noopener ugc nofollow" target="_blank"> <em class="la">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="85c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">身份验证是大多数web应用程序不可或缺的一部分。在本文中，我将展示如何使用Guardian库和Phoenix 1.3基于用户名/密码对用户进行身份验证。登录的用户信息将保存在会话中，以便管理员可以轻松检查和保护敏感资源，防止未经授权的用户访问。</p><p id="2b0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文中我将使用的示例项目基于Chris McCord的书——编程凤凰——高效| &gt;可靠| &gt;快速。我已经根据书中的内容编写了<strong class="kd iu"> rumbl </strong>项目，并对其进行了相应的转换以支持Phoenix 1.3。只有身份验证部分被修改为使用Guardian。完整的项目代码和测试可以在我的github <a class="ae kz" href="https://github.com/imeraj/Phoenix_rumbl" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="d72d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用于Guardian的github <a class="ae kz" href="https://github.com/ueberauth/guardian" rel="noopener ugc nofollow" target="_blank">文档</a>非常好，但是对于一个新手来说，完成所有这些并进行认证可能是一项艰巨的任务。本文的目的是解读其中的一些文本，并提供工作代码来轻松引导项目的认证部分。</p><h1 id="e28a" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">设置依赖关系</strong>:</h1><p id="6e26" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在<strong class="kd iu"> mix.exs </strong>中添加以下依赖关系:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1271" class="mn lc it mj b gy mo mp l mq mr">defp deps <strong class="mj iu">do<br/>  </strong>[<br/>    {:guardian, "~&gt; 1.0"},<br/>    {:comeonin, "~&gt; 4.0"},<br/>    {:bcrypt_elixir, "~&gt; 1.0"}<br/>  ]<br/><strong class="mj iu">end</strong></span></pre><p id="800d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里—</p><p id="5ab9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">i. guardian:是认证库</p><p id="726b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">二。c <a class="ae kz" href="https://github.com/riverrun/comeonin" rel="noopener ugc nofollow" target="_blank"> omeonin </a>:是仙丹的密码哈希库</p><p id="ea9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">三。bcrypt_elixir:是comeonin使用的密码散列算法</p><h1 id="8828" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">实施监护人回调</strong></h1><p id="9741" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">创建下面的模块来设置Guardian回调(<strong class="kd iu"> guardian.ex </strong> ) —</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2d6d" class="mn lc it mj b gy mo mp l mq mr">defmodule Rumbl.Auth.Guardian <strong class="mj iu">do<br/>  </strong>@moduledoc <strong class="mj iu">false<br/><br/>  </strong>use Guardian, otp_app: :rumbl<br/><br/>  alias Rumbl.Accounts<br/><br/>  def subject_for_token(user, _claims) <strong class="mj iu">do<br/>    </strong>sub = to_string(user.id)<br/>    {:ok, sub}<br/>  <strong class="mj iu">end<br/><br/>  </strong>def resource_from_claims(claims) <strong class="mj iu">do<br/>    </strong>id = claims["sub"]<br/>    user = Accounts.get_user(id)<br/>    {:ok, user}<br/>  <strong class="mj iu">end<br/>end</strong></span></pre><p id="92a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们想在<strong class="kd iu">帐户</strong>上下文中使用<strong class="kd iu">用户</strong>模式来认证<strong class="kd iu">用户</strong>。(<em class="la">你可以通读本节在Guardian github上的评论，更好地理解回调</em>)。</p><h1 id="c2e2" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">配置监护人:</strong></h1><p id="c09d" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在<strong class="kd iu"> config.exs </strong>中添加以下内容以配置Guardian —</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6aff" class="mn lc it mj b gy mo mp l mq mr"># Configures Guardian<br/>config :rumbl, Rumbl.Auth.Guardian,<br/>  issuer: "rumbl",<br/>  secret_key: "HNinpKh9Ne3tr8BpjCpAEh0xzCqTIG3PWsfkR2AtzvUaRIpbs6oIQ9RcmjmGPekJ"</span></pre><h1 id="c196" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">注册时创建密码哈希:</strong></h1><p id="78b4" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">完成上述设置后，我们就可以提供特定于应用程序的更改，以便在数据库中存储散列密码，并在登录请求发出时对用户进行身份验证。</p><p id="a39c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在<strong class="kd iu"> user.ex </strong>中的注册变更集如下所示</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="459c" class="mn lc it mj b gy mo mp l mq mr">def registration_changeset(%User{} = user, attrs) <strong class="mj iu">do<br/>  </strong>user<br/>  |&gt; cast(attrs, [:name, :username, :password])<br/>  |&gt; validate_required([:name, :username, :password])<br/>  |&gt; validate_length(:username, min: 3, max: 10)<br/>  |&gt; validate_length(:password, min: 5, max: 10)<br/>  |&gt; unique_constraint(:username)<br/>  |&gt; put_password_hash()<br/><strong class="mj iu">end</strong></span><span id="5f9a" class="mn lc it mj b gy ms mp l mq mr">defp put_password_hash(changeset) <strong class="mj iu">do<br/>  </strong>case changeset <strong class="mj iu">do<br/>    </strong>%Ecto.Changeset{valid?: <strong class="mj iu">true</strong>, changes: %{password: pass}} -&gt;<br/>      put_change(changeset, :password_hash, Comeonin.Bcrypt.hashpwsalt(pass))<br/><br/>    _ -&gt;<br/>      changeset<br/>  <strong class="mj iu">end<br/>end</strong></span></pre><p id="0fbd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，在注册期间，我们使用bcrypt计算一个密码，并将其放入变更集，以便在用户成功注册时保存在DB中。</p><h1 id="6f1e" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">验证用户/登录:</h1><p id="db55" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">每当用户尝试登录时，就会调用一个sessioncontoller#create操作，其中会写入身份验证代码—</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0c04" class="mn lc it mj b gy mo mp l mq mr">def create(conn, %{"session" =&gt; %{"username" =&gt; user, "password" =&gt; password}}) <strong class="mj iu">do<br/>  </strong>case <strong class="mj iu">Rumbl.Auth.authenticate_user</strong>(user, password) <strong class="mj iu">do<br/>    </strong>{:ok, user} -&gt;<br/>      conn<br/>      |&gt; <strong class="mj iu">Rumbl.Auth.login(user)</strong><br/>      |&gt; put_flash(:info, "Welcome back!")<br/>      |&gt; redirect(to: user_path(conn, :index))<br/><br/>    {:error, _reason} -&gt;<br/>      conn<br/>      |&gt; put_flash(:error, "Invalid username/password combination")<br/>      |&gt; render("new.html")<br/>  <strong class="mj iu">end<br/>end</strong></span></pre><p id="35a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，重要的行用粗体显示。<strong class="kd iu"> Rumbl。Auth.authenticate_user </strong>从params获取用户名和密码，并对用户进行身份验证</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="16b3" class="mn lc it mj b gy mo mp l mq mr">def authenticate_user(username, given_password) <strong class="mj iu">do<br/>  </strong>query = Ecto.Query.from(u in User, where: u.username == ^username)<br/><br/>  Repo.one(query)<br/>  |&gt; check_password(given_password)<br/><strong class="mj iu">end<br/><br/></strong>defp check_password(<strong class="mj iu">nil</strong>, _), <strong class="mj iu">do</strong>: {:error, "Incorrect username or password"}<br/><br/>defp check_password(user, given_password) <strong class="mj iu">do<br/>  </strong>case Bcrypt.checkpw(given_password, user.password_hash) <strong class="mj iu">do<br/>    true </strong>-&gt; {:ok, user}<br/>    <strong class="mj iu">false </strong>-&gt; {:error, "Incorrect username or password"}<br/>  <strong class="mj iu">end<br/>end</strong></span></pre><p id="72b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码非常简单。这里，首先使用用户名从数据库中检索用户，并将其与<strong class="kd iu"> check_password </strong>中存储的数据库散列密码进行匹配。</p><p id="e1f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果认证成功，<strong class="kd iu"> Rumbl。Auth.login(user) </strong>被调用(<strong class="kd iu"> auth.ex </strong> ) —</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7eb0" class="mn lc it mj b gy mo mp l mq mr">def login(conn, user) <strong class="mj iu">do<br/>  </strong>conn<br/>  |&gt; Guardian.Plug.sign_in(user)<br/>  |&gt; assign(:current_user, user)<br/><strong class="mj iu">end</strong></span></pre><p id="bc65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这基本上是一个在会话中存储用户信息并将用户分配给<strong class="kd iu"> current_user </strong>的插件。</p><h1 id="b73b" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">注销用户:</strong></h1><p id="458b" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">注销代码非常简单。每当用户注销时，就会调用sessioncontroller#delete操作，并注销用户——</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ce2f" class="mn lc it mj b gy mo mp l mq mr">def delete(conn, _) <strong class="mj iu">do<br/>  </strong>conn<br/>  |&gt; <strong class="mj iu">Rumbl.Auth.logout()</strong><br/>  |&gt; redirect(to: page_path(conn, :index))<br/><strong class="mj iu">end</strong></span></pre><p id="dd19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码中突出显示的粗体部分如下所示(<strong class="kd iu"> auth/auth.ex </strong> ) —</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="231e" class="mn lc it mj b gy mo mp l mq mr">def logout(conn) <strong class="mj iu">do<br/>  </strong>conn<br/>  |&gt; Guardian.Plug.sign_out()<br/><strong class="mj iu">end</strong></span></pre><h1 id="48b1" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">封堵管线保护线路:</strong></h1><p id="921a" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在基本认证工作之后，我们需要保护路由免受未授权用户的访问。为此，我们需要定义下面的管道(<strong class="kd iu">auth _ access _ pipeline . ex)</strong>—</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3477" class="mn lc it mj b gy mo mp l mq mr">defmodule Rumbl.Auth.AuthAccessPipeline <strong class="mj iu">do<br/>  </strong>@moduledoc <strong class="mj iu">false<br/><br/>  </strong>use Guardian.Plug.Pipeline, otp_app: :rumbl<br/><br/>  plug(Guardian.Plug.VerifySession, claims: %{"typ" =&gt; "access"})<br/>  plug(Guardian.Plug.EnsureAuthenticated)<br/>  plug(Guardian.Plug.LoadResource)<br/><strong class="mj iu">end</strong></span></pre><p id="807f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里—</p><p id="dc52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一.<strong class="kd iu">监护人。Plug.VerifySession </strong> —在会话中查找令牌并验证它</p><p id="b1c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">二。<strong class="kd iu">守护者。Plug.EnsureAuthenticated </strong> —确保找到了一个令牌并且它是有效的</p><p id="f900" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">三。<strong class="kd iu">守护者。Plug.LoadResource — </strong>如果找到了一个令牌，就为它加载资源</p><p id="0e95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们需要将管道和错误处理程序添加到<strong class="kd iu"> config.exs </strong>中的配置中</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ba30" class="mn lc it mj b gy mo mp l mq mr">config :rumbl, Rumbl.Auth.AuthAccessPipeline,<br/>  module: Rumbl.Auth.Guardian,<br/>  error_handler: <strong class="mj iu">Rumbl.Auth.AuthErrorHandler</strong></span></pre><p id="2e6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">错误处理器是一个实现<code class="fe mt mu mv mj b">auth_error</code>功能的模块。Rumbl。Auth.AuthErrorHandler 在<strong class="kd iu"> auth_error_handler.ex </strong>中定义</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a02c" class="mn lc it mj b gy mo mp l mq mr">defmodule Rumbl.Auth.AuthErrorHandler <strong class="mj iu">do<br/>  </strong>@moduledoc <strong class="mj iu">false<br/><br/>  </strong>import Plug.Conn<br/><br/>  def auth_error(conn, {type, _reason}, _opts) <strong class="mj iu">do<br/>    </strong>body = Poison.encode!(%{message: to_string(type)})<br/>    send_resp(conn, 401, body)<br/>  <strong class="mj iu">end<br/>end</strong></span></pre><p id="db37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们需要修改<strong class="kd iu"> router.ex </strong>来使用上面提到的管道来保护被认证的路由—</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b6cd" class="mn lc it mj b gy mo mp l mq mr">pipeline :auth <strong class="mj iu">do<br/>  </strong>plug(Rumbl.Auth.AuthAccessPipeline)<br/><strong class="mj iu">end</strong></span><span id="add8" class="mn lc it mj b gy ms mp l mq mr">scope "/", RumblWeb <strong class="mj iu">do<br/>  </strong>pipe_through([:browser, :auth])<br/><br/>  resources("/users", UserController, only: [:index, :show])<br/>  resources("/videos", VideoController)<br/>  resources("/sessions", SessionController, only: [:delete])<br/>  get("/watch/:id", WatchController, :show)<br/><strong class="mj iu">end</strong></span></pre><h1 id="a091" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">获取控制器中的当前用户:</strong></h1><p id="00f2" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在控制器中，我们经常需要当前登录的用户信息。为此，我写了下面的插件—</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8039" class="mn lc it mj b gy mo mp l mq mr">def load_current_user(conn, _) <strong class="mj iu">do<br/>  </strong>conn<br/>  |&gt; assign(:current_user, Guardian.Plug.current_resource(conn))<br/><strong class="mj iu">end</strong></span></pre><p id="5b34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以把它放在任何需要current_user的控制器上面—</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="136b" class="mn lc it mj b gy mo mp l mq mr">import Rumbl.Auth, only: [load_current_user: 2]<br/><br/>plug(:load_current_user when action in [:show, :index])</span></pre><p id="3e30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这应该让你开始使用Guardian在Phoenix web app中进行身份验证。完整的项目代码和测试可以在我的github <a class="ae kz" href="https://github.com/imeraj/Phoenix_rumbl" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="f3f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="la">更多详细和深入的未来技术帖子请关注我这里或点击</em> <a class="ae kz" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"> <em class="la"> twitter </em> </a> <em class="la">。</em></p></div></div>    
</body>
</html>