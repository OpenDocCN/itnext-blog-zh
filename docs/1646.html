<html>
<head>
<title>Production ready Node.js REST API Setup using TypeScript, PostgreSQL and Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript、PostgreSQL和Redis设置生产就绪Node.js REST API</h1>
<blockquote>原文：<a href="https://itnext.io/production-ready-node-js-rest-apis-setup-using-typescript-postgresql-and-redis-a9525871407?source=collection_archive---------0-----------------------#2018-12-20">https://itnext.io/production-ready-node-js-rest-apis-setup-using-typescript-postgresql-and-redis-a9525871407?source=collection_archive---------0-----------------------#2018-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cebcb501f38bfdb90736510570d5929a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXG3RQK9OvhLdfnTSV1Y8Q.png"/></div></div></figure><p id="ff6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个月前，我开发了一个简单的搜索API。它所要做的就是从第三方服务和我们的数据库中抓取一些数据，将所有数据组合起来，然后返回给客户端。这两天听起来是个不错的任务。但是构建一个服务需要的远不止这些。它包括缓存、日志记录、处理各种错误、管理节点实例、安全性、监控，如果能实现来自<a class="ae kw" href="https://github.com/i0natan/nodebestpractices" rel="noopener ugc nofollow" target="_blank"> Node.js最佳实践</a>的大多数模式，那就太好了。</p><p id="e147" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本教程假设您熟悉Node.js和Express。还有，你需要非常基础的打字稿知识。如果你没有，先在5分钟内检查<a class="ae kw" href="http://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html" rel="noopener ugc nofollow" target="_blank">的打字稿。确保你有</a><a class="ae kw" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">最新的Node LTS版本</a>。</p><p id="72bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然有几十种不同的Node.js设置，但只有少数几个覆盖了PostgreSQL并完全使用TypeScript。</p><p id="486b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在深入研究代码之前，让我们先定义一下我们的技术堆栈:</p><ol class=""><li id="798f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">严格模式的打字稿</strong>。必须显式指定所有类型。</li><li id="1277" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">快递</strong>。上一个版本完全支持async/await，所以在我们的路由/控制器中没有回调和明确的承诺。</li><li id="3330" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> PostgreSQL </strong>。这次是关系数据库。让我们看看它有多容易使用。</li><li id="5ed0" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">TypeORM  —用TypeScript编写的强大的ORM，支持迁移，活动记录，有一个优秀的查询生成器等等。</li><li id="02c6" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">温斯顿</strong>——一个几乎所有事情的记录者:)</li><li id="d5af" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">雷迪斯</strong>。我们将使用这个内存存储进行缓存。这将增加一行额外的代码，从而带来巨大的性能差异。</li><li id="6e0f" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> PM2 </strong> — p <a class="ae kw" href="http://pm2.keymetrics.io/" rel="noopener ugc nofollow" target="_blank">进程管理器</a>对于node.js应用，它包括集群、负载均衡、简单的终端监控和日志管理。</li></ol><p id="87b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一部分中，我们将关注项目结构和构建我们的API，并添加节点集群。在第二部分中，我们将看到如何在我们的服务之上添加许多很酷的东西:缓存、日志、使用TypeORM。但是这部分更多的是关于代码。</p><p id="69d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/alexpermyakov/node-rest-api/tree/step.5" rel="noopener ugc nofollow" target="_blank">这是该零件的最终代码</a>。</p><h2 id="1d5c" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">第一步。初始化TypeScript Node.js项目。</h2><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/660cadc282e0c41f7171e560ea2fe358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IuSOzcKoIApjsrf8jE10Cw.jpeg"/></div></div></figure><p id="039a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在2018年末，没有理由不对Node使用TypeScript，设置非常简单，所以，让我们开始吧！</p><p id="c295" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个项目文件夹，并将我们的项目命名为search-api。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9d4a" class="ll lm iq mk b gy mo mp l mq mr">$ mkdir search-api<br/>$ cd search-api<br/>$ npm init -y</span></pre><p id="1602" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，安装typescript和tsc-watch，以便在每次源文件改变时运行我们的服务器。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3054" class="ll lm iq mk b gy mo mp l mq mr">$ npm i typescript tsc-watch</span></pre><p id="e6a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">tsc-watch的解决方案很优雅，它在引擎盖下使用了<em class="ms"> tsc -w </em>，一旦TS编译器编译了所有的更改。它将重启我们的服务器。</p><p id="a518" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将package.json中的脚本部分改为:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6d9a" class="ll lm iq mk b gy mo mp l mq mr">"scripts": {<br/>   "dev": "tsc-watch --onSuccess \"node ./dist/server.js\""<br/>}</span></pre><p id="b4d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在运行它之前，我们必须为TypeScript编译器创建一个配置。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="d147" class="ll lm iq mk b gy mo mp l mq mr">$ npx tsc --init --moduleResolution node --resolveJsonModule --target es6 --noImplicitAny --sourceMap --lib dom,es2017 --outDir dist</span></pre><p id="3428" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用<a class="ae kw" href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" rel="noopener">npx</a>——一个npm包运行程序，用于本地运行已安装的包，在我们的例子中是<em class="ms"> tsc </em>。现在我们在项目根目录下有了一个<em class="ms"> tsconfig.json </em>文件。</p><p id="ce09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，它监视所有。<em class="ms">中的ts文件。/src </em>文件夹并在<em class="ms">中编译。/dist </em>文件夹。还有，<em class="ms">。默认情况下会排除/node_modules </em>。</p><p id="4bf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步，我们将创建一个<em class="ms"> server.ts </em>文件</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2fa6" class="ll lm iq mk b gy mo mp l mq mr">$ mkdir src &amp;&amp; touch ./src/server.ts</span></pre><p id="a88d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们写一个sum函数，每秒钟<em class="ms"> console.log </em>一次。将此添加到<em class="ms"> server.ts </em>文件中。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ae19" class="ll lm iq mk b gy mo mp l mq mr">const sum = (<em class="ms">a</em>: number, <em class="ms">b</em>: number) =&gt; a + b;<br/>setInterval(() =&gt; console.log(sum(2, 3)), 1000);</span></pre><p id="5703" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，一切都准备好运行我们的命令</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="fedc" class="ll lm iq mk b gy mo mp l mq mr">$ npm run dev</span></pre><p id="bdbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它创造了一个<em class="ms">。/dist </em>文件夹，在这里你可以找到一个编译好的<em class="ms"> server.js </em>文件。在终端中，您将每秒看到新的输出。尝试更改此代码，结果将会更新。这就是我们一起使用TS + Node所需的全部内容😃。</p><p id="f2a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们在这里没有使用<em class="ms"> nodemon </em>。主要原因是我们不需要它，因为ts-watch既编译又重启我们的服务器。同时，一起使用ts和nodemon可能会非常棘手。我将为我们设置的每个步骤提供一个链接，<a class="ae kw" href="https://github.com/alexpermyakov/node-rest-api/tree/step.1" rel="noopener ugc nofollow" target="_blank">这里是第一步</a>的代码。</p><h2 id="8ca4" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">第二步。用Express.js创建项目结构。</h2><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/36e895d731a6863b9d9f6efab75e5bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*bIB2pMCinyCV0Y46sAwXwA.png"/></div></figure><p id="ecd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在很多express/KOA/哈比神教程中看到的一个东西是一个非常长的<em class="ms"> server.js </em>文件。它包括所有的中间件/插件和另一个样板代码。但这不是唯一的问题。我们还需要一个地方来配置数据库，记录器，redisClient，swagger。我们必须决定在哪里以及如何放置我们的路线/控制器/模型。在这种情况下，我们将遵循Node.js最佳实践中的<a class="ae kw" href="https://github.com/i0natan/nodebestpractices#1-project-structure-practices" rel="noopener ugc nofollow" target="_blank">项目结构实践。</a></p><p id="dbcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">听起来相当多，但是这个有那么多吗？我们来想办法吧！</p><p id="0487" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从项目根目录运行此命令:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="fddb" class="ll lm iq mk b gy mo mp l mq mr">$ mkdir ./src/config ./src/middleware ./src/services ./src/utils</span></pre><p id="3114" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">项目结构将如下所示:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/16cb8a4719fe39bec9dc16ccd006bd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ktxANCVJUiGFbdOgs94z-Q.png"/></div></div></figure><p id="9441" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个服务文件夹，其中包含应用程序的独立子部分，如用户、产品、订单等。在我们的例子中，它将是一个搜索子文件夹。但是在我们开始之前，让我们用一些经典的中间件来创建<em class="ms"> express </em>服务器。</p><p id="b812" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们安装最新的express版本。然后是用于管理CORS、响应压缩和项目根节点的TS类型的包:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="84a9" class="ll lm iq mk b gy mo mp l mq mr">$ npm i express@5.0.0-alpha.7 <a class="ae kw" href="http://twitter.com/types/express" rel="noopener ugc nofollow" target="_blank">@types/express</a> cors <a class="ae kw" href="http://twitter.com/types/cors" rel="noopener ugc nofollow" target="_blank">@types/cors</a> compression <a class="ae kw" href="http://twitter.com/types/compression" rel="noopener ugc nofollow" target="_blank">@types/compression</a> <a class="ae kw" href="http://twitter.com/types/node" rel="noopener ugc nofollow" target="_blank">@types/node</a></span></pre><p id="3385" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们需要最新的express，因为它支持<em class="ms"> async/await，</em>，但它仍然是一个alpha版本。另一种方法是使用<a class="ae kw" href="http://thecodebarbarian.com/introducing-await-js-express-async-support-for-express-apps" rel="noopener ugc nofollow" target="_blank"> @awaitjs/express </a>模块。</p><p id="5fe5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建一个基本的web服务器:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1466" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，这段代码看起来像100%的JavaScript。但是都是打出来的，有错误TS不会编译。例如，尝试调用<em class="ms"> new express() </em>而不是<em class="ms"> express() </em>，看看会发生什么😋。</p><p id="da67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要添加我们的中间件。但是不要把它们都放在这里，让我们把它们放在<em class="ms">中间件</em>文件夹下。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="105d" class="ll lm iq mk b gy mo mp l mq mr">$ touch ./src/middleware/common.ts ./src/middleware/index.ts</span></pre><p id="13c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<em class="ms"> common.ts </em>文件包含中间件，如cors、压缩和主体解析设置。稍后我们将为日志、安全、缓存等添加中间件。粘贴到<em class="ms">中。/middleware/common.ts: </em></p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e4b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，你终于可以看到一些不同。我们所有的中间件包装器都接受<em class="ms">快速路由器</em>类<em class="ms">。</em></p><p id="ed4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="ms">中。/middleware/index.ts </em>我们将导入所有的中间件，为我们的<em class="ms"> server.ts. </em>提供一个单一的连接点，并且我们将来会在这里放更多的东西。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="ce43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了应用我们的中间件，我们将创建一个获取中间件列表的函数，并将其应用到路由器上。但是之前我们需要在<em class="ms">中放一个<em class="ms"> index.ts </em>文件。/utils </em>文件夹，所以让我们创建它。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="be32" class="ll lm iq mk b gy mo mp l mq mr">$ touch ./src/utils/index.ts</span></pre><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="bd5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">applyMiddleware助手接受我们在T30中定义的中间件包装器列表。/middleware/index.ts 和<em class="ms"> express。路由器</em>。现在一切都准备好了，可以在<em class="ms"> server.ts: </em>中使用</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="20e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它的一个好处是，随着我们添加越来越多的中间件，我们不必更改这些代码。仅在<em class="ms">下创建其文件。/中间件</em>并在<em class="ms">导入。/中间件/index.ts </em>。这是整个故事中最紧张的部分，我只是想让你知道❤️</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/f3ac0fba4290fc8300395ecb65fac5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*-XiQtpf7CweatrjXKAHk8g.jpeg"/></div></figure><p id="3f3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要类似的路由。让我们为我们的搜索服务添加一个基本路由。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="e041" class="ll lm iq mk b gy mo mp l mq mr">$ mkdir ./src/services/search &amp;&amp; touch ./src/services/search/routes.ts &amp;&amp; touch ./src/services/index.ts</span></pre><p id="ec48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<em class="ms">。/services/search/routes.ts </em>并粘贴到此处:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="507c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="ms">。/services/index.ts </em>添加它:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="ee8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们必须在路由器上应用这个声明性指定的路由，在<em class="ms">中。/utils/index.ts </em>。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a8aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ms"> applyRoutes </em>函数是我们将所有路由添加到在<em class="ms"> server.ts. </em>中创建的express router实例的地方。现在让我们打开该文件，用一行代码进行更改:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="14da" class="ll lm iq mk b gy mo mp l mq mr">import { applyMiddleware } from "./utils";</span></pre><p id="89be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与这个</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="e450" class="ll lm iq mk b gy mo mp l mq mr">import { applyMiddleware, applyRoutes } from "./utils";<br/>import routes from "./services";</span></pre><p id="3107" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并在<em class="ms"> applyMiddleware(中间件，路由器)</em>之后添加这个调用:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0b2b" class="ll lm iq mk b gy mo mp l mq mr">applyMiddleware(middleware, router);<br/>applyRoutes(routes, router);</span></pre><p id="a5b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦完成，它允许我们在<em class="ms">下快速添加新功能。/service </em>目录，而我们要做的就是在<em class="ms">中导入他们的路由。/service/index.ts </em>。</p><p id="0a86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用配置创建路由的主要目的是尽可能隔离路由框架(在我们的例子中是express)。并且还提供了在不改变整个结构和模型/控制器代码的情况下使用koa或hapi.js的可能性。这里是第二步的代码。</p><p id="98a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了！现在让我们添加错误处理和更多的中间件。</p><h2 id="ef15" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">第三步。Node.js和Express的错误处理。</h2><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/7ac00ae084e41c6b7febc6566bd2bf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jw9V__6jYhm2amP74D_0lw.png"/></div></div></figure><p id="14b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一步可能会非常累人。我们必须仔细考虑每一种错误。它包括客户端和服务器错误、同步和异步、未捕获的异常和未处理的承诺拒绝。</p><p id="737b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以跳过这一部分，直接进入第4步。如果你想看一些更令人兴奋的东西，而不是一个有“hello world”的空白页面。但是拥有一个健壮的错误处理允许我们专注于解决我们的实际任务，并确保它不会悲惨地崩溃。因为我们没有时间充分考虑如何捕捉所有这些错误。</p><p id="feec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的目标是实现<a class="ae kw" href="https://github.com/i0natan/nodebestpractices#2-error-handling-practices" rel="noopener ugc nofollow" target="_blank">错误处理实践</a>的最关键部分。我们需要考虑的是:</p><ol class=""><li id="424d" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">捕捉<em class="ms">未捕捉异常</em>和<em class="ms">未处理拒绝</em>。</li><li id="2c0e" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">区分客户端错误和服务器错误。</li><li id="4ccd" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">捕捉同步和异步错误，我们不想在控制器代码中加入错误处理。我们希望抛出一个异常，并确保我们专用的中间件会为我们处理它。</li><li id="862f" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">创建一个专用的<em class="ms"> ErrorHandler </em>类用于单元测试。</li></ol><p id="e338" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">处理<em class="ms">未处理异常</em>和<em class="ms">未处理剔除</em>都非常重要。如果你遇到这些问题，那么这个节点实例的游戏就结束了——现在你的应用程序处于一种不确定的状态。最好的办法是杀死这个实例，并产生一个新的实例。像<em class="ms"> forever </em>或者<em class="ms"> pm2 </em>这样的工具可以帮我们做到。我们将在第2部分介绍pm2。现在，让我们为uncaughtException和uncaughtException事件添加处理程序。</p><p id="e37d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来更新一下我们的<em class="ms">。/server.ts </em>文件，在导入部分后添加这几行。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3496" class="ll lm iq mk b gy mo mp l mq mr">process.on("uncaughtException", <em class="ms">e</em> =&gt; {<br/>  console.log(e);<br/>  process.exit(1);<br/>});</span><span id="e2e0" class="ll lm iq mk b gy mz mp l mq mr">process.on("unhandledRejection", <em class="ms">e</em> =&gt; {<br/>  console.log(e);<br/>  process.exit(1);<br/>});</span></pre><p id="33e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">稍后，我们将用一个logger实例替换console.log。</p><p id="d572" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以考虑处理客户端和服务器错误了。首先，让我们创建errorHandlers中间件:</p><p id="29a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ touch ./src/middleware/errorHandlers.ts</code></p><p id="4713" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们把它添加到我们的<em class="ms"> errorHandlers.ts </em>:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="53ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于每个用例，我们有三种不同的错误处理程序:</p><ol class=""><li id="526f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><em class="ms">处理404错误</em>您在express中处理404的方式。如果找不到其他东西，就添加一个后备中间件。</li><li id="faa8" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><em class="ms"> handleClientErrors </em>捕捉客户端API错误，如错误请求或未授权。</li><li id="bf71" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><em class="ms">handleserverrors</em>我们处理“内部服务器错误”的地方。</li></ol><p id="86de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些需要注意的事情:</p><ol class=""><li id="ff38" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">我们不在其中间件中处理404错误——我们直接将其进一步传播给专用的客户端错误处理程序。</li><li id="ef23" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">链中的下一个— <em class="ms"> handleClientErrors </em>。我们只对4xx HTTP错误感兴趣，如果它不是一个案例，我们就把它向下传播。</li><li id="76ba" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">最后<em class="ms">handleserverrors</em>——我们处理错误的最后手段，我们必须在这里处理，否则<em class="ms"> uncaughtException </em>处理程序将被调用，该节点流程将结束。</li></ol><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4ad6ad1f6360ee8b7cd96f0918a546eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*dxYPaacdW2LRA5fEcEO4Rw.jpeg"/></div></figure><p id="5072" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个可行的例子。但是，我们将用于错误处理的express中间件和用于每种类型错误的特定逻辑捆绑在一起。这使得单元测试和替换错误处理策略变得几乎不可能。让我们从中间件文件中提取这个逻辑。首先，创建ErrorHandler.ts文件:</p><p id="37fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ touch ./src/utils/ErrorHandler.ts</code></p><p id="ecb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将下面的代码添加到我们的<em class="ms">中。/utils/ErrorHandler.ts </em>:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c33f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有来更新一下<em class="ms">。/中间件/errorHandlers.ts </em>:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1b01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们有了一个专用的对象，它封装了我们如何管理它的整个逻辑。在第2部分中，我们将通过添加日志来改进这段代码。</p><p id="1c6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来—让我们创建两个专用的HTTP4xxError类，我们将在控制器代码中使用它们。</p><p id="8677" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，创建一个httpErrors.ts文件:</p><p id="9545" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ touch ./src/utils/httpErrors.ts</code></p><p id="e3c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将这段代码粘贴到<em class="ms"> httpErrors.ts </em>中的<em class="ms">http client terror</em>抽象类中。它将消息格式化，使其能够被内置的错误对象所理解。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2405" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，编写<em class="ms"> HTTP400Error </em>和<em class="ms"> HTTP404Error </em>类的代码:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="891b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以这样使用它:<em class="ms">抛出新的HTTP400Error() </em>，错误对象将包含<em class="ms"> statusCode </em>和message。我们不能更改<em class="ms">状态码</em>字段。然而，我们可以将另一个字符串作为消息或对象传递。这对于像<a class="ae kw" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank">类验证器</a>这样的库来说非常简洁，我们将在后面的例子中使用:</p><p id="fe75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ms">抛出新的http 400错误({消息:'密码太短' }) </em></p><p id="f496" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">错误处理器是一种非常特殊的中间件。通常，我们在处理用户路由之前注入中间件。而是错误处理——在我们的控制器中发生了不好的事情之后。或者抛出一个异常，并希望通过我们的错误处理中间件来捕获它。</p><p id="a4d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那就说让我们更新<em class="ms">。/src/server.ts </em>:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="168d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是第三步的代码。</p><p id="e2e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是相当多的，也是最难集中注意力的部分。但是现在我们可以享受它，看看创建一个控制器和自动处理错误是多么容易！</p><h2 id="9bf4" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">第四步。创建搜索服务。</h2><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/70f140233c46a04ddb01b7a6f793b7b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*LUf0HGj8Vs2kE54WyNW2SA.jpeg"/></div></figure><p id="c81f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧。现在，使用我们已经创建的框架，让我们创建一个搜索API。非常简单:</p><ol class=""><li id="662f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">它提供了一个API端点，比如？q =某处</li><li id="85e0" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">它向OpenCage Geocoder发出请求，接收数据并将其发送回用户。</li></ol><p id="69cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一部分的第5步，我们将做像自定义错误检查和API文档这样的事情。</p><p id="d5b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们为搜索服务创建以下结构:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/6bb0ded57868beacf2beb76422c3296d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCEFXZ9IvAkvaf9vNjRfYA.png"/></div></div></figure><p id="470a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过运行这组命令</p><p id="6877" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ mkdir ./src/services/search/providers</code></p><p id="cd4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ touch ./src/services/search/providers/OpenCageDataProvider.ts</code></p><p id="a357" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ touch ./src/services/search/SearchController.ts</code></p><p id="84a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，我们只创建了一个提供商——open cage Geocoder。但是我们可以包含更多，并将结果组合在<em class="ms"> SearchController </em>中。我们将在第2部分重点讨论它。</p><p id="57f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用<em class="ms">请求-承诺</em>模块来请求打开cagedata地理编码器。它支持异步/等待语法，所以让我们安装它:</p><p id="08b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ npm i request request-promise @types/request-promise</code></p><p id="1512" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来写一个获取数据的函数，打开<em class="ms">。/search/provider/opencagedataprovider . ts</em>并粘贴它:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="01d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有几点值得注意:</p><ol class=""><li id="062a" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">我们正在使用OPEN_CAGE_DATA_KEY环境变量，我们不想在源代码中暴露任何凭证。</li><li id="f3ea" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">我们在这里不使用<em class="ms"> try/catch来处理错误。</em>为此，我们使用了专用的中间件。</li></ol><p id="ea4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使用环境变量，安装<em class="ms"> dotenv </em>模块:</p><p id="19e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ npm i dotenv @types/dotenv</code></p><p id="1d96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建<em class="ms">。env </em>放在一个根目录文件中，并在那里添加这个变量(或者将<em class="ms"> .env.example </em>重命名为<em class="ms">)。源代码中的env </em></p><p id="1afb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ touch .env</code></p><p id="bf57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">粘贴到这里:</p><p id="e34d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ms">OPEN _ CAGE _ DATA _ KEY = 8c 0892514 e 884 f 09 af 7c 09 a9 b 067 b 02 b</em></p><p id="cc87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">。/search/<em class="ms">search controller . ts</em>只是简单地调用我们的提供者，在第2部分中，我们将组合添加更多的提供者，并在这里组合结果。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="94fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们的代码。/search/ <em class="ms"> route.ts </em>:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="cc00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在<a class="ae kw" href="http://localhost:3000/api/v1/search?q=Berlin." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/v1/search？q =柏林</a>。接下来，我们的处理程序非常简单。我们向控制器提供一个字符串查询，等待结果并将其发送给用户。这非常重要——我们不想为控制器提供请求和响应对象。这使得我们的代码更难进行单元测试。更重要的是，我们的控制者变成了上帝。哪知这两个<em class="ms">请求</em>和<em class="ms">响应</em>的对象无所不知。</p><p id="3a0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是第四步的代码。</p><h2 id="9b21" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated"><code class="fe na nb nc mk b">Step 5. Add more cool stuff: custom error checking and api </code>大摇大摆地记录文件。</h2><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0a09b612aeb3770afa3eebc04b149a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*3SjT2Dw7tiFFRoEIBbbKvQ.png"/></div></figure><p id="b226" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是第一部分的最后一步。我们将重点关注:</p><ol class=""><li id="9fe1" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">处理一桩失踪案？q参数误差</li><li id="ac08" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">使用swagger记录端点</li></ol><p id="9d51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将创建一个独特的中间件，而不是在控制器的代码中添加一个检查。创建一个<em class="ms">。/middleware/checks.ts </em>文件并添加以下代码:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c40f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们只检查“q”参数的存在，如果它丢失了，就抛出一个异常。感谢我们的错误处理中间件，我们将在那里抓住它！</p><p id="7640" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们加入这个中间件。/search/ <em class="ms"> route.ts </em>:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0165" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法非常适用。我们可以将检查授权、添加缓存等事情串联起来。</p><p id="ece3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，我们有一个具有特定URL结构和错误代码的端点。是时候引入swagger来记录我们的API了。这是它看起来的样子:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/3554e4d309e35d94a80545cefcc9a496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0NZtlOrh2UCGSjLdcdpPg.png"/></div></div></figure><p id="4ade" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用swagger-ui-express作为中间件来提供文档<a class="ae kw" href="http://localhost:3000/api-docs" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API-docs</a>，所以让我们安装这个模块:</p><p id="e7eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ npm i swagger-ui-express @types/swagger-ui-express</code></p><p id="5466" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在<em class="ms">下创建一个<em class="ms"> swagger.json </em>文件。/src/config </em>文件夹下运行:</p><p id="1c79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ touch ./src/config/swagger.json</code></p><p id="9e21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在<em class="ms"> swagger.json中，</em>我们将记录我们的端点:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8431" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让它工作，让我们为此创建一个中间件，运行:</p><p id="31b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ touch ./src/middleware/apiDocs.ts</code></p><p id="038d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并添加以下代码:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="cd30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步，让我们在<em class="ms">中导入这个中间件包装器。/middleware/index.ts: </em></p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d980" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这个！现在这里有:<a class="ae kw" href="http://localhost:3000/api-docs" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API-docs</a>。点击“试用”按钮，你就可以玩了。</p><p id="8979" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是第五步的代码。</p><p id="8ef1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把重点放在阻碍我们在生产中部署它的事情上——缺乏测试、集群和生产配置。</p><h2 id="f6dd" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">第六步。用Jest配置单元测试。</h2><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/55c3b66cc27f089cf48691060521709f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SruahLTSYt6Oo8MKhTMI6w.png"/></div></div></figure><p id="8d94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看当前的搜索服务文件夹:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/6bb0ded57868beacf2beb76422c3296d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCEFXZ9IvAkvaf9vNjRfYA.png"/></div></div></figure><p id="67d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将为服务的每个部分创建测试:我们的控制器、路由和提供者。<a class="ae kw" href="https://basarat.gitbooks.io/typescript/docs/testing/jest.html" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到使用<a class="ae kw" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>和TypeScript的绝佳指导。我们将介绍它的基础知识。</p><p id="639b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们安装它:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f09c" class="ll lm iq mk b gy mo mp l mq mr">npm i jest @types/jest ts-jest -D</span></pre><p id="2c68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在安装<em class="ms"> ts-jest </em>和<em class="ms"> jest。它允许<em class="ms"> jest </em>动态传输文件类型脚本。标记“-D”将其安装为dev依赖项。</em></p><p id="4e95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，在<em class="ms"> package.json </em>中添加‘jest’部分:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d177" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在<em class="ms">脚本</em>部分添加“测试”命令，替换为以下命令:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="cf00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们传递了'— coverage '标志—它表示应该在输出中收集和报告测试覆盖信息。</p><p id="4423" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们修改后的最终<a class="ae kw" href="https://github.com/alexpermyakov/node-rest-api/blob/step.6/package.json" rel="noopener ugc nofollow" target="_blank"> package.json </a>。</p><p id="1026" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们准备运行jest:</p><p id="27c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ npm run test</code></p><p id="aad1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们正确地完成了所有步骤，您将会看到“没有找到测试”错误。这太好了！现在我们已经准备好实际创建测试了。</p><h2 id="9706" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">第七步。添加单元测试。</h2><p id="c96f" class="pw-post-body-paragraph jy jz iq ka b kb ni kd ke kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">我们需要对服务的三个不同部分进行测试:路由、控制器和提供者。让我们从最后一个开始——这里最底层。我们的提供商负责请求第三方服务—<a class="ae kw" href="http://opencagedata.com" rel="noopener ugc nofollow" target="_blank">opencagedata.com</a>。</p><p id="caff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据定义，单元测试应该是快速的，这意味着我们必须用虚假的数据来模拟真实的请求。我们想要测试我们能控制的东西，想要嘲笑我们不能控制的其他东西。</p><p id="8717" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们必须考虑适当的错误处理。真正的服务不可用，返回503错误怎么办？在这种情况下，拥有测试覆盖率会让我们未来的生活更加舒适。</p><h2 id="e8ce" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">让我们开始吧。</h2><p id="0f20" class="pw-post-body-paragraph jy jz iq ka b kb ni kd ke kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">首先，让我们为我们的:<em class="ms"> OpenCageDataProvider </em>创建一个单元测试文件。</p><p id="e0ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">$ touch ./src/services/search/providers/OpenCageDataProvider.test.ts</code></p><p id="b8f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将测试来自<em class="ms"> OpenCageDataProvider </em>模块的<em class="ms"> getPlaces </em>函数，将以下代码复制到我们刚刚创建的文件中:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="41dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们首先模拟整个<em class="ms">请求-承诺</em>模块。然后我们<strong class="ka ir">模仿<em class="ms">请求</em>函数的一个实现</strong>，它被用在我们的<em class="ms"> getPlaces </em>函数中。如果你对上面的陈述感到不确定，这篇文章肯定会有帮助！</p><p id="7725" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们测试一个空查询，和原始服务一样，它应该以字符串形式返回一个有效的JSON对象。空字符串是这里唯一的极限情况:有了TypeScript，<strong class="ka ir">我们不需要测试像</strong>这样的输入:</p><p id="faa4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">Provider.getPlaces(false)</code></p><p id="eb4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">Provider.getPlaces(0)</code></p><p id="59d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc mk b">Provider.getPlaces({})</code></p><p id="14ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它根本无法编译！这太棒了— <strong class="ka ir"> TypeScript帮助我们用更少的代码来覆盖我们的方法。</strong>感觉真好。</p><p id="a822" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果真正的服务不可用或者响应不是有效的JSON字符串怎么办？让我们添加一个测试来检查这个异常:</p><p id="af5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多事情都发生在只有两条线上:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7f41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1)这里，我们再次使用<em class="ms"> mockImplementation。但是这次它返回“服务不可用”字符串。</em></p><p id="78e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2)其次<a class="ae kw" href="https://jestjs.io/docs/en/expect#rejects" rel="noopener ugc nofollow" target="_blank">拒绝</a>帮助我们测试抛出的异常<em class="ms"> SyntaxError。</em>这是我们为<em class="ms"> JSON.parse </em>函数提供无效参数时出现的错误。</p><p id="dfd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3)最后，我们必须将<em class="ms"> await </em>关键字放在expect之前。因为这个测试是异步的，Jest必须等到它完成。</p><p id="6a73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个练习:试着自己为SearchController创建单元测试。这和我们现在创造的不会有太大的不同。</p><h2 id="c3bb" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">第八步。下一层:用Supertest添加集成测试。</h2><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/381ada0cae367d3a1d30415fd05d0aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3l_TDDGGcyfW4a0jU3RUaQ.jpeg"/></div></div></figure><p id="d9f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单元测试很重要，但是当涉及到开发API时，我们非常需要对我们的API端点进行测试。每当我修改代码时，我很快就会厌倦检查Postman。</p><p id="cc5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用<a class="ae kw" href="https://github.com/visionmedia/supertest" rel="noopener ugc nofollow" target="_blank">超级测试</a>作为集成测试工具。有几个好处使它非常吸引人:</p><ul class=""><li id="fb92" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv no ld le lf bi translated">它非常容易使用，不能再简单了。</li><li id="788b" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv no ld le lf bi translated">很适合开玩笑。</li></ul><h2 id="0e2e" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">开始了。</h2><p id="e0e2" class="pw-post-body-paragraph jy jz iq ka b kb ni kd ke kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">首先，让我们安装<em class="ms">超级测试:</em></p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a4da" class="ll lm iq mk b gy mo mp l mq mr">npm i supertest @types/supertest</span></pre><p id="e564" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们正在创建<em class="ms"> routes.test.ts </em>文件:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="da50" class="ll lm iq mk b gy mo mp l mq mr">$ touch <!-- -->./src/services/search/routes.test.ts</span></pre><p id="27e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们将这段代码添加到<em class="ms"> routes.test.ts </em>中:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f39c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这太简单了！让我们浏览一下这段代码:</p><ol class=""><li id="aedb" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">再次，我们模拟请求-承诺，我们不想提出网络请求。</li><li id="a37a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">我们创建一个快速路由器，应用所有的中间件、路由和错误处理器，就像我们在<a class="ae kw" href="https://github.com/alexpermyakov/node-rest-api/blob/step.6/src/server.ts" rel="noopener ugc nofollow" target="_blank"> server.ts </a>中做的一样。</li><li id="1e01" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">我们使用来自<em class="ms">超级测试</em>模块的<em class="ms">请求</em>功能。注意，我们没有创建HTTP服务器。我们只提供快速路由器，supertest在内部创建。然后用我们的数据发出GET请求。</li><li id="5815" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">我们得到了一个包含数据和状态代码的<em class="ms">响应</em>对象。</li></ol><p id="ad63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，<strong class="ka ir">为API创建集成测试并不比为我们的提供者创建单元测试</strong>复杂。但是，这次我们测试了整个中间件链、路由和错误处理程序！</p><p id="ae64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为最后一步，我们可以为无效查询添加集成测试:</p><p id="ab2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将此代码添加到<em class="ms"> routes.test.ts: </em></p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0ca1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，<em class="ms"> supertest </em>的巨大优势是可读性——我们可以看到我们传递了什么，结果是什么。测试给了我们信心，现在我们可以继续前进了！</p><h2 id="ea84" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">第九步。将我们的API与PM2集群化</h2><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/de67a15023a1dc3a83c79079dca616d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H9yAl3ULZZVGOhUmV_-uxA.png"/></div></div></figure><p id="60b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能知道，Node.js事件循环只使用处理器的一个内核来执行代码。Node.js有一个<a class="ae kw" href="https://nodejs.org/api/cluster.html" rel="noopener ugc nofollow" target="_blank">集群模块</a>来产生子进程——工作进程。它们都共享同一个端口。</p><p id="74bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，我们将使用<a class="ae kw" href="https://pm2.io/runtime/" rel="noopener ugc nofollow" target="_blank">PM2——node . js的进程管理器，而不是直接使用集群模块生成进程。</a>它有很好的特性，如负载平衡和自动重启节点实例。</p><h2 id="019a" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">装置</h2><p id="1176" class="pw-post-body-paragraph jy jz iq ka b kb ni kd ke kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">PM2是一个节点包，让我们把它作为本地依赖项安装:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="d3bb" class="ll lm iq mk b gy mo mp l mq mr">$ npm i pm2</span></pre><p id="82a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们必须配置PM2。yaml进程文件:</p><ul class=""><li id="7798" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv no ld le lf bi translated">指定我们要创建多少个实例。</li><li id="7497" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv no ld le lf bi translated">启动应用程序时将执行的脚本</li><li id="b5cb" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv no ld le lf bi translated">将exec_mode设置为<em class="ms">集群</em>，这样PM2知道我们想要在各个实例之间实现负载平衡。</li></ul><p id="7159" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个<em class="ms"> pm2.yaml </em>文件:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3421" class="ll lm iq mk b gy mo mp l mq mr">$ touch pm2.yaml</span></pre><p id="b642" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并粘贴以下代码:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3ea5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们必须添加一个命令来运行PM2进程文件。在<em class="ms"/>our<a class="ae kw" href="https://github.com/alexpermyakov/node-rest-api/blob/step.9/package.json" rel="noopener ugc nofollow" target="_blank">package . JSON</a>中的<em class="ms"> </em>脚本部分添加下面一行:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="4dff" class="ll lm iq mk b gy mo mp l mq mr">"start": "npx pm2 start pm2.yaml"</span></pre><p id="05f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，脚本部分如下所示:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6847" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在运行生产就绪服务之前，我们还需要做一些事情:</p><ul class=""><li id="6692" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv no ld le lf bi translated">编译。ts源文件放入<em class="ms">。/dist </em>文件夹，这样PM2就可以运行我们的。/dist/ <em class="ms"> server.js </em>文件。</li><li id="db34" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv no ld le lf bi translated">将NODE_ENV指定给生产。</li></ul><p id="91cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，当我们执行<code class="fe na nb nc mk b">npm run dev</code>时，我们已经创建了<em class="ms">。/dist </em>文件夹。但是我们正在完成开发过程，但是如果我们的同事只想要npm克隆并运行它呢？</p><p id="f8ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最快的方法是添加npm安装后挂钩。每次在<em class="ms"> npm安装</em>执行<em class="ms">后运行。</em>我们所要做的——使用我们的选项运行TypeScript编译器，让我们将这个钩子添加到我们的<em class="ms"> package.json中。</em>用它更新脚本部分:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2db0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但同样重要的是，我们必须强制我们所有的依赖项使用生产模式。比如<a class="ae kw" href="https://www.dynatrace.com/news/blog/the-drastic-effects-of-omitting-node-env-in-your-express-js-applications/" rel="noopener ugc nofollow" target="_blank">它会把express.js的性能提升3倍！</a></p><p id="4cd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把这一行加到我们的。环境文件:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2b08" class="ll lm iq mk b gy mo mp l mq mr">NODE_ENV=production</span></pre><p id="1004" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，为了在生产中启动Node.js，我们所要做的就是运行:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8aa2" class="ll lm iq mk b gy mo mp l mq mr">$ npm run start</span></pre><h1 id="a9db" class="nq lm iq bd ln nr ns nt lq nu nv nw lt nx ny nz lw oa ob oc lz od oe of mc og bi translated">就是这样！</h1><p id="39f2" class="pw-post-body-paragraph jy jz iq ka b kb ni kd ke kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">如果您有任何问题或反馈，请在下面的评论中告诉我，或者在Twitter上ping我(<a class="ae kw" href="https://twitter.com/alex_permiakov" rel="noopener ugc nofollow" target="_blank"> @alex_permiakov </a>)。在第2部分中，我们将讨论Redis、PostgreSQL、日志记录等缓存技术。敬请期待！</p><h2 id="c051" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">如果这有用，请点击拍手👏下面扣几下，以示支持！⬇⬇ 🙏🏼</h2></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="87cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是我写的更多文章:</p><div class="oo op gp gr oq or"><a href="https://medium.freecodecamp.org/how-to-get-started-with-internationalization-in-javascript-c09a0d2cd834" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">如何开始JavaScript的国际化</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">通过调整我们的应用程序以适应不同的语言和国家，我们提供了更好的用户体验。对用户来说更简单…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">medium.freecodecamp.org</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf jw or"/></div></div></a></div><div class="oo op gp gr oq or"><a href="https://medium.freecodecamp.org/15-useful-javascript-examples-of-map-reduce-and-filter-74cbbb5e0a1f" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">如何用JavaScript中的map()、reduce()和filter()简化代码库</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">当你读到Array.reduce和它有多酷时，你发现的第一个，有时是唯一的例子是…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">medium.freecodecamp.org</p></div></div><div class="pa l"><div class="pg l pc pd pe pa pf jw or"/></div></div></a></div><p id="a561" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢你阅读❤️</p></div></div>    
</body>
</html>