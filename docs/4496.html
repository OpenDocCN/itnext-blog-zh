<html>
<head>
<title>How to use MongoDB Change Streams [Part 2]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用MongoDB变更流[第2部分]</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-mongodb-change-streams-part-2-6a6d049426bb?source=collection_archive---------2-----------------------#2020-07-13">https://itnext.io/how-to-use-mongodb-change-streams-part-2-6a6d049426bb?source=collection_archive---------2-----------------------#2020-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5455" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个博客系列的第二部分，涵盖了MongoDB变更流以及它如何与<code class="fe kl km kn ko b">Azure Cosmos DB</code>一起使用，其中<a class="ae kp" href="https://docs.microsoft.com/azure/cosmos-db/mongodb-feature-support-36?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">具有对MongoDB服务器版本3.6 </a>的有线协议支持(包括<a class="ae kp" href="https://docs.mongodb.com/manual/changeStreams/" rel="noopener ugc nofollow" target="_blank">变更流</a>特性)。第1部分介绍了Change streams processor服务的简介和概述，并向您介绍了如何运行该应用程序，以便您可以看到工作中的变更流。</p><div class="kq kr gp gr ks kt"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-use-mongodb-change-streams-part-1-da9a5e94ba2"><div class="ku ab fo"><div class="kv ab kw cl cj kx"><h2 class="bd ir gy z fp ky fr fs kz fu fw ip bi translated">如何使用MongoDB变更流[第1部分]</h2><div class="la l"><h3 class="bd b gy z fp ky fr fs kz fu fw dk translated">这篇博文演示了如何在MongoDB中使用官方Go驱动程序的变更流。我将使用Azure…</h3></div><div class="lb l"><p class="bd b dl z fp ky fr fs kz fu fw dk translated">itnext.io</p></div></div><div class="lc l"><div class="ld l le lf lg lc lh li kt"/></div></div></a></div><p id="9db7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一部分中，我们将检查代码，看看事情是如何在幕后工作的。</p><blockquote class="lj lk ll"><p id="46c4" class="jn jo lm jp b jq jr js jt ju jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj kk ij bi translated"><em class="iq">一如既往，代码为</em> <a class="ae kp" href="https://github.com/abhirockzz/mongodb-changestreams-processor" rel="noopener ugc nofollow" target="_blank"> <em class="iq">可在GitHub </em> </a>上获得</p></blockquote><h1 id="8056" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">概述:更改处理器应用程序</h1><p id="8be2" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在继续之前，先快速回顾一下Change Processor服务(从第1部分复制过来):</p><p id="b2a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该应用程序是使用变更流功能的变更处理器服务。这是一个使用官方MongoDB Go驱动程序<a class="ae kp" href="https://godoc.org/go.mongodb.org/mongo-driver/mongo" rel="noopener ugc nofollow" target="_blank">的<code class="fe kl km kn ko b"><a class="ae kp" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank">Go</a></code>应用程序，但是这些概念应该适用于任何其本地驱动程序支持变更流的其他语言。</a></p><p id="d31e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它使用<code class="fe kl km kn ko b"><a class="ae kp" href="https://godoc.org/go.mongodb.org/mongo-driver/mongo#Collection.Watch" rel="noopener ugc nofollow" target="_blank">Watch</a></code> <a class="ae kp" href="https://godoc.org/go.mongodb.org/mongo-driver/mongo#Collection.Watch" rel="noopener ugc nofollow" target="_blank"> API </a>来订阅特定<code class="fe kl km kn ko b">Collection</code>中的变更事件提要，以便通知它正在创建、更新和删除的文档。它从变更事件有效负载(即受影响的文档)中提取相关信息，并将其保存到本地文件中。它还演示了如何使用<code class="fe kl km kn ko b">Resume Tokens</code>来保存处理进度。</p><h1 id="5b73" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">代码走查</h1><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/700e1ed8515eaa02fd689013ebf9670c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*fg0B23oYaVhBfOCr.gif"/></div></figure><p id="f92b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是项目布局:<code class="fe kl km kn ko b">main.go</code>文件包含了订阅和处理变更流的大部分逻辑，而<code class="fe kl km kn ko b">token/resume_token.go</code>处理保存/检索恢复令牌。</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="42ef" class="ne lr iq ko b gy nf ng l nh ni">.<br/>├── go.mod<br/>├── go.sum<br/>├── main.go<br/>└── token<br/>    └── resume_token.go</span></pre><p id="4b92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序首先连接到Azure Cosmos DB MongoDB API，如果由于某种原因失败，就会退出。如果连接成功，我们将获得一个想要观察的MongoDB集合的句柄</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="90cd" class="ne lr iq ko b gy nf ng l nh ni">client, err := mongo.NewClient(options.Client().ApplyURI(mongoURI))<br/>    if err != nil {<br/>        log.Fatal("failed to create client: ", err)<br/>    }</span><span id="2dc0" class="ne lr iq ko b gy nj ng l nh ni">    ctx, cancel := context.WithCancel(context.Background())</span><span id="ca1f" class="ne lr iq ko b gy nj ng l nh ni">    err = client.Connect(ctx)<br/>    if err != nil {<br/>        log.Fatal("failed to connect", err)<br/>    }<br/>  <br/>  coll := client.Database(mongoDBName).Collection(mongoCollectionName)<br/>    defer func() {<br/>        err = client.Disconnect(context.Background())<br/>        if err != nil {<br/>            fmt.Println("failed to close connection")<br/>        }<br/>    }()</span></pre><p id="9f59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候开始“跟踪”变更事件的集合了。注意<code class="fe kl km kn ko b">pipeline</code>和<code class="fe kl km kn ko b">opts</code>参数</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="df82" class="ne lr iq ko b gy nf ng l nh ni">cs, err := coll.<strong class="ko ir">Watch</strong>(ctx, pipeline, opts)</span></pre><p id="201d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">pipeline</code>是一只<code class="fe kl km kn ko b"><a class="ae kp" href="https://godoc.org/go.mongodb.org/mongo-driver/mongo#Pipeline" rel="noopener ugc nofollow" target="_blank">*mongo.Pipeline</a></code>。我们指定了几个阶段作为<code class="fe kl km kn ko b">Pipeline</code> - <code class="fe kl km kn ko b">$match</code>和<code class="fe kl km kn ko b">$project</code>以及<code class="fe kl km kn ko b">fullDocument</code>选项的一部分</p><blockquote class="lj lk ll"><p id="450c" class="jn jo lm jp b jq jr js jt ju jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj kk ij bi translated"><em class="iq">在撰写本文时，</em> <a class="ae kp" href="https://docs.microsoft.com/azure/cosmos-db/mongodb-change-streams?WT.mc_id=medium-blog-abhishgu#current-limitations" rel="noopener ugc nofollow" target="_blank"> <em class="iq">由于Azure Cosmos DB特有的约束，这些选项是强制性的</em> </a> <em class="iq">。</em></p></blockquote><p id="ae8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些在代码中是如何体现的:</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="c50b" class="ne lr iq ko b gy nf ng l nh ni">matchStage := bson.D{{"$match", bson.D{{"operationType", bson.D{{"$in", bson.A{"insert", "update", "replace"}}}}}}}<br/>    //matchStage := bson.D{{"$match", bson.D{{"operationType", "insert"}}}}</span><span id="577b" class="ne lr iq ko b gy nj ng l nh ni">projectStage := bson.D{{"$project", bson.M{"_id": 1, "fullDocument": 1, "ns": 1, "documentKey": 1}}}<br/>    pipeline := mongo.Pipeline{matchStage, projectStage}<br/>    opts := </span><span id="49e4" class="ne lr iq ko b gy nj ng l nh ni">options.ChangeStream().SetFullDocument(options.UpdateLookup)</span></pre><p id="b69a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以选择使用resume令牌(由一个环境变量指定——下一节将详细介绍)。使用<code class="fe kl km kn ko b">ResumeAfter</code>字段将恢复令牌设置为<code class="fe kl km kn ko b"><a class="ae kp" href="https://godoc.org/go.mongodb.org/mongo-driver/mongo/options#ChangeStreamOptions" rel="noopener ugc nofollow" target="_blank">*options.ChangeStreamOptions</a></code>。恢复令牌(如果存在的话)被本地存储在一个名为<code class="fe kl km kn ko b">token</code>的文件中——我们在开始我们的变更流之前检查这个令牌，如果它存在就使用它</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="8d14" class="ne lr iq ko b gy nf ng l nh ni">if resumeSupported {<br/>        t, err := token.RetrieveToken()<br/>        if err != nil {<br/>            log.Fatal("failed to fetch resume token: ", err)<br/>        }<br/>        if t != nil {<br/>            opts.SetResumeAfter(t)<br/>        }<br/>    }</span></pre><p id="2701" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，令牌操作(保存和检索)是<code class="fe kl km kn ko b">token/resume_token.go</code>的一部分。以下是获取现有令牌的方式:</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="4b81" class="ne lr iq ko b gy nf ng l nh ni">func RetrieveToken() (bson.Raw, error) {<br/>    tf, err := os.Open(tokenFileName)<br/>    if err != nil {<br/>        if os.IsNotExist(err) {<br/>            return nil, nil<br/>        }<br/>        return nil, err<br/>    }<br/>    token, err := bson.NewFromIOReader(tf)<br/>    if err != nil {<br/>        return nil, err<br/>    }<br/>    return token, nil<br/>}</span></pre><p id="f358" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建输出文件来存储变更事件，并开始观察集合</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="4282" class="ne lr iq ko b gy nf ng l nh ni">op, err := os.OpenFile(outputfileName,<br/>        os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)<br/>  ...</span><span id="05d4" class="ne lr iq ko b gy nj ng l nh ni">cs, err := coll.Watch(ctx, pipeline, opts)<br/>if err != nil {<br/>  log.Fatal("failed to start change stream watch: ", err)<br/>}</span></pre><p id="48d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不同的goroutine用于处理变更事件</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="b551" class="ne lr iq ko b gy nf ng l nh ni">go func() {<br/>        fmt.Println("started change stream...")<br/>        for cs.Next(ctx) {<br/>            re := cs.Current.Index(1)<br/>            _, err := op.WriteString(re.Value().String() + "\n")<br/>            if err != nil {<br/>                fmt.Println("failed to save change event", err)<br/>            }<br/>        }<br/>    }()</span></pre><p id="fa11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">goroutine是这个(相当简单的)处理服务的核心，它作为一个紧密的<code class="fe kl km kn ko b">for</code>循环运行，该循环使用<code class="fe kl km kn ko b"><a class="ae kp" href="https://godoc.org/go.mongodb.org/mongo-driver/mongo#ChangeStream.Next" rel="noopener ugc nofollow" target="_blank">Next</a></code>来获取变更事件。由于<code class="fe kl km kn ko b">Next</code>是一个阻塞调用，我们需要考虑干净/优雅的退出机制。传递给<code class="fe kl km kn ko b">Next</code>的<code class="fe kl km kn ko b">ctx</code>参数扮演了一个重要的角色——它是一个<code class="fe kl km kn ko b"><a class="ae kp" href="https://godoc.org/context#WithCancel" rel="noopener ugc nofollow" target="_blank">cancellable context</a></code>(稍后将详细介绍如何使用它)</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="70a6" class="ne lr iq ko b gy nf ng l nh ni">ctx, cancel := context.WithCancel(context.Background())</span></pre><p id="89fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<code class="fe kl km kn ko b">exit</code>通道用于检测程序终止(例如<code class="fe kl km kn ko b">ctrl+c</code>)</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="45e3" class="ne lr iq ko b gy nf ng l nh ni">exit := make(chan os.Signal)<br/>signal.Notify(exit, syscall.SIGINT, syscall.SIGTERM)</span></pre><p id="72a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当变更流检测和处理在单独的goroutine中运行时，使用<code class="fe kl km kn ko b">exit</code>通道阻塞<code class="fe kl km kn ko b">main</code> goroutine</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="60f3" class="ne lr iq ko b gy nf ng l nh ni">&lt;-exit<br/>fmt.Println("exit signalled. cancelling context")<br/>cancel()<br/>if resumeSupported {<br/>   token.SaveToken(cs.ResumeToken())<br/>}</span></pre><p id="490e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它做了几件事:</p><p id="df7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用<code class="fe kl km kn ko b">cancel()</code>，它只不过是作为创建<code class="fe kl km kn ko b">cancellable</code>上下文的副产品返回的<code class="fe kl km kn ko b"><a class="ae kp" href="https://godoc.org/context#CancelFunc" rel="noopener ugc nofollow" target="_blank">Cancel function</a></code>(传递到<code class="fe kl km kn ko b">Next</code>)。调用<code class="fe kl km kn ko b">CancelFunc</code>将程序终止传播到循环的更改流，允许它退出。</p><blockquote class="lj lk ll"><p id="b928" class="jn jo lm jp b jq jr js jt ju jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj kk ij bi translated"><em class="iq">请注意，我使用了用户发起的(手动)程序终止(如按ctrl+c)作为例子。如果处理器服务作为长期运行的服务器组件执行，则同样的概念适用</em></p></blockquote><p id="2a54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个关键点是将恢复令牌保存到本地文件:</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="5a2c" class="ne lr iq ko b gy nf ng l nh ni">if resumeSupported {<br/>  token.SaveToken(cs.ResumeToken())<br/>}</span></pre><p id="e471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是将恢复令牌保存到本地文件的方式:</p><pre class="mu mv mw mx gt na ko nb nc aw nd bi"><span id="141f" class="ne lr iq ko b gy nf ng l nh ni">func SaveToken(token []byte) {</span><span id="ede6" class="ne lr iq ko b gy nj ng l nh ni">    if len(token) == 0 {<br/>        return<br/>    }<br/>    tf, err := os.Create(tokenFileName)</span><span id="05d2" class="ne lr iq ko b gy nj ng l nh ni">    if err != nil {<br/>        fmt.Println("token file creation failed", err)<br/>        return<br/>    }<br/>    _, err = tf.Write(token)<br/>    if err != nil {<br/>        fmt.Println("failed to save token", err)<br/>        return<br/>    }<br/>    fmt.Println("saved token to file")<br/>}</span></pre><p id="f6c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于MongoDB变更流的两部分系列到此结束。我希望这是有用的，并有助于理解一个实际例子的帮助功能！</p></div></div>    
</body>
</html>