<html>
<head>
<title>Fehrist — Document Indexing Library in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">fehrist—Go中的文档索引库</h1>
<blockquote>原文：<a href="https://itnext.io/fehrist-document-indexing-library-in-go-2516862456ad?source=collection_archive---------2-----------------------#2020-06-07">https://itnext.io/fehrist-document-indexing-library-in-go-2516862456ad?source=collection_archive---------2-----------------------#2020-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/376642a7557cdad40d500f153a60005e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hd2QJSCMs-vwFR1m.jpg"/></div></div></figure><p id="3143" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天我向你们展示我用Go语言制作的另一个库，叫做，<strong class="ka ir"> Fehrist </strong></p><p id="c063" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自<a class="ae kw" href="https://github.com/kadnan/Fehrist" rel="noopener ugc nofollow" target="_blank"> Github自述文件</a>:</p><blockquote class="kx ky kz"><p id="8345" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">Fehrist <em class="iq">是一个纯粹的Go库，用于索引不同类型的文档。目前，它只支持CSV和JSON，但灵活的架构让您可以自由添加更多的文档。Fehrist(فہرست)是乌尔都语的</em> <strong class="ka ir"> <em class="iq">索引</em> </strong> <em class="iq">的意思。Arabic(فھرس)和Farsi(فہرست)也使用类似的术语。</em></p></blockquote><p id="c7b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la"> Fehrist </em>基于用于索引目的的<strong class="ka ir">倒排索引</strong>数据结构。</p><h1 id="268f" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我为什么会成功？</h1><p id="4b9c" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">看起来我在Python之后爱上了Golang。Go是一种固执己见的语言，不会让你在各种小决策上分心。制作这个特殊库的原因仅仅是为了学习索引；它是如何工作的，有哪些算法可用。我选择了<a class="ae kw" href="https://en.wikipedia.org/wiki/Inverted_index" rel="noopener ugc nofollow" target="_blank"> <em class="la">倒排索引</em> </a>是因为它的灵活性，并且比其他的像B+树更容易实现。我还从ElasticSearch获得了在磁盘上编写和排列索引文件的灵感。</p><h1 id="8d02" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">它是如何工作的？</h1><p id="8433" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">正如我提到的，它是基于一个倒排索引。在为每个记录分配一个DOCID的第一阶段之后，所有文件，无论其类型如何，都将被标记化。在CSV、JSON或XML文件的情况下，<em class="la">记录</em>是一个单独的条目。在分配DOCID之后，它被标记化，其中文件中的每个术语被映射到相应的DOCID和文件名。然后，可以通过提供关键字来搜索成功的索引文档。搜索结果的输出是一个JSON结构。Golang <code class="fe mh mi mj mk b">maps</code>数据结构用于中间数据处理和搜索。下图可能有助于您理解整个索引过程。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/64dbd5feafa911c65e9a52c392e1cf54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/0*d_msA9EkJpxDBF-Z.png"/></div></figure><p id="36ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一步中，CSV文件被提供给系统，然后按记录方式进行分割，并用DOCID进行映射。在第二步中，每条记录都被标记到每个术语中，并与出现次数进行映射。例如，在文档<em class="la"> 1.csv </em>和<em class="la"> 2.csv </em>中找到了<em class="la"> Jhon </em>，它将创建一个管道分隔的结构，然后将该结构分配为<code class="fe mh mi mj mk b">map</code>的一个单独的条目，对应于其相应的键。如上图所示，<em class="la"> john </em>出现在docid<strong class="ka ir">docid 1</strong>和<strong class="ka ir"> docid2中。</strong>围棋<code class="fe mh mi mj mk b">maps</code>已被用于此目的。</p><p id="171c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，数据被保存到磁盘中。我从ElasticSearch那里窃取了磁盘数据管理的想法:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/e7dc3532ac7122ddebc0c148a98734e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*hsalRDPXMkqQGNKO.png"/></div></figure><p id="12ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上图所示，每个索引文件都保存为<code class="fe mh mi mj mk b">.idx</code>文件。首先，它创建了一个以您提供的名称命名的文件夹。然后所有相关文件都存储在里面(<em class="la">感谢ElasticSearch给了我这个想法</em>)。您还会看到扩展名为<code class="fe mh mi mj mk b">.document</code>的文件，这实际上是最初的条目及其DOCIds。然后，在<a class="ae kw" href="https://msgpack.org/index.html" rel="noopener ugc nofollow" target="_blank">消息包</a>的帮助下，所有数据被序列化。下面是索引CSV文件的代码。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/f1d0207047d9bd944b925f63db57b243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-9L3HT3asfoMBVmB.png"/></div></div></figure><p id="32a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该库是灵活的。由于Go提供的多态性，您可以通过实现一些方法非常容易地扩展这个库。</p><p id="6ea4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样搜索就很容易了:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/923762e2a39e6920849300505d606a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qjPwl4Uz3d_VOR6-.png"/></div></div></figure><p id="ed04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">Search</code>方法将索引名作为参数，因为创建了一个同名的文件夹，所有文件都存储在其中。<code class="fe mh mi mj mk b">Init()</code>方法用于从<code class="fe mh mi mj mk b">maps</code>中的文件和索引中提取所有数据。</p><p id="87fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我所说，这是一个灵活的库。你只需要添加你自己的文档类型<code class="fe mh mi mj mk b">struct</code>，就像我为JSON和CSV做的那样。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/f28d024263307d9593f22caef6db086b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*AudQ06L27Lnp_b6R.png"/></div></figure><h1 id="5496" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="719f" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">我希望你喜欢这篇文章，并在你的下一个项目中使用这个库。有几件事，它不包括像全面搜索。也不适用于<em class="la">词干</em>和<em class="la">停用词</em>。目前，它根据找到的确切关键字返回数据。你可以通过分叉来增强它。你可以从<a class="ae kw" href="https://github.com/kadnan/Fehrist" rel="noopener ugc nofollow" target="_blank"> Github </a>下载这个库。</p><p id="e0e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la">mak sym Kaharlytskyi在Unsplash上的标题照片</em></p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="71bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la">原载于2020年6月7日</em><a class="ae kw" href="http://blog.adnansiddiqi.me/fehrist-document-indexing-library-in-go/" rel="noopener ugc nofollow" target="_blank"><em class="la">http://blog . adnansiddiqi . me</em></a><em class="la">。</em></p></div></div>    
</body>
</html>