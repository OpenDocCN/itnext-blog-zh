<html>
<head>
<title>Delete stale feature branches in a Kubernetes cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">删除Kubernetes集群中的过时要素分支</h1>
<blockquote>原文：<a href="https://itnext.io/delete-stale-feature-branches-in-a-kubernetes-cluster-23c76da27180?source=collection_archive---------3-----------------------#2020-07-01">https://itnext.io/delete-stale-feature-branches-in-a-kubernetes-cluster-23c76da27180?source=collection_archive---------3-----------------------#2020-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ef8983205a9358dbc7695009da5295b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7ANgL7543E5beGwbgqcTA.png"/></div></div></figure><p id="f22f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">Feature branch</code>(又名部署预览，预览应用)意味着一个拉请求被部署为你的应用程序的一个单独的实例。它允许一个人防止错误和缺陷，因为其他程序员或产品经理可以检查一个特性。本文介绍了一种在<code class="fe kz la lb lc b">Kubernetes</code>集群中删除特性分支资源的方法，在它的拉请求已经被合并到生产中之后。</p><h2 id="f340" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">特征分支</h2><p id="4a98" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">在<code class="fe kz la lb lc b">Kubernetes</code>集群中创建特性分支的一种方法是使用<a class="ae mb" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" rel="noopener ugc nofollow" target="_blank">名称空间</a>将生产部署与其他部署分开。生产配置可能类似于:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="f286" class="ld le it lc b gy mk ml l mm mn">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>name: medium-back-end<br/>...</span><span id="2d49" class="ld le it lc b gy mo ml l mm mn">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  namespace: medium-back-end<br/>spec:<br/>  replicas: 3<br/>...</span></pre><p id="c2ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">否则，特征分支总是具有不同的名称空间。如名称中的<code class="fe kz la lb lc b">-pr-</code>前缀或后缀。下面举例说明:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="0c25" class="ld le it lc b gy mk ml l mm mn">kind: Namespace<br/>apiVersion: v1<br/>metadata:<br/>  name: medium-back-end-pr-17<br/>...</span><span id="918e" class="ld le it lc b gy mo ml l mm mn">kind: Deployment<br/>apiVersion: apps/v1<br/>metadata:<br/>  namespace: medium-back-end-pr-17<br/>spec:<br/>  replicas: 1<br/>...</span></pre><p id="cc8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我创建了<a class="ae mb" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank"> Kubernetes操作符</a>(一个可以访问集群资源的应用程序)。可以在Github 上查看<a class="ae mb" href="https://github.com/dmytrostriletskyi/stale-feature-branch-operator" rel="noopener ugc nofollow" target="_blank">。它会删除与过时特征分支相关联的命名空间。在<code class="fe kz la lb lc b">Kubernetes</code>中，如果一个名称空间被删除，这个名称空间中的所有其他资源也会被自动删除。</a></p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="2f05" class="ld le it lc b gy mk ml l mm mn">$ kubectl get pods --all-namespaces | grep -e "-pr-"<br/>NAMESPACE              ... AGE<br/>medium-back-end-pr-264 ... 4d8h<br/>medium-back-end-pr-265 ... 5d7h</span></pre><p id="8b87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在这里和这里找到关于使用名称空间<a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/feature-deployments-in-kubernetes-c74bdcff0d8e">实现特性分支的更多信息。</a></p><h2 id="e0ea" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">动机</h2><p id="f77b" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">为了理解项目的动机，让我们检查拉式请求的通用持续集成及其生命周期:</p><ol class=""><li id="57b3" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">新的提交被推送到分支。</li><li id="0350" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">代码风格和测试通过。</li><li id="c45c" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">应用特征分支的配置(例如，将拉请求的标识符添加到现成的模板中)。</li><li id="6fef" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">使用<code class="fe kz la lb lc b">kubectl apply</code>将配置部署到集群。</li><li id="d4ba" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">该分支被合并到生产分支中(例如，主分支)。</li></ol><p id="a94f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一件重要的事情是，一个好的生命周期会在将配置应用到新的提交之前，删除特定提交的所有现有特性分支资源。需要确保每个提交的部署都是在清晰的状态下完成的。</p><p id="ed80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要点是:当一个拉请求被合并到一个生产分支时，它的<code class="fe kz la lb lc b">Kubernetes</code>资源仍然存在于一个集群中。发生这种情况是因为，在合并之后，唯一的生产分支将建立在持续集成之上(没有删除陈旧特性分支的场景)。好吧，我们该怎么处理？</p><h2 id="81e7" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">方法</h2><p id="db94" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">将功能分支合并到生产分支后，有三种方法可以删除功能分支的资源。这个项目和这三种方法都不理想。你们每个人都可以选择最适合自己情况的方法。</p><ol class=""><li id="287c" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">在每个生产分支构建中，检测哪个分支最后被合并并删除。</li></ol><ul class=""><li id="a33d" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky nd mv mw mx bi translated">这只能通过获取提交历史来完成。在这种情况下，提交应该包含其拉请求的标识符(一个数字或分支名称)。</li><li id="a470" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky nd mv mw mx bi translated">有时，生产分支的构建会在您不想重新构建的阶段失败。例如，您有以下几个阶段:下载项目、运行项目、运行测试、发布、发送通知、删除过时的特性分支。如果构建在发送通知阶段失败，您将无法轻松地重新构建它。</li><li id="9782" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky nd mv mw mx bi translated">在没有任何上下文的情况下，删除陈旧特征分支的阶段对于新人来说并不明显。</li></ul><p id="56d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.将一个webhook集成到你的持续集成系统中(<a class="ae mb" href="https://github.community/t/trigger-jenkins-job-when-a-pull-request-is-merged-to-a-branch/1169/3" rel="noopener ugc nofollow" target="_blank">例子</a>)。</p><ul class=""><li id="d154" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky nd mv mw mx bi translated">这可能不符合你的开发原则。例如，<a class="ae mb" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>只支持一种类型的管道，您可以将管道的配置文件上传到源代码服务器。因此，要创建一个webhook，你需要<a class="ae mb" href="https://stackoverflow.com/questions/31407332/how-to-process-a-github-webhook-payload-in-jenkins" rel="noopener ugc nofollow" target="_blank">单独的脚本来处理webhook的数据</a>，这些数据不会被上传到源代码服务器，应该保存在用户界面中。</li></ul><p id="9331" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.在Kubernetes集群中创建自己的<code class="fe kz la lb lc b">Cronjob</code>资源。</p><ul class=""><li id="3f37" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky nd mv mw mx bi translated">这也需要开发和维护，尤其是在从一个公司转移到另一个公司的时候。</li><li id="1aea" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky nd mv mw mx bi translated">此外，这个项目的工作原理与<code class="fe kz la lb lc b">Cronjob</code>资源几乎相同，所以在重用时不会有任何损失。</li></ul><h2 id="f155" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">装置</h2><p id="9854" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">使用下面的命令应用最新版本的配置。这将创建<code class="fe kz la lb lc b">StaleFeatureBranch</code>资源，将操作员安装到<code class="fe kz la lb lc b">stale-feature-branch-operator</code>名称空间，创建<a class="ae mb" href="https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/" rel="noopener ugc nofollow" target="_blank">服务帐户</a>，以及必要的<a class="ae mb" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac" rel="noopener ugc nofollow" target="_blank"> RBAC </a>角色。</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="b0a6" class="ld le it lc b gy mk ml l mm mn">$ kubectl apply -f \ https://raw.githubusercontent.com/dmytrostriletskyi/stale-feature-branch-operator/master/configs/production.yml</span></pre><h2 id="a787" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">使用</h2><p id="71fe" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">应用上述安装说明后，创建并应用一个配置文件，其中<code class="fe kz la lb lc b">feature-branch.dmytrostriletskyi.com/v1</code>为<code class="fe kz la lb lc b">apiVersion</code>，而<code class="fe kz la lb lc b">StaleFeatureBranch</code>为<code class="fe kz la lb lc b">kind</code>:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="6935" class="ld le it lc b gy mk ml l mm mn">apiVersion: feature-branch.dmytrostriletskyi.com/v1<br/>kind: StaleFeatureBranch<br/>metadata:<br/>  name: stale-feature-branch<br/>spec:<br/>  namespaceSubstring: -pr-<br/>  afterDaysWithoutDeploy: 3</span></pre><p id="75fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为资源选择任何元数据的名称，并深入了解规范:</p><ol class=""><li id="b8db" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">需要<code class="fe kz la lb lc b">namespaceSubstring</code>来获取所有特征分支的名称空间。例如，如果一个集群中有名称空间<code class="fe kz la lb lc b">medium-back-end</code>、<code class="fe kz la lb lc b">medium-front-end</code>、<code class="fe kz la lb lc b">medium-back-end-pr-17</code>、<code class="fe kz la lb lc b">medium-back-end-pr-33</code>，上面的例子将获取<code class="fe kz la lb lc b">medium-back-end-pr-17</code>和<code class="fe kz la lb lc b">medium-back-end-pr-33</code>，因为<code class="fe kz la lb lc b">-pr-</code>子串出现在那里。</li><li id="8769" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated"><code class="fe kz la lb lc b">afterDaysWithoutDeploy</code>只需要删除旧的名称空间。如果在那里设置<code class="fe kz la lb lc b">3 days</code>，则<code class="fe kz la lb lc b">1 day</code>或<code class="fe kz la lb lc b">2 days</code>之前创建的名称空间不会被删除，但<code class="fe kz la lb lc b">3 days, 1 hour</code>或<code class="fe kz la lb lc b">4 days</code>之前创建的名称空间会被删除。</li></ol><p id="69b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，它每隔<code class="fe kz la lb lc b">30 minutes</code>处理一次特性分支的名称空间。规格中最后一个可用的参数是<code class="fe kz la lb lc b">checkEveryMinutes</code>。如果默认值不符合您的需要，您可以以分钟为单位配置进程的频率。</p><h2 id="5d56" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">它是如何在引擎盖下工作的</h2><p id="75c8" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">该指南展示了如何删除过时的特征分支。您不应该为生产集群复制下面的说明，因为它只是一个详细的示例来理解操作员的行为。在本章中，您将在您的个人计算机上运行一个测试集群。</p><p id="ff19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要求是:</p><ol class=""><li id="ff4e" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated"><a class="ae mb" href="https://docs.docker.com/get-docker" rel="noopener ugc nofollow" target="_blank">码头工人</a>。虚拟化在称为容器的包中运行软件。</li><li id="6848" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated"><a class="ae mb" href="https://kubernetes.io/docs/tasks/tools/install-minikube" rel="noopener ugc nofollow" target="_blank"> Minikube </a>。在个人电脑上的虚拟机(或<code class="fe kz la lb lc b">Docker</code>)中运行单节点<code class="fe kz la lb lc b">Kubernetes</code>集群。</li><li id="15c9" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">库贝克特尔。访问<code class="fe kz la lb lc b">Kubernetes</code>集群的命令行界面。</li></ol><p id="1676" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用以下命令在您的个人计算机上启动<code class="fe kz la lb lc b">Kubernetes</code>集群:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="c336" class="ld le it lc b gy mk ml l mm mn">$ minikube start --vm-driver=docker<br/>minikube v1.11.0 on Darwin 10.15.5<br/>Using the docker driver based on existing profile.<br/>Starting control plane node minikube in cluster minikube.</span></pre><p id="c1f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">之后，选择创建的集群作为<code class="fe kz la lb lc b">kubectl</code>的主集群。当您在一台计算机上处理多个集群时，需要使用它:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="6eb5" class="ld le it lc b gy mk ml l mm mn">$ kubectl config use-context minikube<br/>Switched to context "minikube".</span></pre><p id="f6ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将应用生产配置。但是由于这些是生产配置，它们会期望集群中存在旧的名称空间。我们的集群是新的，不存在旧的资源。因为您没有它们，所以操作符允许您指定调试参数。如果启用了调试，将删除所有命名空间，而不检查是否过时:</p><p id="71d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将生产配置复制到您的个人计算机上:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="29f2" class="ld le it lc b gy mk ml l mm mn">$ curl https://raw.githubusercontent.com/dmytrostriletskyi/stale-feature-branch-operator/master/configs/production.yml &gt; stale-feature-branch-production-configs.yml</span></pre><p id="ead9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过更改设置来启用调试。对于<code class="fe kz la lb lc b">Linux</code>，它是:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="1d22" class="ld le it lc b gy mk ml l mm mn">$ sed -i 's|false|true|g' stale-feature-branch-production-configs.yml</span></pre><p id="3adb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于<code class="fe kz la lb lc b">macOS</code>它是:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="8b0d" class="ld le it lc b gy mk ml l mm mn">$ sed -i "" 's|false|true|g' stale-feature-branch-production-configs.yml</span></pre><p id="5cba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">应用更改后的生产配置:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="2b82" class="ld le it lc b gy mk ml l mm mn">$ kubectl apply -f stale-feature-branch-production-configs.yml</span></pre><p id="7e11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">获取<code class="fe kz la lb lc b">Kubernetes</code>集群中的所有资源(我们可以使用的种类)。您将看到可以创建的<code class="fe kz la lb lc b">StaleFeatureBranch</code>资源:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="5994" class="ld le it lc b gy mk ml l mm mn">$ kubectl api-resources | grep stalefeaturebranches                 NAME                 ... KIND<br/>stalefeaturebranches ... StaleFeatureBranch</span></pre><p id="130f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">获取<code class="fe kz la lb lc b">stale-feature-branch-operator</code>名称空间中的pod。您将看到一个监听新的<code class="fe kz la lb lc b">StaleFeatureBranch</code>资源运行的操作员:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="8467" class="ld le it lc b gy mk ml l mm mn">$ kubectl get pods --namespace stale-feature-branch-operator<br/>NAME                                           ... STATUS  ... AGE stale-feature-branch-operator-6bfbfd4df8-m7sch ... Running ... 38s</span></pre><p id="f688" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">获取操作员的日志以确保它正在运行:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="473e" class="ld le it lc b gy mk ml l mm mn">$ kubectl logs stale-feature-branch-operator-6bfbfd4df8-m7sch -n stale-feature-branch-operator</span><span id="0fdc" class="ld le it lc b gy mo ml l mm mn">... "msg":"Operator Version: 0.0.1"}<br/>... "msg":"Starting EventSource", ... , "source":"kind source: /"}<br/>... "msg":"Starting Controller", ...}<br/>... "msg":"Starting workers", ..., "worker count":1}</span></pre><p id="9771" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为<code class="fe kz la lb lc b">StaleFeatureBranch</code>安装夹具(模拟<code class="fe kz la lb lc b">Kubernetes</code>集群资源的现成配置):</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="57b1" class="ld le it lc b gy mk ml l mm mn">$ kubectl apply -f https://raw.githubusercontent.com/dmytrostriletskyi/stale-feature-branch-operator/master/fixtures/stale-feature-branch.yml</span></pre><p id="09bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">fixture将检查名称中包含<code class="fe kz la lb lc b">-pr-1</code>的名称空间<code class="fe kz la lb lc b">once a minute</code>:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="023c" class="ld le it lc b gy mk ml l mm mn">apiVersion: feature-branch.dmytrostriletskyi.com/v1<br/>kind: StaleFeatureBranch<br/>metadata:<br/>  name: stale-feature-branch<br/>spec:<br/>  namespaceSubstring: -pr-<br/>  afterDaysWithoutDeploy: 1 <br/>  checkEveryMinutes: 1</span></pre><p id="12f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">操作员接受了创建的资源，并准备删除与上述配置匹配的名称空间:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="106b" class="ld le it lc b gy mk ml l mm mn">$ kubectl logs stale-feature-branch-operator-6bfbfd4df8-m7sch -n stale-feature-branch-operator</span><span id="f25a" class="ld le it lc b gy mo ml l mm mn">... "msg":"Stale feature branch is being processing.",<br/>"namespaceSubstring":"-pr","afterDaysWithoutDeploy":1,<br/>"checkEveryMinutes":1,"isDebug":"true"}</span></pre><p id="353c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建包含两个名称空间<code class="fe kz la lb lc b">project-pr-1</code>和<code class="fe kz la lb lc b">project-pr-2</code>以及许多其他资源(部署、服务、秘密等)的fixtures。):</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="f07e" class="ld le it lc b gy mk ml l mm mn">$ kubectl apply -f https://raw.githubusercontent.com/dmytrostriletskyi/stale-feature-branch-operator/master/fixtures/first-feature-branch.yml -f <a class="ae mb" href="https://raw.githubusercontent.com/dmytrostriletskyi/stale-feature-branch-operator/master/fixtures/second-feature-branch.yml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/dmytrostriletskyi/stale-feature-branch-operator/master/fixtures/second-feature-branch.yml</a></span><span id="8207" class="ld le it lc b gy mo ml l mm mn">...<br/>namespace/project-pr-1 created<br/>deployment.apps/project-pr-1 created<br/>service/project-pr-1 created horizontalpodautoscaler.autoscaling/project-pr-1 created secret/project-pr-1 created<br/>configmap/project-pr-1 created<br/>ingress.extensions/project-pr-1 created<br/>namespace/project-pr-2 created<br/>deployment.apps/project-pr-2<br/>created service/project-pr-2 created horizontalpodautoscaler.autoscaling/project-pr-2 created secret/project-pr-2 created<br/>configmap/project-pr-2 created<br/>ingress.extensions/project-pr-2 created</span></pre><p id="4f41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用以下命令检查它们是否存在:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="c7a0" class="ld le it lc b gy mk ml l mm mn">$ kubectl get namespace,pods,deployment,service,horizontalpodautoscaler,configmap,ingress -n project-pr-1 &amp;&amp; kubectl get namespace,pods,deployment,service,horizontalpodautoscaler,configmap,ingress -n project-pr-2</span><span id="2ca9" class="ld le it lc b gy mo ml l mm mn">...<br/>NAME                              ... READY ... STATUS  ... AGE<br/>pod/project-pr-1-848d5fdff6-rpmzw ... 1/1   ... Running ... 67s</span><span id="d9c4" class="ld le it lc b gy mo ml l mm mn">NAME                         ... READY ... AVAILABLE ... AGE<br/>deployment.apps/project-pr-1 ... 1/1   ... 1         ... 67s<br/>...</span></pre><p id="1a17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如上所述，当启用调试时，所有名称空间都将被删除，而不检查是否过时。检查操作员的日志:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="d647" class="ld le it lc b gy mk ml l mm mn">$ kubectl logs stale-feature-branch-operator-6bfbfd4df8-m7sch -n stale-feature-branch-operator</span><span id="884d" class="ld le it lc b gy mo ml l mm mn">... "msg":"Namespace should be deleted due to debug mode is enabled.","namespaceName":"project-pr-1"}<br/>... "msg":"Namespace is being processing.","namespaceName":"project-pr-1"}<br/>... "msg":"Namespace has been deleted.","namespaceName":"project-pr-1"}<br/>... "msg":"Namespace should be deleted due to debug mode is enabled.","namespaceName":"project-pr-2"}<br/>... "msg":"Namespace is being processing.","namespaceName":"project-pr-2"}<br/>... "msg":"Namespace has been deleted.","namespaceName":"project-pr-2"}</span></pre><p id="31d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您再次检查资源，输出将是<code class="fe kz la lb lc b">Terminating</code>或空的；</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="8a19" class="ld le it lc b gy mk ml l mm mn">$ kubectl get namespace,pods,deployment,service,horizontalpodautoscaler,configmap,ingress -n project-pr-1 &amp;&amp; kubectl get namespace,pods,deployment,service,horizontalpodautoscaler,configmap,ingress -n project-pr-2<br/>...</span></pre><p id="1deb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以再次经历创建资源的过程。最后，在一分钟或更短的时间内，资源将再次被删除。</p><p id="2756" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的关注！同样，<a class="ae mb" href="https://github.com/dmytrostriletskyi/stale-feature-branch-operator" rel="noopener ugc nofollow" target="_blank">Github上的Kubernetes操作员</a>。:)</p></div></div>    
</body>
</html>