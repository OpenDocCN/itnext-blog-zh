<html>
<head>
<title>How to auto-deploy your App with one command?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用一个命令自动部署你的应用？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-auto-deploy-your-app-with-one-command-12f9ac00d34a?source=collection_archive---------1-----------------------#2019-03-22">https://itnext.io/how-to-auto-deploy-your-app-with-one-command-12f9ac00d34a?source=collection_archive---------1-----------------------#2019-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2d82" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本文中，我将描述我为应用程序准备自动部署解决方案的经验。此解决方案可以针对任何其他可以使用Unix CLI管理的技术进行修改。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fce702c6b0b8fcfd4479caff20d5fe28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*920OwPHQAaMmxmv1Qj8QNg.jpeg"/></div></div></figure><h1 id="641e" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">史前史</h1><p id="9c82" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">最近我开始了一个新项目。这应该是一个简单的NodeJs服务器应用程序，用于管理移动应用程序。我从头开始设置的。每个项目的一个有用之处是自动部署。它有助于减少开发人员的时间和客户的金钱。此外，任何操作的自动化降低了与人为错误相关的风险。</p><p id="6c56" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在我之前的项目中，我们使用了MeteorUp。这是一个允许在一个命令中部署你的应用程序的工具。这很棒，因为它节省了时间，简化了开发人员的生活。</p><p id="c0ac" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当我开始一个新项目时，我会把这个想法记在心里，并问自己:“嗯……为什么不呢？让我们在当前项目中也这样做吧！”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d17c067bfb1fc1675c6b4a055cb8eda6.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*7ZTsnoATjtpAZ9rZXWSBrA.gif"/></div></figure><p id="dc2c" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我做了一些研究，找到了一些解决方案。但是我一个都不喜欢，因为有些非常复杂，有些不可定制，不灵活。我不喜欢为简单的任务准备复杂的解决方案，所以我会试着为这个任务准备一些有效、简单、灵活的解决方案。</p><p id="2c9f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">该应用程序将被部署到EC2 VPS实例。此外，无论您喜欢在哪里部署应用程序，主要要求是:</p><ul class=""><li id="4e1d" class="ml mm iq ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">建立ssh连接的能力</li><li id="a48a" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">VPS上类似Unix的操作系统</li><li id="323e" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">本地机器上类似Unix的操作系统</li></ul></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="6c1e" class="kr ks iq bd kt ku ng kw kx ky nh la lb jw ni jx ld jz nj ka lf kc nk kd lh li bi translated">理论</h1><p id="1bc6" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们从一些理论开始，以更好地理解我们做什么，我们最终应该得到什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/e26e6e1330f8926c116b0fa61ef091f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*WIVCiohpBiV54mIyS1zuhw.jpeg"/></div></figure><p id="e14c" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">因此，首先，我们假设，我们可以访问VPS和这个项目的所有环境。</p><p id="c691" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">对于节点项目，这应该是:</p><ul class=""><li id="2626" class="ml mm iq ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">NodeJs</li><li id="a384" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">NPM</li><li id="86db" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">饭桶</li><li id="d8d6" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">配置Nginx在默认端口和应用端口之间重定向请求</li><li id="5600" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">开放端口(默认或其他)允许外部HTTP请求到我们的应用程序</li><li id="7390" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">用Git app克隆的。</li></ul><p id="1557" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果所有的背景都准备好了，我们就可以开始设计算法步骤了。要将应用部署到VPS，需要执行以下步骤:</p><ul class=""><li id="9511" class="ml mm iq ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">从我们的本地机器连接到VPS</li><li id="b4f5" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">将当前目录更改为app目录</li><li id="5db7" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">从远程存储库(可以是Github、BitBucket等)获取最新的应用程序代码</li><li id="92e1" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">停止应用程序实例(如果存在)</li><li id="6a87" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">移除已安装的模块(节点应用特定操作)</li><li id="3ae2" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">安装新模块</li><li id="86fe" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">运行最新版本的应用程序</li></ul><p id="7975" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">所有这些操作都可以通过Unix命令行界面(CLI)来完成。同样，在类似Unix的操作系统中，我们获得了一些令人敬畏的能力来编写一些场景——shell脚本。这是可以包含操作系统命令、变量、循环、条件操作符的文件，也可以使用shell脚本运行其他shell脚本文件，并通过CLI执行任何操作系统可以执行的操作。我觉得这一节的理论讲的就够了，下一节可以从一些实践开始。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="cf39" class="kr ks iq bd kt ku ng kw kx ky nh la lb jw ni jx ld jz nj ka lf kc nk kd lh li bi translated">实践</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/566c6a55d5c97314f81bf3f04f9e1169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nwqnV9iYDhPSQl_q7HBJkQ.jpeg"/></div></div></figure><p id="7867" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们来看一下上述算法的每一点，并回顾一下实施每项操作的CLI命令。</p><h2 id="38d8" class="nn ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated">从我们的本地机器连接到VPS</h2><p id="578a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">首先，我们应该与我们的服务器建立连接。出于这些目的，我使用ssh应用程序。它默认安装到ubuntu中，但是对于其他OS可以要求手动安装。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="6fc9" class="nn ks iq oa b gy oe of l og oh">ssh remote_username@remote_host</span></pre><p id="3077" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在该命令之后，CLI会询问您密码，如果您为远程连接输入了正确的密码，所有接下来输入的命令将被重定向到远程服务器，直到您关闭终端或键入“logout”命令。</p><p id="2f07" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我的shell脚本将存储在存储库中，所以我不喜欢将任何密码提交到脚本中，所以我将使用另一种方法来建立连接—权限密钥。AWS EC2提供许可密钥文件来连接它们的服务器，而不是传统的密码方式。因此与使用键的连接将如下所示:</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="ecdc" class="nn ks iq oa b gy oe of l og oh">ssh -i permission_key_file_path remote_username@remote_host</span></pre><p id="5f4c" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果提供了正确的密钥，连接将在没有任何密码的情况下建立。所以脚本可以存储在存储库中，但是密钥文件应该只有项目所有者。</p><h2 id="c234" class="nn ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated">将当前目录更改为app目录</h2><p id="31b6" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这不是一个复杂的动作:</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="5003" class="nn ks iq oa b gy oe of l og oh">cd path_to_project_folder</span></pre><h2 id="9d2b" class="nn ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated">从远程存储库中获取最新的应用程序代码</h2><p id="6893" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这里也一样。这是基于对CLI Git的了解。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="614f" class="nn ks iq oa b gy oe of l og oh">git pull<br/>git checkout branch_name<br/>git pull origin branch_name</span></pre><h2 id="7c89" class="nn ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated">停止应用程序实例</h2><p id="7dac" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这个要看你怎么管理你的app了。我更喜欢使用<a class="ae oi" href="http://pm2.keymetrics.io/" rel="noopener ugc nofollow" target="_blank"> PM2 </a>来管理我的应用程序。对于pm2，这看起来像</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="9fa1" class="nn ks iq oa b gy oe of l og oh">pm2 stop app_id_or_name</span></pre><h2 id="6512" class="nn ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated">移除已安装的模块并安装新模块</h2><p id="2a3d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这是简单的删除文件夹和所有嵌套的文件夹/文件</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="419c" class="nn ks iq oa b gy oe of l og oh">rm -rf node_modules<br/>npm install</span></pre><h2 id="ca38" class="nn ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated">运行最新版本的应用程序</h2><p id="b7bf" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">用于此的同一个pm2工具。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="5798" class="nn ks iq oa b gy oe of l og oh">pm2 start app_id_or_name<br/>pm2 save</span></pre></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="82ce" class="kr ks iq bd kt ku ng kw kx ky nh la lb jw ni jx ld jz nj ka lf kc nk kd lh li bi translated">工作解决方案的构建</h1><p id="ac0b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">上面描述的所有命令片段看起来都很好，但是它们仍然不能解决我们的任务。让我们将上一节中描述的所有内容构建到一个可用的解决方案中。<br/>照做就是了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/13db3f229e73b547eedf9ed881930af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/1*_YbfY23vX9Wsz04lwTjtNw.gif"/></div></figure><p id="4e1e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">首先，我们需要创建shell脚本文件。为此，只需用*创建一个文件。sh分辨率。在我的例子中是“deploy.sh”</p><p id="32ee" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">然后将您的第一条命令写入该文件</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="3397" class="nn ks iq oa b gy oe of l og oh">echo hello world!</span></pre><p id="2331" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">并保存该文件。它将打印到控制台“hello world！”。<br/>要运行您的简单脚本，您应该更改文件权限并允许它可执行。您可以使用操作系统的用户界面或使用简单的方式通过终端来完成:</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="0685" class="nn ks iq oa b gy oe of l og oh">chmod +x deploy.sh</span></pre><p id="98d8" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">现在，您的shell脚本可以使用下一个命令运行了:</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="f0a0" class="nn ks iq oa b gy oe of l og oh">sh deploy.sh</span></pre><p id="ffde" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">所以下一个自动部署脚本将被逐行描述。</p><p id="ff6b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">脚本变量的初始化:</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="2c67" class="nn ks iq oa b gy oe of l og oh">SSH_KEY_PATH="key.pem"<br/>SERVER="remote_username@remote_host"<br/>DEST_FOLDER="path_to_project_folder"</span></pre><p id="68c4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">分支名称变量的初始化。可以将其指定为脚本参数，或者如果不指定该参数，则将“master”用作默认分支。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="a2b2" class="nn ks iq oa b gy oe of l og oh">[[ $1 = '' ]] &amp;&amp; BRANCH="master" || BRANCH=$1</span></pre><p id="1fd2" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">使用之前声明的变量再构造一个变量</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="24c9" class="nn ks iq oa b gy oe of l og oh">PARAMS="BRANCH=\"$BRANCH\" DEST_FOLDER=\"$DEST_FOLDER\""</span></pre><p id="ea77" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">变量“PARAMS”将用于通过shh连接传递参数</p><p id="bc10" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">要使用访问密钥文件，应使用命令将其访问权限更改为400。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="a1ef" class="nn ks iq oa b gy oe of l og oh">chmod 400 key.pem</span></pre><p id="aeba" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">与服务器的连接</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="7ed1" class="nn ks iq oa b gy oe of l og oh">ssh -i $SSH_KEY_PATH $SERVER $PARAMS 'bash -i'  &lt;&lt;-'ENDSSH'<br/>    #Server actions will be here<br/>ENDSSH</span></pre><p id="e531" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">为了连接到能够在其上执行命令的服务器，我使用</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="09cb" class="nn ks iq oa b gy oe of l og oh">&lt;&lt;-'ENDSSH'<br/>    #Server actions will be here<br/>ENDSSH</span></pre><p id="f8fa" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">！重要提示:使用正确的环境变量' bash -i '参数，通过ssh允许exec命令。没有它，npm和节点路径将不可用。</p><p id="2e05" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">以及通过ssh在远程服务器上执行的终端命令，以加载并启动最新版本的应用程序。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="510d" class="nn ks iq oa b gy oe of l og oh">cd $DEST_FOLDER<br/><br/>git stash<br/># to stash package-lock.json file changes<br/><br/>git pull<br/>git checkout $BRANCH<br/>git pull origin $BRANCH<br/><br/>rm -rf node_modules/<br/><br/>npm install<br/><br/>pm2 stop app_name<br/>pm2 start app_name<br/>pm2 save<br/>pm2 list<br/><br/>exit</span></pre><p id="285c" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这组命令可以针对任何其他技术进行更改，例如更改为另一组操作或针对其他技术执行相同的操作。</p><h1 id="7322" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">最终剧本</h1><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="1a29" class="nn ks iq oa b gy oe of l og oh">[[ $1 = '' ]] &amp;&amp; BRANCH="master" || BRANCH=$1<br/><br/>SSH_KEY_PATH="key.pem"<br/>SERVER="remote_username@remote_host"<br/>DEST_FOLDER="path_to_project_folder"<br/>PARAMS="BRANCH=\"$BRANCH\" DEST_FOLDER=\"$DEST_FOLDER\""<br/><br/>echo ===================================================<br/>echo Autodeploy server<br/>echo selected barcn $BRANCH<br/>chmod 400 $SSH_KEY_PATH<br/>echo ===================================================<br/>echo Connecting to remote server...<br/>ssh -i $SSH_KEY_PATH $SERVER $PARAMS 'bash -i'  &lt;&lt;-'ENDSSH'<br/>    #Connected<br/><br/>    cd $DEST_FOLDER<br/><br/>    git stash<br/>    # to stash package-lock.json file changes<br/><br/>    git pull<br/>    git checkout $BRANCH<br/>    git pull origin $BRANCH<br/><br/>    rm -rf node_modules/<br/><br/>    npm install<br/><br/>    pm2 stop app_name<br/>    pm2 start app_name<br/>    pm2 save<br/>    pm2 list<br/><br/>    exit<br/>ENDSSH</span></pre><h1 id="23c8" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结论</h1><p id="324b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">结果，我得到了一个脚本，当我需要部署应用程序时，它可以让我节省时间。我意识到存在一些其他的解决方案，也许在其他情况下会更好。但是对我来说，如果你想为一个小项目快速灵活地设置部署过程，这是一个很好的解决方案。</p><p id="e742" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">此外，这种远程服务器管理方法可以用于其他一些任务和管理其他一些技术</p><p id="6d82" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果这篇文章对你有用，你可以鼓掌(即使是50次))))<br/>如果你有什么问题，欢迎在评论中问我。</p></div></div>    
</body>
</html>