<html>
<head>
<title>A Guide to GraphQL Schema Federation, Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL模式联邦指南，第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/a-guide-to-graphql-schema-federation-part-2-872a820510ff?source=collection_archive---------5-----------------------#2019-06-03">https://itnext.io/a-guide-to-graphql-schema-federation-part-2-872a820510ff?source=collection_archive---------5-----------------------#2019-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6413" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">批准</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/e560e8439605d4950fe3b8967914814c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*GCmd8VMPd-ojX6wgAhfG1w.png"/></div></figure><p id="25ce" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">欢迎阅读构建分布式GraphQL API系列指南的第二部分。在这篇文章中，我们将为用户添加一个非常简单的登录和退出系统的机制。然后，我们将看看nautilus gateway如何允许我们向我们的<code class="fe lj lk ll lm b">Query</code>类型的根添加字段，我们将使用这些字段来查询当前用户。</p><p id="1c48" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">请记住，这篇文章中的代码示例对于生产来说不够安全。我尽我最大的努力尽可能地代表“真实世界”,而不损害例子的清晰性。</p><p id="49ec" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">本教程要求在您的计算机上安装Go和Node。如果你在设置时遇到困难，请随时联系我们！</p><h1 id="2ba6" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">我们的服务</h1><p id="06f2" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">像以前一样，我们将从起始项目的两个服务开始:</p><pre class="kf kg kh ki gt ml lm mm mn aw mo bi"><span id="f877" class="mp lp iq lm b gy mq mr l ms mt">git clone https://github.com/alecaivazis/schema-federation-demo &amp;&amp; git checkout auth</span></pre><p id="04ff" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们的核心应用程序由两个服务组成，一个管理我们的猫照片，另一个负责我们的拍卖。这两个服务被合并到第三个服务中，称为“网关”，作为我们应用程序的单一入口点。在本文中，我们还有第四个服务，负责验证用户。在我们的设置中，每个服务负责其特定的授权逻辑。网关只负责从用户请求中提取信息，并将其转发给其他服务。</p><p id="1168" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">由于我们的例子很小，auth服务只需要向我们的API添加一个突变:<code class="fe lj lk ll lm b">login</code>。正如预期的那样，<code class="fe lj lk ll lm b">login</code>接受<code class="fe lj lk ll lm b">username</code>和<code class="fe lj lk ll lm b">password</code>，如果组合有效，则返回一个令牌，客户机以后可以用它来标识自己。一旦客户机拥有了这个令牌，它将把它包含在对API的所有请求的头中。网关将把这个值转发给其他服务，这些服务负责根据它们的域施加任何授权约束。例如，由照片服务来定义用户1是否可以解决<code class="fe lj lk ll lm b">User.favoritePhoto</code>。</p><h1 id="21cc" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">构建自定义网关</h1><p id="e528" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">默认情况下，nautilus网关在解析查询时不会将任何头转发给后端服务。为了实现这一点，我们必须构建一个定制的二进制文件，这需要编写一些Go。如果你以前从未写过围棋，不要担心！如果你懂JavaScript，读起来应该很简单。</p><p id="5eb6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你看一下<code class="fe lj lk ll lm b">gateway.go</code>,你会看到很多创建网关实例所必需的样板文件已经就绪。我们首先必须自省我们的远程后端，用结果实例化网关，并将其连接到我们的http路由器。</p><p id="81c8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们走得太远之前，让我们验证一切都在工作。按照自述文件中的说明启动其他服务，然后用<code class="fe lj lk ll lm b">go run gateway.go</code>运行网关。现在，您应该会看到一条带有URL的消息，您可以访问我们的系统并与之交互。使用以下查询以用户1的身份登录，并保留返回的身份验证令牌:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="1ed1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">将用户信息转发到我们的后端</h1><p id="0223" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">现在客户机有了一个要求身份的令牌，我们必须在网关中处理它，并向服务发送它们执行任何类型的授权检查所需的信息。为此，我们将定义一个<code class="fe lj lk ll lm b">nautilus.RequestMiddleware</code>，它根据请求上下文中的某个值向出站请求添加一个头。要做到这一点，我们首先必须从传入的请求中获取头的值，并将其保存在执行上下文中。让我们首先定义一个中间件，它将包装我们的操场路由，并将提取传入的<code class="fe lj lk ll lm b">Authorization</code>头的值，将其保存在请求上下文的<code class="fe lj lk ll lm b">"user-id"</code>键下，并调用下一个处理程序:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0734" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">不要忘记用这个中间件包装我们之前定义的路线:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="ec8d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">既然我们在请求上下文中有了授权头的值，我们就可以定义一个<code class="fe lj lk ll lm b">gateway.RequestMiddleware</code>,提取我们之前设置的<code class="fe lj lk ll lm b">"user-id"</code>键的值，并在网关和其他服务之间发出的内部网络请求上设置一个头:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a82c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">将中间件包含到我们对<code class="fe lj lk ll lm b">gateway.New</code>的调用中:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1ba9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">既然我们的网关将用户的ID和他们的请求一起转发，剩下唯一要做的事情就是转到我们的后端服务，用那个值做一些事情。例如，让我们让您看不到另一个用户的<code class="fe lj lk ll lm b">photoGallery</code>。为此，打开<code class="fe lj lk ll lm b">photoService.js</code>并修改<code class="fe lj lk ll lm b">User.photoGallery</code>解析器，如下所示:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5591" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有了这些，您应该能够验证预期的行为。取之前写下的token，设置为操场中<code class="fe lj lk ll lm b">Authorization </code>头的值。现在，当您尝试启动这个查询时，您应该会看到一个错误，因为您是以用户“1”的身份登录的，并且正在查找用户“2”的<code class="fe lj lk ll lm b">photoGallery</code>:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="5650" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">查询当前用户</h1><p id="0ef4" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">虽然分布式API中的大部分逻辑和计算发生在网关“背后”的服务中，但在某些情况下，由网关本身解析字段是有意义的。在具有授权的API中，一个非常常见的实例是查询当前用户的能力。按照惯例，这个字段被称为<code class="fe lj lk ll lm b">Query.viewer</code>，它允许当前用户要求自己的东西:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3b68" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">将这些类型的字段添加到nautilus网关只需要几行代码:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2bc5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">剩下的唯一一件事就是告诉网关将这个字段与我们之前的中间件一起使用:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0015" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们现在应该能够使用以下查询来查询我们最喜欢的照片:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="4f07" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="8bb7" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">在这篇博文中，我们构建了一个定制网关，它接受由mutation提供的auth令牌，并将底层用户的ID转发到我们的后端。然后，我们在服务中使用这些信息来定义特定于域的授权逻辑。最后，我们看到，我们还可以使用这个令牌在网关上定义一个字段，该字段解析为当前用户，而不需要额外的网络跳跃来解析服务级别的字段。</p><p id="bf37" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">虽然这个例子被精简为简单的必需品，但希望它说明了不同的运动部件是如何一起工作的。请记住，验证密码、创建和验证令牌等细节并不意味着展示最佳做法，而是行业标准的占位符。如果你不确定更好的解决方案是什么，你可以随时在gopher's slack上找到我。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="997f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">暂时就这样吧！非常感谢你陪我走了这么远。</p><p id="bfba" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">不幸的是，我还没有准备好这个系列的下一篇文章。然而，我知道它很可能包含一个性能技巧，我们可以用它来加快网关的查询时间。敬请期待！</p><p id="6677" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一如既往，如果这是我们分手的地方，我希望你有一个美好的一天休息。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="5484" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="ln">原载于【https://alec.aivazis.com】<a class="ae nd" href="https://alec.aivazis.com/blog/schema-federation/auth" rel="noopener ugc nofollow" target="_blank"><em class="ln"/></a><em class="ln">。</em></em></p></div></div>    
</body>
</html>