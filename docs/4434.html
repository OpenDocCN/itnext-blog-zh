<html>
<head>
<title>Part 3: Deploying the Application with Helm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第3部分:用Helm部署应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/part-3-deploying-the-application-with-helm-giant-swarm-5994b6044f18?source=collection_archive---------5-----------------------#2020-06-29">https://itnext.io/part-3-deploying-the-application-with-helm-giant-swarm-5994b6044f18?source=collection_archive---------5-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><a href="https://www.giantswarm.io/"><div class="gh gi jn"><img src="../Images/39cc20050877755b9077b7b078c019f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxE4QmLAORxdQei_gRahuQ.jpeg"/></div></a></figure><p id="d663" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">关于如何使用基于Kubernetes的平台轻松获得集中式日志记录、更好的安全性、性能指标和身份验证的深入系列。</em></p><h1 id="9e37" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">介绍</h1><p id="c834" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">这是我们的教程的第三部分，介绍如何使用云原生堆栈创建和部署应用程序。第1部分讨论了如何<a class="ae lw" href="https://www.giantswarm.io/blog/how-the-cloud-native-stack-helps-writing-minimal-microservices/" rel="noopener ugc nofollow" target="_blank">建立开发环境</a>，而第2部分讨论了<a class="ae lw" href="https://www.giantswarm.io/blog/a-few-dozen-lines-of-code-part-2-creating-the-application" rel="noopener ugc nofollow" target="_blank">构建实际的应用程序。</a></p><p id="ab3a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个条目中，我们想要解决部署问题:如何打包和准备我们的应用程序，以便在我们的平台上进行部署。</p><h1 id="545d" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">TL；灾难恢复版本</h1><p id="e1b9" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在这一部分，我们将为我们的应用程序准备一个舵图。我们可以只用Kubernetes清单和“kubectl”命令做同样的事情，但是这样我们就可以用一个Helm命令部署应用程序的所有组件。我们也可以把舵图放到网上，这样其他人更容易找到并安装它。如果您对部署设置细节不感兴趣，并且不想一步一步地部署应用程序，不要担心；码头图片和舵图都是公开的。</p><p id="eac3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">顺便说一句，如果你还没有按照<a class="ae lw" href="https://www.giantswarm.io/blog/how-the-cloud-native-stack-helps-writing-minimal-microservices/" rel="noopener ugc nofollow" target="_blank">第1部分</a>操作，请确保通过运行以下命令来配置你的头盔库:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1290" class="mg ku iq mc b gy mh mi l mj mk">$ helm repo add giantswarm https://giantswarm.github.io/giantswarm-catalog $ helm repo add giantswarm-playground https://giantswarm.github.io/giantswarm-playground-catalog $ helm repo update</span></pre><p id="60db" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要安装就绪舵图，只需运行:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="758a" class="mg ku iq mc b gy mh mi l mj mk">helm install --name gs-todo --namespace todo --version 0.2.7 giantswarm-playground/giantswarm-todo-app</span></pre><p id="0999" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，你可以继续<a class="ae lw" href="https://docs.google.com/document/d/19HTvYdJGYPIlIObBkdysu8xlt8NSWmTaIJuMSQUSpaM/edit?ts=5e68cd44#heading=h.m3toh7l0pqxw" rel="noopener ugc nofollow" target="_blank">关于运营和收益的部分。</a></p><h1 id="898a" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">长版本</h1><p id="4101" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在为我们的应用程序准备部署清单时，我们将使用在<a class="ae lw" href="https://www.giantswarm.io/blog/how-the-cloud-native-stack-helps-writing-minimal-microservices/" rel="noopener ugc nofollow" target="_blank">第1部分:Kubernetes平台</a>中介绍的标准Kubernetes组件。为了简单起见，我们将它们打包成一个舵图，并在这个过程中添加MySQL作为依赖项。</p><p id="36fd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您还没有签出我们教程的存储库，请执行以下步骤:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="15b2" class="mg ku iq mc b gy mh mi l mj mk">git clone https://github.com/giantswarm/giantswarm-todo-app.git cd giantswarm-todo-app git checkout blog_v1'</span></pre><h1 id="ab93" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">部署概述</h1><p id="211a" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">让我们看看我们想要创建的内容:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/2ba2b9070ac31c03c98f10a815864fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/0*1llzS4rkSPryh4e_.png"/></div></figure><p id="1510" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Helm chart只是一组Kubernetes资源，所以我们需要从Kubernetes基本构件开始。上图显示了我们必须在“todo”名称空间中创建的主要组件。基本上，它们包括我们的微服务应用程序的“apiserver”和“todomanager”组件的“部署”,以及每个组件的“服务”,作为访问pod的负载平衡器。</p><p id="2f29" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">MySQL部分将由组成舵图表提供。创建掌舵图时，您可以指向其他掌舵图，作为您正在创建的图表的要求。为此，我们将使用<a class="ae lw" href="https://github.com/helm/charts/tree/master/stable/mysql" rel="noopener ugc nofollow" target="_blank">公共MySQL图表</a>，避免自己编写这一部分。</p><p id="51b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上图还显示了部署到“loki”和“linkerd”名称空间的一些软件。当我们在教程的第1部分的<a class="ae lw" href="https://www.giantswarm.io/blog/how-the-cloud-native-stack-helps-writing-minimal-microservices/" rel="noopener ugc nofollow" target="_blank">中部署洛基和带头盔的林克德时，这些已经为我们创建好了。不过，这里是一个好地方，可以让我们再看一看那里部署了什么。</a></p><p id="910c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">洛基图表部署了两件事:</p><ul class=""><li id="5c25" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">"洛基状态集"</li><li id="60e4" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">“Promtail daemonset”</li></ul><p id="1fe9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将运行实际的Loki服务器，该服务器存储日志并响应日志查询。“<a class="ae lw" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank"> Statefulset </a>”是一个类似于部署的Kubernetes工具，但旨在运行有状态的工作负载。</p><p id="b429" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将运行Promtail工具，该工具在Kubernetes集群的每个主机上启动(这就是<a class="ae lw" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" rel="noopener ugc nofollow" target="_blank"> DaemonSet </a>所做的)。该工具跟踪特定集群节点上运行的pods所写的所有日志，并将它们转发到Loki服务器进行存储。</p><p id="670e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Linkerd图表部署了多种Linkerd服务，让我们仅列出对我们最重要的服务:</p><ul class=""><li id="086a" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">"链接器部署"</li><li id="6793" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">《普罗米修斯》</li><li id="0d1c" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">“格拉法纳”</li></ul><p id="dcc3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这实际上是一整个系列的部署，但重要的是“linkerd-proxy-injector”(图中没有直接显示)。可以想象，为了使Linkerd能够跟踪指向我们服务的每个请求，它需要在运行我们应用程序的容器前面使用一个代理。它通过将一个名为“linkerd-proxy”的新容器动态注入到为我们的应用程序部署的每个pods中来实现这一点。由于Pod是一组一起运行的容器，这非常适合Kubernetes的部署单元。在pod内部，“linkerd-proxy”充当Pod的其他容器的所有传入和传出流量的代理，并将流量信息转发给名称空间中运行的其他linkerd服务。</p><p id="825c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是我们故事中隐藏的英雄。Prometheus 是metrics server，它现在是在Kubernetes集群中收集和分析指标数据的事实标准。Linkerd使用它来获取和存储所有的监控指标。普罗米修斯现在隐藏在我们的教程中，但我们稍后会回来，给它更多的关注。</p><p id="3de3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们已经看到Grafana是我们的web UI，用于查看来自两个来源的数据:用于度量的Prometheus服务器和用于日志的Loki。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><a href="https://www.giantswarm.io/guide-cloud-native-stack?utm_campaign=Blog%20CTA%20Conversion&amp;utm_source=Cloud%20native%20stack%20guide_Blog&amp;utm_medium=Blog%20CTA&amp;utm_term=cloud%20native%20stack%20guide"><div class="gh gi na"><img src="../Images/d7568fdff4f24d79424f0759e0f34959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ryllQrb5CO5mmyUE.jpg"/></div></a></figure><h1 id="a88c" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创建“待办事项”图表</h1><p id="7e2e" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">该图表的全部源代码可在“<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/tree/blog_v1/helm/giantswarm-todo-app" rel="noopener ugc nofollow" target="_blank"> helm/giantswarm-todo-app </a>”目录下获得。“<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/helm/giantswarm-todo-app/Chart.yaml" rel="noopener ugc nofollow" target="_blank"> Chart.yaml </a>”描述的是掌舵图本身。“<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/helm/giantswarm-todo-app/requirements.yaml" rel="noopener ugc nofollow" target="_blank"> requirements.yaml </a>”列出了我们想要使用的附加子图表。在我们的例子中，它是“mysql”，一个我们下载并放在“<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/tree/blog_v1/helm/giantswarm-todo-app/charts/mysql" rel="noopener ugc nofollow" target="_blank"> charts/ </a>”目录中的<a class="ae lw" href="https://github.com/helm/charts/tree/master/stable/mysql" rel="noopener ugc nofollow" target="_blank">外部公共图表</a>，这意味着子图表。</p><p id="a804" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后一个顶层文件是“<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/helm/giantswarm-todo-app/values.yaml" rel="noopener ugc nofollow" target="_blank"> values.yaml </a>”，其中包含了Helm用户可以更改的模板变量。我们的实际部署清单放在“<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/tree/blog_v1/helm/giantswarm-todo-app/templates" rel="noopener ugc nofollow" target="_blank"> templates/ </a>”目录中。我不会写其中的每一个细节，但让我指出一些有趣的片段。</p><p id="32b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“templates/”目录中的一些文件更具有全局特性。剩下的要么是关于“apiserver”的，要么是关于“todomanager”的。全球性的有:</p><ul class=""><li id="e429" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated"><a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/helm/giantswarm-todo-app/templates/hook-pre-install-annotate-namespace.yaml" rel="noopener ugc nofollow" target="_blank">Hook-pre-install-annotate-namespace . YAML</a>用于将“linkerd.io/inject=enabled”注释添加到我们部署应用程序的名称空间中。当命名空间以这种方式注释时，linkerd将自动处理命名空间中的所有pod，并注入Linkerd工作所需的“linkerd-proxy”容器。</li><li id="53e1" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated"><a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/helm/giantswarm-todo-app/templates/mysql_networkpolicy.yaml" rel="noopener ugc nofollow" target="_blank"> Mysql_networkpolicy.yaml </a>提供了一个网络策略，允许“todomanager”与“Mysql”建立连接。由于我们正在为所有组件创建网络策略，我们必须记住mysql是作为子图表包含在内的，否则我们的pods将根本无法连接到“MySQL”。</li><li id="9292" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated"><a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/helm/giantswarm-todo-app/templates/psp.yaml" rel="noopener ugc nofollow" target="_blank"> Psp.yaml </a>定义了我们的pod安全策略。这使得我们的应用程序与提供严格安全性和强制PSP存在的集群兼容(giantswarm集群就是这么做的)。我们的策略拒绝使用特权容器或与主机共享名称空间，但是因为我们使用Linkerd，所以我们必须允许一些许可选项。这是因为Linkerd实际上向我们的pod注入了额外的容器，所以我们的pod需要能够完成Linkerd要求的事情。这就是为什么我们在<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/helm/giantswarm-todo-app/templates/psp.yaml#L15" rel="noopener ugc nofollow" target="_blank">第15–17行</a>中启用了一些“NET_*”功能，以及为什么我们允许容器中的进程以root身份运行，但前提是启用了Linkerd(<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/helm/giantswarm-todo-app/templates/psp.yaml#L37" rel="noopener ugc nofollow" target="_blank">L36–40</a>)。</li><li id="3a3f" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated"><a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/helm/giantswarm-todo-app/templates/rbac.yaml" rel="noopener ugc nofollow" target="_blank"> Rbac.yaml </a>配置我们的pods访问Kubernetes API所需的权限。在我们的应用程序中没有任何这样的需求，但是我们仍然需要允许我们的pods使用我们在psp.yaml中创建的PSP ( <a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/helm/giantswarm-todo-app/templates/rbac.yaml#L14" rel="noopener ugc nofollow" target="_blank"> L14 </a>)。</li></ul><p id="b13a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，“apiserver”和“todomanager”非常相似，它们的基本构建块是一个部署和服务，它们放在各自的文件中，带有“apiserver_”或“todomanager_”前缀。让我们以“apiserver”为例指出一些事情:</p><ul class=""><li id="fd3c" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">在"<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/helm/giantswarm-todo-app/templates/apiserver_deployment.yaml" rel="noopener ugc nofollow" target="_blank">API server _ deployment . YAML</a>"中，我们记得设置了一些重要的东西:</li><li id="db6e" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated"><a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/helm/giantswarm-todo-app/templates/apiserver_networkpolicy.yaml" rel="noopener ugc nofollow" target="_blank">“API server _ network policy . YAML</a>”定义了我们的应用防火墙。默认策略是“拒绝”，但是通过apiserver，我们允许任何传入流量到达端口8080(<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/helm/giantswarm-todo-app/templates/apiserver_networkpolicy.yaml#L15" rel="noopener ugc nofollow" target="_blank">L15–21</a>)，以及传出流量到达“todo manager”(<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/helm/giantswarm-todo-app/templates/apiserver_networkpolicy.yaml#L24" rel="noopener ugc nofollow" target="_blank">L24–31</a>)。此外，我们允许与集群的DNS ( <a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/helm/giantswarm-todo-app/templates/apiserver_networkpolicy.yaml#L33" rel="noopener ugc nofollow" target="_blank"> L33 </a>)和Linkerd的服务(<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/helm/giantswarm-todo-app/templates/apiserver_networkpolicy.yaml#L23" rel="noopener ugc nofollow" target="_blank"> L23 </a>和<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/helm/giantswarm-todo-app/templates/apiserver_networkpolicy.yaml#L35" rel="noopener ugc nofollow" target="_blank"> L35 </a>)进行对话。“Todomanager”更受限制，只允许从“apiserver”接收流量，向“mysql”发送流量。</li><li id="3cd6" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated"><a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/blog_v1/helm/giantswarm-todo-app/templates/apiserver_poddisruptionbudget.yaml" rel="noopener ugc nofollow" target="_blank">“API server _ pod disruption budget . YAML</a>”提供了我们的<a class="ae lw" href="https://kubernetes.io/docs/tasks/run-application/configure-pdb/" rel="noopener ugc nofollow" target="_blank"> pod中断预算</a>——关于我们预计有多少pod在运行的集群信息，即使集群中正在进行一些维护工作，如节点更换。在我们的例子中，我们要求至少有2个pod一直运行(<a class="ae lw" href="https://github.com/giantswarm/giantswarm-todo-app/blob/4a78dbc3c544b6a3ee7081b19d5600c4eba5aae4/helm/giantswarm-todo-app/templates/apiserver_poddisruptionbudget.yaml#L10" rel="noopener ugc nofollow" target="_blank"> L10 </a>)。</li></ul><p id="e09f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在所有的部分都准备好了，我们几乎可以将我们的应用程序部署到Kubernetes集群了。不幸的是，我们不得不保留我们的默认图表文件，以便它们可以被我们的CI/CD管道使用，该管道发布公共图像和图表，如<a class="ae lw" href="https://app.hubspot.com/compose/430224/blog-post/909977#h.2lmwh5fp2bhd" rel="noopener ugc nofollow" target="_blank">简短版本</a>中所述。这使得它们不能被头盔直接使用。因此，为了让它与github存储库中默认的代码一起工作，我们需要编辑两个文件。为了使它变得更容易，存储库包含有必要更改的文件，您只需要替换它们就可以在您的本地minikube集群上使用我们的helm chart。</p><p id="3254" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">副本:</p><ul class=""><li id="247e" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">" helm/local_chart/Chart.yaml "到" helm/giants warm-todo-app/chart . YAML "</li><li id="f547" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">“helm/local_chart/values.yaml”到“helm/giants warm-todo-app/values . YAML”。</li></ul><p id="6b82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们的舵图准备好了，我们可以部署它:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="53c8" class="mg ku iq mc b gy mh mi l mj mk">helm install --name gs-todo --namespace todo ./helm/giantswarm-todo-app</span></pre><p id="e3ea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们首先列出我们的头盔版本:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ae36" class="mg ku iq mc b gy mh mi l mj mk">helm list</span></pre><p id="8bf9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们检查一下是否一切正常:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="335e" class="mg ku iq mc b gy mh mi l mj mk">kubectl -n todo get pods</span></pre><p id="142e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">几分钟后，您应该会在“Ready”列中看到所有pod“Running”和“2/2”。您可能还记得，我们在每个pod中只有一个容器，但是Linkerd注入了另一个容器“linkerd-proxy”，所以我们在每个Pod中得到两个容器和“2/2”Pod状态。</p><p id="8f20" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在第4部分中，我们将看到我们的应用程序和云原生栈的运行！敬请关注。</p><h1 id="130e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">关于巨型蜂群</h1><p id="4367" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">当在生产环境中运行Kubernetes集群时，您会意识到您将需要更多，有时甚至更多，而不仅仅是一个集群。您不仅需要关心部署，还需要关心升级、安全问题和监控。</p><p id="ec57" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是Giant Swarm可以提供帮助的地方——我们提供托管的Kubernetes集群，因此您不必担心自己管理它们。我们还提供托管应用，即众所周知的云原生项目，我们可以在您的Kubernetes集群上为您运行这些项目，从而创建一个完全托管的云原生平台。</p><p id="d129" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由<a class="ae lw" href="https://twitter.com/piontec" rel="noopener ugc nofollow" target="_blank">尤卡兹·piątkowski</a>:<strong class="jw ir"/>kubernetes平台架构师@ <a class="ae lw" href="https://twitter.com/giantswarm" rel="noopener ugc nofollow" target="_blank">巨型蜂群</a>撰写</p></div></div>    
</body>
</html>