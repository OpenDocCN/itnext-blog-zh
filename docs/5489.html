<html>
<head>
<title>Composing functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript编写函数</h1>
<blockquote>原文：<a href="https://itnext.io/composing-functions-in-javascript-48830f31c142?source=collection_archive---------5-----------------------#2021-03-16">https://itnext.io/composing-functions-in-javascript-48830f31c142?source=collection_archive---------5-----------------------#2021-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cb1a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">采用函数式编程方法实现JavaScript中的管道函数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/104a80dc27fa644c848f75436ca9f9e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ekdhwFgsq-2uCztgSe90w.png"/></div></div></figure><p id="544d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">从我的</em> <a class="ae lo" href="https://dev.to/webit/composing-functions-in-javascript-32dl" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> dev .交叉发布到标题相同的</em> </a> <em class="ln">文章。</em></p><p id="8e46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最近我在Medium上读到一篇关于在JavaScript 中使用<a class="ae lo" href="https://betterprogramming.pub/whats-a-pipeline-style-in-javascript-2084b66133f0" rel="noopener ugc nofollow" target="_blank">管道风格的文章。有一篇文章描述了如何通过管道将函数连接在一起，从而让数据流经所有函数。<br/>我在本文中错过的是函数式编程的味道。让我们更进一步，增加一些FP的味道。</a></p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="e620" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">在*nix shell中使用管道</h1><p id="8093" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">想象一下<code class="fe mt mu mv mw b">*nix</code>命令行，我们想要在某个目录中找到所有的<code class="fe mt mu mv mw b">index.js</code>文件。当我们将得到一个文件列表时，我们希望对它们进行计数。假设我们把源代码放在了<code class="fe mt mu mv mw b">src/</code>里面。<br/>这是一个简单的例子，但是解释了我们如何在*nix shell中使用管道命令(使用<code class="fe mt mu mv mw b">|</code>)来传递数据。</p><p id="e15e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了实现我们想要的，我们必须执行以下命令:</p><pre class="kg kh ki kj gt mx mw my mz aw na bi"><span id="c4e8" class="nb lx iq mw b gy nc nd l ne nf">tree src/ | grep index.js | wc -l</span></pre><p id="11fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中:</p><p id="e40f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">- <code class="fe mt mu mv mw b">tree</code>递归地列出目录(在本例中，我将其限制为<code class="fe mt mu mv mw b">src/</code>目录)<br/> - <code class="fe mt mu mv mw b">grep</code>用于过滤具有所提供模式的结果(单行)——我们只需要包含<code class="fe mt mu mv mw b">index.js</code>-<br/>-<code class="fe mt mu mv mw b">wc</code>(字数)的行返回换行数、字数和字节数。与<code class="fe mt mu mv mw b">-l</code>一起使用只返回第一个值，所以我们的<code class="fe mt mu mv mw b">index.js</code>被找到的次数</p><p id="fb39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面命令的示例输出可以是任何数字，在我的例子中是26。</p><p id="6fd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在这里看到的是数据如何从一个命令传递到另一个命令。第一个命令处理输入数据，并将数据返回给第二个命令。依此类推，直到我们到达最后—然后显示最后一个命令返回的数据。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="b7cb" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">在JavaScript中使用管道</h1><p id="a9ae" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们可以用JavaScript实现类似的事情。首先，让我们构建一个函数，用于模仿shell命令的特定目的。</p><pre class="kg kh ki kj gt mx mw my mz aw na bi"><span id="2fb0" class="nb lx iq mw b gy nc nd l ne nf">// node’s execSync allows us to execute shell command<br/>const { execSync } = require('child_process');</span><span id="ae77" class="nb lx iq mw b gy ng nd l ne nf">// readFiles = String =&gt; Buffer<br/>const readFiles = (path = "") =&gt; execSync(`tree ${path}`);<br/>// bufferToString = Buffer =&gt; String<br/>const bufferToString = buffer =&gt; buffer.toString();<br/>// makeFilesList = String =&gt; Array<br/>const makeFilesList = files =&gt; files.split("\n");<br/>// isIndex = String =&gt; Boolean<br/>const isIndexFile = file =&gt; file.indexOf("index.js") &gt; 0;<br/>// findIndexFiles = Array =&gt; Array<br/>const findIndexFiles = files =&gt; files.filter(isIndexFile);<br/>// countIndexFiles = Array =&gt; Number<br/>const countIndexFiles = files =&gt; files.length;</span></pre><p id="b4ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看目前为止我们得到了什么:</p><p id="f23d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">- <code class="fe mt mu mv mw b">readFiles()</code>函数为提供的<code class="fe mt mu mv mw b">path</code>或在我们的JS文件被执行的位置执行<code class="fe mt mu mv mw b">tree</code>命令。函数返回缓冲区<br/> - <code class="fe mt mu mv mw b">bufferToString()</code>函数将缓冲区数据转换为字符串<br/> - <code class="fe mt mu mv mw b">makeFilesList()</code>函数将接收到的字符串转换为数组，使每一行文本都成为单独的数组元素<br/> - <code class="fe mt mu mv mw b">isIndexFile()</code>函数检查提供的文本是否包含<code class="fe mt mu mv mw b">index.js</code>-<code class="fe mt mu mv mw b">findIndexFiles()</code>函数过滤数组并返回只包含<code class="fe mt mu mv mw b">index.js</code>条目的新数组(内部使用<code class="fe mt mu mv mw b">isIndexFile()</code>函数)<br/> - <code class="fe mt mu mv mw b">countIndexFiles()</code>函数只对提供的数组中的元素进行计数</p><p id="89d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们得到了JavaScript实现的所有部分。但是怎么做呢？<br/>我们将使用<em class="ln">函数组合</em>，这里的关键是使用<em class="ln">一元函数</em>。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="173c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">功能组成</h1><p id="f53f" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated"><strong class="kt ir">一元函数</strong>是只接收<em class="ln">一个参数</em>的函数。</p><p id="41ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为它们接受一个参数，我们可以把它们连接起来，创建一个新的函数。这种技术叫做<strong class="kt ir">功能组合</strong>。然后，一个函数返回的数据被用作另一个函数的输入。</p><p id="4640" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以使用<code class="fe mt mu mv mw b">compose</code>函数，你可以在流行的函数式编程库<a class="ae lo" href="https://ramdajs.com/docs/#compose" rel="noopener ugc nofollow" target="_blank"> Ramda </a>中找到。让我们看看如何做到这一点…</p><pre class="kg kh ki kj gt mx mw my mz aw na bi"><span id="403c" class="nb lx iq mw b gy nc nd l ne nf">// returns function that accepts path parameter passed to<br/>// readFiles()</span><span id="e71f" class="nb lx iq mw b gy ng nd l ne nf">const countIndexFiles = R.compose(<br/> countIndexFiles,<br/> findIndexFiles,<br/> makeFilesList,<br/> bufferToString,<br/> readFiles);</span><span id="66cb" class="nb lx iq mw b gy ng nd l ne nf">const countIndexes = countIndexFiles("src/");</span><span id="5992" class="nb lx iq mw b gy ng nd l ne nf">console.log(`Number of index.js files found: ${countIndexes}`);</span></pre><p id="2307" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:我们甚至可以不使用<code class="fe mt mu mv mw b">compose</code>函数来构造函数(但我认为这样可读性较差):</p><pre class="kg kh ki kj gt mx mw my mz aw na bi"><span id="af6a" class="nb lx iq mw b gy nc nd l ne nf">const countIndexes = countIndexFiles(findIndexFiles(makeFilesList(bufferToString(readFiles("src/")))));</span><span id="858d" class="nb lx iq mw b gy ng nd l ne nf">console.log(`Number of index.js files found: ${countIndexes}`);</span></pre><p id="892f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，函数组合允许我们加入函数，而不用担心处理它们之间的数据。以下是我们在不使用合成的情况下必须做的事情:</p><pre class="kg kh ki kj gt mx mw my mz aw na bi"><span id="a0ae" class="nb lx iq mw b gy nc nd l ne nf">const filesBuf = readFiles("src/");<br/>const filesStr = bufferToString(filesBuf);<br/>const filesList = makeFilesList(filesStr);<br/>const indexFiles = findIndexFiles(filesList);<br/>const countIndexes = countIndexFiles(indexFiles);</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="10d8" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">合成与管道</h1><p id="fd1a" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">正如你可能已经注意到的，当使用<code class="fe mt mu mv mw b">compose</code>时，我们需要以相反的顺序传递函数(<em class="ln">从下到上</em>)。<br/>按照<em class="ln">从上到下</em>的顺序阅读更容易。这就是<code class="fe mt mu mv mw b">pipe</code>的用武之地。它执行与<code class="fe mt mu mv mw b">compose</code>相同的操作，但以相反的顺序接受功能。</p><pre class="kg kh ki kj gt mx mw my mz aw na bi"><span id="3438" class="nb lx iq mw b gy nc nd l ne nf">// NOTE even though not takes functions list in reverse order <br/>// it still accepts path parameter passed to readFiles()</span><span id="5731" class="nb lx iq mw b gy ng nd l ne nf">const countIndexFiles = R.pipe(<br/> readFiles,<br/> bufferToString,<br/> makeFilesList,<br/> findIndexFiles,<br/> countIndexFiles);</span><span id="a2f7" class="nb lx iq mw b gy ng nd l ne nf">const countIndexes = countIndexFiles("src/");</span><span id="4837" class="nb lx iq mw b gy ng nd l ne nf">console.log(`Number of index.js files found: ${countIndexes}`); // same result as before 🙌</span></pre><p id="a16d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这取决于我们将使用哪一种方法— <code class="fe mt mu mv mw b">compose</code>或<code class="fe mt mu mv mw b">pipe</code>。试着用一种你(和你的同事)感觉更好的方式。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h2 id="dca9" class="nb lx iq bd ly nh ni dn mc nj nk dp mg la nl nm mi le nn no mk li np nq mm nr bi translated">奖励:使用拉姆达给你的全部力量</h2><p id="965c" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们可以使用其他Ramda方法来进一步缩短我们的代码。这是因为默认情况下，所有的Ramda函数都是<strong class="kt ir">化的</strong>，并且带有“数据最后”的风格。<br/>这意味着我们可以在提供数据之前对它们进行配置。例如,<code class="fe mt mu mv mw b">R.split</code>创建了一个新函数，通过提供的分隔符来分割文本。但是它等待一个文本被传递:</p><pre class="kg kh ki kj gt mx mw my mz aw na bi"><span id="221c" class="nb lx iq mw b gy nc nd l ne nf">const ipAddress = "127.0.0.1";<br/>const ipAddressParts = R.split("."); // -&gt; function accepting string</span><span id="3051" class="nb lx iq mw b gy ng nd l ne nf">console.log(ipAddressParts(ipAddress)); <br/>// -&gt; [ ‘127’, ‘0’, ‘0’, ‘1’ ]</span></pre><p id="bfcc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">足够的理论👨‍🎓<br/>让我们看看我们的代码最终会是什么样子(更像FP风格):</p><pre class="kg kh ki kj gt mx mw my mz aw na bi"><span id="94a5" class="nb lx iq mw b gy nc nd l ne nf">const { execSync } = require("child_process");<br/>const R = require("ramda");</span><span id="5db8" class="nb lx iq mw b gy ng nd l ne nf">// readFiles = String =&gt; Buffer<br/>const readFiles = (path = "") =&gt; execSync(`tree ${path}`);<br/>// bufferToString = Buffer =&gt; String<br/>const bufferToString = buffer =&gt; buffer.toString();<br/>// isIndex = String =&gt; Boolean<br/>const isIndexFile = file =&gt; file.indexOf("index.js") &gt; 0;</span><span id="47b1" class="nb lx iq mw b gy ng nd l ne nf">const countIndexFiles = R.pipe(<br/> readFiles,<br/> bufferToString,<br/> R.split(“\n”),<br/> R.filter(isIndexFile),<br/> R.length);</span><span id="c304" class="nb lx iq mw b gy ng nd l ne nf">const countIndexes = countIndexFiles("src/");</span><span id="451c" class="nb lx iq mw b gy ng nd l ne nf">console.log(`Number of index.js files found: ${countIndexes}`);</span></pre></div></div>    
</body>
</html>