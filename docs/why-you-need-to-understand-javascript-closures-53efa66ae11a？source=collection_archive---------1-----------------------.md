# JavaScript 闭包、记忆化和工厂

> 原文：<https://itnext.io/why-you-need-to-understand-javascript-closures-53efa66ae11a?source=collection_archive---------1----------------------->

![](img/cd731d929bd594d412cbc27594a03d2e.png)

> 闭包是函数和词法环境的组合，函数在词法环境中被声明 [](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) 。

我能想到的最简单的结尾

# 那里发生了什么？

如果你像其他人一样，认为第 12 行将返回 3，那么这篇文章可能会对你有一点帮助。发生的情况是，每次我们调用`count()`时，我们都返回一个新的`innerCount`函数副本，而每个`innerCount`副本都依赖于它自身之外的数据，在它自己的作用域之外。

这个*环境*数据对于函数本身的执行是至关重要的。我们可以说，它依靠它来工作。如果，当我们运行`innerCount`时，我们不能访问`counter`，那么整个功能将被破坏！但是到了执行`innerCount`的时候，`counter`就不再是外界可以访问的了！

JavaScript 来帮忙了，它包装、分组，或者，如果你想说对的话，围绕函数和它需要访问的所有数据创建一个闭包，它的[词法环境](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)。

如果`counter`是全局范围内的一个变量，那么所有的计数器将增加同一个变量，而不是一个闭包内的一个。将`counter`提取到 1 号线以上，随意尝试

# 创建一个函数工厂作为真实世界的例子

我们可以通过创建一个函数来利用闭包行为，该函数根据传递的参数返回一个具有不同执行逻辑的函数。我能想到的最简单的例子是一个将返回给定数字的 *n* 的幂的工厂。结果将与调用`Math.pow(subject, power)`相同

最简单的功能工厂

这个代码片段所做的是创建一个动态函数*，本质上这个函数的算法不是在代码本身中显式定义的，而是在运行时使用传递给工厂的参数创建的。当然，对于前面的例子，你可能会认为它毫无用处，你是对的，但是你需要抓住的是这个功能的潜力。*

*我们现在可以通过简单地调用`var powerOf2 = powerOfNFactory(2)`来定义一个函数，该函数给出 2 的幂。内部`generatedFunction` **将保持对** `**power**` **变量**的封闭，并将完全独立于对`powerOfNFactory`的其他调用。这意味着我们可以**扩展功能**并做一些事情，例如跟踪我们的动态函数被调用的次数，添加*内存化*(缓存结果以防止用相同的参数调用时重复执行)等等。*

## *添加计数器*

*就像我们的动态函数可以访问传递给工厂函数的参数一样，它也可以访问内部定义的任何东西，就像第一个例子中的计数器一样，允许我们定义一个简单的计数器，这样就可以跟踪我们调用它的次数。也许您希望这样做是为了记录日志，也许您希望在做其他事情之前限制某个功能的执行次数，这取决于您。*

*我们为动态函数保留了一个内部计数器*

## *记忆化*

*由于在我们的函数中执行的代码在时间上并不昂贵，我们不应该担心缓存它的执行，但在这里更容易显示它，这将是一个更广泛的例子，对我来说如此赤裸。这对于用相同的参数调用时总是返回相同的值，但在执行时间方面占用更多资源的操作非常有用*

*我们保留一个内部对象作为字典缓存*

*注意，我们在动态函数定义之外定义了一个`cache`变量，就像我们对`counter`所做的一样。当调用动态函数并存储值时，我们将使用作为参数接收的键填充该对象，以便跳过执行`Math.pow(subject, power)`。*

# *摘要*

*我确信，到现在为止，或者至少我希望如此，您已经对闭包有了更好的理解，以及它们有什么用处。这是我们不应该害怕的事情，一旦你理解了它们，以及它们为什么以这种方式工作，你就可以开始利用它们带来的全部潜力。*