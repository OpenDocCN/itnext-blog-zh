<html>
<head>
<title>How I build a desktop chat app with CometChat and NW.js (and how you can too)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何用CometChat和NW.js构建一个桌面聊天应用程序(你也可以)</h1>
<blockquote>原文：<a href="https://itnext.io/how-i-build-a-desktop-chat-app-with-cometchat-and-nw-js-and-how-you-can-too-fb03cb685c0d?source=collection_archive---------2-----------------------#2019-09-22">https://itnext.io/how-i-build-a-desktop-chat-app-with-cometchat-and-nw-js-and-how-you-can-too-fb03cb685c0d?source=collection_archive---------2-----------------------#2019-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d3dfb43a53d7588b2916d12b2d40e270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*U9bmDxD3rDwp9ic_.png"/></div></figure><p id="46a3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这不是你典型的“<em class="ks">贴这个贴这个</em>”和“<em class="ks">贴那个贴那个</em>”式的教程(你可以在【cometchat.com/tutorials】的这里找到很多)。虽然这些教程肯定有价值，但我将从头到尾分享我的思考过程。</p></div><div class="ab cl ku kv hu kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ij ik il im in"><p id="aad0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我构建的应用程序非常简单。当有人加载应用程序时，系统会提示他们输入用户名并开始聊天:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/ef13fbb004b6e62531c0c3c99e9d054a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*ZTfdGRKfalLDv19t.png"/></div></figure><p id="df15" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在NW.js(以前称为node-webkit)的帮助下，应用程序最终在Node上运行。NW.js是有利的，因为它使我们能够使用我们最喜欢的web技术编写跨平台的桌面应用程序。对于这个应用程序，我选择使用React和Redux。</p><p id="3073" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">后端逻辑——从实时发送和接收消息到填充我所谓的“参与者列表”——由CometChat提供支持。继续阅读，你会了解更多关于CometChat 的信息。</p><p id="f5fe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这篇文章并不打算作为一个演练。虽然我将解释这个应用程序的技术组件，但我的主要目标是帮助您从头到尾考虑一个解决方案。希望当你完成这篇文章的时候，你会成为一个稍微好一点的开发者，并考虑将CometChat作为你成长的工具带。</p><h1 id="6b7f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">只想要示例代码？</h1><p id="721e" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">你可以在这里看到源代码<a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw" rel="noopener ugc nofollow" target="_blank"/>。还有一个详细的<a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>，在这里你会找到安装、运行和测试应用所需的所有信息。</p><p id="52db" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为桌面应用程序是使用web技术构建的，所以完全可以在浏览器中运行。在这篇文章的最后，我将向您展示如何在Netlify上部署这个应用程序。</p><h1 id="712a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">规划</h1><p id="27f2" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">在这一部分，我们必须决定需要构建哪些组件。它们将具有什么功能？换句话说，我们需要回答什么问题来计划建造过程？</p><p id="bcc1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们退一步想一想。试着问自己这样的问题，谁会带我们找到应用程序所需的结构。</p><p id="4565" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面我将列出我的问题和答案。这是实际构建应用程序结构的过程，但首先是在你的头脑中。请记住，这种情况经常发生，当回答一个问题时，会出现新的问题。我也是如此。</p><p id="41b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">问题:</strong></p><ul class=""><li id="98af" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated">我在做什么？😆</li><li id="a86d" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">我要构建什么样的应用程序？</li><li id="30b6" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">这样的app需要具备哪些最常见的组件？</li><li id="cd54" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">app的组件之间是如何交互的？</li><li id="f9d3" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">我的目标是什么程度的完成—(演示应用程序不应该是全功能的)？</li></ul><p id="8cff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">答案</strong>(按照问题顺序):</p><ul class=""><li id="ac66" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated">这是很多人忘记思考的最容易被忽视的问题。<em class="ks">当一个人能够先靠边站，给这个问题一个明确的答案时，他未来的发展道路就已经确定了</em>。在我的具体案例中，我得到的答案听起来像这样——“我正在考虑开发一个聊天应用。这个应用程序应该作为一个教程演示应用程序。它必须通过使用CometChat API提供“聊天”的基本功能。它应该在桌面上运行”。样式和关于什么去哪里的具体细节将在后面的过程中出现。</li><li id="3556" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">一个聊天应用程序，将在桌面上运行，并作为本教程的演示。</li><li id="ce1a" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">为了给这个问题一个正确的答案，一个不熟悉的人必须先做一些研究。看看现实世界中的聊天应用程序。记下他们的特点。他们如何把它们放在适当的位置，他们之间以及与应用程序用户之间如何互动。就我而言，我有一些<a class="ae kt" href="https://mihail-gaberov.eu/how-i-build-chat-app-with-react-and-typescript-part1/" rel="noopener ugc nofollow" target="_blank">以前的经验</a>，并且或多或少知道我需要什么。</li><li id="0b25" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">组件之间的交互非常简单。用户应该能够使用主要组件，即文本输入和按钮来发送消息。和侧边栏组件来查看其他聊天参与者。</li><li id="2876" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">演示应用程序应该提供基本的聊天功能——发送和接收实时消息。并且能够在桌面上运行(没有浏览器)。</li></ul><h1 id="2f26" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">特征</h1><p id="66ae" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">我决定在演示应用中实现以下功能:</p><ul class=""><li id="1ea1" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated">用回车键发送</li><li id="b4e2" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">带有姓名和上次活动时间的侧边栏</li><li id="caf6" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">带有错误消息的输入和验证的欢迎屏幕</li><li id="4be2" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">聊天区自动滚动到底部</li><li id="5dc6" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">聊天信息和发送时间。</li></ul><h1 id="ecbb" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">前端—反应</h1><p id="5d8d" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">我们将使用<a class="ae kt" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>来构建我们的用户界面。下面，我将列出我创建的组件，并对每个组件进行简短说明:</p><ul class=""><li id="2ebc" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated"><a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/tree/master/src/components/ChatPane" rel="noopener ugc nofollow" target="_blank"> ChatPane </a> —这是类似容器的主要组件，包含参与者和对话组件，并传递他们需要可视化的数据。</li><li id="5b01" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/blob/master/src/components/Conversation/Conversation.jsx" rel="noopener ugc nofollow" target="_blank">对话</a> —这是负责输入和发送聊天消息的组件。</li><li id="766d" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/blob/master/src/components/Footer/Footer.jsx" rel="noopener ugc nofollow" target="_blank">页脚</a> —显示一个简单的页脚消息，包含应用程序名称和版本，如package.json文件中所定义。</li><li id="ae3d" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/blob/master/src/components/Header/Header.jsx" rel="noopener ugc nofollow" target="_blank"> Header </a> —保存应用菜单栏的Header组件。</li><li id="93a3" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/blob/master/src/components/MenuAppBar/MenuAppBar.jsx" rel="noopener ugc nofollow" target="_blank"> MenuAppBar </a> —应用菜单栏组件，模拟真实菜单栏的样子。左边的汉堡菜单和右边的个人资料下拉菜单是假的——可以点击，但没有功能。</li><li id="6031" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/blob/master/src/components/Messages/Messages.jsx" rel="noopener ugc nofollow" target="_blank"> Messages </a> —一个容器组件，保存消息本身——它有发送者的名字、消息内容和发送时间。</li><li id="fc5e" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/tree/master/src/components/Participants" rel="noopener ugc nofollow" target="_blank">参与者</a> —这个组件显示一个聊天成员的名字和他加入的时间。</li><li id="933d" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/tree/master/src/components/Welcome" rel="noopener ugc nofollow" target="_blank"> Welcome </a> —该组件负责显示登录页面——我们应用程序的起点，在这里我们有与检查某些允许的用户名相关的逻辑，并将它们存储到本地存储以备后用。我还实现了基本的错误处理逻辑，当选择的用户名不正确时，它会显示一个错误，这是根据CometChat API(在我们的演示中是这个特定的情况)注册的用户名——超级1、超级2等等，直到5。</li></ul><p id="0c84" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里是应用程序组件的可视化表示:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/8ec501dd2743258b82019724fdc487d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*6eBPTO7BwulQf3-b.png"/></div></figure><h1 id="427e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">状态管理— Redux</h1><p id="2914" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">如今，每个现代应用程序都有一个状态。放在应用程序存储某些数据以备后用的内存中。对于我们的应用程序状态管理，我们使用<a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>。当然，对于这样一个简单的应用程序，我们完全可以不使用Redux。但是，从学习的角度来看(<em class="ks">毕竟我们这样做都是为了学习新东西，对吗？</em>)，我觉得如果能看到向API发送请求，经过中间件(redux-thunks)，得到记录到状态的响应的整个循环就好了。我们将使用Redux来管理这种状态。</p><h1 id="a1b6" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">它是如何工作的</h1><p id="0215" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">Redux应用程序中的主要构件被称为reducer——用于管理状态的小函数。简单地说，它们所做的是接受旧的状态对象作为输入，并根据某些动作(也在同一个输入中传递)返回新的状态对象。新的状态可以全部或部分改变。</p><p id="df0b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们的应用程序中，我们有三个简单的reducers，它们负责状态的那些部分，负责用户列表、登录过程和发送/接收消息。所有这些都可以在<a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/tree/master/src/reducers" rel="noopener ugc nofollow" target="_blank"> /src/reducers </a>文件夹中看到，还有一个包含我们应用初始状态的<a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/blob/master/src/reducers/initialState.js" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><p id="02cb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为状态管理库，Redux可以与任何其他UI框架一起使用，实际上每个需要状态的应用程序都可以从使用Redux中受益。如果你想深入了解，可以从他们的网站开始，然后跟着做。</p><h1 id="9799" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">副作用处理— Redux Thunks</h1><p id="008d" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">在redux应用中管理副作用的最著名的方法之一叫做<a class="ae kt" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-think </a>。这也是我们在应用程序中使用的。如果你想了解更多关于redux thunks的细节以及如何使用它们，我推荐你从他们的网站开始，然后构建一个小的应用程序，比如这个:)。</p><p id="fc1b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们的项目中，在<a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/tree/master/src/actions" rel="noopener ugc nofollow" target="_blank"> /src/actions文件夹</a>中，是我放演示应用程序中使用的thunks的地方。并且在<a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/tree/master/src/store" rel="noopener ugc nofollow" target="_blank"> /store </a>目录中是redux store的配置所在的位置。</p><h1 id="ca3e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使其成为桌面— NW.js</h1><p id="c98b" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">我们的应用程序中使我们的应用程序能够在桌面上运行的部分由一个名为<a class="ae kt" href="https://nwjs.io/" rel="noopener ugc nofollow" target="_blank"> NW.js </a>的库负责。记住，我们正在构建一个桌面应用程序。确切地说，桌面部分将通过NW.js来实现。与另一个用于构建桌面应用程序的库<a class="ae kt" href="https://electronjs.org/" rel="noopener ugc nofollow" target="_blank">电子</a>类似，NW.js为开发人员提供了一种使用他们的web技能来构建可以在桌面上运行的应用程序的方法。这意味着在构建应用程序时，您仍然可以使用JavaScript/React技能，然后通过Nw.js APIs利用桌面操作系统的强大功能。换句话说，Nw.js让你有能力制作一个骨架app，它可以“填充”你的UI，不管你用什么库创建的。最棒的是，这样的应用程序可以在相同的JavaScript上下文中访问Node.js/NW.js API和DOM。</p><p id="ec03" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">既然我们提到了构建跨平台桌面应用领域的另一个大玩家，让我给你一个两者之间的简单比较。</p><h1 id="746a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Nw.js vs电子</h1><ul class=""><li id="ac6a" class="mi mj iq jw b jx md kb me kf mw kj mx kn my kr mn mo mp mq bi translated">申请条目</li></ul><p id="fda0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">—在NW.js中，应用程序的主入口点是网页或js脚本。您可以在package.json中指定一个HTML或js文件，它将在浏览器窗口中作为应用程序的主窗口打开(如果是HTML入口点),或者执行脚本。</p><p id="bdb8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">—在electronic中，入口点是一个JavaScript脚本。</p><ul class=""><li id="6914" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated">构建系统</li></ul><p id="71a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">— Nw.js使用铬</p><p id="4c1a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">—电子使用<a class="ae kt" href="https://github.com/electron/libchromiumcontent" rel="noopener ugc nofollow" target="_blank"> libchromiumcontent </a>访问Chromium的内容API。libchromiumcontent是一个单独的共享库，包括Chromium内容模块及其所有依赖项。</p><ul class=""><li id="35ff" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated">节点集成</li></ul><p id="3a50" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">—在NW.js中，网页中的节点集成需要修补Chromium才能工作。</p><p id="2e88" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">— In Electron使用不同的方式将libuv循环与每个平台的消息循环集成在一起，以避免入侵Chromium。</p><ul class=""><li id="222f" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated">多语境</li></ul><p id="bf69" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">—因为NW.js是如何实现的，所以发明了节点上下文和web上下文的概念。</p><p id="016a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">—通过使用Node的<a class="ae kt" href="https://github.com/nodejs/node-v0.x-archive/commit/756b622" rel="noopener ugc nofollow" target="_blank">多上下文</a>特性，Electron不会在网页中引入新的JavaScript上下文。</p><h1 id="211e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">聊天— CometChat</h1><p id="c543" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">CometChat API的用法非常简单。这是一个RESTFull API，在此基础上构建了另一个抽象层——comet chat SDK。它允许我们为我们可能想要执行的不同操作直接调用公开的方法，比如发送。下面是这种方法的一个例子:</p><pre class="lb lc ld le gt mz na nb nc aw nd bi"><span id="1766" class="ne lg iq na b gy nf ng l nh ni">return CometChat.sendMessage(textMessage).then(    <br/>  message =&gt; {      <br/>    console.log("Message sent successfully:", message);      <br/>    return message;<br/>  }, <br/>  error =&gt; {      <br/>    console.log("Message sending failed with error:", error);    <br/>  }<br/>);</span></pre><p id="4c10" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在<a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/tree/master/src/chat-api" rel="noopener ugc nofollow" target="_blank"> /src/chat-api </a>文件夹中看到所有的聊天API逻辑。在那里你还会看到我创建的模拟，它允许我们在没有真正连接到API的情况下测试我们的应用程序。</p><h1 id="7952" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">丰富</h1><p id="18be" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">每个项目在完成第一阶段后都值得思考。这个思考过程的一部分将致力于它是如何进行的，什么是好的和坏的，以及什么可以做得更好。一部分将致力于思考可能的改进。以下是我们案例的一些想法。如果有人真的朝这个方向发展并实现了这些，请不要忘记告诉我:)</p><ul class=""><li id="c641" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated">加载聊天记录和用户列表时的等待动画</li><li id="836f" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">如果已经登录，可以选择跳过登录屏幕</li><li id="92fe" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">向新用户发送邀请的选项</li><li id="506a" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">用于查看消息状态的选项—已发送、已接收、已读</li><li id="935c" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">表情符号支持</li><li id="0519" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">内联链接/图像/视频支持，这样用户可以看到它们被解释——播放视频、渲染图像或链接指向的网页。我在我的GitHub 中添加了这些<a class="ae kt" href="https://github.com/mihailgaberov/desktop-chat-nw/issues" rel="noopener ugc nofollow" target="_blank">问题，如果有人想看的话。</a></li></ul><h1 id="4823" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在网络上部署</h1><p id="b68d" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">要将您的应用程序部署到Netlify平台，您需要首先创建一个帐户。去<a class="ae kt" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank">他们的网站</a>注册新账户。之后，继续登录。仍然在Sites部分下，您应该看到一个从Git部署新站点的按钮。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/18a6bc49a48cdf9d170d93432c0eaf4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/0*bRgJcT3ouG-W87fe.png"/></div></figure><p id="f8c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">单击它并按照步骤从您的GitHub存储库中创建一个新的部署站点。您的过程应该类似于下图所示。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/02cae9f47a8afe853875d89d2f15ff63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*ZIU6k7ux-y75B5GA.png"/></div></figure><p id="e14f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，部署应用程序之前的最后一步是确保您有正确的构建命令和环境变量。要做到这一点，在您创建了用于部署的站点之后，转到<strong class="jw ir">Build&amp;deploy</strong>settings屏幕并输入以下内容(不要忘记使用您的repo URL):</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/b587cb5e08650d6259e77c1f3447930e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*-ppF9uk9HCvqXuTs.png"/></div></figure><p id="6581" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<strong class="jw ir">环境下的</strong>部分是您需要输入在您的。环境文件。这是我的样子:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/f9855eee2ece22550ff17801c46aaaae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*xOfl1HjZjRc3Msc6.png"/></div></figure><p id="ed6e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意:<em class="ks">我已经删除了这些值，因为这应该是私人信息，你也不应该分享你的。</em></p><p id="d0ea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这应该足够让你在Netlify上部署你的应用了。请记住，<strong class="jw ir">部署</strong>的默认设置被设置为“自动发布”，这意味着它将在您对repo中的<strong class="jw ir">主分支</strong>执行的每次提交时触发部署。这也是您可以手动触发部署的地方。这是我的<strong class="jw ir">部署</strong>屏幕的样子:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6e2a616af3b4f622b3314795fc218af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*ZWH669TC-yyTYrxp.png"/></div></figure><h1 id="31a2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="9af0" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">在本教程中，我们看到了如何利用我们的web开发技能来创建可以在桌面上运行的应用程序。我们构建的是一个演示应用程序，它缺少许多功能齐全的生产就绪应用程序功能，但当人们想要学习和分享时，这将完成工作。如果你想在这个方向上加深你的知识，我建议你通过实现在真实的桌面应用程序中更容易看到的特性来尝试改进它。</p><p id="0987" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那里有很多探索的机会，我希望这篇教程能给你带来足够的乐趣，让你的好奇心更加旺盛。</p><p id="9899" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">🔥感谢阅读！🔥</p><p id="c755" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">备注:</strong></p><ul class=""><li id="0a91" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated">为了使用Nw.js DevTools，您需要安装SDK build—【https://nwjs.io/downloads/】T2—版本0.38.2或更高版本。</li></ul><p id="9f14" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">资源:</strong></p><ul class=""><li id="6fef" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated">问:什么是‘thunk’？答:当你第一次听到redux-thunk时，你的大脑发出的声音。好吧，对不起，太糟糕了。But…daveceddia.com</li><li id="5cf0" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">[书籍]跨平台桌面应用程序:使用Node、Electron和NW.js</li><li id="00de" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">[书籍]跨平台桌面应用开发:Electron、Node、NW.js、React</li><li id="b8a0" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><a class="ae kt" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank">用于Redux的Thunk中间件</a></li><li id="62df" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><a class="ae kt" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html#useref</a></li></ul></div></div>    
</body>
</html>