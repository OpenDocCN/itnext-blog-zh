<html>
<head>
<title>Golang, Microservices and Twirp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang、微服务和Twirp</h1>
<blockquote>原文：<a href="https://itnext.io/golang-microservices-and-twirp-5ef495278ddf?source=collection_archive---------0-----------------------#2021-07-11">https://itnext.io/golang-microservices-and-twirp-5ef495278ddf?source=collection_archive---------0-----------------------#2021-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5351d5c8fb61d125acd6cb625e85040f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nd8kBFJSlRXZ_xezxmrJZg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">CP3在行动</figcaption></figure><p id="700e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇博文中，我想谈谈API，以及在使用微服务时如何设计API。</p><p id="5783" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">先决条件:<br/> 1。<strong class="ke ir">戈朗</strong>——<a class="ae la" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">https://golang.org/doc/install</a>T5】2。<strong class="ke ir"> Protobuf编译器—</strong><a class="ae la" href="https://grpc.io/docs/protoc-installation/" rel="noopener ugc nofollow" target="_blank">https://grpc.io/docs/protoc-installation/</a></p><p id="33f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该项目的源代码可以在<a class="ae la" href="https://github.com/subzero112233/golang-twirp" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><h2 id="922b" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated"><strong class="ak">打碎整块石头</strong></h2><p id="0efd" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">直到最近，构建应用程序的主要方法是创建一个处理多个相关任务的单层且不可分割的单元。这是独石图案。</p><p id="1111" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种模式在当时是最常见的，在很多情况下仍然有效，并且在今天的行业中仍然被广泛使用。</p><p id="f270" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，这种方法有一些缺点:<br/> 1。你的代码库变得巨大<br/> 2。你违反了SRP原则——一个组件应该做一件事，并且做好。<br/> 3。组件是紧密耦合的。<br/> 4。Monoliths在开发和产品运营方面都不能很好地扩展——所有的东西都是在同一块上运行和开发的。<br/> 5。漏洞、数据泄露和安全漏洞的高风险—有安全漏洞吗？你的整个应用程序都受到了影响。</p><p id="d69f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如今，市场迫使你快速行动，打破常规，改变方向，扩大规模，并且不惜一切代价随时待命。<br/>为了满足这些需求，软件行业开始采用一种新的方法——微服务。</p><p id="051a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">微服务允许你拥有一个高度可维护和可测试的软件，它是松散耦合和独立部署的。小团队可以拥有一个或几个微服务，按照自己的节奏开发，使用自己选择的语言和框架。</p><p id="576a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对我来说，整体服务与微服务之争的答案是<strong class="ke ir">视情况而定。我不打算在这个范围内讨论这个问题，但是每个都有它自己的优点和缺点。</strong></p><h1 id="32aa" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated"><strong class="ak">用例</strong></h1><p id="4eb4" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">一家公司有一个<a class="ae la" href="https://en.wikipedia.org/wiki/Software_as_a_service" rel="noopener ugc nofollow" target="_blank"> SaaS </a>的产品，并向用户公开了一个REST API。<br/>产品已经发展壮大，他们目前使用的整体架构已经不再能满足他们的目标:<br/> -交付新功能花费的时间太长了。<br/> -一些组件需要不同的语言来更好地执行。<br/> -另一个组件需要扩展，但它有点小，您不想扩展整个应用程序。<br/>可以有相当多的原因。</p><p id="5951" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以他们决定将整块分成5个微服务和一个队列。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/092c85379daee4fea3b216fbd739cd6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*iluvp45WHG_vOgWaPY1LSQ.png"/></div></figure><p id="1bdb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mv mw mx my b">stats api</code>将从不同种类的源接收请求，请求不同类型的数据。<br/>此外，我们不想给我们的数据库带来太大的压力，所以我们在<code class="fe mv mw mx my b">stats api</code>和<code class="fe mv mw mx my b">stats writer</code>之间放置了一个队列，它将分批写入数据库，每批10个条目。</p><p id="71fd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">其他组件收到诸如“我想比较Devin Booker和Chris Middleton”的请求，因此它们必须从数据库中获取数据并进行一些高级计算。<br/>这种请求是由用户发起的，必须在几秒钟或更短的时间内返回，所以我们必须保持它们同步。</p><h1 id="4d0d" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">好吧，怎么回事？</h1><p id="61a0" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">开发人员和架构师选择RESTful APIs作为服务间通信的方式是很常见的，但是我想解释一下为什么REST可能是我最后选择的选项之一。</p><h2 id="bbc4" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">休息</h2><p id="1c79" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">如今最常见的API实现叫做<a class="ae la" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> REST </strong> </a> <strong class="ke ir">。<br/> </strong> REST是<strong class="ke ir">RE</strong>presentational<strong class="ke ir">S</strong>state<strong class="ke ir">T</strong>transfer的缩写。</p><p id="32f8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">REST依赖于无状态的客户机-服务器协议，其中客户机和服务器完全分离(关注点分离)。<br/>缓存可以用来提高网络效率和性能。</p><p id="7c91" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">REST APIs有一个统一的接口，允许应用程序独立发展，而无需将应用程序的服务、模型和动作与API层紧密耦合。</p><p id="2bc3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">REST APIs也是由约束组件行为的层次结构层组成的，这样每个组件就不能看到它们正在交互的直接层之外的内容。</p><p id="d386" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于这些原因，REST APIs在过去的十年中因其可伸缩性、性能和易用性而广受欢迎，几乎每个人都在使用它们。</p><p id="b6bf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">听起来像是该走的路，对吧？嗯，不一定。</p><h1 id="384b" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">为什么REST APIs不总是正确的选择</h1><h2 id="7d73" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated"><strong class="ak">服务对服务通信</strong></h2><p id="ba26" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">除了面向公众的API，现在的交流完全是内部的，服务对服务，没有人参与。当你有以下情况时，休息是个不错的选择。需要支持不同类型的客户端:浏览器、手机等。<br/> 2。希望你的请求-响应是人类可读的。<br/> 3。需要一个标准的、被广泛采用的接口和消息格式。<br/> 4。需要支持大量的语言和库。</p><p id="2a98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些在这里都不适用或不需要。</p><h2 id="b0d6" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated"><strong class="ak">代码生成</strong></h2><p id="e715" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">REST APIs的代码生成需要您使用第三方工具，并且本身不受支持。例如，当Go中没有用于生成完全兼容的<a class="ae la" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OAS3 </a>客户端的库时，这可能非常有限。</p><h2 id="5c5f" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated"><strong class="ak"> JSON </strong></h2><p id="1306" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">JSON是迄今为止REST APIs最流行的数据格式，但是有几个限制:<br/> a. <strong class="ke ir">无模式</strong>:我们的数据库有模式，我们的代码是以保留模式的方式编写的，那么为什么我们可以接受没有模式的数据格式呢？<br/>* JSON有模式验证器，但它们并不常用，并且作为外部库提供，需要额外的代码。</p><p id="6417" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">b.<strong class="ke ir">速度</strong>:除了用JS编写的浏览器、服务器端等JavaScript原生环境，JSON序列化最多可以比protobuf慢<a class="ae la" href="https://auth0.com/blog/beating-json-performance-with-protobuf" rel="noopener ugc nofollow" target="_blank"> 6倍</a>。<br/>二进制序列化往往比文本序列化更快。</p><p id="971e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">c.<strong class="ke ir">大小:</strong> JSON会产生一个比二进制替代品更大的对象。</p><p id="76bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">c.<strong class="ke ir">额外代码:</strong> JSON需要样板代码来序列化/反序列化数据，但是你写的代码越多，潜在bug的表面就越大。此外，你在浪费时间编写与业务无关的代码。</p><p id="2567" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">e.<strong class="ke ir">数据类型:</strong> JSON只支持有限数量的数据类型:<br/>字符串、数字、布尔、空、对象、数组。</p><p id="5e05" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">f.<strong class="ke ir">向后兼容:</strong> JSON不是向后兼容的。</p><h2 id="de06" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated"><strong class="ak">可维护性:</strong></h2><p id="09db" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">考虑上面的图表，哪种请求方法对获取玩家的数据最有意义</p><pre class="mr ms mt mu gt mz my na nb aw nc bi"><span id="18ce" class="lb lc iq my b gy nd ne l nf ng">POST /stats/:name<br/>PUT /stats/:name</span></pre><p id="40ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">应该发送什么标头、查询参数和/或请求正文？<br/>应该有什么反应？我们如何交流错误？有太多的问题要问，太多的决定要做。</p><p id="1abd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">开发人员可能必须通读API文档，这些文档必须由某个人编写，并且通常还要阅读应用程序的代码，以了解端点实际上是如何工作的。同样，我们不得不花费宝贵的时间。</p><h1 id="6924" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated"><strong class="ak">输入RPC </strong></h1><p id="61db" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">本质上，RPC使一台机器上的程序能够调用连接到网络的另一台机器上的子例程。RPC更多的是关于动作，而REST是关于资源。</p><p id="efff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RPC服务可以更简单，性能更好，但代价是灵活性和独立性。对于服务对服务的通信，这是非常好的。</p><h1 id="d27f" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">RPC在Go中</h1><p id="f5f2" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">虽然Go中有其他RPC框架，但除非我真的不得不使用，否则我会使用<a class="ae la" href="https://github.com/twitchtv/twirp" rel="noopener ugc nofollow" target="_blank"> Twirp </a>，原因如下:<br/> 1 .非常简单的设置。这对我最重要。<br/> 2。同时支持http1.1和http2.0 <br/> 3。同时支持Protobuf和JSON <br/> 4。易于调试</p><p id="1bc7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">gRPC应该得到一个荣誉奖，并且肯定有它自己的位置，特别是当你需要双向流、长时间连接和客户端负载平衡的时候。<br/>gRPC的缺点是经常会遇到问题，需要第三方，如<a class="ae la" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> grpc-gateway </a>、<a class="ae la" href="https://github.com/grpc/grpc-web" rel="noopener ugc nofollow" target="_blank"> grpc-web </a>等等。</p><h2 id="d4f6" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">原蟾蜍</h2><p id="7331" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">Protobuf是Google编写的一种数据序列化机制，并且变得非常流行。它是开源的，也是语言和平台中立的。<br/> Protobuf使用二进制传输格式，这意味着它不是人类可读的，但也意味着它消耗更少的空间和带宽，消耗更少的CPU。<br/> Protobuf相比其他类型有以下优势:<br/> 1 .有一个模式<br/> 2。就是更快更小<br/> 3。向后兼容<br/> 4。内置了验证和可扩展性。支持更多的数据类型</p><p id="cd33" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了比较Twirp和REST，我编写了这个<a class="ae la" href="https://github.com/subzero112233/golang-twirp" rel="noopener ugc nofollow" target="_blank">基本应用程序</a>，用于通过RPC和REST发送/检索玩家数据。</p><p id="6f9b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">REST的实现很简单，可以在这里找到<a class="ae la" href="https://github.com/subzero112233/golang-twirp/blob/master/handlers/rest/rest.go" rel="noopener ugc nofollow" target="_blank"/>，让我们直接进入twirp。</p><p id="ce5e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，让我们看看我们的<code class="fe mv mw mx my b">stats.proto</code>文件:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="cd53" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个文件以结构化的格式为我们的消息建模，这里我们以请求-响应格式定义我们的RPC服务。</p><p id="622f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如:<code class="fe mv mw mx my b">AddStats</code>函数接收<code class="fe mv mw mx my b">AddStatsRequest</code>消息，它基本上是一个<code class="fe mv mw mx my b">Stats</code>消息的数组，并返回一个<code class="fe mv mw mx my b">AddStatsResponse</code>格式的消息，在本例中是一个字符串。</p><h2 id="2afc" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">如何生成原型文件</h2><p id="11df" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">为此，我们需要安装这两个生成器:<br/> <code class="fe mv mw mx my b">go install github.com/twitchtv/twirp/protoc-gen-twirp<br/>go install google.golang.org/protobuf/cmd/protoc-gen-go</code></p><p id="5c98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从原型文件中生成<code class="fe mv mw mx my b">.go</code>文件:<br/>确保<code class="fe mv mw mx my b">$GOPATH</code>指向您的golang安装目录，在我的例子中是<code class="fe mv mw mx my b">/usr/local/go</code>。<br/>然后运行:<br/> <code class="fe mv mw mx my b">protoc --proto_path=$GOPATH/src:. --twirp_out=../ --go_out=../ rpc/stats/stats.proto</code></p><p id="a0c5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">两个新文件:<code class="fe mv mw mx my b">stats.pb.go</code>和<code class="fe mv mw mx my b">stats.twirp.go</code>，包含客户端和服务器实用程序。<br/>另一件需要提及的重要事情是我们需要在代码中实现的<code class="fe mv mw mx my b">StatsService</code>接口。<br/>在这里(去掉转换部分以缩短主旨):</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b208" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看它是如何工作的。<br/>首先，需要启动服务器。<br/> <code class="fe mv mw mx my b">~ $ go run cmd/main.go</code></p><p id="21f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在发送请求。首先是<strong class="ke ir">的AddStats </strong>，然后是<strong class="ke ir">的GetStats </strong>。我已经创建了一个示例客户端实现来演示这些请求:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="887e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如您所见，请求就像常规函数调用一样被发送！</p><p id="d56c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mv mw mx my b">~ $ go run example/example.go <br/>status:”success”<br/>stats:{player_name:”Reggie Jackson” minutes:32.9 field_goals:14 field_goal_attempts:20 three_pointers_made:4 three_pointer_attempts:7 free_throws_made:6 free_throw_attempts:6 offensive_rebounds:1 defensive_rebounds:3 assists:6 steals:1 turnovers:2 personal_fouls:3 points:38 game_date:{seconds:1625916051}}</code></p><p id="d0c0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一件很酷的事情是，我们还可以使用curl来发送请求。这对于调试和初始设置非常方便:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3c21" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了测试性能差异，我创建了两个测试文件(<code class="fe mv mw mx my b">rest_test.go</code>、<code class="fe mv mw mx my b">twirp_test.go</code> ): <br/>、<code class="fe mv mw mx my b">~ $ go test -bench=. -benchtime=5000x<br/>goos: linux<br/>goarch: amd64<br/>pkg: github.com/subzero112233/golang-twirp<br/>cpu: Intel(R) Core(TM) i7–8550U CPU @ 1.80GHz<br/>BenchmarkRestAdd-8 5000 533270 ns/op<br/>BenchmarkRestGet-8 5000 475062 ns/op<br/>BenchmarkTwirpAdd-8 5000 90284 ns/op<br/>BenchmarkTwirpGet-8 5000 91833 ns/op<br/>PASS<br/>ok github.com/subzero112233/golang-twirp 5.966s</code></p><p id="4b6d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在较小的有效负载上，这种差异可能不太显著，但仍然足够显著，可以在必要时使用RPC。</p><p id="875d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>