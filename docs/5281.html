<html>
<head>
<title>Building Docker Images The Proper Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以正确的方式构建Docker图像</h1>
<blockquote>原文：<a href="https://itnext.io/building-docker-images-the-proper-way-3c9807524582?source=collection_archive---------0-----------------------#2021-02-01">https://itnext.io/building-docker-images-the-proper-way-3c9807524582?source=collection_archive---------0-----------------------#2021-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4074" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们优化Docker构建，以在通常构建时间的一小部分内创建更小、更安全的Docker映像…</h2></div><p id="0192" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一点上，可能每个人都听说过Docker，大多数开发人员都熟悉它，使用它，因此知道如何构建Docker映像等基础知识。它和运行<code class="fe le lf lg lh b">docker built -t name:tag .</code>一样简单，但是还有更多，特别是在优化构建过程和最终创建的映像时。因此，在本文中，我们将超越基础知识，看看我们如何影响Docker映像的构建过程，使其更快，并为我们的应用程序生成更精简、更安全的映像。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/8e68c0d39e60eaa67b6aef38bf89a636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZYRUC186rFiox2B9OVD9g.jpeg"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">照片由<a class="ae ly" href="https://unsplash.com/@timelabpro?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Timelab Pro </a>在<a class="ae ly" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="4bf9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">用于快速构建的缓存</h1><p id="5a91" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">大部分映像构建时间通常来自系统库和应用程序依赖项的下载和安装。然而，它们并不经常改变，因此很适合缓存。</p><p id="9347" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从系统库和工具开始——通常在初始<code class="fe le lf lg lh b">FROM</code>之后立即移动它们的安装就足够了，以确保它们被缓存。无论您使用哪个Linux发行版作为基础映像，您最终都会得到如下结果:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9bc1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，你甚至可以把这些都提取到单独的<code class="fe le lf lg lh b">Dockerfile</code>中来构建你自己的基础图像。然后，可以将该图像推送到注册表，以便您和其他人可以在多个应用程序中重用它。这样你就不用担心任何系统库/依赖项，除非你需要升级它们或者添加/删除一些东西。</p><p id="9182" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在系统库之后，我们通常希望安装应用程序依赖项。这些可能是存储在<code class="fe le lf lg lh b">.m2</code>目录中的来自Maven仓库的Java库、<code class="fe le lf lg lh b">node_modules</code>中的JavaScript模块或者<code class="fe le lf lg lh b">venv</code>中的Python库。这些会比系统依赖项更频繁地改变，但不足以保证每次构建都要完全重新下载和重新安装。但是，如果Dockerfile写得不好，您会注意到，即使没有修改依赖关系，也不会使用缓存:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2e8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是为什么呢？嗯，问题出在<code class="fe le lf lg lh b">COPY . .</code>上，Docker在构建的每一步都使用缓存，直到它运行到新的/修改过的命令/层。在这种情况下，当我们将所有内容复制到映像中时——包括<em class="my">未更改的</em>依赖项列表以及<em class="my">已修改的</em>源代码——Docker只是继续重新下载并重新安装所有依赖项，因为由于修改了源代码，它无法再使用该层的缓存。为了避免这种情况，我们必须分两步复制文件:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e233" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们添加列出所有应用程序依赖项的文件并安装它们。如果没有对此文件进行任何更改，那么这些都将被缓存。只有这样，我们才能将剩余的(修改后的)源代码复制到映像中，并运行应用程序代码的测试和构建。</p><p id="4ef5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于更多的<em class="my">【高级】</em>方法，我们使用Docker的<em class="my">构建工具包</em>和它的实验特性做同样的事情:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="cf82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码展示了我们如何使用<code class="fe le lf lg lh b">RUN</code>命令的<code class="fe le lf lg lh b">--mount</code>选项来选择缓存目录。如果您希望显式使用非默认缓存位置，这可能会很有帮助。如果您想使用这个特性，您将不得不包含指定语法版本的标题行(如上所述),并使用<code class="fe le lf lg lh b">DOCKER_BUILDKIT=1 docker build name:tag .</code>运行构建。关于实验特征的更多信息可以在这些<a class="ae ly" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#run---mounttypecache" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p><p id="1d42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，所说的都只适用于本地构建——对于CI来说，这是一个不同的故事，一般来说，对于每个工具/提供商来说都是不同的，但是对于它们中的任何一个，您都需要一些持久的卷来存储缓存/依赖关系。例如对于<a class="ae ly" href="https://www.jenkins.io/doc/book/pipeline/docker/#caching-data-for-containers" rel="noopener ugc nofollow" target="_blank">詹金斯</a>，你可以在代理中使用存储。对于在Kubernetes上运行的Docker构建版本——无论是使用<em class="my"> JenkinsX </em>、<em class="my"> Tekton </em>还是其他——你都需要Docker守护进程，可以使用Docker (DinD) 中的<em class="my"> Docker来部署，这是在Docker容器中运行的Docker守护进程。至于构建本身，您将需要一个连接到<em class="my"> DinD </em>插座并运行<code class="fe le lf lg lh b">docker build</code>的pod(容器)。</em></p><p id="7d67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于演示目的，为了简单起见，我们可以使用以下pod:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1d78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述pod由两个容器组成——一个用于<em class="my"> DinD </em>和一个用于<em class="my">图像生成器</em>。要使用builder容器运行构建，您可以访问它的shell，克隆一些存储库并运行build:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4318" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后的<code class="fe le lf lg lh b">docker build</code>使用了一些新的选项——一个是<code class="fe le lf lg lh b">--cache-from image:tag</code>,它告诉Docker应该使用来自(远程)注册表的指定图像作为缓存源。这样，即使缓存的层没有存储在本地文件系统上，我们也可以利用缓存。另一个选项——<code class="fe le lf lg lh b">--build-arg BUILDKIT_INLINE_CACHE=1</code>——用于在创建映像时将缓存元数据写入映像。这必须用于<code class="fe le lf lg lh b">--cache-from</code>的工作，更多信息在<a class="ae ly" href="https://docs.docker.com/engine/reference/commandline/build/#specifying-external-cache-sources" rel="noopener ugc nofollow" target="_blank">文档</a>中。</p><h1 id="c8db" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">给他们减肥</h1><p id="6658" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">拥有快速构建固然很好，但是如果你有真正的<em class="my">“厚”</em>映像，拉和推它们仍然需要很长时间，并且胖映像很可能还包含许多库、工具等等，这使得映像更容易受到攻击，因为它创建了更大的攻击面。</p><p id="8aad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">制作更薄图像的最简单的方法是使用类似Alpine Linux的东西，而不是基于Ubuntu或RHEL的图像。另一个好方法是使用多步Docker构建，其中您使用一个映像来构建(第一个<code class="fe le lf lg lh b">FROM</code>命令)和不同的、更精简的映像来运行应用程序(第二个/最后一个<code class="fe le lf lg lh b">FROM</code>)，例如:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="20ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面显示，我们首先在基本Python 3.8.7映像中准备应用程序及其依赖项，该映像相当大，有332.88 MB。在这个映像中，我们安装了应用程序所需的虚拟环境和库。然后我们切换到更小的基于Alpine的图像，只有16.98 MB。我们将之前创建的整个虚拟环境以及源代码复制到这个映像中。通过这种方式，我们可以得到更小的图像，更少的图层，更少的不必要的工具和二进制文件。</p><p id="55b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外要记住的一件事是我们在每次构建时产生的层数。<code class="fe le lf lg lh b">FROM</code>、<code class="fe le lf lg lh b">COPY</code>、<code class="fe le lf lg lh b">RUN</code>和<code class="fe le lf lg lh b">CMD</code>是创建层的四个命令，至少在<code class="fe le lf lg lh b">RUN</code>的情况下，我们可以通过<code class="fe le lf lg lh b">&amp;&amp;</code>将所有<code class="fe le lf lg lh b">RUN</code>命令合并成一个命令来轻松减少它创建的层的数量，如下所示:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f05a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以把它推得更远，完全去掉可能相当厚的基础图像。为此，我们将使用特殊的<code class="fe le lf lg lh b">FROM scratch</code>来通知Docker应该使用最小的基本图像，并且下一个命令将是最终图像的第一层。这对于以二进制形式运行且不需要大量工具运行应用程序尤其有用，例如Go、C++或Rust应用程序。然而，这种方法要求二进制文件是静态编译的，因此不适用于Java或Python这样的语言。一个<code class="fe le lf lg lh b">FROM scratch</code> Dockerfiles的例子可能是这样的:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="84b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单，对吧？有了这种Dockerfile文件，我们可以制作出仅在3MB周边的图像！</p><h1 id="113e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">锁定事物</h1><p id="b57a" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">速度和大小效率是大多数人会关注的两件事，而图像的安全性成为事后的想法。有一些简单的方法可以锁定图像中的内容，并限制对手的攻击面。</p><p id="1a88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最基本的建议是锁定所有库、包、工具和基本映像的版本，这不仅对安全性很重要，对映像的稳定性也很重要。如果你对图像使用<code class="fe le lf lg lh b">latest</code>标签，或者你没有在Python的<code class="fe le lf lg lh b">requirements.txt</code>或JavaScript的<code class="fe le lf lg lh b">package.json</code>中指定版本，你就有可能在构建期间下载的图像/库可能与应用程序代码不兼容，或者它可能暴露你的容器的漏洞。虽然您希望将所有内容锁定到特定版本，但您也应该定期更新所有这些依赖项，以确保您拥有所有最新的安全补丁和修复程序。</p><p id="2fe5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使您非常努力地试图避免所有依赖项中的任何漏洞，仍然会有一些您遗漏了或者尚未修复/发现的漏洞。因此，为了减轻任何可能攻击的影响，最好避免像<code class="fe le lf lg lh b">root</code>那样运行容器。因此，您应该在docker文件中包含<code class="fe le lf lg lh b">USER 1001</code>,以表明从您的docker文件创建的容器应该并且可以作为非根用户(理想情况下是任意用户)运行。当然，这可能需要您修改您的应用程序并选择正确的基础映像，因为一些常见的基础映像如<code class="fe le lf lg lh b">nginx</code>需要root权限(例如，因为特权端口)。</p><p id="2bb3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常很难找到/避免Docker映像中的漏洞，但是如果映像只包含运行应用程序所需的最少部分，那么就容易多了。谷歌制作的<a class="ae ly" href="https://github.com/GoogleContainerTools/distroless" rel="noopener ugc nofollow" target="_blank">发行版</a>就是这样一张图片——或者说是一组图片。Distroless映像被精简到甚至没有外壳或包管理器，这使得它们在安全性方面比Debian或基于Alpine的映像好得多。如果你使用多步Docker构建，那么大多数时候，切换到distrolles<em class="my">runner</em>镜像就像这样简单:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3da1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了最终图像及其容器中可能存在的漏洞，我们还必须考虑我们用来构建图像的Docker守护进程和容器运行时。因此，与我们所有的图像一样，我们不应该允许Docker与<code class="fe le lf lg lh b">root</code>用户一起运行，而是使用所谓的<em class="my">无根</em>模式。在<a class="ae ly" href="https://docs.docker.com/engine/security/rootless/" rel="noopener ugc nofollow" target="_blank"> Docker docs </a>中有关于如何设置的完整指南，但是如果你不想弄乱这种配置，那么你可能想要考虑切换到默认情况下在<em class="my">无根</em>和<em class="my">无域</em>模式下运行的<code class="fe le lf lg lh b">podman</code>——在我这里的另一篇文章中有更多关于它的内容:</p><div class="mz na gp gr nb nc"><a href="https://towardsdatascience.com/its-time-to-say-goodbye-to-docker-5cfec8eff833" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">你不用再用Docker了</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">Docker不是唯一的集装箱工具，可能会有更好的替代工具…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ls nc"/></div></div></a></div><h1 id="c7cb" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="d428" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">容器和Docker已经存在了足够长的时间，每个人除了学习和使用最少的可用特性外，几乎没有什么东西。这篇文章中的提示和例子应该(在我看来)是一个很好的垫脚石，可以增加你的Docker知识，改善你使用的Docker图片的各个方面。然而，除了构建Docker图像之外，我们还可以做更多的事情来改进我们使用图像和容器的方式。这包括例如应用<code class="fe le lf lg lh b">seccomp</code>政策(下面是我的文章)👇)，使用<code class="fe le lf lg lh b">cgroups</code>或者可能使用完全不同的容器运行时/引擎来限制资源消耗。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="2d64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="my">本文最初发布于</em><a class="ae ly" href="https://martinheinz.dev/blog/42?utm_source=tds&amp;utm_medium=referral&amp;utm_campaign=blog_post_42" rel="noopener ugc nofollow" target="_blank"><em class="my">martinheinz . dev</em></a></p><div class="mz na gp gr nb nc"><a rel="noopener  ugc nofollow" target="_blank" href="/hardening-docker-and-kubernetes-with-seccomp-a88b1b4e2111"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">用seccomp强化Docker和Kubernetes</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">您的容器可能不像您想象的那样安全，但是seccomp配置文件可以帮助您解决这个问题…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">itnext.io</p></div></div><div class="nl l"><div class="ny l nn no np nl nq ls nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a href="https://towardsdatascience.com/networking-tools-every-developer-needs-to-know-e17c9159b180" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">每个开发人员都需要知道的网络工具</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">让我们学习被忽视的网络技能，如检查DNS记录，扫描端口，排除连接故障…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nl l"><div class="nz l nn no np nl nq ls nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a href="https://towardsdatascience.com/deploy-any-python-project-to-kubernetes-2c6ad4d41f14" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">将任何Python项目部署到Kubernetes</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">是时候深入Kubernetes，使用这个成熟的项目模板将您的Python项目带到云中了！</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nl l"><div class="oa l nn no np nl nq ls nc"/></div></div></a></div></div></div>    
</body>
</html>