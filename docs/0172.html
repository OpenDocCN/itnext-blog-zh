<html>
<head>
<title>Functional Programming Basics w/ Emojis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有表情符号的函数式编程基础</h1>
<blockquote>原文：<a href="https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223?source=collection_archive---------0-----------------------#2017-10-09">https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223?source=collection_archive---------0-----------------------#2017-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/340a0bbf86d5ec4926929328322c8f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvPr1Dhzh8XB2BckHqZkrQ.png"/></div></div></figure><h2 id="c1dc" class="iz ja jb bd b dl jc jd je jf jg jh dk ji translated" aria-label="kicker paragraph">表情符号爱好者的函数式编程指南</h2><div class=""/><div class=""><h2 id="cb44" class="pw-subtitle-paragraph kh jk jb bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">学习数组映射和闭包的函数基础</h2></div><p id="eadd" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><em class="lv">用表情符号和JavaScript学习函数式编程。代码示例应该足够简单，不需要任何先验知识就可以理解，但是我可以想象它看起来有点奇怪。还有，JavaScript实际上不允许表情符号作为JavaScript变量名。出于这个原因，这些代码示例不会在没有修改的情况下运行。</em></p><ul class=""><li id="5d08" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223" rel="noopener"> <em class="lv">用食物表情符号制作便便。</em> </a></li><li id="4cf2" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3" rel="noopener"> <em class="lv">把暴风云变成晴朗的云。</em>T12】</a></li><li id="34ed" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-3-ef78e3156e" rel="noopener"> <em class="lv">用减速器造独角兽！</em> </a></li><li id="f0f3" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-4-735c17ca4113" rel="noopener"> <em class="lv">管道操作员现在！</em> </a></li><li id="cb51" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-5-a6bc3324a839" rel="noopener"> <em class="lv">为食肉动物过滤肉类。</em>T24】</a></li><li id="7665" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-6-5c1d441d36af" rel="noopener"> <em class="lv">使用递归与归约。</em> </a></li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="95e1" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">函数式编程可能很难理解。这里有一个快速使用食物表情符号的方法:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="728f" class="nb nc jb mx b gy nd ne l nf ng">💩 = [🍔, 🍟, 🍪].reduce(eat)</span></pre><p id="ca25" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">漂亮吧？如果你把汉堡、薯条和饼干放在减肥器里，你最终会得到便便！</p><p id="05eb" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你不明白这一点，我们可以从一些简单的基本数学开始:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b5d7" class="nb nc jb mx b gy nd ne l nf ng">😂 = 😢 + 😀</span><span id="8421" class="nb nc jb mx b gy nh ne l nf ng">😶 = 🤐 - 😐</span></pre><p id="ebcd" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们再举一个函数的例子。我们有一排云。我们将处理这个数组，然后返回另一个数组。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5f3c" class="nb nc jb mx b gy nd ne l nf ng">[🌩️, ⛈️] = [☁️, 🌧️].map(add(⚡))</span></pre><p id="e827" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">最好的函数式编程！我们拿了一些云表情符号，给每一个都加了闪电，用闪电做了云！就像魔法一样！</p><p id="2dcd" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在我们进入疯狂小镇之前，让我们看一个使用不同范例的例子:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="528f" class="nb nc jb mx b gy nd ne l nf ng">addLighting = item =&gt; item + ⚡<br/>🌩️ = addLightning(☁️)</span><span id="c130" class="nb nc jb mx b gy nh ne l nf ng">addSun = item =&gt; item + ☀️<br/>⛅ = addSun(☁️)</span></pre><p id="d8c2" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这段代码虽然有效，但并不枯燥(不要重复)。对于我们想要做的每个<code class="fe ni nj nk mx b">add</code>操作，我们必须手工创建一个全新的函数。相反，我们可以尝试一个更好的解决方案:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2757" class="nb nc jb mx b gy nd ne l nf ng">add = (item, additive) =&gt; item + additive</span><span id="23e1" class="nb nc jb mx b gy nh ne l nf ng">🌩️ = add(☁️, ⚡)</span><span id="5617" class="nb nc jb mx b gy nh ne l nf ng">⛅ = add(☁️, ☀️)</span></pre><p id="e51e" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">太棒了。我们已经创建了一个接受多个参数并返回一个值的通用函数。但是我们还有一个问题！如果我们想对数组中的每一项都调用<code class="fe ni nj nk mx b">add</code>，就像我们之前对<code class="fe ni nj nk mx b">map</code>所做的那样，该怎么办？强制性地这样做，看起来会像这样:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a886" class="nb nc jb mx b gy nd ne l nf ng">clouds = [☁️, 🌧️]<br/>stormyClouds = []</span><span id="cdcd" class="nb nc jb mx b gy nh ne l nf ng">add = (item, additive) =&gt; item + additive</span><span id="2bc4" class="nb nc jb mx b gy nh ne l nf ng">for (let i = 0, l = clouds.length; i &lt; l; i++) {<br/>    stormyClouds<br/>    .push(<br/>        add(clouds[i], ⚡)<br/>    )<br/>}</span></pre><p id="4ab9" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">看起来足够简单，但是<code class="fe ni nj nk mx b">for</code>循环确实很乱。我们不仅在循环的每一轮对<code class="fe ni nj nk mx b">i</code>进行了变异，而且还将值推入了循环之外的<code class="fe ni nj nk mx b">stormyClouds</code>数组。</p><p id="78f6" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">JavaScript也有<code class="fe ni nj nk mx b">for-in</code>循环，为你跟踪<code class="fe ni nj nk mx b">i</code>；所以，你的<code class="fe ni nj nk mx b">for</code>循环可以干净很多。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="c740" class="nb nc jb mx b gy nd ne l nf ng">for (let i in clouds) {<br/>    stormyClouds<br/>    .push(<br/>        add(clouds[i], ⚡)<br/>    )<br/>}</span></pre><p id="6600" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">但是，当我们真正关心的是该指数的值时，为什么要传递这个指数呢？foreach循环，在JavaScript中称为<code class="fe ni nj nk mx b">for-of</code>，让我们更接近函数式方法:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1c69" class="nb nc jb mx b gy nd ne l nf ng">for (let cloud of clouds) {<br/>    stormyClouds<br/>    .push(<br/>        add(cloud, ⚡)<br/>    )<br/>}</span></pre><p id="a5ec" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">既然我们已经在这里了，我们可以通过用<code class="fe ni nj nk mx b">forEach</code>替换<code class="fe ni nj nk mx b">for-of</code>来快速清理这个问题:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d649" class="nb nc jb mx b gy nd ne l nf ng">clouds<br/>.forEach(cloud =&gt; {<br/>    stormyClouds<br/>    .push(<br/>        add(cloud, ⚡)<br/>    )<br/>})</span></pre><p id="e48f" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">略好，但不满意。由于<code class="fe ni nj nk mx b">forEach</code>接受一个函数，我们可以在其他地方创建该函数，然后像这样传递它:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="93b6" class="nb nc jb mx b gy nd ne l nf ng">addLightning = cloud =&gt; {<br/>    stormyClouds<br/>    .push(<br/>        add(cloud, ⚡)<br/>    )<br/>}</span><span id="c48d" class="nb nc jb mx b gy nh ne l nf ng">clouds.forEach(addLightning)</span></pre><p id="8f72" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">虽然<code class="fe ni nj nk mx b">addLighting</code>函数使单元测试变得简单，但我们还是回到了自己身上。现在我们回到创建一次性函数。如果你想写一个<code class="fe ni nj nk mx b">addSun</code>，你将会复制粘贴很多相同的代码。我们的代码仍然不干燥，但是我们一般地写它。这是怎么回事？</p><p id="a438" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这就是我们需要一个了结的地方。我们与<code class="fe ni nj nk mx b">map</code>一起使用的原始<code class="fe ni nj nk mx b">add</code>函数实际上是这样的:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5169" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; item + additive</span></pre><p id="0dca" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这个<code class="fe ni nj nk mx b">add</code>函数允许我们生成函数。它接受一个<code class="fe ni nj nk mx b">additive</code>，然后返回另一个接受<code class="fe ni nj nk mx b">item</code>的函数。关键是第一次调用<code class="fe ni nj nk mx b">add</code>实际上什么都不做；它只是存储<code class="fe ni nj nk mx b">additive</code>，所以当内部函数被调用时，它可以访问<code class="fe ni nj nk mx b">additive</code>，即使它从未被传入！</p><p id="3342" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在我们可以即时生成<code class="fe ni nj nk mx b">addLighting</code>和<code class="fe ni nj nk mx b">addSun</code>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5962" class="nb nc jb mx b gy nd ne l nf ng">addLightning = add(⚡)<br/>🌩️ = addLightning(☁️)</span><span id="b181" class="nb nc jb mx b gy nh ne l nf ng">addSun = add(☀️)<br/>⛅ = addSun(☁️)</span></pre><p id="f0b4" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这是另一种看待它的方式:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="88aa" class="nb nc jb mx b gy nd ne l nf ng">🌩️ = add(⚡)(☁️)</span><span id="0909" class="nb nc jb mx b gy nh ne l nf ng">⛅ = add(☀️)(☁️)</span></pre><p id="6ae3" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">很奇怪吧？为什么我们要返回一个函数，然后调用那个函数，而我们只需要两个参数就可以了呢？是因为复制粘贴的问题。使用闭包，我们可以删除大量样板文件，创建返回其他通用函数的通用函数。</p><p id="68eb" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">使用过程方法，我们通常会这样写:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d58c" class="nb nc jb mx b gy nd ne l nf ng">clouds = [☁️, 🌧️]<br/>stormyClouds = []<br/>sunnyClouds = []</span><span id="0491" class="nb nc jb mx b gy nh ne l nf ng">add = (item, additive)=&gt; item + additive</span><span id="0bb9" class="nb nc jb mx b gy nh ne l nf ng">addLightning = cloud =&gt; {<br/>    stormyClouds<br/>    .push(<br/>        add(cloud, ⚡)<br/>    )<br/>}</span><span id="eac5" class="nb nc jb mx b gy nh ne l nf ng">addSun = cloud =&gt; {<br/>    sunnyClouds<br/>    .push(<br/>        add(cloud, ☀️)<br/>    )<br/>}</span><span id="64ff" class="nb nc jb mx b gy nh ne l nf ng">for(let i = 0, l = clouds.length; i &lt; l; i++) {<br/>    addLightning(clouds[i])<br/>}</span><span id="3b79" class="nb nc jb mx b gy nh ne l nf ng">for(let i = 0, l = clouds.length; i &lt; l; i++) {<br/>    addSun(clouds[i])<br/>}</span><span id="55a3" class="nb nc jb mx b gy nh ne l nf ng">[🌩️, ⛈️] = stormyClouds<br/>[⛅, 🌦️] = sunnyClouds</span></pre><p id="3046" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">但是使用函数式编程，我们可以编写非常简洁的代码来做完全相同的事情:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d4ef" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; item + additive</span><span id="58c4" class="nb nc jb mx b gy nh ne l nf ng">[🌩️, ⛈️] = [☁️, 🌧️].map(add(⚡))<br/>[⛅, 🌦️] = [☁️, 🌧️].map(add(☀️))</span></pre><p id="79e4" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">超级超级强大！相同的功能只需要3行代码！为了更深入一点，我们可以编写一个<code class="fe ni nj nk mx b">subtract</code>函数:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="fb37" class="nb nc jb mx b gy nd ne l nf ng">subtract = subtractor =&gt; item =&gt; item - subtractor</span></pre><p id="e22a" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在我们可以反过来做同样的操作:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="93a9" class="nb nc jb mx b gy nd ne l nf ng">[☁️, 🌧️] = [🌩️, ⛈️️].map(subtract(⚡))<br/>[☁️, 🌧️] = [⛅, 🌦️].map(subtract(☀️))</span></pre><p id="9612" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">俏皮！让我们更进一步。我们实际上可以<code class="fe ni nj nk mx b">map</code>数组，然后通过链接这些函数再次<code class="fe ni nj nk mx b">map</code>它:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5d12" class="nb nc jb mx b gy nd ne l nf ng">[⛅, 🌦️] = (<br/>    [🌩️, ⛈️️]<br/>    .map(subtract(⚡))<br/>    .map(add(☀️))<br/>)</span></pre><p id="7fbd" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">曾经风雨交加的现在阳光明媚。减去闪电，加上太阳。每次调用<code class="fe ni nj nk mx b">map</code>时，它都会返回一个新数组。你第一次运行它时，我们得到的是常规的无闪电云。第二次运行时，它会添加sun。超级简单，超级强大。</p><p id="bfab" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb jl">感受力量！</strong></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="2830" class="nb nc jb bd nl nm nn dn no np nq dp nr li ns nt nu lm nv nw nx lq ny nz oa jh bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3" rel="noopener">点击此处进入第2部分！</a></h2><h1 id="af41" class="ob nc jb bd nl oc od oe no of og oh nr kq oi kr nu kt oj ku nx kw ok kx oa ol bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kz la jb lb b lc om kl le lf on ko lh li oo lk ll lm op lo lp lq oq ls lt lu ij bi translated">如果您对与函数式编程相关的更多主题感兴趣，您应该看看我的其他文章:</p><ul class=""><li id="f12a" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/how-to-safely-refactor-old-code-part-1-a1a853263fec">安全重构旧代码:第1部分</a></li><li id="21e8" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a" rel="noopener">使用Redux的秘密:createNamespaceReducer </a></li><li id="c67f" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/using-redux-reducers-in-react-components-4e92985dd9cb" rel="noopener">在React组件中使用Redux还原剂</a></li><li id="7284" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li><li id="6c88" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="1351" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><em class="lv">我感谢</em> <strong class="lb jl"> <em class="lv">贾斯汀·苏拉德</em> </strong> <em class="lv">在工作中鼓舞人心的懈怠状态:</em></p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0a83" class="nb nc jb mx b gy nd ne l nf ng">💩 = [🍔, 🍟, 🍪].reduce(eat)</span></pre></div></div>    
</body>
</html>