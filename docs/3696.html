<html>
<head>
<title>Inversion of Control (IoC) in Azure Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure函数中的控制反转(IoC)</h1>
<blockquote>原文：<a href="https://itnext.io/inversion-of-control-ioc-in-azure-functions-110393662c61?source=collection_archive---------1-----------------------#2020-02-05">https://itnext.io/inversion-of-control-ioc-in-azure-functions-110393662c61?source=collection_archive---------1-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f8ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无服务器计算和使用Azure函数不仅仅是写一个方法；在现实世界中，它还包括逻辑和架构。</p><p id="423c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Azure Functions是微软Azure提供的无服务器计算服务之一。它们<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale" rel="noopener ugc nofollow" target="_blank">易于扩展</a>，此外，它们支持<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings#supported-bindings" rel="noopener ugc nofollow" target="_blank">各种触发器、绑定</a>，你不需要为消费它们而支付<a class="ae ko" href="https://azure.microsoft.com/en-us/pricing/details/functions/" rel="noopener ugc nofollow" target="_blank">大量金钱</a>。</p><p id="66a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了编写合适的软件，我需要遵循<a class="ae ko" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实的</a>原则和许多其他最佳实践。可测试性、抽象和<a class="ae ko" href="https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#dependency-inversion" rel="noopener ugc nofollow" target="_blank">依赖倒置</a>是必不可少的。使用Azure函数的无服务器计算仍然是编写应用程序。</p><p id="8697" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我解释了如何在Azure函数中实现依赖注入来实现IoC。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><p id="24be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的例子可以在我的Github上找到。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h2 id="ce4c" class="kw kx it bd ky kz la dn lb lc ld dp le kb lf lg lh kf li lj lk kj ll lm ln lo bi translated">开始之前</h2><p id="c199" class="pw-post-body-paragraph jq jr it js b jt lp jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn im bi translated">您不需要拥有Azure帐户。您可以在本地机器上测试和运行项目。只需安装<a class="ae ko" href="https://code.visualstudio.com/Download" rel="noopener ugc nofollow" target="_blank"> VSCode </a>、<a class="ae ko" href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions" rel="noopener ugc nofollow" target="_blank">vs code</a>和<a class="ae ko" href="https://dotnet.microsoft.com/download" rel="noopener ugc nofollow" target="_blank">的Azure函数扩展。NET SDK </a>。</p><h2 id="f3f5" class="kw kx it bd ky kz la dn lb lc ld dp le kb lf lg lh kf li lj lk kj ll lm ln lo bi translated">创建Azure函数项目</h2><p id="5c37" class="pw-post-body-paragraph jq jr it js b jt lp jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn im bi translated">首先，创建一个新文件夹，并在其中打开VSCode。在VSCode中，转到Azure function extensions，并按照以下说明操作:</p><ul class=""><li id="68bc" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated">点击<strong class="js iu">新建项目</strong>，选择当前文件夹作为项目文件夹。</li><li id="3d1f" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">选择C# 作为项目的语言。</li><li id="72c2" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">你需要挑一个<strong class="js iu">模板</strong>做脚手架。对于本文，我使用<strong class="js iu"> Http触发器</strong>。</li><li id="8d4a" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">输入函数的名称和项目的命名空间。</li><li id="3b4f" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">定义访问类型；我选择匿名。</li></ul><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/9d732722b707dfb94302b7fcc731a411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hm_5qaL_UEJCz72TW1FAKw.gif"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">创建新的AzureFunctions项目</figcaption></figure><p id="fe3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了检查您的项目是否创建正确，您可以通过按下<strong class="js iu"> F5 </strong>或者从<strong class="js iu">调试</strong>菜单中选择<strong class="js iu">开始调试</strong>来运行它。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi my"><img src="../Images/6a1371f9606d40a81bbe73a375df659b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CvxODK9G_TMe8TjItf3iNA.gif"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">在VSCode中运行Azure函数</figcaption></figure><p id="eb49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要实现IoC，安装<a class="ae ko" href="https://www.nuget.org/packages/Microsoft.Azure.Functions.Extensions/" rel="noopener ugc nofollow" target="_blank">微软。带有NuGet的Azure.Functions.Extensions </a>包。在VSCode终端中输入以下命令:</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="5920" class="kw kx it na b gy ne nf l ng nh">dotnet add package Microsoft.Azure.Functions.Extensions</span></pre><p id="3253" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并确保<a class="ae ko" href="https://www.nuget.org/packages/Microsoft.NET.Sdk.Functions/" rel="noopener ugc nofollow" target="_blank">微软。项目上的. NET.Sdk.Functions包</a>为1.0.28或更高版本。为此，您可以检查项目的CSProj文件。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ni"><img src="../Images/4d9870d5fe89a13881ac2bdec7b4bf07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztUWoLyMAIlkJzbPL43qTQ.png"/></div></div></figure><h2 id="1c7b" class="kw kx it bd ky kz la dn lb lc ld dp le kb lf lg lh kf li lj lk kj ll lm ln lo bi translated">实现IoC并注册类型和服务</h2><p id="7274" class="pw-post-body-paragraph jq jr it js b jt lp jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn im bi translated">Azure函数中的依赖注入是建立在。NET核心依赖注入特性。但是，在如何覆盖依赖项和如何使用消费计划上的Azure函数读取消费计划上的配置值之间存在差异。对依赖注入的支持始于Azure Functions 2.x。</p><p id="f051" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个名为<strong class="js iu"> Startup </strong>的新类文件。Azure函数将使用这个类来配置IoC和服务。这个类的内容应该如下例所示:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="8d8c" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated"><strong class="js iu"> Startup </strong>类应该继承<strong class="js iu"> FunctionsStartup </strong>类。</li><li id="696b" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">它应该覆盖Configure方法以便能够配置您的IoC。</li><li id="3d3e" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">用<code class="fe nl nm nn na b">[assembly: FunctionsStartup(type of strtup class)]</code>你定义的这个类的属性是启动类。如果你不指定这个属性，Azure函数将找不到启动类。</li></ul><p id="bc4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您在代码中看到的，我注释了几个如何在其中注册服务和类型的例子。</p><p id="dada" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Azure函数提供了与ASP.NET依赖注入相同的服务生命周期。对于函数应用程序，不同的服务生命周期表现如下:</p><ul class=""><li id="98d2" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated"><strong class="js iu">瞬态</strong>:瞬态服务是根据服务的每个请求创建的。</li><li id="7781" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated"><strong class="js iu">作用域</strong>:作用域服务生存期与函数执行生存期相匹配。每次执行都会创建一次作用域服务。稍后在执行期间请求该服务时，重用现有的服务实例。</li><li id="cbeb" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated"><strong class="js iu">Singleton</strong>:Singleton服务生存期与主机生存期相匹配，并在该实例的函数执行中重用。对于连接和客户端，推荐使用单体生命周期服务，例如<code class="fe nl nm nn na b">SqlConnection</code>或<code class="fe nl nm nn na b">HttpClient</code>实例。</li></ul><blockquote class="no np nq"><p id="5087" class="jq jr nr js b jt ju jv jw jx jy jz ka ns kc kd ke nt kg kh ki nu kk kl km kn im bi translated"><em class="it">依赖注入容器只保存显式注册的类型</em>。唯一可作为可注入类型的服务是在<code class="fe nl nm nn na b"><em class="it">Configure</em></code>方法中设置的服务。因此，像<code class="fe nl nm nn na b"><em class="it">BindingContext</em></code>和<code class="fe nl nm nn na b"><em class="it">ExecutionContext</em></code>这样的函数特定类型在设置过程中不可用，也不能作为可注入类型。</p></blockquote><p id="5ff9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，重新运行项目；在输出窗口中，你可以看到Azure函数可以找到Startup类。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nv"><img src="../Images/377cef3a47732c34e9ae686fda4243ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4h0NqxlWXDn1BTsH6M2HQ.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">如果它找到了启动，您应该会看到这条消息。</figcaption></figure><h2 id="6ee7" class="kw kx it bd ky kz la dn lb lc ld dp le kb lf lg lh kf li lj lk kj ll lm ln lo bi translated">使用选项和设置</h2><p id="bef2" class="pw-post-body-paragraph jq jr it js b jt lp jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn im bi translated">每个应用程序至少需要一些选项和设置。在Azure Functions app中，这些设置保存在<strong class="js iu"> local.settings.json </strong>文件中。</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="1a70" class="kw kx it na b gy ne nf l ng nh">{<br/>    "IsEncrypted": false,<br/>    "Values": {<br/>        "AzureWebJobsStorage": "",<br/>        "FUNCTIONS_WORKER_RUNTIME": "dotnet",<br/>        <br/>        "AppInfo:Title": "Hello World",<br/>        "AppInfo:LogInformation": false<br/>    }<br/>}</span></pre><p id="80a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比如在我的app里，我定义了两个选项:<strong class="js iu"> Title </strong>和<strong class="js iu"> LogInformation </strong>。为了处理这些值，我只需要创建一个名为<strong class="js iu"> AppInfo </strong>的类，并为它创建这些属性。</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="520a" class="kw kx it na b gy ne nf l ng nh">namespace AzureFunctions.Ioc.Configurations<br/>{<br/>    public class AppInfo<br/>    {<br/>        public string Title { get; set; }<br/>        public bool LogInformation { get; set; }<br/>    }<br/>}</span></pre><p id="f0fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nr">您可以随意更改类名，但是类名应该与JSON文件中的选项相同。</em></p><p id="ab32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在启动类中，在配置方法中，需要注册配置类。以下代码注册项目的“AppInfo”设置:</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="8a2a" class="kw kx it na b gy ne nf l ng nh">builder.Services.AddOptions&lt;AppInfo&gt;()<br/>    .Configure&lt;IConfiguration&gt;((settings, configuration)<br/>     =&gt; configuration.GetSection("AppInfo").Bind(settings));</span></pre><p id="494a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我有一个叫HelloWorld的服务。它只有一种打招呼的方法。在配置方法中注册服务。</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="1fd4" class="kw kx it na b gy ne nf l ng nh">builder.Services.AddTransient&lt;IHelloWorld, HelloWorld&gt;();</span></pre><p id="1364" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用以下代码替换Azure函数文件的内容:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="463e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构造函数注入用于使依赖关系在函数中可用。你可以在上面的例子中看到。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nw"><img src="../Images/6c72b01c6b30a9d1cbeae1efd4584db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*I0hx30JvaDI46CrrNig76Q.gif"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">运行和调试的最终结果</figcaption></figure></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h2 id="2a4f" class="kw kx it bd ky kz la dn lb lc ld dp le kb lf lg lh kf li lj lk kj ll lm ln lo bi translated"><strong class="ak">结论</strong></h2><p id="7dc8" class="pw-post-body-paragraph jq jr it js b jt lp jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn im bi translated">我们学习了如何创建一个新的Azure函数，如何使用IoC向函数注入服务或设置。下一步是什么？你可以在微软文档上阅读更多关于Azure功能的最佳实践。</p></div></div>    
</body>
</html>