<html>
<head>
<title>TypeScript: isNullish, nonNullish and assertNonNullish</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript: isNullish、nonNullish和assertNonNullish</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-isnullish-nonnullish-and-assertnonnullish-557deb6e8b17?source=collection_archive---------2-----------------------#2022-12-30">https://itnext.io/typescript-isnullish-nonnullish-and-assertnonnullish-557deb6e8b17?source=collection_archive---------2-----------------------#2022-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e55d750af4e000a3b783f0b0d65dd5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WuofP-xnSvOh6tab"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/fr/@shoots_of_bapt_" rel="noopener ugc nofollow" target="_blank">巴蒂斯特·比松</a></figcaption></figure><p id="22cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在<a class="ae kf" href="https://nns.ic0.app/" rel="noopener ugc nofollow" target="_blank"> NNS-dapp </a>中实现了一些宝石，让我们的开发人员的日常生活更加轻松。其中，下面三个小的<a class="ae kf" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>函数被证明是非常有用的。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="75ee" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">isNullish</h1><p id="630c" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">你多久编写一次<code class="fe mo mp mq mr b">if…else</code>语句来检查一个对象是<code class="fe mo mp mq mr b">undefined</code>还是<code class="fe mo mp mq mr b">null</code>？</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="3ce9" class="na lm it mr b be nb nc l nd ne">// Pseudo code (assuming optional chaining does not exist 😉)<br/>const test = (obj: MyObject | undefined | null) =&gt; {<br/>    if (obj === undefined || obj === null) {<br/>        return;<br/>    }<br/><br/>    obj.fn();<br/>}</span></pre><p id="7c3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多亏了<a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>和<a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" rel="noopener ugc nofollow" target="_blank">类型谓词</a>，我们开发了一个助手，让我们在保持类型安全的同时避免代码重复。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="3b03" class="na lm it mr b be nb nc l nd ne">export const isNullish = &lt;T&gt;(argument: T | undefined | null): argument is undefined | null =&gt;<br/>   argument === null || argument === undefined;</span></pre><p id="559d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">泛型<code class="fe mo mp mq mr b">T</code>的使用将把函数的使用范围扩大到我们在项目中声明的类型。</p><p id="4f05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至于类型保护，它缩小了TypeScript的范围，以理解变量确实来自特定的预期类型。换句话说，这个函数使TypeScript理解这个参数——如果它匹配函数的检查——确实是<code class="fe mo mp mq mr b">undefined</code>或<code class="fe mo mp mq mr b">null</code>。</p><p id="bec6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下使用助手:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="0d20" class="na lm it mr b be nb nc l nd ne">const test = (obj: MyObject | undefined | null) =&gt; {<br/>    // 1. Avoid code duplication<br/>    if (isNullish(obj)) {<br/>        return;<br/>    }<br/><br/>    // 2. TypeScript checks it is defined<br/>    obj.fn();<br/>}</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="fe7b" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">非努利语</h1><p id="9eb7" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">有时候我们需要相反的东西，我们需要知道某个东西是否被定义。虽然我们可以否定前面的速记函数，以了解情况是否如此，但我们也希望保持类型安全。</p><p id="21c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以通过使用实用程序<a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullabletype" rel="noopener ugc nofollow" target="_blank">不可空</a>通过排除<code class="fe mo mp mq mr b">undefined</code>和<code class="fe mo mp mq mr b">null</code>来构造类型来实现。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="bf0c" class="na lm it mr b be nb nc l nd ne">export const nonNullish = &lt;T&gt;(argument: T | undefined | null): argument is NonNullable&lt;T&gt; =&gt;<br/>   !isNullish(argument);</span></pre><p id="9939" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，TypeScript将理解确实定义了一个对象。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="0c05" class="na lm it mr b be nb nc l nd ne">const test = (obj: MyObject | undefined | null) =&gt; {<br/>    //1. Avoid code duplication<br/>    if (nonNullish(obj)) {<br/>        // 2. TypeScript checks it is defined<br/>        obj.fn();<br/>    }<br/>}</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="7393" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">assertNonNullish</h1><p id="6727" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">除了检查指定的条件是否正确之外，如果不正确，抛出错误也很方便。特别是开发带有断言模式的防护。</p><p id="6717" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以用TypeScript 3.7中引入的<a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html" rel="noopener ugc nofollow" target="_blank">断言签名</a>概念来增强我们之前开发的功能。</p><p id="9b29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mo mp mq mr b">asserts</code>关键字和一个条件，我们可以让TypeScript知道一个助手将执行一个检查，如果条件不满足就抛出一个错误。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="023b" class="na lm it mr b be nb nc l nd ne">export class NullishError extends Error {}<br/><br/>export const assertNonNullish: &lt;T&gt;(<br/>   value: T,<br/>   message?: string<br/>) =&gt; asserts value is NonNullable&lt;T&gt; = &lt;T&gt;(value: T, message?: string): void =&gt; {<br/>   if (isNullish(value)) {<br/>      throw new NullishError(message);<br/>   }<br/>};</span></pre><p id="d1df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应用到我们前面的代码片段，我们可以转换函数来执行代码，只有当警卫是匹配的。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="601f" class="na lm it mr b be nb nc l nd ne">const test = (obj: MyObject | undefined | null) =&gt; {<br/>    // 1. Avoid code duplication<br/>    // 2. TypeScript understands it might throw an error<br/>    assertNonNullish(obj);<br/>        <br/>    // 3. TypeScript checks it is defined<br/>    obj.fn();<br/>}</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="b77e" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="980e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我发现这些助手非常有用，以至于我现在在我最近的作品中使用它们——包括我新的“秘密疯狂”副业——我打赌你也会这样做😁。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="75c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更多冒险，请在🖖的推特上关注我</p></div></div>    
</body>
</html>