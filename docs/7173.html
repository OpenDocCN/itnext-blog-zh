<html>
<head>
<title>Learning by auditing Kubernetes manifests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过审核Kubernetes清单来学习</h1>
<blockquote>原文：<a href="https://itnext.io/learning-auditing-kubernetes-manifests-2a82db24f8a7?source=collection_archive---------8-----------------------#2022-07-04">https://itnext.io/learning-auditing-kubernetes-manifests-2a82db24f8a7?source=collection_archive---------8-----------------------#2022-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9aace58ea0fae4121a19edcccfc429db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QV3iirC2EyPjBamTH56LzQ.jpeg"/></div></div></figure><p id="5271" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">去年，我在大英博物馆举行的全国DevOps会议上发言。我之前已经参观过这个博物馆了，但是说起来那是一次奇妙的经历。此外，我们有几个小时完全属于自己的博物馆。如果你曾经参观过那个地方，你知道我的意思。</p><p id="bd7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">反正我也参加了一个关于<a class="ae kw" href="https://www.checkov.io/" rel="noopener ugc nofollow" target="_blank"> Checkov </a>的讲座:</p><blockquote class="kx ky kz"><p id="803a" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq"> Checkov扫描云基础设施配置，在部署之前发现错误配置。</em></p><p id="d554" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq"> Checkov使用通用命令行界面来管理和分析跨平台的基础架构代码(IaC)扫描结果，如Terraform、CloudFormation、Kubernetes、Helm、ARM模板和无服务器框架。</em></p></blockquote><p id="7cf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">演讲结束后，我想试一试。虽然我不是一个超级云用户，但我在我的几个演示中使用了Kubernetes。我安装了CLI，在这个<a class="ae kw" href="https://github.com/hazelcast-demos/zerodowntime/tree/master/infrastructure/kube" rel="noopener ugc nofollow" target="_blank">文件夹</a>上启动，只是为了好玩。有趣的是，我学到了很多<em class="la"/>。</p><p id="2c66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们先快速总结一下:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="975b" class="ln lo iq lj b gy lp lq l lr ls">checkov -d infrastructure/kube/ --quiet --compact | grep CKV | sort --unique</span></pre><p id="5624" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该命令输出我违反的所有规则。</p><p id="2511" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我知道其中一些，尽管我不打算在我的上下文中修复它们。例如，请求和限制在生产中是有意义的，但是在我的演示中我不关心它们。</p><p id="d418" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其他的对我来说是全新的。我很高兴在这里分享我的TIL(或没有)。</p><h1 id="53f2" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">更喜欢摘要而不是标签</h1><ul class=""><li id="a46c" class="mq mr iq ka b kb ms kf mt kj mu kn mv kr mw kv mx my mz na bi translated"><em class="la">规则</em> : <a class="ae kw" href="https://docs.bridgecrew.io/docs/bc_k8s_39" rel="noopener ugc nofollow" target="_blank"> CKV_K8S_43 —确保使用摘要选择图像</a></li><li id="2c06" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="la">严重性</em>:中等</li></ul><p id="8cb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我以前被这只咬过。即使我会保持原样，它也值得一个解释。并且解释为<strong class="ka ir">图像标签不是不可变的</strong>。</p><p id="84bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">标签只是指向特定图像的指针。发布者可以将现有标签指向另一个图像。在这种情况下，构建不是等幂的，因为基础映像可能从一个构建变化到另一个构建。</p><p id="76e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个演示，我在本地机器上构建图像，这样保留标签就有意义了。我可以更新依赖项的版本，重新构建，并获得最新构建的映像。</p><h1 id="d34b" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">明确禁止权限提升</h1><ul class=""><li id="7f08" class="mq mr iq ka b kb ms kf mt kj mu kn mv kr mw kv mx my mz na bi translated"><em class="la">规则</em> : <a class="ae kw" href="https://docs.bridgecrew.io/docs/bc_k8s_19" rel="noopener ugc nofollow" target="_blank"> CKV_K8S_20 —确保集装箱不会以AllowPrivilegeEscalation运行</a></li><li id="f850" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="la">严重性</em>:中等</li></ul><p id="2d26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一次的出现有点出乎意料。要理解这个问题，我们需要阅读相关文档:</p><blockquote class="kx ky kz"><p id="fba5" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><strong class="ka ir"><em class="iq">allowprivilegescalation</em></strong><em class="iq">—决定是否允许用户将容器的安全上下文设置为</em> <code class="fe ng nh ni lj b"><em class="iq">allowPrivilegeEscalation=true</em></code> <em class="iq">。这默认为allowed，以便不破坏setuid二进制文件。将它设置为</em> <code class="fe ng nh ni lj b"><em class="iq">false</em></code> <em class="iq">可以确保容器的子进程不会获得比其父进程更多的特权。</em></p><p id="f48a" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae kw" href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Pod安全策略—权限提升</em> </a></p></blockquote><p id="a748" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总结一下:<strong class="ka ir">默认情况下，容器的子进程可以获得比其父进程</strong>更多的特权。</p><p id="0d87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个相当严重的问题。请注意，Pod安全策略本身在1.21版中已被否决，并将在1.25版中被删除。在该版本之前，应该始终将该属性显式设置为<code class="fe ng nh ni lj b">false</code>。</p><h1 id="2d55" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">设置安全上下文</h1><ul class=""><li id="81e8" class="mq mr iq ka b kb ms kf mt kj mu kn mv kr mw kv mx my mz na bi translated"><em class="la">规则</em> : <a class="ae kw" href="https://docs.bridgecrew.io/docs/bc_k8s_28" rel="noopener ugc nofollow" target="_blank"> CKV_K8S_30 —确保安全上下文应用于pod和容器</a></li><li id="1202" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="la">严重性</em>:低</li></ul><p id="fc47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然严重程度被标记为低，但我认为这条规则是必不可少的。每个箱或集装箱在货单中可以有一个<code class="fe ng nh ni lj b">securityContext</code>部分。该部分有许多不同的字段:</p><ul class=""><li id="7a4f" class="mq mr iq ka b kb kc kf kg kj nj kn nk kr nl kv mx my mz na bi translated"><code class="fe ng nh ni lj b">runAsNonRoot</code>、<code class="fe ng nh ni lj b">runAsUser</code>和<code class="fe ng nh ni lj b">runAsGroup</code>:参见下面的<em class="la">不作为根</em>运行</li><li id="02f5" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe ng nh ni lj b">seccompProfile</code>:参见下面的<em class="la">设置秒补偿轮廓</em></li><li id="eed0" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe ng nh ni lj b">fsGroup</code>和<code class="fe ng nh ni lj b">fsGroupChangePolicy</code></li><li id="ea14" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe ng nh ni lj b">seLinuxOptions</code></li><li id="45c3" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe ng nh ni lj b">supplementalGroups</code></li><li id="8472" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe ng nh ni lj b">sysctls</code></li><li id="4357" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe ng nh ni lj b">windowsOptions</code></li></ul><p id="be3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中一些在下面的章节中有更详细的描述，但是完整的描述不仅仅是一篇介绍性的博客文章。如果你想潜得更深，请查阅<a class="ae kw" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#securitycontext-v1-core" rel="noopener ugc nofollow" target="_blank">的相关文档</a>。</p><p id="aba0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，Snykt写了一篇<a class="ae kw" href="https://snyk.io/blog/10-kubernetes-security-context-settings-you-should-understand/" rel="noopener ugc nofollow" target="_blank">很棒的文章</a>来解释最重要的问题。</p><h1 id="edd5" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">不要以root身份运行</h1><ul class=""><li id="2b7e" class="mq mr iq ka b kb ms kf mt kj mu kn mv kr mw kv mx my mz na bi translated"><em class="la">规则</em> : <a class="ae kw" href="https://docs.bridgecrew.io/docs/bc_k8s_22" rel="noopener ugc nofollow" target="_blank"> CKV_K8S_23 —最小化根容器的接纳</a></li><li id="81d5" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="la">严重性</em>:中等</li></ul><p id="bece" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为这一个是相当众所周知的，但它仍然值得重复。容器是一个利用内核特性的Linux进程:</p><ul class=""><li id="ab41" class="mq mr iq ka b kb kc kf kg kj nj kn nk kr nl kv mx my mz na bi translated"><em class="la">控制组</em>限制、说明和隔离资源使用，<em class="la">例如</em> CPU、内存、磁盘I/O、网络等。</li><li id="8b15" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="la">名称空间</em>划分内核资源，使得一组进程看到一组资源，而另一组进程看到不同的资源</li></ul><p id="ae4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然两者都提供了进程隔离，但并不是万无一失的。如果以根用户身份运行的容器受到威胁，攻击者可以使用额外的权限进行进一步攻击。要解决此问题，请使用以下代码片段:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="ae6d" class="ln lo iq lj b gy lp lq l lr ls">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: &lt;name&gt;<br/>spec:<br/>    securityContext:<br/>    runAsNonRoot: true<br/>    runAsUser: &lt;user&gt;</span></pre><h1 id="6550" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">设置高UID用户</h1><ul class=""><li id="49f4" class="mq mr iq ka b kb ms kf mt kj mu kn mv kr mw kv mx my mz na bi translated"><em class="la">规则</em> : <a class="ae kw" href="https://docs.bridgecrew.io/docs/bc_k8s_37" rel="noopener ugc nofollow" target="_blank"> CKV_K8S_40 —确保容器以高UID运行，以避免主机冲突</a></li><li id="a6c4" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="la">严重性</em>:低</li></ul><p id="6ea8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在之前的规则检查中，我们没有以<code class="fe ng nh ni lj b">root</code>的身份运行，也就是UID 1。然而，即使使用其他uid，如果容器受到危害，我们也有在主机系统上冒充另一个用户的风险。为了大幅降低概率，已配置的用户应该只从UID 10，000开始。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="cb95" class="ln lo iq lj b gy lp lq l lr ls">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: &lt;name&gt;<br/>spec:<br/>    securityContext:<br/>    runAsUser: &lt;+10,000&gt;</span></pre><h1 id="98e7" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">设置seccomp配置文件</h1><ul class=""><li id="7054" class="mq mr iq ka b kb ms kf mt kj mu kn mv kr mw kv mx my mz na bi translated"><em class="la">规则</em> : <a class="ae kw" href="https://docs.bridgecrew.io/docs/bc_k8s_30" rel="noopener ugc nofollow" target="_blank"> CKV_K8S_31 —确保seccomp配置文件设置为Docker/Default或Runtime/Default </a></li><li id="f3dd" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="la">严重性</em>:低</li></ul><blockquote class="kx ky kz"><p id="e2a3" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">安全计算模式(</em> <code class="fe ng nh ni lj b"><em class="iq">seccomp</em></code> <em class="iq">)是Linux内核的一个特性。您可以使用它来限制容器内可用的操作。</em> <code class="fe ng nh ni lj b"><em class="iq">seccomp()</em></code> <em class="iq">系统调用在调用进程的seccomp状态下运行。您可以使用此功能来限制您的应用程序的访问。</em></p><p id="b464" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">默认的</em> <code class="fe ng nh ni lj b"><em class="iq">seccomp</em></code> <em class="iq">配置文件为使用seccomp运行容器提供了一个合理的默认值，并禁用了300+个系统调用中的大约44个。它在提供广泛的应用程序兼容性的同时具有适度的保护性。</em></p><p id="f72c" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae kw" href="https://docs.docker.com/engine/security/seccomp/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">停靠站的安全配置文件</em> </a></p></blockquote><p id="ef2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决该问题取决于您的Kubernetes集群的版本:</p><ul class=""><li id="c3f1" class="mq mr iq ka b kb kc kf kg kj nj kn nk kr nl kv mx my mz na bi translated">对于Kubernetes 1.18，对救援的注释:</li></ul><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="4ad3" class="ln lo iq lj b gy lp lq l lr ls">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: &lt;name&gt;<br/>  annotations:<br/>    seccomp.security.alpha.kubernetes.io/pod: "runtime/default"</span></pre><ul class=""><li id="b66d" class="mq mr iq ka b kb kc kf kg kj nj kn nk kr nl kv mx my mz na bi translated">对于Kubernetes 1.19+，属性<code class="fe ng nh ni lj b">securityContext</code>具有一个<code class="fe ng nh ni lj b">secompProfile</code>:</li></ul><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="64c5" class="ln lo iq lj b gy lp lq l lr ls">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: &lt;name&gt;<br/>spec:<br/>  securityContext:<br/>    seccompProfile:<br/>      type: RuntimeDefault<br/>  containers:<br/>    ...</span></pre><h1 id="7504" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="587c" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj nm kl km kn nn kp kq kr no kt ku kv ij bi translated">如果您想在<code class="fe ng nh ni lj b">seccomp</code>执行策略，请根据您的Kubernetes版本，查看与<a class="ae kw" href="https://kubernetes.io/docs/concepts/security/pod-security-admission/" rel="noopener ugc nofollow" target="_blank"> Pod安全许可</a>或<a class="ae kw" href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" rel="noopener ugc nofollow" target="_blank"> Pod安全策略</a>相关的文档。</p><p id="2f3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，运行分析/审计工具是深入了解一个主题的好方法。我已经用Checkov在Kubernetes上做过了，但是这类工具的数量已经足够大，如果你喜欢的话，可以获得即时的知识提升。当然，这不会让你马上成为某个领域的专家，但这是一个很好的开始。</p><p id="7f75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="cff7" class="mq mr iq ka b kb kc kf kg kj nj kn nk kr nl kv mx my mz na bi translated"><a class="ae kw" href="https://www.checkov.io/" rel="noopener ugc nofollow" target="_blank"> Checkov:适用于所有人的策略代码</a></li><li id="eca4" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae kw" href="https://docs.bridgecrew.io/docs/kubernetes-policy-index" rel="noopener ugc nofollow" target="_blank"> Checkov: Kubernetes政策指数</a></li><li id="fbe2" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae kw" href="https://martinheinz.dev/blog/41" rel="noopener ugc nofollow" target="_blank">用seccomp强化Docker和Kubernetes】</a></li><li id="63ca" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae kw" href="https://snyk.io/blog/10-kubernetes-security-context-settings-you-should-understand/" rel="noopener ugc nofollow" target="_blank"> 10 Kubernetes你应该了解的安全上下文设置</a></li><li id="af57" class="mq mr iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae kw" href="https://kubernetes.io/docs/concepts/security/pod-security-admission/" rel="noopener ugc nofollow" target="_blank"> Pod安全准入</a></li></ul></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="e159" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la">最初发表于</em> <a class="ae kw" href="https://blog.frankel.ch/learning-auditing-kubernetes-manifests/" rel="noopener ugc nofollow" target="_blank"> <em class="la">一个Java怪胎</em></a><em class="la">2022年7月4日</em></p></div></div>    
</body>
</html>