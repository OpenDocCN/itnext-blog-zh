# 如何在 PHP 中安全地实现密码恢复

> 原文：<https://itnext.io/how-to-implement-password-recovery-securely-in-php-db2275ab3560?source=collection_archive---------0----------------------->

![](img/c20874feea9dd9231611e6fe90154339.png)

**前言**

本文旨在向 PHP 开发人员介绍正确实现安全特性的思维过程。我们都曾经是 PHP 开发新手，认为如果其中有 md5()，那么它一定是安全的。

这篇文章背后的主要动机是建立在 PHP 社区的努力之上，使安全最佳实践在大量陈旧和不安全的建议中更加明显。当我在 2017 年 6 月出于沮丧首次写下这篇文章时，谷歌搜索“密码恢复 php”的前 10 个结果中有 9 个是不安全的实现。三年多后，这些相同的结果仍然存在。这是我们作为一个社区给所有语言新手的建议。这种情况必须改变，所以这是我的一点微薄之力。

互联网上的安全建议(尤其是 PHP 安全建议)已经过时了。如果你在几年后读到这篇文章，那就要持保留态度，尽管它背后的思维过程仍然适用。

说完了，让我们开始吧。

# 如何(不)在 PHP 中实现密码恢复机制

如果你在互联网上呆过一段时间，你可能已经使用过某个网站的密码恢复功能。标准的做法是要求用户提供他们的电子邮件地址(当他们在网站注册时，您会要求提供)，并向该地址发送一封带有链接的电子邮件。该链接包含一些特定的信息，让应用程序知道正在为哪个用户进行密码恢复。然后它会要求输入新密码，我们就都准备好了。

如果你在想“为什么我不把他们已经有的密码用电子邮件发给他们呢？”这意味着你一开始就没有散列它们。在你继续阅读之前去做那件事。不开玩笑。PHP 提供了一种安全的方式来实现[密码散列和验证](https://www.php.net/manual/en/ref.password.php)，并且默认值是合理的。进一步的阅读材料可以在[这里](https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016)找到。

你可能会想“嘿，连我都知道你不应该这么做！”，但至少有几个谷歌搜索结果中的例子将密码存储在数据库中，没有进行哈希运算。因此，它似乎值得重复，并把我们带到我们的第一个不要。

**不要 1:不要在数据库中存储明文密码。**

您的站点在将密码保存到数据库之前是否对其进行了哈希处理？很好，我们继续。

回到给用户发电子邮件的链接，这样他们就可以重置他们的密码。让我们假设您站点的密码恢复 url 是:

[https://your.site/password_recovery.php](https://your.site/password_recovery.php)

一个简单的解决方案(再次参见顶部的 Google 搜索结果)可能是这样做:

【https://your.site/password_recovery.php?user=john@gmail.com 号

这不安全。为什么？因为如果攻击者知道某人的电子邮件，他就可以更改他的密码。这是我们第二次不要了。

**不要 2:不要使用公共信息作为密码恢复令牌**

您可能会想:“我还能从用户那里获得哪些我可以使用的信息？也许是用户名？”

[https://your.site/password_recovery.php?user_id=13](https://your.site/password_recovery.php?user_id=13)

这也不安全。为什么？虽然攻击者可能不知道他们正在更改哪个用户的密码，但他可以锁定用户的帐户。此外，如果您的站点有某种管理功能，那么 user_id=1 很可能是一个管理用户，现在您已经让自己陷入了痛苦的世界。

**不要 3:不要使用顺序 id 号作为密码恢复令牌。**

此时，您可能已经意识到不能直接使用数据库之外的任何东西。但是，在尝试解决这个问题时，您会想:“让我们使用 md5，这应该可以防止攻击者猜测用户的权利？”。所以你试着这样做:

```
$token = md5($user["email"]);
```

[https://your.site/password_recovery.php?token=$token](https://your.site/password_recovery.php?token=$token)

你甚至可以使用 mysql 中的 md5 函数直接在数据库中查找！

这也不安全。为什么？因为如果我能猜出令牌是如何生成的，例如:通过查看我的令牌(或者你已经在 github 中发布了代码，或者说，我猜出了你复制并粘贴了前 10 个 google 实现中的哪一个)，那么我就可以为每个人生成令牌。正如伟大的克劳德·香农(Claude Shannon)所说:“我们应该在假设敌人会立即完全熟悉系统的情况下设计系统”。

**不要 4:不要让你的安全依赖于你的代码是秘密的这个事实。不会的。**

有一些不光彩的提及。来自谷歌搜索结果中的两个:

```
$token = md5(18247*2567 + $user["id"]); $salt = "SOME!BIG#RANDOM@STRING1337"
$token = md5($salt.$user["email"])
```

两者都落入别 4。如果我知道您的哈希是如何构建的，我就可以为您的所有用户创建恢复令牌。即使你确定别 4 对你不适用，也不要用这些。它们容易受到超出本文范围的其他攻击，但是您可以自己随意破解它们。

作为一个额外的注意，这些都失败了“不满的(前)同事攻击”，即:你的同事，或你自己，可以为任何用户创建令牌，而不需要与系统交互。在这种系统中，这不是一个好的属性。

**不要 5:不要以了解系统的人也可以离线生成的方式生成令牌**

“但是等等！”，你可能会想。“如果我们使用加密而不是散列会怎么样？我可以将密钥置于版本控制之外，我们应该防止上面的问题，对吗？”

尽管您可以:

```
$token = encrypt($user["email"],$some_key);
```

这带来的问题比它解决的更多。

1.  您需要找到一种安全处理密钥的方法。
2.  如果密钥泄露，并且您想要更改它，您将会破坏以前的令牌。
3.  根据算法和密钥大小，密钥可能是可恢复的，因为明文和算法是已知的(参见第 4 页)。
4.  如果密钥被恢复(无论是通过暴力还是由于其他弱点),那么攻击者(或你的同事，见第 5 页)可以为任何离线用户生成重置令牌。

**不要 6:如果可以避免，就不要使用加密技术。它带来的问题比它解决的更多。而你大概** [**反正不知道怎么安全地实现**](http://www.cryptofails.com/page/18)

此时，可能没有更多的方法来使用您已经拥有的数据来生成重置令牌。相反，您必须从一些其他数据中生成它，并将其存储在某个地方，比如用户表中的一个新列。这确实解决了离线生成有效令牌的问题。

**Do 1:生成不依赖于用户数据的令牌。**

从现在开始，我们正在改变攻击模式。到目前为止，攻击者一直在猜测与特定用户相关联的令牌。这已经不可能了。攻击者所能做的就是触发用户的密码重置，并猜测生成了什么令牌。

"那么我该如何生成这个令牌呢？"，你扪心自问。也许使用 PHP 已经给我们的东西，比如 [uniqid](https://www.php.net/manual/en/function.uniqid.php) :

```
php > echo uniqid();
593aceadf16aa
```

这应该是一个随机的，唯一的 id，对吗？？？

![](img/d7657fd2b169a87e93f202def6567e9f.png)

uniqid 的输出专门从当前服务器时间生成。攻击者控制他何时请求密码更改，因此即使它使用的分辨率高达微秒，他也可能将范围缩小到几毫秒，使 id 在几千次尝试后就可被猜出

**不要 7:不要根据时间生成您的令牌，它们是可猜测的。**

注意:散列一个可猜测的令牌不会增加任何安全性。它看起来确实更安全，但事实并非如此。这就像在猜测某人的密码时，你并不关心他的密码的哈希是什么，如果你只能猜测用户很懒，他们的密码就是字面上的“密码”。

此时，作为一个聪明的男人/女人，你可能会说:“如果我想要随机的东西，为什么我要用 uniqid 呢？我就用 PHP 的随机数函数吧！”

```
$token = rand(); // Value between 0 and 2147483647.
```

(许多)随机数生成器的特点是它们是确定性的。如果你知道几个输出，你实际上可以知道下一个会是什么。是的，你没看错。不，我没疯。如果你不相信我，去读读[这个](http://phpsecurity.readthedocs.io/en/latest/Insufficient-Entropy-For-Random-Values.html)和[这个](https://softwareengineering.stackexchange.com/questions/76229/predicting-the-output-of-phps-rand)。回来的时候别忘了你的锡纸帽子。

[rand()](https://www.php.net/manual/en/function.rand) 和 [mt_rand()](https://www.php.net/manual/en/function.mt-rand.php) 都容易受到这种攻击。鲜为人知的 [lcg_value](https://www.php.net/manual/en/function.lcg-value) 也是。PHP 7 [引入了](http://php.net/manual/en/migration70.new-features.php#migration70.new-features.csprng-functions) [random_bytes()](https://www.php.net/manual/en/function.random-bytes.php) 和 [random_int()](https://www.php.net/manual/en/function.random-int.php) ，它们以一种对这类应用安全的方式返回随机数据，即它们是加密安全的随机数生成器。

**不要 8:不要使用 rand、mt_rand 或 lcg_value 作为任何安全相关的随机数来源。**

**Do 2:对安全随机数使用 random_int 或 random_bytes。**

那么，如何构建一个随机且不可预测的令牌呢？

一个简单的方法是:

```
$length = 16; // Adjust length to fit your new paranoia level. 16 is probably a sane default and the same length as md5 (if you are migrating from a method that uses it)
$token = bin2hex(random_bytes($length)); // bin2hex output is url safe.
```

就这样，我们结束了。我们有一个安全令牌用于密码恢复。

现在，您可以开始实现其余的功能了。不过，当你这么做的时候，有几件额外的事情你需要记住。

重置令牌不应该永远有效，所以您应该在令牌旁边添加一个新列，注明创建日期，并使用它来检查它是否应该被接受。此外，它们应该是一次性令牌。因此，一旦用户重置了密码，就要删除令牌。

**做 3:为你的重置令牌设置一个生命周期，越短越好。1 小时可能是一个合理的默认值。**

**做 4:使用后丢弃重置令牌。**

# **Wrapping up/TL；博士**

综上所述，您的一般应用程序流程应该如下所示:

1)用户请求重置密码，并提供了他们的电子邮件

2)使用电子邮件地址在数据库中查找用户

3)安全地创建令牌，并将其与创建时间一起存储在数据库中。

例如:

```
$token = bin2hex(random_bytes(16));
```

4)发送一封电子邮件，其中包含指向您的密码恢复页面的链接，以及作为查询字符串参数的令牌

5)使用令牌在数据库中查找用户，如果找到且未过期，提示他输入新密码

6)将新密码存储在数据库中

7)从数据库中删除已使用的令牌。

**记住，千万不要:**

1)不要将明文密码存储在数据库中。

2)不要使用公共信息作为密码恢复令牌。

3)不要使用连续的 id 号作为密码恢复令牌。

4)不要让你的安全性依赖于你的代码是秘密的这一事实。

5)不要以离线生成令牌的方式生成令牌

6)不要使用加密

7)不要根据时间来生成令牌

8)不要使用 rand、mt_rand 或 lcg_value 作为任何安全相关的随机数来源

**记住，做:**

1)生成不依赖于用户数据的令牌，并将它们存储在数据库中。

2)对安全随机数使用 random_int 或 random_bytes。

3)为您的重置令牌设置生命周期。

4)使用后丢弃重置令牌。