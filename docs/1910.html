<html>
<head>
<title>You may need Laziness in your Javascript (Lazy Evaluation)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的Javascript中可能需要懒惰(懒惰评估)</h1>
<blockquote>原文：<a href="https://itnext.io/you-may-need-laziness-in-your-javascript-f03e8a2d4629?source=collection_archive---------3-----------------------#2019-02-22">https://itnext.io/you-may-need-laziness-in-your-javascript-f03e8a2d4629?source=collection_archive---------3-----------------------#2019-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2586ecfa127735cd8824724497fd592c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1iHc6IWc-ZjNVQgvTLCxQ.jpeg"/></div></div></figure><div class=""/><p id="716e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也许有些时候你过度使用了数组方法<strong class="kd jf"> map，reduce，filter，find等等。这可以让应用程序使用更多本该使用的内存。</strong></p><p id="99e8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个例子:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="fa13" class="li lj je le b gy lk ll l lm ln">const myArray = [1,2,3,4,5,6,7,8,9,10]</span><span id="2521" class="li lj je le b gy lo ll l lm ln">myArray<br/>  .map(<em class="lp">x</em> <em class="lp">=&gt;</em> x <strong class="le jf">*</strong> x)<br/>  .filter(<em class="lp">x</em> <em class="lp">=&gt;</em> x <strong class="le jf">%</strong> 3 <strong class="le jf">===</strong> 0)</span></pre><p id="e7e7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，你已经做过几次类似的事情了，这里的“问题”是什么，我们每次链接数组方法都要创建新的数组。也就是说<strong class="kd jf">。map </strong>用每个索引中的x创建另一个数组(<strong class="kd jf"> [ 1，4，9，16，25，36，49，64，81，100 ] </strong>)，然后创建另一个过滤后的数组<strong class="kd jf"> [ 9，36，81 ] </strong>在这种情况下，您可能不会有任何内存使用性能的问题，但是如果myArray非常大呢？你将再次创造另一个大的，一次又一次，直到你得到你想要的结果。</p><p id="3287" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这些情况下，带有iterables的惰性求值可能会很有用。但是首先，我们如何创建一个迭代器，以及它是如何工作的。</p><h1 id="7599" class="lq lj je bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">什么是迭代器？</h1><p id="df7d" class="pw-post-body-paragraph kb kc je kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">迭代器是一个对象，它定义了一个序列，当序列结束时可能会返回值，这些序列可以是有限的，也可以是无限的。</p><p id="4d2c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">迭代器对象将需要一个名为<strong class="kd jf"> Symbol.iterator </strong>的属性函数，该函数<strong class="kd jf"> </strong>将使用<strong class="kd jf"> next() </strong>方法返回另一个对象。那个<strong class="kd jf">下一个</strong>方法将是返回序列的每个值的方法，并且如果序列完成或者没有使用具有属性<strong class="kd jf"> value </strong>和<strong class="kd jf"> done </strong> as的对象</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="16a8" class="li lj je le b gy lk ll l lm ln">const JustOneIterator = {<br/>  [Symbol.iterator]: function () {<br/>    return {<br/>      next() {<br/>        return { done: false, value: 1 }<br/>      }<br/>    }<br/>  }<br/>}</span><span id="416b" class="li lj je le b gy lo ll l lm ln">const iterator = JustOneIterator[Symbol.iterator]()<br/>iterator.next() // { done: false, value: 1 }<br/>iterator.next() // { done: false, value: 1 }<br/>iterator.next() // { done: false, value: 1 }<br/>iterator.next() // { done: false, value: 1 }<br/>// this will never return done: true</span></pre><p id="41d7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，你可以看到一个无限序列的1。</p><p id="910c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们尝试一个有限数列</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="3ef1" class="li lj je le b gy lk ll l lm ln">const rangeIterator = (from, to = Infinity, step = 1) =&gt; ({<br/>  [Symbol.iterator]: function () {<br/>    let done = false<br/>    let value = 0<br/>    return {<br/>      next () {<br/>        value = from<br/>        done = from &gt; to<br/>        from = !done ? from + step : value<br/>        return { done: done, value: value }<br/>      }<br/>    }<br/>  }<br/>})</span><span id="802b" class="li lj je le b gy lo ll l lm ln">const iterator = rangeIterator(0, 4)[Symbol.iterator]()<br/>iterator.next() // { done: false, value: 0 }<br/>iterator.next() // { done: false, value: 1 }<br/>iterator.next() // { done: false, value: 2 }<br/>iterator.next() // { done: false, value: 3 }<br/>iterator.next() // { done: false, value: 4 }<br/>iterator.next() // { done: true, value: 5}</span><span id="c613" class="li lj je le b gy lo ll l lm ln">var range = rangeIterator(0, 4)</span><span id="6b6c" class="li lj je le b gy lo ll l lm ln">const arr = [...range] // [0, 1, 2, 3, 4]</span></pre><p id="52ae" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为这是一个有限迭代器，我们可以扩展成一个数组或者使用<strong class="kd jf"> Array.from </strong>方法从迭代器创建数组。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="6b9c" class="li lj je le b gy lk ll l lm ln">Array.from(range) // [0, 1, 2, 3, 4]</span></pre><p id="9cde" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们如何创建自己的iterables对象，以便映射、简化、过滤等。</p><figure class="kz la lb lc gt iv"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="169f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这个实用程序，我们现在可以做一些事情:</p><h2 id="a038" class="li lj je bd lr mu mv dn lv mw mx dp lz km my mz md kq na nb mh ku nc nd ml ne bi translated">对于有限的数组</h2><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="e387" class="li lj je le b gy lk ll l lm ln">const cubicPar = compose(<br/>  map.bind(null, x =&gt; x * x * x),<br/>  filter.bind(null, x =&gt; x %2 === 0)<br/>)</span><span id="cf0c" class="li lj je le b gy lo ll l lm ln">const fiveElements = take(10, cubicPar([1,2,3,4,5,6,7,8,9,10]))</span><span id="6b5b" class="li lj je le b gy lo ll l lm ln">getValue(fiveElements)<br/>// [ 8, 64, 216, 512, 1000 ]</span></pre><h2 id="ecfa" class="li lj je bd lr mu mv dn lv mw mx dp lz km my mz md kq na nb mh ku nc nd ml ne bi translated">用一个无限序列</h2><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="64c9" class="li lj je le b gy lk ll l lm ln">const Numbers = generate(function () {<br/>  let n = 0<br/>  return {<br/>    next: () =&gt; ({ done: false, value: n++ })<br/>  }<br/>})</span><span id="6edf" class="li lj je le b gy lo ll l lm ln">const cubirParRest = compose(<br/>  map.bind(null, x =&gt; x * x * x),<br/>  filter.bind(null, x =&gt; x %2 === 0),<br/>  take.bind(null, 10),<br/>  rest<br/>)</span><span id="9022" class="li lj je le b gy lo ll l lm ln">Array.from(cubirParRest(Numbers))<br/>// [ 8, 64, 216, 512, 1000, 1728, 2744, 4096, 5832 ]</span></pre><p id="52ab" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然我们设法从这些实用程序中创建了一些迭代器，我们不想总是组合我们的函数，相反我们想链接<strong class="kd jf">方法</strong>。我们可以在<strong class="kd jf">生成</strong>方法上添加一个依赖项</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="6b5d" class="li lj je le b gy lk ll l lm ln">const LazyIterable = {<br/>  value: function () {<br/>    return Array.from(this)<br/>  },<br/>  map: function (fn) {<br/>    return map(fn, this)<br/>  },<br/>  reduce: function (fn, seed) {<br/>    return reduce(fn, seed, this)<br/>  },<br/>  filter: function (fn) {<br/>    return filter(fn, this)<br/>  },<br/>  find: function (fn) {<br/>    return filter(fn, this).first()<br/>  },<br/>  first: function () {<br/>    return first(this)<br/>  },<br/>  rest: function () {<br/>    return rest(this)<br/>  },<br/>  until: function (fn) {<br/>    return until(fn, this)<br/>  },<br/>  take: function (numberToTake) {<br/>    return take(numberToTake, this)<br/>  }<br/>}</span><span id="3e8c" class="li lj je le b gy lo ll l lm ln">const Numbers = generate(function () {<br/>  let n = 0<br/>  return {<br/>    next: () =&gt; ({ done: false, value: n++ })<br/>  }<br/>}, LazyIterable)</span><span id="2c35" class="li lj je le b gy lo ll l lm ln">Numbers<br/>  .map(x =&gt; x * x * x)<br/>  .filter(x =&gt; x %2 === 0)<br/>  .take(10)<br/>  .rest()<br/>  .value()</span><span id="5a74" class="li lj je le b gy lo ll l lm ln">// [ 8, 64, 216, 512, 1000, 1728, 2744, 4096, 5832 ]</span></pre><p id="05de" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以做一个斐波那契数列</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="8730" class="li lj je le b gy lk ll l lm ln">const Fibonacci = generate(function () {<br/>  let n1 = 0<br/>  let n2 = 1<br/>  let value<br/>  return {<br/>    next: () =&gt; {<br/>      [value, n1, n2] = [n1, n2, n1 + n2]<br/>      return { value }<br/>    }<br/>  }<br/>}, LazyIterable)</span><span id="51bc" class="li lj je le b gy lo ll l lm ln">Fibonacci<br/>  .take(10)<br/>  .value()<br/>// [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ]</span><span id="59b8" class="li lj je le b gy lo ll l lm ln">Fibonacci<br/>  .map(x =&gt; x * 2)<br/>  .filter(x =&gt; x % 4 === 0)<br/>  .take(10)<br/>  .value()<br/>// returns 0, 4, 16, 68, 288, 1220, 5168, 21892, 92736, 392836 ]</span></pre><p id="80f4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们甚至可以创建一个LazyArray对象，从数组中扩展</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="ad23" class="li lj je le b gy lk ll l lm ln">const LazyIterableDescriptor = Object.keys(LazyIterable).reduce((acc, key) =&gt; {<br/>  acc[key] = { value: LazyIterable[key] }<br/>  return acc<br/>}, {})</span><span id="2ddc" class="li lj je le b gy lo ll l lm ln">function LazyArray () {<br/>  this.push.apply(this, arguments)<br/>}</span><span id="59d2" class="li lj je le b gy lo ll l lm ln">LazyArray.prototype = Object.create(Array.prototype, Object.assign({<br/>  constructor: {<br/>    value: LazyArray<br/>  }<br/>}, LazyIterableDescriptor))</span><span id="b571" class="li lj je le b gy lo ll l lm ln">LazyArray.from = function (iterable) {<br/>  const lazy = new LazyArray()</span><span id="af62" class="li lj je le b gy lo ll l lm ln">for (let element of iterable) {<br/>    lazy.push(element)<br/>  }<br/>  return lazy<br/>}</span><span id="9046" class="li lj je le b gy lo ll l lm ln">const lazy = new LazyArray(1,2,3,4,5) <br/>// or LazyArray.from([1,2,3,4,5])</span><span id="091c" class="li lj je le b gy lo ll l lm ln">lazy.value() // [1,2,3,4,5]<br/>lazy.push(6) // 6<br/>lazy.value() // [1,2,3,4,5,6]</span><span id="7a7a" class="li lj je le b gy lo ll l lm ln">lazy<br/>  .map(x =&gt; x * x * x)<br/>  .value()<br/>// [ 1, 8, 27, 64, 125, 216 ]</span></pre><p id="9ff9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以创建另一种类型对象，如<strong class="kd jf"> Stash </strong>、<strong class="kd jf"> LinkedList </strong>等等，它们都可以使用惰性迭代。</p><p id="fb96" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这些信息对你们中的一些人有用，并且你们可以开始在应用程序中使用懒惰。</p><h1 id="594e" class="lq lj je bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">关于性能</h1><p id="2b32" class="pw-post-body-paragraph kb kc je kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">如果我们运行这段代码(在我的电脑上)</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="392b" class="li lj je le b gy lk ll l lm ln">function arrayOfNumbers (n) {<br/>  const array = []<br/>  let i = 0<br/>  while (i &lt; n) {<br/>    array.push(i)<br/>    i++<br/>  }<br/>  return array<br/>}</span><span id="9381" class="li lj je le b gy lo ll l lm ln">const array = arrayOfNumbers(100000000)</span><span id="ca1e" class="li lj je le b gy lo ll l lm ln">let i = 0<br/>while (i &lt; 1000) {<br/>  i++<br/>  array<br/>    .map(x =&gt; x * x)<br/>    .filter(x =&gt; x % 2 === 0)<br/>    .reduce((acc, x) =&gt; acc + x)<br/>}</span></pre><p id="a86d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我得到了这个</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="65da" class="li lj je le b gy lk ll l lm ln">$ time node __tests__/array.js<br/>rss 67.5 MB<br/>heapTotal 54.04 MB<br/>heapUsed 32.11 MB<br/>external 0.01 MB</span><span id="bec1" class="li lj je le b gy lo ll l lm ln">real 0m57.297s<br/>user 0m54.974s<br/>sys 0m1.851s</span></pre><p id="08c4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果我运行这个</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="879f" class="li lj je le b gy lk ll l lm ln">const { LazyArray } = require('../lib/perezoso')</span><span id="0c9b" class="li lj je le b gy lo ll l lm ln">function arrayOfNumbers (n) {<br/>  const array = new LazyArray()<br/>  let i = 0<br/>  while (i &lt; n) {<br/>    array.push(i)<br/>    i++<br/>  }<br/>  return array<br/>}</span><span id="362a" class="li lj je le b gy lo ll l lm ln">const lazyArray = arrayOfNumbers(100000000)</span><span id="f6ec" class="li lj je le b gy lo ll l lm ln">let i = 0<br/>while (i &lt; 1000) {<br/>  i++<br/>  lazyArray<br/>    .map(x =&gt; x * x)<br/>    .filter(x =&gt; x % 2 === 0)<br/>    .reduce((acc, x) =&gt; acc + x)<br/>}</span></pre><p id="5c11" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成于</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="3871" class="li lj je le b gy lk ll l lm ln">$ time node __tests__/lazy2.js<br/>rss 33.38 MB<br/>heapTotal 19.21 MB<br/>heapUsed 9.36 MB<br/>external 0.01 MB</span><span id="b0d1" class="li lj je le b gy lo ll l lm ln">real 0m19.202s<br/>user 0m18.774s<br/>sys 0m0.692s</span></pre><p id="1c0b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是改变迭代器的一切</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="3a11" class="li lj je le b gy lk ll l lm ln">const { Lazy } = require('../lib/perezoso')</span><span id="3a01" class="li lj je le b gy lo ll l lm ln">const Numbers = Lazy.generate(function () {<br/>  let n = 0<br/>  return {<br/>    next () {<br/>      return { value: n++ }<br/>    }<br/>  }<br/>})</span><span id="38a7" class="li lj je le b gy lo ll l lm ln">const lazyArray = Numbers.take(100000000)</span><span id="0d62" class="li lj je le b gy lo ll l lm ln">let i = 0<br/>while (i &lt; 1000) {<br/>  i++<br/>  lazyArray<br/>    .map(x =&gt; x * x)<br/>    .filter(x =&gt; x % 2 === 0)<br/>    .reduce((acc, x) =&gt; acc + x)<br/>}</span></pre><p id="517b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我得到了这个</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="e741" class="li lj je le b gy lk ll l lm ln">$ time node __tests__/lazy.js<br/>rss 32.72 MB<br/>heapTotal 18.23 MB<br/>heapUsed 9.16 MB<br/>external 0.01 MB</span><span id="c7e9" class="li lj je le b gy lo ll l lm ln">real 0m12.556s<br/>user 0m12.218s<br/>sys 0m0.728s</span></pre><p id="ce6f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一件重要的事情是，如果我使用一个更大的<strong class="kd jf">arrayOfNumbers(100000000)</strong>乘*100(再加两个0)<strong class="kd jf">数组</strong>版本和<strong class="kd jf"> LazyArray </strong>版本会因内存错误而失败，但如果我使用唯一的迭代器示例(3rdone)就会完成</p><p id="3b01" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">愿原力与你同在</p><p id="053a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">【2019年5月9日更新</p><p id="b376" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用perezoso.js 的函数方法，我得到了一个与使用完全惰性对象非常相似的内存消耗结果，但是速度更快一些。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="91ea" class="li lj je le b gy lk ll l lm ln">$ time node scripts/funtional.js<br/>rss 32.92 MB<br/>heapTotal 18.71 MB<br/>heapUsed 10.12 MB<br/>external 0.01 MB</span><span id="0b2e" class="li lj je le b gy lo ll l lm ln">real 0m7.166s<br/>user 0m6.907s<br/>sys 0m0.557s</span><span id="3aaa" class="li lj je le b gy lo ll l lm ln">$ time node scripts/funtional2.js<br/>rss 32.45 MB<br/>heapTotal 17.23 MB<br/>heapUsed 7.23 MB<br/>external 0.01 MB</span><span id="67fe" class="li lj je le b gy lo ll l lm ln">real 0m9.077s<br/>user 0m8.793s<br/>sys 0m0.679s</span></pre><p id="caa3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是所有的<a class="ae nf" href="https://github.com/highercomve/perezoso-js/tree/master/scripts" rel="noopener ugc nofollow" target="_blank">https://github . com/higher comve/perezo so-js/tree/master/scripts</a></p></div></div>    
</body>
</html>