<html>
<head>
<title>Introduction to custom Babel Plugins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义巴别塔插件简介</h1>
<blockquote>原文：<a href="https://itnext.io/introduction-to-custom-babel-plugins-98a62dad16ee?source=collection_archive---------2-----------------------#2019-02-28">https://itnext.io/introduction-to-custom-babel-plugins-98a62dad16ee?source=collection_archive---------2-----------------------#2019-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0c6a78f1158919f8c12ddf4cc6e373e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*tn9zcn50cZR339qWnJ0pqA.jpeg"/></div></figure><p id="e77c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Babel是一个JavaScript编译器，它允许我们通过将JavaScript转换成浏览器可以理解的代码来使用最新最好的版本。它无疑是市场上帮助前端开发的最强大的工具之一。</p><p id="24f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这篇文章中，我们将探索巴别塔架构的基础，创建一个基本插件，并研究如何测试我们的插件。</p><p id="039a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Babel不同于将代码转换为二进制格式的传统编译器，例如，Babel可以:</p><ul class=""><li id="80a5" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">源代码转换又称编译，即代码到代码的转换</li><li id="c8e1" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">多填充缺失特征</li><li id="a32e" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">我们可以用源代码想象出任何其他东西</li></ul><p id="2cc1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Babel通过插件和预置的力量做到了这一点。简而言之，插件是帮助执行单一任务的原子组件。比如有把箭头函数转换成ES5函数的插件，有反应函数调用的JSX等等。另一方面，预置是插件的组合，通过避免安装多个插件和担心调用顺序来简化工作流程。<a class="ae lg" href="https://levelup.gitconnected.com/eli5-babel-and-the-gang-e5329313a107" rel="noopener ugc nofollow" target="_blank">阅读本文</a>了解插件和预置的详细解释。</p><h1 id="1ee5" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">巴别塔建筑</h1><p id="40a2" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">在我们继续构建示例插件之前，让我们简单地看一下支持插件使用的Babel的架构。</p><p id="a4b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的代码通过几个主要阶段。其中一些阶段对于任何编译器来说都是非常常见的，而一些阶段对于Babel来说是定制的。</p><blockquote class="mk ml mm"><p id="f337" class="ju jv mn jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">查看这个网站,它帮助我们想象这篇文章的下一部分</p></blockquote><ol class=""><li id="fd1e" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mr ky kz la bi translated"><strong class="jw ir">生成抽象语法树(AST) </strong>:将作为输入传入Babel的代码转换成树状对象。这个阶段被称为<strong class="jw ir">解析</strong>。在内部，这个阶段被分成两个子阶段，第一个阶段将代码转换成词法标记，而下一个阶段将这些标记转换成AST。每一条语句(或其一部分)都被转换成一个令牌，并最终转换成AST中的一个<code class="fe ms mt mu mv b">Node</code>，它包含诸如<code class="fe ms mt mu mv b">Node </code>的类型(如<code class="fe ms mt mu mv b">FunctionDeclaration</code>、<code class="fe ms mt mu mv b">ReturnStatement</code>、<code class="fe ms mt mu mv b">BooleanExpression</code>)、它在源代码中的开始和结束位置以及其他元数据等信息，这些信息有助于进一步理解<code class="fe ms mt mu mv b">Node</code>，并提供可能对处理该<code class="fe ms mt mu mv b">Node</code>有用的信息。</li><li id="5f4f" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mr ky kz la bi translated"><strong class="jw ir">消费插件</strong>:一旦AST生成，Babel编译器利用各种插件将代码从一种形式转换成另一种形式。这个阶段也被称为<strong class="jw ir">遍历</strong>。应用于AST的插件/预置列表以Babel配置的形式提供。插件是按照定义和预置的顺序来应用的，反之亦然。这个阶段本质上是在AST上工作，并输出另一个AST，它由插件执行的变更组成。</li><li id="5a08" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mr ky kz la bi translated"><strong class="jw ir">生成代码</strong>:AST修改完成后，AST转换回代码。</li></ol><p id="0f50" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然我们上面讨论的听起来非常复杂。多亏了<!-- --> <a class="ae lg" href="https://babeljs.io/docs/en/next/babel-generator" rel="noopener ugc nofollow" target="_blank">工具</a>的<a class="ae lg" href="https://babeljs.io/docs/en/next/babel-parser" rel="noopener ugc nofollow" target="_blank">主体</a> <!-- -->，这使得构建和使用巴别塔插件变得相对容易。</p><p id="855e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为插件实际上是针对代码生成的AST工作的，而不是代码本身，所以在继续插件开发之前，我们需要理解最后一件事。</p><p id="e532" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要修改AST，我们需要访问AST节点。传统上，如果我们有一个类似树的对象，并且我们想要修改它，在几轮开发尝试和错误之后，我们可能会以lodash-esque API结束，以从AST创建/更新/删除任何东西。但是在Babel中，引入了一个叫做<code class="fe ms mt mu mv b">Visitors</code>的重要主题，事情略有不同，这个主题基于<a class="ae lg" href="https://en.wikipedia.org/wiki/Visitor_pattern" rel="noopener ugc nofollow" target="_blank">访问者模式</a>。每个<code class="fe ms mt mu mv b">Visitor</code>对象由遇到特定节点类型时将被调用的方法组成。如果我们想为所有的<code class="fe ms mt mu mv b">Identifier</code>和<code class="fe ms mt mu mv b">FunctionDeclaration</code>节点调用一个访问者，它将如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c6b7" class="ne li iq mv b gy nf ng l nh ni">const visitor = {<br/>  Identifier: {<br/>    enter() {<br/>        console.log("Identifier enter called");<br/>    }<br/>    exit() {<br/>        console.log("Identifier exit called");<br/>    }<br/>  },<br/>  FunctionDeclaration: {<br/>    enter() {<br/>        console.log("FunctionDeclaration enter called");<br/>    }<br/>    exit() {<br/>        console.log("FunctionDeclaration exit called");<br/>    }<br/>  }<br/>};</span></pre><p id="5f1d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每次遇到某种类型的节点，在<code class="fe ms mt mu mv b">Visitor</code>上触发相应的<code class="fe ms mt mu mv b">enter</code>方法，然后在控件退出该节点时调用<code class="fe ms mt mu mv b">exit</code>方法。如果我们不关心在<code class="fe ms mt mu mv b">exit</code>发生了什么，我们可以简单地将声明与<code class="fe ms mt mu mv b">enter</code>方法合并。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="0aeb" class="ne li iq mv b gy nf ng l nh ni">const visitor = {<br/>  Identifier() {<br/>      console.log("Identifier enter called");<br/>  }<br/>};</span></pre><p id="49eb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们从经验中知道，代码是高度相互依赖的，我们不能简单地假设没有隐式或显式的依赖。出于这个原因，Babel在AST旁边提供了一个<code class="fe ms mt mu mv b">Path</code>,它表示节点之间的关系以及每个节点的元数据。因此，每当我们修改AST时，<code class="fe ms mt mu mv b">Path</code>就会更新以响应AST的变化。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3366" class="ne li iq mv b gy nf ng l nh ni">const visitor = {<br/>  Identifier: {<br/>    enter(<strong class="mv ir">path</strong>) {<br/>        console.log("Identifier enter called"<strong class="mv ir">, path.node.name</strong>);<br/>    }<br/>    exit(<strong class="mv ir">path</strong>) {<br/>        console.log("Identifier exit called"<strong class="mv ir">, path.node.name</strong>);<br/>    }<br/>  }<br/>  FunctionDeclaration: {<br/>    enter(<strong class="mv ir">path</strong>) {<br/>        console.log("FD enter called"<strong class="mv ir">, path.node.name</strong>);<br/>    }<br/>    exit(<strong class="mv ir">path</strong>) {<br/>        console.log("FD exit called"<strong class="mv ir">, path.node.name</strong>);<br/>    }<br/>  }<br/>};</span></pre><p id="10ae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还有其他高级概念，比如作用域和绑定，我们将在以后的文章中讨论。</p><h1 id="c736" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">示例插件</h1><p id="0e91" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">我们现在准备构建我们的示例插件。在这个例子中，我们将实现一个简单的目标:确定程序中每个方法的运行时间。</p><p id="f993" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了简单起见，我们只考虑几个例子，这些例子对于我们的插件来说很容易处理(但是足够真实):</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="210a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们有三个函数，它们运行循环，评估If条件，调用其他函数，并且包含返回引用的嵌套函数。</p><p id="062c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了能够记录每个方法的运行时间，我们将使用<code class="fe ms mt mu mv b">console.time</code>和<code class="fe ms mt mu mv b">console.timeEnd</code>方法。想法很简单，我们的插件将在函数的顶部插入<code class="fe ms mt mu mv b">console.time</code>,如果存在的话，在<code class="fe ms mt mu mv b">return</code>语句之前插入<code class="fe ms mt mu mv b">console.timeEnd</code>,如果不存在的话，在函数的末尾插入<code class="fe ms mt mu mv b">console.timeEnd</code>。</p><h2 id="2c42" class="ne li iq bd lj nl nm dn ln nn no dp lr kf np nq lv kj nr ns lz kn nt nu md nv bi translated">项目设置</h2><p id="8ff3" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">我们可以建立一个空白的NodeJS项目来创建一个Babel插件。如果你有兴趣走那条路，还有约曼发电机。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="437b" class="ne li iq mv b gy nf ng l nh ni">mkdir babel-plugin-runtime-logger</span><span id="af7a" class="ne li iq mv b gy nw ng l nh ni">cd babel-plugin-runtime-logger</span><span id="b640" class="ne li iq mv b gy nw ng l nh ni">npm init -y</span></pre><p id="5081" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦项目被创建，创建一个文件夹<code class="fe ms mt mu mv b">src</code>并在其中创建<code class="fe ms mt mu mv b">index.js</code>文件。这是我们将要创建插件的文件。这个想法很简单:</p><ol class=""><li id="5438" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mr ky kz la bi translated">在每个功能的顶部插入<code class="fe ms mt mu mv b">console.time(functionName)</code></li><li id="eb57" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mr ky kz la bi translated">在<code class="fe ms mt mu mv b">return</code>语句之前的函数末尾插入<code class="fe ms mt mu mv b">console.timeEnd(functionName)</code>(如果存在)</li></ol><h2 id="234a" class="ne li iq bd lj nl nm dn ln nn no dp lr kf np nq lv kj nr ns lz kn nt nu md nv bi translated">创建访问者</h2><p id="818b" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">首先，让我们创建一个空白访问者，并为其命名:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4758" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们识别何时处理我们的<code class="fe ms mt mu mv b">FunctionDeclaration</code>。如果是这样，我们可以简单地在那里插入我们的<code class="fe ms mt mu mv b">time</code>语句:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e6b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这看起来有点混乱，所以让我们在<code class="fe ms mt mu mv b">FuntionDeclaration</code>上分解<code class="fe ms mt mu mv b">enter</code>方法:</p><blockquote class="nx"><p id="af6c" class="ny nz iq bd oa ob oc od oe of og kr dk translated">W <!-- -->当遇到一个函数声明时(即在回车上)获取当前<code class="fe ms mt mu mv b">path</code>的<code class="fe ms mt mu mv b">body</code>(即获取<code class="fe ms mt mu mv b">BlockStatement within it a.k.a the body of the function</code>)并且在所有事情之前(即<code class="fe ms mt mu mv b">unshift</code>进入<code class="fe ms mt mu mv b">body</code>)插入一个<code class="fe ms mt mu mv b">CallExpression</code>(即函数调用)，该函数调用控制台对象上的时间方法，节点名称作为参数</p></blockquote><p id="ebf9" class="pw-post-body-paragraph ju jv iq jw b jx oh jz ka kb oi kd ke kf oj kh ki kj ok kl km kn ol kp kq kr ij bi translated">唯一自然的下一个问题是:我如何知道调用什么？存在哪些函数，需要哪些参数？答案并不复杂，巴别塔网站有很棒的<a class="ae lg" href="https://babeljs.io/docs/en/next/babel-types.html" rel="noopener ugc nofollow" target="_blank">文档解释类型</a>并且有<a class="ae lg" href="https://babeljs.io/docs/en/next/babel-helpers" rel="noopener ugc nofollow" target="_blank">助手可用</a>来简化你可能需要应用的任何复杂条件和检查。强烈建议使用<a class="ae lg" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST可视化工具</a>来帮助理解更复杂的工作流程。</p><p id="7a05" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们可以将<code class="fe ms mt mu mv b">exit</code>部分添加到<code class="fe ms mt mu mv b">FunctionDeclaration</code>中，根据函数的最后一条语句是否为<code class="fe ms mt mu mv b">ReturnStatement</code>来完成处理。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3fff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">基于函数中最后一条语句的类型，我们在当前最后一条语句之前或之后插入<code class="fe ms mt mu mv b">timeEnd</code>函数调用。</p><p id="afc3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这样，我们的插件开发就完成了。现在让我们来测试一下我们到目前为止所做的改变。</p><h2 id="0e12" class="ne li iq bd lj nl nm dn ln nn no dp lr kf np nq lv kj nr ns lz kn nt nu md nv bi translated">测试</h2><p id="a5db" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">为了测试这个插件，幸运的是我们不需要依赖真实世界的应用程序。相反，我们将使用<code class="fe ms mt mu mv b">babel-plugin-tester</code>库和<code class="fe ms mt mu mv b">Jest</code>来测试插件。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6013" class="ne li iq mv b gy nf ng l nh ni">npm i -D jest babel-plugin-tester</span></pre><p id="c465" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">插件测试器有几种测试插件的方法，在这里可以看到<a class="ae lg" href="https://github.com/babel-utils/babel-plugin-tester#examples" rel="noopener ugc nofollow" target="_blank"/>。但是我们将选择需要最小配置的选项，这样我们就可以投入并测试我们的插件。该选项依赖于<code class="fe ms mt mu mv b">fixtures</code>，它只是预先决定的输入和输出组合。如<code class="fe ms mt mu mv b">babel-plugin-tester</code>存储库所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="2522" class="ne li iq mv b gy nf ng l nh ni">fixtures<br/>├── first-test # test title will be: "first test"<br/>│   ├── code.js # required<br/>│   └── output.js # required<br/>└── second-test<br/>    ├── .babelrc # optional<br/>    ├── code.js<br/>    └── output.js</span></pre><p id="57f3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了设置我们的测试使用<code class="fe ms mt mu mv b">jest</code>运行，我们首先在<code class="fe ms mt mu mv b">src</code>旁边创建一个<code class="fe ms mt mu mv b">test</code>文件夹，并在其中创建一个<code class="fe ms mt mu mv b">index.spec.js</code>文件:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="dcd0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们用来自<code class="fe ms mt mu mv b">src</code>的<code class="fe ms mt mu mv b">plugin</code>和在<code class="fe ms mt mu mv b">test</code>内的<code class="fe ms mt mu mv b">fixtures</code>文件夹中定义的<code class="fe ms mt mu mv b">fixtures</code>来调用<code class="fe ms mt mu mv b">pluginTester</code>。</p><p id="c50a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这种情况下，我们只定义了一个名为<code class="fe ms mt mu mv b">logger</code>的fixture，其内容为<code class="fe ms mt mu mv b">code.js</code>，正如我们在一开始所讨论的:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="839c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们在运行测试和验证我们的断言之前创建预期的<code class="fe ms mt mu mv b">output.js</code>文件:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0415" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该项目的整个目录结构非常简单:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><div class="gh gi om"><img src="../Images/6fee69617add15bc280ce7eac0db542a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_APFkRMyWw5PADVXxXskA.png"/></div></div><figcaption class="or os gj gh gi ot ou bd b be z dk translated">项目文件夹结构</figcaption></figure><p id="d00c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以使用<code class="fe ms mt mu mv b">jest</code>调用这些测试:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d874" class="ne li iq mv b gy nf ng l nh ni">./node_modules/.bin/jest test/</span></pre><p id="f92f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">结果如下所示:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><div class="gh gi ov"><img src="../Images/ad5244bf162d318819058e6d8b7beb5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZnLSscaQCXIqIql1kC4WXA.png"/></div></div><figcaption class="or os gj gh gi ot ou bd b be z dk translated">所有成功的测试</figcaption></figure><p id="da82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于所有的测试都按照预期运行，我们看到测试用例通过了。如果有任何错误，由于有了<code class="fe ms mt mu mv b">babel-plugin-tester</code>，我们会看到它被清楚地标记出来。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><div class="gh gi ow"><img src="../Images/59ccf46d688e6901a1c2e6cbadf4db9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dogA5m0CQiQC35ruWvxZzA.png"/></div></div><figcaption class="or os gj gh gi ot ou bd b be z dk translated">意外结果的迹象</figcaption></figure><h1 id="1616" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">摘要</h1><p id="49ea" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">Babel无疑是一个非常强大的JavaScript transpiler，并且提供了很多功能。参考<a class="ae lg" href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md" rel="noopener ugc nofollow" target="_blank">这个</a>链接了解关于巴别塔编译器内部工作基础的细节，参考<a class="ae lg" href="https://github.com/jamiebuilds/babel-docs/tree/master/en_US/authors" rel="noopener ugc nofollow" target="_blank">这个</a>链接了解关于成为更好的插件作者的其他细节。</p><p id="90c1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文中展示的全部代码可在<a class="ae lg" href="https://github.com/40x/babel-plugin-runtime-logger" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div><div class="ab cl ox oy hu oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="ij ik il im in"><p id="ff30" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mn">如果你喜欢这个博客，一定要为它鼓掌，</em> <a class="ae lg" href="https://medium.com/@kashyap.mukkamala" rel="noopener"> <em class="mn">阅读更多</em> </a> <em class="mn">或者关注我的</em><a class="ae lg" href="https://www.linkedin.com/in/kashyap-mukkamala/" rel="noopener ugc nofollow" target="_blank"><em class="mn">LinkedIn</em></a><em class="mn">和</em><a class="ae lg" href="https://twitter.com/JSSculptor" rel="noopener ugc nofollow" target="_blank"><em class="mn">Twitter</em></a><em class="mn">。</em></p></div></div>    
</body>
</html>