<html>
<head>
<title>Roll your own async compose &amp; pipe functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">推出您自己的异步合成和管道功能</h1>
<blockquote>原文：<a href="https://itnext.io/roll-your-own-async-compose-pipe-functions-658cafe4c46f?source=collection_archive---------0-----------------------#2017-09-19">https://itnext.io/roll-your-own-async-compose-pipe-functions-658cafe4c46f?source=collection_archive---------0-----------------------#2017-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f9b0fa0a6ca228f32001ad707e6b1fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*muSiJcg5NrYQZ0845esMCA.jpeg"/></div></div></figure><p id="cefe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">受函数式编程启发的函数<code class="fe kw kx ky kz b">compose</code>和<code class="fe kw kx ky kz b">pipe</code>非常棒，但是它们只支持同步函数。我将向您展示如何编写您自己的函数，这些函数将与同步和异步函数结合使用，如果这是您喜欢的类型的话。</p><h1 id="fe2d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">酷故事兄弟，给我看看代码吧！</h1><p id="f77e" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">好吧，给你。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">异步合成功能</figcaption></figure><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">异步管道功能</figcaption></figure><h2 id="58a8" class="mn lb iq bd lc mo mp dn lg mq mr dp lk kj ms mt lo kn mu mv ls kr mw mx lw my bi translated">好吧，现在怎么办？</h2><p id="a78d" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">如果您来这里只是为了获得一段代码，这没什么不好意思的，请随意将它添加到您的项目中，继续您的生活！否则，如果你想知道它是如何工作的，请继续阅读。</p><p id="8e9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它可能会有点毛，但对我来说是光秃秃的。如果你熟悉某些部分，就直接跳过。</p><p id="8279" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些功能要求<code class="fe kw kx ky kz b">Promises</code>在您的应用程序环境中可用，无论是浏览器还是带有节点的服务器端。如果你正在为现代网络(不包括IE)开发，承诺已经在大多数浏览器中得到支持。回到现实世界，你可能会使用一个<a class="ae mz" href="https://github.com/stefanpenner/es6-promise" rel="noopener ugc nofollow" target="_blank"> polyfill </a>或者其他一些第三方库，比如<a class="ae mz" href="https://www.npmjs.com/package/bluebird" rel="noopener ugc nofollow" target="_blank"> bluebird </a>，给你<code class="fe kw kx ky kz b">Promise</code>支持。如果你正在读这篇文章，你可能已经熟悉了承诺，如果不是，这里有一个快速入门。</p><h1 id="fb36" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">承诺的简化入门</h1><p id="6b9f" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated"><code class="fe kw kx ky kz b">Promise</code>是一个表示将在未来某个时间完成的动作的对象。这意味着，你为一个异步动作创建你的<code class="fe kw kx ky kz b">Promise</code>，就像一个AJAX请求，当它完成时，类似于使用一个成功回调，你调用它的<code class="fe kw kx ky kz b">resolve</code>函数；如果失败，就调用它的<code class="fe kw kx ky kz b">reject</code>函数。</p><p id="7999" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">Promise</code>对象公开了映射到两个“回调”函数的两个函数，即:当您<code class="fe kw kx ky kz b">resolve</code>承诺时将调用的<code class="fe kw kx ky kz b">.then()</code>和当您<code class="fe kw kx ky kz b">reject</code>承诺时将调用的<code class="fe kw kx ky kz b">.catch()</code>。</p><p id="0974" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有很多事情要做，但是如果你明白这些，你就会做得很好。</p><h1 id="4e14" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">compose &amp; pipe是怎么回事？</h1><p id="8d15" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">仅在Medium上就有许多关于<code class="fe kw kx ky kz b">compose</code>和<code class="fe kw kx ky kz b">pipe</code>的错综复杂的文章，它们在解释这一点上做得很好。如果你现在懒得用谷歌搜索，看到你已经在这里了，我会试着解释一下:作文就像成年人的乐高。这是一种通过使用更小更简单的单元来构建更复杂的东西的方法。在函数式编程中，<code class="fe kw kx ky kz b">compose</code>是将较小的单元(我们的函数)组合成更复杂的东西(你猜对了，另一个函数)的机制。</p><p id="6349" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，<code class="fe kw kx ky kz b">compose</code>接受一个函数列表并返回另一个函数，您可以用您的数据调用它。一个例子就能说明这一点:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="ede2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我们创建了3个执行简单算法的基本函数:<code class="fe kw kx ky kz b">double</code>、<code class="fe kw kx ky kz b">square</code>和<code class="fe kw kx ky kz b">plus3</code>。这里没什么特别的，<code class="fe kw kx ky kz b">double</code>取一个值乘以2；<code class="fe kw kx ky kz b">square</code>取一个值，然后把它和自己相乘，最后，<code class="fe kw kx ky kz b">plus3</code>就是这么做的——它取一个数，然后加3。</p><p id="0131" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第5行，我们使用我们的<code class="fe kw kx ky kz b">compose</code>方法来创建一个新的<code class="fe kw kx ky kz b">composedFunction</code>，它是由我们的3个更简单的函数组成的。每次调用这个<code class="fe kw kx ky kz b">composedFunction</code>时，它都会将这3个函数应用到我们传递给它的任何值上。在第7行，我们用值2调用我们的<code class="fe kw kx ky kz b">composedFunction</code>。为了形象化这里发生的事情，想象一下:</p><pre class="md me mf mg gt na kz nb nc aw nd bi"><span id="f56e" class="mn lb iq kz b gy ne nf l ng nh">double(square(plus3(2)))</span></pre><p id="d74d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很难看，但它表达了这一点。</p><p id="9114" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值2被传递给产生5的<code class="fe kw kx ky kz b">plus3</code>函数。这个结果成为我们的<code class="fe kw kx ky kz b">square</code>函数的输入，这个函数又产生25。最后，我们用25调用<code class="fe kw kx ky kz b">double</code>函数，然后产生50。</p><p id="f58b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这显然是一个简单得可笑的例子，但要点是把复杂的问题想象成一堆你可以一起解决的小问题的总和。</p><p id="8c2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，假设您有一个来自API调用的响应来检索产品列表，您想要映射每个产品并只提取某些属性，比如<code class="fe kw kx ky kz b">title</code>、<code class="fe kw kx ky kz b">description</code>和<code class="fe kw kx ky kz b">price</code>。然后你还想过滤掉所有比<code class="fe kw kx ky kz b">$5</code>便宜的产品，最后按字母顺序对结果进行排序。</p><p id="2a0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以前的你会写3个函数:<code class="fe kw kx ky kz b">pluckProperties</code>、<code class="fe kw kx ky kz b">getCheap</code>和<code class="fe kw kx ky kz b">sortByTitle</code>，然后像这样做:</p><pre class="md me mf mg gt na kz nb nc aw nd bi"><span id="50b0" class="mn lb iq kz b gy ne nf l ng nh">const products = // array of product objects</span><span id="8212" class="mn lb iq kz b gy ni nf l ng nh">const result = pluckProperties(sortByTitle(getCheap(products)))</span></pre><p id="c2b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="nj">额外提示:</em> </strong> <em class="nj">在对数据集做任何事情之前，总是先进行过滤，这样你就可以遍历最少的条目。</em></p><p id="4181" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">新的你将使用<code class="fe kw kx ky kz b">compose</code>来创建你的可重用<code class="fe kw kx ky kz b">getProducts</code>函数:</p><pre class="md me mf mg gt na kz nb nc aw nd bi"><span id="da7b" class="mn lb iq kz b gy ne nf l ng nh">const getProducts = compose(pluckProperties, sortByTitle, getCheap);</span><span id="f446" class="mn lb iq kz b gy ni nf l ng nh">const products = // array of product objects<br/>const result = getProducts(products)</span></pre><p id="fcd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望你现在已经看到使用<code class="fe kw kx ky kz b">compose</code>的好处了。否则，所有的希望都没了，我也帮不了你。笑话。继续思考它，看看它会在哪些地方帮助你写得更干净更可重用(阅读:<strong class="ka ir">更好！日常工作中的代码。</strong></p><p id="9624" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也将快速触摸<code class="fe kw kx ky kz b">pipe</code>。它与<code class="fe kw kx ky kz b">compose</code>完全相同，但它从左到右而不是从右到左应用功能。</p><p id="7678" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe kw kx ky kz b">pipe</code>，我们的示例将如下所示:</p><pre class="md me mf mg gt na kz nb nc aw nd bi"><span id="fd8a" class="mn lb iq kz b gy ne nf l ng nh">const getProducts = pipe(getCheap, sortByTitle, pluckProperties);</span><span id="3f05" class="mn lb iq kz b gy ni nf l ng nh">const products = // array of product objects<br/>const result = getProducts(products)</span></pre><p id="6727" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">pipe</code>对于编写一步一步的程序非常有用，比如:</p><pre class="md me mf mg gt na kz nb nc aw nd bi"><span id="a1f5" class="mn lb iq kz b gy ne nf l ng nh">pipe(logUserIn, displayNotification, redirectToHomepage)(user)</span></pre><h1 id="c416" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">异步<code class="fe kw kx ky kz b">compose</code>和<code class="fe kw kx ky kz b">pipe</code>有什么酷的地方？</h1><p id="253d" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">传统上，<code class="fe kw kx ky kz b">compose</code>和<code class="fe kw kx ky kz b">pipe</code>只对可以传递输入值的同步函数起作用，它对输入做一些事情，然后返回一个输出。查看上面的<code class="fe kw kx ky kz b">pipe</code>示例，您会同意<code class="fe kw kx ky kz b">logUserIn</code>函数很可能是一个异步函数，因为您需要与服务器/数据库进行一些通信。这样就不行了。洗澡时该哭了。</p><p id="e26c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过使用我们自己改进的<code class="fe kw kx ky kz b">pipe</code>函数来解决这个问题:</p><pre class="md me mf mg gt na kz nb nc aw nd bi"><span id="022a" class="mn lb iq kz b gy ne nf l ng nh">pipe(logUserIn, displayNotification, redirectToHomepage)(user)<br/>  .then(() =&gt; {<br/>    // The user is logged in<br/>    // the login notification has been displayed<br/>    // and s/he has been redirected to the homepage<br/>  })</span></pre><p id="ff6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，你完了！</p><h1 id="1869" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们来分解一下</h1><p id="a228" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">作为参考，这里再次是<code class="fe kw kx ky kz b">compose</code>片段。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="88a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们看到<code class="fe kw kx ky kz b">compose</code>是一个返回函数的函数(示例使用标准JavaScript函数):</p><pre class="md me mf mg gt na kz nb nc aw nd bi"><span id="66c6" class="mn lb iq kz b gy ne nf l ng nh">const compose = function(...functions) {<br/>  return function(input) {<br/>    // ...<br/>  };<br/>}</span></pre><p id="a346" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它使用ES2015 <a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> rest参数</a>将所有传入的函数组合成一个数组<code class="fe kw kx ky kz b">functions</code>。</p><p id="cbfa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要理解内部函数的主体，熟悉JavaScript固有的<code class="fe kw kx ky kz b"><a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=b" rel="noopener ugc nofollow" target="_blank">reduce</a></code>和<code class="fe kw kx ky kz b"><a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight" rel="noopener ugc nofollow" target="_blank">reduceRight</a></code>数组方法是很重要的。</p><p id="8d02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">reduce</code>遍历给定数组中的每一项，并对其应用一个函数，每个函数的结果作为下一项函数的输入。每当你有一个东西的列表，你想把它“简化”成一个单一的值，使用<code class="fe kw kx ky kz b">reduce</code>或<code class="fe kw kx ky kz b">reduceRight</code>方法。这些方法有两个参数，第一个是需要为数组中的每一项运行的函数，第二个是可选的起始值。</p><p id="f97a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最简单的是把它想成一个<code class="fe kw kx ky kz b">SUM()</code>或<code class="fe kw kx ky kz b">TOTAL()</code>方法，例如:</p><pre class="md me mf mg gt na kz nb nc aw nd bi"><span id="da87" class="mn lb iq kz b gy ne nf l ng nh">const numbers = [ 1, 5, 9 ];<br/>const total = items.reduce(function(sum, number) {<br/>  return sum + number;<br/>}, 0);</span><span id="4a3d" class="mn lb iq kz b gy ni nf l ng nh">// total = 15 (1 + 5 + 9)</span></pre><p id="f3c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个函数的输出都是下一个函数的输入。对于数组(1)中的第一个数字，<code class="fe kw kx ky kz b">sum</code>将是<code class="fe kw kx ky kz b">0</code>，因为这是起始值，<code class="fe kw kx ky kz b">number</code>将是<code class="fe kw kx ky kz b">1</code>。第二个数(5)将把<code class="fe kw kx ky kz b">1</code>作为<code class="fe kw kx ky kz b">sum</code>的值，<code class="fe kw kx ky kz b">number</code>将是<code class="fe kw kx ky kz b">5</code>，产生<code class="fe kw kx ky kz b">6</code>。因此，对于第三个数字(9)，<code class="fe kw kx ky kz b">sum</code>将是<code class="fe kw kx ky kz b">6</code>并且<code class="fe kw kx ky kz b">number</code>将是<code class="fe kw kx ky kz b">9</code>，这产生了<code class="fe kw kx ky kz b">15</code>的最终输出。</p><p id="865b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">reduce</code>和<code class="fe kw kx ky kz b">reduceRight</code>的唯一区别是<code class="fe kw kx ky kz b">reduceRight</code>从右到左(从后到前)而不是从左到右(从前到后)遍历数组中的元素。</p><p id="bdaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在我们理解了<code class="fe kw kx ky kz b">reduce</code>和<code class="fe kw kx ky kz b">Promises</code>，让我们把它们放在一起理解我们<code class="fe kw kx ky kz b">compose</code>函数的最后一部分。</p><pre class="md me mf mg gt na kz nb nc aw nd bi"><span id="fc65" class="mn lb iq kz b gy ne nf l ng nh">functions.reduceRight(<br/>  (chain, func) =&gt; chain.then(func),<br/>  Promise.resolve(input)<br/>)</span></pre><p id="c368" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与我们在示例中遍历一个数组<code class="fe kw kx ky kz b">numbers</code>不同，这里我们遍历一个数组<code class="fe kw kx ky kz b">functions</code>。这里我们不是从值<code class="fe kw kx ky kz b">0</code>开始，而是从一个<code class="fe kw kx ky kz b">Promise</code>开始，它立即解析为我们调用组合函数时使用的值。</p><p id="92b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的reduce/accumulator函数中，我们不是建立一个<code class="fe kw kx ky kz b">sum</code>，而是把将按顺序解决的承诺链接在一起。为了使用我们的用户登录示例直观显示这一点，将会产生以下内容:</p><pre class="md me mf mg gt na kz nb nc aw nd bi"><span id="e7d8" class="mn lb iq kz b gy ne nf l ng nh">logUserIn(user)<br/>  .then(displayNotification)<br/>  .then(redirectToHomepage)<br/>  .then(result =&gt; `Do whatever we want with the ${result}`)</span></pre><h1 id="f3c9" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">包扎</h1><p id="a40a" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">希望你觉得这很有用，如果你想在你的项目中包含这些功能，要么复制粘贴，要么从NPM获取:</p><ul class=""><li id="df5c" class="nk nl iq ka b kb kc kf kg kj nm kn nn kr no kv np nq nr ns bi translated"><a class="ae mz" href="https://www.npmjs.com/package/compose-then" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/compose-then</a></li><li id="49db" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated"><a class="ae mz" href="https://www.npmjs.com/package/fp-pipe-then" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/fp-pipe-then</a></li></ul><p id="637e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nj">如果你有更好的想法或者很酷的东西可以分享，请告诉我；很乐意向你学习。</em></p></div></div>    
</body>
</html>