<html>
<head>
<title>How to deploy an EFK stack to Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将EFK堆栈部署到Kubernetes</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-deploy-an-efk-stack-to-kubernetes-d1179a56fee8?source=collection_archive---------3-----------------------#2018-04-16">https://itnext.io/how-to-deploy-an-efk-stack-to-kubernetes-d1179a56fee8?source=collection_archive---------3-----------------------#2018-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cecb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能听说过麋鹿(<a class="ae kl" href="https://www.elastic.co/products/elasticsearch" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>、<a class="ae kl" href="https://www.elastic.co/products/logstash" rel="noopener ugc nofollow" target="_blank"> Logstash </a>、<a class="ae kl" href="https://www.elastic.co/products/kibana" rel="noopener ugc nofollow" target="_blank"> Kibana </a>)。EFK是同一个堆栈，我们用<a class="ae kl" href="https://www.fluentd.org/" rel="noopener ugc nofollow" target="_blank"> Fluentd </a>替换Logstash。<br/>那么为什么要用Fluentd代替Logstash呢？</p><p id="d287" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，Fluentd现在由<a class="ae kl" href="https://cncf.io/" rel="noopener ugc nofollow" target="_blank">云本地计算基金会</a>托管，该基金会也托管<a class="ae kl" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>。此外，我发现它很容易配置，有很多插件，它的内存占用很低。</p><p id="a97f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以用<a class="ae kl" href="https://fluentbit.io/" rel="noopener ugc nofollow" target="_blank"> Fluent Bit </a>代替Fluentd，它是一个更轻的日志转发器，但功能比第一个少。</p><h1 id="c5ec" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">它是如何工作的</h1><p id="e053" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">一张图胜过千言万语，所以这里有一个简单的图式。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/48bc8c6967978cedfffe57240435b4ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xUQzaS391iUXIc5E.png"/></div></div></figure><p id="a176" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上每个Fluentd容器读取<code class="fe mb mc md me b">/var/lib/docker</code>来获取节点上每个容器的日志并发送给Elasticsearch。最后，当我们访问Kibana时，它向Elasticsearch请求日志。</p><h1 id="37d9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">为什么</h1><p id="62f7" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">你可能会问自己为什么要设置这样一个堆栈？我可以运行<code class="fe mb mc md me b">docker logs ...</code>，那里有我的日志。</p><p id="438a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，你可以。然而，如果你有几个副本，你必须仔细检查每一个容器才能找到你想要的。在这里，您可以一次浏览所有日志。<br/>此外，使用Kibana，您可以创建仪表板和非常漂亮的可视化效果。</p><p id="77c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看一看:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mf"><img src="../Images/b526bb2e34ac0e2d423332f3bd7a009a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*swvhgTrEOi2zdh0h.jpg"/></div></div></figure><blockquote class="mg mh mi"><p id="ee91" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated"><em class="iq">出自</em><a class="ae kl" href="https://www.elastic.co/" rel="noopener ugc nofollow" target="_blank">【elastic.co】T21</a></p></blockquote><p id="eb54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个有趣的地方是日志的操作。使用Fluentd，您可以非常轻松地过滤、修改和备份您的日志。但是我们会在另一篇文章中讨论这个问题。</p><p id="e7e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">介绍够了，让我们建立这个堆栈！</p><h1 id="8e63" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">弹性搜索</h1><blockquote class="mg mh mi"><p id="9d76" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated"><em class="iq"> Elasticsearch是一个分布式RESTful搜索和分析引擎，能够解决越来越多的用例。作为弹性堆栈的核心，它集中存储您的数据，因此您可以发现预期的数据，发现意外的数据。</em></p></blockquote><p id="9dc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在E*K栈中，我们使用Elasticsearch来存储和搜索Fluentd转发的日志。要将它部署到我们的Kubernetes集群中，我们可以使用GitHub仓库的<a class="ae kl" href="https://github.com/pires/" rel="noopener ugc nofollow" target="_blank">pires</a>:<a class="ae kl" href="https://github.com/pires/kubernetes-elasticsearch-cluster" rel="noopener ugc nofollow" target="_blank">pires/Kubernetes-elastic search-cluster</a></p><p id="db6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以修改<code class="fe mb mc md me b">es-master.yaml</code>、<code class="fe mb mc md me b">es-client.yaml</code>和<code class="fe mb mc md me b">es-data.yaml</code>中的值，以改变副本的数量、名称等。</p><blockquote class="mg mh mi"><p id="16ec" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated"><em class="iq">默认情况下，</em> <code class="fe mb mc md me b"><em class="iq">ES_JAVA_OPTS</em></code> <em class="iq">设置为</em> <code class="fe mb mc md me b"><em class="iq">-Xms256m -Xmx256m</em></code> <em class="iq">。这是一个非常低的值，但许多用户，即minikube用户，都遇到过由于主机内存不足而导致pod被杀死的问题。您可以在该存储库中可用的部署描述符中对此进行更改。<br/> </em> <a class="ae kl" href="https://github.com/pires/kubernetes-elasticsearch-cluster/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> README.md </a></p></blockquote><p id="d203" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还建议将存储器从<code class="fe mb mc md me b">emptyDir</code>更改为您选择的存储器，以获得数据的持久存储。</p><p id="d837" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设置好文件后，您可以运行:</p><pre class="lq lr ls lt gt mn me mo mp aw mq bi"><span id="f263" class="mr kn iq me b gy ms mt l mu mv">$ kubectl -n logging create -f es-discovery-svc.yaml<br/>$ kubectl -n logging create -f es-svc.yaml<br/>$ kubectl -n logging create -f es-master.yaml<br/>$ kubectl -n logging rollout status -f es-master.yaml<br/>$ kubectl -n logging create -f es-client.yaml<br/>$ kubectl -n logging rollout status -f es-client.yaml<br/>$ kubectl -n logging create -f es-data.yaml<br/>$ kubectl -n logging rollout status -f es-data.yaml</span></pre><blockquote class="mg mh mi"><p id="799b" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated"><em class="iq">注意:我将在</em> <code class="fe mb mc md me b"><em class="iq">logging</em></code> <em class="iq">命名空间中运行EFK堆栈，使用</em> <code class="fe mb mc md me b"><em class="iq">kubectl create ns logging</em></code> <em class="iq">来创建它。</em></p></blockquote><p id="02dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照<a class="ae kl" href="https://github.com/pires/kubernetes-elasticsearch-cluster/blob/master/README.md#access-the-service" rel="noopener ugc nofollow" target="_blank"> pires说明</a>检查您的Elasticsearch是否启动并运行。</p><p id="0644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切正常，我们现在可以设置Fluentd(或Fluent Bit)！</p><h1 id="c01a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">流体d</h1><blockquote class="mg mh mi"><p id="0d22" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated"><em class="iq"> Fluentd是一个开源的数据收集器，它可以让您统一数据收集和使用，以便更好地使用和理解数据。<br/></em><a class="ae kl" href="https://www.fluentd.org/architecture" rel="noopener ugc nofollow" target="_blank">https://www.fluentd.org/architecture</a></p></blockquote><p id="a5ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Fluentd可以直接在主机上运行，也可以在Docker容器中运行。这里我们将使用一个<code class="fe mb mc md me b">DaemonSet</code>来确保Fluentd在每个节点上运行。代码来自<a class="ae kl" href="https://github.com/fluent/fluentd-kubernetes-daemonset" rel="noopener ugc nofollow" target="_blank">fluent/fluentd-kubernetes-daemonset</a>。</p><p id="82f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在集群上启用了RBAC(我希望您已经启用了)，请检查<a class="ae kl" href="https://github.com/fluent/fluentd-kubernetes-daemonset/blob/master/fluentd-daemonset-elasticsearch-rbac.yaml" rel="noopener ugc nofollow" target="_blank">fluentd-daemonset-elastic search-RBAC . YAML</a>的<code class="fe mb mc md me b">ClusterRole</code>、<code class="fe mb mc md me b">ClusterRoleBinding</code>和<code class="fe mb mc md me b">ServiceAccount</code>。</p><p id="df17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记将名称空间更改为部署Elasticsearch时使用的名称空间，它应该是相同的。<br/>然后我们可以应用<code class="fe mb mc md me b">DaemonSet</code>:</p><pre class="lq lr ls lt gt mn me mo mp aw mq bi"><span id="8ae8" class="mr kn iq me b gy ms mt l mu mv">apiVersion: apps/v1<br/>kind: DaemonSet<br/>metadata:<br/>  name: fluentd<br/>  namespace: logging<br/>  labels:<br/>    component: fluentd-logging<br/>    version: v1<br/>    kubernetes.io/cluster-service: "true"<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      component: fluentd-logging<br/>  template:<br/>    metadata:<br/>      labels:<br/>        component: fluentd-logging<br/>        version: v1<br/>        kubernetes.io/cluster-service: "true"<br/>    spec:<br/>      serviceAccount: fluentd # if you have RBAC enabled<br/>      serviceAccountName: fluentd # if you have RBAC enabled<br/>      tolerations:<br/>      - key: node-role.kubernetes.io/master<br/>        effect: NoSchedule<br/>      containers:<br/>      - name: fluentd<br/>        image: fluent/fluentd-kubernetes-daemonset:elasticsearch<br/>        env:<br/>          - name:  FLUENT_ELASTICSEARCH_HOST<br/>            value: "elasticsearch" # the name of the previous es-svc.yml <br/>          - name:  FLUENT_ELASTICSEARCH_PORT<br/>            value: "9200" # port of the previous es-svc.yml<br/>          - name: FLUENT_ELASTICSEARCH_SCHEME<br/>            value: "http"<br/>        resources:<br/>          limits:<br/>            memory: 200Mi<br/>          requests:<br/>            cpu: 100m<br/>            memory: 200Mi<br/>        volumeMounts:<br/>        - name: varlog<br/>          mountPath: /var/log<br/>        - name: varlibdockercontainers<br/>          mountPath: /var/lib/docker/containers<br/>          readOnly: true<br/>      terminationGracePeriodSeconds: 30<br/>      volumes:<br/>      - name: varlog<br/>        hostPath:<br/>          path: /var/log<br/>      - name: varlibdockercontainers<br/>        hostPath:<br/>          path: /var/lib/docker/containers</span></pre><h1 id="4a65" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">流畅位</h1><p id="b128" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们将使用<a class="ae kl" href="https://github.com/fluent/fluent-bit-kubernetes-logging" rel="noopener ugc nofollow" target="_blank">fluent/fluent-bit-kubernetes-logging</a>的代码。<br/>至于Fluentd，如果你使用RBAC，用以下命令创建<code class="fe mb mc md me b">ClusterRole</code>、<code class="fe mb mc md me b">ClusterRoleBinding</code>和<code class="fe mb mc md me b">ServiceAccount</code>:</p><pre class="lq lr ls lt gt mn me mo mp aw mq bi"><span id="edd3" class="mr kn iq me b gy ms mt l mu mv">$ kubectl create -f https://raw.githubusercontent.com/fluent/fluent-bit-kubernetes-logging/master/fluent-bit-service-account.yaml<br/>$ kubectl create -f https://raw.githubusercontent.com/fluent/fluent-bit-kubernetes-logging/master/fluent-bit-role.yaml<br/>$ kubectl create -f https://raw.githubusercontent.com/fluent/fluent-bit-kubernetes-logging/master/fluent-bit-role-binding.yaml</span></pre><p id="91b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要为配置创建一个<code class="fe mb mc md me b">ConfigMap</code>。您可以修改<a class="ae kl" href="https://github.com/fluent/fluent-bit-kubernetes-logging/blob/master/output/elasticsearch/fluent-bit-configmap.yaml" rel="noopener ugc nofollow" target="_blank">这个</a>并应用它，或者使用默认的:</p><pre class="lq lr ls lt gt mn me mo mp aw mq bi"><span id="0865" class="mr kn iq me b gy ms mt l mu mv">$ kubectl create -f https://raw.githubusercontent.com/fluent/fluent-bit-kubernetes-logging/master/output/elasticsearch/fluent-bit-configmap.yaml</span></pre><p id="98ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦应用了<code class="fe mb mc md me b">ConfigMap</code>，下面是<code class="fe mb mc md me b">DaemonSet</code>的代码:</p><pre class="lq lr ls lt gt mn me mo mp aw mq bi"><span id="3474" class="mr kn iq me b gy ms mt l mu mv">apiVersion: apps/v1<br/>kind: DaemonSet<br/>metadata:<br/>  name: fluent-bit<br/>  namespace: logging<br/>  labels:<br/>    component: fluent-bit-logging<br/>    version: v1<br/>    kubernetes.io/cluster-service: "true"<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      component: fluent-bit-logging<br/>  template:<br/>    metadata:<br/>      labels:<br/>        component: fluent-bit-logging<br/>        version: v1<br/>        kubernetes.io/cluster-service: "true"<br/>    spec:<br/>      containers:<br/>      - name: fluent-bit<br/>        image: fluent/fluent-bit:0.12.17<br/>        env:<br/>        - name: FLUENT_ELASTICSEARCH_HOST<br/>          value: "elasticsearch" # the name of the previous es-svc.yml <br/>        - name: FLUENT_ELASTICSEARCH_PORT<br/>          value: "9200" # the port of the previous es-svc.yml <br/>        volumeMounts:<br/>        - name: varlog<br/>          mountPath: /var/log<br/>        - name: varlibdockercontainers<br/>          mountPath: /var/lib/docker/containers<br/>          readOnly: true<br/>        - name: fluent-bit-config<br/>          mountPath: /fluent-bit/etc/<br/>      terminationGracePeriodSeconds: 10<br/>      volumes:<br/>      - name: varlog<br/>        hostPath:<br/>          path: /var/log<br/>      - name: varlibdockercontainers<br/>        hostPath:<br/>          path: /var/lib/docker/containers<br/>      - name: fluent-bit-config<br/>        configMap:<br/>          name: fluent-bit-config # name of the previously created ConfigMap<br/>      serviceAccountName: fluent-bit<br/>      tolerations:<br/>      - key: node-role.kubernetes.io/master<br/>        operator: Exists<br/>        effect: NoSchedule</span></pre><h1 id="bd59" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">基巴纳</h1><p id="0b8a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">一旦你有了一些进入Elasticsearch的日志，我们可以像Kibana一样添加一个工具来探索和分析它们。</p><blockquote class="mg mh mi"><p id="9173" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated"><em class="iq"> Kibana可让您可视化您的Elasticsearch数据并浏览Elastic Stack。</em></p></blockquote><p id="5be9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们将部署Kibana作为部署。我们将使用6.2 OSS版本，因为它没有启用X-Pack。(如果想要X-Pack，当然可以调整镜像名)。</p><pre class="lq lr ls lt gt mn me mo mp aw mq bi"><span id="8f82" class="mr kn iq me b gy ms mt l mu mv">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  namespace: logging<br/>  name: kibana<br/>  labels:<br/>    component: kibana<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>     component: kibana<br/>  template:<br/>    metadata:<br/>      labels:<br/>        component: kibana<br/>    spec:<br/>      containers:<br/>      - name: kibana<br/>        image: docker.elastic.co/kibana/kibana-oss:6.2.2<br/>        env:<br/>        - name: CLUSTER_NAME<br/>          value: myesdb # name of the Elasticsearch cluster defined in the first part<br/>        resources:<br/>          limits:<br/>            cpu: 1000m<br/>          requests:<br/>            cpu: 100m<br/>        ports:<br/>        - containerPort: 5601<br/>          name: http</span></pre><p id="0038" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当pod启动并运行时，我们可以通过一个<code class="fe mb mc md me b">Service</code>和一个<code class="fe mb mc md me b">Ingress</code>来访问它:</p><pre class="lq lr ls lt gt mn me mo mp aw mq bi"><span id="0dc8" class="mr kn iq me b gy ms mt l mu mv">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  namespace: logging<br/>  name: kibana<br/>  labels:<br/>    component: kibana<br/>spec:<br/>  selector:<br/>    component: kibana<br/>  ports:<br/>  - name: http<br/>    port: 5601<br/>---<br/>apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  namespace: logging<br/>  name: kibana<br/>  annotations:<br/>    kubernetes.io/ingress.class: traefik<br/>    ingress.kubernetes.io/auth-type: "basic"<br/>    ingress.kubernetes.io/auth-secret: kibana-basic-auth<br/>spec:<br/>  rules:<br/>  - host: "&lt;your-url&gt;"<br/>    http:<br/>      paths:<br/>      - path: /<br/>        backend:<br/>          serviceName: kibana<br/>          servicePort: http</span></pre><p id="2666" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了用用户/密码保护Kibana，我们将使用<a class="ae kl" href="https://traefik.io/" rel="noopener ugc nofollow" target="_blank"> Traefik </a>作为入口控制器。<br/>创造的秘密:</p><pre class="lq lr ls lt gt mn me mo mp aw mq bi"><span id="7633" class="mr kn iq me b gy ms mt l mu mv">$ htpasswd -c ./auth &lt;your-user&gt;<br/>$ kubectl -n logging create secret generic kibana-basic-auth --from-file auth<br/>$ rm auth</span></pre><p id="44ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您第一次访问Kibana时，您需要配置您的第一个索引。<br/>如果您没有更改Fluentd的默认配置，则索引名称/模式为<code class="fe mb mc md me b">logstash-YYYY-MM-DD</code>。通过使用<code class="fe mb mc md me b">logstash-*</code>，您可以使用通配符来捕获所有以<em class="mj"> logstash- </em>开头的索引。</p><p id="83a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你有一个功能EFK堆栈！</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mw"><img src="../Images/6e4ba62bb9c7e2892d4fb68532027d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vJAZ3lrK_YgN-88u.png"/></div></div></figure><p id="2c47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一部分中，我们将深入研究Fluentd和Kibana的配置。</p><blockquote class="mg mh mi"><p id="999c" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated"><em class="iq">感谢</em><a class="ae kl" href="https://jmaitrehenry.ca/" rel="noopener ugc nofollow" target="_blank"><em class="iq">@ jmaitrehenry</em></a><em class="iq">对本帖的反馈。</em></p></blockquote></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="2ef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">原载于2018年4月16日</em><a class="ae kl" href="https://blog.ptrk.io/how-to-deploy-an-efk-stack-to-kubernetes/" rel="noopener ugc nofollow" target="_blank"><em class="mj">blog . ptrk . io</em></a><em class="mj">。</em></p></div></div>    
</body>
</html>