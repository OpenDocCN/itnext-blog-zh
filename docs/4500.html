<html>
<head>
<title>Android Architecture: Hilt, MVVM, Kotlin Coroutines, Live Data, Room and Retrofit (ft. Rick and Morty)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android架构:希尔特，MVVM，科特林协程，实时数据，房间和改造(英尺。里克和莫蒂)</h1>
<blockquote>原文：<a href="https://itnext.io/android-architecture-hilt-mvvm-kotlin-coroutines-live-data-room-and-retrofit-ft-8b746cab4a06?source=collection_archive---------0-----------------------#2020-07-14">https://itnext.io/android-architecture-hilt-mvvm-kotlin-coroutines-live-data-room-and-retrofit-ft-8b746cab4a06?source=collection_archive---------0-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2fb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发Android应用程序时，规划项目的架构非常重要。这将允许我们创建复杂、健壮、高质量、易于维护的应用程序。</p><p id="4dc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我想向你展示我在Android开发中使用推荐实践的方法。</p><p id="59fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所知，在一个活动或片段中编写我们所有的应用程序代码是一个常见的错误。我们应该分离应用程序组件的不同关注点。下一张图将向您展示我们将使用的模块及其交互:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/b8e4371e7f818e0f7cd5cb4ae54fa28c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3u5JnmqONR4UnwRE6tEV3Q.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">Android架构组件</figcaption></figure><h1 id="07e8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">该项目</h1><p id="5532" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们将使用<a class="ae ma" href="https://rickandmortyapi.com/" rel="noopener ugc nofollow" target="_blank">Rick和Morty API，</a>从中提取角色信息，并在RecyclerView中显示它们，通过单击其中一个项目，应用程序将显示一个角色的详细信息。简单。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/784340c0ca720e2313d59e15d4483aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GFYCU0E0AdvRvrSW2mBHzw.jpeg"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">该应用程序</figcaption></figure><p id="d8c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是项目的文件夹结构:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/96824a9e80572835e4336b988a644570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hA5dx2m07_sGfuh1vSu3Cw.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">文件夹结构</figcaption></figure><p id="b8bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能看起来很多。以下是一些解释:</p><p id="6c83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">资料:</strong>我们的M(模特)在MVVM。在那里我们执行数据操作。</p><p id="3101" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">迪:</strong>借助剑柄进行依存注射。</p><p id="c818" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ui :我们的片段和视图模型帮助向用户显示数据。</p><p id="834e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> utils </strong>:助手类和函数。</p><p id="ff16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我建议您在阅读本教程的同时，看看GitHub资源库。</p><div class="mb mc gp gr md me"><a href="https://github.com/sberoch/RickAndMorty-AndroidArchitectureSample" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">sbe Roch/RickAndMorty-Android architecture样本</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">一个Rick和Morty的简单应用程序，展示了在Android开发中使用一些最佳实践的一种方法。…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">github.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms kr me"/></div></div></a></div><p id="7a12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续之前还有最后一件事。当请求字符列表时，API返回这个响应</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="174f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到了分页的响应。实际字符在“结果”下返回。这就是为什么你会在文件夹<em class="mv">实体下找到三个类。</em>但最重要的还是人品。</p><p id="e669" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说到这里，我们继续讨论剑柄和迪。</p><h1 id="9173" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">柄</h1><p id="af59" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这不是阿迪教程，所以我强烈建议在继续之前先熟悉一下这个概念。反正我简单解释一下。</p><p id="5610" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于关注点分离的应用程序来说，一些组件之间存在依赖关系是很常见的。<strong class="jp ir">视图模型</strong>依赖于<strong class="jp ir">存储库</strong>来获取数据。但是存储库也依赖于一个<strong class="jp ir">character remote data source</strong>和一个<strong class="jp ir"> CharacterDao </strong>。这是一个简单的应用程序。它会很快变成一个依赖地狱。</p><p id="cbf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希尔特前来救援。我们只需要告知我们需要在哪里注入这些依赖，以及应该从哪里获取它们。</p><p id="5649" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先在根文件夹中创建一个从Application继承的类，对它进行注释，通知我们将在应用程序中使用Hilt。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">主应用程序. kt</figcaption></figure><p id="0d79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们需要将每个活动和片段标注为AndroidEntryPoints:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">主活动. kt</figcaption></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">CharacterDetailFragment.kt</figcaption></figure><p id="8751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的下一步是在di文件夹中创建我们的<strong class="jp ir"> </strong>模块。如果你不太熟悉di的概念，可以把模块想象成一个“袋子”,我们可以从这个袋子里得到我们的依赖关系。(我将在本教程接下来的章节中展示许多依赖项，所以如果您现在还不完全理解它们，请不要害怕)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">AppModule.kt</figcaption></figure><p id="fdec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mw mx my mz b"><strong class="jp ir">@Module</strong></code> <strong class="jp ir"> </strong>注释对象，表示我们将从这里获取依赖关系。我们将只在这个简单的应用程序中使用一个，但较大规模的项目通常有许多模块。</p><p id="3f4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mw mx my mz b"><strong class="jp ir">@Singleton</strong></code> <strong class="jp ir"> </strong>将强制只创建一个依赖项实例，并在整个应用程序中使用。</p><p id="a19d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mw mx my mz b"><strong class="jp ir">@Provides</strong></code> <strong class="jp ir"> </strong>表明即将到来的函数将提供一个依赖项。</p><p id="27c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那我该怎么注射呢？</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">@注入</figcaption></figure><h1 id="d43f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">ViewModel、LiveData和数据显示。</h1><p id="b85c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">多亏了LiveData和Kotlin协同程序的使用，我们可以避免回调，并有一个非常简单的方法将我们的数据呈现给我们的视图。这个视图模型是这样做的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">CharactersViewModel.kt</figcaption></figure><p id="a68d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能想知道<strong class="jp ir">资源。</strong>就是这个助手类</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">资源. kt</figcaption></figure><p id="3862" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它帮助我们根据状态封装我们的存储库响应，从而使我们的视图很容易相应地显示信息。这就是CharactersFragment观察LiveData值并相应更新自身的方式。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">CharactersFragment.kt(字符观察者)</figcaption></figure><p id="116c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有我们的表示层。我如何获得我的数据？</p><h1 id="d5ba" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">改造和远程数据。</h1><p id="f887" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">翻新帮助我们从我们的应用程序访问远程数据。你可以在<strong class="jp ir"> AppModule.kt </strong>中看到如何构建一个改造对象。我们还需要用HTTP操作编写接口，我们将执行这些操作来与API通信。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">CharacterService.kt</figcaption></figure><p id="b332" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kotlin协同程序为我们带来了<strong class="jp ir"> suspend </strong>修饰符，它表示下面的函数将在一个协同程序(类似于一个线程)中执行，允许我们在执行长时间的操作(例如从互联网上获取数据)时保持UI线程的畅通。</p><p id="6cf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此CharacterService由CharacterRemoteDataSource使用</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">CharacterRemoteDataSource.kt</figcaption></figure><p id="0f5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们为什么要这样做？公平的问题。<strong class="jp ir"> getResult </strong>将改进响应封装在一个<strong class="jp ir">资源</strong>中，这样我们就可以很好地捕捉错误。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">基础数据源. kt</figcaption></figure><h1 id="b2b7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">房间和本地数据存储</h1><p id="100f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">另一方面，我们也对从本地数据库中存储和获取数据感兴趣。我们需要它，以便当用户失去连接时，至少向他们显示一些东西。如果你熟悉这个概念，我们将把它作为我们系统的<em class="mv">缓存</em>。</p><p id="218c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Room为我们提供了一个很好的界面来处理本地数据库。我们在这里建造一个:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">AppDatabase.kt</figcaption></figure><p id="325e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记在<strong class="jp ir"> @Database </strong>注释中包含所有想要持久化的实体。为了有空间看到我们的实体，我们还需要注释它们。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">Character.kt</figcaption></figure><p id="7901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要指定将在数据库上执行的操作。这就是我们的Dao发挥作用的地方(数据访问对象)</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">字符道. kt</figcaption></figure><p id="0953" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，Room有LiveData支持，所以可以从数据库中获得可观察的值。而Kotlin Coroutines让我们暂停房间功能，让这变得更加容易。</p><h1 id="bfa9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">存储库和我们的缓存策略</h1><p id="19d2" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们连接两个数据源。这是我们需要计划数据访问策略的时候了。比如说，在得到一个角色的过程中。</p><ul class=""><li id="d6d1" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated">首先，我们需要让我们的LiveData知道我们正在寻找角色，这样它就应该有一个加载状态。</li><li id="5b24" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">然后，我们希望从本地数据源获取该字符，因为这比从互联网获取要快。如果它找到了，我们就成功地改变了状态</li><li id="bb50" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">不管本地数据库操作的结果如何，我们都希望保持我们的应用程序同步，所以我们也从互联网上获取那个字符(但是请记住，ui线程不会被阻塞，用户可能已经看到了正确的字符信息，因为它在数据库中！).</li><li id="8b56" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">最后，我们需要将远程调用的结果保存在数据库中，以便保持更新。</li></ul><p id="9dcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在我们的存储库中完成所有这些工作:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">CharacterRepository.kt</figcaption></figure><p id="8ea3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mw mx my mz b"><strong class="jp ir">performGetOperation</strong></code> <strong class="jp ir"> </strong>按照我们讨论的策略定义:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">DataAccessStrategy.kt</figcaption></figure><p id="602a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想突出显示我们做<code class="fe mw mx my mz b"><strong class="jp ir">liveData(Dispatchers.IO)</strong></code>的第一行</p><p id="2f5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢Kotlin协同例程和LiveData，当我们这样做时，我们启动了一个新的IO协同例程，因此允许我们使用我们的suspend函数，并且我们还将我们的结果存储在LiveData容器中，这是由ViewModel观察的。</p><p id="4e32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！</p><h1 id="c6cf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">进一步的步骤</h1><p id="4169" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们坚持到了最后。我希望我在整个教程中都很清楚。</p><p id="9e0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使事情简短，我省略了一些待办事项:</p><ul class=""><li id="bc20" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated">我们一直在与我提出的策略同步，而您的应用程序可能不需要它。牢记自己的需求，制定明智的策略。</li><li id="7a03" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">此外，我们只执行get操作。如果我们需要上传一些东西到服务器上呢？在这种情况下，策略也将不同。</li><li id="a475" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">API对其字符进行分页。为什么不呢？看看Jetpack的分页库。</li><li id="3c70" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">测试尚未进行。</li></ul><p id="d232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已。请记住，您可以在GitHub资源库中找到我使用的所有代码</p><div class="mb mc gp gr md me"><a href="https://github.com/sberoch/RickAndMorty-AndroidArchitectureSample" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">sbe Roch/RickAndMorty-Android architecture样本</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">一个Rick和Morty的简单应用程序，展示了在Android开发中使用一些最佳实践的一种方法。…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">github.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms kr me"/></div></div></a></div><p id="d5ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这些对你有用，请留下<strong class="jp ir">掌声</strong>！我将非常感激下一个教程。</p></div></div>    
</body>
</html>