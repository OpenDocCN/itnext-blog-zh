<html>
<head>
<title>Class hierarchy in Dart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart中的类层次结构</h1>
<blockquote>原文：<a href="https://itnext.io/class-hierarchy-in-dart-ecacc28d0581?source=collection_archive---------0-----------------------#2022-08-01">https://itnext.io/class-hierarchy-in-dart-ecacc28d0581?source=collection_archive---------0-----------------------#2022-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/a32384642460f2d55c126f8800aa8062.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*Pl29N797jwfqeVX2RTUJzw.png"/></div></figure><p id="0710" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">面向对象编程是每个开发人员在工作时都会接触到的一种范式。这种编程范式将数据结构化为一个对象，该对象可以具有被描述为方法的特定行为。</p><p id="69d9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Dart是一种面向对象的编程语言，这意味着它允许我们创建包含数据和函数的对象。Dart支持如此多的OOP特性，但是在本文中，我们将讨论层次结构、抽象类、接口和混合。</p><p id="5104" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，我们先来说说等级制度。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/dab45e856a3ec222bc81a5bf496bdec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*hGUVhLQP9H6_t3LZFkqQEA.gif"/></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="9bfd" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">等级制度</h1><p id="3f41" class="pw-post-body-paragraph ju jv iq jw b jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr ij bi translated">不谈阶级，就谈不上等级。</p><p id="78aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mh" href="https://www.oracle.com/java/technologies/oop.html" rel="noopener ugc nofollow" target="_blank">“类是定义数据和处理数据的方法的结构”</a></p><p id="3834" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">换句话说，我们可以将类描述为一个模板，以创建一组共享公共数据和行为的对象。</p><p id="1ef1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在编程中，类的层次结构是当一个类扩展另一个类(超类)时，获得超类的属性和功能。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="ebaf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如你所见，developer的类扩展了person的类，这意味着开发者可以访问Person类中的每个公共变量和函数。</p><blockquote class="mk ml mm"><p id="617e" class="ju jv mn jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated"><strong class="jw ir">如果没有定义超类默认构造函数，就必须像上面</strong>的代码中一样提到超类构造函数。<em class="iq">如果</em>语法<em class="iq">对你来说是新的，查看一下</em> <a class="ae mh" href="https://medium.com/flutter-community/types-of-construtors-in-dart-8642d3f176ae" rel="noopener"> <em class="iq">重定向构造函数</em> </a> <em class="iq">的定义。</em></p></blockquote><p id="7016" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">子类可以通过使用关键字<code class="fe mr ms mt mu b">@override</code>改变超类的扩展方法的行为。嗯，<code class="fe mr ms mt mu b">@override</code>注释不是必须要用的，但是推荐使用。您还可以重写getters和setters方法。</p><h2 id="440c" class="mv lf iq bd lg mw mx dn lk my mz dp lo kf na nb ls kj nc nd lw kn ne nf ma ng bi translated">创建类的实例。</h2><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="01fd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的例子中，你可以看到我们使用<code class="fe mr ms mt mu b">Developer()</code>构造函数创建了一个<code class="fe mr ms mt mu b">Person</code>对象。这是因为<code class="fe mr ms mt mu b">Developer</code>的类型是<code class="fe mr ms mt mu b">Person</code>，所以我们可以在Person实例中分配一个Developer对象。<br/>但是同样的事情不会反过来发生:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><blockquote class="mk ml mm"><p id="b690" class="ju jv mn jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">这不起作用，因为Person不是Developer的子类型。</p><p id="2239" class="ju jv mn jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">Dart中不能做的另一件事是多重继承，extends关键字只允许子类从另一个类扩展。</p></blockquote></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="203d" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">抽象类</h1><p id="c8c6" class="pw-post-body-paragraph ju jv iq jw b jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr ij bi translated">每个无法实例化的类，至少有一个方法没有体(方法声明以“；”结尾))被称为抽象类，正如关键字所暗示的。</p><blockquote class="mk ml mm"><p id="6b2d" class="ju jv mn jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">注意:所有至少有一个方法没有主体的类，必须声明为抽象类。</p></blockquote><p id="6d19" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们在最后一个层次示例中创建一个抽象类。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0e5c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意，在我们的<code class="fe mr ms mt mu b">Person</code>和<code class="fe mr ms mt mu b">SoftwareDeveloper</code> / <code class="fe mr ms mt mu b">AwsDeveloper</code>类中间有一个抽象类，这就是Developer类。当我们有共享相同方法实现逻辑的类时，使用这个类可以帮助我们避免代码重复，在我们的例子中是writeBlogPosts方法。</p><p id="0128" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当抽象类中的方法有主体时，它的子类不需要在它们的类内部调用它们，因为已经有了一个实现，当抽象方法上没有主体时，就需要一个方法实现。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="6bb7" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">接口</h1><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9c51" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是啊！这就是我们如何定义一个接口，就像我们定义一个抽象类一样，没有<code class="fe mr ms mt mu b">interface</code>关键字来声明它。但是编译器还不知道它是接口还是子类的抽象类。</p><p id="4a52" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">那么，它怎么知道是不是呢？</strong></p><p id="8a94" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们声明我们的子类时，我们使用<code class="fe mr ms mt mu b"><em class="mn">implements</em></code> <em class="mn"> </em>关键字来指定我们想要作为接口的抽象类。</p><p id="11dd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，让我们把我们的<code class="fe mr ms mt mu b">RoadMap </code>类变成<code class="fe mr ms mt mu b">SoftwareDeveloper</code>接口。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="dc3f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦我们将<code class="fe mr ms mt mu b"><em class="mn">implements RoadMap</em></code> <em class="mn"> </em>添加到<code class="fe mr ms mt mu b">SoftwareDeveloper</code>定义中，编译器就会触发一个警告，要求我们实现<code class="fe mr ms mt mu b">RoadMap</code>接口中的方法。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><blockquote class="mk ml mm"><p id="3485" class="ju jv mn jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">一个重要的注意事项是，一个类可以实现不止一个接口，这与关键字<code class="fe mr ms mt mu b">extends</code>不同，关键字只允许一个类扩展另一个类。</p></blockquote></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="5980" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">混合蛋白</h1><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/393a6be2466c05ef87cb281b825c6937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*M3e1wp3-agzVF8SzBbAebA.gif"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">嘿，我说混血儿！</figcaption></figure><p id="5cc9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是类层次结构主题中的另一个概念。Mixins的行为类似于抽象类，但没有构造函数，它们用于提供方法并避免代码重复(当两个或更多的类共享时)。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="1ef0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要将一个mixin附加到一个类，我们只需使用<code class="fe mr ms mt mu b"><em class="mn">with</em></code>关键字，后跟mixin名称。我们也可以将多个mixins附加到一个类中。</p><p id="0845" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们将它附加到我们的<code class="fe mr ms mt mu b">AwsDeveloper</code>类中。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="30aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在<code class="fe mr ms mt mu b">AwsDeveloper</code>可以访问<code class="fe mr ms mt mu b">SideHustle</code> mixin方法了🙂。</p><p id="8996" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们想把它附加到我们的<code class="fe mr ms mt mu b">SoftwareDeveloper</code>类，我们必须在<code class="fe mr ms mt mu b"><em class="mn">implements</em></code>关键字之前设置<code class="fe mr ms mt mu b"><em class="mn">with</em></code>关键字，就像这样:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="ee3e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当不需要使用Mixins来实现所提供的方法时，您可以在任何需要的时候访问它们。</p><p id="2b4e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于mixin的另一个有趣的事实是，一个mixin可以附加到另一个mixin上。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="97fc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的例子中，<code class="fe mr ms mt mu b">justAmixin</code>可以访问<code class="fe mr ms mt mu b">SideHustle</code> mixin。</p><p id="5658" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的类层次结构如下所示:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/6018384aabdfcdedb656d0e7ffd5c4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EprNuwSCWk3dx6kE9LqvyA.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="4643" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实际的例子</h1><p id="de26" class="pw-post-body-paragraph ju jv iq jw b jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr ij bi translated">让我们用我们到目前为止所做的。在这一小节中，我们将对我们编写的代码做一些小的改动。让我们这样做:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3128" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们向Person类添加了三(3)个方法<code class="fe mr ms mt mu b">toString()</code>、<code class="fe mr ms mt mu b">Person.fromJson</code>和默认构造函数<code class="fe mr ms mt mu b">Person.ordinary()</code>。</p><ul class=""><li id="80f2" class="nr ns iq jw b jx jy kb kc kf nt kj nu kn nv kr nw nx ny nz bi translated"><code class="fe mr ms mt mu b">toString</code>显示人名。</li><li id="081c" class="nr ns iq jw b jx oa kb ob kf oc kj od kn oe kr nw nx ny nz bi translated"><code class="fe mr ms mt mu b">Person.fromJson()</code>生成<code class="fe mr ms mt mu b">SoftwareDeveloper</code>和<code class="fe mr ms mt mu b">AwsDeveloper</code>等人员实例</li><li id="caf5" class="nr ns iq jw b jx oa kb ob kf oc kj od kn oe kr nw nx ny nz bi translated"><code class="fe mr ms mt mu b">Person.ordinary()</code>如果我们从Json收到一个非预期的对象，创建一个默认的Person。</li></ul><p id="424f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们使用<code class="fe mr ms mt mu b">Person.fromJson()</code>工厂构造函数创建对象。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0e4d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">输出</strong>:</p><p id="bc82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mr ms mt mu b">Algy jr : 5 deployed Projects</code></p><p id="a53a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mr ms mt mu b">Almeida de Almeida : is working as a Cloud developer and sometimes produces youtube videos</code></p><p id="fcdd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mr ms mt mu b">Feliciano Jr : 5 deployed Projects</code></p><p id="6a93" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mr ms mt mu b">John Doe</code></p><p id="994a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，我们将John Doe作为输出，这是因为json中的最后一个对象有一个非预期类型，在本例中，我们使用默认构造函数创建了一个默认的Person对象。还要注意，我们使用了附加到<code class="fe mr ms mt mu b">AwsDeveloper</code>类的<code class="fe mr ms mt mu b">SideHustle</code> mixin中的<code class="fe mr ms mt mu b">videoCreator</code>方法。</p><h1 id="681f" class="le lf iq bd lg lh of lj lk ll og ln lo lp oh lr ls lt oi lv lw lx oj lz ma mb bi translated">结论</h1><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/67cb512705128b4cdee4fde5606a9ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/1*AlCa8CIr3ECOmmJE1uRheA.gif"/></div></figure><p id="a406" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们希望一个类(或多个类)可以访问父方法和属性时，我们使用extend，并且不要求子类实现超类提供的所有方法，但要求在子类构造函数中调用超类构造函数。</p><p id="6ac0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">抽象类不是实例化类，这意味着您不能直接从它们创建对象，而是从它们的派生类创建。当我们想要将方法实现分组到一个地方时，我们可以使用抽象类，这样子类可以在以后实现它们。</p><p id="21f3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Dart中的接口是包含方法签名的抽象类(空体)。接口中定义的签名必须在实现它的类中重写。</p><p id="9bf0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Mixins可用于保存方法实现和方法签名，这些方法签名可由它们所附加的类在以后使用。</p><blockquote class="mk ml mm"><p id="feea" class="ju jv mn jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">什么时候使用接口而不是混合或抽象类？</p><p id="0e2e" class="ju jv mn jw b jx jy jz ka kb kc kd ke mo kg kh ki mp kk kl km mq ko kp kq kr ij bi translated">答案是没有规则，因为这取决于业务规则或您试图解决的问题。一个很好的建议是通过尽量避免代码重复和编写高质量的代码来使用它们。</p></blockquote></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="31a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">谢谢！</strong>阅读这篇文章，希望对你有所帮助。</p><p id="2a1f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你有任何疑问或者你可能觉得有什么遗漏，你可以通过<a class="ae mh" href="https://twitter.com/a_azinar" rel="noopener ugc nofollow" target="_blank">推特</a>或者<a class="ae mh" href="https://t.me/albertoazinar" rel="noopener ugc nofollow" target="_blank">电报</a>联系我。我很乐意和你谈谈这件事。</p><p id="d172" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="mn">一切都是小工具！</em>T9】</strong></p></div></div>    
</body>
</html>