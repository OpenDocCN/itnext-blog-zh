<html>
<head>
<title>Two-phased canary rollout with Gloo, part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gloo的两阶段金丝雀展示，第3部分</h1>
<blockquote>原文：<a href="https://itnext.io/two-phased-canary-rollout-with-gloo-part-3-a523114a7d9a?source=collection_archive---------6-----------------------#2020-05-28">https://itnext.io/two-phased-canary-rollout-with-gloo-part-3-a523114a7d9a?source=collection_archive---------6-----------------------#2020-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="beca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/two-phased-canary-rollout-with-gloo-part-1-ec5b267cdc9e">第一部分中，我们试图提出一个健壮的工作流，您可以用它来执行金丝雀测试和渐进交付，这样团队就可以在生产环境中安全地向用户交付他们服务的新版本。</a></p><p id="070c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/two-phased-canary-rollout-with-gloo-part-2-ffa556a503b0">在第二部分</a>，我们看了如何将它扩展到潜在的许多团队，同时保持域和路由级配置之间的清晰分离。这有助于最大限度地减少开发团队为促进这些工作流而需要维护的配置数量，并使平台能够自助服务，同时防止错误配置。</p><p id="4b17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一部分中，我们将创建一个掌舵图，我们的开发团队可以使用它将应用程序部署到他们的Kubernetes集群上的Gloo。这意味着他们可以通过提供一些helm值来安装应用程序，并且他们可以通过执行helm升级来调用canary升级工作流。这样做有很多好处:</p><ul class=""><li id="8706" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">它降低了进入的门槛；这个工作流程很容易执行。</li><li id="daa6" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">它极大地减少了不同团队需要维护的(通常)复制粘贴配置的数量。</li><li id="fda5" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">它提供了很好的防护栏，最大限度地减少了错误配置的可能性。</li><li id="eb3d" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">集成到GitOps /连续交付工作流中变得微不足道。</li></ul><p id="5bab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为免责声明，许多服务最终都需要相当广泛的配置，其中一些是特定用例所特有的。然而，在一定程度上，你的团队可以遵循标准的惯例，这些惯例可以像我们在这里做的那样被编码在掌舵图中。对于这一部分，我们将为我们的场景创建一个最小的定制集；将来，我们会让它更通用。</p><h1 id="aa41" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置我们的图表</h1><p id="8b6b" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">Helm包括一个创建图表的工具。运行<code class="fe md me mf mg b">helm create gloo-app</code>之后，您将得到一个包含一个<code class="fe md me mf mg b">Chart.yaml</code>、一个默认的<code class="fe md me mf mg b">values.yaml</code>、一个空的crds目录和一个包含许多文件的templates目录的目录。</p><p id="af5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将更新<code class="fe md me mf mg b">Chart.yaml</code>，删除空的crds目录，并且我们将删除模板目录的内容。在接下来的几个步骤中，我们将开始添加模板来模拟我们的服务。</p><h1 id="14fd" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">分解我们的需求</h1><p id="46f9" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">在最后一部分中，我们通过应用四个资源来部署每个服务——echo和foxtrot:部署、服务、gloo上游和gloo路由表。这些将成为我们图表中的四个模板。我们将假设每个服务的名称空间都是预先或自动创建的，并且不包含在图表本身中。</p><p id="d567" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，该图表不包含Gloo控制平面本身，也不包含将所有路由表绑定到我们的域的单一虚拟服务。这些将由一个中央平台团队建立，而掌舵图旨在供开发团队使用，以便加入平台。</p><h1 id="060d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设计我们的初始价值观</h1><p id="186b" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们将提取最少的最小值，以便图表可以在特定版本部署我们的<code class="fe md me mf mg b">echo</code>或<code class="fe md me mf mg b">foxtrot</code>服务。我们需要为我们的应用程序提供四个值:</p><ul class=""><li id="93af" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">服务名(<code class="fe md me mf mg b">echo</code>):我们将从Helm release的名称中提取，并在模板中用<code class="fe md me mf mg b">{{ .Release.Name }}</code>访问它</li><li id="b67e" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">名称空间(<code class="fe md me mf mg b">echo</code>):这也将由Helm命令提供，所以我们将使用<code class="fe md me mf mg b">{{ .Release.Namespace }}</code>来访问它。</li><li id="5227" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">App Version ( <code class="fe md me mf mg b">v1</code>):这将决定在pod上用于子集路由的版本标签。现在，我们将使用<code class="fe md me mf mg b">{{ .Values.appVersion }}</code>访问它。</li><li id="d1ec" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">Api Group ( <code class="fe md me mf mg b">example</code>):这将是我们在路由表中使用的标签，因此它与我们的虚拟服务选择器相匹配，现在我们将使用<code class="fe md me mf mg b">{{ .Values.apiGroup }}</code></li></ul><h1 id="0c16" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建我们的模板</h1><p id="de27" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">现在我们可以创建模板了。</p><h2 id="e75f" class="mh lb iq bd lc mi mj dn lg mk ml dp lk jy mm mn lo kc mo mp ls kg mq mr lw ms bi translated">部署</h2><p id="14a5" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">首先，让我们在<code class="fe md me mf mg b">templates/deployment.yaml</code>中创建一个部署。我们最初的echo部署如下所示:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="2123" class="mh lb iq mg b gy nb nc l nd ne">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: echo-v1<br/>  namespace: echo<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: echo<br/>      version: v1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: echo<br/>        version: v1<br/>    spec:<br/>      containers:<br/>        - image: hashicorp/http-echo<br/>          args:<br/>            - "-text=version:echo-v1"<br/>            - -listen=:8080<br/>          imagePullPolicy: Always<br/>          name: echo-v1<br/>          ports:<br/>            - containerPort: 8080</span></pre><p id="763b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了将此归纳为一个可以部署<code class="fe md me mf mg b">echo</code>或<code class="fe md me mf mg b">foxtrot</code>的模板，在一个特定的版本中，让我们提取值。这就产生了这样一个模板:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="e82e" class="mh lb iq mg b gy nb nc l nd ne">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: {{ .Release.Name }}-{{ .Values.appVersion }}<br/>  namespace: {{ .Release.Namespace }}<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: {{ .Release.Name }}<br/>      version: {{ .Values.appVersion }}<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: {{ .Release.Name }}<br/>        version: {{ .Values.appVersion }}<br/>    spec:<br/>      containers:<br/>        - image: hashicorp/http-echo<br/>          args:<br/>            - "-text=version:{{ .Release.Name }}-{{ .Values.appVersion }}"<br/>            - -listen=:8080<br/>          imagePullPolicy: Always<br/>          name: {{ .Release.Name }}-{{ .Values.appVersion }}<br/>          ports:<br/>            - containerPort: 8080</span></pre><h2 id="a52f" class="mh lb iq bd lc mi mj dn lg mk ml dp lk jy mm mn lo kc mo mp ls kg mq mr lw ms bi translated">服务</h2><p id="8a02" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们的服务也是如此。我们最初的服务是这样的:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="0b9b" class="mh lb iq mg b gy nb nc l nd ne">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: echo<br/>  namespace: echo<br/>spec:<br/>  ports:<br/>    - port: 80<br/>      targetPort: 8080<br/>      protocol: TCP<br/>  selector:<br/>    app: echo</span></pre><p id="3e79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将基于此创建一个模板，并提取我们的值:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="16e7" class="mh lb iq mg b gy nb nc l nd ne">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: {{ .Release.Name }}<br/>  namespace: {{ .Release.Namespace }}<br/>spec:<br/>  ports:<br/>    - port: 80<br/>      targetPort: 8080<br/>      protocol: TCP<br/>  selector:<br/>    app: {{ .Release.Name }}</span></pre><h2 id="0a38" class="mh lb iq bd lc mi mj dn lg mk ml dp lk jy mm mn lo kc mo mp ls kg mq mr lw ms bi translated">向上游</h2><p id="8203" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">现在我们已经有了部署和服务，我们可以添加我们的上游。我们最初的上游是这样的:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="56a7" class="mh lb iq mg b gy nb nc l nd ne">apiVersion: gloo.solo.io/v1<br/>kind: Upstream<br/>metadata:<br/>  name: echo<br/>  namespace: gloo-system<br/>spec:<br/>  kube:<br/>    selector:<br/>      app: echo<br/>    serviceName: echo<br/>    serviceNamespace: echo<br/>    servicePort: 8080<br/>    subsetSpec:<br/>      selectors:<br/>        - keys:<br/>            - version</span></pre><p id="ec9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将提取到以下模板中:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="7956" class="mh lb iq mg b gy nb nc l nd ne">apiVersion: gloo.solo.io/v1<br/>kind: Upstream<br/>metadata:<br/>  name: {{ .Release.Name }}<br/>  namespace: {{ .Release.Namespace }}<br/>spec:<br/>  kube:<br/>    selector:<br/>      app: {{ .Release.Name }}<br/>    serviceName: {{ .Release.Name }}<br/>    serviceNamespace: {{ .Release.Namespace }}<br/>    servicePort: 8080<br/>    subsetSpec:<br/>      selectors:<br/>        - keys:<br/>            - version</span></pre><h2 id="91c8" class="mh lb iq bd lc mi mj dn lg mk ml dp lk jy mm mn lo kc mo mp ls kg mq mr lw ms bi translated">路由表</h2><p id="6da5" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">最后，我们需要创建包含初始路由的路由表。首先，这看起来像是:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="5db8" class="mh lb iq mg b gy nb nc l nd ne">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: foxtrot-routes<br/>  namespace: foxtrot<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - prefix: /foxtrot<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: foxtrot<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v1</span></pre><p id="0d5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将基于该路由表创建以下模板:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="a750" class="mh lb iq mg b gy nb nc l nd ne">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: {{ .Release.Name }}-routes<br/>  namespace: {{ .Release.Namespace }}<br/>  labels:<br/>    apiGroup: {{ .Values.apiGroup }}<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - prefix: "/{{ .Release.Name }}"<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: {{ .Release.Name }}<br/>            namespace: {{ .Release.Namespace }}<br/>          subset:<br/>            values:<br/>              version: {{ .Values.appVersion }}</span></pre><h1 id="4398" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">默认值</h1><p id="f721" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们可以将图表中的默认<code class="fe md me mf mg b">values.yaml</code>更新为以下内容:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="6f84" class="mh lb iq mg b gy nb nc l nd ne">appVersion: v1<br/>apiGroup: example</span></pre><h1 id="705a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">测试我们的图表</h1><p id="a413" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">现在，我们应该已经有了使用以下命令部署echo和foxtrot所需的组件:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="73ce" class="mh lb iq mg b gy nb nc l nd ne">kubectl create ns echo<br/>helm install echo  ./gloo-app --namespace echo<br/>kubectl create ns foxtrot<br/>helm install foxtrot  ./gloo-app --namespace foxtrot</span></pre><h2 id="0bd5" class="mh lb iq bd lc mi mj dn lg mk ml dp lk jy mm mn lo kc mo mp ls kg mq mr lw ms bi translated">测试舵图的侧边栏</h2><p id="c2fd" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">关于如何测试舵图，有不同的学派。在Gloo中，我们创建了一些库，这样我们就可以确保当提供不同的值集时，图表可以使用预期的资源进行呈现。头盔3也有一些内置的测试起点。实际上，用于生产的图表应该经过良好的测试，但是在这篇文章中，我们将跳过单元测试。</p><p id="a4af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开发这些模板时，我们可能使用的另一种技术是定期运行带有<code class="fe md me mf mg b">--dry-run</code>标志的<code class="fe md me mf mg b">helm install</code>命令，以确保模板没有语法错误，并且资源按照我们的预期呈现。</p><h1 id="a629" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">更新我们的图表以支持两阶段升级工作流程</h1><p id="0747" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">现在我们有了一个基础图表，我们需要公开一些值来帮助执行我们的分阶段升级工作流。请记住，我们的推广战略有以下几个阶段:</p><ul class=""><li id="7141" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">第1阶段:金丝雀测试，使用一个特殊的报头，将少量有目标的流量路由到新版本进行功能测试</li><li id="096d" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">阶段2:将负载转移到新版本，同时监控性能</li></ul><h1 id="a768" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设计我们的掌舵价值观</h1><p id="b5da" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们可以从设计一些能够表达工作流中不同点的值开始。特别是，如果我们考虑在工作流程中需要修改哪些资源，我们的价值观中有两个主要部分:</p><ul class=""><li id="baa7" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">部署:该部分将用于控制要安装的部署版本。我们可能想要部署单个版本，或者多个版本。可能需要部署一个版本而根本不路由到它，例如做阴影。不同的版本需要不同的配置，所以我们在设计时会有这样的假设。</li><li id="c718" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">Routes:这个部分将用于配置我们处于流的哪个阶段。我们将使用<code class="fe md me mf mg b">routes.primary</code>来配置我们的主要路线，使用<code class="fe md me mf mg b">routes.canary</code>来对canary工作流程的不同阶段进行所有必要的修改。</li></ul><p id="43e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到这些需求，我们将把我们的<code class="fe md me mf mg b">deployment</code> helm值做成一个映射，其中键是版本名，值是特定于版本的配置。然后，为了配置我们的主版本和金丝雀版本，我们将使用这些键来指定一个版本。</p><p id="652d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将使用一种简单的方法来完成第2阶段。我们将添加一个<code class="fe md me mf mg b">routes.canary.weight</code>参数，这样金丝雀目的地可以被赋予0到100之间的权重。主重量将按<code class="fe md me mf mg b">100 - routes.canary.weight</code>计算。</p><h2 id="c4e2" class="mh lb iq bd lc mi mj dn lg mk ml dp lk jy mm mn lo kc mo mp ls kg mq mr lw ms bi translated">金丝雀工作流程，表示为舵值</h2><p id="b550" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">既然我们已经决定了一个设计，让我们实际上用一系列的舵值来表达这个工作流程。</p><p id="879d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们有我们的开始状态，在这里我们部署应用程序的v1:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="1c5e" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v1: {} <br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v1</span></pre><p id="40f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们可以部署v2，但还没有设置任何金丝雀路由:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="3af3" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v1: {} <br/>  v2: {} <br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v1</span></pre><p id="a4d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以开始阶段1，并提供金丝雀配置:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="5f4f" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v1: {} <br/>  v2: {} <br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v1<br/>  canary:<br/>    version: v2<br/>    headers: <br/>      stage: canary</span></pre><p id="1110" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们准备开始第二阶段时，我们可以开始调整金丝雀路线的权重。请注意，为简单起见，前面的值等效于此值(0重量):</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="c00c" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v1: {} # we'll most likely want version-specific deployment configuration in the future;<br/>  v2: {} # for now, we just need the list of versions that should be deployed<br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v1<br/>  canary:<br/>    version: v2<br/>    weight: 0 # 0 to 100 to facilitate traffic shift<br/>    headers: <br/>      stage: canary</span></pre><p id="49da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们完成工作流程的一半时，我们的值可能如下所示:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="dcb9" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v1: {} # we'll most likely want version-specific deployment configuration in the future;<br/>  v2: {} # for now, we just need the list of versions that should be deployed<br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v1<br/>  canary:<br/>    version: v2<br/>    weight: 50 # 0 to 100 to facilitate traffic shift<br/>    headers: <br/>      stage: canary</span></pre><p id="5f03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将所有流量转移到金丝雀版本:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="b7ed" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v1: {} # we'll most likely want version-specific deployment configuration in the future;<br/>  v2: {} # for now, we just need the list of versions that should be deployed<br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v1<br/>  canary:<br/>    version: v2<br/>    weight: 100 # 0 to 100 to facilitate traffic shift<br/>    headers: <br/>      stage: canary</span></pre><p id="f103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是淘汰旧版本:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="a6ed" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v2: {} # for now, we just need the list of versions that should be deployed<br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v2</span></pre><p id="abd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太棒了——我们现在可以用声明性的舵值来表达我们工作流程的每一步。这意味着一旦我们更新了图表，我们将能够简单地通过运行<code class="fe md me mf mg b">helm upgrade</code>来执行我们的工作流。</p><h1 id="0577" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">更新我们的模板</h1><p id="ec5e" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">现在我们知道了我们想要如何表达我们的价值观，我们可以更新模板了。由于上游和服务模板没有使用来自Helm值的任何内容，我们不需要更改它们，我们只需要更新部署和路由表。</p><h2 id="5c15" class="mh lb iq bd lc mi mj dn lg mk ml dp lk jy mm mn lo kc mo mp ls kg mq mr lw ms bi translated">部署</h2><p id="7c5c" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们的部署模板需要更新，因为<code class="fe md me mf mg b">deployment</code>是版本到配置的映射。我们希望为地图中的每个版本创建一个部署资源，因此我们将包装模板以覆盖部署值。看起来是这样的:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="cdd3" class="mh lb iq mg b gy nb nc l nd ne">{{- $relname := .Release.Name -}}<br/>{{- $relns := .Release.Namespace -}}<br/>{{- range $version, $config := .Values.deployment }}<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: {{ $relname }}-{{ $version }}<br/>  namespace: {{ $relns }}<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: {{ $relname }}<br/>      version: {{ $version }}<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: {{ $relname }}<br/>        version: {{ $version }}<br/>    spec:<br/>      containers:<br/>        - image: hashicorp/http-echo<br/>          args:<br/>            - "-text=version:{{ $relname }}-{{ $version }}"<br/>            - -listen=:8080<br/>          imagePullPolicy: Always<br/>          name: {{ $relname }}-{{ $version }}<br/>          ports:<br/>            - containerPort: 8080<br/>---<br/>{{- end }}</span></pre><p id="8501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于这一点，请注意以下几点:</p><ul class=""><li id="15ab" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">使用范围影响范围，所以<code class="fe md me mf mg b">.Release.Name</code>和<code class="fe md me mf mg b">.Release.Namespace</code>在范围内不可用。相反，我们将把它们保存到我们可以访问的变量中。</li><li id="b3d8" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">我们添加了一个YAML分隔符，因为我们有时会最终生成多个对象。</li></ul><p id="1855" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">否则，这看起来非常类似于我们以前的模板。</p><h2 id="202d" class="mh lb iq bd lc mi mj dn lg mk ml dp lk jy mm mn lo kc mo mp ls kg mq mr lw ms bi translated">路由表</h2><p id="7116" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">现在，让我们更新路由表，在指定这些值后，开始表达我们的金丝雀路由配置。</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="d262" class="mh lb iq mg b gy nb nc l nd ne">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: {{ .Release.Name }}-routes<br/>  namespace: {{ .Release.Namespace }}<br/>  labels:<br/>    apiGroup: {{ .Values.routes.apiGroup }}<br/>spec:<br/>  routes:<br/>    {{- if .Values.routes.canary }}<br/>    - matchers:<br/>        - headers:<br/>            {{- range $headerName, $headerValue := .Values.routes.canary.headers }}<br/>            - name: {{ $headerName }}<br/>              value: {{ $headerValue }}<br/>            {{- end }}<br/>          prefix: "/{{ .Release.Name }}"<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: {{ .Release.Name }}<br/>            namespace: {{ .Release.Namespace }}<br/>          subset:<br/>            values:<br/>              version: {{ .Values.routes.canary.version }}<br/>    {{- end }}<br/>    - matchers:<br/>        - prefix: "/{{ .Release.Name }}"<br/>      routeAction:<br/>        {{- if .Values.routes.canary }}<br/>        multi:<br/>          destinations:<br/>            - destination:<br/>                upstream:<br/>                  name: {{ .Release.Name }}<br/>                  namespace: {{ .Release.Namespace }}<br/>                subset:<br/>                  values:<br/>                    version: {{ .Values.routes.primary.version }}<br/>              weight: {{ sub 100 .Values.routes.canary.weight }}<br/>            - destination:<br/>                upstream:<br/>                  name: {{ .Release.Name }}<br/>                  namespace: {{ .Release.Namespace }}<br/>                subset:<br/>                  values:<br/>                    version: {{ .Values.routes.canary.version }}<br/>              weight: {{ add 0 .Values.routes.canary.weight }}<br/>        {{- else }}<br/>        single:<br/>          upstream:<br/>            name: {{ .Release.Name }}<br/>            namespace: {{ .Release.Namespace }}<br/>          subset:<br/>            values:<br/>              version: {{ .Values.routes.primary.version }}<br/>        {{- end }}</span></pre><p id="d53b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们一段一段来。我们对顶部的元数据做的唯一改变是我们把<code class="fe md me mf mg b">apiGroup</code>移到了一个新的头盔值。</p><p id="9723" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe md me mf mg b">routes</code>部分，事情开始变得有趣起来。首先，我们添加了一个条件块来呈现金丝雀路线:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="ed2b" class="mh lb iq mg b gy nb nc l nd ne">{{- if .Values.routes.canary }}<br/>    - matchers:<br/>        - headers:<br/>            {{- range $headerName, $headerValue := .Values.routes.canary.headers }}<br/>            - name: {{ $headerName }}<br/>              value: {{ $headerValue }}<br/>            {{- end }}<br/>          prefix: "/{{ .Release.Name }}"<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: {{ .Release.Name }}<br/>            namespace: {{ .Release.Namespace }}<br/>          subset:<br/>            values:<br/>              version: {{ .Values.routes.canary.version }}<br/>    {{- end }}</span></pre><p id="6bfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要<code class="fe md me mf mg b">canary</code>不为零，这条路线就会被包括在内。它将使用我们引入的<code class="fe md me mf mg b">version</code>和<code class="fe md me mf mg b">headers</code>值来指定匹配和子集路由应该如何工作。</p><p id="1703" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要定制另一条路线上的路线操作，因为在第2阶段，我们将其从单目的地更改为多目的地，并建立权重:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="043c" class="mh lb iq mg b gy nb nc l nd ne">      routeAction:<br/>        {{- if .Values.routes.canary }}<br/>        multi:<br/>          destinations:<br/>            - destination:<br/>                upstream:<br/>                  name: {{ .Release.Name }}<br/>                  namespace: {{ .Release.Namespace }}<br/>                subset:<br/>                  values:<br/>                    version: {{ .Values.routes.primary.version }}<br/>              weight: {{ sub 100 .Values.routes.canary.weight }}<br/>            - destination:<br/>                upstream:<br/>                  name: {{ .Release.Name }}<br/>                  namespace: {{ .Release.Namespace }}<br/>                subset:<br/>                  values:<br/>                    version: {{ .Values.routes.canary.version }}<br/>              weight: {{ add 0 .Values.routes.canary.weight }}<br/>        {{- else }}<br/>        single:<br/>          upstream:<br/>            name: {{ .Release.Name }}<br/>            namespace: {{ .Release.Namespace }}<br/>          subset:<br/>            values:<br/>              version: {{ .Values.routes.primary.version }}<br/>        {{- end }}</span></pre><p id="d426" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简单起见，一旦提供了金丝雀值，我们就切换到多目的地。除非用户明确地给金丝雀增加一个权重，否则这不会有任何影响，所有的流量将继续被路由到主版本。这只是保持我们的模板和值最小。</p><p id="0613" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个有趣的注意事项是，我们在权重上使用了<code class="fe md me mf mg b">Helm</code>算术函数，因此我们总是以总权重100结束，并且用户只需要在值中指定一个权重。</p><h1 id="aee7" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用我们的新图表运行工作流程</h1><p id="70e5" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们现在准备好执行我们的整个canary工作流，通过执行helm安装，然后升级和更改值。</p><p id="f84e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我假设我们在Kubernetes集群上部署了Gloo，并且没有任何现有的虚拟服务。如果您之前已经安装了<code class="fe md me mf mg b">echo</code>和<code class="fe md me mf mg b">foxtrot</code>，只需运行<code class="fe md me mf mg b">kubectl delete ns echo foxtrot</code>即可。我们将从为我们的<code class="fe md me mf mg b">example</code> API组部署通用虚拟服务开始。然后，当我们用我们的舵图安装新的服务时，这些航线将被自动选取。</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="179a" class="mh lb iq mg b gy nb nc l nd ne">apiVersion: gateway.solo.io/v1<br/>kind: VirtualService<br/>metadata:<br/>  name: app<br/>  namespace: gloo-system<br/>spec:<br/>  virtualHost:<br/>    domains:<br/>      - '*'<br/>    routes:<br/>      - matchers:<br/>          - prefix: /<br/>        delegateAction:<br/>          selector:<br/>            labels:<br/>              apiGroup: example<br/>            namespaces:<br/>              - "*"</span></pre><p id="e7af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用以下命令将其应用于集群:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="29eb" class="mh lb iq mg b gy nb nc l nd ne">kubectl apply -f vs.yaml</span></pre><p id="2df0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经准备好开始使用图表部署服务了。</p><h1 id="295b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">安装echo</h1><p id="9527" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">让我们为echo创建一个名称空间。</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="98ba" class="mh lb iq mg b gy nb nc l nd ne">kubectl create ns echo</span></pre><p id="3765" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以使用初始值进行安装:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="58f9" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v1: {}<br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v1</span></pre><p id="599c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将发出以下命令来安装helm:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="9772" class="mh lb iq mg b gy nb nc l nd ne">➜ k create ns echo<br/>namespace/echo created</span><span id="bf11" class="mh lb iq mg b gy nf nc l nd ne">➜ helm install echo  ./gloo-app --namespace echo -f values-1.yaml<br/>NAME: echo<br/>LAST DEPLOYED: Thu Apr 16 16:04:29 2020<br/>NAMESPACE: echo<br/>STATUS: deployed<br/>REVISION: 1<br/>TEST SUITE: None</span></pre><p id="40a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以验证事情是否正常，并测试路线:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="11f4" class="mh lb iq mg b gy nb nc l nd ne">➜ glooctl check<br/>Checking deployments... OK<br/>Checking pods... OK<br/>Checking upstreams... OK<br/>Checking upstream groups... OK<br/>Checking auth configs... OK<br/>Checking secrets... OK<br/>Checking virtual services... OK<br/>Checking gateways... OK<br/>Checking proxies... OK<br/>No problems detected.</span><span id="8d3b" class="mh lb iq mg b gy nf nc l nd ne">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v1</span></pre><p id="8e81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！我们的安装已经完成。通过安装我们的图表，我们能够将Gloo中的新服务的新路线上线。</p><p id="f8c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更好地衡量，让我们也安装狐步舞:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="1da2" class="mh lb iq mg b gy nb nc l nd ne">➜ kubectl create ns foxtrot<br/>namespace/foxtrot created</span><span id="eb92" class="mh lb iq mg b gy nf nc l nd ne">➜ helm install foxtrot  ./gloo-app --namespace foxtrot -f values-1.yaml<br/>NAME: foxtrot<br/>LAST DEPLOYED: Thu Apr 16 16:08:23 2020<br/>NAMESPACE: foxtrot<br/>STATUS: deployed<br/>REVISION: 1<br/>TEST SUITE: None</span><span id="3d72" class="mh lb iq mg b gy nf nc l nd ne">➜ curl $(glooctl proxy url)/foxtrot<br/>version:foxtrot-v1</span></pre><p id="af12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与以前相比，这是一个巨大的改进，在以前，我们需要复制粘贴大量的yaml，并且需要做更多的手工工作来使新的服务上线。让我们看看这如何扩展到推动我们的升级工作流程。</p><h1 id="6bdf" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">开始升级到echo-v2</h1><p id="d27a" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们将使用以下值进行头盔升级，最初部署echo-v2。请注意，这还没有创建任何金丝雀路线，它只是添加了新的部署:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="82d9" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v1: {}<br/>  v2: {}<br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v1</span></pre><p id="65b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe md me mf mg b">helm upgrade</code>，我们可以执行这个步骤:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="f06c" class="mh lb iq mg b gy nb nc l nd ne">➜ helm upgrade echo --values values-2.yaml  ./gloo-app --namespace echo<br/>Release "echo" has been upgraded. Happy Helming!<br/>NAME: echo<br/>LAST DEPLOYED: Thu Apr 16 16:12:03 2020<br/>NAMESPACE: echo<br/>STATUS: deployed<br/>REVISION: 4<br/>TEST SUITE: None</span></pre><p id="7e55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，新部署已经创建，v2 pod现在正在运行:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="3721" class="mh lb iq mg b gy nb nc l nd ne">➜ kubectl get pods -n echo<br/>NAME                       READY   STATUS    RESTARTS   AGE<br/>echo-v1-8569c78bcf-dtl6m   1/1     Running   0          9m5s<br/>echo-v2-9c4b669cd-ldkdv    1/1     Running   0          90s</span></pre><p id="5ee7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的路线仍然有效:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="b0a3" class="mh lb iq mg b gy nb nc l nd ne">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v1</span></pre><h1 id="fdb6" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">进入第一阶段</h1><p id="686b" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">现在我们要在标题<code class="fe md me mf mg b">stage: canary</code>上设置一个匹配的路由，并路由到新版本。所有其他请求应该继续路由到旧版本。我们可以用另一个<code class="fe md me mf mg b">helm upgrade</code>来部署它。我们将使用这些值:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="b71e" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v1: {}<br/>  v2: {}<br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v1<br/>  canary:<br/>    version: v2<br/>    headers:<br/>      stage: canary</span></pre><p id="f6e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用以下命令进行升级:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="7fde" class="mh lb iq mg b gy nb nc l nd ne">➜ helm upgrade echo --values values-3.yaml  ./gloo-app --namespace echo<br/>Release "echo" has been upgraded. Happy Helming!<br/>NAME: echo<br/>LAST DEPLOYED: Thu Apr 16 16:16:29 2020<br/>NAMESPACE: echo<br/>STATUS: deployed<br/>REVISION: 5<br/>TEST SUITE: None</span></pre><p id="30b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在我们的测试中，我们将能够开始使用金丝雀路线:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="9ac0" class="mh lb iq mg b gy nb nc l nd ne">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v1</span><span id="3570" class="mh lb iq mg b gy nf nc l nd ne">➜ curl $(glooctl proxy url)/echo -H "stage: canary"<br/>version:echo-v2</span></pre><h1 id="f936" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">进入第二阶段</h1><p id="7423" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">正如我们上面讨论的，最后一组值将为阶段2设置我们的加权目的地，但是将在金丝雀路线上将权重设置为0。所以现在，我们可以做另一个头盔升级来改变重量。如果我们想改变权重，使50%的流量流向上游的金丝雀，我们可以使用这些值:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="a043" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v1: {}<br/>  v2: {}<br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v1<br/>  canary:<br/>    version: v2<br/>    weight: 50<br/>    headers:<br/>      stage: canary</span></pre><p id="9f58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们升级的命令:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="85b9" class="mh lb iq mg b gy nb nc l nd ne">➜ helm upgrade echo --values values-4.yaml  ./gloo-app --namespace echo<br/>Release "echo" has been upgraded. Happy Helming!<br/>NAME: echo<br/>LAST DEPLOYED: Thu Apr 16 16:19:26 2020<br/>NAMESPACE: echo<br/>STATUS: deployed<br/>REVISION: 6<br/>TEST SUITE: None</span></pre><p id="237e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这些路线的行为符合我们的预期。金丝雀路线仍然存在，我们已经将主要路线上一半的流量转移到新版本:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="9888" class="mh lb iq mg b gy nb nc l nd ne">➜ curl $(glooctl proxy url)/echo -H "stage: canary"<br/>version:echo-v2</span><span id="4075" class="mh lb iq mg b gy nf nc l nd ne">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v2</span><span id="a8c9" class="mh lb iq mg b gy nf nc l nd ne">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v1</span></pre><h1 id="4b49" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">完成阶段2</h1><p id="2a7d" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">让我们更新路由，以便100%的流量都流向新版本。我们将使用这些值:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="3e9c" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v1: {}<br/>  v2: {}<br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v1<br/>  canary:<br/>    version: v2<br/>    weight: 100<br/>    headers:<br/>      stage: canary</span></pre><p id="ebbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用以下命令进行部署:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="630f" class="mh lb iq mg b gy nb nc l nd ne">➜ helm upgrade echo --values values-5.yaml  ./gloo-app --namespace echo<br/>Release "echo" has been upgraded. Happy Helming!<br/>NAME: echo<br/>LAST DEPLOYED: Thu Apr 16 16:21:37 2020<br/>NAMESPACE: echo<br/>STATUS: deployed<br/>REVISION: 7<br/>TEST SUITE: None</span></pre><p id="d047" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们测试路由时，我们现在看到所有流量都流向新版本:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="f3ce" class="mh lb iq mg b gy nb nc l nd ne">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v2</span><span id="10a7" class="mh lb iq mg b gy nf nc l nd ne">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v2</span><span id="12fe" class="mh lb iq mg b gy nf nc l nd ne">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v2</span><span id="450b" class="mh lb iq mg b gy nf nc l nd ne">➜ curl $(glooctl proxy url)/echo  -H "stage: canary"<br/>version:echo-v2</span></pre><h1 id="0fad" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">退役v1</h1><p id="543a" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们工作流程的最后一步是淘汰旧版本。我们的价值观可以归结为:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="ff10" class="mh lb iq mg b gy nb nc l nd ne">deployment:<br/>  v2: {}<br/>routes:<br/>  apiGroup: example<br/>  primary:<br/>    version: v2</span></pre><p id="94a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用以下命令进行升级:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="b05e" class="mh lb iq mg b gy nb nc l nd ne">➜ helm upgrade echo --values values-6.yaml  ./gloo-app --namespace echo<br/>Release "echo" has been upgraded. Happy Helming!<br/>NAME: echo<br/>LAST DEPLOYED: Thu Apr 16 16:24:05 2020<br/>NAMESPACE: echo<br/>STATUS: deployed<br/>REVISION: 8<br/>TEST SUITE: None</span></pre><p id="075d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以确保我们的路线是健康的:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="e93b" class="mh lb iq mg b gy nb nc l nd ne">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v2</span></pre><p id="6839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以确保我们的旧舱被清理干净:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="25ee" class="mh lb iq mg b gy nb nc l nd ne">➜ kubectl get pod -n echo<br/>NAME                      READY   STATUS    RESTARTS   AGE<br/>echo-v2-9c4b669cd-ldkdv   1/1     Running   0          12m</span></pre><h1 id="f7f9" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结束语</h1><p id="3d39" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">就是这样！我们已经使用Helm安装了我们的服务，然后通过执行<code class="fe md me mf mg b">helm upgrade</code>和定制值来执行我们的整个两阶段升级工作流。</p><p id="7094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里，我们现在可以看到两种不同的改进。</p><p id="0ea5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要在图表中引入更多的值，以便开始支持更多的工作流、路由功能和开发人员用例。我们可能需要定制很多东西，比如部署映像、资源限制、启用的选项等等。我们可能还需要支持多条路线和替代路径。希望在这一点上，您确信我们可以将这些作为我们迄今为止工作的扩展来处理，并且我们可以在未来的部分中对此进行深入研究。</p><p id="78a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，我们现在已经准备好完全集成到CI/CD流程中。许多用户通过定制helm值和使用自动化(如Helm operator或Flux project)来与他们的生产集群进行交互，以便在事实的来源(通常是git repo)发生变化时帮助将这些更新交付给集群。有了Helm，在我们的平台上加入和升级新服务已经变得微不足道，并且可以通过GitOps实现自动化。</p><h1 id="e362" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">加入Gloo社区</h1><p id="c6a1" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">除了企业客户群之外，Gloo还有一个庞大且不断增长的开源用户社区。要了解更多关于Gloo的信息:</p><ul class=""><li id="2ab0" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">检查一下<a class="ae kl" href="https://github.com/solo-io/gloo" rel="noopener ugc nofollow" target="_blank">回购</a>，在那里你可以看到代码和文件问题</li><li id="fad4" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">查看<a class="ae kl" href="https://docs.solo.io/gloo/latest" rel="noopener ugc nofollow" target="_blank">文档</a>，其中有大量的指南和例子</li><li id="ac21" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">加入<a class="ae kl" href="http://slack.solo.io/" rel="noopener ugc nofollow" target="_blank"> slack频道</a>并开始与Solo工程团队和用户社区聊天</li></ul><p id="1da8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想与我联系(反馈总是被感激！)，你可以在Slack上找到我或者发邮件给我<a class="ae kl" href="mailto:rick.ducott@solo.io" rel="noopener ugc nofollow" target="_blank"> rick.ducott@solo.io </a>。</p></div></div>    
</body>
</html>