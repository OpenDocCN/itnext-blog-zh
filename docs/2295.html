<html>
<head>
<title>State Management with NGRX — Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NGRX状态管理—简介</h1>
<blockquote>原文：<a href="https://itnext.io/state-management-with-ngrx-introduction-1aae0803e988?source=collection_archive---------3-----------------------#2019-05-02">https://itnext.io/state-management-with-ngrx-introduction-1aae0803e988?source=collection_archive---------3-----------------------#2019-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ba64" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">NGRX平台简介——概念、最佳实践和技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/886b69889dd109c0b64d0af38e0d28a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlu3ZwrnKXqG1vMbsiemxQ.png"/></div></div></figure><p id="2168" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我想向您介绍构成NGRX平台的概念及其所有部分，以充分理解它如何帮助我们创建更好的应用程序。</p><p id="5aa8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln"> NGRX </em>，对于还不知道的人来说，是<em class="ln"> Angular </em>的<em class="ln"> Redux </em>库。它帮助我们进行状态管理，这可以说是现代大规模客户端应用程序中最难管理的部分。</p><p id="65d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相比于<em class="ln"> Redux </em>只提供商店的图层，<em class="ln"> NGRX </em>自带了不少强大的功能。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="db8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是4篇文章系列的第一部分，将涵盖:</p><ul class=""><li id="ccc0" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated">NGRX的支柱</li><li id="9b87" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">如何使用减速器和实体来构建我们的商店</li><li id="6fe0" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">管理和测试副作用</li><li id="b617" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">将我们的用户界面连接到门面服务，有利弊</li></ul><h1 id="dab6" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">为什么选择NGRX或任何状态管理解决方案</h1><p id="399b" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">NGRX和Angular的其他状态管理库(NGXS，Akita)已经成为复杂web应用程序架构中的重要部分。</p><p id="66b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的一个不受欢迎的观点是，每个Angular应用程序都应该使用某种状态管理，无论是RX驱动的服务、MobX还是不同的Redux实现。</p><p id="9c64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我发现大型(甚至小型)项目在组件中使用本地状态有几个缺陷，例如:</p><ul class=""><li id="8bff" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated">在路由之间传递数据有困难</li><li id="6ffa" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">缓存已提取的数据有困难</li><li id="9955" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">重复的逻辑和请求</li><li id="6d7d" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">没有惯例</li></ul><p id="bdbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个列表可能会更长，但这足以让我相信某种状态管理对于不在短时间内重构新应用程序是必不可少的。</p><h1 id="e399" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">NGRX支柱</h1><p id="d27f" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">让我们看看围绕<em class="ln"> NGRX </em>的平台是如何构建的:</p><ul class=""><li id="de2b" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated"><code class="fe ng nh ni nj b">store</code> —这是一个中央存储库，从中我们可以<em class="ln">选择</em>角度DI中每个组件和服务的状态</li><li id="3ec3" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated"><code class="fe ng nh ni nj b">effects</code>——顾名思义，这是当一个动作被调度时发生的副作用</li><li id="e37d" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated"><code class="fe ng nh ni nj b">entity</code> —一个帮助减少常见样板文件的实体框架</li></ul><p id="f7b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们更详细地看看我们将在接下来的步骤中探索的所有概念。</p><h2 id="f07e" class="nk mk iq bd ml nl nm dn mp nn no dp mt la np nq mv le nr ns mx li nt nu mz nv bi translated">商店</h2><p id="83f5" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">商店是我们存储数据的中央存储库。</p><p id="3308" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们的应用数据库，也是我们客户的唯一真实来源。从技术上讲，它只是一个我们用来选择和存储数据的嵌套对象。</p><p id="fdb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于可以通过Angular DI访问<em class="ln"> Store </em>服务，所以我们应用程序中的所有组件和服务都可以访问我们商店中的数据。</p><p id="0661" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于状态的任何信息，除非被隔离到应用程序的一个单独部分(例如表单、弹出窗口、瞬时状态)，可能应该存储在存储中。</p><h2 id="2ddb" class="nk mk iq bd ml nl nm dn mp nn no dp mt la np nq mv le nr ns mx li nt nu mz nv bi translated">行动</h2><p id="c06f" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">在NGRX-speak中——actions是保存传递给reducers或触发副作用的信息的类。</p><p id="cb15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">动作有两个参数:</p><ul class=""><li id="e5eb" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated">我们命名为<code class="fe ng nh ni nj b">type</code>的唯一标识符(确保您将其标记为<code class="fe ng nh ni nj b">readonly</code>)</li><li id="9183" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">可选的<code class="fe ng nh ni nj b">payload</code>属性，表示传递给动作的数据</li></ul><pre class="kg kh ki kj gt nw nj nx ny aw nz bi"><span id="4cda" class="nk mk iq nj b gy oa ob l oc od">export enum LoginActionTypes {<br/>    LoginButtonClicked = '[Login Button] LOGIN_BUTTON_CLICKED',<br/>    LoginRequestStarted = '[Login API] LOGIN_REQUEST_STARTED'<br/>}</span><span id="0f1b" class="nk mk iq nj b gy oe ob l oc od">export class LoginButtonClicked {<br/>   public readonly type = LoginActionTypes.LoginButtonClicked;</span><span id="258a" class="nk mk iq nj b gy oe ob l oc od">constructor(public payload: LoginRequestPayload) {}<br/>}</span><span id="f869" class="nk mk iq nj b gy oe ob l oc od">export class LoginRequestStarted {<br/>   public readonly type = LoginActionTypes.LoginRequestStarted;</span><span id="c3ac" class="nk mk iq nj b gy oe ob l oc od">constructor(public payload: LoginRequestPayload) {}<br/>}</span><span id="72fa" class="nk mk iq nj b gy oe ob l oc od">export type UserActions = LoginButtonClicked | LoginRequestStarted;</span></pre><p id="94f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">命名<code class="fe ng nh ni nj b">type</code>参数的惯例:</p><ul class=""><li id="aa29" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated">你通常会看到使用<code class="fe ng nh ni nj b">[prefix] NAME</code>格式书写的字体</li><li id="04d7" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">正如NGRX小组所建议的，这个前缀对于声明请求的来源很有用</li></ul><p id="85ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">💡专业提示:写许多精细的动作，并且总是写它们的起源。如果你重写一些动作来做同样的事情，这并不重要。</p><h2 id="aef8" class="nk mk iq bd ml nl nm dn mp nn no dp mt la np nq mv le nr ns mx li nt nu mz nv bi translated">还原剂</h2><p id="3bc9" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">Reducers只是负责以不可变的方式更新状态对象的纯函数。</p><p id="d968" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">reducer是一个函数，它接收两个参数:当前状态对象和一个动作类，并将新状态作为输出返回。</p><p id="e388" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">新的状态<strong class="kt ir">总是新构建的对象</strong>，并且<strong class="kt ir">我们从不改变状态</strong>。</p><pre class="kg kh ki kj gt nw nj nx ny aw nz bi"><span id="f35c" class="nk mk iq nj b gy oa ob l oc od">export function loginReducer(<br/>    state: UserState = {},<br/>    action: UserActions<br/>): UserState {<br/>    switch (action.type) {<br/>        case UserActionTypes.LoginSuccess:<br/>            return action.payload;<br/>        default:<br/>            return state;<br/>}</span></pre><p id="532a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个非常简单的缩减器，如果没有匹配的动作，它就返回当前状态，或者返回动作的有效负载作为下一个状态。在实际应用中，您的减速器最终会比示例大得多。</p><p id="b8b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有很多库可以简化reducers的使用，但对我来说，它们很少值得使用。</p><p id="901f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于更复杂的减速器，我建议创建函数，并且<strong class="kt ir">保持减速器函数简单而小巧</strong>。</p><p id="1340" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上，我们可以通过简单地使用一个对象来重构switch语句，并将动作类型与对象的键相匹配。</p><p id="0011" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们改写一下:</p><pre class="kg kh ki kj gt nw nj nx ny aw nz bi"><span id="941a" class="nk mk iq nj b gy oa ob l oc od">interface LoginReducerActions { <br/>    [key: UserActionTypes]: (<br/>        state: UserState, <br/>        action: UserActions<br/>    ): UserState;<br/>};</span><span id="d0eb" class="nk mk iq nj b gy oe ob l oc od">const loginReducerActions: LoginReducerActions = { <br/>    [UserActionTypes.LoginSuccess]: (<br/>       state: UserState, <br/>       action: LoginSuccess<br/>    ) =&gt; action.payload<br/>};</span><span id="bb63" class="nk mk iq nj b gy oe ob l oc od">export function loginReducer(<br/>    state: UserState = {},<br/>    action: UserActions<br/>): UserState {<br/>    if (loginReducerActions.hasOwnProperty(action.type)) {<br/>       return loginReducerActions[action.type](state, action);<br/>    }</span><span id="2821" class="nk mk iq nj b gy oe ob l oc od">return state;<br/>}</span></pre><h2 id="a9b6" class="nk mk iq bd ml nl nm dn mp nn no dp mt la np nq mv le nr ns mx li nt nu mz nv bi translated">选择器</h2><p id="b9d3" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">选择器只是我们定义的从商店对象中选择信息的函数。</p><p id="28e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们介绍选择器之前，让我们看看我们通常如何在服务中从存储中选择数据:</p><pre class="kg kh ki kj gt nw nj nx ny aw nz bi"><span id="27c0" class="nk mk iq nj b gy oa ob l oc od">interface DashboardState {<br/>   widgets: Widget[];<br/>}</span><span id="27bc" class="nk mk iq nj b gy oe ob l oc od">export class DashboardRepository {<br/>    widgets$ = this.store.select((state: DashboardState) =&gt; {<br/>        return state.widgets;<br/>    });</span><span id="e779" class="nk mk iq nj b gy oe ob l oc od">constructor(private store: Store&lt;DashboardState&gt;) {}<br/>}</span></pre><p id="5ecf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为什么这种方法不理想？</p><ul class=""><li id="5ab0" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated">它没干</li><li id="b8de" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">如果商店的结构会改变(相信我，它会)，我们需要改变所有地方的选择</li><li id="3fc8" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">服务本身知道商店的结构</li><li id="6a71" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">不缓存</li></ul><p id="f742" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们介绍一下由<code class="fe ng nh ni nj b">@ngrx/store</code>提供的名为<code class="fe ng nh ni nj b">createSelector</code>的实用程序，它的灵感来自于React库<code class="fe ng nh ni nj b">reselect</code>。</p><p id="a707" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了简单起见，我将保持代码片段的统一，但是您应该假设选择器是在一个单独的文件中创建的，并且它们被导出。</p><pre class="kg kh ki kj gt nw nj nx ny aw nz bi"><span id="7b96" class="nk mk iq nj b gy oa ob l oc od">// selectors<br/>import { createSelector, createFeatureSelector } from '@ngrx/store';</span><span id="115a" class="nk mk iq nj b gy oe ob l oc od">const selectDashboardState = createFeatureSelector('dashboard');</span><span id="809f" class="nk mk iq nj b gy oe ob l oc od">export const selectAllWidgets = createSelector(<br/>    selectDashboardState, <br/>    (state: DashboardState) =&gt; state.widgets<br/>);</span><span id="a0e4" class="nk mk iq nj b gy oe ob l oc od">// service<br/>export class DashboardRepository {<br/>    widgets$ = this.store.select(selectAllWidgets);</span><span id="9861" class="nk mk iq nj b gy oe ob l oc od">constructor(private store: Store&lt;DashboardState&gt;) {}<br/>}</span></pre><p id="117d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">💡<strong class="kt ir">专业提示:</strong>选择器非常有用，总是编写粒度选择器，并尝试将逻辑封装在选择器中，而不是在您的服务或组件中</p><h2 id="9a29" class="nk mk iq bd ml nl nm dn mp nn no dp mt la np nq mv le nr ns mx li nt nu mz nv bi translated">实体</h2><p id="11b1" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">实体由包<code class="fe ng nh ni nj b">@ngrx/entity</code>添加。</p><p id="a924" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您曾经使用过Redux，您可能会发现，常见CRUD操作的样板文件非常耗时而且多余。</p><p id="f9ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">NGRX实体通过提供一组现成的通用操作和选择器来帮助我们，这些操作和选择器有助于减小我们的reducer的大小。</p><p id="a7b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用这个实体框架我们的状态是什么样子的？</p><pre class="kg kh ki kj gt nw nj nx ny aw nz bi"><span id="efc6" class="nk mk iq nj b gy oa ob l oc od">interface EntityState&lt;V&gt; {  <br/>  ids: string[] | number[];   <br/>  entities: { <br/>      [id: string | id: number]: V <br/>  }; <br/>}</span></pre><p id="b640" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我通常先在一个单独的文件中创建一个适配器，这样我们就可以从不同的文件中导入它，比如reducer和选择器的文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b0d826085e47535d989faa322563aeae.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*v9EpQXnp-aNUhDNb1oVMSQ.png"/></div></figure><pre class="kg kh ki kj gt nw nj nx ny aw nz bi"><span id="c6b7" class="nk mk iq nj b gy oa ob l oc od">export const adapter: EntityAdapter&lt;Widget&gt; = createEntityAdapter&lt;Widget&gt;();</span></pre><p id="a8ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在我们的减速器中使用适配器。适配器如何与之交互？</p><ul class=""><li id="4ff0" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated">它创建一个初始状态(见上面的界面<code class="fe ng nh ni nj b">EntityState</code>)</li><li id="9433" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">它给了我们一系列<em class="ln"> CRUD </em>操作方法来动态编写减速器</li></ul><pre class="kg kh ki kj gt nw nj nx ny aw nz bi"><span id="0211" class="nk mk iq nj b gy oa ob l oc od">const initialState: DashboardState = adapter.getInitialState();</span><span id="61c3" class="nk mk iq nj b gy oe ob l oc od">export const dashboardReducer(<br/>    state = initialState,<br/>    action: DashboardActions<br/>): DashboardState {<br/>   switch (action.type) {<br/>       case DashbordActionTypes.AddWidget:<br/>          const widget: Widget = action.payload;  <br/>          return adapter.addOne(action.payload, state);<br/>   }</span><span id="778d" class="nk mk iq nj b gy oe ob l oc od">// more ... <br/>   }<br/>}</span></pre><p id="0d14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">💡<strong class="kt ir"> Pro提示</strong> : <a class="ae og" href="https://ngrx.io/guide/entity/adapter#adapter-collection-methods" rel="noopener ugc nofollow" target="_blank">看看NGRX实体中所有可用的方法</a></p><p id="186d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实体适配器还允许我们启动一组选择器来查询商店。</p><p id="9a60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一个在我们的仪表板状态中选择所有小部件的示例:</p><pre class="kg kh ki kj gt nw nj nx ny aw nz bi"><span id="86dd" class="nk mk iq nj b gy oa ob l oc od">const { selectAll } = adapter.getSelectors();</span><span id="aaf1" class="nk mk iq nj b gy oe ob l oc od">export const selectDashboardState = createFeatureSelector&lt;DashboardState&gt;('dashboard');</span><span id="a006" class="nk mk iq nj b gy oe ob l oc od">export const selectAllWidgets = createSelector(<br/>  selectDashboardState,<br/>  selectAll<br/>);</span></pre><p id="96cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">💡<strong class="kt ir"> Pro提示</strong> : <a class="ae og" href="https://ngrx.io/guide/entity/adapter#entity-selectors" rel="noopener ugc nofollow" target="_blank">看看NGRX实体中所有可用的选择器</a></p><h2 id="464b" class="nk mk iq bd ml nl nm dn mp nn no dp mt la np nq mv le nr ns mx li nt nu mz nv bi translated">效果</h2><p id="e9af" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">最后，我最喜欢的NGRX特性:<em class="ln">特效</em>。</p><p id="13fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">顾名思义，我们使用效果来管理应用程序中的副作用。NGRX将效果实现为动作发出的流，在大多数情况下返回新的动作。</p><p id="fc51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们考虑下图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/4d79c3a704d3e2df1aaeba5ff11af9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*zucA-8bRWyhrhxkdMBOpLA.png"/></div></figure><ul class=""><li id="920e" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated">一个动作从应用程序中的某个地方被分派(例如:UI、WebSocket、定时器等等)。)</li><li id="8c56" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">效果拦截动作，为此定义了副作用。副作用被执行</li><li id="d0c9" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">副作用，除了例外，返回一个新的动作</li><li id="458f" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">该动作通过一个缩减器并更新存储</li></ul><p id="3264" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我提到的，不是所有的副作用都会返回一个新的动作。如果不需要的话，我们可以配置一个不调度任何动作的效果，但是重要的是你要明白，在大多数情况下，我们确实想要调度新的动作。</p><p id="8937" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<em class="ln"> NGRX </em>中，效果最实际的用例是发出<em class="ln"> HTTP </em>请求:</p><pre class="kg kh ki kj gt nw nj nx ny aw nz bi"><span id="9869" class="nk mk iq nj b gy oa ob l oc od">export class WidgetsEffects {<br/>    constructor(<br/>        private actions$: Actions,<br/>        private api: WidgetApiService<br/>    ) {}</span><span id="a4c9" class="nk mk iq nj b gy oe ob l oc od">@Effect()<br/>    createWidget$: Observable&lt;AddWidgetAction&gt; = <br/>        this.actions$.pipe(<br/>            ofType(WidgetsActionTypes.CreateWidgetRequestStarted),<br/>            mergeMap((action: CreateWidgetAction) =&gt; {<br/>                return this.api.createWidget(action.payload); <br/>            }),<br/>            map((widget: Widget) =&gt; new AddWidgetAction(widget))<br/>         );</span><span id="5704" class="nk mk iq nj b gy oe ob l oc od">@Effect({ dispatch: false })<br/>    exportWidgets$: Observable&lt;void&gt; = <br/>        this.actions$.pipe(<br/>            ofType(WidgetsActionTypes.ExportWidgets),<br/>            tap((action: ExportWidgets) =&gt; {<br/>                return this.api.exportWidgets(); <br/>            }),<br/>         );<br/>}</span></pre><p id="6321" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们把上面的片段分解一下。</p><ul class=""><li id="6ff7" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated">我们创建了一个名为<code class="fe ng nh ni nj b">WidgetsEffects</code>的类</li><li id="b31d" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">我们导入两个提供者:<code class="fe ng nh ni nj b">Actions</code>和<code class="fe ng nh ni nj b">WidgetsApiService</code></li><li id="6909" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated"><code class="fe ng nh ni nj b">Actions</code>是一连串的动作。我们使用操作符<code class="fe ng nh ni nj b">ofType</code>来帮助我们过滤动作，只过滤我们想听的动作</li><li id="c53e" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">我们在类上创建一个属性并用<code class="fe ng nh ni nj b">Effect</code>来修饰它</li><li id="d462" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">当一个名为<code class="fe ng nh ni nj b">CREATE_WIDGET_REQUEST</code>的动作被调度时，这个效果被调用</li><li id="b1a1" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">我们从动作中获取有效负载，并使用我们的API服务执行调用</li><li id="40f0" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">一旦成功执行，我们将它映射为动作<code class="fe ng nh ni nj b">AddWidgetAction</code>,该动作可以被reducer获取并更新我们的存储</li><li id="e02b" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">在名为<code class="fe ng nh ni nj b">exportWidgets$</code>的第二个效果中，我们收到一个动作<code class="fe ng nh ni nj b">ExportWidgets</code>，我们使用<code class="fe ng nh ni nj b">tap</code>操作符来执行一个副作用，然后……嗯，什么也没有！当我们通过配置<code class="fe ng nh ni nj b">{ dispatch: false }</code>时，我们不必返回任何动作</li></ul><h1 id="560d" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">外卖食品</h1><ul class=""><li id="0155" class="lv lw iq kt b ku nb kx nc la oi le oj li ok lm ma mb mc md bi translated">状态管理解决方案，无论是库还是您自己的实现，都应该优先于本地状态</li><li id="a734" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">像商店这样的单一事实来源可以帮助我们管理应用程序的状态，但也有一些例外，比如状态是暂时的</li><li id="96a6" class="lv lw iq kt b ku me kx mf la mg le mh li mi lm ma mb mc md bi translated">我们简要地探讨了存储、动作、减少器、实体、选择器和效果的概念，但是在接下来的步骤中，我们将通过一些更高级的例子来详细介绍每一个概念</li></ul><p id="8466" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望你喜欢这篇文章，并继续关注这个系列的下一部分！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="7c58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">原发布于</em><a class="ae og" href="https://frontend.consulting/state-management-with-ngrx-introduction" rel="noopener ugc nofollow" target="_blank"><em class="ln">https://frontend . consulting</em></a><em class="ln">。</em></p></div></div>    
</body>
</html>