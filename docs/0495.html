<html>
<head>
<title>TIL — lookaheads (and lookbehinds) in JavaScript regular expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TIL—JavaScript正则表达式中的lookaheads(和lookbehinds)</h1>
<blockquote>原文：<a href="https://itnext.io/til-lookaheads-and-lookbehinds-in-javascript-regular-expressions-1c3b2eb21609?source=collection_archive---------3-----------------------#2018-03-19">https://itnext.io/til-lookaheads-and-lookbehinds-in-javascript-regular-expressions-1c3b2eb21609?source=collection_archive---------3-----------------------#2018-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/71d782bec9f38bd6bfe832f4b3747932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U-Toc4hTDCLb5gCC3cONuQ.png"/></div></div></figure><p id="63f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正则表达式本身就是一个挑战。对我来说，我总是要花几分钟时间才能理解一个特定的正则表达式是做什么的，但毫无疑问，它们是有用的。</p><p id="cc0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我刚刚喝完周日早上的咖啡，看了幻灯片<a class="ae kw" href="https://slidr.io/mathiasbynens/what-s-new-in-es2018#1" rel="noopener ugc nofollow" target="_blank"><a class="ae kw" href="https://twitter.com/bmeurer?lang=de" rel="noopener ugc nofollow" target="_blank">bene dikt Meurer</a>和<a class="ae kw" href="https://twitter.com/mathias" rel="noopener ugc nofollow" target="_blank"> Mathias Bynens </a>的《ES2018中的新内容】</a>。</p><p id="828e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些幻灯片中有很多有用的信息，除了新的语言特性，如异步迭代、对象扩展属性和正则表达式中的<a class="ae kw" href="https://github.com/tc39/proposal-regexp-named-groups" rel="noopener ugc nofollow" target="_blank">命名捕获组</a>(🎉)还介绍了正则表达式中的lookaheads(以及即将出现的lookbehinds)。</p><p id="dad6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我偶尔会遇到JavaScript正则表达式中的前视头，我不得不承认我从来没有使用过它们，但是现在语言中也会出现后视头，所以我决定阅读一些文档，最终了解这些前视头是什么。</p><h1 id="7efd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JavaScript中的前瞻</h1><p id="cedc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">使用lookaheads，您可以定义只有在被另一个模式跟随或不被另一个模式跟随时才匹配的模式。</p><p id="cf54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener ugc nofollow" target="_blank">关于正则表达式的MDN文章</a>描述了正则表达式中两种不同类型的前视。</p><p id="8e1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正面和负面展望:</p><ul class=""><li id="cd10" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b">x(?=y)</code>–正向前瞻(匹配后跟“y”的“x”)</li><li id="15ab" class="ma mb iq ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b">x(?!y)</code>–否定前瞻(当后面没有‘y’时匹配‘x’)</li></ul><h1 id="8893" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JavaScript中的捕获组——看起来相似的同伴</h1><p id="01cf" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">哦，好吧…<code class="fe mj mk ml mm b">x(?=y)</code>–如果你问我的话，这是一个复杂的语法。最初让我困惑的是，我通常在JavaScript表达式中使用<code class="fe mj mk ml mm b">()</code>来表示捕获的组。</p><p id="0ffc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个捕获组的示例:</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="277b" class="na ky iq mm b gy nb nc l nd ne">const regex = /\w+\s(\w+)\s\w+/;</span><span id="06dc" class="na ky iq mm b gy nf nc l nd ne">regex.exec('eins zwei drei'); <br/>// ['eins zwei drei', 'zwei'] <br/>//                      /\ <br/>//                      || <br/>//                 captured group <br/>//                 defined with<br/>//                     (\w+)</span></pre><p id="f394" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您在上面看到的是一个正则表达式，它捕获一个被一个空格和另一个单词包围的单词(在本例中是<code class="fe mj mk ml mm b">zwei</code>)。</p><h1 id="6494" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">前瞻不像被捕获的组</h1><p id="8ec3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">所以让我们来看一个典型的例子，当你阅读JavaScript正则表达式中的前视时，你会发现这个例子。</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="2408" class="na ky iq mm b gy nb nc l nd ne">const regex = /Max(?= Mustermann)/;</span><span id="5666" class="na ky iq mm b gy nf nc l nd ne">regex.exec('Max Mustermann')<br/>// ['Max']</span><span id="522c" class="na ky iq mm b gy nf nc l nd ne">regex.exec('Max Müller')<br/>// null</span></pre><p id="a703" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当<code class="fe mj mk ml mm b">Max</code>后面跟有<code class="fe mj mk ml mm b">Mustermann</code>时，这个例子就匹配它，否则就不匹配，并返回<code class="fe mj mk ml mm b">null</code>。对我来说有趣的是，它只匹配<code class="fe mj mk ml mm b">Max</code>，而不匹配前瞻中定义的模式。在使用正则表达式一段时间后，这看起来很奇怪，但是当你想到这一点时，这就是前瞻的意义。</p><p id="ec20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“Max Mustermann”的例子在我看来是没有用的，所以让我们用一个真实的用例来深入研究正面和负面的前瞻。</p><h1 id="6bce" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">积极前瞻</h1><p id="8f49" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们假设你有一长串的减价商品，其中包括一系列人和他们的食物偏好。当一切都是一长串的时候，你怎么知道哪些人是素食主义者呢？</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="eeb6" class="na ky iq mm b gy nb nc l nd ne">const people = `<br/> - Bob (vegetarian)<br/> - Billa (vegan)<br/> - Francis<br/> - Elli (vegetarian)<br/> - Fred (vegan)<br/>`; </span><span id="7e8d" class="na ky iq mm b gy nf nc l nd ne">const regex = /-\s(\w+?)\s(?=\(vegan\))/g;<br/>//                |----| |-----------|<br/>//                  /          \ <br/>//            more than one     \<br/>//           word character     positive lookahead<br/>//            but as few as     =&gt; followed by "(vegan)"<br/>//              possible </span><span id="6777" class="na ky iq mm b gy nf nc l nd ne">let result = regex.exec(people);<br/>while(result) {<br/>  console.log(result[1]);<br/>  result = regex.exec(people);<br/>} </span><span id="cd26" class="na ky iq mm b gy nf nc l nd ne">// Result: <br/>// Billa<br/>// Fred</span></pre><p id="4656" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们快速浏览一下正则表达式，并试着用单词表达出来。</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="c027" class="na ky iq mm b gy nb nc l nd ne">const regex = /-\s(\w+?)\s(?=\(vegan\))/g;</span></pre><p id="0185" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧…让我们开始吧！</p><blockquote class="ng nh ni"><p id="275f" class="jy jz nj ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">匹配任何破折号，后跟一个空格字符、一个以上但尽可能少的单词字符(A-Za-z0–9 _)、一个空格和“(纯素食)”模式</em></p></blockquote><h1 id="b9ab" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">消极/否定的前瞻</h1><p id="7f79" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">另一方面，你怎么知道谁不是素食主义者？</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="f92d" class="na ky iq mm b gy nb nc l nd ne">const people = `<br/> - Bob (vegetarian)<br/> - Billa (vegan)<br/> - Francis<br/> - Elli (vegetarian)<br/> - Fred (vegan)<br/>`;</span><span id="57a7" class="na ky iq mm b gy nf nc l nd ne">const regex = /-\s(\w+)\s(?!\(vegan\))/g <br/>//                |---| |-----------|<br/>//                  /         \<br/>//           more than one     \<br/>//          word character    negative lookahead<br/>//           but as few as    =&gt; not followed by "(vegan)"<br/>//              possible</span><span id="16da" class="na ky iq mm b gy nf nc l nd ne">let result = regex.exec(people);</span><span id="99fd" class="na ky iq mm b gy nf nc l nd ne">while(result) {<br/>  console.log(result[1]);<br/>  result = regex.exec(people);<br/>} </span><span id="9d7f" class="na ky iq mm b gy nf nc l nd ne">// Result:<br/>// Bob<br/>// Francis<br/>// Elli</span></pre><p id="b0fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们快速浏览一下正则表达式，并试着用单词表达它。</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="7a82" class="na ky iq mm b gy nb nc l nd ne">const regex = /-\s(\w+)\s(?!\(vegan\))/g</span></pre><blockquote class="ng nh ni"><p id="8ea5" class="jy jz nj ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">匹配任何破折号，后跟一个空格字符，后跟一个以上但尽可能少的单词字符(A-Za-z0–9 _)，后跟一个空格字符(包括换行符)，后面没有“(纯素食)”模式</em></p></blockquote><h1 id="c2ca" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">前视者很快就会有后视者的陪伴</h1><p id="5439" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/tc39/proposal-regexp-lookbehind" rel="noopener ugc nofollow" target="_blank"> Lookbehinds </a>将以相同的方式工作，但对于匹配模式之前的模式(lookaheads考虑匹配部分之后的模式)和<a class="ae kw" href="http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Lookbehind_Assertions" rel="noopener ugc nofollow" target="_blank">在今天的Chrome中已经得到支持</a>。他们也可以作为正面回顾<code class="fe mj mk ml mm b">x(?&lt;=y)</code>和负面回顾<code class="fe mj mk ml mm b">x(?&lt;!y)</code>。</p><p id="750f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们翻转例子中的字符串时，仍然使用lookbehinds以同样的方式工作。:)</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="f3d0" class="na ky iq mm b gy nb nc l nd ne">const people = `<br/> - (vegetarian) Bob<br/> - (vegan) Billa<br/> - Francis<br/> - (vegetarian) Elli<br/> - (vegan) Fred<br/>`; </span><span id="6f64" class="na ky iq mm b gy nf nc l nd ne">const regex = /(?&lt;=\(vegan\))\s(\w+)/g;<br/>//             |------------|  |---| <br/>//                   /           \__ <br/>//         positive lookbehind      \ <br/>//         =&gt; following "(vegan)"   more than one<br/>//                                  word character<br/>//                                  but as few as possible</span><span id="1a50" class="na ky iq mm b gy nf nc l nd ne">let result = regex.exec(people);</span><span id="882a" class="na ky iq mm b gy nf nc l nd ne">while(result) {<br/>  console.log(result[1]);<br/>  result = regex.exec(people);<br/>} </span><span id="b834" class="na ky iq mm b gy nf nc l nd ne">// Result:<br/>// Billa<br/>// Fred</span></pre><p id="c327" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nj">旁注:对于摆弄正则表达式，我通常推荐</em><a class="ae kw" href="http://regexr.com/" rel="noopener ugc nofollow" target="_blank"><em class="nj">RegExr</em></a><em class="nj">，但是还不支持lookbehinds。</em></p><p id="1901" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你对更前沿的特性感兴趣，看看Mathias和Benedikt的关于JavaScript新特性的幻灯片会有更多令人兴奋的东西出现。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="2466" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nj">最初发表于</em><a class="ae kw" href="https://www.stefanjudis.com/today-i-learned/the-complicated-syntax-of-lookaheads-in-javascript-regular-expressions/" rel="noopener ugc nofollow" target="_blank"><em class="nj">【www.stefanjudis.com】</em></a><em class="nj">。</em></p></div></div>    
</body>
</html>