<html>
<head>
<title>Writing “Lazy Task” Using New Features of C# 7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C# 7的新特性编写“懒惰任务”</h1>
<blockquote>原文：<a href="https://itnext.io/writing-lazy-task-using-new-features-of-c-7-7e9b3f2fda07?source=collection_archive---------1-----------------------#2020-06-01">https://itnext.io/writing-lazy-task-using-new-features-of-c-7-7e9b3f2fda07?source=collection_archive---------1-----------------------#2020-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/764a8582c90637b9d98a75396e50c5d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*d0gOLynlOC6jEu8EY5Eq0A.png"/></div></figure><p id="b58a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">无论您是否“等待”它们，您在C#代码中处理的几乎100%的异步任务正在运行或已经完成。下面的例子可以说明这一点:</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="7f8a" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">static async</strong> Task Main()<br/>{<br/>    <strong class="kx ir">var</strong> task = GetValueAsync();<br/>    <strong class="kx ir">await</strong> Task.Delay(500);<br/>    Console.WriteLine("<em class="lh">Awating...</em>");</span><span id="5348" class="lb lc iq kx b gy li le l lf lg">    Console.WriteLine("<em class="lh">Result is: </em>" + <strong class="kx ir">await</strong> task);<br/>}</span><span id="0738" class="lb lc iq kx b gy li le l lf lg"><strong class="kx ir">static async</strong> Task&lt;<strong class="kx ir">int</strong>&gt; GetValueAsync()<br/>{<br/>    Console.WriteLine("<em class="lh">Async Start</em>");<br/>    <strong class="kx ir">await</strong> Task.Delay(100);<br/>    Console.WriteLine("<em class="lh">Async End</em>");<br/>    <strong class="kx ir">return</strong> 42;<br/>}</span></pre><p id="8766" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">输出:</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="a0ff" class="lb lc iq kx b gy ld le l lf lg">Async Start<br/>Async End<br/>Awating...<br/>Result is: 42</span></pre><p id="f96e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，<strong class="jw ir">等待</strong>之前<strong class="jw ir"> GetValueAsync </strong>已完成，但是如果行为不是您所期望的，并且您不希望任务在至少有一个“等待者”之前开始执行，该怎么办呢？当然，您可以使用<strong class="jw ir">惰性</strong>——来自<strong class="jw ir">系统</strong>名称空间的通用类:</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="2cb8" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">static async</strong> Task Main()<br/>{<br/>    <strong class="kx ir">var</strong> task = <strong class="kx ir">new</strong> Lazy&lt;Task&lt;int&gt;&gt;(GetValueAsync);<br/>    <strong class="kx ir">await</strong> Task.Delay(500);<br/>    Console.WriteLine("<em class="lh">Awating...</em>");<br/>    Console.WriteLine("<em class="lh">Result is: </em>" + <strong class="kx ir">await</strong> task.Value);<br/>}</span><span id="2164" class="lb lc iq kx b gy li le l lf lg"><strong class="kx ir">static async</strong> Task&lt;<strong class="kx ir">int</strong>&gt; GetValueAsync()<br/>{<br/>    Console.WriteLine("<em class="lh">Async Start</em>");<br/>    <strong class="kx ir">await</strong> Task.Delay(100);<br/>    Console.WriteLine("<em class="lh">Async End</em>");<br/>    <strong class="kx ir">return</strong> 42;<br/>}</span></pre><p id="58c2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">输出:</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="ba94" class="lb lc iq kx b gy ld le l lf lg">Awating...<br/>Async Start<br/>Async End<br/>Result is: 42</span></pre><p id="a2a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，还有另一个解决方案会稍微影响您的客户端代码——它是用<strong class="jw ir"> LazyTask </strong>替换由您的异步函数返回的<strong class="jw ir">Task</strong>——一个您可以使用新的C#7特性创建的类— <strong class="jw ir">通用异步返回类型</strong></p><p id="7a3e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，您的代码将如下所示:</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="9bde" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">static async</strong> Task Main()<br/>{<br/>    <strong class="kx ir">var</strong> task = GetValueAsync();<br/>    <strong class="kx ir">await</strong> Task.Delay(500);<br/>    Console.WriteLine("<em class="lh">Awating...</em>");<br/>    Console.WriteLine("<em class="lh">Result is: </em>" + await task);<br/>}</span><span id="cecc" class="lb lc iq kx b gy li le l lf lg"><strong class="kx ir">static async</strong> LazyTask&lt;<strong class="kx ir">int</strong>&gt; GetValueAsync()<br/>{<br/>    Console.WriteLine("<em class="lh">Async Start</em>");<br/>    <strong class="kx ir">await</strong> Task.Delay(100);<br/>    Console.WriteLine("<em class="lh">Async End</em>");<br/>    <strong class="kx ir">return</strong> 42;<br/>}</span></pre><p id="3b75" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">输出:</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="28a1" class="lb lc iq kx b gy ld le l lf lg">Awating...<br/>Async Start<br/>Async End<br/>Result is: 42</span></pre><p id="2fcd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">众所周知，C#编译器将标记为<strong class="jw ir"> async </strong>的方法转换为状态机，其中每个状态代表一个标记为<strong class="jw ir"> await </strong>的异步操作的完成。<strong class="jw ir">通用异步返回类型</strong>允许你访问状态机执行(我在<a class="ae lj" href="https://habr.com/en/post/458692/" rel="noopener ugc nofollow" target="_blank">我以前的一篇文章</a>中详细研究了这个机制)。)在我们的例子中，我们只需要推迟第一步，直到我们至少有了一个“奖励者”。这可以通过调整<strong class="jw ir">启动</strong>的方法来实现:</p><blockquote class="lk ll lm"><p id="fba4" class="ju jv lh jw b jx jy jz ka kb kc kd ke ln kg kh ki lo kk kl km lp ko kp kq kr ij bi translated"><a class="ae lj" href="https://github.com/0x1000000/LazyTask/blob/master/LazyTask/LazyTaskMethodBuilder.cs" rel="noopener ugc nofollow" target="_blank">lazytaskmethodbuilder . cs</a></p></blockquote><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="870e" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">public class</strong> LazyTaskMethodBuilder&lt;T&gt;<br/>{<br/>    <strong class="kx ir">public</strong> LazyTaskMethodBuilder() =&gt; this.Task = <strong class="kx ir">new</strong> LazyTask&lt;T&gt;();</span><span id="05dd" class="lb lc iq kx b gy li le l lf lg">    <strong class="kx ir">public void</strong> Start&lt;TStateMachine&gt;(<br/>        <strong class="kx ir">ref</strong> TStateMachine stateMachine)..<br/>    {<br/>        <em class="lh">//instead of stateMachine.MoveNext();</em><br/>        <strong class="kx ir">this</strong>.Task.SetStateMachine(stateMachine);<br/>    }<br/>    ...<br/>}</span></pre><p id="a74a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Start </strong>方法并没有开始第一步，而是在<strong class="jw ir"> LazyTask </strong>对象中存储了一个到状态机的链接。</p><p id="638d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">只有当我们有了第一个“奖赏者”时，第一步才能被称为:</p><blockquote class="lk ll lm"><p id="e285" class="ju jv lh jw b jx jy jz ka kb kc kd ke ln kg kh ki lo kk kl km lp ko kp kq kr ij bi translated"><a class="ae lj" href="https://github.com/0x1000000/LazyTask/blob/master/LazyTask/LazyTask.cs" rel="noopener ugc nofollow" target="_blank"> LazyTask.cs </a></p></blockquote><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="4b84" class="lb lc iq kx b gy ld le l lf lg"><strong class="kx ir">public void</strong> OnCompleted(Action continuation)                               {<br/>    ...</span><span id="f591" class="lb lc iq kx b gy li le l lf lg">    <strong class="kx ir">this</strong>._asyncStateMachine.MoveNext();<br/>    ...</span><span id="3205" class="lb lc iq kx b gy li le l lf lg">}</span></pre><p id="48c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="lh">注意:有趣的是，这个技巧甚至可以在没有任何异步调用的方法中使用(没有“await”关键字)。</em></p><p id="0a65" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">仅此而已！</p><p id="4bac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">总之，我想说的是<strong class="jw ir">通用异步返回类型</strong>是一个强大的机制，而<strong class="jw ir"> LazyTask </strong>只是如何利用它的一个例子。</p><h2 id="c8c7" class="lb lc iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">链接</h2><ol class=""><li id="97da" class="mh mi iq jw b jx mj kb mk kf ml kj mm kn mn kr mo mp mq mr bi translated"><a class="ae lj" href="https://github.com/0x1000000/LazyTask" rel="noopener ugc nofollow" target="_blank">git nub上的源代码；</a></li></ol><p id="9ce4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae lj" href="https://habr.com/en/post/458692/" rel="noopener ugc nofollow" target="_blank"> 2。“也许”monad通过异步/等待在C#中(没有任务！)</a> —一篇详细分析了<strong class="jw ir">广义异步返回类型</strong>的文章。</p></div></div>    
</body>
</html>