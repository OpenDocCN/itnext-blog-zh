<html>
<head>
<title>How I used Mutation Testing to Improve my Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用变异测试来改进我的代码</h1>
<blockquote>原文：<a href="https://itnext.io/how-i-used-mutation-testing-to-improve-my-code-71c7fcf5174d?source=collection_archive---------2-----------------------#2019-04-28">https://itnext.io/how-i-used-mutation-testing-to-improve-my-code-71c7fcf5174d?source=collection_archive---------2-----------------------#2019-04-28</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><figure class="iq ir gq gs is it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj ip"><img src="../Images/9f3b0322af03af0f2ac3d8b7b7a9bdc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMMSCP75UXF4Ahwko6q3yA.png"/></div></div><figcaption class="ja jb gk gi gj jc jd bd b be z dk translated">曼谷一夜(图片由作者提供)</figcaption></figure><div class=""/><div class=""><h2 id="4902" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">让我的测试更加诚实</h2></div><p id="cc7e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">不久前，我写了一个名为<code class="fe lr ls lt lu b"><a class="ae lv" href="https://github.com/davesag/amqp-delegate" rel="noopener ugc nofollow" target="_blank">amqp-delegate</a></code>的小工具，它使用标准的<code class="fe lr ls lt lu b">amqplib</code>库，允许通过<code class="fe lr ls lt lu b">aqmp</code>消息总线(如<code class="fe lr ls lt lu b"><a class="ae lv" href="https://www.rabbitmq.com" rel="noopener ugc nofollow" target="_blank">Rabbit MQ</a></code>)轻松创建和调用远程工作者。</p><p id="10f5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">我写了一篇关于这个的文章，叫做“使用NodeJS和AMQP委派工作”。</p><p id="b49b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">我写这篇文章的时候正在海滩上，感觉很懒。为了在我的回购协议上获得一个漂亮的绿色<code class="fe lr ls lt lu b">100%</code>覆盖徽章，我欺骗并使用<code class="fe lr ls lt lu b">/* istanbul ignore next */</code>来完全忽略我的工作委托人的<code class="fe lr ls lt lu b"><a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/1.0.3/src/makeDelegator.js#L50" rel="noopener ugc nofollow" target="_blank">invoke</a></code> <a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/1.0.3/src/makeDelegator.js#L50" rel="noopener ugc nofollow" target="_blank">功能</a>。</p><p id="2833" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">在我的测试中，我添加了一点<code class="fe lr ls lt lu b">TODO</code>注意:</p><pre class="lw lx ly lz gu ma lu mb mc aw md bi"><span id="5545" class="me mf jg lu b gz mg mh l mi mj">// TODO: work out how to test the channel.consume callback</span></pre><p id="1af0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">然后<a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/1.0.3/test/unit/makeDelegator.test.js#L112" rel="noopener ugc nofollow" target="_blank">我</a> <code class="fe lr ls lt lu b"><a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/1.0.3/test/unit/makeDelegator.test.js#L112" rel="noopener ugc nofollow" target="_blank">skipped</a></code> <a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/1.0.3/test/unit/makeDelegator.test.js#L112" rel="noopener ugc nofollow" target="_blank">测试</a>。</p><p id="0a88" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">我想我已经用我的<em class="mk">集成</em>测试测试了这段代码，所以纠结于<em class="mk">单元</em>测试代码覆盖率只是浪费时间。我的代码有效，因此是好代码。</p><p id="0ea7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">然后我读到了一个名为<a class="ae lv" href="https://stryker-mutator.io" rel="noopener ugc nofollow" target="_blank"> Stryker Mutator </a>的突变测试库，我想我应该把它添加到我的库中，看看它能为我做些什么。</p><h1 id="4162" class="ml mf jg bd mm mn mo mp mq mr ms mt mu km mv kn mw kp mx kq my ks mz kt na nb bi translated">什么是突变测试。</h1><p id="dadf" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ik bi translated">突变测试是测试你的测试的一种方式。如上所述，通过跳过一些代码来欺骗你的测试覆盖报告是很容易的，但是有时你的单元测试并没有真正完成它们的工作也是不明显的。</p><p id="29ef" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">变异测试以巧妙的方式破坏你的代码，将<code class="fe lr ls lt lu b">false</code>改为<code class="fe lr ls lt lu b">true</code>，更改<code class="fe lr ls lt lu b">strings</code>和<code class="fe lr ls lt lu b">numbers</code>的值，将<code class="fe lr ls lt lu b">plus</code>改为<code class="fe lr ls lt lu b">minus</code>，诸如此类，然后对你代码的每个变异一次又一次地运行你的测试。如果尽管对代码进行了更改，测试仍然通过，那么您的测试就被认为是失败的。</p><p id="094e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">在一个理想的世界里<em class="mk">,你的测试没有一个能在你的代码被变异后存活下来。</em></p><h1 id="821c" class="ml mf jg bd mm mn mo mp mq mr ms mt mu km mv kn mw kp mx kq my ks mz kt na nb bi translated">尝试一下</h1><p id="7c3e" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ik bi translated">运行我的突变测试显示，我的终端中出现了大片红色，因为我告诉<code class="fe lr ls lt lu b"><a class="ae lv" href="https://istanbul.js.org" rel="noopener ugc nofollow" target="_blank">Istanbul</a></code>忽略的所有代码都被标记出来，还有一堆我认为测试良好的其他代码。</p><p id="84be" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">为了给出一个更详细的例子，下面是我上面提到的<code class="fe lr ls lt lu b"><a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/1.0.3/src/makeDelegator.js#L50" rel="noopener ugc nofollow" target="_blank">makeDelegator</a></code> <a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/1.0.3/src/makeDelegator.js#L50" rel="noopener ugc nofollow" target="_blank">函数</a>的代码。</p><p id="6e95" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">具体来说，下面是<code class="fe lr ls lt lu b">invoke</code>函数的样子。您可以看到为什么这很难进行单元测试。</p><pre class="lw lx ly lz gu ma lu mb mc aw md bi"><span id="7f58" class="me mf jg lu b gz mg mh l mi mj">const invoke = async (name, ...params) =&gt; {<br/>  if (!channel) throw new Error(QUEUE_NOT_STARTED)<br/>  const queue = await channel.assertQueue('', { exclusive: true })<br/>  const buffer = Buffer.from(JSON.stringify(params))<br/>  const correlationId = v4()<br/>  const replyTo = queue.queue</span><span id="be39" class="me mf jg lu b gz nh mh l mi mj">  return new Promise((resolve, reject) =&gt; {<br/>    channel.consume(<br/>      replyTo,<br/>      message =&gt; {<br/>        if (message.properties.correlationId === correlationId) {<br/>          try {<br/>            const result = JSON.parse(message.content.toString())<br/>            return resolve(result)<br/>          } catch (err) {<br/>            return reject(err)<br/>          }<br/>        } else return reject(WRONG_CORRELATION_ID)<br/>      },<br/>      { noAck: true }<br/>    )</span><span id="fb4b" class="me mf jg lu b gz nh mh l mi mj">    channel.sendToQueue(name, buffer, { correlationId, replyTo })<br/>  })<br/>}</span></pre><p id="6162" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">该函数的工作方式是注册一个消息消费者，然后将数据发送到消息队列。消息消费者等待，直到得到正确的<code class="fe lr ls lt lu b">correlationId</code>响应，然后才执行<code class="fe lr ls lt lu b">resolve</code>或<code class="fe lr ls lt lu b">reject</code>操作<code class="fe lr ls lt lu b">promise</code>。</p><p id="8fcc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">对<code class="fe lr ls lt lu b">resolve</code>或<code class="fe lr ls lt lu b">reject</code>的调用深埋在响应消息处理器中，使得单元测试非常困难。作为一个完美主义者，我不得不试一试。</p><h2 id="2c39" class="me mf jg bd mm ni nj dn mq nk nl dp mu le nm nn mw li no np my lm nq nr na ns bi translated">重构</h2><p id="1e8a" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ik bi translated">第一步是提取响应消息处理程序并单独测试。</p><p id="3563" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">处理函数需要访问总体承诺的<code class="fe lr ls lt lu b">resolve</code>和<code class="fe lr ls lt lu b">reject</code>函数以及<code class="fe lr ls lt lu b">correlationId</code>函数，以便与<code class="fe lr ls lt lu b">message</code>自己的<code class="fe lr ls lt lu b">correlationId</code>进行比较。我创建了下面的<em class="mk"> curried </em>实用函数:</p><p id="7c0a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated"><code class="fe lr ls lt lu b"><a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/develop/src/utils/messageCorrelator.js" rel="noopener ugc nofollow" target="_blank">src/utils/messageCorrelator.js</a></code></p><pre class="lw lx ly lz gu ma lu mb mc aw md bi"><span id="00b6" class="me mf jg lu b gz mg mh l mi mj">const { WRONG_CORRELATION_ID } = require('../errors')</span><span id="4236" class="me mf jg lu b gz nh mh l mi mj">const messageCorrelator = (correlationId, resolve, reject) =&gt;<br/>  message =&gt; {<br/>    if (message.properties.correlationId === correlationId) {<br/>      try {<br/>        const result = JSON.parse(message.content.toString())<br/>        return resolve(result)<br/>      } catch (err) {<br/>        return reject(err)<br/>      }<br/>    }</span><span id="fa18" class="me mf jg lu b gz nh mh l mi mj">    return reject(WRONG_CORRELATION_ID)<br/>  }</span><span id="5790" class="me mf jg lu b gz nh mh l mi mj">module.exports = messageCorrelator</span></pre><p id="af6e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">这很容易测试。只需传入<code class="fe lr ls lt lu b">resolve</code>和<code class="fe lr ls lt lu b">reject</code>函数的存根，并设置<code class="fe lr ls lt lu b">correlationIds</code>匹配或不匹配的场景。此外，为了完整性，当响应消息的<code class="fe lr ls lt lu b">content</code>不可解析为<code class="fe lr ls lt lu b">JSON</code>时，加入一个测试。</p><pre class="lw lx ly lz gu ma lu mb mc aw md bi"><span id="e434" class="me mf jg lu b gz mg mh l mi mj">const { expect } = require('chai')<br/>const { stub, resetHistory } = require('sinon')</span><span id="e053" class="me mf jg lu b gz nh mh l mi mj">const messageCorrelator =<br/>  require('../../../src/utils/messageCorrelator')</span><span id="ca4a" class="me mf jg lu b gz nh mh l mi mj">const { WRONG_CORRELATION_ID } = require('../../../src/errors')</span><span id="d1f6" class="me mf jg lu b gz nh mh l mi mj">describe('utils/messageCorrelator', () =&gt; {<br/>  const RESOLVED = 'resolved'<br/>  const REJECTED = 'rejected'<br/>  const resolve = stub().returns(RESOLVED)<br/>  const reject = stub().returns(REJECTED)<br/>  const correlationId = '123456'<br/>  const content = { test: 'data', is: 'good data' }</span><span id="689d" class="me mf jg lu b gz nh mh l mi mj">  const correlate =<br/>    messageCorrelator(correlationId, resolve, reject)<br/>  let result</span><span id="4880" class="me mf jg lu b gz nh mh l mi mj">  context('given matching correlationId', () =&gt; {<br/>    context('given unparsable message content', () =&gt; {<br/>      const message = {<br/>        properties: {<br/>          correlationId<br/>        },<br/>        content: 'junk'<br/>      }</span><span id="d6bc" class="me mf jg lu b gz nh mh l mi mj">      before(() =&gt; {<br/>        result = correlate(message)<br/>      })</span><span id="5cd6" class="me mf jg lu b gz nh mh l mi mj">      after(resetHistory)</span><span id="230a" class="me mf jg lu b gz nh mh l mi mj">      it('invoked reject with a SyntaxError', () =&gt; {<br/>        expect(reject).to.have.been.called<br/>        const err = reject.firstCall.args[0]<br/>        expect(err).to.be.instanceof(SyntaxError)<br/>      })</span><span id="5cf6" class="me mf jg lu b gz nh mh l mi mj">      it('returned the evaluated rejection', () =&gt; {<br/>        expect(result).to.equal(REJECTED)<br/>      })<br/>    })</span><span id="f842" class="me mf jg lu b gz nh mh l mi mj">    context('given parsable message content', () =&gt; {<br/>      const message = {<br/>        properties: {<br/>          correlationId<br/>        },<br/>        content: JSON.stringify(content)<br/>      }</span><span id="3012" class="me mf jg lu b gz nh mh l mi mj">      before(() =&gt; {<br/>        result = correlate(message)<br/>      })</span><span id="e784" class="me mf jg lu b gz nh mh l mi mj">      after(resetHistory)</span><span id="00b5" class="me mf jg lu b gz nh mh l mi mj">      it('invoked resolve with parsed content', () =&gt; {<br/>        expect(resolve).to.have.been.calledWith(content)<br/>      })</span><span id="80da" class="me mf jg lu b gz nh mh l mi mj">      it('returned the evaluated rejection', () =&gt; {<br/>        expect(result).to.equal(RESOLVED)<br/>      })<br/>    })<br/>  })</span><span id="9821" class="me mf jg lu b gz nh mh l mi mj">  context('given non-matching correlationId', () =&gt; {<br/>    const message = {<br/>      properties: {<br/>        correlationId: 'some-other-id'<br/>      },<br/>      content: JSON.stringify(content)<br/>    }</span><span id="d55e" class="me mf jg lu b gz nh mh l mi mj">    before(() =&gt; {<br/>      result = correlate(message)<br/>    })</span><span id="5cd8" class="me mf jg lu b gz nh mh l mi mj">    after(resetHistory)</span><span id="f19e" class="me mf jg lu b gz nh mh l mi mj">    it('invoked reject with WRONG_CORRELATION_ID', () =&gt; {<br/>      expect(reject).to.have.been.calledWith(WRONG_CORRELATION_ID)<br/>    })</span><span id="fab9" class="me mf jg lu b gz nh mh l mi mj">    it('returned the evaluated rejection', () =&gt; {<br/>      expect(result).to.equal(REJECTED)<br/>    })<br/>  })<br/>})</span></pre><p id="46b6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">现在我有了这个实用程序，我可以通过制作一个简单的curried <code class="fe lr ls lt lu b"><a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/develop/src/utils/invoker.js" rel="noopener ugc nofollow" target="_blank">invoker</a></code> <a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/develop/src/utils/invoker.js" rel="noopener ugc nofollow" target="_blank">函数</a>从invoke函数中提取调用逻辑，如下所示:</p><pre class="lw lx ly lz gu ma lu mb mc aw md bi"><span id="a7bf" class="me mf jg lu b gz mg mh l mi mj">const messageCorrelator = require('./messageCorrelator')</span><span id="05ad" class="me mf jg lu b gz nh mh l mi mj">const invoker = (correlationId, channel, replyTo) =&gt;<br/>  async (name, params) =&gt;<br/>    new Promise((resolve, reject) =&gt; {<br/>      channel.consume(<br/>        replyTo,<br/>        messageCorrelator(correlationId, resolve, reject),<br/>        { noAck: true }<br/>      )</span><span id="e90b" class="me mf jg lu b gz nh mh l mi mj">      channel.sendToQueue(<br/>        name,<br/>        Buffer.from(JSON.stringify(params)),<br/>        {<br/>          correlationId,<br/>          replyTo<br/>        }<br/>      )<br/>    })</span><span id="06e7" class="me mf jg lu b gz nh mh l mi mj">module.exports = invoker</span></pre><p id="2417" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">这使用了<code class="fe lr ls lt lu b">messageCorrelator</code>，非常容易测试。这个函数中根本没有分支逻辑。该函数不关心得到的承诺是被解决还是被拒绝，所以测试非常简单。</p><p id="edaf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">在许多测试中，我使用测试工具创建一个假的<a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/develop/test/unit/fakes.js" rel="noopener ugc nofollow" target="_blank"/><code class="fe lr ls lt lu b"><a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/develop/test/unit/fakes.js" rel="noopener ugc nofollow" target="_blank">channel</a></code>来代替真的<code class="fe lr ls lt lu b">amqp channel</code>。</p><pre class="lw lx ly lz gu ma lu mb mc aw md bi"><span id="dc20" class="me mf jg lu b gz mg mh l mi mj">const fakeChannel = () =&gt; ({<br/>  assertExchange: stub(),<br/>  publish: stub(),<br/>  close: stub(),<br/>  assertQueue: stub(),<br/>  purgeQueue: stub(),<br/>  bindQueue: stub(),<br/>  prefetch: stub(),<br/>  consume: stub(),<br/>  ack: stub(),<br/>  nack: stub(),<br/>  sendToQueue: stub()<br/>})</span></pre><p id="6f5f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">我使用<code class="fe lr ls lt lu b"><a class="ae lv" href="https://github.com/thlorenz/proxyquire" rel="noopener ugc nofollow" target="_blank">proxyquire</a></code>来剔除<code class="fe lr ls lt lu b">messageCorrelator</code>，因为我已经单独测试过了，所以<a class="ae lv" href="https://github.com/davesag/amqp-delegate/blob/develop/test/unit/utils/invoker.test.js" rel="noopener ugc nofollow" target="_blank">测试</a>看起来像这样:</p><pre class="lw lx ly lz gu ma lu mb mc aw md bi"><span id="6ddc" class="me mf jg lu b gz mg mh l mi mj">const { expect } = require('chai')<br/>const { stub, match } = require('sinon')<br/>const proxyquire = require('proxyquire')</span><span id="ff54" class="me mf jg lu b gz nh mh l mi mj">const { fakeChannel } = require('../fakes')</span><span id="3bfe" class="me mf jg lu b gz nh mh l mi mj">describe('utils/invoker', () =&gt; {<br/>  const channel = fakeChannel()<br/>  const messageCorrelator = stub()<br/>  const correlationId = '12345'<br/>  const name = 'some name'<br/>  const param = 'some param'<br/>  const replyTo = 'some replyTo address'</span><span id="04d6" class="me mf jg lu b gz nh mh l mi mj">  const invoker = proxyquire('../../../src/utils/invoker', {<br/>    './messageCorrelator': messageCorrelator<br/>  })</span><span id="e283" class="me mf jg lu b gz nh mh l mi mj">  const invocation = invoker(correlationId, channel, replyTo)<br/>  const message = 'a message'</span><span id="7bb7" class="me mf jg lu b gz nh mh l mi mj">  before(() =&gt; {<br/>    messageCorrelator.returns(message)<br/>    invocation(name, [param])<br/>  })</span><span id="c627" class="me mf jg lu b gz nh mh l mi mj">  it('called the messageCorrelator with the right values', () =&gt; {<br/>    expect(messageCorrelator).to.have.been.calledWith(<br/>      correlationId,<br/>      match.func,<br/>      match.func<br/>    )<br/>  })</span><span id="ec63" class="me mf jg lu b gz nh mh l mi mj">  it('called channel.consume with the right values', () =&gt; {<br/>    expect(channel.consume).to.have.been.calledWith(<br/>      replyTo,<br/>      message,<br/>      { noAck: true }<br/>    )<br/>  })</span><span id="b065" class="me mf jg lu b gz nh mh l mi mj">  it('called channel.sendToQueue with the right values', () =&gt; {<br/>    expect(channel.sendToQueue).to.have.been.calledWith(<br/>      name,<br/>      Buffer.from(JSON.stringify([param])),<br/>      { correlationId, replyTo }<br/>    )<br/>  })<br/>})</span></pre><p id="8912" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">然后我可以重构原始的<code class="fe lr ls lt lu b">invoke</code>函数，使其更加简单:</p><pre class="lw lx ly lz gu ma lu mb mc aw md bi"><span id="c0cd" class="me mf jg lu b gz mg mh l mi mj">const invoke = async (name, ...params) =&gt; {<br/>  if (!channel) throw new Error(QUEUE_NOT_STARTED)<br/>  const queue = await channel.assertQueue('', { exclusive: true })<br/>  const correlationId = v4()<br/>  const replyTo = queue.queue<br/>  const invocation = invoker(correlationId, channel, replyTo)<br/>  return invocation(name, params)<br/>}</span></pre><p id="b761" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">这更容易测试。</p><pre class="lw lx ly lz gu ma lu mb mc aw md bi"><span id="6b17" class="me mf jg lu b gz mg mh l mi mj">describe('invoke', () =&gt; {<br/>  const invocation = stub()</span><span id="1f64" class="me mf jg lu b gz nh mh l mi mj">  context('before the delegator was started', () =&gt; {<br/>    before(() =&gt; {<br/>      delegator = makeDelegator({ exchange })<br/>    })</span><span id="410f" class="me mf jg lu b gz nh mh l mi mj">    after(resetHistory)</span><span id="7286" class="me mf jg lu b gz nh mh l mi mj">    it('throws QUEUE_NOT_STARTED', () =&gt;<br/>     expect(delegator.invoke())<br/>       .to.be.rejectedWith(QUEUE_NOT_STARTED))<br/>  })</span><span id="9ecc" class="me mf jg lu b gz nh mh l mi mj">  context('after the delegator was started', () =&gt; {<br/>    const name = 'some name'<br/>    const param = 'some param'</span><span id="1d4e" class="me mf jg lu b gz nh mh l mi mj">    before(async () =&gt; {<br/>      queue = fakeQueue()<br/>      delegator = makeDelegator({ exchange })<br/>      channel = fakeChannel()<br/>      connection = fakeConnection()<br/>      channel.assertQueue.resolves(queue)<br/>      connection.createChannel.resolves(channel)<br/>      amqplib.connect.resolves(connection)<br/>      await delegator.start()<br/>      invocation.resolves()<br/>      invoker.returns(invocation)<br/>      await delegator.invoke(name, param)<br/>    })</span><span id="c533" class="me mf jg lu b gz nh mh l mi mj">    after(resetHistory)</span><span id="0633" class="me mf jg lu b gz nh mh l mi mj">    it('called channel.assertQueue with the right params', () =&gt; {<br/>      expect(channel.assertQueue).to.have.been.calledWith('', {<br/>        exclusive: true<br/>      })<br/>    })</span><span id="0e35" class="me mf jg lu b gz nh mh l mi mj">    it('called the invoker with the right params', () =&gt; {<br/>      expect(invoker).to.have.been.calledWith(<br/>        correlationId,<br/>        channel,<br/>        queue.queue<br/>      )<br/>    })</span><span id="20e0" class="me mf jg lu b gz nh mh l mi mj">    it('called invocation with the right params', () =&gt; {<br/>      expect(invocation).to.have.been.calledWith(name, [param])<br/>    })<br/>  })<br/>})</span></pre><p id="2129" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">然后，我将同样的分解应用到代码的其他部分，这些部分以前很难测试。</p><h1 id="e652" class="ml mf jg bd mm mn mo mp mq mr ms mt mu km mv kn mw kp mx kq my ks mz kt na nb bi translated">结论</h1><p id="baf5" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ik bi translated">通过增加突变测试，我被迫返回并使我的代码更易于测试，结果我使它更加模块化，更容易推理。结果无疑是更好的代码，尽管它实际上并不比突变前的测试代码更好。</p><p id="d2db" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">好处是，在过去的几个周末，我回顾了我维护的所有开源代码库，并为它们添加了变异测试，并修复了变异测试揭示的所有问题。</p><h1 id="c4b4" class="ml mf jg bd mm mn mo mp mq mr ms mt mu km mv kn mw kp mx kq my ks mz kt na nb bi translated">链接</h1><ul class=""><li id="cf1f" class="nt nu jg kx b ky nc lb nd le nv li nw lm nx lq ny nz oa ob bi translated"><em class="mk">使用NodeJS和AMQP委托工作</em>’—<a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/delegating-work-using-nodejs-and-amqp-4d3cc1f62824">https://it next . io/delegateing-Work-using-NodeJS-and-amqp-4d 3c C1 f 62824</a></li><li id="bbe5" class="nt nu jg kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated"><code class="fe lr ls lt lu b">amqp-delegate</code>——<a class="ae lv" href="https://github.com/davesag/amqp-delegate" rel="noopener ugc nofollow" target="_blank">https://github.com/davesag/amqp-delegate</a></li><li id="2582" class="nt nu jg kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated"><code class="fe lr ls lt lu b">amqp-delegate</code>之前我加了突变测试—<a class="ae lv" href="https://github.com/davesag/amqp-delegate/tree/1.0.3" rel="noopener ugc nofollow" target="_blank">https://github.com/davesag/amqp-delegate/tree/1.0.3</a></li><li id="753b" class="nt nu jg kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated">https://istanbul.js.org的<code class="fe lr ls lt lu b">Istanbul</code></li><li id="7e3e" class="nt nu jg kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated"><code class="fe lr ls lt lu b">Stryker Mutator</code>—<a class="ae lv" href="https://stryker-mutator.io" rel="noopener ugc nofollow" target="_blank">https://stryker-mutator . io</a></li><li id="4156" class="nt nu jg kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated">【https://www.rabbitmq.com】——<a class="ae lv" href="https://www.rabbitmq.com" rel="noopener ugc nofollow" target="_blank"/></li><li id="bd82" class="nt nu jg kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated"><code class="fe lr ls lt lu b">Mocha</code>—<a class="ae lv" href="https://mochajs.org" rel="noopener ugc nofollow" target="_blank">https://mochajs.org</a></li><li id="aa56" class="nt nu jg kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated"><code class="fe lr ls lt lu b">Sinon</code>—<a class="ae lv" href="https://sinonjs.org" rel="noopener ugc nofollow" target="_blank">https://sinonjs.org</a></li><li id="a6b5" class="nt nu jg kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated"><code class="fe lr ls lt lu b">Proxyquire</code>——<a class="ae lv" href="https://github.com/thlorenz/proxyquire" rel="noopener ugc nofollow" target="_blank">https://github.com/thlorenz/proxyquire</a></li></ul><p id="41ff" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi">—</p><p id="f5f2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">像这样但不是订户？你可以通过<a class="ae lv" href="https://davesag.medium.com/membership" rel="noopener">davesag.medium.com</a>加入来支持作者。</p></div></div>    
</body>
</html>