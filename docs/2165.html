<html>
<head>
<title>Don’t do ‘this’ — Part One</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要做“这个”——第一部分</h1>
<blockquote>原文：<a href="https://itnext.io/dont-do-this-part-one-objects-and-their-misuse-bd0771c3178a?source=collection_archive---------1-----------------------#2019-04-10">https://itnext.io/dont-do-this-part-one-objects-and-their-misuse-bd0771c3178a?source=collection_archive---------1-----------------------#2019-04-10</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><figure class="iq ir gq gs is it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj ip"><img src="../Images/dcbadd3849bb2e70e22f9bd47e4b4e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEFloLgNhc6hqX-udV6CNg.png"/></div></div><figcaption class="ja jb gk gi gj jc jd bd b be z dk translated">即使是最好的工具也会被误用。(图片由作者提供)</figcaption></figure><div class=""/><div class=""><h2 id="4669" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">对象及其误用</h2></div><h1 id="6c38" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">背景</h1><p id="cca8" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">我在之前的一篇文章中指出，没有人应该使用Typescript，我认为最好是详细说明我为什么这么认为。</p><p id="6641" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">这是由两部分组成的文章的第一部分。跳到<a class="ae mj" href="https://medium.com/@davesag/dont-do-this-part-two-the-trouble-with-typescript-8ea9b26892e2" rel="noopener">下一部分</a>，在那里我表达了对Typescript的强烈意见。</p><h2 id="3f60" class="mp kw jg bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">Javascript是面向对象的语言吗？</h2><p id="5d9a" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">是的，也不是。很多人，尤其是来自传统面向对象语言如Java或SmallTalk的人，看到Javascript对<code class="fe nb nc nd ne b">class</code>和<code class="fe nb nc nd ne b">this</code>关键字的支持，就认为他们能够并且应该将他们在Java中应用的原则应用到Javascript中。但是Javascript中的<code class="fe nb nc nd ne b">class</code>不像Java类。它仅仅是语法上的糖衣，并没有给Javascript开发者提供与真正的面向对象语言中真正的<code class="fe nb nc nd ne b">class</code>相同的保护。</p><p id="7a45" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">在我深入探讨Javascript特殊的(有些人会说是奇特的)面向对象方法之前，有必要问问我们自己，面向对象是否值得追求。</p><p id="38b0" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">TL；DR:我会说不，不多，尤其是在Javascript中。</p><h1 id="3c0c" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">物品的问题</h1><p id="2b57" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">用面向对象的话来说，一个对象是一段代码，<em class="nf">封装了</em>数据和作用于该数据的函数，并且可以用构造函数<em class="nf">实例化</em>。对象可以<em class="nf">从其他对象继承</em>数据和功能，形成具有可预测特性的对象层次结构。</p><h2 id="43f3" class="mp kw jg bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">纯面向对象示例(伪代码)</h2><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="3206" class="mp kw jg ne b gz no np l nq nr">class Animal {<br/>  legs: 4,<br/>  walk() { /* do walking */ }<br/>}</span><span id="1a8b" class="mp kw jg ne b gz ns np l nq nr">class Cat extends Animal {<br/>  purr() { / do purring */ }<br/>}</span><span id="29a9" class="mp kw jg ne b gz ns np l nq nr">class Dog extends Animal {<br/>  woof() { /* do woofing */ }<br/>}</span><span id="90f5" class="mp kw jg ne b gz ns np l nq nr">class PetWalker {<br/>  pets: [],<br/>  addPet(pet) {<br/>    this.pets.push(pet)<br/>  }<br/>  <br/>  walkPets() {<br/>    this.pets.forEach(walk)<br/>  }<br/>}</span><span id="8ed6" class="mp kw jg ne b gz ns np l nq nr">class Application {<br/>  static run() {<br/>    const walker = new PetWalker()<br/>    const mrFluffy = new Cat()<br/>    const mrsFluffy = new Cat()<br/>    const fido = new Dog()<br/>    walker.addPet(mrFluffy)<br/>    walker.addPet(mrsFluffy)<br/>    walker.addPet(fido)<br/>    walker.walkPets()<br/>  }<br/>}</span></pre><p id="45fc" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">那这张图有什么问题呢？</p><p id="197b" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">首先，如果这是一种纯粹的面向对象语言，那么创建walker的<em class="nf">实例</em>的代码也需要封装在一个更高级的对象中，直到你得到运行一切的<code class="fe nb nc nd ne b">Application</code>对象。</p><p id="6b99" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">另一方面，我不知道你有没有试过带一只猫去散步，但是…</p><figure class="ng nh ni nj gu it"><div class="bz fq l di"><div class="nt nu l"/></div><figcaption class="ja jb gk gi gj jc jd bd b be z dk translated">猫不是特别适合走路</figcaption></figure><p id="7ddb" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">所以你聪明的OO程序员很可能会创建一个<code class="fe nb nc nd ne b">Walkable</code>接口并重构上面的内容(也是用伪代码)</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="21b6" class="mp kw jg ne b gz no np l nq nr">interface Walkable {<br/>  walk()<br/>}</span><span id="9c2c" class="mp kw jg ne b gz ns np l nq nr">class Animal {<br/>  legs: 4<br/>}</span><span id="289c" class="mp kw jg ne b gz ns np l nq nr">class Cat extends Animal {<br/>  purr() { / do purring */ }<br/>}</span><span id="75e7" class="mp kw jg ne b gz ns np l nq nr">class Dog extends Animal, is Walkable {<br/>  walk() { /* do walking */ }<br/>  woof() { /* do woofing */ }<br/>}</span><span id="9f29" class="mp kw jg ne b gz ns np l nq nr">class WalkablePetWalker {<br/>  pets: [],<br/>  addPet(pet&lt;Walkable&gt;) {<br/>    this.pets.push(pet)<br/>  }<br/>  <br/>  walkPets() {<br/>    this.pets.forEach(walk)<br/>  }<br/>}</span><span id="dfb5" class="mp kw jg ne b gz ns np l nq nr">class Application {<br/>  static run() {<br/>    const walker = new PetWalker()<br/>    const fido = new Dog()<br/>    const mrFluffy = new Cat()<br/>    try {<br/>      walker.addPet(fido)<br/>      walker.addPet(mrFluffy) // =&gt; boom throws error.<br/>    } catch (err) {<br/>      logger.error(err)<br/>    } finally {<br/>      walker.walkPets()<br/>    }<br/>  }<br/>}</span></pre><p id="1772" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">因为继承迫使你预先定义你的问题域的深层结构，它变得越复杂就越脆弱。</p><p id="8386" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">尝试将<code class="fe nb nc nd ne b">Possum</code>添加到组合中。负鼠和猫一样，也不太愿意被人遛，但它们愿意。所以有理由说:</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="08d7" class="mp kw jg ne b gz no np l nq nr">class Possum extends Cat {}</span></pre><p id="4a9e" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">但这真的有意义吗？比方说，有些动物是可以被拍的，如果你试图拍一只不能被拍的动物，你就会被咬。</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="51ed" class="mp kw jg ne b gz no np l nq nr">interface Pattable {<br/>  pat()<br/>}</span><span id="106e" class="mp kw jg ne b gz ns np l nq nr">interface Purrs {<br/>  purr()<br/>}</span><span id="89c7" class="mp kw jg ne b gz ns np l nq nr">interface Woofer {<br/>  woof()<br/>}</span><span id="22d9" class="mp kw jg ne b gz ns np l nq nr">interface Bitey {<br/>  bite()<br/>}</span><span id="b864" class="mp kw jg ne b gz ns np l nq nr">class Cat extends Animal is Pattable, Purrs {<br/>  purr() { /* do purring */ }</span><span id="1813" class="mp kw jg ne b gz ns np l nq nr">  pat() {<br/>    this.purr()<br/>  }<br/>}</span><span id="7ba6" class="mp kw jg ne b gz ns np l nq nr">class Dog extends Animal is Walkable, Pattable, Woofs {<br/>  woof() { /* do woofing */ }<br/>  <br/>  pat() {<br/>    this.woof()<br/>  }<br/>}</span><span id="a49c" class="mp kw jg ne b gz ns np l nq nr">class Possum extends Animal is Bitey {<br/>  bite() { /* do biting */ }<br/>  <br/>  pat() {<br/>    this.bite()<br/>  }<br/>}</span></pre><p id="93a7" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">为了让这个有意义，我们需要<code class="fe nb nc nd ne b">Possum</code>也是<code class="fe nb nc nd ne b">Pattable</code>，这样外部对象就可以使用它的<code class="fe nb nc nd ne b">pat</code>功能。另外，与<code class="fe nb nc nd ne b">purr</code>和<code class="fe nb nc nd ne b">woof</code>不同的是，<code class="fe nb nc nd ne b">bite</code>需要一个目标。负鼠不仅会咬人，还会咬人。</p><p id="5f49" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">所以，为了让<code class="fe nb nc nd ne b">bite</code>函数知道谁在咬，我们需要修改<code class="fe nb nc nd ne b">Pattable</code>接口来指定哪个<code class="fe nb nc nd ne b">hand</code>在拍。</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="ecb0" class="mp kw jg ne b gz no np l nq nr">interface Pattable {<br/>  pat(hand)<br/>}</span><span id="4a07" class="mp kw jg ne b gz ns np l nq nr">class Cat extends Animal is Pattable, Purrs {<br/>  purr() { /* do purring */ }</span><span id="646c" class="mp kw jg ne b gz ns np l nq nr">  pat(hand) {<br/>    this.purr()<br/>  }<br/>}</span><span id="de2a" class="mp kw jg ne b gz ns np l nq nr">class Dog extends Animal is Walkable, Pattable, Woofs {<br/>  woof() { /* do woofing */ }<br/>  <br/>  pat(hand) {<br/>    this.woof()<br/>  }<br/>}</span><span id="1c97" class="mp kw jg ne b gz ns np l nq nr">class Possum extends Animal is Bitey {<br/>  bite(hand) { /* do biting of hand */ }<br/>  <br/>  pat(hand) {<br/>    this.bite(hand)<br/>  }<br/>}</span></pre><p id="a804" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">那么负鼠的<code class="fe nb nc nd ne b">bite(hand)</code>功能发生了什么？什么是<code class="fe nb nc nd ne b">hand</code>？</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="3bbd" class="mp kw jg ne b gz no np l nq nr">interface Biteable {<br/>  bittenBy(animal&lt;Bitey&gt;)<br/>}</span></pre><p id="a34f" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">让我们把蛇也加入进来。<code class="fe nb nc nd ne b">Snakes</code>明明是<code class="fe nb nc nd ne b">Animals</code>，他们不是<code class="fe nb nc nd ne b">Walkable</code>，而是<code class="fe nb nc nd ne b">Pattable</code>，他们不是<code class="fe nb nc nd ne b">purr</code>而是他们做<code class="fe nb nc nd ne b">bite</code>。但是他们没有<code class="fe nb nc nd ne b">legs</code>。</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="5f9d" class="mp kw jg ne b gz no np l nq nr">class Snake extends Animal is Pattable, Bitey {<br/>  legs: 0</span><span id="8517" class="mp kw jg ne b gz ns np l nq nr">  bite(hand&lt;Bitable&gt;) {<br/>   hand.bittenBy(this)<br/>  }</span><span id="b206" class="mp kw jg ne b gz ns np l nq nr">  pat(hand&lt;Bitable&gt;) {<br/>    this.bite(hand)<br/>  }<br/>}</span></pre><p id="7611" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">事情就是这样。</p><p id="b981" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">你原来的<code class="fe nb nc nd ne b">Animals</code>类现在可能需要了解<code class="fe nb nc nd ne b">bitable</code> <code class="fe nb nc nd ne b">hands</code>和其他各种事情。</p><p id="9a55" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">Erlang的创造者Joe Armstong在Peter Seibel所著的《工作中的编码者》一书中有一句名言:</p><blockquote class="nv nw nx"><p id="c8f2" class="ln lo nf lp b lq mk kh ls lt ml kk lv ny mm ly lz nz mn mc md oa mo mg mh mi ik bi translated">“面向对象语言的问题是，它们拥有所有这些它们随身携带的隐含环境。你想要一个香蕉，但你得到的是一只大猩猩拿着香蕉和整个丛林”</p></blockquote><h2 id="95ab" class="mp kw jg bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">宾语是名词，功能是动词</h2><p id="840e" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">切换到一个晚餐聚会的类比，在一个OO系统中，你不能广播一个“传递黄油”的一般请求，你必须查找实现<code class="fe nb nc nd ne b">Passable</code>的<code class="fe nb nc nd ne b">butter</code>，可能通过某种<code class="fe nb nc nd ne b">TableItemsManager</code>服务，然后调用它的<code class="fe nb nc nd ne b">pass</code>函数，把<code class="fe nb nc nd ne b">self</code>作为目标。太疯狂了。</p><p id="01c0" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">宾语通常被认为是名词的类似物；真实的东西。而对象的功能，或者用面向对象的说法是<em class="nf">方法</em>，是作用于那些名词的动词。但是现实世界并没有如此紧密地联系在一起。</p><p id="471c" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">史蒂夫·耶格在他的文章《名词王国中的执行》中明确讨论了这一点。</p><blockquote class="nv nw nx"><p id="1b37" class="ln lo nf lp b lq mk kh ls lt ml kk lv ny mm ly lz nz mn mc md oa mo mg mh mi ik bi translated">“Javaland中的动词负责所有的工作，但因为它们受到所有人的蔑视，所以任何动词都不允许自由走动。如果一个动词要在公共场合出现，它必须始终由一个名词伴随。</p><p id="e4da" class="ln lo nf lp b lq mk kh ls lt ml kk lv ny mm ly lz nz mn mc md oa mo mg mh mi ik bi translated">当然“护送”，作为一个动词本身，几乎不允许光着身子跑来跑去；必须获得马鞭草以方便护送。但是“促成”和“促成”呢？碰巧的是，促进者和拉皮条者都是相当重要的名词，他们的工作是分别通过促进和拉皮条伴随低级动词“促进”和“采购”。"</p></blockquote><p id="25cb" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">避免面向对象编程的原因有很多，但主要原因是<em class="nf">过度使用</em>对象，以及过度使用对象继承和多态(即使用接口对常见行为进行分组)。面向对象编程给了你一些惊人的工具来创建高度结构化，但非常脆弱的意大利面。没有人喜欢易碎的意大利面条。</p><h1 id="d0fc" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">面向对象和Javascript</h1><p id="de0f" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">对象的一个关键特性是它们能够在内部引用自己。在Javascript中，这意味着<code class="fe nb nc nd ne b">this</code>关键字。</p><p id="2441" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">关于关键字<code class="fe nb nc nd ne b">this</code>的脆弱本质，已经有很多文章了。Javascript开发新手在编写以下形式的回调函数时经常遇到困难:</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="7771" class="mp kw jg ne b gz no np l nq nr">function doSomething(data, callback) {<br/>  try {<br/>    const result = blahBlahSomethingWith(data)<br/>    callback(null, result)<br/>  } catch (err) {<br/>    callback(err)<br/>  }<br/>}</span></pre><p id="9a12" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">然后在一个对象中调用它</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="4348" class="mp kw jg ne b gz no np l nq nr">class SomethingDoer {<br/>  constructor(data) {<br/>    this.data = data<br/>    this.result = undefined<br/>  }<br/>  <br/>  doThing() {<br/>    doSomething(data, function(err, result) {<br/>      if (!err) {<br/>        this.result = result<br/>      }<br/>    })<br/>  }<br/>}</span></pre><p id="4500" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">这是行不通的，因为回调中的<code class="fe nb nc nd ne b">this</code>不是来自包含对象的<code class="fe nb nc nd ne b">this</code>，而是回调本身。</p><p id="5b23" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">您要么需要将回调<code class="fe nb nc nd ne b">bind</code>到外部上下文，要么可以使用箭头函数:</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="181b" class="mp kw jg ne b gz no np l nq nr">doThing() {<br/>  doSomething(data, (err, result) =&gt; {<br/>    if (!err) {<br/>      this.result = result<br/>    }<br/>  })<br/>}</span></pre><p id="7a9f" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">箭头功能使用外部上下文作为<code class="fe nb nc nd ne b">this</code>。</p><p id="22c7" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">但是回调混乱现在不是问题了，因为现在我们有了<code class="fe nb nc nd ne b">async</code> / <code class="fe nb nc nd ne b">await</code>没有人再使用回调了，除非他们被强迫。</p><p id="88c7" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">尽管如此，类似这样的代码并不少见:</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="6f4d" class="mp kw jg ne b gz no np l nq nr">class Compressor {<br/>  constructor(data, algorithm) {<br/>    this.algorithm = algorithm<br/>    this.data = data<br/>    this.result = {}<br/>  }<br/>  <br/>  compress() {<br/>    Object.keys(this.data).forEach(function(key) {<br/>      this.result[key] = this.algorithm(this.data[key])<br/>    })<br/>  }<br/>}</span></pre><p id="1cbb" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">当然，这和上面的原因是一样的。用箭头函数来修复它只能解决一部分问题:</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="a2a2" class="mp kw jg ne b gz no np l nq nr">compress() {<br/>  Object.keys(this.data).forEach(key =&gt; {<br/>    this.result[key] = this.algorithm(this.data[key])<br/>  })<br/>}</span></pre><p id="b8f9" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">会工作，但它很丑。最好使用<a class="ae mj" href="https://codeburst.io/currying-in-javascript-how-why-a0d66f1366b" rel="noopener" target="_blank">curry</a>并采取更实用的方法。</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="31c9" class="mp kw jg ne b gz no np l nq nr">const compressor = algorithm =&gt; data =&gt;<br/>  Object.keys(data).reduce((acc, elem) =&gt; {<br/>    acc[elem] = algorithm(data[elem])<br/>    return acc<br/>  }, {})</span></pre><p id="2320" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">然后用它来代替写作:</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="cbe8" class="mp kw jg ne b gz no np l nq nr">const compressor = new Compressor(data, gzip)<br/>compressor.compress()<br/>console.log(compressor.result)</span></pre><p id="bad5" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">你可以写:</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="40f1" class="mp kw jg ne b gz no np l nq nr">const compress = compressor(gzip)<br/>console.log(compress(data))</span></pre><p id="66fd" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">在Javascript中，除非明确需要一个事物的多个实例，否则最好还是坚持使用函数式方法。</p><h2 id="a2c9" class="mp kw jg bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">对象与对象</h2><p id="09d9" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">Javascript支持两种形式的OO风格对象</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="7bf3" class="mp kw jg ne b gz no np l nq nr">class SomeThing { ... }</span></pre><p id="6dcc" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">或者</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="b166" class="mp kw jg ne b gz no np l nq nr">function SomeThing() { ... }</span></pre><p id="ad1e" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">这些本质上是一回事。</p><p id="2f70" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">Javascript还允许以下对象:</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="3294" class="mp kw jg ne b gz no np l nq nr">const someThing = {<br/>  x: 'some x',<br/>  y: 'some y'<br/>}</span></pre><p id="d0d9" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">哪个更像其他语言中的<code class="fe nb nc nd ne b">struct</code>或<code class="fe nb nc nd ne b">dictionary</code>。大多数Javascript开发人员使用一个术语“对象”来指代这两种类型，其含义来自上下文。</p><p id="d4a5" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">一般来说，如果你用<code class="fe nb nc nd ne b">class</code>来定义它或者使用<code class="fe nb nc nd ne b">new</code>关键字来创建它的一个实例，那么你就用大写字母来命名它。如果它只是一个容器，那么你就不能把它资本化。</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="1b4b" class="mp kw jg ne b gz no np l nq nr">class Thing {}<br/>const thing = new Thing()</span><span id="f28e" class="mp kw jg ne b gz ns np l nq nr">const somethingElse = {<br/>  yay: 'That makes sense'<br/>}</span></pre><h1 id="f667" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">题外话:什么是函数式编程？</h1><p id="3dfa" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">函数式编程强调<a class="ae mj" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">不变性</a>、<a class="ae mj" href="https://en.wikipedia.org/wiki/Idempotence" rel="noopener ugc nofollow" target="_blank">幂等性</a>和<a class="ae mj" href="https://www.simplethread.com/pure-and-deterministic-functions/" rel="noopener ugc nofollow" target="_blank">确定性</a>。它更喜欢<a class="ae mj" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank"> <em class="nf">纯</em>函数</a>而不是有副作用或者结果不确定的函数，以及<a class="ae mj" href="https://en.wikipedia.org/wiki/Function_composition" rel="noopener ugc nofollow" target="_blank">函数组合</a>，又名currying。函数式编程语言的一个关键特征是函数是“一级”语言元素，这意味着你可以传递它们并对它们赋值，就像它们只是另一个变量一样。</p><p id="b231" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">函数式编程植根于λ演算，这是一种数学抽象，为描述函数及其评估提供了理论框架。</p><h2 id="a284" class="mp kw jg bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">纯函数</h2><p id="3462" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">纯函数就是不影响函数外部任何东西的函数，对于相同的输入，它将总是返回相同的输出。</p><p id="9214" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">所以下面的<code class="fe nb nc nd ne b">pusher</code>函数在改变数组的值时并不纯粹。</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="965f" class="mp kw jg ne b gz no np l nq nr">function pusher(array, data) {<br/>  array.push(data)<br/>}</span></pre><p id="f6df" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">一个纯粹的版本会像</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="0e3d" class="mp kw jg ne b gz no np l nq nr">function pusher(originalArray, data) {<br/>  return [...originalArray, data]<br/>}</span></pre><p id="9178" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">在这种情况下，原始数组没有被修改，而是将其元素复制到结果中。</p><p id="43ed" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">纯函数很容易推理，也很容易单独测试。</p><h1 id="5da5" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">更多Javascript OO的怪异之处</h1><p id="3840" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">这是我见过的一段真实的代码:</p><p id="938f" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">假设这个文件在<code class="fe nb nc nd ne b">src/utils/Cache.js</code>中。</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="b216" class="mp kw jg ne b gz no np l nq nr">class Cache {<br/>  constructor() {<br/>    this.store = {}<br/>  }<br/>  <br/>  put(key, value) {<br/>    this.store[key] = value<br/>  }<br/>  <br/>  take(key) {<br/>    return this.store[key]<br/>  }<br/>  <br/>  clear(key) {<br/>    delete this.store[key]<br/>  }<br/>  <br/>  reset() {<br/>    this.store = {}<br/>  }<br/>}</span></pre><p id="3159" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">然后在<code class="fe nb nc nd ne b">src/utils/sharedCache.js</code>里。</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="5173" class="mp kw jg ne b gz no np l nq nr">const Cache = require('src/utils/Cache)</span><span id="ced6" class="mp kw jg ne b gz ns np l nq nr">module.exports = new Cache()</span></pre><p id="092b" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">然后在<code class="fe nb nc nd ne b">src/server.js</code>。</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="c0d9" class="mp kw jg ne b gz no np l nq nr">const { put } = require('./utils/sharedCache')<br/>const makeServer = require('./utils/server/makeServer')</span><span id="636e" class="mp kw jg ne b gz ns np l nq nr">function async start() {<br/>  const server = makeServer()<br/>  await server.start()<br/>  put('server', server)<br/>}</span></pre><p id="1363" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">但是有一件奇怪的事情:这根本行不通。<code class="fe nb nc nd ne b">put</code>函数中的<code class="fe nb nc nd ne b">this</code>并不是您所期望的<code class="fe nb nc nd ne b">Cache</code>对象的实例，而是您调用它的函数。</p><p id="9e3b" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">正如在Javascript的this关键字指南中所解释的:</p><blockquote class="nv nw nx"><p id="7eba" class="ln lo nf lp b lq mk kh ls lt ml kk lv ny mm ly lz nz mn mc md oa mo mg mh mi ik bi translated">当变量被定义为指向实例方法的函数时，该函数将丢失此</p></blockquote><p id="8e70" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">这是一个非常微妙的错误，我见过甚至是经验丰富的Javascript程序员，包括我自己，在很多情况下都会犯这个错误。</p><p id="6cda" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">除非您需要一个以上的共享缓存，老实说，您为什么要这样做，那么最好只写:</p><p id="a240" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">在文件<code class="fe nb nc nd ne b">src/utils/sharedCache.js</code>中</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="0a42" class="mp kw jg ne b gz no np l nq nr">let store</span><span id="6d14" class="mp kw jg ne b gz ns np l nq nr">const put = (key, value) =&gt; {<br/>  store[key] = value<br/>}</span><span id="f682" class="mp kw jg ne b gz ns np l nq nr">const take = key =&gt; store[key]</span><span id="d1cb" class="mp kw jg ne b gz ns np l nq nr">const clear = key =&gt; {<br/>  delete store[key]<br/>}</span><span id="de23" class="mp kw jg ne b gz ns np l nq nr">const reset = () =&gt; {<br/>  store = {}<br/>}</span><span id="60d4" class="mp kw jg ne b gz ns np l nq nr">reset()</span><span id="22a1" class="mp kw jg ne b gz ns np l nq nr">module.exports = { put, take, clear, reset }</span></pre><p id="f218" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">在Javascript中，模块中的代码在模块第一次加载时就被执行。一旦加载，就不会再执行。您可以利用这个事实来避免使用<code class="fe nb nc nd ne b">this</code>或<code class="fe nb nc nd ne b">bind</code>。</p><h2 id="31f5" class="mp kw jg bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">Javascript中的对象比纯函数更难测试</h2><p id="630f" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">假设你有一个函数，比如:</p><pre class="ng nh ni nj gu nk ne nl nm aw nn bi"><span id="7cb6" class="mp kw jg ne b gz no np l nq nr">const Client = require('api-access-client')<br/>const config = require('../config')<br/>const mapUsers = require('../utils/mapUsers')</span><span id="24f2" class="mp kw jg ne b gz ns np l nq nr">const client = new Client(config)</span><span id="3ec8" class="mp kw jg ne b gz ns np l nq nr">const getUsers = async function() {<br/>  const client = new Client(config)<br/>  const userData = await client.get()<br/>  return userData.map(mapUsers)<br/>}</span></pre><p id="05ca" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">为了测试这一点，用<code class="fe nb nc nd ne b">mocha</code>和<code class="fe nb nc nd ne b">proxyquire</code>模拟客户端，您需要创建一个模拟<code class="fe nb nc nd ne b">Client</code>类。要用<code class="fe nb nc nd ne b">Jest</code>模拟它，你需要写一个<a class="ae mj" href="https://jestjs.io/docs/en/manual-mocks.html" rel="noopener ugc nofollow" target="_blank">手动模拟</a>。不管怎样，这都是一堆额外的工作。如果<code class="fe nb nc nd ne b">Client</code>只是一个漂亮的curried函数，那么做这些模拟将是微不足道的。</p><h1 id="99a2" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">第一部分到此结束</h1><p id="7cb1" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ik bi translated">转到第二部分,我在其中详述了我的面向对象体系结构，解释为什么没有人应该使用Typescript。</p><h2 id="1ba1" class="mp kw jg bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">我们了解到:</h2><ul class=""><li id="dca5" class="ob oc jg lp b lq lr lt lu lw od ma oe me of mi og oh oi oj bi translated">分层面向对象的软件设计只适用于非常有限的问题领域，过度使用面向对象会导致糟糕的软件架构</li><li id="f83b" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated">在Javascript中过度使用对象是一件可怕的事情</li><li id="23aa" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated">如果你以一种有纪律的方式接受Javascript的灵活的T21类型和功能方法，你将会写出更好的代码</li><li id="1d42" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated">你应该测试一切——至少是单元测试和集成测试，但是也要加入一些突变测试来测试你的测试</li></ul><h1 id="4d78" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">链接</h1><h2 id="66be" class="mp kw jg bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">文章</h2><ul class=""><li id="1434" class="ob oc jg lp b lq lr lt lu lw od ma oe me of mi og oh oi oj bi translated"><a class="ae mj" href="http://codersatwork.com" rel="noopener ugc nofollow" target="_blank">工作中的编码员</a></li><li id="398d" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" rel="noopener ugc nofollow" target="_blank">名词王国里的处决</a></li><li id="a956" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://www.sciencedirect.com/science/article/abs/pii/S1350630704000123" rel="noopener ugc nofollow" target="_blank">干意大利面的脆断</a></li><li id="06d5" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://codeburst.io/currying-in-javascript-how-why-a0d66f1366b" rel="noopener" target="_blank">Javascript中的Currying如何和为什么</a></li><li id="3461" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://medium.com/datadriveninvestor/a-potterheads-guide-to-javascript-s-this-keyword-7908399d0e93" rel="noopener">Javascript的this关键字指南</a></li><li id="cf2d" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://medium.com/@davesag/shit-javascript-coders-say-7a2d2881228d" rel="noopener">狗屁Javascript编码员说</a></li></ul><h2 id="b13e" class="mp kw jg bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">技术</h2><ul class=""><li id="19a4" class="ob oc jg lp b lq lr lt lu lw od ma oe me of mi og oh oi oj bi translated"><a class="ae mj" href="https://www.typescriptlang.org" rel="noopener ugc nofollow" target="_blank">打字稿</a></li><li id="14dd" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank"> NodeJS </a></li><li id="52ce" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://mochajs.org" rel="noopener ugc nofollow" target="_blank">摩卡</a></li><li id="453e" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://github.com/thlorenz/proxyquire" rel="noopener ugc nofollow" target="_blank">代理查询</a></li><li id="2fbd" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://babeljs.io" rel="noopener ugc nofollow" target="_blank">巴别塔</a></li><li id="59f5" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://webpack.js.org" rel="noopener ugc nofollow" target="_blank">网络包</a></li><li id="2b3c" class="ob oc jg lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><a class="ae mj" href="https://jestjs.io" rel="noopener ugc nofollow" target="_blank">笑话</a></li></ul><p id="3546" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi">—</p><p id="f5f2" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ik bi translated">像这样但不是订户？你可以通过<a class="ae mj" href="https://davesag.medium.com/membership" rel="noopener">davesag.medium.com</a>加入来支持作者。</p></div></div>    
</body>
</html>