<html>
<head>
<title>Getting a Persistant Address to a ECS Fargate Container.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">获取ECS Fargate容器的持久地址。</h1>
<blockquote>原文：<a href="https://itnext.io/getting-a-persistant-address-to-a-ecs-fargate-container-3df5689f6e56?source=collection_archive---------1-----------------------#2020-08-06">https://itnext.io/getting-a-persistant-address-to-a-ecs-fargate-container-3df5689f6e56?source=collection_archive---------1-----------------------#2020-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2dba" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">实用开发工具</h2><div class=""/><div class=""><h2 id="7dac" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">应该很容易吧？其实不是。我是这样做的。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ffe56b9be8dabb964060bc6fed9cafe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1C3ou2hEl149dta2OJiAg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我的ECS容器在哪里？—<a class="ae le" href="https://unsplash.com/@jens_johnsson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jens Johnsson</a>在<a class="ae le" href="https://unsplash.com/photos/hUqt9UQM_5Q?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="65c2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，我们有一个EC2实例，它的寿命比自己长，<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/breaking-in-to-a-ec2-instance-c01443f61ce9">密钥丢失了(在这里阅读我们如何恢复内容)</a>并且需要替换它。</p><p id="1f4d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">与其为它重新安装一个全新的EC2服务器，我想，嘿，为什么不做一个小的docker容器并在Fargate上部署它，这应该足够简单了，对吧？</p><p id="1d9a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">事实证明，实际上有两个复杂的问题，其中一个我将在这里讨论，另一个是另一篇文章的主题:<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/stay-in-control-with-your-private-npm-registry-f7d1d4791698">提示，它将涉及使用l </a>锁定/冻结注册表的字节安全。</p><p id="9555" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另一个挑战，乍一看，似乎微不足道。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mb"><img src="../Images/bb5f41b9500e3190f6951ace4a46302a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P__aMxMQoLtCl8gR"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">维克多·加西亚在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f3fa" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我只需要为运行Statsd应用程序的ECS Fargate容器保留相同的公共地址。正如人们可能猜测的那样，这个地址在我们的整个环境中使用，在大量的服务和应用程序中配置。不断改变配置测试将是一场噩梦。</p><p id="1d59" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">不幸的是，使用内部IP(这对于这样的服务来说完全有意义)是不可能的，因为服务需要从多个VPC可达，而由于IP重叠，没有VPC对等的可能性。</p><p id="d7f7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，在你们大喊“使用AWS ECS服务发现”之前，我只想指出…该服务目前不适用于公共IP，仅适用于内部IP。如果您一直读到这里，请在下面的链接中为添加ECS功能投票😃</p><blockquote class="mc"><p id="1e1f" class="md me iq bd mf mg mh mi mj mk ml ma dk translated">很遗憾，ECS服务发现目前不发布公共IP，仅发布内部IP…</p></blockquote><div class="mm mn mo mp mq mr"><a href="https://github.com/aws/containers-roadmap/issues/737" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ja gy z fp mw fr fs mx fu fw iz bi translated">[ECS][请求]:公共IP服务发现问题# 737 AWS/containers-路线图</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">机构群体注意事项请通过添加👍对原始问题的反应，以帮助社区和…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">github.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ky mr"/></div></div></a></div><p id="0559" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是，在AWS的好人们添加这个功能之前，请继续阅读。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="e003" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，我们要做的是让ECS在每次docker容器启动时用公共IP地址更新Route53。这样，我们可以在我们的应用程序和服务中使用服务的DNS名称。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/211eaf1ef3e11c4839ff4511e6cc4503.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*VvbAmiMKaBqB20wsCxTSjg.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">(是的，我以前就有一个)bert sz在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3da5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">环顾四周，我已经看到了该解决方案的一些不同变体，但我得到的最接近的是部署一个Lambda函数，该函数由ECS生命周期中的状态变化触发。<a class="ae le" href="https://medium.com/@andreas.pasch/automatic-public-dns-for-fargate-managed-containers-in-amazon-ecs-f0ca0a0334b5" rel="noopener">像这个</a>或者<a class="ae le" href="https://medium.com/galvanize/static-ip-applications-on-aws-ecs-c7d411421d4f" rel="noopener">这个。对我来说，这样的解决方案有点...对我的用例来说臃肿。我想让我的溶液很好地，包含在…容器里。而不是开始使用(并支付)更多的服务。(使用ALB/NLB完成小型ECS Fargate任务的成本很容易超过实际ECS本身的成本)</a></p><p id="4945" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由于我有点守旧，我将使用Bash和CLI工具来完成这项工作。😁</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="fb6c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我将从我的容器开始，它是<a class="ae le" href="https://github.com/statsd/statsd" rel="noopener ugc nofollow" target="_blank">官方Statsd容器</a>，从那里我们将稍微修改我们的docker文件以安装AWSCLI包和jq工具，并添加定制脚本来准备和执行对Route53的UPSERT。</p><p id="07cb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们还将利用ECS变量来了解要修改哪个DNS记录。这样，我们将能够使用不同的公共IP运行相同的容器，一个用于我们的测试环境，一个用于。生产等。</p><h2 id="dd6d" class="no np iq bd nq nr ns dn nt nu nv dp nw lo nx ny nz ls oa ob oc lw od oe of iw bi translated">Dockerfile文件</h2><p id="31d7" class="pw-post-body-paragraph lf lg iq lh b li og ka lk ll oh kd ln lo oi lq lr ls oj lu lv lw ok ly lz ma ij bi translated">我们将创建一个包装器脚本，并使用它来代替我们现有的入口点配置</p><p id="23e2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">启动statsd的未更改docker文件大致如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="565e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将把上面的入口点换成一个包装器脚本，它执行我们的Route53魔术，然后启动节点应用程序。同时，让我们添加我们的依赖项，<strong class="lh ja"> awscli </strong>和<strong class="lh ja"> jq </strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="6dcc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">‼️注意你使用的是哪个版本的awscli。我花了太多的时间来解决为什么我的容器没有像预期的那样运行。我第一次尝试使用apt-get来安装它，给了我一个旧版本，它没有失败，但在API响应中遗漏了一些元素。</p><p id="07c7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Entrypoint.sh很简单:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="3b97" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是在<strong class="lh ja">更新-route53.sh </strong>是我们的奇迹发生的地方。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/4a4227fd2ce83ae70c0c870d4f0d18e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RiZqzK04lRm6bP3GF3EgKg.png"/></div></div></figure><ol class=""><li id="b7a2" class="oo op iq lh b li lj ll lm lo oq ls or lw os ma ot ou ov ow bi translated">首先，我们调用任务元数据端点来获取当前的TaskARN和集群ID。</li><li id="ae18" class="oo op iq lh b li ox ll oy lo oz ls pa lw pb ma ot ou ov ow bi translated">使用这些，我们调用ECS API来获取我们连接的网络接口(ENI)。</li><li id="849a" class="oo op iq lh b li ox ll oy lo oz ls pa lw pb ma ot ou ov ow bi translated">最后，我们调用EC2 API来获取ENI的详细信息，即我们的公共IP地址。</li></ol><p id="45a2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们知道我们的公共IP时，我们使用ECS任务定义中提供的设置构建一个UPSERT记录并发送给Route53 API。</p><p id="6aaf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以下是完整的更新-route53.sh:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="2c3a" class="no np iq bd nq nr ns dn nt nu nv dp nw lo nx ny nz ls oa ob oc lw od oe of iw bi translated">ECS任务配置</h2><p id="c4ff" class="pw-post-body-paragraph lf lg iq lh b li og ka lk ll oh kd ln lo oi lq lr ls oj lu lv lw ok ly lz ma ij bi translated">现在，为了实现上述目标，我们需要一些额外的访问权限，以便能够从API获取信息并更新Route53。</p><p id="e332" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">根据您的设置和安全需求，您可能希望下面的内容更严格一些。</p><p id="8eb3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">💡</strong>在将下面的资源添加到您的ECS任务角色之前，不要忘记将其更改为Route53 ZoneID</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="0c0f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后一步是配置ECS环境变量，这些变量将指示脚本修改哪个Route53区域以及创建或更新哪个DNS记录。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pc"><img src="../Images/4b75eef67cebde12343b2a39c26b65d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhlfFX1qp-AnO_RFXtVJWQ.png"/></div></div></figure></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="9f17" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">就是这样！现在，您可以重新启动ECS实例，一旦新容器启动，它将自动使用其公共IP更新Route53 DNS条目。</p></div></div>    
</body>
</html>