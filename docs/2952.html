<html>
<head>
<title>Part 2: A Complete Guide For Building RESTful Applications Using Aqueduct</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第2部分:使用Aqueduct构建RESTful应用程序的完整指南</h1>
<blockquote>原文：<a href="https://itnext.io/part-2-a-complete-guide-for-building-restful-applications-using-aqueduct-c58688ab8b8e?source=collection_archive---------4-----------------------#2019-09-05">https://itnext.io/part-2-a-complete-guide-for-building-restful-applications-using-aqueduct-c58688ab8b8e?source=collection_archive---------4-----------------------#2019-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/acbbb66e49d2e1c585cd98970a252896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d4epJ7VXxqwDGHZ2r65fA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:<a class="ae kc" href="https://bs-uploads.toptal.io/blackfish-uploads/blog/article/content/cover_image_file/cover_image/14556/cover-code-sharing-angular-dart-flutter-bloc-fdde1ea49ed55f1ab00c61d9dabeb97c.png" rel="noopener ugc nofollow" target="_blank">https://bs-uploads . toptal . io</a></figcaption></figure><p id="93fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章是我第一篇关于<a class="ae kc" href="https://medium.com/@zubairehman.work/part-1-a-complete-guide-for-building-restful-applications-using-aqueduct-668b07f62ad5" rel="noopener"> <strong class="kf ir">的文章的延续，这是一篇关于使用Aqueduct </strong> </a> <strong class="kf ir">构建RESTful应用程序的完整指南。</strong>在上一篇文章中，我们了解了渡槽及其核心概念。在本文中，我们将学习如何使用<strong class="kf ir"><em class="lb"/></strong>配置和构建我们的第一个应用程序。到本文结束时，您将已经创建了一个为虚构的英雄服务的Aqueduct应用程序。</p><p id="5828" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们继续之前，如果您对Aqueduct不熟悉，我建议您阅读我的第一篇文章，在这篇文章中，我简要介绍了Aqueduct及其核心概念。</p><h1 id="51bf" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">介绍</h1><p id="a8a4" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Aqueduct是一个现代的Dart HTTP服务器框架。该框架由用于处理和路由HTTP请求、对象关系映射(ORM)、身份验证和授权(OAuth 2.0 provider)以及文档(OpenAPI)的库组成。这些库用于构建运行在Dart VM上的可伸缩REST APIs。</p><h1 id="d042" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">入门指南</h1><p id="f93e" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">要开始使用，请确保您安装了以下软件:</p><ol class=""><li id="8a84" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">镖(<a class="ae kc" href="https://www.dartlang.org/install" rel="noopener ugc nofollow" target="_blank">安装说明</a></li><li id="38db" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">IntelliJ IDEA或任何其他Jetbrains IDE，包括免费社区版(<a class="ae kc" href="https://www.jetbrains.com/idea/download/" rel="noopener ugc nofollow" target="_blank">安装说明</a>)</li><li id="2684" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">IntelliJ IDEA Dart插件(<a class="ae kc" href="https://www.dartlang.org/tools/jetbrains-plugin" rel="noopener ugc nofollow" target="_blank">安装说明</a>)</li></ol><h2 id="a58b" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">激活导水管</h2><p id="9a27" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在你的终端上运行<code class="fe nf ng nh ni b">pub global activate aqueduct</code>，激活<strong class="kf ir"> <em class="lb">水道</em> </strong>。这将下载并安装使用Aqueduct <strong class="kf ir">所需的所有依赖项。</strong></p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/f699db5be5d2fa561df67efcdc09842f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8N_4jF8sqtIBeeUa1Ubreg.png"/></div></div></figure><h2 id="a264" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">创建项目</h2><p id="7bbe" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在终端上运行<code class="fe nf ng nh ni b"> aqueduct create heroes</code>创建一个新项目。这将在终端中指定的目录下创建一个<code class="fe nf ng nh ni b">heroes</code>项目。您可以在<a class="ae kc" href="https://www.jetbrains.com/idea/download/" rel="noopener ugc nofollow" target="_blank"> IntelliJ IDE </a>、<a class="ae kc" href="https://atom.io/" rel="noopener ugc nofollow" target="_blank"> Atom </a>或<a class="ae kc" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio Code </a>中打开项目目录。这三个ide都有可用的Dart插件。</p><p id="d3b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在项目视图中，找到<code class="fe nf ng nh ni b">lib</code>目录；这是您的项目的代码将去的地方。这个项目有两个源文件- <code class="fe nf ng nh ni b">heroes.dart</code>和<code class="fe nf ng nh ni b">channel.dart</code>。打开文件<code class="fe nf ng nh ni b">heroes.dart</code>。点击编辑器右上角的<code class="fe nf ng nh ni b">Enable Dart Support</code>。</p><blockquote class="no np nq"><p id="d3f0" class="kd ke lb kf b kg kh ki kj kk kl km kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated">注意:项目名必须是snake_case</p></blockquote><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/f91d6a12459d76785c5296ada4a1dc2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z7g2X9ALmGvHMKTO25Kfkw.png"/></div></div></figure><p id="b3a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有其他模板包含使用<strong class="kf ir"> Aqueduct的</strong> ORM和OAuth 2.0实现的基础代码。这些模板可以列出:</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="5bb3" class="mt ld iq ni b gy nz oa l ob oc">aqueduct create list-templates</span></pre><p id="815b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建项目时，您可以提供模板的名称以使用该模板:</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="fb93" class="mt ld iq ni b gy nz oa l ob oc">aqueduct create -t db [my_project_name]</span></pre><h2 id="bd7f" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">运行项目</h2><p id="f20d" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">现在我们已经成功地创建了一个项目，是时候通过简单地从我们的项目目录中运行<code class="fe nf ng nh ni b">aqueduct serve</code>来运行我们的应用程序了。对于在IDE中运行，运行<code class="fe nf ng nh ni b">bin/main.dart</code>。默认情况下，将使用名为<code class="fe nf ng nh ni b">config.yaml</code>的配置文件。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/7dd600fb5a513970c8252f998f6c4415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ciz3_kCiv7lfLpeicCeOVg.png"/></div></div></figure><p id="b32d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您的浏览器中输入以下URL(我使用的是端口8888。此端口可能与您的不同，并且在启动aqueduct服务器后在终端中可见)</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="1f6c" class="mt ld iq ni b gy nz oa l ob oc"><a class="ae kc" href="http://localhost:8888/example" rel="noopener ugc nofollow" target="_blank">http://localhost:8888/example</a></span></pre><p id="12e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该能够在浏览器中看到以下输出</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="2106" class="mt ld iq ni b gy nz oa l ob oc">{"key":"value"}</span></pre><p id="d5e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在我们的<code class="fe nf ng nh ni b">heroes</code>项目中添加更多的代码来获得一个英雄列表，并通过其标识符获得一个英雄。这些请求是:</p><ol class=""><li id="3240" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated"><code class="fe nf ng nh ni b">GET /heroes</code>获取英雄列表</li><li id="af2e" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><code class="fe nf ng nh ni b">GET /heroes/:id</code>获得个人英雄</li></ol><p id="39f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在我们深入实现之前，让我们快速看一下我们的请求是如何处理的。</p><h2 id="af38" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">控制器对象处理请求</h2><p id="9089" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">请求由<em class="lb">控制器对象</em>处理。控制器对象可以响应请求。它还可以采取其他行动，让另一个控制器作出响应。</p><p id="ab88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的应用程序将连接两个控制器:</p><ul class=""><li id="031a" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la oe ml mm mn bi translated">确保请求路径是<code class="fe nf ng nh ni b">/heroes</code>或<code class="fe nf ng nh ni b">/heroes/:id</code>的<code class="fe nf ng nh ni b">Router</code></li><li id="5216" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la oe ml mm mn bi translated">用英雄对象响应的<code class="fe nf ng nh ni b">HeroesControllers</code></li></ul><p id="9add" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的应用程序从一个名为<code class="fe nf ng nh ni b">application channel</code>的通道对象开始。您将应用程序中的控制器链接到该通道。每个应用程序都有一个<code class="fe nf ng nh ni b">ApplicationChannel</code>的子类，您可以覆盖其中的方法来设置您的控制器。这个类型已经在<code class="fe nf ng nh ni b">lib/channel.dart</code>中声明了——打开这个文件，找到<code class="fe nf ng nh ni b">ApplicationChannel.entryPoint</code>:</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="b4e3" class="mt ld iq ni b gy nz oa l ob oc">@override<br/>  Controller get entryPoint {<br/>    final router = Router();<br/><br/>    router<br/>      .route('/example')<br/>      .linkFunction((request) async {<br/>        return Response.ok({'key': 'value'});<br/>      });<br/><br/>    return router;<br/>  }</span></pre><p id="7804" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您的应用程序收到请求时，<code class="fe nf ng nh ni b">entryPoint</code>控制器首先处理它。在我们的例子中，这是一个<code class="fe nf ng nh ni b">Router</code>——一个<code class="fe nf ng nh ni b">Controller</code>的子类。我们需要将路径<code class="fe nf ng nh ni b">/heroes</code>路由到我们自己的控制器，这样我们就可以控制发生了什么。</p><p id="0613" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过在<code class="fe nf ng nh ni b">lib/controller/heroes_controller.dart</code>中创建一个新文件来创建一个<code class="fe nf ng nh ni b">HeroesController</code>，并添加以下代码(您将需要创建子目录<code class="fe nf ng nh ni b">lib/controller/</code>):</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="4a5d" class="mt ld iq ni b gy nz oa l ob oc">import 'package:aqueduct/aqueduct.dart';<br/>import 'package:heroes/heroes.dart';<br/><br/>class HeroesController extends Controller {<br/>  final _heroes = [<br/>    {'id': 11, 'name': 'Captain America'},<br/>    {'id': 12, 'name': 'Ironman'},<br/>    {'id': 13, 'name': 'Wonder Woman'},<br/>    {'id': 14, 'name': 'Hulk'},<br/>    {'id': 15, 'name': 'Black Widow'},    <br/>  ];</span><span id="aa92" class="mt ld iq ni b gy of oa l ob oc">  @override<br/>  Future&lt;RequestOrResponse&gt; handle(Request request) async {<br/>    return Response.ok(_heroes);<br/>  }<br/>}</span></pre><p id="421c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，<code class="fe nf ng nh ni b">HeroesController</code>是<code class="fe nf ng nh ni b">Controller</code>的子类，它通过返回200 OK状态码和包含JSON编码的英雄列表<code class="fe nf ng nh ni b">Response</code>对象的主体来覆盖<code class="fe nf ng nh ni b">handle</code>方法。</p><p id="0496" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们的<code class="fe nf ng nh ni b">HeroesController</code>还没有连接到应用程序通道。我们需要把它连接到路由器上。首先，在<code class="fe nf ng nh ni b">channel.dart</code>的顶部导入我们的新文件。</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="00fd" class="mt ld iq ni b gy nz oa l ob oc">import 'controller/heroes_controller.dart';</span></pre><p id="1eb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后将此<code class="fe nf ng nh ni b">HeroesController</code>链接到路径<code class="fe nf ng nh ni b">/heroes</code>的<code class="fe nf ng nh ni b">Router</code>:</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="68d3" class="mt ld iq ni b gy nz oa l ob oc">@override<br/>Controller get entryPoint {<br/>  final router = Router();</span><span id="7b95" class="mt ld iq ni b gy of oa l ob oc">  router<br/>    .route('/heroes')<br/>    .link(() =&gt; HeroesController());</span><span id="54a4" class="mt ld iq ni b gy of oa l ob oc">  router<br/>    .route('/example')<br/>    .linkFunction((request) async {<br/>      return Response.ok({'key': 'value'});<br/>    });</span><span id="a753" class="mt ld iq ni b gy of oa l ob oc">  return router;<br/>}</span></pre><p id="fc82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有一个应用程序将返回一个英雄列表。让我们使用<code class="fe nf ng nh ni b">Ctrl+ c</code>停止我们的应用程序，并通过从命令行运行以下命令来重新启动:</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="0c47" class="mt ld iq ni b gy nz oa l ob oc">aqueduct serve</span></pre><p id="9de1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在浏览器中输入以下URL</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="b207" class="mt ld iq ni b gy nz oa l ob oc"><a class="ae kc" href="http://localhost:8888/heroes" rel="noopener ugc nofollow" target="_blank">http://localhost:8888/heroes</a></span></pre><p id="fcfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该能够在浏览器中看到以下输出</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="cb6f" class="mt ld iq ni b gy nz oa l ob oc">[<br/>  {"id":11,"name":"Captain America"},<br/>  {"id":12,"name":"Ironman"},<br/>  {"id":13,"name":"Wonder Woman"},<br/>  {"id":14,"name":"Hulk"},<br/>  {"id":15,"name":"Black Widow"}<br/>]</span></pre><p id="30ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜你，你已经完成了第一部分的设置，这是得到一个<code class="fe nf ng nh ni b">heroes</code>的列表。现在，让我们继续下一步，通过提供单个<code class="fe nf ng nh ni b">hero</code>的<code class="fe nf ng nh ni b">:id</code>来检索它。</p><h2 id="fb02" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">高级路由</h2><p id="398f" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">现在，我们的应用程序处理<code class="fe nf ng nh ni b">GET /heroes</code>请求。现在我们想发送一个请求来找回一个英雄。让我们修改<code class="fe nf ng nh ni b">channel.dart</code>中的<code class="fe nf ng nh ni b">/heroes</code>路线，并添加以下代码:</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="666a" class="mt ld iq ni b gy nz oa l ob oc">router<br/>  .route('/heroes/[:id]')<br/>  .link(() =&gt; HeroesController());</span></pre><p id="a634" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方括号内的任何内容都是可选的，在我们的例子中，它是我们路线的<code class="fe nf ng nh ni b">:id</code>部分。让我们修改<code class="fe nf ng nh ni b">heroes_controller.dart</code>来增加对处理单个英雄请求的支持。</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="b2b0" class="mt ld iq ni b gy nz oa l ob oc">@override<br/>Future&lt;RequestOrResponse&gt; handle(Request request) async {<br/>  if (request.path.variables.containsKey('id')) {<br/>    final id = int.parse(request.path.variables['id']);<br/>    final hero = _heroes.firstWhere((hero) =&gt; hero['id'] == id, orElse: () =&gt; null);<br/>    if (hero == null) {<br/>      return Response.notFound();<br/>    }</span><span id="eb14" class="mt ld iq ni b gy of oa l ob oc">    return Response.ok(hero);<br/>  }</span><span id="8394" class="mt ld iq ni b gy of oa l ob oc">  return Response.ok(_heroes);<br/>}</span></pre><p id="7f49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们重新启动我们的应用程序，并通过在浏览器中键入以下URL来发出单个英雄请求:</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="780b" class="mt ld iq ni b gy nz oa l ob oc">http://localhost:8888/heroes/11</span></pre><p id="8484" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出将是这样的:</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="9063" class="mt ld iq ni b gy nz oa l ob oc">{"id":11,"name":"Captain America"}</span></pre><blockquote class="no np nq"><p id="3238" class="kd ke lb kf b kg kh ki kj kk kl km kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated">注意:也可以使用终端做请求，例如:curl-X GET<a class="ae kc" href="http://localhost:8888/heroes/11" rel="noopener ugc nofollow" target="_blank">http://localhost:8888/heroes/11</a>。你也可以通过获得一个不存在的英雄来触发404未找到响应。</p></blockquote><p id="10b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe nf ng nh ni b">HeroesController</code>现在还可以，但是很快就会遇到一个问题:当我们想要创造一个新英雄的时候会发生什么？或者更新一个现有英雄的名字？我们的<code class="fe nf ng nh ni b">handle</code>方法将很快变得难以控制。</p><p id="b91f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是<code class="fe nf ng nh ni b">ResourceController</code>的用武之地。</p><h2 id="75a7" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">资源控制器和操作方法</h2><p id="8d2b" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">一个<code class="fe nf ng nh ni b">ResourceController</code>允许你为我们可以在英雄身上执行的每个操作创建一个独特的方法。</p><p id="d7ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nf ng nh ni b">heroes_controller.dart</code>中，用以下内容替换<code class="fe nf ng nh ni b">HeroesController</code>:</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="3612" class="mt ld iq ni b gy nz oa l ob oc">class HeroesController extends ResourceController {<br/>  final _heroes = [<br/>    {'id': 11, 'name': 'Captain America'},<br/>    {'id': 12, 'name': 'Ironman'},<br/>    {'id': 13, 'name': 'Wonder Woman'},<br/>    {'id': 14, 'name': 'Hulk'},<br/>    {'id': 15, 'name': 'Black Widow'},<br/>  ];</span><span id="8c4b" class="mt ld iq ni b gy of oa l ob oc">  @Operation.get()<br/>  Future&lt;Response&gt; getAllHeroes() async {<br/>    return Response.ok(_heroes);<br/>  }</span><span id="68ed" class="mt ld iq ni b gy of oa l ob oc">  @Operation.get('id')<br/>  Future&lt;Response&gt; getHeroByID() async {<br/>    final id = int.parse(request.path.variables['id']);<br/>    final hero = _heroes.firstWhere((hero) =&gt; hero['id'] == id, orElse: () =&gt; null);<br/>    if (hero == null) {<br/>      return Response.notFound();<br/>    }</span><span id="107e" class="mt ld iq ni b gy of oa l ob oc">    return Response.ok(hero);<br/>  }<br/>}</span></pre><p id="8690" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们不必覆盖<code class="fe nf ng nh ni b">ResourceController</code>中的<code class="fe nf ng nh ni b">handle</code>。一个<code class="fe nf ng nh ni b">ResourceController</code>实现这个方法来调用我们的一个<em class="lb">操作方法</em>。像<code class="fe nf ng nh ni b">getAllHeroes</code>和<code class="fe nf ng nh ni b">getHeroByID</code>这样的操作方法必须有一个<code class="fe nf ng nh ni b">Operation</code>注释。命名构造函数<code class="fe nf ng nh ni b">Operation.get</code>意味着当请求的方法是<code class="fe nf ng nh ni b">GET</code>时，这些方法被调用。操作方法也必须返回一个<code class="fe nf ng nh ni b">Future&lt;Response&gt;</code>。</p><p id="39ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nf ng nh ni b">getHeroByID</code>的注释也有一个参数——我们的路径变量<code class="fe nf ng nh ni b">:id</code>的名称。如果该路径变量存在于请求的路径中，将调用<code class="fe nf ng nh ni b">getHeroByID</code>。如果不存在，就会调用<code class="fe nf ng nh ni b">getAllHeroes</code>。</p><h2 id="3881" class="mt ld iq bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">请求绑定</h2><p id="8b8b" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">一个操作方法可以声明参数并将它们绑定到请求的属性上。当我们的操作方法被调用时，请求中的值将作为参数传递给它。请求绑定自动将值解析为参数的类型(如果解析失败，则返回更好的错误响应)。改变方法<code class="fe nf ng nh ni b">getHeroByID()</code>:</p><pre class="nk nl nm nn gt nv ni nw nx aw ny bi"><span id="1cb5" class="mt ld iq ni b gy nz oa l ob oc">@Operation.get('id')<br/>Future&lt;Response&gt; getHeroByID(@Bind.path('id') int id) async {<br/>  final hero = _heroes.firstWhere((hero) =&gt; hero['id'] == id, orElse: () =&gt; null);</span><span id="ee0c" class="mt ld iq ni b gy of oa l ob oc">  if (hero == null) {<br/>    return Response.notFound();<br/>  }</span><span id="33d7" class="mt ld iq ni b gy of oa l ob oc">  return Response.ok(hero);<br/>}</span></pre><p id="5ef9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜，我们已经创建了一个为虚构英雄服务的沟渠应用程序。到目前为止，我们都是将数组硬编码到代码中。我们接下来要做的是将英雄存储到数据库中并执行CRUD操作。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="9265" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读！欢迎在LinkedIn <a class="ae kc" href="https://www.linkedin.com/in/zubairehman/" rel="noopener ugc nofollow" target="_blank"> @zubairehman </a>或在下面的回复中打招呼或分享你的想法！</p><h1 id="4da4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">下一篇文章</h1><p id="75f9" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">故事还没有结束，在下一篇文章中，我们将学习如何使用PostgreSQL配置和执行CRUD操作，敬请关注:)</p><p id="022f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的其他部分:</p><ul class=""><li id="5b8d" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la oe ml mm mn bi translated"><a class="ae kc" href="https://medium.com/@zubairehman.work/part-1-a-complete-guide-for-building-restful-applications-using-aqueduct-668b07f62ad5" rel="noopener">第1部分:使用Aqueduct构建RESTful应用程序的完整指南(核心概念)</a></li><li id="4885" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la oe ml mm mn bi translated">第2部分:使用Aqueduct构建RESTful应用程序的完整指南(应用程序开发)</li><li id="28de" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la oe ml mm mn bi translated">第3部分:使用Aqueduct构建RESTful应用程序的完整指南(DB配置，即将推出)</li></ul><h1 id="4179" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">有用的资源</h1><p id="c179" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">【http://aqueduct.io/docs/ T4】</p><p id="d3ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lb">这篇文章到此为止，如果你喜欢这篇文章，别忘了拍手👏尽可能多的表达你的支持，留下你的评论并与你的朋友分享。</em>T9】</strong></p></div></div>    
</body>
</html>