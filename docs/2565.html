<html>
<head>
<title>Writing Maintainable PowerShell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写可维护的PowerShell</h1>
<blockquote>原文：<a href="https://itnext.io/writing-maintainable-powershell-503e5b680ed9?source=collection_archive---------0-----------------------#2019-06-16">https://itnext.io/writing-maintainable-powershell-503e5b680ed9?source=collection_archive---------0-----------------------#2019-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7f93" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">应用流行的模式使我们的代码更易维护</h2></div><p id="7a2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">第五部分</em> <a class="ae lf" href="https://medium.com/@cjkuech/declarative-devops-microframeworks-9908c8d05332" rel="noopener"> <em class="le">声明性DevOps微框架</em> </a></p><p id="cd04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">PowerShell比大多数语言更难在大型代码库中管理。虽然REST APIs和应用程序有你可以遵循的标准设计模式，但这并不一定适用于DevOps代码库。因此，许多代码库在面向用户的界面和内部逻辑之间缺乏强有力的分离，从而变得难以阅读和维护。我们可以利用其他语言中的一些常见模式与PowerShell一起工作，以保持大型PowerShell代码库的可维护性。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/6acd269cc27ae06aa7f5642d536d540c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6H48s1Qxy2Inw_mLfmmOw.jpeg"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">大事情最容易分成小部分来处理(照片由Raphael Koh在Unsplash上拍摄)</figcaption></figure><h1 id="cf2a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">手动音量调节</h1><p id="1d04" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated"><a class="ae lf" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> MVC </a>对于大型面向用户的应用程序来说是一种非常常见的软件工程模式，无论它们是<a class="ae lf" href="https://dotnet.microsoft.com/apps/aspnet/mvc" rel="noopener ugc nofollow" target="_blank">ASP.NET网站</a>还是iOS应用程序。MVC通过将应用程序代码划分为模型、视图和控制器，将表示逻辑与业务逻辑完全分离。就像图形用户界面一样，命令行界面也可以从这种分离中受益。</p><h2 id="154c" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">模型</h2><p id="412d" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">模型是表示应用程序核心结构的模式化数据对象。它们可以用于存储业务逻辑的状态，或者包含与模型直接相关的业务逻辑。它永远不能包含表示逻辑，除了一个<code class="fe nf ng nh ni b">ToString()</code>方法。</p><p id="dde1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在PowerShell中，我们通常将模型定义为类。<a class="ae lf" href="https://medium.com/@cjkuech/new-to-powershell-use-classes-ab7b1e6f72ec" rel="noopener">类可以让你的代码更加直观</a>并且让开发者能够<a class="ae lf" href="https://medium.com/@cjkuech/functional-powershell-with-classes-820c8e9acd8f" rel="noopener">更好的对与他们的模型直接相关的代码进行分组</a>。它们还支持<a class="ae lf" href="https://medium.com/@cjkuech/defensive-powershell-with-validation-attributes-8e7303e179fd" rel="noopener">验证属性</a>，帮助你最小化代码。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="2b90" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">视图</h2><p id="6dd1" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">视图只包含与向最终用户展示模型相关的代码。在GUI中，视图可以是按钮、页面、文本编辑器或任何其他面向用户的UI元素。视图只能接收和显示模型，或者调用控制器——它们不能直接更新模型。</p><p id="71fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在PowerShell中，视图是Cmdlets。Cmdlets允许开发人员以声明方式<a class="ae lf" href="https://medium.com/@cjkuech/defensive-powershell-with-validation-attributes-8e7303e179fd" rel="noopener">为他们的功能</a>定义<a class="ae lf" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods" rel="noopener ugc nofollow" target="_blank">富于表现力的面向用户的命令行界面</a>，并通过将<code class="fe nf ng nh ni b">[CmdletBinding()]</code>属性应用到他们的<code class="fe nf ng nh ni b">Param</code>块来添加对类似于<code class="fe nf ng nh ni b">-ErrorAction</code>参数的特性的支持。视图是从我们的模块中导出的唯一cmdlets。</p><p id="6e58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两类视图cmdlets</p><ul class=""><li id="c746" class="nl nm it kk b kl km ko kp kr nn kv no kz np ld nq nr ns nt bi translated"><strong class="kk iu">数据视图</strong>—数据视图输出模型。不能从PowerShell中的模块干净地导出类，所以我们需要使用数据视图函数来抽象任何类构造函数或静态类方法调用。数据视图应该干净地与管道集成，如果可能的话，遵循<a class="ae lf" href="https://medium.com/@cjkuech/functional-programming-in-powershell-876edde1aadb" rel="noopener">功能范例</a>，并且在运行时不会对执行产生副作用。在下面的例子中，<code class="fe nf ng nh ni b">Test-Node</code>是一个数据视图。</li><li id="ec6d" class="nl nm it kk b kl nu ko nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><strong class="kk iu">用户视图</strong> —用户视图不是输出值，而是向用户提供用户友好的格式化输出，例如使用<code class="fe nf ng nh ni b">Format-Table</code>或<code class="fe nf ng nh ni b">Write-Host</code>。尽管<code class="fe nf ng nh ni b">Write-Host</code>通常被PSScriptAnalyzer禁止，但是<code class="fe nf ng nh ni b">Write-Host</code>在用户视图中使用是可以接受的，因为用户视图应该只由用户直接运行。任何与用户的交互，例如与<code class="fe nf ng nh ni b">Read-Host</code>的交互，必须包含在用户视图中，以及任何进度指示器或其他UI元素中。在下面的例子中，<code class="fe nf ng nh ni b">Start-Troubleshooter</code>是一个用户视图。</li></ul><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="d671" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">控制器</h2><p id="c607" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">为了确保表示逻辑和业务逻辑完全分离，视图永远不能修改模型，只能与控制器交互。控制器是模型和视图之间的粘合剂。</p><p id="a348" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">视图很难进行单元测试，因为它们是为人类而不是计算机优化的，并且有许多可能的参数组合。如果我们干净地将业务逻辑分成具有更简单接口的控制器和模型，我们可以向控制器和模型添加单元测试，同时主要依靠声明性验证属性来最小化视图代码中的错误。我们还可以通过将输入验证合并到视图中，并设计我们的控制器来假设来自视图的有效输入，从而简化我们的控制器和模型代码。</p><p id="7632" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在PowerShell中，控制器被优化定义为函数。为了区分视图函数和控制器函数，使用param list(<code class="fe nf ng nh ni b">function MyFunc([int]$x, [string]$y) {</code>)而不是<code class="fe nf ng nh ni b">Param</code>块来定义控制器函数，并使用PascalCase或camelCase来区分控制器和动词名词命名的视图。控制器的简化界面将迫使你防御性地编程<a class="ae lf" href="https://medium.com/@cjkuech/defensive-powershell-with-validation-attributes-8e7303e179fd" rel="noopener"/>，并在你的视图中尽早验证输入。参数列表也将迫使你保持控制器接口尽可能简单，以最小化你的控制器测试覆盖所需的单元测试用例的数量。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="ca3b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">模块</h1><p id="675c" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">模块是组织代码的一种方式。模块被一次导入到你的会话中(除非你使用<code class="fe nf ng nh ni b">-Force</code>)，所以你可以避免由于重新声明代码而损失的执行时间。模块还允许您在模块范围的变量中存储状态。因此，模块相当于纯面向对象语言(如C#和Java)中用于管理代码的静态类。<a class="ae lf" href="https://medium.com/@cjkuech/private-powershell-modules-76f51a1bf893" rel="noopener">将PowerShell放入私有模块</a>将迫使你将代码分解成更易管理的部分，这也可以推动你将代码抽象成<a class="ae lf" href="https://medium.com/@cjkuech/declarative-devops-microframeworks-9908c8d05332" rel="noopener">微框架</a>，并确保你的代码具有定义良好的接口。因此，模块有一些坚实的优势—</p><h2 id="7c7b" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">可试验的</h2><p id="3990" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">模块具有定义良好的导出cmdlets接口。接口可以很容易地用Pester测试来维护和验证。相比之下，没有模块实现的等效代码不会保持严格的接口，并且将不可避免地开始与代码库的其余部分纠缠在一起，由于运行该函数所需的难以再现的状态，以及由于运行该函数而导致的难以验证的副作用，使得测试变得困难。</p><h2 id="523c" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">轻便的</h2><p id="744f" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">模块与你的代码库的其余部分相隔离，确保关注点的分离。因此，它们可以被<a class="ae lf" href="https://medium.com/@cjkuech/private-powershell-modules-76f51a1bf893" rel="noopener">便携地复制并在系统的其他地方</a>使用。随着代码库的发展，模块也可以被干净地替换——模块迫使您为您单独关心的代码创建一个定义良好的接口，因此如果您需要删除它，您完全知道如何替换它。</p><h2 id="cbf9" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">比脚本更好</h2><p id="b007" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">模块还支持按名称导入，因此可以避免硬编码相对路径:<code class="fe nf ng nh ni b">Import-Module MyModule</code>。相反，必须用<code class="fe nf ng nh ni b">&amp;"$PSScriptRoot\path\to\MyScript.ps1"</code>调用脚本，将脚本耦合到它的相对路径。</p><p id="5c87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接受用户输入的脚本必须使用<code class="fe nf ng nh ni b">Param</code>块作为脚本中的第一个代码，禁止声明<code class="fe nf ng nh ni b">enum</code>或其他可能简化脚本参数的类型。如果运行多次，它们的效率也很低，因为每次运行脚本时，都必须重新定义内部定义的任何帮助函数或其他常量值。人们可能会尝试将下面的代码实现为一个单独的<code class="fe nf ng nh ni b">Get-BadNode</code>脚本，但是<code class="fe nf ng nh ni b">$someDynamicSetting</code>和<code class="fe nf ng nh ni b">myHelperFunction</code>会在每次调用时被初始化，这不必要地损害了性能；此外，<code class="fe nf ng nh ni b">Get-BadNode</code>的脚本实现不支持使用<code class="fe nf ng nh ni b">enum</code>来帮助完成<code class="fe nf ng nh ni b">-Values</code>参数的值。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="1a83" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">后续步骤</h1><p id="a7f5" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">开始将这些概念应用到您自己的代码库中—</p><ul class=""><li id="46e1" class="nl nm it kk b kl km ko kp kr nn kv no kz np ld nq nr ns nt bi translated">将您的大型脚本分解成业务逻辑和表示逻辑。</li><li id="8044" class="nl nm it kk b kl nu ko nv kr nw kv nx kz ny ld nq nr ns nt bi translated">将您的脚本分组分解成具有良好定义的接口的模块。对这些接口进行单元测试。</li><li id="0ee6" class="nl nm it kk b kl nu ko nv kr nw kv nx kz ny ld nq nr ns nt bi translated">识别代码中难以测试或经常需要手动测试的区域，将难以测试的接口从核心中分离出来，并围绕核心添加单元测试。</li><li id="84b0" class="nl nm it kk b kl nu ko nv kr nw kv nx kz ny ld nq nr ns nt bi translated">考虑如何使您的演示视图cmdlets更加用户友好。</li><li id="9d2e" class="nl nm it kk b kl nu ko nv kr nw kv nx kz ny ld nq nr ns nt bi translated">开始将你的代码模块化成<a class="ae lf" href="https://medium.com/@cjkuech/declarative-devops-microframeworks-9908c8d05332" rel="noopener">声明性DevOps微框架</a>。</li></ul></div></div>    
</body>
</html>