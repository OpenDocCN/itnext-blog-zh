<html>
<head>
<title>How to Handle Async Actions for Global State With React Hooks and Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React挂钩和上下文处理全局状态的异步操作</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-handle-async-actions-for-global-state-with-react-hooks-and-context-72d88c2e8323?source=collection_archive---------4-----------------------#2019-12-20">https://itnext.io/how-to-handle-async-actions-for-global-state-with-react-hooks-and-context-72d88c2e8323?source=collection_archive---------4-----------------------#2019-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6be8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用React跟踪</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0be81e8f55ffa4487a4f07a8ba85fb3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GWn7Sa0rtC52xg8n.png"/></div></div></figure><h1 id="96e7" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="389b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我一直在开发React Tracked，这是一个带有React钩子和上下文的全局状态库。</p><p id="838d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae mn" href="https://react-tracked.js.org/" rel="noopener ugc nofollow" target="_blank">https://react-tracked.js.org</a></p><p id="27fa" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是一个小图书馆，只专注于一件事。它使用状态使用跟踪来优化重新渲染。从技术上来说，它使用代理来检测渲染中的使用情况，并且只在必要时触发重新渲染。</p><p id="8376" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">因此，React Tracked的用法非常简单。这就像正常的使用环境。这里有一个例子。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="6cef" class="mt kv it mp b gy mu mv l mw mx">const Counter = () =&gt; {<br/>  const [state, setState] = useTracked();<br/>  // The above line is almost like the following.<br/>  // const [state, setState] = useContext(Context);<br/>  const increment = () =&gt; {<br/>    setState(prev =&gt; ({ ...prev, count: prev.count + 1 }));<br/>  };<br/>  return (<br/>    &lt;div&gt;<br/>      {state.count}<br/>      &lt;button onClick={increment}&gt;+1&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="ef22" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">具体例子请查看<a class="ae mn" href="https://react-tracked.js.org/" rel="noopener ugc nofollow" target="_blank">文档</a>中的“入门”。</p><p id="24c6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，因为React Tracked是React挂钩和上下文的包装器，所以它本身不支持异步操作。这篇文章展示了一些如何处理异步动作的例子。它是为React Tracked编写的，但它可以在没有React Tracked的情况下使用。</p><p id="6790" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们使用的例子是一个简单的从服务器获取数据的例子。第一种模式没有任何库，使用定制的钩子。剩下的是用三个库，其中一个是我自己的。</p><h1 id="b89a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">不带库的自定义挂钩</h1><p id="07ca" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们来看一个本地解决方案。我们首先定义一个商店。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="f46c" class="mt kv it mp b gy mu mv l mw mx">import { createContainer } from 'react-tracked';</span><span id="da3a" class="mt kv it mp b gy my mv l mw mx">const useValue = () =&gt; useState({ loading: false, data: null });<br/>const { Provider, useTracked } = createContainer(useValue);</span></pre><p id="e33c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是在React Tracked中创建存储(容器)的模式之一。请查看其他图案的<a class="ae mn" href="https://react-tracked.js.org/docs/recipes#recipes-for-createcontainer" rel="noopener ugc nofollow" target="_blank">配方</a>。</p><p id="85b5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们创建一个自定义挂钩。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="47a0" class="mt kv it mp b gy mu mv l mw mx">const useData = () =&gt; {<br/>  const [state, setState] = useTracked();<br/>  const actions = {<br/>    fetch: async (id) =&gt; {<br/>      setState(prev =&gt; ({ ...prev, loading: true }));<br/>      const response = await fetch(`<a class="ae mn" href="https://reqres.in/api/users/" rel="noopener ugc nofollow" target="_blank">https://reqres.in/api/users/</a>${id}?delay=1`);<br/>      const data = await response.json();<br/>      setState(prev =&gt; ({ ...prev, loading: false, data }));<br/>    },<br/>  };<br/>  return [state, actions];<br/>};</span></pre><p id="ce20" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是一个基于useTracked的新钩子，它返回状态和动作。您可以调用<code class="fe mz na nb mp b">action.fetch(1)</code>开始获取。</p><p id="bcd3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意:如果需要稳定的异步函数，可以考虑用useCallback包装。</p><p id="f2e1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">React Tracked实际上接受一个自定义钩子，所以这个自定义钩子可以嵌入到容器中。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="997c" class="mt kv it mp b gy mu mv l mw mx">import { createContainer } from 'react-tracked';</span><span id="21ce" class="mt kv it mp b gy my mv l mw mx">const useValue = () =&gt; {<br/>  const [state, setState] = useState({ loading: false, data: null });<br/>  const actions = {<br/>    fetch: async (id) =&gt; {<br/>      setState(prev =&gt; ({ ...prev, loading: true }));<br/>      const response = await fetch(`<a class="ae mn" href="https://reqres.in/api/users/" rel="noopener ugc nofollow" target="_blank">https://reqres.in/api/users/</a>${id}?delay=1`);<br/>      const data = await response.json();<br/>      setState(prev =&gt; ({ ...prev, loading: false, data }));<br/>    },<br/>  };<br/>  return [state, actions];<br/>};</span><span id="6b81" class="mt kv it mp b gy my mv l mw mx">const { Provider, useTracked } = createContainer(useValue);</span></pre><p id="ee0f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">尝试工作示例。</p><p id="7341" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae mn" href="https://codesandbox.io/s/hungry-nightingale-qjeis" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/hungry-nightingale-qjeis</a></p><h1 id="6f21" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用useThunkReducer</h1><p id="79db" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><a class="ae mn" href="https://github.com/nathanbuchar/react-hook-thunk-reducer" rel="noopener ugc nofollow" target="_blank">react-hooks-thunk-reducer</a>提供自定义钩子<code class="fe mz na nb mp b">useThunkReducer</code>。这个钩子返回接受thunk函数的<code class="fe mz na nb mp b">dispatch</code>。</p><p id="324c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">同样的例子可以这样实现。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="0100" class="mt kv it mp b gy mu mv l mw mx">import { createContainer } from 'react-tracked';<br/>import useThunkReducer from 'react-hook-thunk-reducer';</span><span id="9e5b" class="mt kv it mp b gy my mv l mw mx">const initialState = { loading: false, data: null };<br/>const reducer = (state, action) =&gt; {<br/>  if (action.type === 'FETCH_STARTED') {<br/>    return { ...state, loading: true };<br/>  } else if (action.type === 'FETCH_FINISHED') {<br/>    return { ...state, loading: false, data: action.data };<br/>  } else {<br/>    return state;<br/>  }<br/>};</span><span id="4a93" class="mt kv it mp b gy my mv l mw mx">const useValue = () =&gt; useThunkReducer(reducer, initialState);<br/>const { Provider, useTracked } = createContainer(useValue);</span></pre><p id="fbff" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">调用异步操作就像这样。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="6dbf" class="mt kv it mp b gy mu mv l mw mx">const fetchData = id =&gt; async (dispatch, getState) =&gt; {<br/>  dispatch({ type: 'FETCH_STARTED' });<br/>  const response = await fetch(`<a class="ae mn" href="https://reqres.in/api/users/" rel="noopener ugc nofollow" target="_blank">https://reqres.in/api/users/</a>${id}?delay=1`);<br/>  const data = await response.json();<br/>  dispatch({ type: 'FETCH_FINISHED', data });<br/>};</span><span id="01ae" class="mt kv it mp b gy my mv l mw mx">dispatch(fetchData(1));</span></pre><p id="6166" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于redux-thunk用户来说应该很熟悉。</p><p id="3a20" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">尝试工作示例。</p><p id="4b58" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae mn" href="https://codesandbox.io/s/crimson-currying-og54c" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/crimson-currying-og54c</a></p><h1 id="bb0d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用减速器</h1><p id="38ec" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><a class="ae mn" href="https://github.com/azmenak/use-saga-reducer" rel="noopener ugc nofollow" target="_blank">使用-saga-reducer </a>提供自定义挂钩<code class="fe mz na nb mp b">useSagaReducer</code>。因为这个库使用了<a class="ae mn" href="https://redux-saga.js.org/docs/api/index.html#external-api" rel="noopener ugc nofollow" target="_blank">外部API </a>，所以可以不用redux就使用redux-saga。</p><p id="d9f7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们用Sagas再次实现同样的例子。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="2fa6" class="mt kv it mp b gy mu mv l mw mx">import { createContainer } from 'react-tracked';<br/>import { call, put, takeLatest } from 'redux-saga/effects';<br/>import useSagaReducer from 'use-saga-reducer';</span><span id="650b" class="mt kv it mp b gy my mv l mw mx">const initialState = { loading: false, data: null };<br/>const reducer = (state, action) =&gt; {<br/>  if (action.type === 'FETCH_STARTED') {<br/>    return { ...state, loading: true };<br/>  } else if (action.type === 'FETCH_FINISHED') {<br/>    return { ...state, loading: false, data: action.data };<br/>  } else {<br/>    return state;<br/>  }<br/>};</span><span id="3f16" class="mt kv it mp b gy my mv l mw mx">function* fetcher(action) {<br/>  yield put({ type: 'FETCH_STARTED' });<br/>  const response = yield call(() =&gt; fetch(`<a class="ae mn" href="https://reqres.in/api/users/" rel="noopener ugc nofollow" target="_blank">https://reqres.in/api/users/</a>${action.id}?delay=1`));<br/>  const data = yield call(() =&gt; response.json());<br/>  yield put({ type: 'FETCH_FINISHED', data });<br/>};</span><span id="bb5f" class="mt kv it mp b gy my mv l mw mx">function* fetchingSaga() {<br/>  yield takeLatest('FETCH_DATA', fetcher);<br/>}</span><span id="24db" class="mt kv it mp b gy my mv l mw mx">const useValue = () =&gt; useSagaReducer(fetchingSaga, reducer, initialState);<br/>const { Provider, useTracked } = createContainer(useValue);</span></pre><p id="f087" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">调用它很简单。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="e66a" class="mt kv it mp b gy mu mv l mw mx">dispatch({ type: 'FETCH_DATA', id: 1 });</span></pre><p id="facb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意相似和不同之处。如果你不熟悉生成器函数，它可能看起来很奇怪。</p><p id="8696" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">无论如何，尝试工作的例子。</p><p id="b37a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae mn" href="https://codesandbox.io/s/fancy-silence-1pukj" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/fancy-silence-1pukj</a></p><p id="be3d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">(不幸的是，截至发稿时，这个沙盒还不能在线使用。请“导出到ZIP”并在本地运行。)</p><h1 id="9de2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">useReducerAsync</h1><p id="e16e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><a class="ae mn" href="https://github.com/dai-shi/use-reducer-async" rel="noopener ugc nofollow" target="_blank"> use-reducer-async </a>提供自定义钩子<code class="fe mz na nb mp b">useReducerAsync</code>。这是我开发的库，灵感来自<code class="fe mz na nb mp b">useSagaReducer</code>。它不具备生成器函数所能做到的功能，但是它可以与任何异步函数一起工作。</p><p id="5cbe" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是这个钩子的同一个例子。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="f859" class="mt kv it mp b gy mu mv l mw mx">import { createContainer } from 'react-tracked';<br/>import { useReducerAsync } from 'use-reducer-async';</span><span id="f28b" class="mt kv it mp b gy my mv l mw mx">const initialState = { loading: false, data: null };<br/>const reducer = (state, action) =&gt; {<br/>  if (action.type === 'FETCH_STARTED') {<br/>    return { ...state, loading: true };<br/>  } else if (action.type === 'FETCH_FINISHED') {<br/>    return { ...state, loading: false, data: action.data };<br/>  } else {<br/>    return state;<br/>  }<br/>};</span><span id="5e1f" class="mt kv it mp b gy my mv l mw mx">const asyncActionHandlers = {<br/>  FETCH_DATA: (dispatch, getState) =&gt; async (action) =&gt; {<br/>    dispatch({ type: 'FETCH_STARTED' });<br/>    const response = await fetch(`<a class="ae mn" href="https://reqres.in/api/users/" rel="noopener ugc nofollow" target="_blank">https://reqres.in/api/users/</a>${action.id}?delay=1`);<br/>    const data = await response.json();<br/>    dispatch({ type: 'FETCH_FINISHED', data });<br/>  },<br/>};</span><span id="3a1f" class="mt kv it mp b gy my mv l mw mx">const useValue = () =&gt; useReducerAsync(reducer, initialState, asyncActionHandlers);<br/>const { Provider, useTracked } = createContainer(useValue);</span></pre><p id="a8f0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您可以用同样的方式调用它。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="f871" class="mt kv it mp b gy mu mv l mw mx">dispatch({ type: 'FETCH_DATA', id: 1 });</span></pre><p id="013e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">模式类似于useSagaReducer，但语法类似于useThunkReducer或本机解决方案。</p><p id="5a6e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">尝试工作示例。</p><p id="24d5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae mn" href="https://codesandbox.io/s/bitter-frost-4lxck" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/bitter-frost-4lxck</a></p><h1 id="7fd1" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">比较</h1><p id="05c1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">虽然可能有失偏颇，但以下是我的建议。如果您喜欢没有库的解决方案，请使用本机解决方案。如果你是saga用户，毫无疑问使用useSagaReducer。如果你喜欢redux-thunk，使用redux-thunk reducer会很好。否则，请考虑useReducerAsync或本机解决方案。</p><p id="5e4d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于TypeScript用户，我的建议是useSagaReducer和useReducerAsync。原生解决方案应该也可以。请查看React Tracked中的完整类型示例。</p><ul class=""><li id="f403" class="nc nd it lo b lp mi ls mj lv ne lz nf md ng mh nh ni nj nk bi translated"><a class="ae mn" href="https://github.com/dai-shi/react-tracked/tree/master/examples/12_async" rel="noopener ugc nofollow" target="_blank">https://github . com/Dai-Shi/react-tracked/tree/master/examples/12 _ async</a></li><li id="41de" class="nc nd it lo b lp nl ls nm lv nn lz no md np mh nh ni nj nk bi translated"><a class="ae mn" href="https://github.com/dai-shi/react-tracked/tree/master/examples/13_saga" rel="noopener ugc nofollow" target="_blank">https://github . com/Dai-Shi/react-tracked/tree/master/examples/13 _ saga</a></li></ul><h1 id="35d4" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结束语</h1><p id="7844" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">老实说，我认为原生解决方案对于小应用来说很好。所以，我没有动力去创建一个图书馆。然而，在为React Tracked编写教程的过程中，我注意到用库来限制模式更容易解释。use-reducer-async是一个很小的库，没有什么特别的。但是，它显示了一个模式。</p><p id="7a22" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">关于异步操作的另一个注意事项是数据获取的暂停。目前在实验频道。新推荐的数据获取方式是取即渲染模式。这与这篇文章中描述的模式完全不同。我们将会看到它如何发展。最有可能的是，这种新模式需要一个库来方便开发人员遵循这种模式。有兴趣的话可以看看我的<a class="ae mn" href="https://github.com/dai-shi/react-hooks-fetch" rel="noopener ugc nofollow" target="_blank">实验项目</a>。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="9e48" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="nx">原载于2019年12月20日</em><a class="ae mn" href="https://blog.axlight.com/posts/how-to-handle-async-actions-for-global-state-with-react-hooks-and-context/" rel="noopener ugc nofollow" target="_blank"><em class="nx">【https://blog.axlight.com</em></a><em class="nx">。</em></p></div></div>    
</body>
</html>