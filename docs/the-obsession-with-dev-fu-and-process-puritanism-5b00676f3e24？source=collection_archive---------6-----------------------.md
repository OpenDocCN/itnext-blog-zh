# 对 Dev-Fu 和过程清教主义的痴迷

> 原文：<https://itnext.io/the-obsession-with-dev-fu-and-process-puritanism-5b00676f3e24?source=collection_archive---------6----------------------->

我最近意识到的一件事是，作为一个职业，我们陷入了关注我们如何做我们的工作的陷阱，而不是我们实际生产的东西。它让人想起功夫及其对美学、传统和纯粹的强调。当我们想强调一个人在某方面的技能时，我们甚至有时会加上后缀“福”。例如 Google-Fu 或 Git-Fu。

然而，正如从 MMA 学到的，风格和纯粹不会产生结果。实用主义有。

> “…第一届 ufc 向所有人开放，他们非常注重风格与风格的对比…
> 
> *…在短暂的几次 ufc 之后，一种模式出现了。抓钩手拥有罢工者，他们大多是传统主义者和纯粹主义者，对抓钩一无所知。这对传统主义者来说很尴尬。巴西柔术从默默无闻中脱颖而出，成为最知名和最受尊敬的风格，为人们准备 MMA 战斗。空手道、功夫和其他传统艺术开始被视为低人一等。”*
> 
> [-功夫和尚 vs UFC 格斗家|功夫 vs MMA](https://www.youtube.com/watch?v=MljHo7hLhGw)

这导致大多数新拳手不再只练空手道、功夫或类似的拳术，而是专注于更加务实和“贴身”的巴西柔术。从那以后，它进一步发展了。但基本的一点，也就是重新学到的，李小龙很久以前就说得很好了。

![](img/26a6eda95b2178c6d0ffab0e7b626e71.png)

因此，当研究(MMA =战斗的结果)表明，结合不同的战斗风格，适合你独特的情况和技能，是成功的先决条件，那么你应该吸收它。拒绝无用的东西。这不是让你成功的神奇秘方，但是不遵循它基本上意味着无法获得成功。

在过去的 20 年里，类似的版本在软件开发行业也出现过，尽管没有那么暴力。我们已经看到了它与敏捷的斗争(引用 b .巴金斯的话，“去而复返”)。我们现在有希望看到新转变的萌芽。或者实际上我们早就应该看到这样的转变。但是还没有…

几年来,《DevOps 状态》已经出版，研究结果已经被反复确认，我们现在实际上已经有了一个非常坚实的基础来了解到底是什么驱动了软件交付性能。

业内许多知名人士都认同这些发现。但是软件开发人员和组织似乎很难接受这些发现和结论并采取相应的行动。

在许多方面，在许多领域，我们实际上一直在以与数据告诉我们的相反的方式工作。

尽管它被称为计算机科学或软件工程，但我们更多的是凭直觉来使用计算机和软件。

我们做自己觉得应该做的事情，模仿完全不同的地方的流程，而且我们通常不擅长让数据来指导我们的决策。

我试图深入研究不同学科的可用数据和研究，并试图将其与我自己的经历联系起来。我选择了几个我最讨厌和最感兴趣的问题，并将深入探讨这些问题。

# 第一个深层原因:缺乏对基于主干的开发和非阻塞工作流的采用

我们不妨从最让人热血沸腾的一个开始。尽管我们的职业不像 MMA 那样暴力，但它与攻击性和愤怒有关。

在“[《devo PS 手册》](https://www.amazon.com/DevOps-Handbook-World-Class-Reliability-Organizations-ebook/dp/B01M9ASFQ3)*”*中 Jez 谦逊的写道:

> "基于主干的开发可能是本书中讨论的最有争议的实践."

然后继续描述基于主干的开发(TBD)所带来的好处。

在 2016 年 DevOps 报告中，您可以阅读:

> “我们发现，在被合并到主干之前具有非常短的生命周期(不到一天)的分支或分叉，以及总共少于三个活动分支，是连续交付的重要方面，并且都有助于更高的性能。每天将代码合并到主干或主数据库中也是如此。”

在后来的工作中，这一发现得到了反复验证，案件比以往任何时候都更加有力。似乎没有什么歧义。

> ***基于主干的开发(TBD)和持续集成提高了软件交付性能。***

![](img/23e5ecb87bba18c8731df5c5f6d6d8e2.png)

第 31 页，来自 DevOps 2019 加速状态

这不仅仅是一个积极的影响，这是对监控、部署自动化和代码可维护性的影响。

除非分支保持在最低限度并且非常短暂，否则软件交付性能的一些改进仍然是无法实现的。

先说清楚。DevOps 状态中显示的交付性能改进并不小…它们是两位数的改进乘数。

根据经验，您拥有的分支越多，它们存在的时间越长，这些软件交付性能的改进就越难以实现。最有可能的是，软件交付性能实际上受到了阻碍。

尽管如此，我还是一次又一次地看到人们查看“完整”特性分支、Git-flow 等等。与作为行业中事实上的标准的拉请求相结合。挑战它会让人觉得你是个异教徒、十足的白痴或者根本不是专业开发人员。

我对 TBD(及相关)的看法是基于 10 多年与 TBD、特性分支、版本分支以及这些分支的混合工作的经验。我曾在几个不同领域和不同类型的组织、应用程序和系统中工作过。但主要是在全栈应用和系统开发中。

我也进行了大量的讨论和阅读，试图理解利弊，人们讨厌和喜欢什么，以及为什么功能分支和拉请求如此诱人。以及为什么人们选择这个过程，尽管数据向我们展示了什么。我读过更多关于这个话题的令人讨厌的讨论，我认为这对大多数人来说是不健康的。

鉴于我的背景，下面的文章主要关注使用 Git 或类似 VCS 的软件开发。有些观点适用范围更广，但是如果这是您正在使用的软件类型，那么这些文章是最相关的。围绕实际代码变动和反馈周期的过程不在这些文章的范围之内。

为了透明起见，我可以透露我的首选开发设置是:

> 特性切换支持 Mono(/big)存储库中基于主干的开发，具有后期代码集成审查和向测试环境的持续交付。

一个更简短(更吸引人)的名字叫做**基于主干的非阻塞评审开发(TBD w. NBR)。**

## 两篇文章的故事

基本上有两种方法来传达为什么行为应该改变的信息。你可以充实更好的选择，以及为什么你认为它提供了更好的价值。或者你可以探究为什么当前的行为是有问题的，或者提供的价值更少，因此应该改变。

由于有点贪心，我选择了这两种方法，将我对这个主题的看法分成了两篇不同的文章。

第一篇聚焦于 TBD·w·NBR，试图具体说明其方式和原因。基本原理和价值。

第二篇文章集中在为什么我认为特性分支、拉请求和聚合库会有问题并影响性能。

这两篇文章的共同点是假设**我们想要在团队中培养什么**来提高软件交付性能，是我们**所知道的**工作的实践和文化。

*   工作的持续整合
*   无摩擦的工作流程
*   心理安全
*   了解价值链

也就是说，基本上是从 DevOps、Accelerate 和对高绩效团队的研究中得出的结论。

因此评价是否做某事，应该根据对上述目标的影响来评价。

注意:我主要关注企业或其他组织的软件开发。即非开源贡献驱动/志愿者软件开发。

我希望你阅读这两篇文章中的一篇或两篇，因为它们旨在从不同的角度阐明这个问题。一篇突出了 TBD·w·NBR 的优点，另一篇突出了我所看到的与特征分支、拉取请求和 polyrepos 相关并由其引发的缺点。

我期待着一次愉快而富有建设性的讨论。

# 第一部分:NBR 的 TBD

你可以在这里阅读关于 TBD·w·NBR 的深度文章:

[优化软件开发流程，实现持续集成和工作流程](https://medium.com/@mortensensc/optimizing-the-software-development-for-continuous-integration-and-flow-of-work-56cf614b3f59)。

# 第 2 部分:特性分支的问题&拉请求

由于特性分支、拉请求和聚合库如何与上述目标相违背，我在本文中概述了各种问题:

[特性分支和拉请求如何与最佳实践相违背](https://medium.com/@mortensensc/how-feature-branches-and-pull-requests-work-against-best-practice-a13a85a016ef)。

# 下一次深潜

如果你对我下一次的深度潜水有什么建议，我会很感激。也许我会研究如何最好地确保所描述的设置(或任何实际设置)中的连续质量(CQ)。

它可以基于手动或自动测试、监控和许多其他事情。但是在我看来，批量大小和即时反馈的减少实际上比高自动化测试覆盖率更能驱动质量和价值交付。并且付出的努力和机会成本更低。这表明了一个有趣的、违反直觉的等式和结果。调查许多与自动化测试相关的假设和实际研究可能会带来一些惊喜。

感谢 Antonio、Ebbe、Jonas 和 Andreas 对本文的反馈和讨论:-)

有许多关于 TBD 的“观点”文章，我可以推荐看看。

[以后 GitHub 世界中的分支和切换为特色](https://www.youtube.com/watch?v=lqRQYEHAtpk)

[为什么不应该使用特征分支](https://fire.ci/blog/why-you-should-not-use-feature-branches/)

[为什么代码评审会伤害你的代码质量和团队生产力](https://simpleprogrammer.com/code-review-trunk-based-development/)

[持续集成和特性分支](http://www.davefarley.net/?p=247)和[基于主干开发的感知障碍](http://www.davefarley.net/?p=269)

[为什么我喜欢基于主干的开发](https://medium.com/@mattia.battiston/why-i-love-trunk-based-development-641fcf0b94a0)

[基于拉式请求的开发(sucks)](http://lisperator.net/blog/pull-request-based-development-sucks/)

[以及单一与多元回购](http://blog.shippable.com/our-journey-to-microservices-and-a-mono-repository)