<html>
<head>
<title>Error handling and validation architecture in .NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中的错误处理和验证架构。网络核心</h1>
<blockquote>原文：<a href="https://itnext.io/error-handling-and-validation-architecture-in-net-core-c628a108082c?source=collection_archive---------2-----------------------#2018-12-09">https://itnext.io/error-handling-and-validation-architecture-in-net-core-c628a108082c?source=collection_archive---------2-----------------------#2018-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6732" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在许多项目中，错误处理和验证以条件(“if-else”序列)的形式分布在业务逻辑、API控制器和数据访问层中。这导致违反了<a class="ae ko" href="https://deviq.com/separation-of-concerns/" rel="noopener ugc nofollow" target="_blank">关注点分离原则</a>，并产生了<a class="ae ko" href="https://en.wikipedia.org/wiki/Spaghetti_code" rel="noopener ugc nofollow" target="_blank">意大利面条代码</a>，如下例所示。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="dd08" class="ky kz it ku b gy la lb l lc ld">....<br/>    if (user != null)<br/>    {<br/>        if (subscription != null)<br/>        {<br/>            if (term == Term.Annually)<br/>            {<br/>                // code 1<br/>            }<br/>            else if (term == Term.Monthly)<br/>            {<br/>                // code 2<br/>            }<br/>            else<br/>            {<br/>                throw new InvalidArgumentException(nameof(term));<br/>            }<br/>        }<br/>        else<br/>        {<br/>            throw new ArgumentNullException(nameof(subscription));<br/>        }<br/>    }<br/>    else<br/>    {<br/>        throw new ArgumentNullException(nameof(user));<br/>    }<br/>.....</span></pre><p id="f3eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我描述了将验证和错误处理逻辑从其他应用层中分离出来的方法。下面使用的模式和实践可以在下面的Git Hub存储库中找到。</p><div class="le lf gp gr lg lh"><a href="https://github.com/Boriszn/DeviceManager.Api" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">Boris Zn/设备管理器。美国石油学会(American Petroleum Institute)</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">Web API解决方案展示了交互式架构，使用实体框架、统一工作、存储库模式…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv lw lh"/></div></div></a></div><h1 id="0949" class="lx kz it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">架构概述</h1><p id="3014" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">为了简单起见，我使用N-tire架构，但是，所解释的方法可以在CQRS、事件驱动、微服务、SOA等架构中重用。</p><p id="2626" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例架构包括以下层:</p><ul class=""><li id="abe2" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated">表示层—用户界面/应用编程接口</li><li id="fc9d" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">业务逻辑层——服务或域服务(如果您有DDD架构)</li><li id="0a9b" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">数据层/数据访问层</li></ul><p id="a214" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下图显示了属于不同层的组件和模块，右侧包含表示/API层、业务逻辑层、数据访问，左侧包含相关的验证和错误处理逻辑。</p><figure class="kp kq kr ks gt no gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nn"><img src="../Images/51921a03ca206f7ca5a8be8b382013ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZbQ2SaW7CUPHAMS83DAxgw.png"/></div></div></figure><p id="4623" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">验证和错误处理架构包含几个组件，我将在接下来的几个部分中描述它们。</p><h2 id="2dd9" class="ky kz it bd ly nu nv dn mc nw nx dp mg kb ny nz mk kf oa ob mo kj oc od ms oe bi translated">API验证级别</h2><p id="9652" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">API控制器可能包含许多验证，如参数检查、模型状态检查等，如下例所示。我将使用声明性编程将验证逻辑从API控制器中移出。</p><figure class="kp kq kr ks gt no"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8349" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过创建验证模型属性，可以很容易地清理API控制器。以下示例包含简单的模型验证检查。</p><figure class="kp kq kr ks gt no"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8b3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">把这个属性加到<em class="oh"> startup.cs </em>里就行了</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="4fc7" class="ky kz it ku b gy la lb l lc ld">services.AddMvc(options =&gt;<br/>{             <br/>   options.Filters.Add(typeof(ValidateModelStateAttribute));<br/>});</span></pre><p id="ef7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了验证API动作方法的参数，我将创建一个属性并移动验证逻辑。属性内部的逻辑检查参数是否包含验证属性并验证值。</p><p id="d510" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果需要，现在可以将属性添加到操作方法中。(下面的例子)</p><figure class="kp kq kr ks gt no"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b791" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在可以将属性添加到API方法中，如下例所示。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="80e5" class="ky kz it ku b gy la lb l lc ld">[HttpGet]                               [SwaggerOperation("GetDevices")]                               [<strong class="ku iu">ValidateActionParameters</strong>]<br/>public IActionResult Get(<br/>[FromQuery, <strong class="ku iu">Required</strong>]int page, <br/>[FromQuery, <strong class="ku iu">Required</strong>]int pageSize)                               <br/>{                                   <br/>  return new ObjectResult(deviceService.GetDevices(page, pageSize));                               }</span></pre><h2 id="5de6" class="ky kz it bd ly nu nv dn mc nw nx dp mg kb ny nz mk kf oa ob mo kj oc od ms oe bi translated">业务层验证</h2><p id="d4be" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">业务层验证由两部分组成:验证服务和验证规则。</p><p id="d574" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在设备验证服务中，我已经将所有自定义验证和基于规则的验证逻辑从服务中移出(以下示例中的设备服务)。这个想法很类似于使用<a class="ae ko" href="https://deviq.com/guard-clause/" rel="noopener ugc nofollow" target="_blank">守卫</a>的模式。下面是验证服务的例子。</p><figure class="kp kq kr ks gt no"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="cbdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在规则中，我已经移动了与视图或API模型相关的所有可能的验证检查。在下面的示例中，您可以看到设备视图模型验证规则。验证本身在验证服务内部触发。</p><p id="7267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于<a class="ae ko" href="https://github.com/JeremySkinner/FluentValidation" rel="noopener ugc nofollow" target="_blank"> FluentValidation </a>框架的验证规则允许您以fluent格式构建规则。</p><figure class="kp kq kr ks gt no"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="58a3" class="ky kz it bd ly nu nv dn mc nw nx dp mg kb ny nz mk kf oa ob mo kj oc od ms oe bi translated">异常处理中间件</h2><p id="2ddc" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">最后，我将介绍错误/异常处理。我将这个主题一直讲到最后，因为所有的验证组件都会生成异常，而处理这些异常并提供适当的JSON错误对象的集中式组件是必需的。</p><p id="a048" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的例子中，我使用了<a class="ae ko" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.1" rel="noopener ugc nofollow" target="_blank">。NET核心中间件</a>捕捉所有异常并创建HTTP错误状态，根据异常类型(在<em class="oh">ConfigurationExceptionType</em>方法中)并构建错误JSON对象。</p><p id="2d65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">中间件也可以用来在一个地方记录所有异常。</p><figure class="kp kq kr ks gt no"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="ad84" class="ky kz it bd ly nu nv dn mc nw nx dp mg kb ny nz mk kf oa ob mo kj oc od ms oe bi translated">结论</h2><p id="fd46" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">在本文中，我介绍了创建可维护验证架构的几种选择。本文的主要目标是清理业务、表示和数据访问逻辑。我不建议将这些方法视为“银弹”,因为它们有优点也有缺点。</p><p id="0e73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如:</p><ul class=""><li id="fcf8" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated"><em class="oh">中间件</em> —覆盖现有的响应流，这对于API来说是个好选择，但对于Web解决方案来说可能是个缺点。对于不同的解决方案类型，您可能需要两个中间件。</li></ul><h2 id="d600" class="ky kz it bd ly nu nv dn mc nw nx dp mg kb ny nz mk kf oa ob mo kj oc od ms oe bi translated">源代码</h2><p id="f645" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">所有示例都可以在现成的框架<a class="ae ko" href="https://github.com/Boriszn/DeviceManager.Api" rel="noopener ugc nofollow" target="_blank">中找到。</a></p></div></div>    
</body>
</html>