<html>
<head>
<title>Manage Redis on AWS from Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理Kubernetes上的Redis</h1>
<blockquote>原文：<a href="https://itnext.io/manage-redis-on-aws-from-kubernetes-eeadba7eb889?source=collection_archive---------2-----------------------#2022-09-18">https://itnext.io/manage-redis-on-aws-from-kubernetes-eeadba7eb889?source=collection_archive---------2-----------------------#2022-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c7b963474b04d6ac47e2170978017a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2plcuR0yNCkRbBNcLNpxoA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">使用ACK为EKS的Redis集群创建Amazon MemoryDB</figcaption></figure><div class=""/><div class=""><h2 id="46e9" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">使用<code class="fe ku kv kw kx b">AWS Controller for Kubernetes </code>和<code class="fe ku kv kw kx b">CDK for Kubernetes</code></h2></div><p id="2697" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇博文中，你将学习如何使用<code class="fe ku kv kw kx b">ACK</code>和<a class="ae lu" href="https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html" rel="noopener ugc nofollow" target="_blank">亚马逊EKS </a>在AWS上创建一个Redis集群(和<a class="ae lu" href="https://docs.aws.amazon.com/memorydb/latest/devguide/what-is-memorydb-for-redis.html" rel="noopener ugc nofollow" target="_blank">亚马逊MemoryDB </a>)。</p><p id="4554" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/community/overview/" rel="noopener ugc nofollow" target="_blank">Kubernetes的AWS控制器</a>(也称为<strong class="la jg"> ACK </strong>)利用<a class="ae lu" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#custom-resources" rel="noopener ugc nofollow" target="_blank"> Kubernetes自定义资源和自定义资源定义</a>，让您能够直接从Kubernetes管理和使用AWS服务，而无需在集群之外定义资源。它<a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/community/services/" rel="noopener ugc nofollow" target="_blank">支持多种AWS服务</a>，包括<code class="fe ku kv kw kx b">S3</code>、<code class="fe ku kv kw kx b">DynamoDB</code>、<code class="fe ku kv kw kx b">MemoryDB</code>等。</p><p id="01cc" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">通常情况下，您会使用YAML在ACK中定义自定义资源。但是，在这种情况下，我们将利用<a class="ae lu" href="https://cdk8s.io/docs/latest/" rel="noopener ugc nofollow" target="_blank">cdk8s</a>(Kubernetes的云开发工具包)，这是一个开源框架(CNCF的一部分)，允许您使用常规编程语言(而不是<code class="fe ku kv kw kx b">yaml</code>)定义您的Kubernetes应用程序。由于<code class="fe ku kv kw kx b">cdk8s</code>对<a class="ae lu" href="https://betterprogramming.pub/write-your-kubernetes-infrastructure-as-go-code-using-custom-resource-definitions-with-cdk8s-5d9500693e02" rel="noopener ugc nofollow" target="_blank"> Kubernetes自定义资源定义</a>的支持，我们将把<code class="fe ku kv kw kx b">MemoryDB</code><code class="fe ku kv kw kx b">ACK</code>CRD作为API导入，然后使用代码定义一个集群(为此我将使用<code class="fe ku kv kw kx b">Go</code>)。</p><p id="4754" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">还没完呢！除了基础设施之外，我们还将关注代表将与MemoryDB集群连接的应用程序的应用程序。为此，我们将使用<a class="ae lu" href="https://cdk8s.io/docs/latest/plus/" rel="noopener ugc nofollow" target="_blank"> cdk8s-plus库</a>来定义一个Kubernetes <code class="fe ku kv kw kx b">Deployment</code>(并使用<code class="fe ku kv kw kx b">Service</code>来公开它)，从而构建一个端到端的解决方案。在这个过程中，你会了解到<code class="fe ku kv kw kx b">ACK</code>的其他一些细微差别，比如<code class="fe ku kv kw kx b">FieldExport</code>等。</p><blockquote class="lv lw lx"><p id="3659" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><em class="jf">我围绕cdk8s和Go </em>  <em class="jf">写了一篇</em> <a class="ae lu" href="https://betterprogramming.pub/kubernetes-infrastructure-as-code-for-go-developers-cdk8s-plus-in-action-ee3eb2203745" rel="noopener ugc nofollow" target="_blank"> <em class="jf">的几篇博文，也许你会觉得有用</em></a></p></blockquote></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="2785" class="mj mk jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated">先决条件</h1><p id="04e3" class="pw-post-body-paragraph ky kz jf la b lb nb kg ld le nc kj lg lh nd lj lk ll ne ln lo lp nf lr ls lt ij bi translated">要一步一步地学习，除了AWS账户，你还需要安装<a class="ae lu" href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>、<a class="ae lu" href="https://cdk8s.io/docs/latest/getting-started/#install-the-cli" rel="noopener ugc nofollow" target="_blank"> cdk8s CLI </a>、<a class="ae lu" href="https://kubernetes.io/docs/tasks/tools/#kubectl" rel="noopener ugc nofollow" target="_blank"> kubectl </a>、<a class="ae lu" href="https://helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank"> helm </a>和<a class="ae lu" href="https://go.dev/dl/" rel="noopener ugc nofollow" target="_blank"> Go编程语言</a>。</p><p id="045b" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有很多种方法可以创建一个亚马逊EKS集群。我更喜欢使用eks CTL CLI，因为它提供了方便！</p><h1 id="5f96" class="mj mk jf bd ml mm ng mo mp mq nh ms mt kl ni km mv ko nj kp mx kr nk ks mz na bi translated">首先，设置MemoryDB控制器</h1><blockquote class="lv lw lx"><p id="d569" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><em class="jf">以下大部分步骤改编自</em> <code class="fe ku kv kw kx b"><em class="jf">ACK</em></code> <em class="jf">文档- </em> <a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/user-docs/install/" rel="noopener ugc nofollow" target="_blank"> <em class="jf">安装ACK控制器</em> </a></p></blockquote><p id="8a72" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg">使用</strong> <code class="fe ku kv kw kx b"><strong class="la jg">Helm</strong></code> <strong class="la jg"> : </strong>安装</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="912b" class="nt mk jf kx b gy nu nv l nw nx">export SERVICE=memorydb</span><span id="fc9f" class="nt mk jf kx b gy ny nv l nw nx">#change/update this as required <a class="ae lu" href="https://api.github.com/repos/aws-controllers-k8s/memorydb-controller/releases/latest" rel="noopener ugc nofollow" target="_blank">https://api.github.com/repos/aws-controllers-k8s/memorydb-controller/releases/latest</a><br/>export RELEASE_VERSION=0.0.2</span><span id="7748" class="nt mk jf kx b gy ny nv l nw nx">export ACK_SYSTEM_NAMESPACE=ack-system<br/><br/># you can change the region as required<br/>export AWS_REGION=us-east-1<br/><br/>aws ecr-public get-login-password --region us-east-1 | helm registry login --username AWS --password-stdin public.ecr.aws<br/><br/>helm install --create-namespace -n $ACK_SYSTEM_NAMESPACE ack-$SERVICE-controller \<br/>  oci://public.ecr.aws/aws-controllers-k8s/$SERVICE-chart --version=$RELEASE_VERSION --set=aws.region=$AWS_REGION</span></pre><p id="5829" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要确认，请运行:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="3390" class="nt mk jf kx b gy nu nv l nw nx">kubectl get crd</span><span id="c75e" class="nt mk jf kx b gy ny nv l nw nx"># output (multiple CRDs)<br/>NAME                                         CREATED AT<br/>acls.memorydb.services.k8s.aws               2022-08-13T19:15:46Z<br/>adoptedresources.services.k8s.aws            2022-08-13T19:15:53Z<br/>clusters.memorydb.services.k8s.aws           2022-08-13T19:15:47Z<br/>eniconfigs.crd.k8s.amazonaws.com             2022-08-13T19:02:10Z<br/>fieldexports.services.k8s.aws                2022-08-13T19:15:56Z<br/>parametergroups.memorydb.services.k8s.aws    2022-08-13T19:15:48Z<br/>securitygrouppolicies.vpcresources.k8s.aws   2022-08-13T19:02:12Z<br/>snapshots.memorydb.services.k8s.aws          2022-08-13T19:15:51Z<br/>subnetgroups.memorydb.services.k8s.aws       2022-08-13T19:15:52Z<br/>users.memorydb.services.k8s.aws              2022-08-13T19:15:53Z</span></pre><p id="eb7b" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">由于控制器必须与AWS服务交互(进行API调用)，我们需要为服务帐户(也称为<strong class="la jg"> IRSA </strong>)配置<a class="ae lu" href="https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html" rel="noopener ugc nofollow" target="_blank"> IAM角色。</a></p><blockquote class="lv lw lx"><p id="b9e9" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><em class="jf">详见</em> <a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/user-docs/irsa/" rel="noopener ugc nofollow" target="_blank"> <em class="jf">配置IAM权限</em></a><em class="jf"/></p></blockquote><p id="ddb2" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg"> IRSA配置</strong></p><p id="650a" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">首先，为您的群集创建一个OIDC身份提供者。</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="95f2" class="nt mk jf kx b gy nu nv l nw nx">export EKS_CLUSTER_NAME=&lt;name of your EKS cluster&gt;<br/>export AWS_REGION=&lt;cluster region&gt;</span><span id="fffd" class="nt mk jf kx b gy ny nv l nw nx">eksctl utils associate-iam-oidc-provider --cluster $EKS_CLUSTER_NAME --region $AWS_REGION --approve</span></pre><p id="7d1d" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">目标是创建一个IAM角色并通过策略附加适当的权限。然后，我们可以创建一个<a class="ae lu" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" rel="noopener ugc nofollow" target="_blank"> Kubernetes服务帐户</a>，并为其附加IAM角色。因此，控制器<code class="fe ku kv kw kx b">Pod</code>将能够进行AWS API调用。注意，我们通过<code class="fe ku kv kw kx b">arn:aws:iam::aws:policy/AmazonMemoryDBFullAccess</code>策略向我们的控件提供所有的<code class="fe ku kv kw kx b">DynamoDB</code>权限。</p><p id="2cdd" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">多亏了<code class="fe ku kv kw kx b">eksctl</code>，这一点只用一行就能做到！</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="638f" class="nt mk jf kx b gy nu nv l nw nx">export SERVICE=memorydb<br/>export ACK_K8S_SERVICE_ACCOUNT_NAME=ack-$SERVICE-controller</span><span id="dc0a" class="nt mk jf kx b gy ny nv l nw nx"># recommend using the same name<br/>export ACK_SYSTEM_NAMESPACE=ack-system<br/>export EKS_CLUSTER_NAME=&lt;enter EKS cluster name&gt;<br/>export POLICY_ARN=arn:aws:iam::aws:policy/AmazonMemoryDBFullAccess</span><span id="b41b" class="nt mk jf kx b gy ny nv l nw nx"># IAM role has a format - do not change it. you can't use any arbitrary name<br/>export IAM_ROLE_NAME=ack-$SERVICE-controller-role</span><span id="82ed" class="nt mk jf kx b gy ny nv l nw nx">eksctl create iamserviceaccount \<br/>    --name $ACK_K8S_SERVICE_ACCOUNT_NAME \<br/>    --namespace $ACK_SYSTEM_NAMESPACE \<br/>    --cluster $EKS_CLUSTER_NAME \<br/>    --role-name $IAM_ROLE_NAME \<br/>    --attach-policy-arn $POLICY_ARN \<br/>    --approve \<br/>    --override-existing-serviceaccounts</span></pre><blockquote class="lv lw lx"><p id="df88" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><em class="jf">根据</em><a class="ae lu" href="https://github.com/aws-controllers-k8s/memorydb-controller/blob/main/config/iam/recommended-policy-arn" rel="noopener ugc nofollow" target="_blank"><em class="jf">https://github . com/AWS-controllers-k8s/memory db-controller/blob/main/config/iam/recommended-policy-arn</em></a>选择策略( <code class="fe ku kv kw kx b"><em class="jf">AmazonMemoryDBFullAccess</em></code> <em class="jf">)</em></p></blockquote><p id="f0f5" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要进行确认，您可以检查IAM角色是否已创建，并检查Kubernetes服务帐户</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="93fc" class="nt mk jf kx b gy nu nv l nw nx">aws iam get-role --role-name=$IAM_ROLE_NAME --query Role.Arn --output text</span><span id="2494" class="nt mk jf kx b gy ny nv l nw nx">kubectl describe serviceaccount/$ACK_K8S_SERVICE_ACCOUNT_NAME -n $ACK_SYSTEM_NAMESPACE</span><span id="4d3b" class="nt mk jf kx b gy ny nv l nw nx"># you will see similar output</span><span id="2a37" class="nt mk jf kx b gy ny nv l nw nx">Name:                ack-memorydb-controller<br/>Namespace:           ack-system<br/>Labels:              app.kubernetes.io/instance=ack-memorydb-controller<br/>                     app.kubernetes.io/managed-by=eksctl<br/>                     app.kubernetes.io/name=memorydb-chart<br/>                     app.kubernetes.io/version=v0.0.2<br/>                     helm.sh/chart=memorydb-chart-v0.0.2<br/>                     k8s-app=memorydb-chart<br/>Annotations:         eks.amazonaws.com/role-arn: arn:aws:iam::568863012249:role/ack-memorydb-controller-role<br/>                     meta.helm.sh/release-name: ack-memorydb-controller<br/>                     meta.helm.sh/release-namespace: ack-system<br/>Image pull secrets:  &lt;none&gt;<br/>Mountable secrets:   ack-memorydb-controller-token-2cmmx<br/>Tokens:              ack-memorydb-controller-token-2cmmx<br/>Events:              &lt;none&gt;</span></pre><p id="807e" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了使<code class="fe ku kv kw kx b">IRSA</code>生效，您需要重新启动ACK <code class="fe ku kv kw kx b">Deployment</code>:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="9c36" class="nt mk jf kx b gy nu nv l nw nx"># Note the deployment name for ACK service controller from following command<br/>kubectl get deployments -n $ACK_SYSTEM_NAMESPACE</span><span id="7433" class="nt mk jf kx b gy ny nv l nw nx">kubectl -n $ACK_SYSTEM_NAMESPACE rollout restart deployment ack-memorydb-controller-memorydb-chart</span></pre><p id="0e98" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">确认<code class="fe ku kv kw kx b">Deployment</code>已重启(当前为<code class="fe ku kv kw kx b">Running</code>)且<code class="fe ku kv kw kx b">IRSA</code>已正确配置:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="e3a3" class="nt mk jf kx b gy nu nv l nw nx">kubectl get pods -n $ACK_SYSTEM_NAMESPACE</span><span id="8368" class="nt mk jf kx b gy ny nv l nw nx">kubectl describe pod -n $ACK_SYSTEM_NAMESPACE ack-memorydb-controller-memorydb-chart-5975b8d757-k6x9k | grep "^\s*AWS_"<br/># The output should contain following two lines:</span><span id="9d85" class="nt mk jf kx b gy ny nv l nw nx">AWS_ROLE_ARN=arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/&lt;IAM_ROLE_NAME&gt;<br/>AWS_WEB_IDENTITY_TOKEN_FILE=/var/run/secrets/eks.amazonaws.com/serviceaccount/token</span></pre><p id="7b26" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在我们已经完成了配置，是时候…</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="7840" class="mj mk jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated"><code class="fe ku kv kw kx b">cdk8s</code>在行动！</h1><p id="c8eb" class="pw-post-body-paragraph ky kz jf la b lb nb kg ld le nc kj lg lh nd lj lk ll ne ln lo lp nf lr ls lt ij bi translated">我们将一步一步来:</p><ul class=""><li id="6801" class="nz oa jf la b lb lc le lf lh ob ll oc lp od lt oe of og oh bi translated">构建应用Docker映像并将其推送到亚马逊ECR<a class="ae lu" href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/what-is-ecr.html" rel="noopener ugc nofollow" target="_blank">中的私有注册表</a></li><li id="8523" class="nz oa jf la b lb oi le oj lh ok ll ol lp om lt oe of og oh bi translated">部署<code class="fe ku kv kw kx b">MemoryDB</code>以及应用程序和所需的配置</li><li id="a6db" class="nz oa jf la b lb oi le oj lh ok ll ol lp om lt oe of og oh bi translated">测试应用程序</li></ul><h2 id="ad3e" class="nt mk jf bd ml on oo dn mp op oq dp mt lh or os mv ll ot ou mx lp ov ow mz ox bi translated">构建Docker映像并推送到ECR</h2><p id="8580" class="pw-post-body-paragraph ky kz jf la b lb nb kg ld le nc kj lg lh nd lj lk ll ne ln lo lp nf lr ls lt ij bi translated"><strong class="la jg">创建ECR私有存储库</strong></p><p id="4533" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">登录到ECR:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="d875" class="nt mk jf kx b gy nu nv l nw nx">aws ecr get-login-password --region &lt;enter region&gt; | docker login --username AWS --password-stdin &lt;enter aws_account_id&gt;.dkr.ecr.&lt;enter region&gt;.amazonaws.com</span></pre><p id="26c1" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">创建私有存储库:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="8b89" class="nt mk jf kx b gy nu nv l nw nx">aws ecr create-repository \<br/>    --repository-name memorydb-app \<br/>    --region &lt;enter region&gt;</span></pre><p id="522f" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg">构建映像并推送到ECR </strong></p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="6bb3" class="nt mk jf kx b gy nu nv l nw nx"># if you're on Mac M1<br/>#export DOCKER_DEFAULT_PLATFORM=linux/amd64<br/>docker build -t memorydb-app .</span><span id="c2c9" class="nt mk jf kx b gy ny nv l nw nx">docker tag memorydb-app:latest &lt;enter aws_account_id&gt;.dkr.ecr.&lt;enter region&gt;.amazonaws.com/memorydb-app:latest</span><span id="50b2" class="nt mk jf kx b gy ny nv l nw nx">docker push &lt;enter aws_account_id&gt;.dkr.ecr.&lt;enter region&gt;.amazonaws.com/memorydb-app:latest</span></pre><h2 id="3280" class="nt mk jf bd ml on oo dn mp op oq dp mt lh or os mv ll ot ou mx lp ov ow mz ox bi translated">使用<code class="fe ku kv kw kx b">cdk8s</code>和<code class="fe ku kv kw kx b">kubectl</code>部署MemoryDB和应用程序</h2><p id="59af" class="pw-post-body-paragraph ky kz jf la b lb nb kg ld le nc kj lg lh nd lj lk ll ne ln lo lp nf lr ls lt ij bi translated">这是一个现成的<code class="fe ku kv kw kx b">cdk8s</code>项目，你可以使用。整个逻辑在<a class="ae lu" href="https://github.com/abhirockzz/memorydb-ack-cdk8s-go/blob/master/memorydb-cdk8s/main.go" rel="noopener ugc nofollow" target="_blank"> main.go文件</a>中——我将在下一节深入研究代码的本质。</p><p id="dd75" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">从Github克隆项目，并切换到正确的目录:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="89a0" class="nt mk jf kx b gy nu nv l nw nx">git clone https://github.com/abhirockzz/memorydb-ack-cdk8s-go.git<br/>cd memorydb-ack-cdk8s-go</span></pre><p id="a1ed" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg">生成并部署清单</strong></p><p id="ff2b" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用<code class="fe ku kv kw kx b">cdk8s synth</code>生成<code class="fe ku kv kw kx b">MemoryDB</code>的清单、应用程序以及所需的配置。然后我们可以使用<code class="fe ku kv kw kx b">kubectl</code>来<code class="fe ku kv kw kx b">apply</code>它。</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="502a" class="nt mk jf kx b gy nu nv l nw nx">export SUBNET_ID_LIST=&lt;enter comma-separated list of subnet IDs. should be same as your EKS cluster&gt;</span><span id="b835" class="nt mk jf kx b gy ny nv l nw nx"># for example:<br/># export SUBNET_ID_LIST=subnet-086c4a45ec9a206e1,subnet-0d9a9c6d2ca7a24df,subnet-028ca54bb859a4994</span><span id="6395" class="nt mk jf kx b gy ny nv l nw nx">export SECURITY_GROUP_ID=&lt;enter security group ID&gt;</span><span id="9a7b" class="nt mk jf kx b gy ny nv l nw nx"># for example<br/># export SECURITY_GROUP_ID=sg-06b6535ee64980616</span><span id="091a" class="nt mk jf kx b gy ny nv l nw nx">export DOCKER_IMAGE=&lt;enter ECR repo that you created earlier&gt;<br/># example<br/># export DOCKER_IMAGE=1234567891012.dkr.ecr.us-east-1.amazonaws.com/memorydb-app:latest</span></pre><blockquote class="lv lw lx"><p id="bae2" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><em class="jf">还可以添加其他环境变量</em><code class="fe ku kv kw kx b"><em class="jf">MEMORYDB_CLUSTER_NAME</em></code><em class="jf"/><code class="fe ku kv kw kx b"><em class="jf">MEMORYDB_USERNAME</em></code><em class="jf"/><code class="fe ku kv kw kx b"><em class="jf">MEMORYDB_PASSWORD</em></code><em class="jf">。这些不是强制性的，默认分别为</em> <code class="fe ku kv kw kx b"><em class="jf">memorydb-cluster-ack-cdk8s</em></code> <em class="jf">、</em> <code class="fe ku kv kw kx b"><em class="jf">demouser</em></code> <em class="jf">和</em><code class="fe ku kv kw kx b"><em class="jf">Password123456789</em></code><em class="jf"/></p></blockquote><p id="1ba7" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要生成清单:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="c49e" class="nt mk jf kx b gy nu nv l nw nx">cdk8s synth</span><span id="4823" class="nt mk jf kx b gy ny nv l nw nx"># check the "dist" folder - you should see these files:</span><span id="59b7" class="nt mk jf kx b gy ny nv l nw nx">0000-memorydb.k8s.yaml<br/>0001-config.k8s.yaml<br/>0002-deployment.k8s.yaml</span></pre><p id="aa63" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们逐个部署它们，从创建<code class="fe ku kv kw kx b">MemoryDB</code>集群的那个开始。除了集群，它还将提供支持组件，包括<a class="ae lu" href="https://docs.aws.amazon.com/memorydb/latest/devguide/components.html#whatis.components.acls" rel="noopener ugc nofollow" target="_blank"> ACL </a>、<a class="ae lu" href="https://docs.aws.amazon.com/memorydb/latest/devguide/components.html#whatis.components.user" rel="noopener ugc nofollow" target="_blank">用户</a>和<a class="ae lu" href="https://docs.aws.amazon.com/memorydb/latest/devguide/components.html#whatis.components.subnetgroups" rel="noopener ugc nofollow" target="_blank">子网组</a></p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="b55f" class="nt mk jf kx b gy nu nv l nw nx">kubectl apply -f dist/0000-memorydb.k8s.yaml</span><span id="a444" class="nt mk jf kx b gy ny nv l nw nx">#output<br/>secret/memdb-secret created<br/>users.memorydb.services.k8s.aws/demouser created<br/>acls.memorydb.services.k8s.aws/demo-acl created<br/>subnetgroups.memorydb.services.k8s.aws/demo-subnet-group created<br/>clusters.memorydb.services.k8s.aws/memorydb-cluster-ack-cdk8s</span></pre><blockquote class="lv lw lx"><p id="accb" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><strong class="la jg"><em class="jf"/></strong><code class="fe ku kv kw kx b"><strong class="la jg"><em class="jf">Secret</em></strong></code><em class="jf">用于保存</em> <code class="fe ku kv kw kx b"><em class="jf">MemoryDB</em></code> <em class="jf">集群用户的密码。</em></p></blockquote><p id="2a14" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这将启动集群创建。您可以使用AWS控制台检查状态。创建完成后，您可以使用<code class="fe ku kv kw kx b">redis-cli</code>测试连通性:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="390c" class="nt mk jf kx b gy nu nv l nw nx"># run this from EC2 instance in the same subnet as the cluster<br/>export REDIS=&lt;enter cluster endpoint&gt;<br/># example<br/># export REDIS=clustercfg.memorydb-cluster-ack-cdk8s.smtjf4.memorydb.us-east-1.amazonaws.com</span><span id="10c1" class="nt mk jf kx b gy ny nv l nw nx">redis-cli -h $REDIS -c --user demouser --pass Password123456789 --tls --insecure</span></pre><p id="758f" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们应用第二个清单。这将创建与配置相关的组件，即<code class="fe ku kv kw kx b">ConfigMap</code>和<code class="fe ku kv kw kx b">FieldExport</code>s——这些是我们的应用程序所需要的(将在此之后部署)</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="025e" class="nt mk jf kx b gy nu nv l nw nx">kubectl apply -f dist/0001-config.k8s.yaml</span><span id="7593" class="nt mk jf kx b gy ny nv l nw nx">#output<br/>configmap/export-memorydb-info created<br/>fieldexports.services.k8s.aws/export-memorydb-endpoint created<br/>fieldexports.services.k8s.aws/export-memorydb-username created</span></pre><p id="6dbc" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这种情况下，我们创建两个<code class="fe ku kv kw kx b">FieldExport</code>来从我们之前创建的集群(来自<code class="fe ku kv kw kx b">.status.clusterEndpoint.address</code>和用户(<code class="fe ku kv kw kx b">.spec.name</code>)资源中提取数据，并将其植入<code class="fe ku kv kw kx b">ConfigMap</code>。</p><blockquote class="lv lw lx"><p id="99a1" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><code class="fe ku kv kw kx b"><em class="jf">ConfigMap</em></code> <em class="jf">和</em> <code class="fe ku kv kw kx b"><em class="jf">FieldExport</em></code> <em class="jf"> : </em></p><p id="c76b" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><code class="fe ku kv kw kx b"><em class="jf">FieldExport</em></code> <em class="jf">是一个ACK组件，可以</em>“将ACK资源中的任何规范或状态字段导出到Kubernetes <code class="fe ku kv kw kx b">ConfigMap</code>或<code class="fe ku kv kw kx b">Secret</code><em class="jf">。你可以阅读</em> <a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/user-docs/field-export/" rel="noopener ugc nofollow" target="_blank"> <em class="jf"> ACK文档</em> </a> <em class="jf">中的细节以及一些例子。</em></p></blockquote><p id="9fdc" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您应该能够通过检查<code class="fe ku kv kw kx b">FieldExport</code>和<code class="fe ku kv kw kx b">ConfigMap</code>来确认:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="1706" class="nt mk jf kx b gy nu nv l nw nx">kubectl get fieldexport</span><span id="3259" class="nt mk jf kx b gy ny nv l nw nx">#output<br/>NAME                       AGE<br/>export-memorydb-endpoint   20s<br/>export-memorydb-username   20s</span><span id="b2c8" class="nt mk jf kx b gy ny nv l nw nx">kubectl get configmap/export-memorydb-info -o yaml</span></pre><p id="d4b4" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们从一个空白的<code class="fe ku kv kw kx b">ConfigMap</code>开始，但是<code class="fe ku kv kw kx b">ACK</code>神奇地用所需的属性填充了它:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="444e" class="nt mk jf kx b gy nu nv l nw nx">apiVersion: v1<br/>data:<br/>  default.export-memorydb-endpoint: clustercfg.memorydb-cluster-ack-cdk8s.smtjf4.memorydb.us-east-1.amazonaws.com<br/>  default.export-memorydb-username: demouser<br/>immutable: false<br/>kind: ConfigMap<br/>#....omitted</span></pre><p id="0f3a" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们创建应用程序资源— <code class="fe ku kv kw kx b">Deployment</code>和<code class="fe ku kv kw kx b">Service</code>。</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="b5e9" class="nt mk jf kx b gy nu nv l nw nx">kubectl apply -f dist/0003-deployment.k8s.yaml</span><span id="c736" class="nt mk jf kx b gy ny nv l nw nx">#output<br/>deployment.apps/memorydb-app created<br/>service/memorydb-app-service configured</span></pre><blockquote class="lv lw lx"><p id="9d14" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><em class="jf">由于服务类型是</em> <code class="fe ku kv kw kx b"><em class="jf">LoadBalancer</em></code> <em class="jf">，将提供一个合适的</em> <a class="ae lu" href="https://docs.aws.amazon.com/eks/latest/userguide/network-load-balancing.html" rel="noopener ugc nofollow" target="_blank"> <em class="jf"> AWS负载平衡器</em> </a> <em class="jf">以允许外部访问。</em></p></blockquote><p id="5c2d" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">检查<code class="fe ku kv kw kx b">Pod</code>和<code class="fe ku kv kw kx b">Service</code>:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="5681" class="nt mk jf kx b gy nu nv l nw nx">kubectl get pods<br/>kubectl get service/memorydb-app-service</span><span id="81a2" class="nt mk jf kx b gy ny nv l nw nx"># to get the load balancer IP<br/>APP_URL=$(kubectl get service/memorydb-app-service -o jsonpath="{.status.loadBalancer.ingress[0].hostname}")</span><span id="ac8e" class="nt mk jf kx b gy ny nv l nw nx">echo $APP_URL</span><span id="6fe8" class="nt mk jf kx b gy ny nv l nw nx"># output example<br/>a0042d5b5b0ad40abba9c6c42e6342a2-879424587.us-east-1.elb.amazonaws.com</span></pre><p id="2f7f" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您已经部署了应用程序，并且知道可以公开访问它的端点。以下是当前架构的高级视图:</p><figure class="nl nm nn no gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oy"><img src="../Images/41854d3f5845cbbb4e0a7407d9aa226f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a4ab6lt7z6HlU7VK.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">高级解决方案架构</figcaption></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="5df3" class="mj mk jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated">现在您可以访问应用程序了…</h1><p id="30ff" class="pw-post-body-paragraph ky kz jf la b lb nb kg ld le nc kj lg lh nd lj lk ll ne ln lo lp nf lr ls lt ij bi translated">这非常简单——它公开了几个HTTP端点来读写Redis中的数据(您可以在<a class="ae lu" href="https://github.com/abhirockzz/memorydb-ack-cdk8s-go/tree/master/memorydb-app" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看):</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="afc0" class="nt mk jf kx b gy nu nv l nw nx"># create a couple of users - this will be added as a `HASH` in Redis</span><span id="967d" class="nt mk jf kx b gy ny nv l nw nx">curl -i -X POST -d '{"email":"user1@foo.com", "name":"user1"}' http://$APP_URL:9090/</span><span id="29fd" class="nt mk jf kx b gy ny nv l nw nx">curl -i -X POST -d '{"email":"user2@foo.com", "name":"user2"}' http://$APP_URL:9090/<br/></span><span id="4072" class="nt mk jf kx b gy ny nv l nw nx">HTTP/1.1 200 OK<br/>Content-Length: 0</span><span id="448e" class="nt mk jf kx b gy ny nv l nw nx"># search for user via email<br/>curl -i http://$APP_URL:9090/user2@foo.com</span><span id="6f00" class="nt mk jf kx b gy ny nv l nw nx">HTTP/1.1 200 OK<br/>Content-Length: 41<br/>Content-Type: text/plain; charset=utf-8</span><span id="e0cf" class="nt mk jf kx b gy ny nv l nw nx">{"email":"user2@foo.com","name":"user2"}</span></pre><blockquote class="lv lw lx"><p id="ce4f" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><em class="jf">如果在访问LB URL时出现</em> <code class="fe ku kv kw kx b"><em class="jf">Could not resolve host</em></code> <em class="jf">错误，请等待一分钟左右，然后重试</em></p></blockquote><p id="8dad" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一旦你完成了…</p><h2 id="e55d" class="nt mk jf bd ml on oo dn mp op oq dp mt lh or os mv ll ot ou mx lp ov ow mz ox bi translated">…不要忘记删除资源..</h2><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="2dcb" class="nt mk jf kx b gy nu nv l nw nx"># delete MemoryDB cluster, configuration and the application</span><span id="2045" class="nt mk jf kx b gy ny nv l nw nx">kubectl delete -f dist/</span><span id="9f2f" class="nt mk jf kx b gy ny nv l nw nx"># to uninstall the ACK controller<br/>export SERVICE=memorydb<br/>helm uninstall -n $ACK_SYSTEM_NAMESPACE ack-$SERVICE-controller</span><span id="0d19" class="nt mk jf kx b gy ny nv l nw nx"># delete the EKS cluster. if created via eksctl:<br/>eksctl delete cluster --name &lt;enter name of eks cluster&gt;</span></pre><p id="38ba" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">到目前为止，您已经为MemoryDB部署了ACK控制器，设置了一个集群，一个连接到集群的应用程序，并测试了端到端解决方案。太好了！</p><p id="509b" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在让我们看看让这一切发生的<code class="fe ku kv kw kx b">cdk8s</code>代码。逻辑分为三个<code class="fe ku kv kw kx b">Chart</code>。为了简洁起见，我将只关注代码的关键部分，其余部分将被省略。</p><blockquote class="lv lw lx"><p id="762d" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><em class="jf">可以参考</em> <a class="ae lu" href="https://github.com/abhirockzz/memorydb-ack-cdk8s-go/tree/master/memorydb-cdk8s" rel="noopener ugc nofollow" target="_blank"> <em class="jf">上的完整代码GitHub </em> </a></p></blockquote></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="6349" class="mj mk jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated">代码遍历</h1><p id="bebf" class="pw-post-body-paragraph ky kz jf la b lb nb kg ld le nc kj lg lh nd lj lk ll ne ln lo lp nf lr ls lt ij bi translated"><strong class="la jg">内存数据库及相关组件</strong></p><p id="cd33" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们首先定义<code class="fe ku kv kw kx b">MemoryDB</code>集群以及所需的组件——ACL、用户和子网组。</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="e20a" class="nt mk jf kx b gy nu nv l nw nx">func NewMemoryDBChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {<br/>    //...<br/>    secret = cdk8splus22.NewSecret(chart, jsii.String("password"), &amp;cdk8splus22.SecretProps{<br/>        Metadata:   &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(secretName)},<br/>        StringData: &amp;map[string]*string{"password": jsii.String(memoryDBPassword)},<br/>    })</span><span id="f5ae" class="nt mk jf kx b gy ny nv l nw nx">    user = users_memorydbservicesk8saws.NewUser(chart, jsii.String("user"), &amp;users_memorydbservicesk8saws.UserProps{<br/>        Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(memoryDBUsername)},<br/>        Spec: &amp;users_memorydbservicesk8saws.UserSpec{<br/>            Name:         jsii.String(memoryDBUsername),<br/>            AccessString: jsii.String(memoryDBUserAccessString),<br/>            AuthenticationMode: &amp;users_memorydbservicesk8saws.UserSpecAuthenticationMode{<br/>                Type: jsii.String("Password"),<br/>                Passwords: &amp;[]*users_memorydbservicesk8saws.UserSpecAuthenticationModePasswords{<br/>                    {Name: secret.Name(), Key: jsii.String(secretKeyName)},<br/>                },<br/>            },<br/>        },<br/>    })</span></pre><p id="2d0e" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe ku kv kw kx b">ACL</code>引用上面定义的<code class="fe ku kv kw kx b">User</code>:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="4c73" class="nt mk jf kx b gy nu nv l nw nx">acl := acl_memorydbservicesk8saws.NewAcl(chart, jsii.String("acl"),<br/>        &amp;acl_memorydbservicesk8saws.AclProps{<br/>            Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(memoryDBACLName)},<br/>            Spec: &amp;acl_memorydbservicesk8saws.AclSpec{<br/>                Name:      jsii.String(memoryDBACLName),<br/>                UserNames: jsii.Strings(*user.Name()),<br/>            },<br/>        })</span></pre><p id="ec64" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">子网ID(对于子网组)以及集群的安全组ID是从环境变量中读取的。</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="da76" class="nt mk jf kx b gy nu nv l nw nx">subnetGroup := subnetgroups_memorydbservicesk8saws.NewSubnetGroup(chart, jsii.String("sg"),<br/>        &amp;subnetgroups_memorydbservicesk8saws.SubnetGroupProps{<br/>            Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(memoryDBSubnetGroup)},<br/>            Spec: &amp;subnetgroups_memorydbservicesk8saws.SubnetGroupSpec{<br/>                Name: jsii.String(memoryDBSubnetGroup),<br/>                SubnetIDs: jsii.Strings(strings.Split(subnetIDs, ",")...), //same as EKS cluster<br/>            },<br/>        })</span></pre><p id="b441" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后，定义了<code class="fe ku kv kw kx b">MemoryDB</code>集群——它引用了上面创建的所有资源(有意省略了):</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="bb4b" class="nt mk jf kx b gy nu nv l nw nx">memoryDBCluster = memorydbservicesk8saws.NewCluster(chart, jsii.String("memorydb-ack-cdk8s"),<br/>        &amp;memorydbservicesk8saws.ClusterProps{<br/>            Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(memoryDBClusterName)},<br/>            Spec: &amp;memorydbservicesk8saws.ClusterSpec{<br/>                Name:                jsii.String(memoryDBClusterName),<br/>                //omitted<br/>            },<br/>        })</span><span id="c4d1" class="nt mk jf kx b gy ny nv l nw nx">    return chart<br/>}</span></pre><p id="6439" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg">配置</strong></p><p id="6c2f" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">然后，我们转到下一个图表，处理与配置相关的方面。它为MemoryDB集群端点和用户名分别定义了一个<code class="fe ku kv kw kx b">ConfigMap</code>(为空)和<code class="fe ku kv kw kx b">FieldExport</code> s(密码从<code class="fe ku kv kw kx b">Secret</code>中读取)</p><blockquote class="lv lw lx"><p id="8eeb" class="ky kz ly la b lb lc kg ld le lf kj lg lz li lj lk ma lm ln lo mb lq lr ls lt ij bi translated"><em class="jf">创建完成后，根据</em> <code class="fe ku kv kw kx b"><em class="jf">FieldExport</em></code> <em class="jf">中的</em> <code class="fe ku kv kw kx b"><em class="jf">from</em></code> <em class="jf">和</em> <code class="fe ku kv kw kx b"><em class="jf">to</em></code> <em class="jf">配置，用所需数据填充</em> <code class="fe ku kv kw kx b"><em class="jf">ConfigMap</em></code> <em class="jf">。</em></p></blockquote><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="126c" class="nt mk jf kx b gy nu nv l nw nx">func NewConfigChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {<br/>    //...<br/>    cfgMap = cdk8splus22.NewConfigMap(chart, jsii.String("config-map"),<br/>        &amp;cdk8splus22.ConfigMapProps{<br/>            Metadata: &amp;cdk8s.ApiObjectMetadata{<br/>                Name: jsii.String(configMapName)}})</span><span id="7487" class="nt mk jf kx b gy ny nv l nw nx">    fieldExportForClusterEndpoint = servicesk8saws.NewFieldExport(chart, jsii.String("fexp-cluster"), &amp;servicesk8saws.FieldExportProps{<br/>        Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(fieldExportNameForClusterEndpoint)},<br/>        Spec: &amp;servicesk8saws.FieldExportSpec{<br/>            From: &amp;servicesk8saws.FieldExportSpecFrom{Path: jsii.String(".status.clusterEndpoint.address"),<br/>                Resource: &amp;servicesk8saws.FieldExportSpecFromResource{<br/>                    Group: jsii.String("memorydb.services.k8s.aws"),<br/>                    Kind:  jsii.String("Cluster"),<br/>                    Name:  memoryDBCluster.Name()}},<br/>            To: &amp;servicesk8saws.FieldExportSpecTo{<br/>                Name: cfgMap.Name(),<br/>                Kind: servicesk8saws.FieldExportSpecToKind_CONFIGMAP}}})</span><span id="5ffb" class="nt mk jf kx b gy ny nv l nw nx">    fieldExportForUsername = servicesk8saws.NewFieldExport(chart, jsii.String("fexp-username"), &amp;servicesk8saws.FieldExportProps{<br/>        Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(fieldExportNameForUsername)},<br/>        Spec: &amp;servicesk8saws.FieldExportSpec{<br/>            From: &amp;servicesk8saws.FieldExportSpecFrom{Path: jsii.String(".spec.name"),<br/>                Resource: &amp;servicesk8saws.FieldExportSpecFromResource{<br/>                    Group: jsii.String("memorydb.services.k8s.aws"),<br/>                    Kind:  jsii.String("User"),<br/>                    Name:  user.Name()}},<br/>            To: &amp;servicesk8saws.FieldExportSpecTo{<br/>                Name: cfgMap.Name(),<br/>                Kind: servicesk8saws.FieldExportSpecToKind_CONFIGMAP}}})</span><span id="ec86" class="nt mk jf kx b gy ny nv l nw nx">    return chart<br/>}</span></pre><p id="5bdd" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg">应用图表</strong></p><p id="7a7f" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后，我们处理<code class="fe ku kv kw kx b">Deployment</code>(在其专用的<code class="fe ku kv kw kx b">Chart</code>)它利用了我们在前面的图表中定义的配置对象:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="48a1" class="nt mk jf kx b gy nu nv l nw nx">func NewDeploymentChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {<br/>    //....<br/>    dep := cdk8splus22.NewDeployment(chart, jsii.String("memorydb-app-deployment"), &amp;cdk8splus22.DeploymentProps{<br/>        Metadata: &amp;cdk8s.ApiObjectMetadata{<br/>            Name: jsii.String("memorydb-app")}})</span></pre><p id="810d" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下一个重要的部分是容器及其配置。我们指定了ECR图像存储库和环境变量——它们引用了我们在前面的图表中定义的<code class="fe ku kv kw kx b">ConfigMap</code>(一切都是关联的！):</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="b577" class="nt mk jf kx b gy nu nv l nw nx">//...<br/>    container := dep.AddContainer(<br/>        &amp;cdk8splus22.ContainerProps{<br/>            Name:  jsii.String("memorydb-app-container"),<br/>            Image: jsii.String(appDockerImage),<br/>            Port:  jsii.Number(appPort)})</span><span id="486d" class="nt mk jf kx b gy ny nv l nw nx">    container.Env().AddVariable(jsii.String("MEMORYDB_CLUSTER_ENDPOINT"),<br/>        cdk8splus22.EnvValue_FromConfigMap(<br/>            cfgMap,<br/>            jsii.String("default."+*fieldExportForClusterEndpoint.Name()),<br/>            &amp;cdk8splus22.EnvValueFromConfigMapOptions{Optional: jsii.Bool(false)}))</span><span id="d42a" class="nt mk jf kx b gy ny nv l nw nx">    container.Env().AddVariable(jsii.String("MEMORYDB_USERNAME"),<br/>        cdk8splus22.EnvValue_FromConfigMap(<br/>            cfgMap,<br/>            jsii.String("default."+*fieldExportForUsername.Name()),<br/>            &amp;cdk8splus22.EnvValueFromConfigMapOptions{Optional: jsii.Bool(false)}))</span><span id="64b9" class="nt mk jf kx b gy ny nv l nw nx">    container.Env().AddVariable(jsii.String("MEMORYDB_PASSWORD"),<br/>        cdk8splus22.EnvValue_FromSecretValue(<br/>            &amp;cdk8splus22.SecretValue{<br/>                Secret: secret,<br/>                Key:    jsii.String("password")},<br/>            &amp;cdk8splus22.EnvValueFromSecretOptions{}))</span></pre><p id="4f19" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后，我们定义了允许外部应用程序访问的<code class="fe ku kv kw kx b">Service</code>(类型<code class="fe ku kv kw kx b">LoadBalancer</code>)并在<code class="fe ku kv kw kx b">main</code>函数中将它们联系在一起:</p><pre class="nl nm nn no gt np kx nq nr aw ns bi"><span id="d692" class="nt mk jf kx b gy nu nv l nw nx">//...<br/>    dep.ExposeViaService(<br/>        &amp;cdk8splus22.DeploymentExposeViaServiceOptions{<br/>            Name:        jsii.String("memorydb-app-service"),<br/>            ServiceType: cdk8splus22.ServiceType_LOAD_BALANCER,<br/>            Ports: &amp;[]*cdk8splus22.ServicePort{<br/>                {Protocol: cdk8splus22.Protocol_TCP,<br/>                    Port:       jsii.Number(lbPort),<br/>                    TargetPort: jsii.Number(appPort)}}})<br/>//...</span><span id="a396" class="nt mk jf kx b gy ny nv l nw nx">func main() {<br/>    app := cdk8s.NewApp(nil)</span><span id="b4c8" class="nt mk jf kx b gy ny nv l nw nx">    memorydb := NewMemoryDBChart(app, "memorydb", nil)<br/>    config := NewConfigChart(app, "config", nil)</span><span id="b81d" class="nt mk jf kx b gy ny nv l nw nx">    config.AddDependency(memorydb)<br/>    deployment := NewDeploymentChart(app, "deployment", nil)</span><span id="4893" class="nt mk jf kx b gy ny nv l nw nx">    deployment.AddDependency(memorydb, config)<br/>    app.Synth()<br/>}</span></pre><p id="96a6" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">暂时就这样吧！</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="a2b8" class="mj mk jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated">包裹..</h1><p id="e46f" class="pw-post-body-paragraph ky kz jf la b lb nb kg ld le nc kj lg lh nd lj lk ll ne ln lo lp nf lr ls lt ij bi translated">如果你想管理AWS服务和Kubernetes应用程序，结合Kubernetes和<code class="fe ku kv kw kx b">cdk8s</code>的AWS控制器会证明是有用的——使用代码(不是<code class="fe ku kv kw kx b">yaml</code>)。在这篇博客中，您看到了如何在<code class="fe ku kv kw kx b">MemoryDB</code>和一个由<code class="fe ku kv kw kx b">Deployment</code>和<code class="fe ku kv kw kx b">Service</code>组成的应用程序的上下文中实现这一点。我鼓励你也尝试其他AWS服务- <a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/community/services/" rel="noopener ugc nofollow" target="_blank">这里有一个完整的列表</a>。</p><p id="2782" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在那之前，快乐大厦！</p></div></div>    
</body>
</html>