<html>
<head>
<title>Understanding var, let &amp; const in JavaScript — ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的var，let &amp; const—ES6</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-var-let-const-in-javascript-es6-a80d6c62a5f0?source=collection_archive---------2-----------------------#2019-07-24">https://itnext.io/understanding-var-let-const-in-javascript-es6-a80d6c62a5f0?source=collection_archive---------2-----------------------#2019-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ae7682846bb5cbf84db71a1df87d54bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgmSNM4Te_6h_pgUPnec_g.png"/></div></div></figure><p id="8237" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ES6 (也称为ECMAScript 2015)对JavaScript的语法进行了重大改变，并带来了以前不存在的新功能。</p><p id="8155" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">学习ES6很重要，因为一个原因是，它使JavaScript更好更容易编写，而且ES6正与当今的现代web技术一起使用，如<strong class="ka ir"> React、Node.js </strong>等。</p><p id="49d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本帖中，你将学习ES6为<strong class="ka ir">变量声明</strong> : <code class="fe kw kx ky kz b">let</code>和<code class="fe kw kx ky kz b">const</code>带来的新关键词。但是首先，让我们解释一下<code class="fe kw kx ky kz b">var</code>到底出了什么问题。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="afe9" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">var的问题是什么？</h1><p id="5f13" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">我们已经在JS中使用了<code class="fe kw kx ky kz b">var</code>关键字来声明变量。那么为什么ES6引入了额外的关键词呢？</p><p id="d381" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要理解<code class="fe kw kx ky kz b">var</code>中的问题，首先你需要明白<a class="ae mk" href="https://www.w3schools.com/js/js_scope.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="ml">范围</em> </strong> </a>是什么。</p><blockquote class="mm"><p id="3d5b" class="mn mo iq bd mp mq mr ms mt mu mv kv dk translated">范围决定了代码不同部分的变量、对象和函数的可访问性。— w3schools</p></blockquote><p id="53cf" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">JavaScript中有3种类型的作用域:</p><ul class=""><li id="7e60" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated">函数(局部)范围</li><li id="4a29" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">全球范围</li><li id="0069" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">数据块范围(ES6新增)</li></ul><blockquote class="np nq nr"><p id="fe25" class="jy jz ml ka b kb kc kd ke kf kg kh ki ns kk kl km nt ko kp kq nu ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b"><strong class="ka ir">var</strong></code> <strong class="ka ir">支持函数&amp;全局作用域，不支持块作用域。</strong></p></blockquote><figure class="nv nw nx ny gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="c484" class="ob li iq bd lj oc od dn ln oe of dp lr kj og oh lv kn oi oj lz kr ok ol md om bi translated">函数(局部)范围</h2><p id="b03d" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">当变量在<strong class="ka ir">函数</strong>内部定义时，它将<strong class="ka ir">局部</strong>仅用于该函数，不能在外部使用:</p><pre class="nv nw nx ny gt on kz oo op aw oq bi"><span id="8ee0" class="ob li iq kz b gy or os l ot ou"><strong class="kz ir">function</strong> local() {<br/>   <strong class="kz ir">var</strong> number = 1;<br/><br/>   console.log(number); // 1 gets printed<br/>}</span><span id="8c85" class="ob li iq kz b gy ov os l ot ou">console.log(number); // undefined</span></pre><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/6447ea8e337a88b154d2d53ae6b6686e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMGvrHrA3hC8SWiXL7ORLw.png"/></div></div></figure><h2 id="9e60" class="ob li iq bd lj oc od dn ln oe of dp lr kj og oh lv kn oi oj lz kr ok ol md om bi translated">全球范围</h2><p id="756d" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">当一个变量在函数之外声明，或者没有关键字<code class="fe kw kx ky kz b">var</code>时，它将成为<strong class="ka ir">全局变量</strong>，并且可以从任何地方访问:</p><pre class="nv nw nx ny gt on kz oo op aw oq bi"><span id="4e4e" class="ob li iq kz b gy or os l ot ou"><strong class="kz ir">var</strong> number = 1;</span><span id="8869" class="ob li iq kz b gy ov os l ot ou"><strong class="kz ir">function</strong> local() {<br/>  console.log(number); // 1 gets printed<br/>}</span><span id="dca3" class="ob li iq kz b gy ov os l ot ou">console.log(number); // 1 gets printed</span></pre><h2 id="1b1f" class="ob li iq bd lj oc od dn ln oe of dp lr kj og oh lv kn oi oj lz kr ok ol md om bi translated">块范围</h2><p id="c52e" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">循环的<strong class="ka ir">花括号{ }、if-else案例</strong>和<strong class="ka ir">内的所有内容都是<strong class="ka ir">块范围的</strong>。这是<code class="fe kw kx ky kz b">var</code>不支持的部分。</strong></p><p id="e8e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在for循环中定义一个变量(用<code class="fe kw kx ky kz b">var</code> ) <strong class="ka ir">，看看会打印出什么…</strong></p><pre class="nv nw nx ny gt on kz oo op aw oq bi"><span id="c985" class="ob li iq kz b gy or os l ot ou"><strong class="kz ir">for</strong>(<strong class="kz ir">var</strong> i = 1; i &lt; 10; i++) {<br/>  console.log(i);<br/>} </span><span id="0cd1" class="ob li iq kz b gy ov os l ot ou">console.log(i);    // What do we expect here?</span></pre><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/94dff17c850c5c22a6ccf20164b995da.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*3Ol4GcpXx1HmdveODHKlCA.png"/></div></figure><p id="5c69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切似乎都很好，直到这里。但是第二个<strong class="ka ir"> console.log呢？</strong></p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/5288ab7496af15d5d2a67804460fc64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*mw_ut_4f46jziMo0LXTZfw.png"/></div></figure><p id="e202" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个<strong class="ka ir"> console.log </strong>在循环的<strong class="ka ir">之外，并且<strong class="ka ir">局部变量“I”</strong>仍然被打印，而它应该是<strong class="ka ir">未定义的</strong>。</strong></p><p id="cedc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果我们使用<strong class="ka ir"> let或const，由于它们是块范围的</strong>，这个问题就解决了。</p><h2 id="5180" class="ob li iq bd lj oc od dn ln oe of dp lr kj og oh lv kn oi oj lz kr ok ol md om bi translated">风险值的重新申报问题</h2><p id="fa47" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated"><code class="fe kw kx ky kz b">var</code>的另一个问题是它允许<strong class="ka ir">一次又一次地重新声明</strong>相同的变量:</p><pre class="nv nw nx ny gt on kz oo op aw oq bi"><span id="2b90" class="ob li iq kz b gy or os l ot ou"><strong class="kz ir">var</strong> number = 1;   // first declaration<br/><strong class="kz ir">var</strong> number = 2;   // same variable redeclared with the same name</span><span id="24e5" class="ob li iq kz b gy ov os l ot ou">console.log(number); // And we see no errors</span></pre><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/19a239e31e0d4ffa3246f4236ed199d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*JRxNs1dZiq2IZbY9hKwkYg.png"/></div></figure><p id="e2f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看ES6是如何处理它们的…</p><h1 id="3d48" class="lh li iq bd lj lk pa lm ln lo pb lq lr ls pc lu lv lw pd ly lz ma pe mc md me bi translated">用字母代替var</h1><p id="2043" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">为了防止我上面提到的问题，让我们用<code class="fe kw kx ky kz b">let</code>再试一次:</p><pre class="nv nw nx ny gt on kz oo op aw oq bi"><span id="a30d" class="ob li iq kz b gy or os l ot ou"><strong class="kz ir">for</strong>(<strong class="kz ir">let</strong> i = 0; i &lt; 10; i++) {   // same local variable with <strong class="kz ir">let</strong> <br/>  console.log(i);<br/>}</span><span id="5c0e" class="ob li iq kz b gy ov os l ot ou">console.log(i); // This time what do we expect?</span></pre><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/4186f6946b2ebfa447f41ae6810c7e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*BnanKC10yETQYQVsVTLGxQ.png"/></div></figure><p id="7f3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以<code class="fe kw kx ky kz b">let</code>支持块范围，第二个<strong class="ka ir"> console.log </strong>返回<strong class="ka ir">未定义</strong>。完美！</p><p id="81af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，试图用<code class="fe kw kx ky kz b">let</code> <strong class="ka ir"> </strong>重新声明变量会返回一个错误:</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pg"><img src="../Images/009e89ccccc867690d6d6e4b2bb2b5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53yg2pQm0CoWgKBWmnzPHw.png"/></div></div></figure><p id="667c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以<code class="fe kw kx ky kz b">let</code>关键词:</p><ul class=""><li id="1471" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated">可以代替<code class="fe kw kx ky kz b">var</code></li><li id="d81f" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><strong class="ka ir">是块范围的</strong></li><li id="7127" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">不允许<strong class="ka ir">重新申报</strong>，但稍后可以<strong class="ka ir">重新分配</strong></li></ul><h1 id="1fd1" class="lh li iq bd lj lk pa lm ln lo pb lq lr ls pc lu lv lw pd ly lz ma pe mc md me bi translated">常数</h1><p id="b16c" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">ES6带来的另一个新关键词是<code class="fe kw kx ky kz b">const</code>。</p><blockquote class="mm"><p id="f97b" class="mn mo iq bd mp mq mr ms mt mu mv kv dk translated">"不变的东西:不变的东西."</p></blockquote><p id="0b62" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated"><code class="fe kw kx ky kz b">let</code>和<code class="fe kw kx ky kz b">const</code>的区别在于，一旦我们用<code class="fe kw kx ky kz b">const</code>声明了一个变量，以后就不能更改了:</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/da0acf0f2cf89466a51fae44c46387c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*fhKsI8zRU-RXlGZd6zuD4Q.png"/></div></figure><p id="61d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">const</code>关键字:</p><ul class=""><li id="df2e" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated">也可以代替<code class="fe kw kx ky kz b">var</code></li><li id="472a" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">一旦它声明了</li><li id="97c7" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">和<code class="fe kw kx ky kz b">let</code>一样<strong class="ka ir">也是块范围的</strong></li><li id="6fb3" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">不允许<strong class="ka ir">重新申报</strong>或<strong class="ka ir">重新分配</strong></li></ul></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="5391" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ES6显著改变了JavaScript，并随着ES7、ES8等不断改变。如果你有问题，请在下面评论。如果你喜欢文章，请分享。</p><p id="6200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">如果你想了解更多关于Web开发的知识，欢迎在Youtube上关注我</strong><a class="ae mk" href="https://www.youtube.com/channel/UC1EgYPCvKCXFn8HlpoJwY3Q" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"/></a><strong class="ka ir">！</strong></p><p id="cd13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的时间&amp;再见！</p></div></div>    
</body>
</html>