<html>
<head>
<title>Pixels matter or easy UI screenshot testing in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native中的像素问题或简单UI截图测试</h1>
<blockquote>原文：<a href="https://itnext.io/pixels-matter-or-easy-ui-screenshot-testing-in-react-native-36c774cee3d1?source=collection_archive---------4-----------------------#2019-09-10">https://itnext.io/pixels-matter-or-easy-ui-screenshot-testing-in-react-native-36c774cee3d1?source=collection_archive---------4-----------------------#2019-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f55fdb7e4c95547e0a8c7174b91c179c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSejU7dNWT5SRbOgqtThEg.png"/></div></div></figure><p id="e8e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">开发任何应用程序都需要大量的知识、努力、时间，当然还有测试。但是一旦你的产品到达客户手中，你的代码组织得有多好，你有多少单元测试，或者你集成了哪些革命性的框架或库，都没有关系。客户首先看到的是你的应用程序的用户界面，这极大地影响了他们对你的应用程序的第一印象和总体看法。谁知道呢，他们可能会不喜欢你的应用程序，甚至离开你的应用程序，永远不再回来，或者你在应用程序商店获得的星星比预期的少。这就是为什么你的应用程序必须是像素完美的，应该总是看上去一模一样。你只有一次机会来打动你的顾客。</p><p id="a1ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，你会发现对<a class="ae kz" href="https://www.npmjs.com/package/pixels-catcher" rel="noopener ugc nofollow" target="_blank"> pixels-catcher </a>项目的介绍，该项目可以应用于任何React本地应用程序，并使你能够对任何屏幕或组件进行UI快照测试。此外，如果它与<a class="ae kz" href="https://en.wikipedia.org/wiki/Continuous_integration" rel="noopener ugc nofollow" target="_blank"> CI </a>集成，它将能够自动检查屏幕质量，并验证应用程序是否像素完美，是否符合预定义的用户界面预期。</p><h1 id="e63a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">截屏</h1><p id="b0fe" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">毫无疑问，你已经知道“像素完美”是什么意思，但如果你需要刷新你的知识，你可以在这里找到一个很好的例子:<a class="ae kz" href="http://cdn.ustwo.com/PPP/PP3.pdf" rel="noopener ugc nofollow" target="_blank">像素完美精度手册</a>。你会注意到大部分内容只是简单地比较图像，就像这样:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/74a0ead705e7b4d4782ad9d7c9cfa256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdsTrYLdcpA30Zkx0PONrQ.png"/></div></div></figure><p id="dc61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个很好的例子，说明了截图测试是什么以及它为什么有用。因此，在图片的右侧是参考图像或设计，而在左侧，您可以看到由您的应用程序呈现的实际实现的结果。在这种情况下，很容易发现差异，并很快理解特性还没有准备好，或者引入的更改破坏了预期的布局。也可能发生这样的情况，一个UI解决方案在一个平台上工作正常，但在另一个平台上表现不同。</p><p id="e553" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为截图的替代方法，您可能已经使用<a class="ae kz" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> jest </a>进行单元测试，这是测试您的应用程序代码的强大框架。它的一种可能性是捕获组件当前状态的快照，并使用引用快照创建一个diff。但是看最初的<a class="ae kz" href="https://github.com/facebook/jest/blob/master/examples/react-native/__tests__/__snapshots__/intro.test.js.snap" rel="noopener ugc nofollow" target="_blank">快照</a>:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/dc8293c34af102300743694606d1a875.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*IwPvNrJ94W7Pg8pBt6Rwyw.png"/></div></figure><p id="4230" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你不知道这实际上是如何在你的应用程序中呈现的，在小屏幕或大屏幕上，在Android或iOS上，等等。因此，您需要深入研究快照和源代码，运行应用程序来检查和了解实际发生了什么变化，组件是如何使用的，应用了哪些属性，更重要的是，手动确认它在不同设备上的呈现方式。</p><h1 id="dbf7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">UI测试的好处</h1><p id="dabd" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">乍一看，你可能会认为开发应用程序和集成<a class="ae kz" href="https://www.npmjs.com/package/pixels-catcher" rel="noopener ugc nofollow" target="_blank">像素捕捉器</a>项目需要更多时间，因此你不会得到任何好处。但是，让我们来看看在开发过程中您能获得什么:</p><h2 id="8b58" class="mj lb it bd lc mk ml dn lg mm mn dp lk km mo mp lo kq mq mr ls ku ms mt lw mu bi translated">初始实施</h2><p id="6419" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">新功能或完整应用程序的开发通常包括以下几个阶段:</p><ul class=""><li id="a641" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">设计和开发</li><li id="ee43" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">测试(单元测试、手册等。)</li><li id="299b" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">代码审查</li><li id="a9af" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">批准</li><li id="2fd5" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">等等。</li></ul><p id="48ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">引入可视化UI测试意味着每次你交付一个特性，比如一个新的屏幕或者一个组件，你也需要编写测试来呈现不同状态、大小甚至不同平台上的屏幕/组件。这种测试的输出将是参考图像，这意味着:</p><ul class=""><li id="dfc3" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">UI设计人员可以快速检查图像，并提供关于实现的反馈，验证它是否符合预期。</li><li id="4e67" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">另一个开发人员/审核人员可以使用该图像作为第一步来验证拉/合并请求是否准备好接受审核，并直观地了解变更的结果。这意味着如果屏幕没有准备好，就不需要编译项目和运行应用程序。</li><li id="7c33" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">即使对开发人员来说也有好处，因为在不同的设备上运行可视化UI测试后，很容易得到所有设备的结果，因此减少了人工工作量，而不会降低应用程序的质量。</li></ul><h2 id="28d8" class="mj lb it bd lc mk ml dn lg mm mn dp lk km mo mp lo kq mq mr ls ku ms mt lw mu bi translated">重构</h2><p id="49e0" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">设想一个需要重构的现有应用程序或组件。这可能是更改模型、数据层、提高性能等的请求。并且可能在这个阶段项目已经包含了一些<code class="fe nj nk nl nm b">e2e</code>、<code class="fe nj nk nl nm b">unit</code>或者其他测试。根据不同的变化，有可能所有相关的测试和实现代码都需要一些重构。唯一不变的是UI表示。在这种情况下，给定通过参考图像引入的屏幕截图和定义的UI状态，所有这些参考图像应该保持不变。这意味着即使快照测试本身需要更改，生成的快照映像也应该保持不变。因此，这提供了很大的信心，用户界面中没有任何东西被破坏，客户不会注意到变化。</p><p id="3132" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在另一种情况下，可能需要一个确实影响UI的更改。假设应用程序中有一些全局定义的字体大小，例如<code class="fe nj nk nl nm b">h1</code>、<code class="fe nj nk nl nm b">h2</code>等。并且要求改变<code class="fe nj nk nl nm b">h2</code>字体的大小。这一变化预计将反映在所有应用程序组件/屏幕中，因为全局字体应在任何地方重复使用以保持一致性。在这种情况下，对所有屏幕和组件进行截图测试可以突出引入的差异。这基本上意味着，当一些测试在第一次运行后没有失败时，它们显然不使用这种字体大小。如果使用了一些自定义字体而不是预定义字体，或者UI在屏幕/组件之间不一致，就会出现这种情况。作为您的更改的最终结果，所有更新的参考图像应该出现在合并/拉取请求中，并且将可用于更好的代码审查。</p><h2 id="fd06" class="mj lb it bd lc mk ml dn lg mm mn dp lk km mo mp lo kq mq mr ls ku ms mt lw mu bi translated">发展</h2><p id="b577" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">即使在应用程序、屏幕或组件的开发过程中，也有很多好处。一个例子是当你有一个组件需要用不同的内容进行测试时；它可以是一些长或短的文本，不同的空白/填充等。在这种情况下，进行屏幕截图测试的好处是，一旦你写好了，就有可能在不同的设备(包括大小和平台)上用不同的内容多次触发测试。</p><p id="7146" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个很好的例子是本地化的实现。假设应用程序必须支持几种语言，比方说五种，这意味着开发人员必须改变语言并运行应用程序至少5次。但是考虑到支持android和iOS平台，并且至少需要测试一个小型和大型设备，因此将导致(5种语言)* (2个平台)* (2个屏幕大小)= 20次测试。如果您还需要在中等大小的设备上进行测试，情况会变得更糟；这导致(5种语言)* (2种平台)* (3种屏幕尺寸)= 30次测试或运行。这对开发人员来说太耗费时间和大量的工作。但是在CI和/或一些本地脚本的帮助下，所有这些作业都可以自动并行触发。这意味着测试结果将会更快地获得，而且几乎不需要开发人员付出任何努力。</p><p id="0173" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快照测试还有很多有用的用例，但是现在，让我们看看如何使用和集成<a class="ae kz" href="https://www.npmjs.com/package/pixels-catcher" rel="noopener ugc nofollow" target="_blank">像素捕捉器</a>项目。</p><h1 id="9dba" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">入门指南</h1><p id="c2c7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">每个项目都有预算和期限，这不是秘密。因此，使用简单而强大的工具会很有用。另一个要点是要有一个透明的工具，没有任何恶意软件，维护良好，对社区贡献开放。幸运的是，<a class="ae kz" href="https://www.npmjs.com/package/pixels-catcher" rel="noopener ugc nofollow" target="_blank">像素捕捉器</a>符合所有这些标准。</p><h1 id="4e4f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">要求</h1><p id="f8ee" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><a class="ae kz" href="https://www.npmjs.com/package/pixels-catcher" rel="noopener ugc nofollow" target="_blank">像素捕捉器</a>项目没有任何特定的要求，可以很容易地集成到任何现有的项目中。此外，由于另一个开源项目<a class="ae kz" href="https://www.npmjs.com/package/react-native-save-view" rel="noopener ugc nofollow" target="_blank"> react-native-save-view </a>，在<a class="ae kz" href="https://www.npmjs.com/package/pixels-catcher" rel="noopener ugc nofollow" target="_blank"> pixels-catcher </a>项目中使用的解决方案允许“隐藏”所有原生Android和iOS实现。因此，唯一需要的知识就是JavaScript。不需要Java(android)或swift(iOS)特定体验。这意味着任何React本地开发人员都可以使用它。</p><h1 id="dd3c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">综合</h1><p id="c779" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><a class="ae kz" href="https://www.npmjs.com/package/pixels-catcher" rel="noopener ugc nofollow" target="_blank">像素捕捉器</a>可以通过以下几个步骤集成到项目中:</p><p id="7c3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">将</strong> it作为npm的开发依赖项安装:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="4d77" class="mj lb it nm b gy nr ns l nt nu">$ npm install pixels-catcher --save-dev</span></pre><p id="0abb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或纱线:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="b4d1" class="mj lb it nm b gy nr ns l nt nu">$ yarn add --dev pixels-catcher</span></pre><p id="47df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">链接</strong><a class="ae kz" href="https://www.npmjs.com/package/react-native-save-view" rel="noopener ugc nofollow" target="_blank">react-native-save-view</a>依赖项(实现原生实现将任意react原生元素抓取到base64 image的依赖项):</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="8e47" class="mj lb it nm b gy nr ns l nt nu">$ react-native link react-native-save-view</span></pre><p id="9bdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从<a class="ae kz" href="https://github.com/facebook/react-native/releases/tag/v0.60.0" rel="noopener ugc nofollow" target="_blank"> RN 0.60 </a>开始，不再需要链接— <a class="ae kz" href="https://facebook.github.io/react-native/blog/2019/07/03/version-60" rel="noopener ugc nofollow" target="_blank">本机模块现在自动链接</a>。</p><p id="80a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在<code class="fe nj nk nl nm b">package.json</code>中配置</strong> it，用以下属性定义一个新的<code class="fe nj nk nl nm b">PixelsCatcher</code>属性:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="9a51" class="mj lb it nm b gy nr ns l nt nu">"PixelsCatcher": {<br/>  "activityName" : "ACTIVITY_NAME",<br/>  "apkFile"      : "PATH_TO_APK_FILE",<br/>  "emulatorName" : "EMULATOR_NAME",<br/>  "packageName"  : "ANDROID_PACKAGE_NAME",<br/>  "snapshotsPath": "PATH_TO_SNAPSHOTS_FILES"<br/>}</span></pre><p id="a5a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者，您可以创建一个<code class="fe nj nk nl nm b"><a class="ae kz" href="https://github.com/rumax/react-native-PixelsCatcher/blob/master/demo/pixels-catcher.json" rel="noopener ugc nofollow" target="_blank">pixels-catcher.json</a></code>文件并在那里配置您的选项。</p><h2 id="3f03" class="mj lb it bd lc mk ml dn lg mm mn dp lk km mo mp lo kq mq mr ls ku ms mt lw mu bi translated">添加测试</h2><p id="57b8" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">有一些可用的导入:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="9265" class="mj lb it nm b gy nr ns l nt nu">import {<br/>  registerSnapshot,<br/>  runSnapshots,<br/>  Snapshot,<br/>} from 'pixels-catcher';</span></pre><p id="0539" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其中<code class="fe nj nk nl nm b">Snapshot</code>是快照的“抽象”类。它需要实现<code class="fe nj nk nl nm b">renderContent</code>方法(<em class="nv">是呈现</em>的替代方法)，该方法应该呈现将被测试的所需组件或页面。和静态属性snapshotName，它定义了<code class="fe nj nk nl nm b">screenshot</code>的名称，并对应于参考图像的名称。</p><p id="eae1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，在一个基本的react本地项目中，快照的实现应该如下所示:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="2a1b" class="mj lb it nm b gy nr ns l nt nu">class AppSnapshot extends Snapshot&lt;*, *&gt; {<br/>  static snapshotName = 'AppSnapshot';</span><span id="4717" class="mj lb it nm b gy nw ns l nt nu">renderContent() {<br/>    return &lt;App /&gt;;<br/>  }<br/>}</span></pre><p id="11bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快照可以注册到:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="f240" class="mj lb it nm b gy nr ns l nt nu">registerSnapshot(AppSnapshot);</span></pre><p id="6273" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，可以测试任何React本地组件:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="547e" class="mj lb it nm b gy nr ns l nt nu">registerSnapshot(class AppSnapshot extends Snapshot&lt;*, *&gt; {<br/>  static snapshotName = 'Page';</span><span id="9c48" class="mj lb it nm b gy nw ns l nt nu">renderContent() {<br/>    return &lt;Page /&gt;;<br/>  }<br/>});</span><span id="52ed" class="mj lb it nm b gy nw ns l nt nu">registerSnapshot(class AppSnapshot extends Snapshot&lt;*, *&gt; {<br/>  static snapshotName = 'Footer';</span><span id="fb39" class="mj lb it nm b gy nw ns l nt nu">renderContent() {<br/>    return &lt;Footer /&gt;;<br/>  }<br/>});</span></pre><p id="fc73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注册所有必需的快照后，最后一步是运行所有快照:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="96d2" class="mj lb it nm b gy nr ns l nt nu">runSnapshots(PUT_YOUR_APP_NAME_HERE);</span></pre><p id="3526" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是集成和编写屏幕截图测试所需的全部内容。</p><h2 id="3fd7" class="mj lb it bd lc mk ml dn lg mm mn dp lk km mo mp lo kq mq mr ls ku ms mt lw mu bi translated">运行测试</h2><p id="e4ee" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">要运行测试，可以修改<code class="fe nj nk nl nm b">index.js</code>文件的内容，并且必须注册快照，而不是<code class="fe nj nk nl nm b">App</code>组件:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="b867" class="mj lb it nm b gy nr ns l nt nu">import { AppRegistry } from 'react-native';<br/>import App from './App';<br/>const useSnapshotTest = true;<br/>if (! useSnapshotTest) {<br/>  AppRegistry.registerComponent('app', () =&gt; App);<br/>} else {<br/>  require('./indexSnapshot');<br/>}</span></pre><p id="d9b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其中所有快照都在<code class="fe nj nk nl nm b">indexSnapshot.js</code>文件中实现。</p><p id="20b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注册和运行快照的另一种方法是将<code class="fe nj nk nl nm b">indexSnapshot.js</code>文件指定为入口文件。如果你需要更多这方面的信息，你可以查看<a class="ae kz" href="https://github.com/rumax/react-native-PixelsCatcher/tree/master/demo" rel="noopener ugc nofollow" target="_blank">演示项目</a>项目。</p><p id="2935" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">之后，启动服务器:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="e9c8" class="mj lb it nm b gy nr ns l nt nu">./node_modules/.bin/pixels-catcher dev</span></pre><p id="ebd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe nj nk nl nm b">react-native run-ios</code>或<code class="fe nj nk nl nm b">react-native run-android</code>命令照常运行应用程序。</p><p id="b17b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦应用程序启动，所有的快照将被一个接一个地渲染，结果将被报告给本地服务器，使用捕获图像的<code class="fe nj nk nl nm b">base64</code>数据。最终报告将打印到控制台，所有结果将存储到<code class="fe nj nk nl nm b">PixelsCatcher.snapshotsPath</code>中指定的文件夹，其中:</p><ul class=""><li id="0193" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated"><code class="fe nj nk nl nm b">uploads</code> -是实际结果</li><li id="3658" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><code class="fe nj nk nl nm b">refImages</code> -是你的参考图片</li><li id="520f" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><code class="fe nj nk nl nm b">diffs</code> -是差异，用红色像素突出显示</li></ul><p id="e8ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首次运行快照后，所有测试都将失败。这是因为还没有参考图像。要解决这个问题，请检查包含所有结果的<code class="fe nj nk nl nm b">uploads</code>文件夹。所以在<code class="fe nj nk nl nm b">App</code>组件的情况下，结果将是:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/e747f471cf12ceae0c3f1e4e3707ea93.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*9K1o6gAxTQut2NODdmVKqw.png"/></div></figure><p id="76b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果当前结果符合预期，将文件从<code class="fe nj nk nl nm b">uploads</code>文件夹移动到<code class="fe nj nk nl nm b">refImages</code>文件夹并重新开始测试。现在所有的考验都将过去。</p><p id="baa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果某些测试失败，检查<code class="fe nj nk nl nm b">diffs</code>文件夹会很有用，其中包含突出显示参考图像和实际结果不匹配的图像。例如，结果可能是:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c95a5dae762f17f641d8cb9642e22327.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Xv0gwTcVyTMD63GqFrgUiw.png"/></div></figure><p id="c6ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其中不匹配用红色突出显示(在这种情况下是<code class="fe nj nk nl nm b">One</code>、<code class="fe nj nk nl nm b">then</code>和<code class="fe nj nk nl nm b">Help</code>)。它可以是一种新的颜色，一个改变的尺寸或者它的位置被移动了一点，等等。这就是变化的确切位置，如果这是预期的结果，就必须彻底检查它。使用<a class="ae kz" href="https://www.npmjs.com/package/pixelmatch" rel="noopener ugc nofollow" target="_blank">像素匹配</a>计算差值。</p><h1 id="84ba" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/df85c2e8629720a0eb383373f2250444.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*ER6JtwTlxLYbhYEMw6_H_Q.jpeg"/></div></figure><p id="b7e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上述解决方案表明，将<a class="ae kz" href="https://www.npmjs.com/package/pixels-catcher" rel="noopener ugc nofollow" target="_blank"> pixels-catcher </a>项目与任何现有的react原生应用程序集成和使用非常容易，因此可以更好地控制开发流程，在应用程序发布之前对变更更有信心，等等。在CI集成的情况下，可以获得额外的检查和快速反馈。但最重要的是，该应用程序将保持像素完美，并将继续吸引用户。</p><p id="fa1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！如果您想尝试一下，您可以查看包含工作示例的<a class="ae kz" href="https://github.com/rumax/react-native-PixelsCatcher/tree/master/demo" rel="noopener ugc nofollow" target="_blank">演示项目</a>。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="ee0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nv">原载于2019年9月10日</em><a class="ae kz" href="https://medium.com/ing-blog/pixels-matter-or-easy-ui-screenshot-testing-in-react-native-6e41ba91b225" rel="noopener"><em class="nv">https://medium.com</em></a><em class="nv">。</em></p></div></div>    
</body>
</html>