<html>
<head>
<title>How to run IPv6-enabled Docker containers on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在AWS上运行支持IPv6的Docker容器</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-run-ipv6-enabled-docker-containers-on-aws-87e090ab0397?source=collection_archive---------4-----------------------#2019-01-22">https://itnext.io/how-to-run-ipv6-enabled-docker-containers-on-aws-87e090ab0397?source=collection_archive---------4-----------------------#2019-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dfe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您想忘记NAT并运行容器而不必转换IP地址吗？然后你需要公共IP地址，很多。不幸的是，每个IPv4地址<a class="ae kl" href="http://www.circleid.com/posts/20181024_the_2018_ipv4_market_third_quarter_report/" rel="noopener ugc nofollow" target="_blank">的价格超过了20美元</a>，所以你不会得到你的每个集装箱一个。另一方面，IPv6地址并不缺乏，所以理论上，您可以为任意多个容器分配一个唯一的IPv6地址。</p><p id="4791" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">早在1981年<a class="ae kl" href="https://tools.ietf.org/html/rfc791" rel="noopener ugc nofollow" target="_blank"/>就定义了有助于将博客文章发送到你的设备的互联网协议(<strong class="jp ir"> IP </strong>)时，识别源和目的地的互联网地址被指定为固定长度的四个八位字节(<strong class="jp ir"> 32位</strong>)。这实际上是协议的第四个版本，因此我们将这些地址称为IP版本4 ( <strong class="jp ir"> IPv4 </strong>)地址。</p><p id="2d94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大约10年后的1992年<a class="ae kl" href="https://tools.ietf.org/html/rfc1338" rel="noopener ugc nofollow" target="_blank"/>，很明显我们最终会用完32位IPv4地址，所以在1994年3月<a class="ae kl" href="https://tools.ietf.org/html/rfc1597" rel="noopener ugc nofollow" target="_blank"/>中，为了保留IP地址空间，定义了可重复使用的<strong class="jp ir">私有IP </strong>地址。您可以使用这些来识别企业专用的主机。如果这些主机中的任何一台需要连接到外部主机，其地址需要转换为<strong class="jp ir">a-公共</strong> — <strong class="jp ir"> IP </strong>地址，该地址是全局唯一的。这个过程被称为网络地址转换(<strong class="jp ir"> NAT </strong>)，几个月后<a class="ae kl" href="https://tools.ietf.org/html/rfc1631" rel="noopener ugc nofollow" target="_blank">被定义为</a>。</p><p id="c905" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大约一年后(1995年)出现了新版本的互联网协议，提供了扩展的寻址能力。我们称之为<strong class="jp ir"> IPv6 </strong>，它将IP地址的大小从32位增加到<strong class="jp ir"> 128位</strong>。</p><blockquote class="km kn ko"><p id="350d" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">问题是什么？IPv6与IPv4不向后兼容，因此过渡非常非常缓慢……20多年来，当前的<a class="ae kl" href="https://www.google.com/intl/en/ipv6/statistics.html" rel="noopener ugc nofollow" target="_blank">采用了大约22% </a>。</p></blockquote><p id="f267" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论如何，这篇文章的目的是演示如何使用IPv6在云提供商(AWS)上运行容器。这是我上一篇文章中未解决的问题:<a class="ae kl" href="https://medium.com/@nleiva/kubernetes-multi-cluster-networking-made-simple-c8f26827813" rel="noopener"> Kubernetes使多集群网络变得简单</a>。目标拓扑如下。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/0762f0a757ddf04fd5da08628c1dd321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3u4QZGhjH8VH_X3fzMWfQ.png"/></div></div></figure><p id="d34c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我们目前不能分解分配给<code class="fe lf lg lh li b">VPC</code> ( <code class="fe lf lg lh li b">/56</code>)的IPv6地址块，以便在AWS中将更小的子网(<code class="fe lf lg lh li b">/64</code>)分配给实例，但是我们可以使用弹性网络接口(<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html" rel="noopener ugc nofollow" target="_blank"/>)将连续的IPv6地址块关联到一个实例。这将生成一个大于<code class="fe lf lg lh li b">/64</code>(在本例中为<code class="fe lf lg lh li b">/126</code>)的IPv6前缀长度，这在局域网中不是一个最佳实践，所以对此要有所保留。</p><p id="b794" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，这就是我们将要做的:</p><ol class=""><li id="650d" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">创建附加有<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html" rel="noopener ugc nofollow" target="_blank"> ENI </a>的<a class="ae kl" href="https://aws.amazon.com/ec2/" rel="noopener ugc nofollow" target="_blank"> EC2 </a>实例。</li><li id="eaaa" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">在实例上重新配置IPv6寻址并安装Docker。</li><li id="cce9" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">仅使用IPv6运行几个容器。</li></ol><h1 id="c20c" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">创建附加了ENI的EC2例程</h1><p id="66a0" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">我们将使用AWS<a class="ae kl" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank">CLI</a><a class="ae kl" href="https://docs.aws.amazon.com/cli/latest/reference/ec2/create-network-interface.html" rel="noopener ugc nofollow" target="_blank">create-network-interface</a>为我们的每个实例创建一个<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html" rel="noopener ugc nofollow" target="_blank"> ENI </a>，其中包含一个主IPv6地址和一个连续的IPv6地址块。这些地址将来自一个已知的<code class="fe lf lg lh li b">Subnet</code>。我们还将对我们的<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html" rel="noopener ugc nofollow" target="_blank"> ENI </a>应用一个<code class="fe lf lg lh li b">Security Group</code>。</p><h2 id="3876" class="na ly iq bd lz nb nc dn md nd ne dp mh jy nf ng ml kc nh ni mp kg nj nk mt nl bi translated">子网、安全组和ENI</h2><p id="9b39" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">如果你还没有一个支持IPv6的<code class="fe lf lg lh li b">VPC</code>，请看看<a class="ae kl" href="https://docs.aws.amazon.com/vpc/latest/userguide/get-started-ipv6.html" rel="noopener ugc nofollow" target="_blank">亚马逊VPC IPv6入门</a>，这样你就可以在变量<code class="fe lf lg lh li b">subnetId</code>和<code class="fe lf lg lh li b">sgId</code>中存储<code class="fe lf lg lh li b">Subnet</code>和<code class="fe lf lg lh li b">Security Group</code>的ID。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="4018" class="na ly iq li b gy nq nr l ns nt">subnetId=subnet-09a931730fa9exxxx<br/>sgId=sg-0eaf439572982yyyy</span></pre><p id="eff5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe lf lg lh li b">instance-1</code>，我们将保留地址<code class="fe lf lg lh li b">::1:1</code>、<code class="fe lf lg lh li b">::8</code>、<code class="fe lf lg lh li b">::9</code>、<code class="fe lf lg lh li b">::a</code>和<code class="fe lf lg lh li b">::b</code>。为了便于阅读，我去掉了子网前缀。第一个地址将用于实例，其他四个地址将构成容器将连接到的linux桥所需的<code class="fe lf lg lh li b">/126</code>。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="5cbb" class="na ly iq li b gy nq nr l ns nt">2600:1f18:47b:ca03::1:1<br/>2600:1f18:47b:ca03::8<br/>2600:1f18:47b:ca03::9<br/>2600:1f18:47b:ca03::a<br/>2600:1f18:47b:ca03::b</span></pre><p id="2716" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的<code class="fe lf lg lh li b">instance-2</code>，我们将保留地址<code class="fe lf lg lh li b">::2:2</code>、<code class="fe lf lg lh li b">::c</code>、<code class="fe lf lg lh li b">::d</code>、<code class="fe lf lg lh li b">::e</code>和<code class="fe lf lg lh li b">::f</code>。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="4a55" class="na ly iq li b gy nq nr l ns nt">2600:1f18:47b:ca03::2:2<br/>2600:1f18:47b:ca03::c<br/>2600:1f18:47b:ca03::d<br/>2600:1f18:47b:ca03::e<br/>2600:1f18:47b:ca03::f</span></pre><p id="4407" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些信息，我们执行<a class="ae kl" href="https://docs.aws.amazon.com/cli/latest/reference/ec2/create-network-interface.html" rel="noopener ugc nofollow" target="_blank">create-network-interface</a>命令。但是，我们还需要存储<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html" rel="noopener ugc nofollow" target="_blank"> ENI </a>的ID用于后面的操作，所以我们<code class="fe lf lg lh li b">query</code> <code class="fe lf lg lh li b">NetworkInterface.NetworkInterfaceId</code>并将返回值存储在<code class="fe lf lg lh li b">eni1</code>中用于<code class="fe lf lg lh li b">instance-1</code>。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="3685" class="na ly iq li b gy nq nr l ns nt"><strong class="li ir">eni1</strong>=`aws ec2 create-network-interface \<br/>  --subnet-id <strong class="li ir">$subnetId</strong> \<br/>  --description "My IPv6 ENI 1" \<br/>  --groups <strong class="li ir">$sgId</strong> \<br/>  --ipv6-addresses \<br/>  Ipv6Address=2600:1f18:47b:ca03<strong class="li ir">::1:1</strong> \<br/>  Ipv6Address=2600:1f18:47b:ca03<strong class="li ir">::8</strong> \<br/>  Ipv6Address=2600:1f18:47b:ca03<strong class="li ir">::9</strong> \<br/>  Ipv6Address=2600:1f18:47b:ca03<strong class="li ir">::a</strong> \<br/>  Ipv6Address=2600:1f18:47b:ca03<strong class="li ir">::b</strong> \<br/>  --query <strong class="li ir">'NetworkInterface.NetworkInterfaceId'</strong> \<br/>  --output text`</span></pre><p id="4e46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以按如下方式检查返回值。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="3147" class="na ly iq li b gy nq nr l ns nt">$ echo $eni1<br/>eni-08ba7c2f50a22a160</span></pre><p id="153e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对第二个<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html" rel="noopener ugc nofollow" target="_blank"> ENI </a>重复上述步骤。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="de55" class="na ly iq li b gy nq nr l ns nt"><strong class="li ir">eni2</strong>=`aws ec2 create-network-interface \<br/>  --subnet-id <strong class="li ir">$subnetId</strong> \<br/>  --description "My IPv6 ENI 2" \<br/>  --groups <strong class="li ir">$sgId</strong> \<br/>  --ipv6-addresses \<br/>  Ipv6Address=2600:1f18:47b:ca03<strong class="li ir">::2:2</strong> \<br/>  Ipv6Address=2600:1f18:47b:ca03<strong class="li ir">::c</strong> \<br/>  Ipv6Address=2600:1f18:47b:ca03<strong class="li ir">::d</strong> \<br/>  Ipv6Address=2600:1f18:47b:ca03<strong class="li ir">::e</strong> \<br/>  Ipv6Address=2600:1f18:47b:ca03<strong class="li ir">::f</strong> \<br/>  --query <strong class="li ir">'NetworkInterface.NetworkInterfaceId'</strong> \<br/>  --output text`</span></pre><h2 id="9b59" class="na ly iq bd lz nb nc dn md nd ne dp mh jy nf ng ml kc nh ni mp kg nj nk mt nl bi translated">启动附加了ENI的实例</h2><p id="f3bd" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">Amazon EC2使用公钥加密来加密和解密登录信息[ <a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html" rel="noopener ugc nofollow" target="_blank"> Amazon EC2密钥对</a> ]，因此您需要一个公钥和一个私钥来连接到实例。</p><p id="cb32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用一个现有的文件，或者创建一个，如下所示，其中<code class="fe lf lg lh li b">~/.ssh/id_rsa.pub</code>是您的公钥文件的位置。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="2c9b" class="na ly iq li b gy nq nr l ns nt">aws ec2 import-key-pair \<br/>  --key-name <strong class="li ir">&lt;name&gt;</strong> \<br/>  --public-key-material <strong class="li ir">file://~/.ssh/id_rsa.pub</strong></span></pre><p id="2d1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将密钥对的名称存储在一个名为<code class="fe lf lg lh li b">AWS_SSH_KEY</code>的变量中。您可以手动分配名称，就像您刚才选择它一样，或者使用<code class="fe lf lg lh li b">describe-key-pairs</code>从AWS中检索它。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="f477" class="na ly iq li b gy nq nr l ns nt">AWS_SSH_KEY=$(aws ec2 describe-key-pairs --query KeyPairs[0].KeyName --output text)</span></pre><p id="d9fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是创建实例的时候了。我们将使用<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html" rel="noopener ugc nofollow" target="_blank"> AMI </a> ID <code class="fe lf lg lh li b">ami-0ac019f4fcb7cb7e6</code>，也就是<code class="fe lf lg lh li b">Ubuntu Server 18.04 LTS</code>，实例类型<code class="fe lf lg lh li b">r5d.large</code>。</p><p id="228d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以分配给一个实例的IP地址数量受到其类型的限制，因此对于<code class="fe lf lg lh li b">r5d.large</code>来说，我们可以分配多达10个IPv6地址，这对于这个小型的概念验证来说已经足够了。参见<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI" rel="noopener ugc nofollow" target="_blank">每个实例类型的每个网络接口的IP地址</a>中实例类型的详细信息。</p><p id="d503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还想附加我们之前创建的<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html" rel="noopener ugc nofollow" target="_blank"> ENI </a>，它的ID存储在<code class="fe lf lg lh li b">eni1</code>中。我们将从AWS收到的实例ID保存在<code class="fe lf lg lh li b">vm1</code>中(我们正在查询<code class="fe lf lg lh li b">Instances[0].InstanceId</code>)。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="1e3f" class="na ly iq li b gy nq nr l ns nt"><strong class="li ir">vm1</strong>=`aws ec2 run-instances \<br/>  --key-name <strong class="li ir">$AWS_SSH_KEY</strong> \<br/>  --image-id <strong class="li ir">ami-0ac019f4fcb7cb7e6</strong> \<br/>  --instance-type <strong class="li ir">r5d.large</strong> \<br/>  --network-interfaces <strong class="li ir">DeviceIndex=0,NetworkInterfaceId=$eni1</strong> \<br/>  --query <strong class="li ir">'Instances[0].InstanceId'</strong> \<br/>  --output text`</span></pre><p id="3687" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe lf lg lh li b">instance-2</code>也是如此。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="f55d" class="na ly iq li b gy nq nr l ns nt"><strong class="li ir">vm2</strong>=`aws ec2 run-instances \<br/>  --key-name <strong class="li ir">$AWS_SSH_KEY</strong> \<br/>  --image-id <strong class="li ir">ami-0ac019f4fcb7cb7e6</strong> \<br/>  --instance-type <strong class="li ir">r5d.large</strong> \<br/>  --network-interfaces <strong class="li ir">DeviceIndex=0,NetworkInterfaceId=$eni2</strong> \<br/>  --query <strong class="li ir">'Instances[0].InstanceId'</strong> \<br/>  --output text`</span></pre><p id="3355" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们获取<code class="fe lf lg lh li b">instance-1</code>的第一个公有IPv6地址，并将其存储在<code class="fe lf lg lh li b">ip1</code>中。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="144e" class="na ly iq li b gy nq nr l ns nt"><strong class="li ir">ip1</strong>=`aws ec2 describe-instances \<br/>  --filter Name=<strong class="li ir">instance-id</strong>,Values=<strong class="li ir">$vm1</strong> \<br/>  --output text \<br/>  --query 'Reservations[].Instances[].NetworkInterfaces[].\<br/><strong class="li ir">Ipv6Addresses[0].Ipv6Address</strong>'`</span></pre><p id="a168" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您现在可以使用<code class="fe lf lg lh li b">ssh -i &lt;private key file&gt; ubuntu@${ip1}</code>访问<code class="fe lf lg lh li b">instance-1</code>。类似地，对于<code class="fe lf lg lh li b">instance-2</code>，您可以使用以下命令检索第一个公共IPv6地址:</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="b316" class="na ly iq li b gy nq nr l ns nt"><strong class="li ir">ip2</strong>=`aws ec2 describe-instances \<br/>  --filter Name=<strong class="li ir">instance-id</strong>,Values=<strong class="li ir">$vm2</strong> \<br/>  --output text \<br/>  --query 'Reservations[].Instances[].NetworkInterfaces[].\<br/><strong class="li ir">Ipv6Addresses[0].Ipv6Address</strong>'`</span></pre><p id="1a46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以你可以用<code class="fe lf lg lh li b">ssh -i &lt;private key file&gt; ubuntu@${ip2}</code>来访问它。</p><h2 id="6b0a" class="na ly iq bd lz nb nc dn md nd ne dp mh jy nf ng ml kc nh ni mp kg nj nk mt nl bi translated">使实例支持IPv6</h2><p id="297d" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">我们需要在我们的实例中安装软件。不幸的是，这不可能马上实现，因为我们的<code class="fe lf lg lh li b">sources.list</code>文件带有到<code class="fe lf lg lh li b"><a class="ae kl" href="http://us-east-1.ec2.archive.ubuntu.com/ubuntu/" rel="noopener ugc nofollow" target="_blank">us-east-1.ec2.archive.ubuntu.com</a></code>的链接，这些链接不能解析为IPv6地址。👎我们需要替换这些来使用正确支持IPv6的<code class="fe lf lg lh li b"><a class="ae kl" href="http://us-east-1.ec2.archive.ubuntu.com/ubuntu/" rel="noopener ugc nofollow" target="_blank">archive.ubuntu.com</a></code>。你可以用<code class="fe lf lg lh li b">sed</code>做到这一点。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="7ae5" class="na ly iq li b gy nq nr l ns nt">sudo sed -i 's/us-east-1\.ec2\.//g' /etc/apt/sources.list</span></pre><p id="3014" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在您可以将<code class="fe lf lg lh li b">apt-get</code>与选项<code class="fe lf lg lh li b">Acquire::ForceIPv6=true</code>一起使用。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="9bc2" class="na ly iq li b gy nq nr l ns nt">$ <strong class="li ir">sudo apt-get -o Acquire::ForceIPv6=true update</strong><br/>Get:1 <a class="ae kl" href="http://archive.ubuntu.com/ubuntu" rel="noopener ugc nofollow" target="_blank">http://archive.ubuntu.com/ubuntu</a> bionic InRelease [242 kB]<br/>Get:2 <a class="ae kl" href="http://security.ubuntu.com/ubuntu" rel="noopener ugc nofollow" target="_blank">http://security.ubuntu.com/ubuntu</a> bionic-security InRelease [83.2 kB]<br/>Get:3 <a class="ae kl" href="http://archive.ubuntu.com/ubuntu" rel="noopener ugc nofollow" target="_blank">http://archive.ubuntu.com/ubuntu</a> bionic-updates InRelease [88.7 kB]<br/>...<br/>Get:38 <a class="ae kl" href="http://archive.ubuntu.com/ubuntu" rel="noopener ugc nofollow" target="_blank">http://archive.ubuntu.com/ubuntu</a> bionic-backports/universe Sources [2068 B]<br/>Get:39 <a class="ae kl" href="http://archive.ubuntu.com/ubuntu" rel="noopener ugc nofollow" target="_blank">http://archive.ubuntu.com/ubuntu</a> bionic-backports/universe amd64 Packages [3468 B]<br/>Get:40 <a class="ae kl" href="http://archive.ubuntu.com/ubuntu" rel="noopener ugc nofollow" target="_blank">http://archive.ubuntu.com/ubuntu</a> bionic-backports/universe Translation-en [1604 B]<br/>Fetched 28.4 MB in 5s (5363 kB/s)<br/>Reading package lists... Done</span></pre><h1 id="cd4b" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">在实例上重新配置IPv6寻址并安装Docker</h1><p id="61e4" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">现在，我们的实例有一个带有多个IPv6地址的接口。<code class="fe lf lg lh li b">instance-1</code>显示五个<code class="fe lf lg lh li b">/128</code> IPv6地址。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="d596" class="na ly iq li b gy nq nr l ns nt">$ <strong class="li ir">ip add</strong><br/>...<br/>2: ens5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP group default qlen 1000<br/>...<br/>    inet6 <strong class="li ir">2600:1f18:47b:ca03::1:1</strong>/128 scope global dynamic noprefixroute<br/>       valid_lft 385sec preferred_lft 85sec<br/>    inet6 <strong class="li ir">2600:1f18:47b:ca03::8</strong>/128 scope global dynamic noprefixroute<br/>       valid_lft 385sec preferred_lft 85sec<br/>    inet6 <strong class="li ir">2600:1f18:47b:ca03::9</strong>/128 scope global dynamic noprefixroute<br/>       valid_lft 385sec preferred_lft 85sec<br/>    inet6 <strong class="li ir">2600:1f18:47b:ca03::a</strong>/128 scope global dynamic noprefixroute<br/>       valid_lft 385sec preferred_lft 85sec<br/>    inet6 <strong class="li ir">2600:1f18:47b:ca03::b</strong>/128 scope global dynamic noprefixroute<br/>       valid_lft 385sec preferred_lft 85sec</span></pre><h2 id="0c82" class="na ly iq bd lz nb nc dn md nd ne dp mh jy nf ng ml kc nh ni mp kg nj nk mt nl bi translated">新IPv6地址分配</h2><p id="b528" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">我们只希望主接口中有一个(<code class="fe lf lg lh li b">/64</code>)和linux桥(docker0)中的一个<code class="fe lf lg lh li b">/126</code>来分配这个范围内的容器地址。为此，我们将在<code class="fe lf lg lh li b">/etc/netplan/50-cloud-init.yaml</code>编辑<a class="ae kl" href="https://netplan.io/" rel="noopener ugc nofollow" target="_blank">网络计划</a>的配置文件。它最初看起来像这样:</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="ec7e" class="na ly iq li b gy nq nr l ns nt">network:<br/>  version: 2<br/>  ethernets:<br/>    ens5:<br/>      dhcp4: true<br/>      <strong class="li ir">dhcp6: true</strong><br/>      match:<br/>        macaddress: 12:fb:b4:8b:15:f8<br/>      set-name: ens5</span></pre><p id="836e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只从中删除了<code class="fe lf lg lh li b">dhcp6</code>语句。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="9514" class="na ly iq li b gy nq nr l ns nt">network:<br/>  version: 2<br/>  ethernets:<br/>    ens5:<br/>      dhcp4: true<br/>      match:<br/>        macaddress: 12:fb:b4:8b:15:f8<br/>      set-name: ens5</span></pre><p id="8f72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便提一下，并且完全<strong class="jp ir">可选</strong>，实例的<code class="fe lf lg lh li b">MAC</code>地址和与之关联的IPv6地址可以随时从<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html#instancedata-data-retrieval" rel="noopener ugc nofollow" target="_blank">实例元数据</a>中检索。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="f1e7" class="na ly iq li b gy nq nr l ns nt">$ <strong class="li ir">curl http://169.254.169.254/latest/meta-data/network/interfaces/macs/</strong><br/>12:fb:b4:8b:15:f8</span></pre><p id="5a7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且:</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="d175" class="na ly iq li b gy nq nr l ns nt">$ <strong class="li ir">curl http://169.254.169.254/latest/meta-data/network/interfaces/macs/12:fb:b4:8b:15:f8/ipv6s/</strong><br/>2600:1f18:47b:ca03:0:0:0:8<br/>2600:1f18:47b:ca03:0:0:0:9<br/>2600:1f18:47b:ca03:0:0:0:a<br/>2600:1f18:47b:ca03:0:0:0:b<br/>2600:1f18:47b:ca03:0:0:1:1</span></pre><blockquote class="km kn ko"><p id="cc9e" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">⚠️:是的，<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html#instancedata-data-retrieval" rel="noopener ugc nofollow" target="_blank">实例元数据</a>是一项仅支持IPv4的服务👎。好消息是你不需要一个公共IPv4地址来访问它。</p></blockquote><p id="8efb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续实例的接口配置，我们还需要在<code class="fe lf lg lh li b">/etc/netplan/60-ipv6-static.yaml</code>为IPv6配置创建一个单独的文件。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="cf05" class="na ly iq li b gy nq nr l ns nt">network:<br/>  version: 2<br/>  ethernets:<br/>    ens5:<br/>      <strong class="li ir">dhcp6: no</strong><br/>      <strong class="li ir">accept-ra: no</strong><br/>      addresses:<br/>      - <strong class="li ir">2600:1f18:47b:ca03::1:1/64</strong><br/>      gateway6: <strong class="li ir">fe80::1066:30ff:feb8:c008</strong></span></pre><p id="3523" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们禁用了DHCPv6 ( <code class="fe lf lg lh li b">dhcp6: no</code>)并丢弃了IPv6路由器广告(<code class="fe lf lg lh li b">accept-ra: no</code>)。网关信息(<code class="fe lf lg lh li b">fe80::1066:30ff:feb8:c008</code>)来自<code class="fe lf lg lh li b">iproute2</code>命令(似乎在EC2中总是相同的)。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="734b" class="na ly iq li b gy nq nr l ns nt">$ <strong class="li ir">ip -6 route | grep default</strong><br/>default via <strong class="li ir">fe80::1066:30ff:feb8:c008</strong> dev ens5 proto ra metric 100 pref medium</span></pre><p id="433b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，用<code class="fe lf lg lh li b">netplan apply</code>应用我们的配置更改。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="a36e" class="na ly iq li b gy nq nr l ns nt">sudo netplan --debug apply</span></pre><p id="2ee1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用相应的地址对<code class="fe lf lg lh li b">instance-2</code>重复。</p><h2 id="9147" class="na ly iq bd lz nb nc dn md nd ne dp mh jy nf ng ml kc nh ni mp kg nj nk mt nl bi translated">安装Docker</h2><p id="4d0e" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">你可以按照<a class="ae kl" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce" rel="noopener ugc nofollow" target="_blank">官方安装指南</a>或者只运行以下命令。注意<code class="fe lf lg lh li b">apt-get</code>的选项<code class="fe lf lg lh li b">Acquire::ForceIPv6=true</code>。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="e80f" class="na ly iq li b gy nq nr l ns nt">curl -fsSL <a class="ae kl" href="https://download.docker.com/linux/ubuntu/gpg" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/ubuntu/gpg</a> | sudo apt-key add -<br/>sudo add-apt-repository "deb [arch=amd64] <a class="ae kl" href="https://download.docker.com/linux/ubuntu" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable"<br/>sudo apt-get <strong class="li ir">-o Acquire::ForceIPv6=true </strong>update<br/>sudo apt-get <strong class="li ir">-o Acquire::ForceIPv6=true </strong>install -y docker-ce<br/>sudo usermod -aG docker ${USER}</span></pre><p id="234b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要注销并重新登录，以使用户更改生效。</p><p id="fda9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在<code class="fe lf lg lh li b">/etc/docker/daemon.json</code>编辑/创建一个Docker配置文件，开始为我们的容器分配IPv6地址。对于<code class="fe lf lg lh li b">instance-1</code>应该是这样的。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="d2c4" class="na ly iq li b gy nq nr l ns nt">{<br/>  "ipv6": true,<br/>  "fixed-cidr-v6": "2600:1f18:47b:ca03::8/126"<br/>}</span></pre><p id="2e8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后重新启动守护程序以应用更改；<code class="fe lf lg lh li b">sudo systemctl restart docker</code>。我们现在已经成功地在主接口和Docker网桥之间分割了ENI IPv6地址分配。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="f4ef" class="na ly iq li b gy nq nr l ns nt">$ <strong class="li ir">ip add</strong><br/>...<br/>2: <strong class="li ir">ens5</strong>: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP group default qlen 1000<br/>...<br/>    inet6 <strong class="li ir">2600:1f18:47b:ca03::1:1/64</strong> scope global<br/>       valid_lft forever preferred_lft forever<br/>...<br/>3: <strong class="li ir">docker0</strong>: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default<br/>...<br/>    inet6 <strong class="li ir">2600:1f18:47b:ca03::9/126</strong> scope global tentative<br/>       valid_lft forever preferred_lft forever<br/>...</span></pre><p id="509c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对<code class="fe lf lg lh li b">instance-2</code>做同样的操作，用<code class="fe lf lg lh li b">fixed-cidr-v6</code> = <code class="fe lf lg lh li b">::c/126</code>。</p><h1 id="160a" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">仅使用IPv6运行几个容器</h1><p id="6713" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">我们准备运行容器。或者至少我是这么想的。原来<code class="fe lf lg lh li b">registry-1.docker.io</code>和<code class="fe lf lg lh li b">hub.docker.com</code>不支持IPv6，所以我们无法从中获取Docker镜像。👎</p><h2 id="7b18" class="na ly iq bd lz nb nc dn md nd ne dp mh jy nf ng ml kc nh ni mp kg nj nk mt nl bi translated">运行映像</h2><p id="136f" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">我们是不是走进了死胡同？不，谷歌容器注册来拯救我们！→ <code class="fe lf lg lh li b">gcr.io/gcp-runtimes/ubuntu_18_0_4:latest</code>。让我们在每个实例上运行这个。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="de64" class="na ly iq li b gy nq nr l ns nt">docker run -it --rm gcr.io/gcp-runtimes/ubuntu_18_0_4:latest bash</span></pre><p id="b7ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在每个容器中安装<code class="fe lf lg lh li b">ping</code>和<code class="fe lf lg lh li b">iproute2</code>进行一些连通性测试并检查路由表。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="6575" class="na ly iq li b gy nq nr l ns nt">apt-get <strong class="li ir">-o Acquire::ForceIPv6=true </strong>update<br/>apt-get <strong class="li ir">-o Acquire::ForceIPv6=true </strong>install iputils-ping iproute2 -y</span></pre><p id="139d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们已经验证了实例可以通过IPv6访问互联网(通过<code class="fe lf lg lh li b">apt-get</code>)。让我们看看分配的IP地址；我们在<code class="fe lf lg lh li b">instance-1</code> ( <code class="fe lf lg lh li b">container-1</code>)的容器中得到<code class="fe lf lg lh li b">::a </code>。类似地，我们在运行于<code class="fe lf lg lh li b">instance-2</code> ( <code class="fe lf lg lh li b">container-2</code>)的容器中得到<code class="fe lf lg lh li b">::e</code>。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="6555" class="na ly iq li b gy nq nr l ns nt">root@d7c9480161f9:/# <strong class="li ir">ip add</strong><br/>...<br/>4: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default<br/>...<br/>    inet6 <strong class="li ir">2600:1f18:47b:ca03::a/126</strong> scope global nodad<br/>       valid_lft forever preferred_lft forever<br/>...</span></pre><p id="664c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更清楚地说明这一点，我们可以通过IPv6 ping互联网中的主机。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="75e3" class="na ly iq li b gy nq nr l ns nt">root@d7c9480161f9:/# <strong class="li ir">ping6 ipv6-test.com -c 1</strong><br/>PING ipv6-test.com(agaric.t0x.net (2001:41d0:8:e8ad::1)) 56 data bytes<br/>64 bytes from agaric.t0x.net (2001:41d0:8:e8ad::1): icmp_seq=1 ttl=46 time=78.7 ms</span><span id="a655" class="na ly iq li b gy nu nr l ns nt">--- ipv6-test.com ping statistics ---<br/>1 packets transmitted, 1 received, <strong class="li ir">0% packet loss</strong>, time 0ms<br/>rtt min/avg/max/mdev = 78.788/78.788/78.788/0.000 ms</span></pre><p id="14da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在让我们从<code class="fe lf lg lh li b">container-1</code>(<code class="fe lf lg lh li b">5312fff41595</code>)ping<code class="fe lf lg lh li b">container-2</code>(<code class="fe lf lg lh li b">d7c9480161f9</code>)。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="8351" class="na ly iq li b gy nq nr l ns nt">root@d7c9480161f9:/# <strong class="li ir">ping6 2600:1f18:47b:ca03::e -c 1</strong><br/>PING 2600:1f18:47b:ca03::e(2600:1f18:47b:ca03::e) 56 data bytes<br/>64 bytes from 2600:1f18:47b:ca03::e: icmp_seq=1 ttl=62 time=0.250 ms</span><span id="5b5e" class="na ly iq li b gy nu nr l ns nt">--- 2600:1f18:47b:ca03::e ping statistics ---<br/>1 packets transmitted, 1 received, <strong class="li ir">0% packet loss</strong>, time 0ms<br/>rtt min/avg/max/mdev = 0.250/0.250/0.250/0.000 ms</span></pre><p id="450f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反过来(<code class="fe lf lg lh li b">container-2</code>到<code class="fe lf lg lh li b">container-1)</code>，以防万一。一切正常。😎</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="1dcd" class="na ly iq li b gy nq nr l ns nt">root@5312fff41595:/#  <strong class="li ir">ping6 2600:1f18:47b:ca03::a -c 1</strong><br/>PING 2600:1f18:47b:ca03::a(2600:1f18:47b:ca03::a) 56 data bytes<br/>64 bytes from 2600:1f18:47b:ca03::a: icmp_seq=1 ttl=62 time=0.263 ms</span><span id="66b4" class="na ly iq li b gy nu nr l ns nt">--- 2600:1f18:47b:ca03::a ping statistics ---<br/>1 packets transmitted, 1 received, <strong class="li ir">0% packet loss</strong>, time 0ms<br/>rtt min/avg/max/mdev = 0.263/0.263/0.263/0.000 ms</span></pre><p id="d17f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这对您不起作用，请确保应用于<a class="ae kl" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html" rel="noopener ugc nofollow" target="_blank"> ENI </a>的<code class="fe lf lg lh li b">Security Group</code>允许来自您的实例的IPv6 ICMP。我专门创建了一个入站<code class="fe lf lg lh li b">Custom ICMP Rule — IPv6</code>，它具有与源相同的<code class="fe lf lg lh li b">Security Group</code> ID，以使这个例子能够工作。</p><h2 id="c0b7" class="na ly iq bd lz nb nc dn md nd ne dp mh jy nf ng ml kc nh ni mp kg nj nk mt nl bi translated">路由表</h2><p id="9b9b" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">让我们来探究一下<code class="fe lf lg lh li b">container-1</code>中的路由表。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="96cc" class="na ly iq li b gy nq nr l ns nt">root@d7c9480161f9:/# <strong class="li ir">ip -6 route</strong><br/>2600:1f18:47b:ca03<strong class="li ir">::8</strong>/126 dev <strong class="li ir">eth0</strong> proto kernel metric 256 pref medium<br/>fe80::/64 dev eth0 proto kernel metric 256 pref medium<br/><strong class="li ir">default</strong> via 2600:1f18:47b:ca03<strong class="li ir">::9</strong> dev eth0 metric 1024 pref medium</span></pre><p id="dfe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lf lg lh li b">::9</code>是在前面的终端输出中看到的<code class="fe lf lg lh li b">docker0</code>中的IP。<code class="fe lf lg lh li b">instance-1</code>路由的表呢？</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="36e8" class="na ly iq li b gy nq nr l ns nt">$ <strong class="li ir">ip -6 route</strong><br/>2600:1f18:47b:ca03::8/126 dev docker0 proto kernel metric 256 pref medium<br/>2600:1f18:47b:ca03::8/126 dev docker0 metric 1024 pref medium<br/>2600:1f18:47b:ca03::/64 dev ens5 proto kernel metric 256 pref medium<br/>...<br/>default via fe80::1066:30ff:feb8:c008 dev ens5 proto static metric 1024 pref medium</span></pre><h2 id="8ea5" class="na ly iq bd lz nb nc dn md nd ne dp mh jy nf ng ml kc nh ni mp kg nj nk mt nl bi translated">一句忠告</h2><p id="cf74" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">Docker 建议我们在Linux上启用IPv6路由，通过执行下面两行代码来实现这一点。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="e89a" class="na ly iq li b gy nq nr l ns nt">sudo sysctl net.ipv6.conf.default.forwarding=1<br/>sudo sysctl net.ipv6.conf.all.forwarding=1</span></pre><p id="3c30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个例子，我不必这样做，因为EC2实例已经有了这个设置。他们也不推荐小于<code class="fe lf lg lh li b">/80</code>的IPv6子网。</p><blockquote class="km kn ko"><p id="f8c8" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">⚠️“Docker容器的子网大小应该至少为/80，这样IPv6地址可以以容器的MAC地址结束，并且可以防止docker层的NDP邻居缓存失效问题”<a class="ae kl" href="https://docs.docker.com/v17.09/engine/userguide/networking/default_network/ipv6/#how-ipv6-works-on-docker" rel="noopener ugc nofollow" target="_blank">docker</a></p></blockquote><p id="ed0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，但同样重要的是，我遇到了一个<a class="ae kl" href="https://github.com/containernetworking/cni/issues/531" rel="noopener ugc nofollow" target="_blank">讨论</a>，其中他们声明IPv6在某些Docker版本的容器上是禁用的。我在跑<code class="fe lf lg lh li b">18.09.0</code>。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="40ca" class="na ly iq li b gy nq nr l ns nt">$ <strong class="li ir">docker info  -f '{{.ServerVersion}}'</strong><br/>18.09.0</span></pre><p id="c03f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是容器内<code class="fe lf lg lh li b"> disable_ipv6</code>的网络内核设置。</p><pre class="ku kv kw kx gt nm li nn no aw np bi"><span id="13e9" class="na ly iq li b gy nq nr l ns nt">root@d7c9480161f9:/# sysctl -a | grep disable_ipv6<br/>net.ipv6.conf.all.disable_ipv6 = 1<br/>net.ipv6.conf.default.disable_ipv6 = 1<br/>net.ipv6.conf.<strong class="li ir">eth0.disable_ipv6 = 0</strong><br/>net.ipv6.conf.<strong class="li ir">lo.disable_ipv6 = 0</strong></span></pre><h1 id="c772" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">结论</h1><p id="b889" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">虽然这并不是最终目标，但有趣的是我们现在可以在云中运行仅支持IPv6的容器。✅</p><p id="b2e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我将尝试扩展它，在一个云提供商上运行只支持IPv6的Kubernetes或者先看看不同云提供商对IPv6的支持。</p></div></div>    
</body>
</html>