<html>
<head>
<title>Flutter Riverpod Simple Example And Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter Riverpod简单示例和指南</h1>
<blockquote>原文：<a href="https://itnext.io/flutter-riverpod-simple-example-and-guide-f183de192445?source=collection_archive---------0-----------------------#2022-06-21">https://itnext.io/flutter-riverpod-simple-example-and-guide-f183de192445?source=collection_archive---------0-----------------------#2022-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cfa056015f72d95b2c33432583f31174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-G3Gv8vZmAo0MOT_R_4LgA.png"/></div></div></figure><p id="c1f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们开始使用Flutter时，我们选择了Flutter最喜欢的供应商。通过这个项目，我们看到了所有的好处和问题，对于下一个项目，我们决定使用Riverpod。从那时起，它一直是我们的国家管理的选择。在这个简单的教程中，我们将创建一个简单的riverpod (1.0.4)使用示例。如果你读过我以前的文章，你会知道我欠你一些关于快车道部署的新东西，但从那以后，我们的<a class="ae kw" href="https://qed.academy/" rel="noopener ugc nofollow" target="_blank"> Flutter academy </a>花了我的时间，把我的注意力转移到这上面来帮助所有的学生。</p><p id="4107" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">*更新—第二章是<a class="ae kw" href="https://medium.com/@vedran.balagovic/flutter-riverpod-example-and-guide-with-networking-b758af7b646b" rel="noopener">这里</a>:)</p><h1 id="8454" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">第一步。—新项目和模拟数据</h1><p id="3b4c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">创建一个新项目，并将一个数据文件夹添加到根目录中(在这个例子中，我们将使用json文件，但是在这个实现之后，您可以很容易地将其切换到http call或firestore)。你可以从这个<a class="ae kw" href="https://gist.github.com/vbalagovic/178afa70fdc4b858c87a963d2571ad4e" rel="noopener ugc nofollow" target="_blank">链接</a>中使用json，我们将在项目中使用它。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/5779b2a39697d3c5929cbd6bd9366ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tc9PbAOgCjYBu-SM"/></div></div></figure><p id="404a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要将数据文件夹作为资产使用和访问，您需要更新您的pubspec.yaml文件。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/72c4d6b708f98348b45a4c0d8381dbc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xsLg5s4A2Y9g9SC2"/></div></div></figure><h1 id="b343" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">第二步。—创建模型类</h1><p id="6d51" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在lib目录中创建models文件夹，我们将在其中添加movie.dart文件，该文件将成为我们的电影模型类。颤振架构中的模型对应<a class="ae kw" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> MVC </a>。当我们有我们期望收到的相同类型的数据时，通过一个模型来处理它(甚至是意想不到的事情)会容易得多，因为它简化了工作。我们总是知道我们将得到什么以及以什么形式得到，这将帮助我们通过应用来管理它。</p><ul class=""><li id="b592" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">这样做的基本方法是定义一个类，并添加我们期望的所有变量，以及构造函数(在我们的例子中，也是今天的标准API格式)来解析来自JSON和JSON的模型</li><li id="1921" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">在<a class="ae kw" href="https://javiercbk.github.io/json_to_dart/" rel="noopener ugc nofollow" target="_blank"> JSON to dart </a>应用程序的帮助下，如果我们指定了Json格式，该应用程序将为我们完成所有工作，因此无需更多麻烦，从movies.json列表中取出一个Json对象，并将其复制粘贴到Json to dart应用程序。正如你所看到的，它甚至为我们处理了JSON对象中的数组数据(唯一的缺点是它可能不是最新的dart版本，所以你可能需要调整代码来删除不必要的关键字等):</li></ul><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/a85452f1bafd02528dc9327568654b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k0e72R1MaLgvlbkH"/></div></div></figure><h1 id="ee90" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">第三步。—创建简单视图</h1><p id="4efd" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">用小工具创建一个简单的电影列表。我们提取了一个电影卡片小部件，并添加了一个简单的列表视图构建器和一个电影类模型示例。我们应该有这样的东西。这个步骤的代码在一个单独的<a class="ae kw" href="https://github.com/vbalagovic/flutter-riverpod-example/tree/STEP-3-simple-widgets" rel="noopener ugc nofollow" target="_blank">分支</a>中，所以你可以看到它。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/a106ad50a18e7283818220c8e01022db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gHgGFuFa39eLGNDp"/></div></div></figure><h1 id="b802" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">第四步。—介绍Flutter Riverpod</h1><p id="3f65" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">首先，我们需要添加一个<a class="ae kw" href="https://pub.dev/packages/flutter_riverpod/install" rel="noopener ugc nofollow" target="_blank"> flutter riverpod包</a>你有一个关于给定链接的安装指南，然后做以下事情:</p><ul class=""><li id="071d" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">一旦安装了Riverpod，我们就可以用ProviderScope包装我们的根小部件:</li><li id="0e31" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">ProviderScope是一个小部件，它存储我们创建的所有提供者的状态。</li></ul><p id="49d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们将把我们的StatelessWidget转换成消费者Widget。通过子类化ConsumerWidget，我们的小部件的build()方法现在有了一个额外的WidgetRef参数，我们可以用它来监视我们的提供者。</p><p id="eefe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">WidgetRef是什么？</p><p id="ea39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Riverpod文档将WidgetRef定义为允许小部件与提供者交互的对象。</p><blockquote class="mv mw mx"><p id="0a8b" class="jy jz my ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated">为了更好地理解WidgetRef的用途，让我们将它与BuildContext进行比较:</p><p id="7937" class="jy jz my ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated">BuildContext允许我们访问小部件树中的祖先小部件(例如Theme.of(context)和MediaQuery.of(context))</p></blockquote><p id="e095" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，WidgetRef允许我们访问任何我们想要的提供者。这是故意的，因为所有Riverpod提供商都是全球性的。</p><p id="55be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们将看到的，这有很多优点，让我们可以轻松地将任何状态管理逻辑移到小部件树之外。状态可用性的示例:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/3f8a9c2ab23cffa7598e748c1d760c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wEIw8CfvQX0ACZyp"/></div></div></figure><p id="06d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，这个设置仍然以引入riverpod之前的方式工作，所以让我们创建第一个提供者。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/0e8824779cdbc22a13958b324b7614fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YXolYX6eRUtNyeh6"/></div></div></figure><h1 id="9dbd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">第五步。—创建电影提供商</h1><p id="a095" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Provider和StateProvider对于像反例这样的简单用例已经足够了。但是在更复杂的应用程序中，我们经常需要在小部件类之外存储一些状态和一些业务逻辑。</p><p id="0699" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们将为我们的业务逻辑使用StateNotifier提供程序。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/a73a473532a2de849945337c875e9b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YqzzCMJ5M1bMX9xU"/></div></div></figure><blockquote class="mv mw mx"><p id="d2ec" class="jy jz my ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated">StateNotifierProvider是一个提供程序，用于侦听和公开StateNotifier(来自Riverpod重新导出的包state_notifier)。</p><p id="ff52" class="jy jz my ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated">StateNotifierProvider和StateNotifier是Riverpod推荐的管理状态的解决方案，状态可能会随着用户交互而改变。</p></blockquote><p id="e74a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们需要一个不可变的状态，为了创建这个简单的方法，我们将使用一个名为<a class="ae kw" href="https://pub.dev/packages/freezed" rel="noopener ugc nofollow" target="_blank">冻结</a>的包。它将为我们生成所有的样板代码，所以我们的提供者将会很好很干净。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/974c9565ed97dfba38e6f3ac3d098004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1t6yIrcKuPqXBt-A"/></div></div></figure><p id="cdc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个简单的提供程序将加载我们的json movies数据，看起来像这样(如果您只是复制粘贴它，不要担心丢失文件，要创建丢失的冻结文件，您需要运行冻结包指令中指定的一些命令):</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/141a1a269beaf13849e0798dadd83ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zGJZqW2zGgPpfK82"/></div></div></figure><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c78e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在还可以清理main.dart文件，只需读取提供者就可以从列表中看到我们的电影。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/775bb3771b4d6078fe74de8a5552c975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P3-Z4HzopHNPa-MC"/></div></div></figure><h1 id="615c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">第六步。—增加简单的交互性</h1><p id="ec75" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们将添加一个简单的文本输入小部件和onChanged function trigger，我们将调用提供者提供的一个新方法filterMovies。</p><p id="81b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们的main.dart现在看起来像这样:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="59d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像这样调出movie_provider.dart:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="112d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们可以看到的，虽然它的工作，我们有太多的重复代码，没有加载器时，搜索，当它将是一个API请求，这可能需要一些时间。</p><p id="bd4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决问题1:提取JSON到服务的加载(稍后可以很容易地切换到http方法)</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f090" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并替换提供程序中的获取。现在，我们可以在一个地方轻松地切换任何类型的数据获取方法。有了存储库(下一篇文章)，它将很容易测试。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/33962dd59a10f15e37324efc501aaf95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4Yzbi51Wv5ZDppBv"/></div></div></figure><p id="7c43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决问题2:在搜索时添加加载程序</p><p id="28a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这可以用FutureProvider自然解决，但为了方便起见，让我们用最简单的方法来解决这个问题:</p><ul class=""><li id="507b" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">在MovieState中添加isLoading变量(每次加载时触发)</li></ul><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ul class=""><li id="a28c" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">运行命令重新生成电影状态</li></ul><p id="f1c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">颤振包发布运行构建_运行构建—删除—冲突—输出</p><ul class=""><li id="8684" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">主屏幕上正在加载监视程序</li></ul><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d4f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">向模拟加载程序的服务添加延迟:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/ab8b4cae9811c3959ea740fcdbc2cca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P8n1xd6WhO6n8D16"/></div></div></figure><p id="2fa4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也许这不是最佳的方式或代码，但我认为它对初学者来说是友好的，你可以在这个基础上构建，这也是本文的目的。</p><p id="392c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整代码回购可在<a class="ae kw" href="https://github.com/vbalagovic/flutter-riverpod-example" rel="noopener ugc nofollow" target="_blank"> github链接</a>上获得。</p><h1 id="4f22" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么是Riverpod？</h1><p id="25c9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">正如文件中所说的。为了理解我们为什么需要Riverpod，让我们来看一些使用Riverpod解决的Provider最常见的问题:</p><p id="6415" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照设计，Provider是对InheritedWidget的改进，它依赖于小部件树</p><ul class=""><li id="eca0" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">组合提供者非常冗长</li><li id="5d27" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">通过类型和运行时异常获取提供程序</li></ul><p id="a00f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">高级Riverpod功能，我们将在未来详细讨论:</p><ul class=""><li id="bd54" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">自动丢弃修改器</li><li id="a1f3" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">家庭修饰符</li><li id="272d" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">使用Riverpod的依赖性覆盖</li><li id="75f3" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">将提供商与Riverpod相结合</li><li id="4b0c" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">范围提供者</li></ul><p id="403e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我个人认为对于一个使用redux/vuex等的网络背景的人来说。Riverpod是一种非常自然和符合逻辑的状态管理方式，而且它的核心毕竟是提供者(Flutter favorite ),而且是由同一个人制作的。此外，在这个简单的项目中，我们没有使用存储库，所以请记住这一点，并检查该模式的可测试性，直到我可以写一篇扩展文章。</p><p id="349d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二章是<a class="ae kw" href="https://medium.com/@vedran.balagovic/flutter-riverpod-example-and-guide-with-networking-b758af7b646b" rel="noopener">这里</a>:)</p></div></div>    
</body>
</html>