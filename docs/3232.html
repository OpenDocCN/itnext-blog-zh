<html>
<head>
<title>Container Image Building with Kaniko</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kaniko构建容器形象</h1>
<blockquote>原文：<a href="https://itnext.io/container-image-building-with-kaniko-dda7a451e25c?source=collection_archive---------2-----------------------#2019-10-31">https://itnext.io/container-image-building-with-kaniko-dda7a451e25c?source=collection_archive---------2-----------------------#2019-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><a href="https://www.giantswarm.io/on-demand-webinar-kubernetes-hard-lessons-and-how-to-avoid-them?utm_campaign=Medium%20CTA%20Conversion&amp;utm_source=Kubernetes%20hard%20lessons_Medium&amp;utm_medium=Medium%20CTA&amp;utm_term=Kubernetes%20hard%20lessons"><div class="gh gi jq"><img src="../Images/88bbcc04d197a665b237a742a81c80ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hCYccf56_Y56Psvs.jpg"/></div></a></figure><p id="a22c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我们关于容器图像构建技术的<a class="ae kv" href="https://blog.giantswarm.io/building-container-images-with-img/" rel="noopener ugc nofollow" target="_blank">系列</a>的下一篇文章中，我们将关注名为<a class="ae kv" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>的开源项目。</p><p id="9407" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Kaniko是谷歌在2018年初发起的项目。Kaniko背后的基本原理是寻求在执行容器映像构建时消除对提升特权的需求。如果您一直在阅读本系列文章，那么您现在应该已经知道，非特权容器映像构建是关注安全性的组织最需要的特性之一。这与Kubernetes集群中的容器映像构建特别相关。</p><p id="519a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">那么，Kaniko是什么，它是如何工作的？</strong></p><h1 id="2eaf" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">方法</h1><p id="60f9" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">Kaniko使用您通常用来构建容器图像的熟悉对象；包含构建指令和构建上下文的other文件，其中包含other文件和映像所需的任何其他工件。</p><p id="e9db" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，与本地Docker客户机构建命令不同，它不需要Docker守护进程来执行构建步骤。</p><p id="67cd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">相反，Kaniko使用自己的'<a class="ae kv" href="https://console.cloud.google.com/gcr/images/kaniko-project/GLOBAL/executor@sha256:9c40a04cf1bc9d886f7f000e0b7fa5300c31c89e2ad001e97eeeecdce9f07a29?tag=latest" rel="noopener ugc nofollow" target="_blank">执行器</a>来执行构建步骤，它在一个容器(可能是一个Kubernetes pod)中运行。当然，构建上下文需要对容器或pod可用，以便构建使用它。因为构建步骤是在容器内部执行的，所以最终仍然依赖于Docker守护进程或其他一些容器运行时，但是重要的区别在于构建步骤本身是由执行器代码执行的。</p><p id="244c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">执行器遍历over文件中定义的每个构建阶段。它提取为构建阶段指定的基础映像并解压缩其rootfs。然后，它依次执行每个Dockerfile指令，在执行过程中添加或更改rootfs的内容。如果对rootfs进行了更改，执行器会将文件系统的更改作为“diff”层进行快照，并在必要时更新映像元数据。快照是通过将文件系统的先前状态与Dockerfile指令执行后的状态进行比较来实现的。这与overlayfs之类的写时复制文件系统的行为没有什么不同，只是该操作完全是在用户空间中执行的。一旦构建步骤完成，差异层将按顺序添加到基础映像中以形成新映像。</p><p id="9cd5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">“构建的映像会发生什么变化？我听到你问，“图像不会随着用过的容器或容器消失吗？</strong></p><p id="3f9b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">嗯，executor还希望在命令行上指定一个或多个容器注册库名称，这样它就可以在成功构建完成时推送新的映像。</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><a href="https://www.giantswarm.io/on-demand-webinar-kubernetes-hard-lessons-and-how-to-avoid-them?utm_campaign=Medium%20CTA%20Conversion&amp;utm_source=Kubernetes%20hard%20lessons_Medium&amp;utm_medium=Medium%20CTA&amp;utm_term=Kubernetes%20hard%20lessons"><div class="gh gi lz"><img src="../Images/9ecafeb580122d973bbb8fe546c81b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UnBgi5Tmzx3aIunFCFxwnQ.jpeg"/></div></a></figure><h1 id="fc81" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">构建上下文</h1><p id="12d7" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">Kaniko在定义构建上下文的来源时非常灵活。可以使用卷挂载来指定包含上下文的本地目录(到容器),上面的示例强调了使用git存储库作为源。</p><p id="97c1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">考虑到Kaniko的起源，如果云存储不被认为是构建上下文的来源，那将是一个惊喜。果然，Kaniko支持使用三大公共云提供商提供的对象存储解决方案。</p><h1 id="6e04" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">构建缓存</h1><p id="6784" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">容器映像构建的一个非常重要的组件是能够利用之前对映像构建步骤的调用，这些调用通常会被缓存以用于此目的。如果构建步骤会产生相同的输出，构建器将使用缓存的内容，而不是重新执行构建步骤。</p><p id="9bc2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> Kaniko为增强的图像构建提供了两种缓存功能:</strong></p><ol class=""><li id="14fa" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated">基本映像可以下载到一个本地的共享卷上，在调用executor容器时可以使用这个卷。这就避免了每次调用执行器容器时都要拉同一个基础映像，从而节省了构建时间。Kaniko为此提供了“加热器”。您只需要指定本地目录来存储您想要缓存的图像和相关图像。</li><li id="9f23" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">在映像构建过程中创建的中间映像层也是构建缓存的重要组成部分。同样，Kaniko支持缓存在执行RUN Dockerfile指令期间创建的图像，但是这些图像存储在远程容器注册表存储库中。在执行器处理运行指令之前，检查指定的储存库的等效层。如果找到了，它将从存储库中取出，而不是正在执行的指令。</li></ol><h1 id="d766" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">安全性</h1><p id="33a8" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">由于Kaniko避免了使用Docker守护进程的构建API端点来执行构建步骤，这对于安全性有很大帮助。执行器可以作为非特权容器运行，不需要在容器中安装Docker守护进程套接字。这是寻求在Kubernetes上的pods中安全运行容器映像构建的重要一步。</p><p id="be16" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">缺点是构建步骤可能需要以root (uid=0)用户的身份执行。一般来说，容器应该使用非root用户运行—容器中的root用户就是主机上的root用户。如果基础映像的rootfs的组件需要由root用户拥有，或者命令需要以root权限执行，这对于Kaniko来说是不可避免的。</p><p id="42ac" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">与作为根用户运行executor容器相关的一些问题可以得到部分缓解。通过提供额外的隔离，可以保护运行executor容器的主机。谷歌自己的<a class="ae kv" href="https://gvisor.dev/" rel="noopener ugc nofollow" target="_blank"> gVisor </a>用户空间内核抽象是这种隔离的一个很好的例子，正如<a class="ae kv" href="https://katacontainers.io/" rel="noopener ugc nofollow" target="_blank"> Kata容器</a>运行时一样。</p><h1 id="93d4" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="740b" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">Kaniko是一种新型的图像构建工具，旨在消除对Docker守护进程的长期依赖。它很好地做到了这一点，并在Kubernetes集群中提供了可信的容器映像构建体验。这是在没有通常与针对Docker守护进程的构建相关联的安全恐惧的情况下实现的。出于这个原因，Kaniko是一个流行的映像构建工具，并经常作为<a class="ae kv" href="https://github.com/tektoncd/pipeline" rel="noopener ugc nofollow" target="_blank"> Tekton管道</a>的后端构建任务。</p><p id="b6e3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">尽管Kaniko很受欢迎，但它并没有完全实现无根容器映像构建的涅槃，并且还延续了基于Dockerfile的构建的顺序性质。</p><p id="d171" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您是否希望将Kubernetes容器投入生产？<a class="ae kv" href="https://www.giantswarm.io/contact" rel="noopener ugc nofollow" target="_blank">联系Giant Swarm </a>开始你的云原生之旅。</p><p id="eb18" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">由<a class="ae kv" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank"> Puja Abbassi </a>撰写——开发者倡导者@ <a class="ae kv" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型蜂群</a></p><div class="ms mt gp gr mu mv"><a href="https://twitter.com/puja108" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">Puja Abbassi</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">Puja Abbassi的最新推文(@puja108)。开发者关系&amp;产品@ GiantSwarm研究员；主题…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">twitter.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj jv mv"/></div></div></a></div></div></div>    
</body>
</html>