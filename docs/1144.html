<html>
<head>
<title>GraphQL using .NET Boxed: Mutations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL。NET Boxed:突变</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-using-net-boxed-mutations-cbc39190f6db?source=collection_archive---------2-----------------------#2018-07-29">https://itnext.io/graphql-using-net-boxed-mutations-cbc39190f6db?source=collection_archive---------2-----------------------#2018-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ec0b04437a7edcd3e26a43b7f02b0450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OiPzHlnFphzdQ1nNI5YEhQ.png"/></div></div></figure><p id="9f66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章将继续我使用<a class="ae kw" href="https://github.com/Dotnet-Boxed/Templates" rel="noopener ugc nofollow" target="_blank">对<a class="ae kw" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>的探索。NET Boxed </a>模板作为跳开点。我开始写的代码可以在<a class="ae kw" href="https://github.com/elanderson/ASP.NET-Core-GraphQl/tree/f8a353800ab5006c78b5445cc0204cb66f367147" rel="noopener ugc nofollow" target="_blank">这里</a>找到。使用查看<a class="ae kw" href="https://elanderson.net/2018/07/graphql-using-net-boxed-queries/" rel="noopener ugc nofollow" target="_blank"> GraphQL。NET Boxed: Queries </a>从上周开始探索查询。</p><p id="7d0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">突变是GraphQL允许客户端请求更改服务器端数据的方式。</p><h2 id="552e" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">出发点</h2><p id="4f0a" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">正如我们上周发现的，MainSchema是发现GraphQL如何在这个模板中设置的中心点。仅供参考，这里是完整的类。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="3a4c" class="kx ky iq ma b gy me mf l mg mh">public class MainSchema : Schema<br/>{<br/>    public MainSchema(<br/>        QueryObject query,<br/>        MutationObject mutation,<br/>        SubscriptionObject subscription,<br/>        IDependencyResolver resolver)<br/>        : base(resolver)<br/>    {<br/>        this.Query = resolver.Resolve&lt;QueryObject&gt;();<br/>        this.Mutation = mutation;<br/>        this.Subscription = subscription;<br/>    }<br/>}</span></pre><p id="785b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们感兴趣的是被赋予了变异对象的变异属性。</p><h2 id="941f" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">突变对象</h2><p id="c78a" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">下面是完整的MutationObject类，它定义了该服务器上的哪些对象允许哪些变化，以及收到变化请求时会发生什么。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="72b2" class="kx ky iq ma b gy me mf l mg mh">public class MutationObject : ObjectGraphType&lt;object&gt;<br/>{<br/>    public MutationObject(IHumanRepository humanRepository)<br/>    {<br/>        this.Name = "Mutation";<br/>        this.Description = "The mutation type for updates to our data.";<br/>        this.FieldAsync&lt;HumanObject, Human&gt;(<br/>            "createHuman",<br/>            "Create a new human.",<br/>            arguments: new QueryArguments(<br/>                new QueryArgument&lt;NonNullGraphType&lt;HumanInputObject&gt;&gt;()<br/>                {<br/>                    Name = "human",<br/>                    Description = "The human you want to create.",<br/>                }),<br/>            resolve: context =&gt;<br/>            {<br/>                var human = context.GetArgument&lt;Human&gt;("human");<br/>                return humanRepository.AddHuman(human,<br/>                                                context.CancellationToken);<br/>            });<br/>    }<br/>}</span></pre><p id="bb2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这与上周设置的QueryObject非常相似。第一个大的不同是在QueryArguments中。变异采用HumanInputObject类而不是ID。如果你看一下查询参数，你会发现这个参数不允许为空。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="39e6" class="kx ky iq ma b gy me mf l mg mh">new QueryArgument&lt;NonNullGraphType&lt;HumanInputObject&gt;&gt;()</span></pre><p id="626f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么是HumanInputObject类？它是一个InputObjectGraphType，定义了突变查询参数的形状。正如您在下面看到的，它提供了名称、描述和字段列表。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9570" class="kx ky iq ma b gy me mf l mg mh">public class HumanInputObject : InputObjectGraphType<br/>{<br/>    public HumanInputObject()<br/>    {<br/>        this.Name = "HumanInput";<br/>        this.Description = "A humanoid creature from Star Wars.";<br/>        this.Field&lt;NonNullGraphType&lt;StringGraphType&gt;&gt;(nameof(Human.Name));<br/>        this.Field&lt;StringGraphType&gt;(nameof(Human.HomePlanet));<br/>        this.Field&lt;ListGraphType&lt;EpisodeEnumeration&gt;&gt;(nameof(Human.AppearsIn), "Which movie they appear in.");<br/>    }<br/>}</span></pre><p id="3051" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，请注意，这些字段在human类的属性上使用nameof，以确保名称匹配，这将防止该项目正在处理的3个不同的Human类之间的映射出现任何问题。下面是从上述示例中提取的字段定义的示例。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="2e9d" class="kx ky iq ma b gy me mf l mg mh">this.Field&lt;NonNullGraphType&lt;StringGraphType&gt;&gt;(nameof(Human.Name));</span></pre><p id="e0c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一件要注意的事情是，即使在字段级别，除了设置字段类型之外，您还可以设置字段是否允许为空。</p><p id="0a95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到变异对象，让我们看看FieldAsync调用内部的解析。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="0671" class="kx ky iq ma b gy me mf l mg mh">resolve: context =&gt;<br/>{<br/>    var human = context.GetArgument&lt;Human&gt;("human");<br/>    return humanRepository.AddHuman(human, context.CancellationToken);<br/>});</span></pre><p id="57c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是提取人工查询参数，并将其转换为人类类的实例，然后发送到存储库进行保存。</p><h2 id="2933" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">包扎</h2><p id="f3bd" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">这涵盖了突变的基本探索。我在考虑订阅。</p><p id="8961" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相关的示例代码可以在<a class="ae kw" href="https://github.com/elanderson/ASP.NET-Core-GraphQl/tree/59792e870382dba7c6c40d444cfe573577b2569b" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="2794" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mp">原载于</em><a class="ae kw" href="https://elanderson.net/2018/07/graphql-using-net-boxed-mutations/" rel="noopener ugc nofollow" target="_blank"><em class="mp"/></a><em class="mp">。</em></p></div></div>    
</body>
</html>