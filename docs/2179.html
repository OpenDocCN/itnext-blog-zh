<html>
<head>
<title>Introduction to functional programming with Python examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python示例介绍函数式编程</h1>
<blockquote>原文：<a href="https://itnext.io/introduction-to-functional-programming-with-python-examples-83f33308856a?source=collection_archive---------4-----------------------#2019-04-12">https://itnext.io/introduction-to-functional-programming-with-python-examples-83f33308856a?source=collection_archive---------4-----------------------#2019-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d8130fd86810a8e628a3956125bd169c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vC-KF85oTeEN-wEmuEbPjg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.duomly.com/" rel="noopener ugc nofollow" target="_blank"> Duomly —在线编程课程</a></figcaption></figure><p id="bc21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文最初发表于:<a class="ae kf" href="https://www.blog.duomly.com/the-most-important-aspects-of-functional-programming-with-python-examples/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/the-most-important-aspects-of-functional-programming-with-python-examples/</a></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="799b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">函数式编程</strong>是一个有趣的编程概念，最近得到了很多关注。本文介绍了函数式编程的一些最重要的方面，并提供了几个Python中的例子。</p><p id="475d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数式编程是一种声明式编程范式，其中函数表示对象之间的关系，就像数学中一样。因此，函数不仅仅是普通的例程。</p><p id="763c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种编程范式可以用多种语言实现。有几种函数式编程语言，如Closure、Erlang或Haskel。除了其他范例之外，许多语言还支持函数式编程:C++、C#、F#、Java、Python、JavaScript等。</p><p id="35c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，您将找到与函数式编程相关的几个重要原则和概念的解释:</p><ul class=""><li id="4fa6" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated">纯函数，</li><li id="961f" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">匿名函数，</li><li id="650f" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">递归函数，</li><li id="757c" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">一流的功能，</li><li id="ac60" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">不可变的数据类型。</li></ul></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="1bf6" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">纯函数</h1><p id="371d" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">纯函数是这样的函数:</p><ul class=""><li id="3ab1" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated">是幂等的—如果提供相同的参数，则返回相同的结果，</li><li id="a7b2" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">没有副作用。</li></ul><p id="0479" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一个函数使用一个来自更高作用域的对象或随机数，与文件通信等等，它可能是<em class="nc">不纯的</em>，因为它的结果不仅仅取决于它的参数。</p><p id="aa5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个函数在它的作用域之外修改对象，写入文件，打印到控制台等等，有副作用，也可能是不纯的。</p><p id="fdb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">纯函数通常不使用外部作用域的对象，从而避免共享状态。这可能会简化程序并帮助避免一些错误。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="6feb" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">匿名函数</h1><p id="82f4" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">匿名(lambda)函数对于函数式编程结构来说非常方便。它们没有名字，通常是临时创建的，只有一个目的。</p><p id="1d5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python中，使用lambda关键字创建一个匿名函数:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="c3d9" class="nm ma it ni b gy nn no l np nq">lambda x, y: x + y</span></pre><p id="84fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的语句创建了接受两个参数并返回它们之和的函数。在下一个例子中，函数f和g做同样的事情:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="59f5" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; f = lambda x, y: x + y <br/>&gt;&gt;&gt; def g(x, y): <br/>return x + y</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="65d8" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">递归函数</h1><p id="aec9" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated"><em class="nc">递归函数</em>是在执行过程中调用自身的函数。例如，我们可以使用递归来寻找函数式的阶乘:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="425f" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; def factorial_r(n): <br/>if n == 0:<br/>return 1<br/>return n * factorial_r(n — 1)</span></pre><p id="d2e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，我们可以用while或for循环解决同样的问题:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="589e" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; def factorial_l(n):<br/>if n == 0:<br/>return 1<br/>product = 1<br/>for i in range(1, n+1):<br/>product *= i<br/>return product</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="79fb" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">一级函数</h1><p id="2129" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在函数式编程中，函数是第<em class="nc">级</em>对象，也称为<em class="nc">高阶</em>函数——数据类型与其他类型的处理方式相同。</p><p id="a5aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数(或者更准确地说，它们的指针或引用)可以作为参数传递给其他函数，也可以从其他函数返回。它们也可以用作程序内部的变量。</p><p id="5fff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码演示了将内置函数max作为函数f的参数传递，并从f内部调用它。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="f5b9" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; def f(function, *arguments):<br/>return function(*arguments)</span><span id="d980" class="nm ma it ni b gy nr no l np nq">&gt;&gt;&gt; f(max, 1, 2, 4, 8, 16)<br/>16</span></pre><p id="e5e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非常重要的函数式编程概念是:</p><ul class=""><li id="f277" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated">映射，</li><li id="626a" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">过滤，</li><li id="b7cb" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">减少。</li></ul><p id="aaf5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python中都是支持的。</p><p id="2fc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nc">映射</em>使用内置的类别映射进行。它将一个函数(或方法，或任何可调用的函数)作为第一个参数，将一个iterable(如列表或元组)作为第二个参数，并返回迭代器，其中包含对iterable项调用函数的结果:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="92cb" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; list(map(abs, [-2, -1, 0, 1, 2]))<br/>[2, 1, 0, 1, 2]</span></pre><p id="cf8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，内置函数abs分别使用参数-2、-1、0、1和2进行调用。我们可以通过列表理解获得相同的结果:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="92c0" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; [abs(item) for item in [-2, -1, 0, 1, 2]]<br/>[2, 1, 0, 1, 2]</span></pre><p id="2221" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不必使用内置函数。可以提供自定义函数(或方法，或任何可调用的函数)。在这种情况下，Lambda函数可能特别方便:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="46a6" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; list(map(lambda item: 2 * item, [-2, -1, 0, 1, 2]))<br/>[-4, -2, 0, 2, 4]</span></pre><p id="52de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的语句使用自定义(lambda)函数lambda item: 2 * item将列表中的每一项[-2，-1，0，1，2]乘以2。当然，我们可以用领悟来达到同样的目的:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="d832" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; [2 * item for item in [-2, -1, 0, 1, 2]]<br/>[-4, -2, 0, 2, 4]</span></pre><p id="f1fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nc">过滤</em>使用内置的类别过滤器执行。它还将一个函数(或方法，或任何可调用的函数)作为第一个参数，将iterable作为第二个参数。它对iterable的项调用函数，并返回一个新的iterable，其中包含函数返回True的项或任何被评估为True的项。例如:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="be21" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; list(filter(lambda item: item &gt;= 0, [-2, -1, 0, 1, 2]))<br/>[0, 1, 2]</span></pre><p id="d5a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的语句返回[-2，-1，0，1，2]的非负项列表，如函数lambda item: item &gt;= 0所定义。同样，使用理解可以获得相同的结果:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="f94e" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; [item for item in [-2, -1, 0, 1, 2] if item &gt;= 0]<br/>[0, 1, 2]</span></pre><p id="43ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nc">减少</em>是通过functools模块的减少功能执行的。同样，它需要两个参数:一个函数和一个iterable。它对iterable的前两项调用函数，然后对该操作的结果和第三项调用函数，依此类推。它返回一个值。例如，我们可以找到列表中所有项目的总和，如下所示:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="d4fd" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; import functools<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; functools.reduce(lambda x, y: x + y, [1, 2, 4, 8, 16])<br/>31</span></pre><p id="4fad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个例子只是为了说明。计算总和的首选方法是使用内置的减函数sum:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="e00e" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; sum([1, 2, 4, 8, 16])<br/>31</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="85d8" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">不可变数据类型</h1><p id="306c" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated"><em class="nc">不可变对象</em>是一个一旦创建就不能修改状态的对象。相反，<em class="nc">可变对象</em>允许改变其状态。</p><p id="5469" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在函数式编程中，不可变对象通常是可取的。</p><p id="a313" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，在Python中，列表是可变的，而元组是不可变的:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="2fd8" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; a = [1, 2, 4, 8, 16] &gt;&gt;&gt; a[0] = 32 # OK. You can modify lists. <br/>&gt;&gt;&gt; a<br/>[32, 2, 4, 8, 16]<br/>&gt;&gt;&gt; a = (1, 2, 4, 8, 16)<br/>&gt;&gt;&gt; a[0] = 32 # Wrong! You can’t modify tuples.<br/>Traceback (most recent call last):<br/>File “”, line 1, in <br/>TypeError: ‘tuple’ object does not support item assignment</span></pre><p id="e9a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过向列表追加新元素来修改列表，但是当我们尝试用元组来做这件事时，它们并没有改变，而是创建了新的实例:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="91f5" class="nm ma it ni b gy nn no l np nq">&gt;&gt;&gt; # Lists (mutable) <br/>&gt;&gt;&gt; a = [1, 2, 4] # a is a list <br/>&gt;&gt;&gt; b = a # a and b refer to the same list object <br/>&gt;&gt;&gt; id(a) == id(b) <br/>True <br/>&gt;&gt;&gt; a += [8, 16] # a is modified and so is b — they refer to the same object <br/>&gt;&gt;&gt; a <br/>[1, 2, 4, 8, 16] <br/>&gt;&gt;&gt; b <br/>[1, 2, 4, 8, 16] <br/>&gt;&gt;&gt; id(a) == id(b) <br/>True <br/>&gt;&gt;&gt; <br/>&gt;&gt;&gt; # Tuples (immutable) <br/>&gt;&gt;&gt; a = (1, 2, 4) # a is a tuple <br/>&gt;&gt;&gt; b = a # a and b refer to the same tuple object <br/>&gt;&gt;&gt; id(a) == id(b) <br/>True <br/>&gt;&gt;&gt; a += (8, 16) # new tuple is created and assigned to a; b is unchanged <br/>&gt;&gt;&gt; a # a refers to the new object <br/>(1, 2, 4, 8, 16) <br/>&gt;&gt;&gt; b # b refers to the old object <br/>(1, 2, 4) <br/>&gt;&gt;&gt; id(a) == id(b) <br/>False</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="c605" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">函数式编程的优势</h1><p id="a194" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">基本的概念和原则——尤其是高阶函数、不可变数据和无副作用——意味着函数式程序的重要优势:</p><ul class=""><li id="fa70" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated">它们可能更容易理解、实现、测试和调试，</li><li id="6a75" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">它们可能更短更简洁(比较上面计算阶乘的两个程序)，</li><li id="9005" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">它们可能不太容易出错，</li><li id="dc52" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">当实现并行执行时，它们更容易使用。</li></ul><p id="9b92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数式编程是一个值得学习的有价值的范式。除了上面列出的优点，它可能会给你一个解决编程问题的新视角。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/615b08df31bdb641b1c4fd642e2007ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZOK6TUCtnCafOXYF4VMtA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.duomly.com/" rel="noopener ugc nofollow" target="_blank"> Duomly —编程在线课程</a></figcaption></figure><p id="bf89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读。</p><p id="e417" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">内容由我们的队友米尔科提供。</p></div></div>    
</body>
</html>