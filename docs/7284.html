<html>
<head>
<title>Distributed Tracing with Quarkus, Python, Open Telemetry and Jaeger (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Quarkus、Python、Open Telemetry和Jaeger进行分布式追踪(第1部分)</h1>
<blockquote>原文：<a href="https://itnext.io/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-1-2d83f761b786?source=collection_archive---------2-----------------------#2022-08-10">https://itnext.io/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-1-2d83f761b786?source=collection_archive---------2-----------------------#2022-08-10</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="dbe2" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在微服务世界中，没有简单的方法将调试器或分析器附加到一个组件上，以了解它为什么公开某种行为。剖析一个组件可能会发现这是其他人的问题。我过去曾经使用过OpenTracing，但是现在这个已经被弃用了，而且OpenTelemetry是一个新的很酷的产品，我想去看看。下图显示了该帖子的整体设置:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj kn"><img src="../Images/66fe921daafd058d2f2de4729a6f2f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXH-DXsButCcZbYVmKxa_Q.png"/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">一般设置</figcaption></figure><p id="9671" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这个设置部分是一个真实的用例，因为我有一个基于Quarkus的应用程序“<em class="ld">后端</em>，它调用一个Python服务器“<em class="ld"> fake-rbac </em>”。为了让事情变得更有趣，也为了便于学习，我还从Python应用程序向另一个基于Quarkus的服务“<em class="ld"> engine </em>”发出了一个出站调用。让我们从后端Quarkus应用程序开始吧</p><h2 id="e150" class="le lf ir bd lg lh li dn lj lk ll dp lm jz ln lo lp kd lq lr ls kh lt lu lv lw bi translated">将OpenTelemetry添加到我的Quarkus <em class="lx">后端</em>应用程序</h2><p id="ef32" class="pw-post-body-paragraph jo jp ir jq b jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl ik bi translated">OpenTelemetry 上的<a class="ae km" href="https://quarkus.io/guides/opentelemetry" rel="noopener ugc nofollow" target="_blank"> Quarkus指南是一个很好的起点。因为我已经有了基本代码，所以我继续将以下依赖项添加到我的pom.xml文件:</a></p><pre class="ko kp kq kr gu md me mf mg aw mh bi"><span id="e339" class="le lf ir me b gz mi mj l mk ml">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-opentelemetry&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-opentelemetry-exporter-otlp&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;<br/>    &lt;artifactId&gt;opentelemetry-extension-trace-propagators&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.opentelemetry.instrumentation&lt;/groupId&gt;<br/>    &lt;artifactId&gt;opentelemetry-jdbc&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;<br/>    &lt;artifactId&gt;opentelemetry-extension-annotations&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="527a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这看起来很多，我希望只有一个包含以上所有内容的<em class="ld">quar kus-open telemetry-all</em>扩展，但最终这并不重要，因为我必须添加一次这个，然后就完成了。</p><p id="44c2" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">下一步是在<em class="ld"> application.properties </em>中添加一些设置，然后我们就可以开始了。首先，我们设置跟踪收集器的位置，在新的OpenTelemetry Line Protocol (OTLP)本地模式中，它将是<a class="ae km" href="https://www.jaegertracing.io" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>:</p><pre class="ko kp kq kr gu md me mf mg aw mh bi"><span id="347a" class="le lf ir me b gz mi mj l mk ml"><strong class="me is">quarkus.application.name</strong>=backend<br/><strong class="me is">quarkus.opentelemetry.enabled</strong>=true<br/><strong class="me is">quarkus.opentelemetry.tracer.exporter.otlp.endpoint</strong>=http://127.0.0.1:4317</span></pre><p id="5170" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">接下来，更改数据库连接以支持跟踪:</p><pre class="ko kp kq kr gu md me mf mg aw mh bi"><span id="c338" class="le lf ir me b gz mi mj l mk ml"><strong class="me is">quarkus.datasource.db-kind</strong>=postgresql<br/><br/><strong class="me is">quarkus.datasource.jdbc.url</strong>=jdbc:<strong class="me is"><em class="ld">otel</em></strong>:postgresql://127.0.0.1:5432/postgres<br/><strong class="me is">quarkus.datasource.jdbc.driver</strong>=io.opentelemetry.instrumentation.jdbc.OpenTelemetryDriver</span></pre><h2 id="7b0d" class="le lf ir bd lg lh li dn lj lk ll dp lm jz ln lo lp kd lq lr ls kh lt lu lv lw bi translated">开始Jaeger</h2><p id="9297" class="pw-post-body-paragraph jo jp ir jq b jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl ik bi translated"><a class="ae km" href="https://www.jaegertracing.io" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>从1.35 版本开始原生支持<a class="ae km" href="https://medium.com/jaegertracing/introducing-native-support-for-opentelemetry-in-jaeger-eb661be8183c" rel="noopener"> OTLP。当我在笔记本电脑上使用docker-compose启动一系列服务时，我有以下条目，它启用OTLP并打开端口4317/4318(分别用于grpc和http传输)。查看</a><a class="ae km" href="https://www.jaegertracing.io/docs/1.37/deployment/" rel="noopener ugc nofollow" target="_blank"> Jaeger文档了解更多部署</a>选项。</p><pre class="ko kp kq kr gu md me mf mg aw mh bi"><span id="ade0" class="le lf ir me b gz mi mj l mk ml"><strong class="me is">jaeger</strong>:<br/>  <strong class="me is">image</strong>: jaegertracing/all-in-one:1.37.0<br/>  <strong class="me is">ports</strong>:<br/>    - 16686:16686<br/>    - 4317:4317<br/>    - 4318:4318<br/>  <strong class="me is">environment</strong>:<br/>    <strong class="me is">COLLECTOR_OTLP_ENABLED</strong>: true</span></pre><p id="c19a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">当我们现在点击<em class="ld">后端</em>上的REST-endpoint，转到端口16686上的Jaeger UI，搜索踪迹并点击现有的踪迹，我们将看到如下的可视化:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj mm"><img src="../Images/c51cde7995347fb0270d0708fad07ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hfy0982I6RxwBAbSGilWFA.png"/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">Jaeger在单个过程中可视化一个轨迹</figcaption></figure><p id="2ef5" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们看到总处理时间为26毫秒，并且由此触发了2次数据库查询。我们还看到一些RbacFilter被调用。下面我就说说那个滤镜。</p><h2 id="83f1" class="le lf ir bd lg lh li dn lj lk ll dp lm jz ln lo lp kd lq lr ls kh lt lu lv lw bi translated">框架的自动检测</h2><p id="c27f" class="pw-post-body-paragraph jo jp ir jq b jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl ik bi translated">有趣的是，在没有任何代码更改的情况下，我们获得了被调用方法的计时，包括数据库调用的计时。OpenTelemetry为常用的框架提供了大量的工具。上面我们已经引入了对<em class="ld">io . open telemetry . instrumentation:open telemetry-JDBC</em>的依赖，并稍微修改了jdbc url，将<em class="ld"> otlp </em>包含在其中，从而为我们的数据库调用获取数据。事实上，当我们单击其中一个调用的范围以展开详细信息时，我们甚至可以看到触发了什么查询:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj mn"><img src="../Images/7056a24beee46f4e7c18a5d9a45bb7a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TReoSYTmayzcO-gh6sj6yw.png"/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">Jaeger UI中的数据库查询详细信息</figcaption></figure><p id="8f91" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">自动插装不仅存在于Quarkus(或者一般的Java ),也存在于各种各样的编程语言和框架。</p><h2 id="2f3a" class="le lf ir bd lg lh li dn lj lk ll dp lm jz ln lo lp kd lq lr ls kh lt lu lv lw bi translated">现在转到Python</h2><p id="d479" class="pw-post-body-paragraph jo jp ir jq b jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl ik bi translated">在我的项目中，我需要调用一个用Python编写的RBAC(基于角色的访问控制)服务器。由于我想了解在该服务器中启用跟踪需要什么，我开始用内置的Python http.server包实现一个简单的http-server(我很清楚其他服务器也存在，甚至OpenTelemetry Python <a class="ae km" href="https://opentelemetry.io/docs/instrumentation/python/getting-started/" rel="noopener ugc nofollow" target="_blank"> <em class="ld">入门</em> </a>也使用Flask)。</p><p id="090c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">尽管有<a class="ae km" href="https://opentelemetry.io/docs/instrumentation/python/getting-started/#run-the-instrumented-app" rel="noopener ugc nofollow" target="_blank">open telemetry-instrument</a>的存在，我还是决定使用手动插装，以便更清楚地了解插装你自己的库所涉及的一些细节。</p><p id="ccde" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我不打算在这里分享完整的代码，你可以在GitHub 上找到。相反，我将专注于核心部分。</p><p id="a882" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们要做的第一件事是从全局配置的工厂中获取一个<em class="ld"> tracer </em>实例(我们稍后会谈到这个问题):</p><pre class="ko kp kq kr gu md me mf mg aw mh bi"><span id="33fa" class="le lf ir me b gz mi mj l mk ml">from opentelemetry import trace<br/>tracer = trace.get_tracer(__name__)</span></pre><p id="b394" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">然后，我们可以在服务器处理程序方法(do_GET)中使用它:</p><pre class="ko kp kq kr gu md me mf mg aw mh bi"><span id="b54b" class="le lf ir me b gz mi mj l mk ml">def do_GET(self):<br/>    with tracer.start_as_current_span("do-get-span") as span:<br/>        self.send_response(200)<br/>        span.set_attribute("type", "json")</span></pre><p id="4413" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在这里，我们从跟踪器中启动一个<em class="ld">跨度</em>(基本上是上面Jaeger可视化中的一个棕色条)，然后在跨度上设置一个属性。然后，处理继续正常进行，一旦do_GET完成，span就结束。</p><h2 id="ec32" class="le lf ir bd lg lh li dn lj lk ll dp lm jz ln lo lp kd lq lr ls kh lt lu lv lw bi translated">把数据发给耶格</h2><p id="b207" class="pw-post-body-paragraph jo jp ir jq b jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl ik bi translated">OpenTelemetry通过OpenTelemetry API(我们刚刚看到的)将数据采集与OpenTelemetry SDK中对数据进行导出、批处理或采样等操作的部分分开。这意味着仅仅使用上面的OpenTelemetry还不知道如何处理跨度以及如何将跨度输出到Jaeger。因此，我们必须在获取数据之前配置导出器:</p><pre class="ko kp kq kr gu md me mf mg aw mh bi"><span id="21f4" class="le lf ir me b gz mi mj l mk ml"># Set up exporting<br/>#  First set the name of our service<br/>resource = Resource(attributes={ SERVICE_NAME: "fake-rbac" })<br/># Configure the provider with the service name<br/>provider = TracerProvider(resource=resource)<br/># Set up the OTLP exporter as processor<br/>processor = BatchSpanProcessor(<br/>            <strong class="me is">OTLPSpanExporter(endpoint="http://localhost:4317"))</strong></span><span id="eca6" class="le lf ir me b gz mo mj l mk ml"># Tell OTEL to use this processor<br/>provider.add_span_processor(processor)</span><span id="fd90" class="le lf ir me b gz mo mj l mk ml"># And finally tell the tracer to use this provider<br/>trace.set_tracer_provider(provider)<br/><br/>tracer = trace.get_tracer(__name__)</span></pre><p id="4c62" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">首先，我们需要设置服务的名称。没有它也能工作，但耶格只会显示出<em class="ld">未知_服务</em>这不是我们想要的。然后，我们建立了出口商。在这种情况下，我选择了OTLP-Grpc导出程序。还有一个http/protobuf变体，如果您的grpc库有问题，这可能是理想的。对于该变体，您将配置端点使用端口4318，例如在<a class="ae km" href="http://localhost:4318/v1/traces" rel="noopener ugc nofollow" target="_blank">http://localhost:4318/v1/traces</a>中。</p><p id="1c87" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">当我现在使用curl访问我的服务时，我在Jaeger中看到一个很好的跟踪:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj mp"><img src="../Images/0fe1c4f45ba5e0899d734f227b5a305a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yD9RcTCgIgOdjKegdB2bIg.png"/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">概述中对我们服务的跟踪</figcaption></figure><h2 id="89e5" class="le lf ir bd lg lh li dn lj lk ll dp lm jz ln lo lp kd lq lr ls kh lt lu lv lw bi translated">让我们连接电话</h2><p id="ae35" class="pw-post-body-paragraph jo jp ir jq b jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl ik bi translated">现在让我们触发后端调用Python服务，看看会发生什么</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj mq"><img src="../Images/9bebfc34c41deeba9a7b46c8629b6af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c85KQHG_Rhf0ZBWu4Karbg.png"/></div></div></figure><p id="a710" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我看到了来自后端的跟踪，但没有提到假rbac Python服务。原因是我们还没有告诉我们的Python代码如何处理trace-id的传播。</p><p id="d91a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">而这(作为一个扣人心弦的:-)也是这个帖子的结尾。在<a class="ae km" href="https://pilhuhn.medium.com/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-2-d533e3a83703" rel="noopener">的下一篇文章</a>中，我会谈到<em class="ld">后端</em>和<em class="ld">假rbac </em>之间的痕迹传播。请再次记住，我在这里“手动”做了很多工作，以显示通常隐藏在检测库中的细节。这些库当然对日常工作有很大的帮助，所以我不想鼓励不使用它们。</p><p id="9964" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">感谢<a class="mr ms ep" href="https://medium.com/u/31f1d3c010e9?source=post_page-----2d83f761b786--------------------------------" rel="noopener" target="_blank">Jura ci paix o krhling</a>审阅本文。</p></div></div>    
</body>
</html>