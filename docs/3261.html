<html>
<head>
<title>3 Ways To Implement Responsive Design In Your React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React应用中实现响应式设计的3种方法</h1>
<blockquote>原文：<a href="https://itnext.io/3-ways-to-implement-responsive-design-in-your-react-app-bcb6ee7eb424?source=collection_archive---------0-----------------------#2019-11-08">https://itnext.io/3-ways-to-implement-responsive-design-in-your-react-app-bcb6ee7eb424?source=collection_archive---------0-----------------------#2019-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a26676992909242664297ab4d746bddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYGqYfPIt-FIVp2JGUgc0g.png"/></div></div></figure><h2 id="d2e5" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">反应——游戏规则的改变者</strong></h2><p id="15a7" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">React真正改变了我们现在开发web前端应用程序的方式。组件从一开始就违背了“关注点分离”的经验法则，选择利用JSX并将HTML和JS放在同一个文件中。UI元素现在通过它们自己的组件呈现，具有可重用性的所有意图和目的。</p><h2 id="9460" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">有求必应做了很多方面</h2><p id="06f5" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">响应式设计一直是一项要求，现在我们正在使用“移动优先”的思维模式构建应用程序，这比以往任何时候都更加重要。</p><p id="f0d6" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">使用最基本的方法，使用媒体查询实现了响应式设计，其中更有经验的开发人员可以选择添加响应“resize”事件的事件侦听器，并通过JS添加/移除样式。尽管如此，新手和有经验的开发人员都可能使用Bootstrap这样的前端框架，或者使用预定义的断点和定制组件来实现这些更改。</p><h2 id="cd4b" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">做出反应并实施响应式设计</strong></h2><p id="944c" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">因此，让我们来看看在您的下一个React应用程序中实现响应式设计的3种不同方法。</p><ol class=""><li id="44b7" class="lu lv iq kw b kx lp lb lq kh lw kl lx kp ly lo lz ma mb mc bi translated">媒体查询</li><li id="21b2" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo lz ma mb mc bi translated">内嵌样式</li><li id="c755" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo lz ma mb mc bi translated">高阶组件—(反应袜)</li></ol><p id="9e2d" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">流程</strong></p><p id="f30b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">当我们回顾实现响应式设计的不同方法时，我将关注以下几点，无论您采用哪种方法，这些都是必须完成的。</p><ol class=""><li id="638a" class="lu lv iq kw b kx lp lb lq kh lw kl lx kp ly lo lz ma mb mc bi translated">跟踪窗口大小(宽度/高度)的变化</li><li id="c95c" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo lz ma mb mc bi translated">添加/删除/更新必要的DOM元素以反映这些更改</li></ol><p id="cff4" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">演示版</strong></p><p id="a099" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">app:<a class="ae mi" href="https://wpixk.csb.app/" rel="noopener ugc nofollow" target="_blank">https://wpixk.csb.app/</a></p><p id="7ddc" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir"> <em class="mj">注意:</em> </strong>上面的演示使用的是内联式方法</p><p id="9f09" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">尽管该网站有许多响应功能，但出于演示的目的，我将只关注导航菜单，并进行以下更改:</p><p id="10f4" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">Mobile: width &lt; 1024 — Removes the top navigation and shows the hamburger icon</p><p id="ccd9" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">Desktop: width &gt; 1023 —显示导航元素并隐藏汉堡包图标</p><p id="8cb1" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">所以让我们开始吧！</p><h2 id="a8e5" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">媒体查询</h2><p id="66b1" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">CSS的力量永远不会停止给人惊喜和启发。我在CodePen上看到了无数的CSS艺术作品，几乎每天我都会学到一些关于CSS的新东西。因此，不言而喻，实现响应式设计的第一种方法是使用媒体查询。</p><p id="951c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">code sandbox:<a class="ae mi" href="https://codesandbox.io/s/mars-media-queries-0wqnv" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/mars-media-queries-0wqnv</a></p><p id="e888" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir"> <em class="mj">注:</em> </strong>媒体查询被添加到单独的<strong class="kw ir"> responsive.css </strong>文件中</p><p id="a02f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">跟踪窗口大小的变化</strong></p><p id="0204" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">使用<a class="ae mi" href="https://www.w3schools.com/cssref/css3_pr_mediaquery.asp" rel="noopener ugc nofollow" target="_blank"> CSS @media规则</a>跟踪窗口大小的变化，并将最小宽度设置为1024px。这实质上说明了此处定义的规则仅在窗口宽度最小为1024ppx时适用。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="91ba" class="jy jz iq mp b gy mt mu l mv mw">@media only screen and (min-width: 1024px) {</span><span id="8cb2" class="jy jz iq mp b gy mx mu l mv mw">}</span></pre><p id="c75b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">更新DOM元素</strong></p><p id="92dc" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在媒体查询规则中，添加了针对特定DOM元素的附加CSS规则。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="cf3b" class="jy jz iq mp b gy mt mu l mv mw">@media only screen and (min-width: 1024px) {<br/>  .container header .header-nav-area #nav_container  {<br/>    display:flex;<br/>  }<br/>}</span></pre><p id="b716" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">利弊</strong></p><p id="a72c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">赞成的意见</p><ul class=""><li id="b7e7" class="lu lv iq kw b kx lp lb lq kh lw kl lx kp ly lo my ma mb mc bi translated">应用起来相对简单</li><li id="0a96" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo my ma mb mc bi translated">任何具有基本CSS技能的人都可以创建和实现媒体查询</li></ul><p id="b0df" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">骗局</p><ul class=""><li id="3e20" class="lu lv iq kw b kx lp lb lq kh lw kl lx kp ly lo my ma mb mc bi translated">React将呈现被CSS隐藏的、从不使用的额外DOM元素</li><li id="a7b4" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo my ma mb mc bi translated">CSS在组件的外部</li><li id="f8db" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo my ma mb mc bi translated">CSS文件需要额外的导入</li></ul><h2 id="3937" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">内嵌样式</h2><p id="8451" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">每当我讲授介绍前端Web开发和内联风格的话题时，我总是强调说，“不要这样做”。然后我继续强调样式应该通过CSS来定义。直到我们开始学习JS和/或jQuery。风格还是。我们是否打破了规则。</p><p id="4639" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">code sandbox:<a class="ae mi" href="https://codesandbox.io/s/mars-inline-styles-wpixk" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/mars-inline-styles-wpixk</a></p><p id="9123" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir"> <em class="mj">注意:</em> </strong> Nav元素已经被拆分成它们自己的组件，并放置到一个TopNav文件夹中</p><p id="2411" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">跟踪窗口大小</strong></p><p id="3e98" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">跟踪窗口大小的变化要求我们向窗口对象添加一个事件侦听器来侦听“resize”事件。一旦“resize”事件发生，就会调用一个回调函数从窗口对象中检索当前宽度。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7527" class="jy jz iq mp b gy mt mu l mv mw">window.addEventListener(“resize”, updateDimensions)</span><span id="ecb2" class="jy jz iq mp b gy mx mu l mv mw">const updateDimensions = () =&gt; {<br/>  const width = window.innerWidth<br/>}</span></pre><p id="417d" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">既然钩子风靡一时，让我们导入并使用<strong class="kw ir"> useState </strong>来创建一个宽度变量及其支持的setWindowWidth()方法，该方法将用于更新updateDimensions()函数中的宽度。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d5bc" class="jy jz iq mp b gy mt mu l mv mw">import React, { useState } from 'react'</span><span id="9891" class="jy jz iq mp b gy mx mu l mv mw">function App() {<br/>  const [width, setWindowWidth] = useState(0);</span><span id="28fa" class="jy jz iq mp b gy mx mu l mv mw">  const updateDimensions = () =&gt; {<br/>    const width = window.innerWidth<br/>    setWindowWidth(width)<br/>  }</span><span id="eb3f" class="jy jz iq mp b gy mx mu l mv mw">  //…rest of App.js below…<br/>}</span></pre><p id="f75e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">然后，我们将创建一个支持函数，负责获取window.innerWidth值并更新状态:</p><p id="f032" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">添加事件监听器</strong></p><p id="571c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">现在必须导入<strong class="kw ir"> useEffect </strong>挂钩并用于以下操作:</p><ol class=""><li id="45c7" class="lu lv iq kw b kx lp lb lq kh lw kl lx kp ly lo lz ma mb mc bi translated">调用updateDimensions将初始宽度设置为当前窗口大小</li><li id="fc7f" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo lz ma mb mc bi translated">当组件挂载时添加事件监听器</li><li id="8469" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo lz ma mb mc bi translated">当组件卸载时，删除事件侦听器</li></ol><p id="2b8d" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">useEffect实质上替换了基于类的componentDidMount、componentDidUppdate和componentWillUnmount生命周期方法。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="a1ce" class="jy jz iq mp b gy mt mu l mv mw">import React, { useState, useEffect } from 'react'</span><span id="738c" class="jy jz iq mp b gy mx mu l mv mw">function App() {<br/>  const [width, setWindowWidth] = useState(0)</span><span id="8c6f" class="jy jz iq mp b gy mx mu l mv mw">   useEffect(() =&gt; { <br/><br/>     updateDimensions();<br/><br/>     window.addEventListener(“resize”, updateDimensions);</span><span id="8fd0" class="jy jz iq mp b gy mx mu l mv mw">     return () =&gt; <br/>       window.removeEventListener(“resize”,updateDimensions);</span><span id="3885" class="jy jz iq mp b gy mx mu l mv mw">    }, [])</span><span id="a159" class="jy jz iq mp b gy mx mu l mv mw">    const updateDimensions = () =&gt; {<br/>      const width = window.innerWidth<br/>      setWindowWidth(width)<br/>    }</span><span id="9af3" class="jy jz iq mp b gy mx mu l mv mw">   //…rest of App.js below…<br/>}</span></pre><p id="ea0a" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">更新元素</strong></p><p id="dbd7" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我选择创建一个对象，它使用条件逻辑来确定对宽度的任何更改是否需要显示/隐藏顶部导航。这将作为道具传递给<strong class="kw ir">标题</strong>。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0167" class="jy jz iq mp b gy mt mu l mv mw">const responsive = {<br/>  showTopNavMenu: width &gt; 1023<br/>}</span><span id="d043" class="jy jz iq mp b gy mx mu l mv mw">return (<br/>  &lt;&gt;<br/>    &lt;Header showTopNavMenu={responsive.showTopNavMenu}/&gt;<br/>    &lt;Main /&gt;<br/>  &lt;/&gt;<br/>)</span></pre><p id="b0b5" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">然后,<strong class="kw ir"> </strong>头计算出自己的逻辑来确定将用于显示/隐藏特定DOM元素的确切CSS。在这种情况下，元素的显示属性将设置为“flex”或“none”。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="abb5" class="jy jz iq mp b gy mt mu l mv mw">const showNav= {<br/>  display: showTopNavMenu ? 'flex' : 'none'<br/>}</span><span id="b43b" class="jy jz iq mp b gy mx mu l mv mw">const showMenuIcon = {<br/>  display: showTopNavMenu ? 'none' : 'flex',<br/>}</span><span id="c020" class="jy jz iq mp b gy mx mu l mv mw">return (<br/>   &lt;&gt;<br/>     &lt;div id="nav_container" style={showNav}&gt;<br/>       &lt;nav id="navigation"&gt;{navMenuItems}&lt;/nav&gt;<br/>     &lt;/div&gt;<br/>     &lt;span className="menu-icon" style={showMenuIcon}/&gt;<br/>   &lt;/&gt;<br/>)</span></pre><p id="bf6c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">下面是这些DOM元素在开发人员工具中的样子:</p><p id="4b91" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">桌面:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/96199791838c4ca1797382f43c0708ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNZIYwoLfH72Ayx_GSkG5A.png"/></div></div></figure><p id="c86d" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">平板电脑:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/4e25d34ab83c9bf9b47edfd39963011f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XMNJC8UK55pg0AUUPc7avg.png"/></div></div></figure><p id="93f2" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">利弊</strong></p><p id="c4e2" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">赞成的意见</p><ul class=""><li id="a19d" class="lu lv iq kw b kx lp lb lq kh lw kl lx kp ly lo my ma mb mc bi translated">响应式设计不再依赖于外部CSS文件</li><li id="9332" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo my ma mb mc bi translated">该组件更加独立和可重用</li><li id="c757" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo my ma mb mc bi translated">CSS被限定在这个组件的范围内，这样就减少了CSS冲突的可能性</li></ul><p id="5573" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">骗局</p><ul class=""><li id="6246" class="lu lv iq kw b kx lp lb lq kh lw kl lx kp ly lo my ma mb mc bi translated">比媒体查询要多得多的工作要做</li><li id="42b7" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo my ma mb mc bi translated">媒体查询更容易和直观地阅读</li></ul><h2 id="35f5" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">高阶组件</h2><p id="8644" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">有相当多的第三方库可供选择，为了这篇文章，我选择了<a class="ae mi" href="https://www.npmjs.com/package/react-socks" rel="noopener ugc nofollow" target="_blank"> React-Socks </a>。我争论使用的另一个方法是<a class="ae mi" href="https://www.npmjs.com/package/react-use-media" rel="noopener ugc nofollow" target="_blank"> react-use-media </a>，然而，我正在寻找一种更<a class="ae mi" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>的方法，这就是我使用React-Socks的原因。</p><p id="199b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">code sandbox:<a class="ae mi" href="https://codesandbox.io/s/mars-react-socks-xg8z2" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/mars-react-socks-xg8z2</a></p><p id="54c7" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">使用该库需要通过npm或yarn安装它。我在这些演示中使用了CodeSandbox，并通过“添加依赖项”将其导入。</p><p id="1b2f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">安装完成后，我们导入<strong class="kw ir">断点</strong>和<strong class="kw ir">断点提供者</strong>组件，并用<strong class="kw ir">断点提供者包装顶层组件。</strong></p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8f36" class="jy jz iq mp b gy mt mu l mv mw">import { Breakpoint, BreakpointProvider } from ‘react-socks’;</span><span id="9cd5" class="jy jz iq mp b gy mx mu l mv mw">function App() {</span><span id="271a" class="jy jz iq mp b gy mx mu l mv mw">//...rest of App.js above....</span><span id="53d4" class="jy jz iq mp b gy mx mu l mv mw">return (<br/>  &lt;BreakpointProvider&gt;<br/>    &lt;Header /&gt;<br/>    &lt;Main /&gt;<br/>  &lt;/BreakpointProvider&gt;</span><span id="b76d" class="jy jz iq mp b gy mx mu l mv mw">}</span></pre><p id="6a5d" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这个更高级的组件现在提供了对层次结构内所有子组件中的<strong class="kw ir">断点</strong>组件的访问。</p><p id="01a8" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">该库还提供了一些监听常见断点的配置。最简单的方法是使用<strong class="kw ir">小</strong>、<strong class="kw ir">中</strong>和<strong class="kw ir">大</strong>关键字来定位断点，然后将<strong class="kw ir">向上</strong>或<strong class="kw ir">向下</strong>分配给它们应该应用的方向。</p><p id="d2b7" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">nav_container将只在大桌面和更高的桌面(&gt; 1023)上显示，菜单图标将只在中等和更低的桌面(&lt;767).</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c541" class="jy jz iq mp b gy mt mu l mv mw">&lt;Breakpoint large up&gt;<br/>  &lt;div id=”nav_container” &gt;&lt;/div&gt;<br/>&lt;/Breakpoint&gt;</span><span id="a9c0" class="jy jz iq mp b gy mx mu l mv mw">&lt;Breakpoint medium down&gt;<br/>  &lt;div className=”menu-icon”&gt;&lt;/div&gt;<br/>&lt;/Breakpoint&gt;</span></pre><p id="5852" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">Here’s what those settings look like in developer tools when applied. Take note that the class name syntax uses the <a class="ae mi" href="https://www.integralist.co.uk/posts/bem/#4" rel="noopener ugc nofollow" target="_blank"> BEM </a>)上显示。</p><p id="cbe2" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">桌面:</strong></p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/f675ee631e09fc84b74ab1d7c5934dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWulzuN_NHFRkqAIQ6PqSg.png"/></div></div></figure><p id="9dde" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">平板电脑:</strong></p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/3b0a736fa9f1bb750f79cc834be1eab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75nxoCl0UYG-PtxfG6pS6w.png"/></div></div></figure><p id="a843" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">利弊</strong></p><p id="f9d8" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">赞成的意见</p><ul class=""><li id="78a5" class="lu lv iq kw b kx lp lb lq kh lw kl lx kp ly lo my ma mb mc bi translated">易于实施和配置</li><li id="e967" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo my ma mb mc bi translated">开发工具中的类名是语义性的，反映了变化</li></ul><p id="c275" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">骗局</p><ul class=""><li id="9132" class="lu lv iq kw b kx lp lb lq kh lw kl lx kp ly lo my ma mb mc bi translated">注意到删除/添加导航元素时有一点延迟</li><li id="2ea9" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo my ma mb mc bi translated">不适用于内联元素，比如spans，但这可能只是这个库的一个局限</li><li id="3ed9" class="lu lv iq kw b kx md lb me kh mf kl mg kp mh lo my ma mb mc bi translated">需要将内联元素更改为block或使用div而不是spans</li></ul><h2 id="c2f5" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">最后的想法</h2><p id="dd4e" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">随着React的不断发展和推进前端开发的边界，我们也需要重新思考旧的范例。如果你对媒体查询感到舒服，那么尽一切办法继续使用它们，但是随着越来越多的开发人员倾向于使用CSS-in-JS方法，你会发现自己很难不朝那个方向前进。</p><p id="469a" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">请记住，尽管在本例中不同方法的缺点很小，但在实际生产应用程序中，这些缺点可能会因更高的复杂性而加剧，并导致性能问题。</p><p id="ef3b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">特别感谢托马斯·尼克尔斯的额外反馈和评论，这些反馈和评论为文章增添了一些收尾工作。</p></div></div>    
</body>
</html>