<html>
<head>
<title>How to build a bluetooth low energy scanner using react native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用react native构建蓝牙低能耗扫描仪</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-a-bluetooth-low-energy-scanner-using-react-native-4e30bf877d7?source=collection_archive---------0-----------------------#2020-03-08">https://itnext.io/how-to-build-a-bluetooth-low-energy-scanner-using-react-native-4e30bf877d7?source=collection_archive---------0-----------------------#2020-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="98ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文探讨了如何创建一个基于Polidea的react-native蓝牙低能耗库的react原生应用程序。该应用程序可以发现蓝牙设备，查询它们的服务，确定每个服务的特征，并与读写特征进行交互。我的目标是帮助您了解如何与预配置的蓝牙低能耗(BLE)设备进行交互。为了演示这一功能，应用程序将使用标准Nordic UART RX/TX连接模式编写一个文本字符串。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/3f45a369265e2ef9e4570114643c5f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wZ6vJZ8GKJl-9Dub9g82A.png"/></div></div></figure><p id="4178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用的是兼容Arduino的Adafruit Flora平台和专为可穿戴设备定制的bluefruit LE add on。这个应用大致基于<a class="ae kx" href="https://github.com/adafruit/Bluefruit_LE_Connect_v2" rel="noopener ugc nofollow" target="_blank">AdaFruit iOS blue fruit _ LE _ Connect</a>应用，我用它来了解他们是如何实现UART传输功能的。我试图尽可能详细地让你理解扫描蓝牙设备和服务的概念。我有一个我在文章结尾写的源代码的链接，我确实建议你下载代码并尝试一下，以及调试它，无论你选择什么，我更喜欢使用<a class="ae kx" href="https://github.com/jhen0409/react-native-debugger" rel="noopener ugc nofollow" target="_blank"> react本机调试器</a>。本文假设您已经在没有使用Expo的情况下构建了一个react原生应用程序，并且已经完成了在手机上安装它的步骤。如果这是您第一次使用react原生应用程序或者尝试学习redux，您可能会感到沮丧。</p><p id="014b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里展示的流程是与大多数BLE设备通信的标准方式:首先搜索设备，然后连接到设备并确定其服务，选择一个服务来确定特征，然后与特定特征进行交互。虽然没有明确作为标准包括在内，但从微控制器的角度来看，Nordic UART服务已经变得非常普遍，因为假设您可以使用Arduino或Raspberry Pi等IDE对您的设备进行编程，您可以使用它来发送文本字符串形式的命令，这些文本字符串可以在您的设备上轻松翻译并可用于执行功能。Adafruit应用程序在其控制器中使用这一点，例如改变LED的颜色。应用程序会发送一个字符串，如“！C00FF00用于表示命令，接下来的值被解释为用于改变颜色的十六进制值。这是设备上的一段代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="5bed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个应用程序基于我在以前文章中的工作，所以它使用了类似的架构:我们将使用Polidea的<a class="ae kx" href="https://github.com/Polidea/react-native-ble-plx" rel="noopener ugc nofollow" target="_blank"> React Native BLE PLX </a>作为库来执行所有蓝牙通信，<a class="ae kx" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>用于状态管理，<a class="ae kx" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux Thunk </a>用于控制蓝牙管理器和设备并与之交互，<a class="ae kx" href="https://nativebase.io/" rel="noopener ugc nofollow" target="_blank"> Native Base </a>用于UI元素，<a class="ae kx" href="https://facebook.github.io/react-native/docs/flatlist" rel="noopener ugc nofollow" target="_blank"> React Native Flat List </a>用于显示BLE设备、服务和特性的列表， <a class="ae kx" href="https://facebook.github.io/react-native/docs/activityindicator" rel="noopener ugc nofollow" target="_blank">活动指示器</a>在我们查询蓝牙设备时显示一个微调器，以及<a class="ae kx" href="https://reactnavigation.org/" rel="noopener ugc nofollow" target="_blank">反应导航</a>用于管理应用程序屏幕。 我还擅自改进了以前代码的某些方面:我将react-navigation库更新到了最新版本，我使用了不变性助手来降低我的reducer的复杂性，我添加了一个数据活动UI组件，用于在与蓝牙设备通信时显示一个旋转的轮子。</p><p id="3996" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该应用的基本流程如下图所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0b8c00945848b890b9a55a749a20bea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQDbxNblEVTvvk_CYZBrpw.png"/></div></div></figure><h1 id="b108" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">iOS上的蓝牙</h1><p id="c203" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">开发一个蓝牙app，你将无法使用Expo，也无法在电脑上使用模拟器。我在以前的文章中概述了这些步骤，请阅读“<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/using-a-raspberry-pi-to-control-leds-part-iii-react-native-app-29ee3f4afb8c">如何与React Native </a>蓝牙”一节来了解所需的步骤。我想为iOS开发概述的另一个步骤是，您需要在Xcode中修改您的info.plist，以允许用户接受您的应用程序使用蓝牙。否则，在运行应用程序时会出现以下错误:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="491d" class="mi lb iq me b gy mj mk l ml mm"><strong class="me ir">BLEDiscoveryApp[21467:5688265] [access] This app has crashed because it attempted to access privacy-sensitive data without a usage description.  The app's Info.plist must contain an NSBluetoothAlwaysUsageDescription key with a string value explaining to the user how the app uses this data.</strong></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/4bfc82e1d4b09b55c6329f4b18685de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mjuzi9_Fvxr5lXZpEgf8_w.png"/></div></div></figure><p id="99d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，请在Xcode中打开您的工作区。在项目浏览器中，单击位于顶部的项目，然后选择您正在构建的目标应用程序。完成后，点击顶部的信息选项卡。要添加新密钥，请单击要添加新密钥的项目旁边的加号。这将在下面添加一个新项目。你可以滚动到隐私部分，也可以剪切粘贴“nsbluetooth alwaysusagedescription”。当用户第一次启动应用程序时，我选择了“我们使用蓝牙来查找设备”。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/071bb4c3316111afcaaaa40ec88e01d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*EmejNt3tXniuKf1NZJZl-Q.png"/></div></figure><h1 id="d76d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Redux:状态</h1><p id="ab8f" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">该应用程序的状态旨在使在FlatList组件中显示数据变得简单:应用程序中的每个屏幕都使用一个组件，该组件使用FlatList中的数据属性绑定到redux store中的一个对象:设备发现屏幕使用BLEList对象，服务屏幕使用connectedDeviceServices对象，特征屏幕使用connectedServiceCharacteristics。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="028a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了填充每个屏幕上的列表之外，我还使用store来保存关于用户选择的设备、服务和特性的信息。这是与设备和底层服务正确通信所必需的。为此，当用户点击列表中的设备、服务和特性时，我会将它们分别存储为connectedDevice、selectedService和selectedCharacteristic。</p><h1 id="1a32" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Redux:减速器</h1><p id="0d9b" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">正如我前面提到的，我添加了来自<a class="ae kx" href="https://github.com/kolodny" rel="noopener ugc nofollow" target="_blank"> Moshe Kolodny </a>的棒极了的库，叫做<a class="ae kx" href="https://github.com/kolodny/immutability-helper" rel="noopener ugc nofollow" target="_blank">不变性助手</a>，它极大地简化了我的缩减器。在我之前的应用程序中，我明确地返回了每个reducer的整个状态。每当我向存储中添加一个新对象时，这就变得容易出错和麻烦。为了解决这个问题，不变性助手函数允许我修改我的reducer中的特定对象，而不必显式地复制每个对象。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/5e0310631d7dbaa96e22590ff8038b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvV9DyzOLf5upm9j6SDsTw.png"/></div></div></figure><p id="4441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为这个库允许您用一个方法改变redux存储的深层副本，所以我可以减少状态对象的数量，但是，为了使事情易于理解，我使用带有$set参数的update函数来改变我的状态和从蓝牙管理器返回的对象。这有点像使用传播函数，但更容易阅读。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">还原剂</figcaption></figure><h1 id="db94" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Redux:动作</h1><p id="848e" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">大多数操作都是从一个thunks中分派的，用于专门更新状态。为了更容易理解，我的动作的名称与它们正在修改的对象相对应。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">行动</figcaption></figure><h1 id="4f47" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Redux: Thunk</h1><p id="7df4" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">理解应用程序中的思维和动作流可能会变得非常困难。每个组件的基本流程是相同的，所以我将突出显示第一个屏幕中发生的事情，以填充设备列表，我希望这将有助于您理解如何破译其他组件，以及它们各自的thunks和操作。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/93a84c909b69aaf5b1ac2cbf0412eb11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*vFY8mWo9TVtJeCW9WuZ57g.png"/></div></figure><p id="a586" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用thunks来控制我的应用程序与BLE设备的通信。每个功能根据应用程序窗口和用户交互执行特定的任务。这使得理解BLE需要执行的每个任务变得更加简单，也使得将它们与特定的用户交互联系起来变得更加简单。这些承诺的结果使用上述动作之一存储在redux存储中。查看上面的图表，当初始化BLEList组件时(调用构造函数)，我调用了thunk startScan()。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="5bbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数确保您手机的蓝牙处于开机状态，然后调用scan() thunk，查找您手机范围内的所有设备。如果在扫描设备之前没有检查电源是否打开，将会出现错误。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="2085" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">scan()函数与蓝牙设备管理器交互，以执行startDeviceScan函数。我将redux store中的状态更改为“scanning”，这是应用程序上的一个可视指示器，每次找到一个设备时，都会调用addBLE操作，将找到的设备作为输入。这将调用ADD_BLE缩减器，它将设备追加到BLEList数组中。将设备添加到阵列后，Flatlist组件会更新以反映新设备。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="e362" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序保持在上面列出的状态，直到用户点击他们想要连接的设备。如上面设备发现图的右侧所示，这将启动一个handleClick事件，该事件开始操作，使设备管理器连接到设备，更新存储中的设备对象，发现设备中的服务集，最后用提供的服务更新存储。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="db90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">屏幕和组件遵循与我上面描述的BLE列表流相似的模式。例如，当用户选择一个服务时，在服务屏幕上触发一个handleClick事件，该事件将用户导航到特征组件，该组件调用“getServiceCharacteristics。这告诉Bluetooth设备管理器为连接的设备查找服务，然后调用“connectedServiceCharacteristics”操作，该操作调用“CONNECTED _ CHARACTERISTICS”缩减器，最后更新存储。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><h1 id="cb3e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">与特征交互</h1><p id="1296" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">到目前为止，我所描述的代码应该可以在手机连接范围内的任何蓝牙设备上运行。我很惊讶有这么多设备，尤其是在你家里！我发现我的电动牙刷竟然还有蓝牙！既然我们正在研究与特定特征的实际交互，那么你就要自己学习如何与你的特定设备进行交互。如果这些设备遵循任何标准化的GATT服务定义，你应该能够编写或找到一些代码来使用它们。我写这个应用程序的目标是与基于Arduino的蓝牙设备通信，并能够向它们发送特殊命令来帮助我完成项目，这些项目主要是关于<a class="ae kx" href="https://www.linkedin.com/pulse/my-bluetooth-enabled-led-tuxedo-gregg-larson/" rel="noopener ugc nofollow" target="_blank">可穿戴设备和led</a>。</p><p id="b99c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了演示这种能力，我想指出的最后一个函数是“write character istic”thunk，它执行向连接的设备发送数据的工作。此功能可能需要根据您正在通信的设备进行调整:我正在使用基于Arduino的蓝牙连接，一些设置(如packetsize)已写入Arduino代码。如果看不到结果，您可以尝试将该数字调整为较小的值。这个函数接收一个ASCII字符串，将其转换成一个uint8数组，然后将数据作为20字节的数据包进行传输，直到所有信息都发送完毕。为了实现这一点，我使用了名为“writecharacteringwithouttresponseforservice”的蓝牙功能，该功能允许在设备没有响应的情况下发送数据包。Arduino设备正在寻找“\n”或字符代码(10)来表示字符串的结束。我在handleClick事件中追加了这个值:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><h1 id="dc0f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">助手功能</h1><p id="2d77" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我使用了几个函数来帮助通过蓝牙传输字符串。第一个是将字符串转换为uint8array的函数:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="ad4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个功能是在传输结束时添加一个循环冗余校验(CRC)字节，用于确保数据包正确到达设备。像这样通过蓝牙传输数据可能会有问题，因此在传输结束时包含一个CRC值是一个很好的做法，您的设备可以使用它来确保成功传输。我没有使用它，因为我使用的Arduino代码不需要它。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><h1 id="257a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">反应导航</h1><p id="0532" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">与我之前的代码相比，另一个改进是我将react-navigation库升级到了最新版本，这简化了一些事情，并认为我应该突出这些变化。大部分的改动都是在<a class="ae kx" href="https://github.com/momolarson/BLEServiceDiscovery/blob/master/App.js" rel="noopener ugc nofollow" target="_blank"> app.js </a>中处理的。我们现在导入新的库并创建一个StackNavigator，并返回一个导航容器，该容器使用一堆用于导航的屏幕。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="12ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组件之间最大的区别是移除了withNavigation包装。导航栈包含在redux store中，您可以简单地调用导航函数，并将上面定义的一个屏幕的名称传递给它。</p><h1 id="258d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">UI组件</h1><p id="2ffc" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">显示设备、服务和特性列表的UI组件都依赖于一个Flatlist和一个处于redux状态的数组，所以我将突出显示其中一个，其他的组件可以查看代码来找出每个组件的细节。</p><p id="030c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">黑名单</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="9814" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还想强调一下用于确定特征是读还是写的组件，我将向您展示用于向设备写入数据的UI。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="168e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据活动指示器</strong></p><p id="aacc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FlatList组件的一个很好的特性是能够附加另一个组件，当没有要显示的项目时，这个组件就会显示出来。使用<a class="ae kx" href="https://reactnative.dev/docs/flatlist#listemptycomponent" rel="noopener ugc nofollow" target="_blank">“ListEmptyComponent”属性</a>，我创建了一个特殊的组件，它使用了<a class="ae kx" href="https://reactnative.dev/docs/activityindicator" rel="noopener ugc nofollow" target="_blank"> React本机活动指示器</a>，这是一个旋转的图标，当应用程序搜索设备、服务和特性时会显示出来。这有助于给用户一些关于正在发生什么的反馈，这比空白屏幕好得多。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ky kz l"/></div></figure><h1 id="0b8b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="1b13" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我开发这个应用程序的动机是帮助我更好地理解蓝牙通信，而不是专注于控制设备执行特定任务的特定问题集。实际上，如果您知道您正在使用的设备、服务和特征，您就不需要特意要求用户交互来完成每个步骤。也就是说，需要使用设备管理器执行发现操作，以便它能够理解如何通信，因此，您需要以编程方式执行每个步骤，以免出错。如果您不这样做，设备管理器会抱怨服务或特性不存在，即使您知道它们存在。</p><h1 id="ad44" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">密码</h1><div class="mv mw gp gr mx my"><a href="https://github.com/momolarson/BLEServiceDiscovery" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">momolarson/BLEServiceDiscovery</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">通过在GitHub上创建帐户，为momolarson/BLEServiceDiscovery开发做出贡献。</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">github.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm kv my"/></div></div></a></div><h1 id="d0c7" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">关于我</h1><div class="mv mw gp gr mx my"><a href="https://www.linkedin.com/in/gregglarson/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">Gregg Larson -软件开发副总裁- Concept3D Inc. | LinkedIn</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">我的职业生涯一直致力于帮助初创公司成长为盈利的公司，我有一个成功的记录…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.linkedin.com</p></div></div><div class="nh l"><div class="nn l nj nk nl nh nm kv my"/></div></div></a></div><h1 id="006f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">了解更多信息</h1><p id="26f0" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">了解循环冗余校验:</p><div class="mv mw gp gr mx my"><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">循环冗余校验</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">循环冗余校验(CRC)是一种错误检测代码，通常用于数字网络和存储设备中，以…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">en.wikipedia.org</p></div></div><div class="nh l"><div class="no l nj nk nl nh nm kv my"/></div></div></a></div></div></div>    
</body>
</html>