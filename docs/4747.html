<html>
<head>
<title>Configure Custom Tooling in Argo CD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Argo CD中配置定制工具</h1>
<blockquote>原文：<a href="https://itnext.io/configure-custom-tooling-in-argo-cd-a4948d95626e?source=collection_archive---------0-----------------------#2020-09-06">https://itnext.io/configure-custom-tooling-in-argo-cd-a4948d95626e?source=collection_archive---------0-----------------------#2020-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1627dd913853e34e24d9d54a9aa0ecc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tcU-h452sfjDT96C.png"/></div></div></figure><p id="a3f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在写完第一篇文章之后的一段时间，我巧妙地使用了jsonnet和gitlab，我意识到管道当然是好的，但是不必要的困难和不便。</p><p id="4377" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在大多数情况下，一个典型的任务是需要:“生成YAML，并把它放在Kubernetes”。事实上，这是阿尔戈光盘做得很好。</p><p id="36ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Argo CD允许您连接Git存储库，并将其状态同步到Kubernetes。默认支持几种类型的应用程序:Kustomize、Helm charts、Ksonnet、raw Jsonnet或带有YAML/JSON清单的简单目录。</p><p id="8e5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数用户会为拥有这个工具集而高兴，但不是所有人。为了满足任何人的需求，Argo CD有能力使用定制工具。</p><p id="36fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我对有机会添加对<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/trying-new-tools-for-building-and-automate-the-deployment-in-kubernetes-f96f9684e580#4c4b"> qbec </a>和<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/trying-new-tools-for-building-and-automate-the-deployment-in-kubernetes-f96f9684e580#29ed"> git-crypt </a>的支持很感兴趣，这在之前的文章中有充分的讨论。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="00f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开始配置之前，我们需要先了解Argo光盘是如何工作的。<br/>对于每个添加的应用程序，它有两个阶段:</p><ul class=""><li id="0deb" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir">init</strong>—部署前的初始准备，任何东西都可以在这里:依赖项下载、解包秘密等等。</li><li id="7b95" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir"> generate </strong> —执行生成清单的命令，输出必须是有效的YAML流，这正是将应用于集群的内容。</li></ul><p id="754e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，Argo将这种方法应用于任何类型的应用，包括Helm。因此，在Argo中，CD Helm不将任何版本部署到集群，而是仅用于生成清单。</p><p id="0382" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从另一方面来说，Argo能够处理头盔挂钩，这允许不打破应用释放的逻辑。</p><h1 id="da10" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">QBEC</h1><p id="848e" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">Qbec允许您使用jsonnet方便地描述应用程序，此外，它具有渲染舵图的能力，并且由于Argo CD可以处理舵钩，使用Argo CD的这一功能可以让您获得更正确的结果。</p><p id="0bc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了给argocd添加qbec支持，您需要两件东西:</p><ul class=""><li id="2ebf" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">您的Argo CD配置必须包含自定义插件定义以及用于生成清单的特定命令。</li><li id="04a4" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">所需的二进制文件必须在<strong class="ka ir"> argocd-repo-server </strong>映像中可用。</li></ul><p id="7a3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个任务<a class="ae kw" href="https://argoproj.github.io/argo-cd/user-guide/config-management-plugins/" rel="noopener ugc nofollow" target="_blank">很简单地解决了</a>:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1eb5" class="ne lt iq na b gy nf ng l nh ni"># cm.yaml<br/>data:<br/>  configManagementPlugins: |<br/>    - name: qbec<br/>      generate:<br/>        command: [sh, -xc]<br/>        args: ['qbec show "$ENVIRONMENT" -S --force:k8s-namespace "$ARGOCD_APP_NAMESPACE"']</span></pre><p id="8890" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nj">(命令</em> <strong class="ka ir"> <em class="nj">初始化</em> </strong> <em class="nj">不使用)</em></p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3a80" class="ne lt iq na b gy nf ng l nh ni">$ kubectl -n argocd patch cm/argocd-cm -p "$(cat cm.yaml)"</span></pre><p id="df06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了添加二进制文件，建议构建一个新的映像，或者使用带有init-container 的<a class="ae kw" href="https://argoproj.github.io/argo-cd/operator-manual/custom_tools/#adding-tools-via-volume-mounts" rel="noopener ugc nofollow" target="_blank">技巧:</a></p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f8dd" class="ne lt iq na b gy nf ng l nh ni"># deploy.yaml<br/>spec:<br/>  template:<br/>    spec:<br/>      # 1. Define an emptyDir volume which will hold the custom binaries<br/>      volumes:<br/>      - name: custom-tools<br/>        emptyDir: {}<br/>      # 2. Use an init container to download/copy custom binaries into the emptyDir<br/>      initContainers:<br/>      - name: download-tools<br/>        image: alpine:3.12<br/>        command: [sh, -c]<br/>        args:<br/>        - wget -qO- https://github.com/splunk/qbec/releases/download/v0.12.2/qbec-linux-amd64.tar.gz | tar -xvzf - -C /custom-tools/<br/>        volumeMounts:<br/>        - mountPath: /custom-tools<br/>          name: custom-tools<br/>      # 3. Volume mount the custom binary to the bin directory (overriding the existing version)<br/>      containers:<br/>      - name: argocd-repo-server<br/>        volumeMounts:<br/>        - mountPath: /usr/local/bin/qbec<br/>          name: custom-tools<br/>          subPath: qbec<br/>        - mountPath: /usr/local/bin/jsonnet-qbec<br/>          name: custom-tools<br/>          subPath: jsonnet-qbec</span><span id="780a" class="ne lt iq na b gy nk ng l nh ni">$ kubectl -n argocd patch deploy/argocd-repo-server -p "$(cat deploy.yaml)"</span></pre><p id="2338" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看我们的应用程序的清单是什么样子的:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="647e" class="ne lt iq na b gy nf ng l nh ni">apiVersion: argoproj.io/v1alpha1<br/>kind: Application<br/>metadata:<br/>  name: qbec-app<br/>  namespace: argocd<br/>spec:<br/>  destination: <br/>    namespace: default<br/>    server: <a class="ae kw" href="https://kubernetes.default.svc" rel="noopener ugc nofollow" target="_blank">https://kubernetes.default.svc</a><br/>  project: default<br/>  source: <br/>    path: examples/test-app<br/>    targetRevision: fix-example<br/>    plugin: <br/>      env: <br/>        - name: ENVIRONMENT<br/>          value: dev<br/>      name: qbec<br/>    repoURL: <a class="ae kw" href="https://github.com/kvaps/qbec" rel="noopener ugc nofollow" target="_blank">https://github.com/kvaps/qbec</a><br/>  syncPolicy: <br/>    automated: <br/>      prune: true</span></pre><p id="970c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">环境变量包含我们需要为其生成清单的环境的名称。</p><p id="8350" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">申请并看看我们得到了什么:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/386040379cb6033b79065e08f16cf6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*drkPpgDHwOWYZIA2.png"/></div></div></figure><p id="d6e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序已启动并运行，太棒了！</p><h1 id="567a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">git-crypt</h1><p id="9773" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">Git-crypt允许您设置存储库的透明加密。这是在git中存储敏感数据的一种简单而安全的方法。</p><p id="a24a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">git-crypt实现变得更加困难。理论上，我们可以在自定义插件的初始化阶段运行<code class="fe nm nn no na b">git-crypt unlock</code>,但是这不是很方便，因为它不允许使用本地部署方法。例如，在Helm和Jsonnet的情况下，我们失去了一个简化应用程序配置(值文件等)的灵活的GUI界面。).<br/>这就是为什么我想在克隆的早期就解封仓库。</p><p id="ad70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为目前Argo CD不提供描述任何用于同步存储库的钩子的能力，所以我不得不使用一个包装git命令的复杂的shell脚本来绕过这个限制:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="bb1f" class="ne lt iq na b gy nf ng l nh ni">#!/bin/sh<br/>$(dirname $0)/git.bin "$@"<br/>ec=$?<br/>[ "$1" = fetch ] &amp;&amp; [ -d .git-crypt ] || exit $ec<br/>GNUPGHOME=/app/config/gpg/keys git-crypt unlock 2&gt;/dev/null<br/>exit $ec</span></pre><p id="26c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每次部署操作前，Argo CD都会运行<code class="fe nm nn no na b">git fetch</code>。Exaclty这个命令我用来处理执行<code class="fe nm nn no na b">git-crypt unlock</code>来解锁仓库。</p><p id="3a49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于测试，您可以使用我的docker图像，它已经有了所有需要的东西:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f37d" class="ne lt iq na b gy nf ng l nh ni">$ kubectl -n argocd set image deploy/argocd-repo-server argocd-repo-server=docker.io/kvaps/argocd-git-crypt:v1.7.3</span></pre><p id="60a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要考虑Argo将如何解密储存库。</p><p id="15df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们为它生成一个gpg密钥:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="58cf" class="ne lt iq na b gy nf ng l nh ni">$ kubectl exec -ti deploy/argocd-repo-server -- bash</span><span id="7d69" class="ne lt iq na b gy nk ng l nh ni">$ printf "%s\n" \<br/>    "%no-protection" \<br/>    "Key-Type: default" \<br/>    "Subkey-Type: default" \<br/>    "Name-Real: YOUR NAME" \<br/>    "Name-Email: YOUR EMAIL@example.com" \<br/>    "Expire-Date: 0" \<br/>    &gt; genkey-batch </span><span id="f82b" class="ne lt iq na b gy nk ng l nh ni">$ gpg --batch --gen-key genkey-batch<br/>gpg: WARNING: unsafe ownership on homedir '/home/argocd/.gnupg'<br/>gpg: keybox '/home/argocd/.gnupg/pubring.kbx' created<br/>gpg: /home/argocd/.gnupg/trustdb.gpg: trustdb created<br/>gpg: key 8CB8B24F50B4797D marked as ultimately trusted<br/>gpg: directory '/home/argocd/.gnupg/openpgp-revocs.d' created<br/>gpg: revocation certificate stored as '/home/argocd/.gnupg/openpgp-revocs.d/9A1FF8CAA917CE876E2562FC8CB8B24F50B4797D.rev'</span></pre><p id="dc07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">保存密钥名称<code class="fe nm nn no na b">8CB8B24F50B4797D</code>以供后续步骤使用，然后导出密钥本身:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="4051" class="ne lt iq na b gy nf ng l nh ni">$ gpg --list-keys<br/>gpg: WARNING: unsafe ownership on homedir '/home/argocd/.gnupg'<br/>/home/argocd/.gnupg/pubring.kbx<br/>-------------------------------<br/>pub   rsa3072 2020-09-04 [SC]<br/>      9A1FF8CAA917CE876E2562FC8CB8B24F50B4797D<br/>uid           [ultimate] YOUR NAME &lt;YOUR EMAIL@example.com&gt;<br/>sub   rsa3072 2020-09-04 [E]</span><span id="134f" class="ne lt iq na b gy nk ng l nh ni">$ gpg --armor --export-secret-keys 8CB8B24F50B4797D</span></pre><p id="c82c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将其添加为单独的秘密:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="c907" class="ne lt iq na b gy nf ng l nh ni"># argocd-gpg-keys-secret.yaml<br/>apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: argocd-gpg-keys-secret<br/>  namespace: argocd<br/>stringData:<br/>  8CB8B24F50B4797D: |-<br/>    -----BEGIN PGP PRIVATE KEY BLOCK-----</span><span id="c059" class="ne lt iq na b gy nk ng l nh ni">    lQVYBF9Q8KUBDACuS4p0ctXoakPLqE99YLmdixfF/QIvXVIG5uBXClWhWMuo+D0c<br/>    ZfeyC5GvH7XPUKz1cLMqL6o/u9oHJVUmrvN/g2Mnm365nTGw1M56AfATS9IBp0HH<br/>    O/fbfiH6aMWmPrW8XIA0icoOAdP+bPcBqM4HRo4ssbRS9y/i<br/>    =yj11<br/>    -----END PGP PRIVATE KEY BLOCK-----</span><span id="bb60" class="ne lt iq na b gy nk ng l nh ni">$ kubectl apply -f argocd-gpg-keys-secret.yaml</span></pre><p id="fa17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">剩下的唯一一件事就是将它连接到<strong class="ka ir"> argocd-repo-server </strong>容器，以实现这个编辑部署:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="d885" class="ne lt iq na b gy nf ng l nh ni">$ kubectl -n argocd edit deploy/argocd-repo-server</span></pre><p id="4dd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将现有的<strong class="ka ir"> gpg-keys </strong>卷类型替换为<code class="fe nm nn no na b">projected</code>，并在那里指定我们的秘密:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="fef0" class="ne lt iq na b gy nf ng l nh ni">spec:<br/>  template:<br/>    spec:<br/>      volumes:<br/>      - name: gpg-keys<br/>        projected:<br/>          sources:<br/>          - secret:<br/>            name: argocd-gpg-keys-secret<br/>          - configMap:<br/>            name: argocd-gpg-keys-cm</span></pre><p id="89b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Argo CD在启动时自动从这个目录加载gpg密钥，所以它也加载我们的私钥。</p><p id="16f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们检查一下:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="fb58" class="ne lt iq na b gy nf ng l nh ni">$ kubectl -n argocd exec -ti deploy/argocd-repo-server -- bash<br/>$ GNUPGHOME=/app/config/gpg/keys gpg --list-secret-keys<br/>gpg: WARNING: unsafe ownership on homedir '/app/config/gpg/keys'<br/>/app/config/gpg/keys/pubring.kbx<br/>--------------------------------<br/>sec   rsa2048 2020-09-05 [SC] [expires: 2021-03-04]<br/>      ED6285A3B1A50B6F1D9C955E5E8B1B16D47FFC28<br/>uid           [ultimate] Anon Ymous (ArgoCD key signing key) &lt;noreply@argoproj.io&gt;</span><span id="70ce" class="ne lt iq na b gy nk ng l nh ni">sec   rsa3072 2020-09-03 [SC]<br/>      9A1FF8CAA917CE876E2562FC8CB8B24F50B4797D<br/>uid           [ultimate] YOUR NAME &lt;YOUR EMAIL@example.com&gt;<br/>ssb   rsa3072 2020-09-03 [E]</span></pre><p id="aa48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，钥匙装好了！现在我们只需要将Argo CD作为合作者添加到我们的存储库中。这将实现动态自动解密。</p><p id="7cf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将密钥导入本地计算机:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1589" class="ne lt iq na b gy nf ng l nh ni">$ <!-- -->GNUPGHOME=/app/config/gpg/keys gpg --armor --export <!-- -->8CB8B24F50B4797D &gt; 8CB8B24F50B4797D.pem<br/>$ gpg --import 8CB8B24F50B4797D.pem</span></pre><p id="b3d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">信任密钥:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e020" class="ne lt iq na b gy nf ng l nh ni">$ gpg --edit-key 8CB8B24F50B4797D<br/>trust<br/>5</span></pre><p id="2ff1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将argo作为协作者添加到您的git项目中:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ec66" class="ne lt iq na b gy nf ng l nh ni">$ git-crypt add-gpg-user 8CB8B24F50B4797D</span></pre><p id="fc29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">相关链接</strong>:</p><ul class=""><li id="9829" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><a class="ae kw" href="http://github.com/kvaps/argocd-git-crypt" rel="noopener ugc nofollow" target="_blank"> GitHub:带有修改图像的存储库</a></li><li id="9091" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae kw" href="https://argoproj.github.io/argo-cd/operator-manual/custom_tools/" rel="noopener ugc nofollow" target="_blank"> Argo CD:定制工具</a></li><li id="266e" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae kw" href="https://argoproj.github.io/argo-cd/user-guide/config-management-plugins/" rel="noopener ugc nofollow" target="_blank"> Argo光盘:配置管理插件</a></li><li id="c347" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae kw" href="https://gist.github.com/vrillusions/5484422" rel="noopener ugc nofollow" target="_blank"> GitHub要点:通过批处理文件生成gpg密钥</a></li></ul></div></div>    
</body>
</html>