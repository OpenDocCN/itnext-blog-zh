<html>
<head>
<title>Making the Spark DataFrame composition type safe(r)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使火花数据帧合成类型安全(r)</h1>
<blockquote>原文：<a href="https://itnext.io/making-the-spark-dataframe-composition-type-safe-r-7b6fed524ec2?source=collection_archive---------5-----------------------#2021-02-03">https://itnext.io/making-the-spark-dataframe-composition-type-safe-r-7b6fed524ec2?source=collection_archive---------5-----------------------#2021-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b6893553dbbb41a289aaa03679bb8985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5GU3nxf3_WvCgejX"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">米卡·鲍梅斯特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="59a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Spark 1.6中，引入了类型化数据集API。这是一个非常强大的特性，支持高阶函数(map、flatMap等)。)和类型安全转换，其正确性在编译时得到验证。类型化API并非没有缺点，其中一些缺点是:</p><ul class=""><li id="517c" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">Spark配备了一系列SQL函数，这通常会让生活变得更加轻松。例如，<em class="lk"> coalesce(a，b，c) </em>看起来比<em class="lk">r =&gt;r . a or else(r . b)干净得多。getOrElse(r.c) </em>。尽管后者显然是类型安全的，而前者却不是。</li><li id="f597" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">在许多情况下，使用非类型化API对于数据转换来说更方便。考虑一个使用从现有属性派生的附加属性来扩展输入的用例。这可以通过使用<a class="ae kc" href="https://spark.apache.org/docs/latest/api/java/org/apache/spark/sql/Dataset.html#withColumn-java.lang.String-org.apache.spark.sql.Column-" rel="noopener ugc nofollow" target="_blank"> <em class="lk">和</em> </a>列的方法轻松实现。来自类型化数据集API的高阶函数将需要创建一个新类型(原始类型的超集)，这又会导致在计算新属性的同时复制所有未改变的属性。这个过程很快就变得繁琐而难以维护。另外，每次输入的模式改变时，代码中的多个地方都需要更新。</li><li id="1b67" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">尽管数据集和数据帧之间的性能差距不断缩小，但Spark仍然无法反思前者使用的lambdas，Catalyst optimizer最终会为后者提供更好的性能。关于这个话题有石崎和树博士的综合讲座(<a class="ae kc" href="https://databricks.com/session/demystifying-dataframe-and-dataset" rel="noopener ugc nofollow" target="_blank">链接</a>)。</li><li id="1390" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">一旦我们通过连接将数据集组合在一起，类型将不可避免地丢失。人们总是可以求助于使用<a class="ae kc" href="https://spark.apache.org/docs/latest/api/java/org/apache/spark/sql/Dataset.html#joinWith-org.apache.spark.sql.Dataset-org.apache.spark.sql.Column-" rel="noopener ugc nofollow" target="_blank"> <em class="lk"> joinWith </em> </a> <em class="lk"> </em>方法，该方法返回一个类型化元组的数据集，但事实证明，该输出很少能在下游使用。通常需要做额外的工作来使输出平坦，以便可以存储在表中。身边还带着<em class="lk"> _1 </em>、<em class="lk"> _2 </em>等。引用使得代码更难阅读和理解。以这种方式连接两个以上的数据集会使问题变得更糟。</li></ul><p id="8346" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于上述原因，我经常看到非类型化的DataFrame API比它的强类型对应API更受青睐。</p><p id="0da5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同时，如果我们能在编译时确保数据帧转换和组合的正确性，那就太好了。这就是为什么本文的目的是回答一个问题:<strong class="kf ir">我们是否可以利用Scala类型系统的能力，为非类型化DataFrame API引入某种级别的类型安全，同时保留这个API提供的其他好处？</strong></p><h1 id="cb3d" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">假设和要求</h1><p id="0804" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在OLAP世界中，大多数(但不是全部)日常遇到的用例涉及一个单一的事实表(或其他来源),伴随着多个维度表。常见的管道实现包括以下操作的任意组合:</p><ul class=""><li id="6ad0" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">从不同的来源(蜂巢/冰山表、拼花文件等)创建一个或多个数据集(事实和维度)。)</li><li id="644a" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">事实数据集(进一步称为“事实”)通过与一个或多个维度数据集的组合(连接)来扩展维度属性。</li><li id="5ced" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">使用一些谓词过滤事实。</li><li id="161c" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">用从现有属性计算出的新属性来扩展事实。</li><li id="379b" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">事实在一个或多个维度上聚合(分组依据)。</li><li id="c995" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">生成的数据集被投影以匹配输出的模式，并存储在Hive/Iceberg表或其他位置。</li></ul><p id="5868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文主要关注这个列表中的前两个操作:数据集创建和组合。</p><p id="58c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到上述假设，我们现在可以概述以下要求:</p><ol class=""><li id="2b6e" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la mt lh li lj bi translated">我们需要一种方法，在创建时用相应的源“注释”每个数据帧实例。在缺乏强类型API的情况下，我们需要某种类型的“标签”,它将指示给定的DataFrame实例代表哪种数据集。</li><li id="f4da" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la mt lh li lj bi translated">假设满足了第一个要求，我们应该能够组合(通过连接)带注释的数据帧实例。理想情况下，我们希望保留这个组合的血统，并在类型级别上反映出来。</li></ol><p id="cb14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实证明，Scala可以满足这两个要求。</p><h1 id="fadc" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">遇见未注释的数据框架</h1><p id="bf20" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">让我们首先关注第一个需求，看看如何用类型“tag”来丰富每个DataFrame实例，该类型“tag”指示给定实例的来源。为了实现这一点，我们引入了一个名为<em class="lk"> AnnotatedDataFrame </em>的新实体:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">定义中的类型参数<strong class="kf ir"> D </strong> ( <strong class="kf ir"> d </strong> ataset)就是我们之前说的那个“标签”。</p><p id="3d6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要建立一种惯用的方法来产生带注释的数据帧实例。为此，我们引入一个名为<em class="lk"> DataSource </em>的类型类:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9506" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这两个定义，我们现在可以尝试定义一些数据集。</p><p id="d9f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们想象一下，我们对从一些任意设备收集的测量值进行分析。假设我们用以下两个数据集来建模我们的数据:</p><ul class=""><li id="7449" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">设备模型</strong> —维度数据集。每个记录包含每个已知设备型号的详细信息(型号名称、硬件规格等。).该数据集中的主键是<em class="lk">设备型号id </em>。</li><li id="caa8" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated"><strong class="kf ir">设备测量</strong> —事实数据集。该数据集中的每条记录代表从设备收集的单个测量值，包括<em class="lk"> device_model_id </em>属性，该属性是用于引用<strong class="kf ir"> DeviceModel </strong>数据集的外键。</li></ul><p id="79a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以将上述定义转换成类型标签，并实现各自的<em class="lk">数据源</em>实例。</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1e35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使例子更简单，我们省略了自定义源参数，只在第二个类型参数中提供了<em class="lk">单元</em>给<em class="lk">数据源</em>类型类。</p><p id="530b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DeviceMeasurement标记和源实例的定义看起来非常相似:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3a63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在很容易在我们的Spark应用程序中实例化2个数据集:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="eafc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们将创建<em class="lk"> AnnotatedDataFrame </em>实例的过程与实际使用它的逻辑分离得多么好。</p><p id="eb4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一点上，我们不再处理裸露的数据帧。我们现在可以通过查看每个实例的类型来推断其来源。不幸的是，这种方法的实用性和适用性非常有限。缺失的部分可以在我们的第二个需求中找到:通过连接组成带注释的数据集。</p><h1 id="89d1" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">类型安全连接</h1><p id="985e" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">因为我们将数据集建模为类型参数，所以我们需要另一个类型类来描述如何连接任意两个数据集。让我们从一个简单的定义开始:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="da64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">马上弹出的第一个问题:在<em class="lk"> join </em>函数的返回类型中，应该用什么类型参数来代替一个问号？</p><p id="033a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们重温一下我们之前所做的假设，并对其进行一些扩展:</p><ul class=""><li id="1e47" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">我们正在处理连接到一个或多个维度数据集的单个事实数据集。</li><li id="b172" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">当连接时，我们希望事实数据集在左边，而维度数据集在右边。</li><li id="3dfa" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">有时，维度数据集也可以位于左侧。这方面的一个例子是从多个规范化的源组成一个维度数据集。</li></ul><p id="b96c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定上面的假设，我们得出结论，我们的连接的组成应该是面向左的，这导致选择<strong class="kf ir"> L </strong>作为输出类型的类型参数。</p><p id="0547" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦实现了相应的<em class="lk"> Join </em>实例，我们会在代码中看到类似这样的内容:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3892" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不错，但还是不够好。产生的类型丢失了所有关于带有来自<strong class="kf ir">设备模型</strong>的属性的<strong class="kf ir">设备测量</strong>数据集的扩展的信息。在编译器看来<em class="lk">enrichedDeviceMeasurement</em>和<em class="lk"> deviceMeasurement </em>是等价的(类型方面)，尽管在这一点上它们是完全不同的实体。</p><p id="d95b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有没有一种方法可以跟踪哪些数据集被加入到我们的事实数据集，并在类型级别存储这些信息？原来是有的！</p><h1 id="7c08" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">修订的注释数据框架</h1><p id="2157" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">解决方案就在问题本身之中:我们只需要维护一个连接数据集的异构列表，并将其存储为一种类型。</p><p id="d629" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，类型安全异构列表已经在<a class="ae kc" href="https://github.com/milessabin/shapeless" rel="noopener ugc nofollow" target="_blank"> Shapeless </a>中实现了——一个Scala的通用编程库。我们需要的类型叫做<em class="lk"> HList </em>，它本质上是一个<em class="lk">列表</em>，其中每个元素的类型在编译时都是静态已知的。后一个属性使得<em class="lk"> HList </em>更类似于Scala的tuple。例如:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="fce3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于<em class="lk"> HList </em>有趣的事情是，它的项目同时存在于两个平面上:作为值(<em class="lk"> 1，" Hello "，Foo("World") </em>)，也作为类型(<em class="lk"> Int，String，Foo </em>)。</p><p id="eb41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们并不关心HList的值，但是我们可以从它的类型属性中获益匪浅。</p><p id="6159" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们先介绍一个<em class="lk"> JoinList </em>的概念:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="389c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是用一个额外的类型参数<strong class="kf ir"> J </strong>来扩展<em class="lk"> AnnotatedDataFrame </em>定义，该参数携带连接数据集的列表:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="179d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们需要相应地更新<em class="lk">数据源</em>定义:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="daf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，当我们最初从源代码中读取时，连接列表是空的(因为我们还没有执行任何连接)，这就是为什么<em class="lk"> AnnotatedDataFrame </em>的第二个类型参数被设置为<em class="lk"> HNil </em>，这表示一个空列表。</p><p id="f760" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一剩下的步骤是更新<em class="lk"> Join </em>类型类的定义。</p><h1 id="aa58" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">加入沿袭跟踪</h1><p id="9831" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">为了确保保留连接数据集的血统，我们需要执行以下类型级别的操作:</p><ol class=""><li id="b592" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la mt lh li lj bi translated">连接左右数据集的连接列表。</li><li id="b13d" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la mt lh li lj bi translated">将右侧数据集的类型标记添加到上一步获得的列表中。</li></ol><p id="3e8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试着在代码中反映这一点:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="94dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新定义的第一个不同之处是,<em class="lk"> Join </em>类型类扩展了两个额外的类型参数——<strong class="kf ir">LJ</strong>和<strong class="kf ir"> RJ </strong>,它们分别代表左右数据集的连接列表。</p><p id="c1c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个有趣的细节是在<em class="lk"> join </em>的定义中对<em class="lk"> Prepend </em>类型类的隐式引用。<em class="lk"> Prepend </em> —是由<em class="lk"> Shapeless </em>库提供的类型类，它将第一个类型参数中提供的<em class="lk"> HList </em>类型前置到第二个类型参数中指定的类型。串联产生的类型存储在路径相关类型<em class="lk"> Out </em>中。整个操作只涉及类型，并且发生在编译时。</p><p id="2723" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们查看返回类型的第二个类型参数，我们会发现它反映了我们在本节开始时概述的两个操作。我们将类型<strong class="kf ir"> R </strong>前置到<strong class="kf ir"> P.Out </strong>，正如我们现在所知，这又是<strong class="kf ir"> LJ </strong>和<strong class="kf ir"> RJ </strong>串联的结果。</p><p id="75ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以用一个<em class="lk"> join </em>语法来扩展<em class="lk"> AnnotatedDataFrame </em>:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0e22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们只需要把所有的拼图拼在一起。</p><h1 id="25ae" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">把所有的碎片放在一起</h1><p id="5cfd" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">为了演示沿袭跟踪的强大功能，我们应该首先介绍一个<em class="lk"> Join </em>类型类的实现，该类描述了如何连接<strong class="kf ir"> DeviceMeasurement </strong>和<strong class="kf ir"> DeviceModel </strong>数据集。我们可以引入相应的类型类实例作为<strong class="kf ir">设备模型</strong>伴随对象的一部分:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5a7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<strong class="kf ir">设备测量</strong>数据集在左侧位置，而<strong class="kf ir">设备模型</strong>数据集在右侧。</p><p id="95ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们连接两个数据集:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="bdb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到连接操作已经反映在<em class="lk"> AnnotatedDataFrame </em>类型的第二个类型参数中！</p><p id="a067" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连接操作也是可组合的。换句话说，如果我们选择用一个额外的维度数据集<strong class="kf ir"> Country </strong>来扩展我们的数据模型，那么组合将如下所示:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8fe2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个很棒的特性是，我们现在可以从丰富的类型类<a class="ae kc" href="https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/ops/hlists.scala" rel="noopener ugc nofollow" target="_blank">集合</a>中受益，它与<em class="lk"> HList </em>一起出现在<em class="lk"> Shapeless </em>库中。</p><p id="be88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们需要确保来自<strong class="kf ir"> DeviceModel </strong>数据集的属性是我们业务逻辑的输入的一部分，我们可以这样实现:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2f7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，指定的约束将在编译时强制执行。</p><h1 id="788e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="e4a2" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">为了让非类型化的DataFrame API更加类型安全，我们创建了一个固执己见的框架，它涵盖了几乎每个ETL管道都有的几个关键步骤:</p><ul class=""><li id="c1ec" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">数据集创建。</li><li id="b10d" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">通过连接进行数据集合成。</li></ul><p id="417d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这两个操作中都实现了一定程度的类型安全。现在，数据集是使用规则创建和组成的，其正确性在编译时强制执行。这进一步允许开发人员对业务逻辑的某些部分的输入进行约束，这些约束也将在编译时实施。这反过来会导致更安全的实现和更少的错误。</p><p id="0d66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个框架适用于任何用例吗？答案是否定的。该框架对数据集的组成模式(事实、维度等)做出了某些假设。)，这在很多情况下可能不成立。</p><p id="d770" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提议的框架可以补充现有的管道实现。它还可以与类型化数据集API共存，并在后者能力不足的地方作为一种增强(例如连接)。</p><p id="287c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文中提出的想法可以很容易地扩展到典型ETL管道的其他步骤，比如从一个数据集到另一个数据集的转换以及投影。</p><p id="c9a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后是包含完整实现、示例等内容的gist:<a class="ae kc" href="https://gist.github.com/izeigerman/d1fe83519767de6514cfd02384075457" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/izeigerman/d1fe 83519767 de 6514 CFD 02384075457</a></p></div></div>    
</body>
</html>