<html>
<head>
<title>Building a kubernetes cluster on Raspberry Pi and low-end equipment. Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Raspberry Pi和低端设备上构建kubernetes集群。第二部分</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-kubernetes-cluster-on-raspberry-pi-and-low-end-equipment-part-2-33f21695251c?source=collection_archive---------2-----------------------#2019-06-15">https://itnext.io/building-a-kubernetes-cluster-on-raspberry-pi-and-low-end-equipment-part-2-33f21695251c?source=collection_archive---------2-----------------------#2019-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ec86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是<strong class="jp ir">在Raspberry Pi和低端设备上构建kubernetes集群</strong>文章的第二部分。在这一部分中，我将为kubernetes集群创建一个面向互联网的网络。</p><p id="c6de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://medium.com/@eduard.iskandarov/building-a-kubernetes-cluster-on-raspberry-pi-and-low-end-equipment-part-1-a768359fbba3" rel="noopener"> <strong class="jp ir">第1部分</strong> </a>中，我提供了kubernetes节点，建立了集群，并运行了测试应用程序。</p><p id="9c8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要目标是创建一个基础设施，允许使用互联网访问kubernetes中的应用程序。</p><p id="53a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终，它将与<a class="ae kl" href="https://aws.amazon.com/elasticloadbalancing/?nc1=h_ls" rel="noopener ugc nofollow" target="_blank"> AWS弹性负载平衡器</a>、<a class="ae kl" href="https://cloud.google.com/load-balancing/" rel="noopener ugc nofollow" target="_blank"> GCP负载平衡器</a>、<a class="ae kl" href="https://azure.microsoft.com/en-us/services/load-balancer/" rel="noopener ugc nofollow" target="_blank"> Azure负载平衡器</a>以及云基础设施中的任何负载平衡器具有相同的用途。</p><p id="debd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅靠一个组件是不可能解决这个问题的，所以要用到几个东西:互联网网关、动态DNS、内容交付网络。</p><h1 id="2e75" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">介绍互联网网关</h1><p id="8d4e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">一个互联网网关术语可能意味着任何事情。为了让事情更清楚，我需要给它一个完全适合这篇文章的定义。</p><p id="60de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lp">互联网网关</em> —旨在传输层(<a class="ae kl" href="https://en.wikipedia.org/wiki/OSI_model#Layer_4:_Transport_Layer" rel="noopener ugc nofollow" target="_blank"> OSI模型第4层</a>)提供从公共互联网段到私有网络的网络连接的硬件和软件系统。</p><p id="74b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有几种方法可以做到这一点:<a class="ae kl" href="https://en.wikipedia.org/wiki/Network_address_translation" rel="noopener ugc nofollow" target="_blank">网络地址转换(NAT) </a>，不同的代理服务器(如<a class="ae kl" href="http://www.haproxy.org/" rel="noopener ugc nofollow" target="_blank"> HAProxy </a>，<a class="ae kl" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> nginx </a>，<a class="ae kl" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank"> envoy </a>等等)。</p><p id="4b45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用代理服务器需要专用的网络设备，该设备接受来自互联网的连接并代理到kubernetes节点。文章的精神是只使用低端设备，尽可能利用现有组件。因此使用NAT是我的选择。</p><p id="137f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，我使用了一个功能丰富的Mikrotik路由器，即使在复杂的情况下设置它也相对容易。</p><p id="3644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一节将使用Mikrotik路由器配置。在许多其它路由器上实现这一点是可能的。我有意跳过NAT和Mikrotik的具体细节，只提供一般信息。读者可以随时了解主题并在不同的硬件上复制。</p><p id="e543" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对学习Mikrotik感兴趣——这里有一个官方文档的链接:<a class="ae kl" href="https://wiki.mikrotik.com/wiki/Manual:IP/Firewall/NAT" rel="noopener ugc nofollow" target="_blank">手册:IP/防火墙/NAT </a>。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="39f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从天真的方法开始。回想一下，在第1部分，我们有如下设置:kubernetes节点的IP地址是:<code class="fe lx ly lz ma b">192.168.40.103</code>和<code class="fe lx ly lz ma b">192.168.40.104</code>；nginx在<code class="fe lx ly lz ma b">31681</code>节点端口<strong class="jp ir">公开服务。我很快就会需要那些东西。</strong></p><p id="30c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在图1中，有一个用户、互联网、一个路由器和一个kubernetes节点。<br/>用户通过互联网发送HTTP请求；一个<a class="ae kl" href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol" rel="noopener ugc nofollow" target="_blank">点对点协议(PPP) </a>接口通过<a class="ae kl" href="https://en.wikipedia.org/wiki/Wide_area_network" rel="noopener ugc nofollow" target="_blank">广域网(WAN) </a>将路由器与互联网相连；路由器在<a class="ae kl" href="https://en.wikipedia.org/wiki/Local_area_network" rel="noopener ugc nofollow" target="_blank">局域网</a>与kubernetes节点连接。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/083a317a4d07cae67adc1a9668165a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*Bv6XgjHV7UR4tSFzHrLP4w.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图一。互联网网关组件</figcaption></figure><p id="d84b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们需要做的是告诉路由器以某种方式处理网络流量。我会用Mikrotik控制台(更多细节是官方文档<a class="ae kl" href="https://wiki.mikrotik.com/wiki/Manual:Console" rel="noopener ugc nofollow" target="_blank">手册:控制台</a>)。</p><pre class="mc md me mf gt mn ma mo mp aw mq bi"><span id="0431" class="mr kn iq ma b gy ms mt l mu mv">/ip firewall nat<br/>add chain=dstnat action=dst-nat \<br/> in-interface=all-ppp protocol=tcp dst-port=80 to-addresses=192.168.40.103 to-ports=31681</span></pre><p id="9fb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述命令指示路由器对到达<em class="lp"> PPP接口</em>的目的端口为80的TCP数据包执行网络地址转换，以便数据包进一步转发到31681端口的192.168.40.103 IP地址。</p><p id="d667" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，如果一个HTTP请求(默认端口80)将到达路由器的公共IP地址—路由器将把请求转发到nginx服务的kubernetes节点1(通过节点端口)。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="f154" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个明显的缺点。流量只被转发到kubernetes节点之一，因此负载平衡不起作用。我有两个，可能还有更多。幸运的是，还有改进的空间。我将使用路由器的一些高级功能。</p><h2 id="7995" class="mr kn iq bd ko mw mx dn ks my mz dp kw jy na nb la kc nc nd le kg ne nf li ng bi translated">具有负载平衡的互联网网关</h2><p id="cf7a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">负载平衡假设流量被分成几个流，每个流被转发到相应的目标后端。</p><p id="dc45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Mikrotik术语中，该技术被称为每个连接分类器的<em class="lp">。</em></p><blockquote class="nh ni nj"><p id="0fc5" class="jn jo lp jp b jq jr js jt ju jv jw jx nk jz ka kb nl kd ke kf nm kh ki kj kk ij bi translated"><a class="ae kl" href="https://wiki.mikrotik.com/wiki/Manual:PCC" rel="noopener ugc nofollow" target="_blank">每连接分类器(PCC) </a> matcher将允许您将流量分成相等的流，并能够将具有特定选项集的数据包保存在一个特定的流中。</p></blockquote><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/cd5f4682112192ec95fa4de38371ba9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*kR3DpCl3YftP5mX_PY81yw.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图二。具有负载平衡组件的互联网网关</figcaption></figure><p id="e981" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下路由器配置由两部分组成:<br/> 1。流量分类。该步骤设置交通标志<br/> 2。基于标记的网络地址翻译</p><pre class="mc md me mf gt mn ma mo mp aw mq bi"><span id="db31" class="mr kn iq ma b gy ms mt l mu mv">/ip firewall mangle<br/>add chain=prerouting action=mark-connection \<br/>  in-interface=all-ppp protocol=tcp dst-port=80 \<br/>  new-connection-mark=kube_node_1 per-connection-classifier=src-address-and-port:2/0 \<br/>  comment="Load balancer. Service nginx. Mark connections to kube node 1"<br/>add chain=prerouting action=mark-connection \<br/>  in-interface=all-ppp protocol=tcp dst-port=80 \<br/>  new-connection-mark=kube_node_2 per-connection-classifier=src-address-and-port:2/1 \<br/>  comment="Load balancer. Service nginx. Mark connections to kube node 2"<br/><br/>/ip firewall nat<br/>add chain=dstnat action=dst-nat \<br/> connection-mark=kube_node_1 to-addresses=192.168.40.103 protocol=tcp to-ports=<!-- -->31681<!-- --> \<br/> comment="Load balancer. Service nginx. DST NAT to kube node 1"<br/>add chain=dstnat action=dst-nat \<br/>  connection-mark=kube_node_2 to-addresses=192.168.40.104 protocol=tcp to-ports=<!-- -->31681<!-- --> \<br/>  comment="Load balancer. Service nginx. DST NAT to kube node 2"</span></pre><p id="2b0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我指示路由器用<code class="fe lx ly lz ma b">kube_node_1</code>和<code class="fe lx ly lz ma b">kube_node_2</code>标记一段流量。<br/>此外，带有标记<code class="fe lx ly lz ma b">kube_node_1</code>的流量去往kubernetes节点1(IP地址<code class="fe lx ly lz ma b">192.168.40.103</code>)；带有标记<code class="fe lx ly lz ma b">kube_node_2</code>的流量去往kubernetes节点2(IP地址<code class="fe lx ly lz ma b">192.168.40.104</code>)。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="1796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来像魔术，但仔细一看并不复杂。分类器采用TCP数据包源地址和端口的数字表示，然后</p><blockquote class="nh ni nj"><p id="7cb4" class="jn jo lp jp b jq jr js jt ju jv jw jx nk jz ka kb nl kd ke kf nm kh ki kj kk ij bi translated">然后将该值除以指定的<em class="iq">分母</em>，然后将余数与指定的<em class="iq">余数</em>进行比较，如果相等，则将捕获数据包。</p></blockquote><p id="d6c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，让我们假设一个样本TCP包来自IP地址<code class="fe lx ly lz ma b">192.0.2.87</code>并且操作系统选择了<code class="fe lx ly lz ma b">59831</code>(通常是一个<a class="ae kl" href="https://en.wikipedia.org/wiki/Ephemeral_port" rel="noopener ugc nofollow" target="_blank">临时端口</a>)。</p><p id="2b61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么<code class="fe lx ly lz ma b">192.0.2.87</code>的数值表示等于3221226071 <strong class="jp ir">。<br/> </strong>最后，IP地址值和端口号之和(我不知道每个连接的分类器算法的实现细节——出于演示目的，使用sum运算作为最简单的)。</p><pre class="mc md me mf gt mn ma mo mp aw mq bi"><span id="6792" class="mr kn iq ma b gy ms mt l mu mv">3221226071 + 59831 = 3221285902</span></pre><p id="4375" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如文档所述，该值除以指定的分母，然后将余数与指定的<em class="lp">余数</em>进行比较。在我的例子中分母是<code class="fe lx ly lz ma b">2</code>。</p><pre class="mc md me mf gt mn ma mo mp aw mq bi"><span id="59d2" class="mr kn iq ma b gy ms mt l mu mv">3221285902 % 2 = 0</span></pre><p id="b107" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">划分提醒是<code class="fe lx ly lz ma b">0</code>，因此在本实验中，分类器会将该数据包标记为<code class="fe lx ly lz ma b">kube_node_1</code>。唷！</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="77bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图3证实了我的配置是正确的。浏览器使用公共IP地址在kubernetes中打开nginx。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/cb101c7e0afbf5a76947610f25f07a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRIbA8C1XywhwJafNDMMow.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图3。kubernetes中的nginx使用公共IP地址</figcaption></figure><p id="31a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于安全和隐私的目的，我不会暴露我的真实公共IP地址。<code class="fe lx ly lz ma b">198.51.100.19</code>用于演示。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="5775" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我有一个具有所需属性的互联网网关。它接受来自互联网的流量，并对kubernetes节点进行负载平衡。</p><h1 id="cf5a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">动态DNS</h1><p id="d8bf" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我的互联网服务提供商有一个公共IP地址池，每个VPN会话(<a class="ae kl" href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol_over_Ethernet" rel="noopener ugc nofollow" target="_blank"><em class="lp">【PPPoE】</em></a>)路由器都会收到其中一个IP地址。这意味着由于公共IP地址的动态特性，不可能预测下一次VPN会话中的IP地址。假设VPN重新连接可能随时发生—我有麻烦了。</p><p id="a61d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说——网站有一个名字。我已经购买了一个域名<code class="fe lx ly lz ma b">kube-test.info</code>,想用它来访问我的kubernetes上的网络资源。但是，如果IP地址是动态的，我该如何创建DNS记录呢？</p><p id="f891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，有一个解决方案。<a class="ae kl" href="https://en.wikipedia.org/wiki/Dynamic_DNS" rel="noopener ugc nofollow" target="_blank">动态DNS </a>技术允许创建指向路由器当前公共IP地址的DNS记录。</p><p id="8be5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的Mikrotik路由器动态DNS具有内置功能。一旦启用—我的路由器的公共IP地址就有了一个静态DNS名称。</p><pre class="mc md me mf gt mn ma mo mp aw mq bi"><span id="b26c" class="mr kn iq ma b gy ms mt l mu mv">/ip cloud set ddns-enabled=yes<br/>/ip cloud print<br/>          ddns-enabled: yes<br/>  ddns-update-interval: none<br/>           update-time: yes<br/>        public-address: <!-- -->198.51.100.19<br/>              <strong class="ma ir">dns-name: </strong><strong class="ma ir">529c0491d41c.sn.mynetname.net</strong><br/>                status: updated</span></pre><p id="2859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中，DNS名称的前12个字节(<code class="fe lx ly lz ma b">529c0491d41c</code>)是路由器的序列号。出于安全和隐私的目的，DNS名称是不真实的。</p><p id="08fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们测试一下是否可以使用Mikrotik提供的DNS名称在kubernetes中打开nginx。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/caf4886d0ba7fa2fe4c60ec5fccbe5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1N_XYqBd5Jsi1XSyXbmvoA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图4。kubernetes中的nginx使用动态DNS名称</figcaption></figure><p id="c7d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有用！现在我有了可以进一步依赖的稳定的东西。</p><h1 id="c746" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">内容交付网络</h1><p id="e257" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Content_delivery_network" rel="noopener ugc nofollow" target="_blank">内容交付网络(CDN) </a>给出了几个优势。对于这个练习来说，最重要的是:现成的HTTPS支持和安全性增强。通过安全性增强，我的意思是Cloudflare将我的后端隐藏在它的公共IP地址之后。所以，没有一个简单的方法来说明什么样的后端隐藏在域后面，服务器在哪里。如果您确实关心您的站点安全，我强烈推荐使用这种技术。</p><p id="8e67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Cloudflare提供免费计划，因此不会造成任何预算损失。</p><p id="c198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lp">CDN有替代方案。对于HTTPS，您可以使用类似</em><a class="ae kl" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank"><em class="lp">letencrypt</em></a><em class="lp">的东西，并将DNS记录直接指向动态DNS CNAME，但我会将此选项留给您练习。对这种组合的讨论超出了主题范围。</em></p><p id="de34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将域添加到Cloudflare并完成初始设置后，我为动态DNS域<code class="fe lx ly lz ma b">529c0491d41c.sn.mynetname.net</code>创建了一个DNS记录。代理模式已启用，因此我拥有Cloudflare的所有安全优势。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi ns"><img src="../Images/ad9171c9c9f72dcd994b6ad5b55aff12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RSkIiR3DmTIGnnikCpHOQ.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图5。Cloudflare中的DNS配置</figcaption></figure><p id="e026" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们的后端只能以普通的HTTP进行通信，我需要指示Cloudflare将来自客户端的HTTPS请求代理到后端的HTTP端口。那就是所谓的<strong class="jp ir">灵活的</strong> SSL模式。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi ns"><img src="../Images/e77d10f579af972d31e1614e77964f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZlgRdt-E3SmBquYZrnlSA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图6。在Cloudflare中启用灵活的SSL模式</figcaption></figure></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="dd74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">面向Internet的网络设置已准备好。我现在可以用一个普通的网址【https://kube-test.info/ T2】打开托管在kubernetes的nginx。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/fa3caa28977bc34368e8cad2b697846c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MEFkMmUfRgx1hQXZ4aUP1A.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图7。云闪背后的库贝内特斯nginx</figcaption></figure><p id="f5aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图7显示我可以从互联网访问kubernetes集群中的nginx web服务器。</p><h1 id="ae07" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">后续步骤</h1><p id="1960" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在<strong class="jp ir">接下来的部分，在Raspberry Pi和低端设备</strong>系列上构建kubernetes集群，为pods启用持久存储层，寻找设备资源优化的方法。</p></div></div>    
</body>
</html>