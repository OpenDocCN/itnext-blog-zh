<html>
<head>
<title>Zero Downtime on Deployments with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker实现零停机部署</h1>
<blockquote>原文：<a href="https://itnext.io/a-simple-solution-for-zero-downtime-on-deployments-with-docker-bdb71f3101d0?source=collection_archive---------2-----------------------#2020-11-11">https://itnext.io/a-simple-solution-for-zero-downtime-on-deployments-with-docker-bdb71f3101d0?source=collection_archive---------2-----------------------#2020-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b6c314a4089266aa9692708e6eb566ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vuWiCTZVQ4NOgNLKNbVHw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用简单的部件建造美妙的建筑</figcaption></figure><p id="5476" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">两个月前，在对我们的应用程序进行分类后，我接到了一项任务，要为我们的部署实现零宕机。不使用Docker的时候，为了0-down，可以使用Puma HTTP server的<code class="fe la lb lc ld b">phased-restart</code>功能。有了Docker基础设施，你也可以使用<code class="fe la lb lc ld b">Swarm</code>或<code class="fe la lb lc ld b">Kubernetes</code>，但是大多数时候，<code class="fe la lb lc ld b">Swarm</code>或<code class="fe la lb lc ld b">Kubernetes</code>对我们来说都是多余的。</p><p id="2477" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我们将使用一些简单的工具来实现0停机部署，您可以用其他工具来替代它们，因此我们不想拘泥于某些特定的工具。请记住，实现一种适当的容器部署方式，需要对Docker技术有很好的了解，因此在阅读本文之前，请确保您对Docker有足够的了解。</p><p id="796e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们将实现一个具有单个端点的简单Rails应用程序，在将其docker化之后，我们将使用Capistrano进行一个基于docker容器的简单部署。然后我们将设置Nginx反向代理，为了做到这一点，我们将使用<code class="fe la lb lc ld b">nginx-proxy</code> docker图像。在最后两步中，我们将改进我们的部署脚本以支持零停机时间，最后，我们将使用<code class="fe la lb lc ld b">ApacheBench</code>工具在部署上测试零停机时间。</p><p id="ef15" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">根据这篇文章，我还准备了一个示例项目，您可以通过下面的链接查看:</p><div class="le lf gp gr lg lh"><a href="https://github.com/AliSepehri/zero_downtime" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd ir gy z fp lm fr fs ln fu fw ip bi translated">AliSepehri/zero_downtime</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jw lh"/></div></div></a></div></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="4eb9" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">初始化应用程序并实现简单的端点</h1><p id="04a0" class="pw-post-body-paragraph kc kd iq ke b kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv nf kx ky kz ij bi translated">为了有一个简单的应用程序，我们想使用Ruby-on-Rails框架。如果您使用的是其他语言/框架，那么对于这个部分，我们唯一需要的就是一个返回带有<code class="fe la lb lc ld b">200</code> HTTP状态的响应的<code class="fe la lb lc ld b">/ping</code>端点。</p><p id="6de6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我们不想讨论安装Ruby、Ruby on Rails以及其他先决条件。我假设我们已经在机器上安装了Ruby on Rails，为了初始化Rails应用程序，我们执行下面的命令:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="7497" class="no me iq ld b gy np nq l nr ns">rails new zero-downtime --api</span></pre><p id="9c83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了实现<code class="fe la lb lc ld b">/ping</code>端点，使用Rails生成器生成<code class="fe la lb lc ld b">ping</code>控制器:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="c37e" class="no me iq ld b gy np nq l nr ns">rails g controller ping</span></pre><p id="e290" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将简单测试添加到<code class="fe la lb lc ld b">test/controllers/ping_controller_test.rb</code>文件，将路线添加到<code class="fe la lb lc ld b">config/routes.rb</code>文件，将相关动作添加到<code class="fe la lb lc ld b">app/controllers/ping_controller.rb</code>:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/test/controllers/ping _ controller _ test . Rb</figcaption></figure><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/config/routes.rb</figcaption></figure><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/app/controllers/ping _ controller . Rb</figcaption></figure><p id="205d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，运行测试以确保一切工作正常:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="ba87" class="no me iq ld b gy np nq l nr ns">rails test test/controllers/ping_controller_test.rb</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="36dd" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">将申请归档</h1><p id="7056" class="pw-post-body-paragraph kc kd iq ke b kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv nf kx ky kz ij bi translated">现在我们将为我们的Rails应用程序编写一个简单的<code class="fe la lb lc ld b">Dockerfile</code>。如果你正在使用另一个框架，你肯定可以在网上找到很多关于如何将它dockerize的文章。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/Dockerfile</figcaption></figure><p id="eb99" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在通过运行<code class="fe la lb lc ld b">docker build</code>命令构建Docker映像:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="5421" class="no me iq ld b gy np nq l nr ns">docker build -t zero-downtime .</span></pre><p id="0539" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基于我们的Docker映像创建并运行一个容器:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="9dc9" class="no me iq ld b gy np nq l nr ns">docker run --rm --name zero-downtime-app -p 3000:3000 zero-downtime</span></pre><p id="cc71" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并测试它:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="25c1" class="no me iq ld b gy np nq l nr ns">curl <a class="ae nv" href="http://localhost:3000/ping" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/ping</a></span><span id="7449" class="no me iq ld b gy nw nq l nr ns"># ===&gt; {"message":"pong!"}</span></pre><p id="7edc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你得到了<code class="fe la lb lc ld b">{"message":"pong!"}</code>，这意味着你的容器工作了；停止正在运行的容器(<code class="fe la lb lc ld b">Ctrl+C</code>)，跟随文章。在下一节中，我们将通过Capistrano工具将容器部署到我们的本地机器上。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="937c" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">使用Capistrano实现简单部署</h1><p id="c9a1" class="pw-post-body-paragraph kc kd iq ke b kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv nf kx ky kz ij bi translated">现在我们想使用Capistrano为我们的应用程序实现一个简单的部署流程。当然，Capistrano有许多替代方案，您可以轻松地使用它们，因为我们在Capistrano任务中使用的命令非常接近原始shell命令。</p><p id="801c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们要将Capistrano添加到我们的Gemfile中，安装并初始化它。为此，我们可以执行以下命令:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="a3da" class="no me iq ld b gy np nq l nr ns"><em class="nx"># Add and install the Gem</em><br/><strong class="ld ir">bundle add capistrano</strong></span><span id="3481" class="no me iq ld b gy nw nq l nr ns"><em class="nx"># Generate default config files</em><br/><strong class="ld ir">bundle exec cap install</strong></span></pre><p id="c80d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">去掉不必要的线条后，我展示了我的<code class="fe la lb lc ld b">Capfile</code>:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/Capfile</figcaption></figure><p id="0ecf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">到<code class="fe la lb lc ld b">./config/deploy.rb</code>文件中，我们需要设置<code class="fe la lb lc ld b">repo_url</code>来引用我们的代码。为此，您应该使用git服务器。例如，您可以使用Github存储库，然后将ssh远程URL从存储库页面复制到我们的<code class="fe la lb lc ld b">deploy.rb</code>文件中。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/config/部署. rb</figcaption></figure><p id="a1bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如您所见，我们还有一些任务将在默认部署步骤之后执行。我们将实现<code class="fe la lb lc ld b">docker.rake</code>文件中的任务。</p><p id="464f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用Capistrano，您可以针对不同阶段进行不同的配置。我已经展示了我们在开发阶段的配置。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/config/deploy/开发. rb</figcaption></figure><p id="5dc5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如您所见，我们已经为<code class="fe la lb lc ld b">server</code>属性设置了<code class="fe la lb lc ld b">localhost</code>，这意味着我们将使用本地机器进行部署，而不需要使用虚拟机或真实的服务器。</p><p id="be60" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如我们之前提到的，我们有一些定制任务要在Capistrano的默认步骤之后运行，以完成部署流程的主要部分。</p><p id="7d89" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们已经将这些定制任务放在了<code class="fe la lb lc ld b">./lib/capistrano/tasks/docker.rake</code>文件中。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/lib/capistrano/tasks/docker . rake</figcaption></figure><p id="76b2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我将简要地解释每个任务，当然我们应该对Docker有一些经验，以找出在这些任务中到底发生了什么。<code class="fe la lb lc ld b">create_network</code>创建<code class="fe la lb lc ld b">backend</code>网络，我们将使用它来运行同一网络中的所有容器，以便它们能够相互访问。<code class="fe la lb lc ld b">create_volumes</code>创建必备的Docker卷。<code class="fe la lb lc ld b">db_setup</code>运行<code class="fe la lb lc ld b">rails db:setup</code>来初始化数据库(当然，对于一个实际的应用程序，您不应该在每个部署上执行数据库设置)。最后<code class="fe la lb lc ld b">start_container</code>将使用指定的环境变量运行应用程序容器。</p><p id="928c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们已经准备好部署我们的应用程序了。<code class="fe la lb lc ld b">bundle exec cap development deploy</code>命令运行开发阶段的Capistrano部署流程。运行部署命令后，您应该会看到以下错误:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="cc68" class="no me iq ld b gy np nq l nr ns">...</span><span id="b82f" class="no me iq ld b gy nw nq l nr ns">Errno::ECONNREFUSED: Connection refused — connect(2) for 127.0.0.1:22</span><span id="41b3" class="no me iq ld b gy nw nq l nr ns">...</span></pre><p id="0cbe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的本地机器上没有任何ssh-server，这就是我们得到这个错误的原因。要在Ubuntu机器上安装ssh-server并配置ssh-key对，您可以遵循以下命令:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="4372" class="no me iq ld b gy np nq l nr ns"><em class="nx"># ------- Install ssh-server, enable, and run its servic -------<br/></em><strong class="ld ir">sudo apt-get install openssh-server<br/>sudo systemctl enable ssh<br/>sudo systemctl start ssh</strong></span><span id="5ccf" class="no me iq ld b gy nw nq l nr ns"><em class="nx"># ------- Create a new key-pair -------</em><br/><strong class="ld ir">ssh-keygen -t rsa -b 4096 -C "Capistrano Local" -f ~/.ssh/capistrano_local</strong></span><span id="8f6b" class="no me iq ld b gy nw nq l nr ns"><em class="nx"># ------- Add the new private-key for ssh-client -------</em><br/><strong class="ld ir">ssh-add ~/.ssh/capistrano_local</strong></span><span id="816e" class="no me iq ld b gy nw nq l nr ns"><em class="nx"># ------- Add the new public-key for ssh-server -------</em><br/><strong class="ld ir">cat ~/.ssh/capistrano_local.pub &gt;&gt; ~/.ssh/authorized_keys</strong></span></pre><p id="5e0a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以我们将在我们的机器上同时拥有<code class="fe la lb lc ld b">ssh-server</code>和<code class="fe la lb lc ld b">ssh-client</code>。现在，我们可以开始部署了:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="0602" class="no me iq ld b gy np nq l nr ns">bundle exec cap development deploy</span></pre><p id="8706" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当它成功完成时，应用程序容器应该正在运行并负责<code class="fe la lb lc ld b">curl</code>请求:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="1468" class="no me iq ld b gy np nq l nr ns"><strong class="ld ir">curl </strong><a class="ae nv" href="http://localhost:3000/ping" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir">http://localhost:3000/ping</strong></a></span><span id="8147" class="no me iq ld b gy nw nq l nr ns"><em class="nx"># ===&gt; {"message":"pong!"}</em></span></pre><p id="3ad6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们得到了<code class="fe la lb lc ld b">{"message":"pong!"}</code>响应，这意味着您的应用程序容器已经启动并正在运行。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="fd6c" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">添加Nginx</h1><p id="f1f1" class="pw-post-body-paragraph kc kd iq ke b kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv nf kx ky kz ij bi translated">在我们现有的结构中，运行在应用程序容器中的Puma直接接收请求。在这一节中，我们将设置一个Nginx容器，并将应用程序容器放在它的后面。为此，我们将使用<a class="ae nv" href="https://hub.docker.com/r/jwilder/nginx-proxy" rel="noopener ugc nofollow" target="_blank"> jwilder/nginx-proxy </a>图像，而不是<a class="ae nv" href="https://hub.docker.com/_/nginx" rel="noopener ugc nofollow" target="_blank">官方nginx </a>图像。当一个新的容器运行时，<code class="fe la lb lc ld b">nginx-proxy</code>会识别它，生成反向代理配置，并自动重新加载Nginx进程。</p><p id="9dc5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们只需要运行<code class="fe la lb lc ld b">nginx-proxy</code>一次，最好不要让它出现在您的部署流程中，但是为了简单起见，我们将使用Capistrano来运行<code class="fe la lb lc ld b">nginx-proxy</code>容器。此外，我们需要向应用程序容器添加一个新的环境变量(<code class="fe la lb lc ld b">VIRTUAL_HOST</code>)。由于有了<code class="fe la lb lc ld b">VIRTUAL_HOST</code>环境变量，新容器将被自动识别，并在Nginx配置中用作服务器名。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/lib/capistrano/tasks/docker . rake</figcaption></figure><p id="822e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">start_nginx</code>检查正在运行的容器，如果没有运行，则运行<code class="fe la lb lc ld b">nginx-proxy</code>容器。对于<code class="fe la lb lc ld b">start_container</code>任务，我们也有两个小的变化，正如你所看到的，我们不再需要端口映射，取而代之的是，我们将<code class="fe la lb lc ld b">VIRTUAL_HOST</code> env传递给应用程序容器——正如我们之前所描述的。</p><p id="a046" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要更新<code class="fe la lb lc ld b">config/deploy.rb</code>文件，将新任务添加到我们的部署流程中:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/config/部署. rb</figcaption></figure><p id="bc11" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们需要再次运行Capistrano部署命令来查看我们的更改:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="03ce" class="no me iq ld b gy np nq l nr ns">bundle exec cap development deploy</span></pre><p id="5f23" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于测试，请记住，如果请求来自通过<code class="fe la lb lc ld b">VIRTUAL_HOST</code>环境变量指定的指定域，那么<code class="fe la lb lc ld b">nginx-proxy</code>会将请求导航到我们的应用程序容器。所以我们需要通过为<code class="fe la lb lc ld b">curl</code>请求设置<code class="fe la lb lc ld b">Host</code>头来伪造域:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="c596" class="no me iq ld b gy np nq l nr ns"><strong class="ld ir">curl --header "Host: app-domain.test:8080" localhost:8080/ping</strong></span><span id="7322" class="no me iq ld b gy nw nq l nr ns"><em class="nx"># ===&gt; {"message":"pong!"}</em></span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="a2c3" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">通过蓝绿部署实现零停机(关键时刻)</h1><p id="8078" class="pw-post-body-paragraph kc kd iq ke b kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv nf kx ky kz ij bi translated">我们的想法是向我们的应用程序容器添加一个健康检查，在不停止旧容器的情况下运行新版本的容器，同时运行旧版本和新版本的应用程序，直到新版本负责请求，并最终停止旧容器。</p><p id="ff46" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过向应用程序容器添加健康检查，我们将能够发现容器是否对请求负责。为我们的容器实现健康检查的一个简单方法是向<code class="fe la lb lc ld b">/ping</code>端点发送<code class="fe la lb lc ld b">curl</code>请求——这是我们在第一节中实现的。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/lib/capistrano/tasks/docker . rake</figcaption></figure><p id="d8e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，根据我们的想法，我们需要在<code class="fe la lb lc ld b">start_container</code>任务中添加health-check。<code class="fe la lb lc ld b">curl -f localhost:3000/ping</code>将每10秒执行一次，并将更新容器的状态。<code class="fe la lb lc ld b">wait_for_container</code>将等待新容器(<code class="fe la lb lc ld b">zero-downtime-app-new</code>)变得健康，之后将执行<code class="fe la lb lc ld b">stop_container</code>来停止旧容器，最后<code class="fe la lb lc ld b">rename_container</code>任务将把新容器的名称从<code class="fe la lb lc ld b">zero-downtime-app-new</code>重命名为<code class="fe la lb lc ld b">zero-downtime-app</code>。</p><p id="30ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">确保您已经将新步骤添加到<code class="fe la lb lc ld b">config/deploy.rb</code>文件中:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">。/config/部署. rb</figcaption></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1a36" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">使用ApacheBench测试零停机时间</h1><p id="7ad6" class="pw-post-body-paragraph kc kd iq ke b kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv nf kx ky kz ij bi translated">我们想使用<a class="ae nv" href="https://httpd.apache.org/docs/2.4/programs/ab.html" rel="noopener ugc nofollow" target="_blank"> ApacheBench工具</a>来测试我们的零停机部署实现。我们将使用它在指定的时间限制内发送大量请求，并同时运行部署。ApacheBench将告诉我们<code class="fe la lb lc ld b">Non-2xx responses</code>的计数，这个值应该为零，以便我们确认我们的解决方案。</p><p id="774d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在机器上打开两个独立的终端。在第一个终端中运行部署:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="233d" class="no me iq ld b gy np nq l nr ns">bundle exec cap development deploy</span></pre><p id="1f64" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第二个示例中运行ApacheBench如果这是您第一次运行这个命令，那么从注册表中获取<code class="fe la lb lc ld b">ab</code>映像需要一些时间:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="9d6e" class="no me iq ld b gy np nq l nr ns">docker run --rm --network=backend httpd ab -s5000 -t50 -n1000000 -H "Host: app-domain.test" -c1 <a class="ae nv" href="http://nginx/ping" rel="noopener ugc nofollow" target="_blank">http://nginx/ping</a></span></pre><p id="5d05" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">完成部署后，您可以停止ApacheBench容器(<code class="fe la lb lc ld b">Ctrl + C</code>)，它将生成报告:</p><pre class="ng nh ni nj gt nk ld nl nm aw nn bi"><span id="52dc" class="no me iq ld b gy np nq l nr ns">This is ApacheBench, Version 2.3 &lt;$Revision: 1879490 $&gt;<br/>Copyright 1996 Adam Twiss, Zeus Technology Ltd, <a class="ae nv" href="http://www.zeustech.net/" rel="noopener ugc nofollow" target="_blank">http://www.zeustech.net/</a><br/>Licensed to The Apache Software Foundation, <a class="ae nv" href="http://www.apache.org/" rel="noopener ugc nofollow" target="_blank">http://www.apache.org/</a></span><span id="33bc" class="no me iq ld b gy nw nq l nr ns">Benchmarking nginx (be patient)</span><span id="1686" class="no me iq ld b gy nw nq l nr ns">Server Software:        nginx/1.19.3<br/>Server Hostname:        nginx<br/>Server Port:            80</span><span id="6711" class="no me iq ld b gy nw nq l nr ns">Document Path:          /ping<br/>Document Length:        19 bytes</span><span id="d95d" class="no me iq ld b gy nw nq l nr ns">Concurrency Level:      1<br/>Time taken for tests:   52.124 seconds<br/><strong class="ld ir">Complete requests:      24705</strong><br/><strong class="ld ir">Failed requests:        0</strong><br/>Total transferred:      13488930 bytes<br/>HTML transferred:       469395 bytes<br/>Requests per second:    473.97 [#/sec] (mean)<br/>Time per request:       2.110 [ms] (mean)<br/>Time per request:       2.110 [ms] (mean, across all concurrent requests)<br/>Transfer rate:          252.72 [Kbytes/sec] received</span><span id="1e16" class="no me iq ld b gy nw nq l nr ns">Connection Times (ms)<br/>              min  mean[+/-sd] median   max<br/>Connect:        0    0   0.1      0       9<br/>Processing:     1    1   0.3      1      13<br/>Waiting:        1    1   0.3      1      13<br/>Total:          1    1   0.3      1      13</span><span id="aee0" class="no me iq ld b gy nw nq l nr ns">Percentage of the requests served within a certain time (ms)<br/>  50%      1<br/>  66%      1<br/>  75%      2<br/>  80%      2<br/>  90%      2<br/>  95%      2<br/>  98%      2<br/>  99%      3<br/> 100%     13 (longest request)</span></pre><p id="d595" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">Failed requests</code>应该是<code class="fe la lb lc ld b">0</code>并且你也不应该看到报告中的<code class="fe la lb lc ld b">Non-2xx responses</code>部分。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="b2de" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">托多斯</h1><ul class=""><li id="40c1" class="ny nz iq ke b kf nb kj nc kn oa kr ob kv oc kz od oe of og bi translated">在服务器或CI上使用Capistrano构建应用程序docker-image</li><li id="4ad3" class="ny nz iq ke b kf oh kj oi kn oj kr ok kv ol kz od oe of og bi translated">在部署工作流之外配置并运行<code class="fe la lb lc ld b">nginx-proxy</code></li></ul></div></div>    
</body>
</html>