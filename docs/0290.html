<html>
<head>
<title>A Scalable JS Script Deployment Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可扩展的JS脚本部署工作流</h1>
<blockquote>原文：<a href="https://itnext.io/a-scalable-js-script-deployment-workflow-c206bc3cf8f6?source=collection_archive---------3-----------------------#2018-02-09">https://itnext.io/a-scalable-js-script-deployment-workflow-c206bc3cf8f6?source=collection_archive---------3-----------------------#2018-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你有一个团队为一个可发布的JS脚本做贡献吗？你是否认为你的开发和部署过程过于复杂？这篇文章也许能帮到你。</p><p id="ff3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fa-scalable-js-script-deployment-workflow-c206bc3cf8f6" rel="noopener ugc nofollow" target="_blank"> <em class="km">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="1bf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设有几个人在编写一个JS脚本，这个脚本需要在一个或多个目标应用程序的特定页面上运行。你的开发过程是什么样的？你如何测试特定的特性？你如何测试和部署一个完整的版本？没有完美的工作流，尤其是当越来越多的人加入到这个组合中来为同一个代码库做出贡献的时候。然而，我在这里分享一个过程和使能技术，它们正在为我在VICE的小团队工作。</p><p id="3707" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始之前，这里有一些<strong class="jp ir">需求、假设、</strong>和<strong class="jp ir">工具</strong>来实现这个工作流:</p><p id="5ef8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">要求</strong>:</p><ul class=""><li id="9989" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">必须能够轻松地允许多个开发人员在同一个代码库工作</li><li id="9059" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">必须能够轻松测试特定的错误修复或功能</li><li id="da7f" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">必须能够在接收应用程序的试运行环境中轻松测试下一个版本</li><li id="8a9a" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">必须能够轻松触发试运行/生产部署</li><li id="3dc2" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">必要时必须能够轻松回滚</li></ul><p id="bdb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">假设</strong>:</p><ol class=""><li id="9222" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk lb kt ku kv bi translated">接收应用程序有一个暂存环境</li><li id="51f1" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">自动气象站S3桶的前端是一个CDN</li></ol><p id="d4ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">启用工具</strong>:</p><ol class=""><li id="37e5" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk lb kt ku kv bi translated">持续集成服务(Travis CI)</li><li id="cabd" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">云存储(AWS S3)</li><li id="d57e" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">云代码库(Github)</li><li id="d43a" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">一些简单的可执行脚本(Bash)</li></ol><p id="4110" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">明白要点了吗？好的，酷，我们开始吧。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="db83" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">概观</h1><p id="003f" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">首先，我们需要规划我们试图实现的工作流程。下面我创建了一个彩色的流程图，我希望不会太混乱…</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mm"><img src="../Images/c588f0232ca6951c5e2922c4cd8c6f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-demet-VNLuuCx1D0I_SUQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">开发和部署工作流</figcaption></figure><p id="7b15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是上述步骤的概要:</p><ol class=""><li id="6e1a" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk lb kt ku kv bi translated">总支是起点</li><li id="e2ab" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">从主分支创建的发布分支<br/>特性/从主分支创建的bug分支→ <em class="km">触发S3部署</em></li><li id="3a95" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">在接收应用程序上测试功能/缺陷(本地环境)</li><li id="abff" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">特性/bug分支被<strong class="jp ir">挤压+合并</strong>到发布分支→ <em class="km">触发S3部署</em></li><li id="e968" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">一旦所有的功能和错误都在，发布将在接收应用程序(暂存环境)上进行测试</li><li id="3892" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">发布分支<strong class="jp ir">被压扁+合并</strong>到主分支→ <em class="km">触发S3部署</em></li></ol><p id="c26b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个高层次的概述，下面是AWS S3部署过程中幕后发生的事情…</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nc"><img src="../Images/5b6292913ed13888128489e84020f237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yn7-uMTNSp5Rtu6oM1TzSw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">AWS S3部署路径</figcaption></figure><p id="f8ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意上图中的开发S3部署也使用了staging bucket(除了使用此bucket的staging部署之外)。其原因将在测试部分讨论。</p><p id="fbcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们来看看实现这一过程所需的项目…</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="9458" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">设置分发(或构建)文件夹</h1><p id="8627" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">启用这个工作流首先需要的是建立<code class="fe nd ne nf ng b">dist</code>文件夹的<em class="km">开发、试运行、</em>和<em class="km">生产</em>构建。</p><ol class=""><li id="046a" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk lb kt ku kv bi translated"><code class="fe nd ne nf ng b">npm run build-dev</code> → <code class="fe nd ne nf ng b">./dist/{branch-name}/{bundle-name}.js</code></li><li id="c18d" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated"><code class="fe nd ne nf ng b">npm run build-staging</code> → <code class="fe nd ne nf ng b">./dist/{release-version}/{bundle-name}.js</code></li><li id="00ae" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated"><code class="fe nd ne nf ng b">npm run build-prod</code> → <code class="fe nd ne nf ng b">./dist/{release-version}/{bundle-name}.js</code></li></ol><p id="c9e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管<code class="fe nd ne nf ng b">staging</code>和<code class="fe nd ne nf ng b">prod</code>构建将构建工件发送到同一个<code class="fe nd ne nf ng b">dist</code>路径，但是假设这些构建在幕后是完全不同的。例如，<code class="fe nd ne nf ng b">prod</code>构建已经缩减了代码，而<code class="fe nd ne nf ng b">staging</code>构建没有。您可以有几个Webpack配置来启用这些不同的构建。此外，这里有一些提示可以帮助您构建所需的<code class="fe nd ne nf ng b">dist</code>路径。</p><ol class=""><li id="1d41" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk lb kt ku kv bi translated"><strong class="jp ir"> Branch name → </strong>您可以简单地访问<code class="fe nd ne nf ng b">TRAVIS_BRANCH</code>环境变量(记住，构建将在CI服务器中执行)</li><li id="43e3" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated"><strong class="jp ir">发布版本</strong> →可以导入<code class="fe nd ne nf ng b">package.json</code>，从那里抓取<code class="fe nd ne nf ng b">version</code>属性(假设更新到当前发布版本)。</li></ol><p id="5639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该设置构建，以便它们也可以在本地执行以进行测试。因此，您应该能够在Travis上或在本地环境中提取分支名称。这里有一个简单的脚本来<code class="fe nd ne nf ng b">echo</code>在Travis服务器或本地工作的分支名称:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="00f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Travis上，我们需要执行一个<code class="fe nd ne nf ng b">build_dist.sh</code>脚本，它将根据分支名称检测要执行哪个构建:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fe02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，该脚本使用正则表达式匹配来检测分支是否是发布分支。我建议对发布分支有一个分支命名约定，这样这个检测是可能的。在这种情况下，惯例是<code class="fe nd ne nf ng b">release-v#.#.##</code>。任何具有该名称的分支都被认为是一个发布，因此将执行阶段构建。</p><p id="a8d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦构建完成，我们就可以继续前进了。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="d0b4" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">自动化S3部署</h1><p id="04ed" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">接下来，我们希望实现自动化S3部署。</p><p id="341a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">先决条件:</em></p><ul class=""><li id="e2c2" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">构建工件可以按照上一节的说明构建到<code class="fe nd ne nf ng b">dist</code>文件夹路径中</li><li id="c08e" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">为存储库启用了Travis CI</li><li id="53ff" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">Travis CI配置为执行AWS S3 CLI命令(<em class="km">访问密钥</em>和<em class="km">秘密访问密钥</em>可用)</li></ul><p id="ea2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.创建一个可执行的<code class="fe nd ne nf ng b">deploy_script.sh</code> bash脚本，如下所示:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a7b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.更新<code class="fe nd ne nf ng b">travis.yml</code>以包括<code class="fe nd ne nf ng b">build_dist.sh</code>和<code class="fe nd ne nf ng b">deploy_script.sh</code>脚本，如下所示:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e9e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当构建在Travis上运行时，<code class="fe nd ne nf ng b">build_dist.sh</code>脚本将使构建工件在<code class="fe nd ne nf ng b">dist</code>文件夹中可用，<code class="fe nd ne nf ng b">deploy_script.sh</code>脚本将触发S3部署。<code class="fe nd ne nf ng b">deploy_script.sh</code>脚本将确定以哪个存储桶为目标，并使用AWS S3 CLI <code class="fe nd ne nf ng b">sync</code>命令将<code class="fe nd ne nf ng b">dist</code>文件夹与该存储桶同步。假设我们在上一节中正确地设置了我们的构建，我们应该可以开始了。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="463f" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><strong class="ak">测试功能/缺陷修复</strong></h1><p id="a4c5" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">请注意，开发工作流部署到分段存储桶，并使用功能/ bug分支名称作为附加的名称空间。这有两个好处:</p><ol class=""><li id="1eb0" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk lb kt ku kv bi translated">您可以轻松地修改<code class="fe nd ne nf ng b">src</code>来测试接收应用程序中的脚本:<br/> <code class="fe nd ne nf ng b">&lt;script src="{CDN-domain*}/{project-namespace}/{branch-name}/{bundle-name}.js"&gt;&lt;/script&gt;</code> *这里提到CDN域是因为它假设S3桶由CDN或边缘服务器提供(从而防止S3桶被公开访问，启用缓存、SSL等)。)</li><li id="9953" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">你不需要第三个发展S3桶。您只需要两个，一个暂存区和一个生产区。</li></ol><p id="550f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦验证了特性/缺陷修复在接收应用程序中正常工作，就可以将分支<strong class="jp ir">挤压</strong> + <strong class="jp ir">合并</strong>到发布分支中。推入发布分支的提交将启动阶段部署，并允许测试下一个发布。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="3900" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">测试下一版本</h1><p id="07b5" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">一旦下一个版本在特性和错误修复方面被锁定，它需要在部署前被彻底测试。有了这个工作流，就像在<code class="fe nd ne nf ng b">src</code>中更新版本路径一样简单，您的JS脚本在接收应用程序的暂存环境中下载:</p><p id="7010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nd ne nf ng b">&lt;script src="{CDN-domain}/{project-namespace}/{release-version}/{bundle-name}.js"&gt;&lt;/script&gt;</code></p><p id="0a33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常有一个QA团队和/或一些由Selenium/Cucumber支持的自动化浏览器测试来接管发布测试。一旦一切看起来都很好，每个人都很高兴，<strong class="jp ir">挤压+合并* </strong>发布分支成为主触发生产S3部署！所有接收应用程序还需要将更新后的<code class="fe nd ne nf ng b">src</code>路径部署到它们的生产环境中。</p><p id="0c04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">*我更喜欢这里的<strong class="jp ir">压扁+合并</strong>的主要原因就是因为这个:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nj"><img src="../Images/b488490f857b6e2b88987fe186097927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDhen8p43X38y4uhRmFh7g.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">在主服务器上提交历史记录</figcaption></figure><p id="b24b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在master上有这样一个提交历史的主要好处是发布被完全封装到一个提交中。这使得缩小与特定版本相关的回归或问题以及执行回滚变得更加容易…这就引出了我的下一个主题！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="3af9" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">执行回滚</h1><p id="9733" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">哦，糟糕……有东西爆炸了！</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="nk ni l"/></div></figure><p id="7de2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在惊慌失措了一会儿并得出结论认为不可能轻松修复之后，是时候回滚了！使用此工作流，您可以让接收应用程序更新<code class="fe nd ne nf ng b">src</code>路径以反映先前的版本，从而完成回滚。与此同时，您和您的团队可以继续发布后续补丁。太简单了，感觉像作弊！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="aadc" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="8d6d" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">使用这个部署工作流，您可以让几个人在同一个项目上无缝地工作，同时无论在什么环境下都可以自信地测试和部署变更。您可以像对待任何其他第三方脚本一样对待该脚本。如果当前版本是坏的，你可以简单地下载另一个已知稳定的版本。我的团队开发了VICE Video Embedded Web Player，它本质上是一个运行在嵌入式页面(iframes)上的JS脚本。这个团队由三个人组成，这个过程对我们来说非常有效。</p><p id="9335" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢这本书，并学到一些新东西！欢迎在评论区留下任何问题、评论或建议！</p></div></div>    
</body>
</html>