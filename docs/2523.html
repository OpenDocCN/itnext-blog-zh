<html>
<head>
<title>[ReadingKoa] Day One — How Koa middleware works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[阅读Koa]第一天Koa中间件如何工作</h1>
<blockquote>原文：<a href="https://itnext.io/how-koa-middleware-works-f4386b5573c?source=collection_archive---------2-----------------------#2019-06-07">https://itnext.io/how-koa-middleware-works-f4386b5573c?source=collection_archive---------2-----------------------#2019-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a40ae1723f7baecead42f00da332f91d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2whg_KJu-TseyDe9hCOPUg.jpeg"/></div></div></figure><p id="e17b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Koa中的中间件不同于Express，Koa使用<strong class="ka ir">洋葱模型。</strong>这个惊人的框架Koa只包含四个文件，今天我们只看主文件——<code class="fe kw kx ky kz b">application.js</code>。它已经包含了中间件如何工作的核心逻辑。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi la"><img src="../Images/fccfdc32e34ce1c79e69c4f755680526.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*pIpgH_ojNtxyeaBADCBYug.png"/></div></figure><h1 id="0823" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">准备</h1><pre class="lb lc ld le gt md kz me mf aw mg bi"><span id="b41f" class="mh lg iq kz b gy mi mj l mk ml">git clone git@github.com:koajs/koa.git<br/>npm install</span></pre><p id="1d7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们在项目的根处添加一个<code class="fe kw kx ky kz b">index.js</code>用于测试目的</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="aa3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以运行以下命令来启动服务器:</p><pre class="lb lc ld le gt md kz me mf aw mg bi"><span id="4f4f" class="mh lg iq kz b gy mi mj l mk ml">node index.js</span></pre><p id="43f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">访问<code class="fe kw kx ky kz b">http://localhost:3000</code>，你会看到<code class="fe kw kx ky kz b">1, 2, 3, 4, 5, 6</code>的输出。这叫做<strong class="ka ir">洋葱模型(中间件)</strong></p><h1 id="2600" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">洋葱模型如何工作</h1><p id="4f9e" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">让我们阅读koa的核心，看看中间件是如何工作的。在<code class="fe kw kx ky kz b">index.js</code>中，我们这样使用中间件:</p><pre class="lb lc ld le gt md kz me mf aw mg bi"><span id="cebc" class="mh lg iq kz b gy mi mj l mk ml">const app = new Koa();<br/>app.use(// middleware);<br/>app.use(// middleware);<br/>app.listen(3000);</span></pre><p id="903a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看<code class="fe kw kx ky kz b">application.js</code>，这里是那些与中间件相关的代码，我在代码中添加了一些注释。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="55b5" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">关于合成功能</h1><p id="d8db" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">关于<code class="fe kw kx ky kz b">compose</code>函数的更多信息，我们可以看看<code class="fe kw kx ky kz b">koa-compose</code>包</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a234" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有的中间件都被传递给<code class="fe kw kx ky kz b">compose</code>函数，它返回dispatch(0)，它立即执行dispatch函数并返回一个承诺。在我们理解<code class="fe kw kx ky kz b">dispatch</code>函数的内容之前，我们必须理解promise的语法。</p><h1 id="1fce" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">关于承诺</h1><p id="8671" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">通常我们这样使用承诺:</p><pre class="lb lc ld le gt md kz me mf aw mg bi"><span id="6eca" class="mh lg iq kz b gy mi mj l mk ml">const promise = new Promise(function(resolve, reject) {<br/>  if (success){<br/>    resolve(value);<br/>  } else {<br/>    reject(error);<br/>  }<br/>});</span></pre><p id="0810" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Koa中，它是这样使用的:</p><pre class="lb lc ld le gt md kz me mf aw mg bi"><span id="b2f3" class="mh lg iq kz b gy mi mj l mk ml">let testPromise = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    resolve('test success');<br/>  }, 1000);<br/>});</span><span id="29a8" class="mh lg iq kz b gy mt mj l mk ml">Promise.resolve(testPromise).then(function (value) {<br/>  console.log(value); // "test success"<br/>});</span></pre><p id="07c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们知道在compose函数中，它返回一个<strong class="ka ir">承诺</strong>。</p><h1 id="a0ac" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">回到Koa —组合中间件</h1><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ca86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">dispatch</code>是一个递归函数，会循环所有中间件。在我们的<code class="fe kw kx ky kz b">index.js</code>中，我们有3个中间件，所有3个中间件将在<code class="fe kw kx ky kz b">await next();</code>之前执行那些编码</p><pre class="lb lc ld le gt md kz me mf aw mg bi"><span id="b515" class="mh lg iq kz b gy mi mj l mk ml">app.use(async (ctx, next) =&gt; {<br/>  console.log(2);<br/>  const start = Date.now();<br/>  await next(); // &lt;- stop here and wait for the next middleware complete<br/>  console.log(5);<br/>  const ms = Date.now() - start;<br/>  ctx.set('X-Response-Time', `${ms}ms`);<br/>});</span></pre><p id="1e08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看看<code class="fe kw kx ky kz b">index.js</code>中那三个中间件的执行顺序:</p><ul class=""><li id="9613" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">执行<code class="fe kw kx ky kz b">dispatch(0)</code>时，执行<code class="fe kw kx ky kz b">Promise.resolve(fn(context, dispatch.bind(null, 0 + 1)))</code></li><li id="a016" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">第一个中间件内容将运行到<code class="fe kw kx ky kz b">await next()</code></li><li id="1860" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated"><code class="fe kw kx ky kz b">next()</code> = <code class="fe kw kx ky kz b">dispatch.bind(null, 0 + 1)</code>，第二个中间件是哪个</li><li id="eafe" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">第二个中间件将运行到<code class="fe kw kx ky kz b">await next()</code></li><li id="b9a3" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated"><code class="fe kw kx ky kz b">next()</code> = <code class="fe kw kx ky kz b">dispatch.bind(null, 1 + 1)</code>，这是第三个中间件</li><li id="af6d" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">第三个中间件将运行到<code class="fe kw kx ky kz b">await next()</code></li><li id="e8e5" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated"><code class="fe kw kx ky kz b">next()</code> = <code class="fe kw kx ky kz b">dispatch.bind(null, 2 + 1)</code>，没有第四个中间件，它会被<code class="fe kw kx ky kz b">if (!fn) return Promise.resolve()</code>立即返回，第三个中间件中的<code class="fe kw kx ky kz b">await next()</code>被解析，执行第三个中间件中剩余的代码。</li><li id="106e" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">第二中间件中的<code class="fe kw kx ky kz b">await next()</code>被解析，第二中间件中的剩余代码被执行。</li><li id="b0e1" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">第一中间件中的he <code class="fe kw kx ky kz b">await next()</code>被解析，执行第一中间件中的剩余代码。</li></ul><h1 id="0ddd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么是洋葱模型？</h1><p id="8d3c" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">如果我们在中间件中有async/ await，编码会更简单。当我们想要为api请求编写一个时间记录器时，通过添加这个中间件可以变得非常容易:</p><pre class="lb lc ld le gt md kz me mf aw mg bi"><span id="bd10" class="mh lg iq kz b gy mi mj l mk ml">app.use(async (ctx, next) =&gt; {<br/>  const start = Date.now();<br/>  await next(); // your API logic<br/>  const ms = Date.now() - start;<br/>  console.log('API response time:' + ms);<br/>});</span></pre><h1 id="c585" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">下一篇文章:阅读Koa中的所有代码</h1><div class="ni nj gp gr nk nl"><a href="https://medium.com/@alickwong/readingkoa-day-two-read-and-understand-koa-core-a6afd24e012c" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">[阅读Koa]第二天—阅读并理解Koa核心</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">在15分钟内从Koa读取所有代码</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz jw nl"/></div></div></a></div><h1 id="281a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">参考</h1><ul class=""><li id="857b" class="mu mv iq ka b kb mo kf mp kj oa kn ob kr oc kv mz na nb nc bi translated"><a class="ae od" href="https://github.com/eggjs/egg/blob/master/docs/source/en/intro/egg-and-koa.md" rel="noopener ugc nofollow" target="_blank">鸡蛋/鸡蛋</a></li></ul></div></div>    
</body>
</html>