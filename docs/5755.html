<html>
<head>
<title>Redis Streams in Action: Part 1 (Intro and overview)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis Streams在运行:第1部分(介绍和概述)</h1>
<blockquote>原文：<a href="https://itnext.io/redis-streams-in-action-part-1-intro-and-overview-135f66d3ab58?source=collection_archive---------1-----------------------#2021-05-18">https://itnext.io/redis-streams-in-action-part-1-intro-and-overview-135f66d3ab58?source=collection_archive---------1-----------------------#2021-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c195" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这一部分探讨了用例、动机，并提供了解决方案中使用的Redis特性的高级概述。</h2></div><p id="1e51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎阅读这一系列博客文章，这些文章通过一个实际例子的帮助涵盖了<a class="ae lb" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank"> Redis流</a>。我们将使用一个示例应用程序来实时搜索和查询Twitter数据。<a class="ae lb" href="https://redisearch.io/" rel="noopener ugc nofollow" target="_blank">redi research</a>和<a class="ae lb" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank">redi Streams</a>是这个解决方案的支柱，它由几个合作组件组成，我们将在一篇专门的博客文章中介绍每一个组件。</p><ul class=""><li id="05d9" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">第1部分—本博客</li><li id="6ad9" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://abhishek1987.medium.com/redis-streams-in-action-part-2-tweets-consumer-app-674fd3b45f6f" rel="noopener">第二部分</a></li><li id="ff2d" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/redis-streams-in-action-part-3-tweets-processor-app-254161838973">第三部分</a></li><li id="fb54" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/redis-streams-in-action-part-4-serverless-monitoring-service-faef52ee58db">第四部分</a></li></ul><blockquote class="lq lr ls"><p id="b48e" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">本GitHub回购中有代码—</em><a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://github.com/abhirockzz/redis-streams-in-action</em></a></p></blockquote><p id="29f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是第一部分，探讨了用例、动机，并提供了解决方案中使用的Redis特性的高级概述。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="68b1" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">解决方案架构</h1><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi mw"><img src="../Images/2dcf1c087cde505b88484082efa002e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IT2Xajn2Fo-TjYn9.jpg"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">高层建筑</figcaption></figure><p id="51f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用例相对简单。作为最终目标，我们希望有一个服务，让我们能够根据一些标准，如标签，用户，位置等搜索推文。当然，对此已有解决方案。本博客系列中提供的是一个示例场景，可以应用于类似的问题。</p><p id="1720" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是各个组件的摘要:</p><ol class=""><li id="9346" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la nm li lj lk bi translated">Twitter流消费者:一个Rust应用程序，用于消费Twitter流数据，并将它们传递给Redis流。我将在<a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/container-instances-overview?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure容器实例</a>中演示如何将它作为Docker容器运行</li><li id="8c44" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la nm li lj lk bi translated">Tweets处理器:来自Redis流的tweets由Java应用程序处理——这也将使用Azure容器实例进行部署(和扩展)。</li><li id="e1f5" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la nm li lj lk bi translated">监控服务:最后一部分是一个<a class="ae lb" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>应用程序，用于监控tweets处理器服务的进度，并确保任何失败的记录都得到重新处理。这是一个无服务器组件，将被部署到Azure Functions中，你可以基于定时器触发器运行它，并且只需为它运行的时间付费。</li></ol><p id="ef88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经使用了一些Azure服务(包括支持Redis模块如<code class="fe nn no np nq b">RediSearch</code>、<code class="fe nn no np nq b">RedisTimeSeries</code>和Redis Bloom的Azure Cache的<a class="ae lb" href="https://techcommunity.microsoft.com/t5/apps-on-azure/delivering-an-even-better-redis-experience-on-azure/ba-p/2176217?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank">企业层)来运行解决方案的不同部分，但是您可以稍微调整一下指令，并根据您的环境应用它们，例如，您可以使用Docker在本地运行一切！尽管各个服务是用不同的编程语言编写的，但同样的概念也适用(在Redis流、<code class="fe nn no np nq b">RediSearch</code>、可伸缩性等方面)。)并可以用您选择的语言实现。</a></p><h1 id="4f1f" class="me mf iq bd mg mh nr mj mk ml ns mn mo jw nt jx mq jz nu ka ms kc nv kd mu mv bi translated">“规模需求”</h1><p id="912c" class="pw-post-body-paragraph kf kg iq kh b ki nw jr kk kl nx ju kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">我写了一篇博文<a class="ae lb" href="https://redislabs.com/blog/redisearch-in-action/" rel="noopener ugc nofollow" target="_blank"> RediSearch in Action </a>，涵盖了相同的用例，即如何实现一组实时消费推文的应用程序，在<a class="ae lb" href="https://redisearch.io/" rel="noopener ugc nofollow" target="_blank"> RediSearch </a>中索引它们，并使用REST API查询它们。然而，这里提出的解决方案是在Redis Streams和其他组件的帮助下实现的，目的是使架构具有可伸缩性和容错性。在这个具体的例子中，它是处理大量推文的能力，但同样的想法可以扩展/应用到处理高速数据的其他用例，如物联网、日志分析等。这类问题得益于一种架构，在这种架构中，您可以横向扩展您的应用程序来处理不断增长的数据量。通常，这涉及到引入一个消息传递系统作为生产者和消费者之间的缓冲。因为这是一个常见的需求，而且问题空间也很好理解，所以在分布式消息传递领域有很多成熟的解决方案，从JMS (Java消息传递服务)、<a class="ae lb" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Kafka </a>、<a class="ae lb" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>、<a class="ae lb" href="https://nats.io/" rel="noopener ugc nofollow" target="_blank"> NATS </a>，当然还有Redis。</p><h1 id="93c9" class="me mf iq bd mg mh nr mj mk ml ns mn mo jw nt jx mq jz nu ka ms kc nv kd mu mv bi translated">Redis中的许多选项！</h1><p id="e9f7" class="pw-post-body-paragraph kf kg iq kh b ki nw jr kk kl nx ju kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">不过，Redis有一些独特之处。从消息传递的角度来看，Redis非常灵活，因为它提供了多种选项来支持不同的范例，因此适用于广泛的用例。它的特性包括<a class="ae lb" href="https://redis.io/topics/pubsub" rel="noopener ugc nofollow" target="_blank">发布订阅</a>、<a class="ae lb" href="https://redis.io/topics/data-types-intro#redis-lists" rel="noopener ugc nofollow" target="_blank">列表</a>(工作队列方法)和Redis流。因为这个博客系列主要关注Redis流，所以在继续之前，我将提供一个其他可能性的快速概览。</p><ul class=""><li id="d451" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">Pub-Sub:它遵循一个基于广播的范例，其中多个接收者可以消费发送到特定<em class="lt">通道</em>的消息。生产者和消费者是完全分离的，但是请注意，没有<em class="lt">消息持久性的概念，也就是说，如果消费者应用程序没有启动并运行，当它稍后重新启动时，它不会获得那些消息。</em></li><li id="b8dd" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">列表:它们允许我们采用基于工作队列的方法，可以在工作应用程序之间分配负载。消息一旦被消费就被删除。它可以使用<code class="fe nn no np nq b">RPOPLPUSH</code>(和<code class="fe nn no np nq b">BRPOPLPUSH</code>)提供一定程度的容错和可靠性</li></ul></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="cd65" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">Redis流</h1><p id="2ff9" class="pw-post-body-paragraph kf kg iq kh b ki nw jr kk kl nx ju kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">Redis Streams是在Redis 5.0中引入的，它提供了最好的发布/订阅和列表，以及可靠的消息传递、消息重放的持久性、用于负载平衡的使用者组、用于监控的待定条目列表等等！它的不同之处在于它是一个<code class="fe nn no np nq b">append-only log</code>数据结构。简而言之，生产者可以添加记录(使用<code class="fe nn no np nq b">XADD</code>)，消费者可以订阅到达流的新项目(使用<code class="fe nn no np nq b">XREAD</code>)。支持范围查询(<code class="fe nn no np nq b">XRANGE</code>等。)由于消费者团体，一组应用程序可以分配处理负载(<code class="fe nn no np nq b">XREADGROUP</code>)并可以监控其状态(<code class="fe nn no np nq b">XPENDING</code>等)。</p><p id="4528" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为Redis的魅力在于它强大的命令系统，所以让我们来看一下Redis Streams的一些命令，为了更容易理解，这些命令按照功能进行了分组:</p><p id="3b48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">添加条目</strong></p><p id="6afe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有一种方法可以将消息添加到Redis流中。<a class="ae lb" href="https://redis.io/commands/XADD" rel="noopener ugc nofollow" target="_blank"> XADD </a>将指定的流条目追加到流中指定的键处。如果键不存在，作为运行该命令的副作用，将使用流值创建键。</p><p id="cb71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">读取条目</strong></p><ul class=""><li id="f4bf" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" href="https://redis.io/commands/xrange" rel="noopener ugc nofollow" target="_blank"> XRANGE </a>返回匹配给定ID范围的流条目(<code class="fe nn no np nq b">-</code>和<code class="fe nn no np nq b">+</code>特殊ID分别表示流内可能的最小ID和最大ID)</li><li id="080e" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://redis.io/commands/XREVRANGE" rel="noopener ugc nofollow" target="_blank"> XREVRANGE </a>与<code class="fe nn no np nq b">XRANGE</code>完全相同，但不同之处在于以相反的顺序返回条目(先使用结束ID，后使用开始ID)</li><li id="c624" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://redis.io/commands/XREAD" rel="noopener ugc nofollow" target="_blank">xdread</a>从一个或多个流中读取数据，只返回ID大于调用者报告的最后接收到的ID的条目。</li><li id="c6fc" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://redis.io/commands/XREADGROUP" rel="noopener ugc nofollow" target="_blank"> XREADGROUP </a>是<code class="fe nn no np nq b">XREAD</code>命令的特殊版本，支持消费者群体。您可以创建客户端组，使用到达给定流的消息的不同部分</li></ul><p id="d79e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">管理Redis流</strong></p><ul class=""><li id="5b8e" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" href="https://redis.io/commands/XACK" rel="noopener ugc nofollow" target="_blank"> XACK </a>从流使用者组的待定条目列表(<code class="fe nn no np nq b">PEL</code>)中删除一条或多条消息。</li><li id="8850" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://redis.io/commands/XGROUP" rel="noopener ugc nofollow" target="_blank"> XGROUP </a>用于管理与Redis流相关的消费者组。</li><li id="42ac" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://redis.io/commands/XPENDING" rel="noopener ugc nofollow" target="_blank"> XPENDING </a>用于检查待处理消息列表，以观察和了解流消费者群体的情况。</li><li id="c981" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://redis.io/commands/XCLAIM" rel="noopener ugc nofollow" target="_blank"> XCLAIM </a>用于获取消息的所有权并继续处理。</li><li id="0b9c" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">XAUTOCLIAM 转移符合指定标准的挂起流条目的所有权。从概念上讲，<code class="fe nn no np nq b">XAUTOCLAIM</code>相当于先调用<code class="fe nn no np nq b">XPENDING</code>，再调用<code class="fe nn no np nq b">XCLAIM</code></li></ul><p id="9798" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">删除</strong></p><ul class=""><li id="240b" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" href="https://redis.io/commands/xdel" rel="noopener ugc nofollow" target="_blank"> XDEL </a>从流中删除指定的条目，并返回删除条目的数量，如果某些id不存在，该数量可能不同于传递给命令的id数量。</li><li id="6b45" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://redis.io/commands/xtrim" rel="noopener ugc nofollow" target="_blank"> XTRIM </a>如果需要，通过驱逐旧条目(id较低的条目)来整理流。</li></ul><blockquote class="lq lr ls"><p id="e02e" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">详细的话，我强烈推荐阅读</em><a class="ae lb" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank"><em class="iq">《Redis流简介》</em> </a> <em class="iq">(来自Redis官方文档)。</em></p></blockquote><h1 id="c065" class="me mf iq bd mg mh nr mj mk ml ns mn mo jw nt jx mq jz nu ka ms kc nv kd mu mv bi translated">再搜索呢？</h1><p id="66b3" class="pw-post-body-paragraph kf kg iq kh b ki nw jr kk kl nx ju kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">Redis有一套通用的数据结构，从简单的字符串到强大的抽象，如Redis流。原生数据类型可以带您走很长一段路，但是有些用例可能需要一个解决方法。一个例子是Redis中使用二级索引的要求，以便超越基于关键字的搜索/查找，获得更丰富的查询功能。虽然你可以使用<a class="ae lb" href="https://redis.io/topics/indexes" rel="noopener ugc nofollow" target="_blank">有序集合、列表等等来完成工作</a>，但是你需要考虑一些权衡。</p><p id="4964" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">得益于一流的二级索引引擎，<code class="fe nn no np nq b">RediSearch</code>作为Redis模块提供了灵活的搜索功能。它的一些关键特性包括全文搜索、自动完成和地理索引。还有许多其他特性，它们的详细探讨超出了本博客系列的范围。我强烈建议您通过<a class="ae lb" href="https://oss.redislabs.com/redisearch/" rel="noopener ugc nofollow" target="_blank">文档</a>进行进一步探索。现在，这里是一些<code class="fe nn no np nq b">RediSearch</code>命令的快速概述。您将在后续的博客文章中看到它们的实际应用。</p><p id="c686" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个最重要的命令包括创建索引和执行搜索查询:</p><ul class=""><li id="213b" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" href="https://oss.redislabs.com/redisearch/Commands/#ftcreate" rel="noopener ugc nofollow" target="_blank">英尺。CREATE </a>用于创建具有给定模式和相关细节的索引。</li><li id="3d5c" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://oss.redislabs.com/redisearch/Commands/#ftsearch" rel="noopener ugc nofollow" target="_blank">英尺。SEARCH </a>使用文本查询搜索索引，返回文档或id。</li></ul><p id="1efb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以对索引执行其他操作:</p><ul class=""><li id="088a" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">英尺。DROPINDEX 删除索引。请注意，默认情况下，它不会删除与索引相关联的文档哈希</li><li id="0dd0" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://oss.redislabs.com/redisearch/Commands/#ftinfo" rel="noopener ugc nofollow" target="_blank">英尺。INFO </a>返回索引的信息和统计数据，比如文档数量、不同术语的数量等等。</li><li id="1ff9" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://oss.redislabs.com/redisearch/Commands/#ftalter_schema_add" rel="noopener ugc nofollow" target="_blank">英尺。ALTER SCHEMA ADD </a>向索引中添加一个新字段。这将导致将来的文档更新在索引和重新索引现有文档时使用新字段。</li></ul><p id="7865" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用自动完成功能，您可以使用“建议”:</p><ul class=""><li id="b2ec" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" href="https://oss.redislabs.com/redisearch/Commands/#ftsugadd" rel="noopener ugc nofollow" target="_blank">英尺SUGADD </a>将建议字符串添加到自动完成的建议字典中。</li><li id="e2fd" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://oss.redislabs.com/redisearch/Commands/#ftsugget" rel="noopener ugc nofollow" target="_blank">英尺SUGGET </a>获取前缀的补全建议。</li></ul><p id="2c67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np nq b">RediSearch</code>支持同义词，这是一种由一组组组成的数据结构，每个组都包含同义词。<a class="ae lb" href="https://oss.redislabs.com/redisearch/Commands/#ftsynupdate" rel="noopener ugc nofollow" target="_blank">英尺SYNUPDATE </a>可用于创建或更新带有附加术语的同义词组。</p><p id="c4d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想要查询拼写检查纠正(类似于“你的意思是”功能)，你可以使用<a class="ae lb" href="https://oss.redislabs.com/redisearch/Commands/#ftspellcheck" rel="noopener ugc nofollow" target="_blank"> FT。SPELLCHECK </a>对查询执行拼写纠正，返回拼写错误的术语的建议。</p><p id="de3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字典是一组术语。词典可用于修改RediSearch的查询拼写更正行为，方法是在潜在的拼写更正建议中包含或排除其内容。你可以用<a class="ae lb" href="https://oss.redislabs.com/redisearch/Commands/#ftdictadd" rel="noopener ugc nofollow" target="_blank"> FT。口述</a>和<a class="ae lb" href="https://oss.redislabs.com/redisearch/Commands/#ftdictdel" rel="noopener ugc nofollow" target="_blank"> FT。DICTDEL </a>分别添加和删除术语。</p><p id="2b0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这部分到此为止！</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="e841" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">展望未来…</h1><p id="fd6c" class="pw-post-body-paragraph kf kg iq kh b ki nw jr kk kl nx ju kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">正如我提到的，这只是一个介绍。在接下来的三篇博文中，您将了解用于构建解决方案的各个组件的细节。您将在Azure上部署、运行和验证它们，并浏览代码以更好地理解“幕后”发生的事情。敬请期待！</p></div></div>    
</body>
</html>