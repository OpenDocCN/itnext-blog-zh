# 辉煌的 Makefile:构建您的静态网站

> 原文：<https://itnext.io/glorious-makefile-building-your-static-website-4e7cdc32d985?source=collection_archive---------2----------------------->

![](img/eb8dcdef38c63634129f15166705b7ac.png)

托德·夸肯布什在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

如今静态网站又开始流行了。它甚至还有一个名字: [JAMStack](https://jamstack.org/) 。经过多年的完善和发展，我们重新发现了一个事实:静态网站非常快。有时我们甚至高估了网站动态性的好处。即使我们需要它，也有很多好的前端 javascript 框架让我们下载 JSON 数据，只在浏览器中构建动态部分。

因此，也有大量的工具来创建静态网站。你有[杰基尔](https://jekyllrb.com/)[盖茨比](https://www.gatsbyjs.com/)[雨果](https://gohugo.io/)等等。所有这些都是非常好的工具。但是今天我想向你展示如何用一个非常古老的学校工具来做这件事，这个工具叫做: [Make](https://en.wikipedia.org/wiki/Make_(software)) 。

如果你不在乎解释，只是想看代码，你应该感到羞耻，但这里是要点。

# 为什么要制造？

有几个原因。首先，Make 是你可能已经拥有的经典工具之一。第一版于 1976 年发布。不需要安装一个新的工具，这反过来迫使你安装一个你不使用的编程语言。事实上，大多数 Make 都是建立在 shell 脚本之上的，您可能已经知道了。

另一个原因是**你会学到一些在很多情况下有用的东西**，而不仅仅是建立静态网站。这是因为，虽然 Make 用法是为了特定目的，但是这个目的是非常通用的。您创建目标任务并组织它们之间的依赖关系。这是一个建立网站的虚拟例子:

在这里，如果你把它放在一个名为“Makefile”的目录中，那么在这个目录中，你可以使用命令`make html`或`make css`。但是你也可以使用命令`make all`来构建 HTML 和 CSS，因为在规范中，同一行冒号后面的是依赖关系。实际上我们甚至可以单独运行`make`,因为没有参数，Make 将默认它在文件中找到的第一个目标/任务。

最后，Make 的优点是它非常适合在每次迭代中只重建必要的东西。这是因为 Make 的工作方式是，对于每个目标，它比较依赖项和目标文件的修改时间，以了解目标是否需要构建。

**警告:为了让 Make 正常工作，您需要使用制表符来缩进。如果您使用空格，它将不起作用。如果在文本编辑器和展开标签中使用空格，请确保 Makefiles 有例外。下面是如何在 Vim 中设置它:**

```
**autocmd** FileType **make** setlocal **noexpandtab tabstop=4 shiftwidth=4**
```

# 制作一个静态网站项目

现在让我们严肃起来。根据你的喜好随意改变任何东西，但是我们要做的是有 2 个目录，一个`src`用于我们的源文件，一个`build`用于我们生成的文件或静态资产。目录将会是完成的网站。

所以添加这些目录和一个`Makefile`，在其中您将从以下内容开始:

```
SRC_DIR = src
DST_DIR = build
```

所以你可以创建一些变量。注意，您可以在等号两边加上空格，这在 shell 脚本中是不可能的。

# 制作一些 CSS

我们刚刚为两个主目录创建了占位符:源目录*和目的目录*和目的目录*。现在让我们再添加几个来构建我们的 CSS 文件。我们将认为我们所有的源文件都是 SCSS 文件，都在同一个层次上。我们的 SCSS 包含一个嵌套的`includes`目录，文件以下划线开头。如果您不需要包含的文件，请随意简化代码。*

以下是目前为止的结构:

```
./
├── Makefile
├── build/
└── src/
    └── scss/
        ├── includes/
        │   └── _inc.scss
        └── main.scss
```

你显然可以有更多的 SCSS 文件和更多的包括。这是我们新的 Makefile:

```
SRC_DIR = src
DST_DIR = buildCSS_DIR = $(DST_DIR)/css
SCSS_DIR = $(SRC_DIR)/scss
SCSS_INCLUDES_DIR = $(SCSS_DIR)/includesSCSS_FILES = $(wildcard $(SCSS_DIR)/*.scss)
CSS_FILES = $(patsubst $(SCSS_DIR)/%.scss, $(CSS_DIR)/%.css, $(SCSS_FILES))
```

在这里，您可以看到如何基于以前的变量创建新的变量。名字只是被`**$(**NAME**)**` 包围。最复杂的部分是最后的两行。括号里的其实是宏。它们可以只是一个变量名，但是你也可以使用函数。`wildcard`函数的作用与 shell 中的通配符相同，它将直接在 SCSS 目录中为您提供所有 SCSS 文件的数组。而`patsubst`函数通过替换文件夹名和扩展名来生成要创建的 CSS 文件列表。它是这样工作的:

```
$( patsubst pattern, replacement, text )
```

我们的文本是 SCSS 文件的列表。`patsubst`应用于由空格分隔的每个“部分”(即本例中的每个文件名)。然后通过匹配原始模式中的占位符“%”，基于替换模式创建一个新列表。详见[制作手册](https://www.gnu.org/software/make/manual/make.html#Functions)。

现在我们有了 CSS 文件的列表，我们可以创建我们的第一个目标:

```
.PHONY: css
css: $(CSS_FILES) ## Build all CSS files from SCSS
```

不要太担心第一线。您需要知道的是，大多数时候，默认情况下，要构建的目标被认为是文件或目录。稍后你会看到这个。但其他的只是一个动作的名字。典型的例子是“清洁”或“帮助”。其他的——比如这里——是代表一组文件的名称。这并不总是可能的，但你可能有一个名为“css”、“clean”或“help”的文件或目录。问题是，如果你运行它，它会寻找文件或目录，并检查“修改时间”，看看是否需要重新构建。

带有`.PHONY`的那一行告诉我们，具有指定名称的目标不是一个文件，并且没有“修改时间”可以检查。它应该总是被认为是“过时的”并运行。而当目标不在时。假冒，使检查的“修改时间”的文件。如果其中一个依赖项比目标更新，则重新构建目标，因为至少有一个依赖项在生成后发生了更改。

为了避免任何问题，通常总是声明`.PHONY`任何不是文件的目标。

然后，目标本身的行告诉您，您想要创建一个名为“css”的目标，它将所有 CSS 文件作为依赖项。这意味着要完成目标，必须创建所有的 CSS 文件。“#”后面的一切都只是注释。

因此，让我们为这些 CSS 文件创建一个目标:

这里发生了很多事情。首先要注意的是，模式替换也适用于目标。它是这样工作的:

```
# Doing this$(CSS_DIR)/%.css: $(SCSS_DIR)/%.scss# Is the same as doing this for every single 
# CSS file in the directory.$(CSS_DIR)/main.css: $(SCSS_DIR)/main.scss
$(CSS_DIR)/resets.css: $(SCSS_DIR)/resets.scss
$(CSS_DIR)/goodies.css: $(SCSS_DIR)/goodies.scss
# ...
```

基本上，你在一行中写了许多规则/任务/目标。

然后我们添加包含文件作为依赖项，因为我们不知道哪个 SCSS 文件使用哪个包含文件。因此，我们需要确保每次修改包含文件时都要重新构建 CSS 文件。这就是目标声明的工作方式。您是说，如果在构建目标之后修改了任何依赖项，那么您希望重新构建目标。

然后是 Sass 命令本身，这是构建目标的“配方”:

```
sass --load-path=$(SCSS_INCLUDES_DIR) --style=compressed --scss $< $@
```

在食谱中，你可以使用已经有的宏，也可以使用一些特殊的宏。宏`$@`是目标名称的占位符，在基于模式声明目标时很有用。宏`$<`是列表中第一个依赖项的占位符。本案中的 SCSS 档案。

我假设您不需要解释命令行参数。如果你有，你可以阅读 [SASS 命令行手册](https://sass-lang.com/documentation/cli)。

注意:我在这里使用的是旧的基于 Ruby 的命令行。请注意，新的实现可能会有所不同。如果您使用不同的命令行参数，请阅读手册以确定命令行参数。

所有这些都工作正常，但是它假设 CSS 文件的目录已经存在。让我们做一些更复杂的事情来确保在目录不存在时创建它。

我们为 CSS 目录本身创建一个目标。它没有依赖关系，因为它不需要任何东西。我们为 CSS 文件创建了一个新的依赖项。现在它需要目录存在。但是这个在“|”管道符号之后。管道符号后的从属关系意味着从属关系只需要存在。我们不需要检查一个“修改时间”。我总是看到这个特性用于目录。

现在，如果你有 SCSS 文件并运行`make css`，你应该看到它为你构建了 CSS 文件。如果您第二次运行它而不更改任何文件，Make 会告诉您一切都是最新的。到目前为止还不错。

请注意，Make 将打印它运行的所有命令。您可以在任何不想打印的命令前添加“@”。通常你不希望在运行之前打印一个`echo`命令，因为它会打印两次。

```
@echo Print only once please
```

# 制作一些 HTML

我个人经常使用只有一个页面的简单设置，因为它是一个单页面应用程序。但是为了这个例子，让我们用 [Markdown](https://www.markdownguide.org/) 文件构建许多 HTML 页面。

这个过程有点类似于我们对 SCSS 文件所做的。但是有一个主要的区别:它们可以在一个嵌套的层次结构中，而不仅仅是一个级别。至少这是我们正在建设的，因为这很有可能。

让我们从顶部的变量开始:

```
MD_FILES = $(shell find $(SRC_DIR) -type f -name '*.md')
HTML_FILES = $(patsubst $(SRC_DIR)/%.md, $(DST_DIR)/%.html, $(MD_FILES))
```

我们不需要子目录，因为 HTML 文件在根目录下。但是我们将使用一个新的宏函数来收集所有的降价文件。`shell`宏函数非常简单，它需要一个 shell 命令来执行。这个程序使用命令`find`获取所有可能嵌套的降价文件的列表。它们可以嵌套的事实是我们这次不使用`wildcard`函数的原因，因为它不支持递归通配符，只支持 Bourne Shell 通配符。

然后我们使用`patsubst`函数得到 HTML 文件的列表，就像我们对 CSS 文件所做的那样。一些目标的时间:

这一切看起来很熟悉，因为过程与 SCSS 的一样，除了没有要创建的目录，我们使用 [Pandoc](https://pandoc.org) 而不是 [Sass](https://sass-lang.com) 。请注意`--standalone`选项。如果你不这样做，Pandoc 将不会创建一个有头和正文的独立的 HTML 文件，而是一个片段。

去试试吧。运行`make html`，它将创建你的 HTML 页面。

很好！现在，让我们为构建所有内容创建一个目标。这很容易。另一个名称及其从属关系:

```
.PHONY: all
all: html css ## Build the whole website
```

现在你可以运行`make all`了，它会构建所有的东西。我个人把这个作为第一目标，这样我就可以运行`make`。如果它不在顶部，您仍然可以将其定义为默认目标，如下所示:

```
.DEFAULT_GOAL := all
```

# 把它弄干净

现在是时候引入一个经典的 Make 目标来删除所有生成的文件并重新开始了:

它只是删除所有的 HTML 文件和整个 CSS 目录。当出现问题时，或者当您希望确保下次运行`make`时一切都将重新构建时，通常会使用这种方法。

# 充分利用 Pandoc

好的，我们有 HTML 文件，但是我们没有充分发挥 Pandoc 的潜力。你想创建带有页眉、页脚和所有内容的网页。让我们对其进行修改，并利用一些 Pandoc 特性:

所以我们在源文件中添加了一个 template.html 文件。这样你就可以遵循你在动态网站上用过的模式。也就是说，每一页都要有一个模板，包括页眉和页脚之间的降价内容。

为了做到这一点，我们使用 Pandoc 的模板语言。至少你将使用`$body$`，它将包含你的降价文件的主体。请注意，我们已经删除了`--standalone`选项，因为我们使用的是模板。

如果你需要更多的变量，你可以根据你想做的事情以多种方式来实现。如果它是特定于构建的或全局的，那么您可以在命令行中使用类似于`--variable today="$(date)"`的选项来传递它。但是如果你的变量是特定于 Markdown 文件的，比如页面的标题，你可以使用元数据。

事实上，如果你看看`--from`选项，不仅仅是“降价”，现在它是一个更长的选项，具有额外的功能。首先，它使用 github 口味的 Markdown。但是也有`yaml_metadata_block`，它允许你包含一个 [YAML](https://yaml.org/) 元数据块，很可能在减价页面的顶部。

```
---
title: The Practice of Programming
authors:
  - Kernighan
  - Pike
---
```

然后所有这些都将在您的模板中可用。我们可以走得更远，有多个模板或包括，等等。但是我相信这足以让您开始并调整这个样板文件以满足您的需要。

更多详情可以阅读 [Pandoc 手册](https://pandoc.org/MANUAL.html)。

# 制作一些网站地图

同样，您可以添加或改进许多东西，但一个明显的特性是创建一个“sitemap.xml”文件和一个“robots.txt”文件。让我们首先在顶部添加一个新变量来设置我们的域名。

```
BASE_URL = "https://www.example.org"
```

然后，我们希望确保在构建“all”目标时构建这些文件。换句话说，我们将把它们添加为依赖项

```
**all**: html css $(DST_DIR)/robots.txt $(DST_DIR)/sitemap.xml
```

机器人的目标应该不难理解。我们只是使用一些“echo”命令来编写文件。我们使用 BASE_URL 变量来添加您的域名。

网站地图稍微复杂一点。在开始和结束的 urlset 标记中，我们遍历所有的 html 文件并添加一个 url 标记。同样，我们将域名放在 BASE_URL 变量中，但问题是我们的 html 文件中有我们需要删除的构建/目标目录名。

首先注意，make 宏和 bash 变量都是以“$”开头的。为了做到这一点，你必须用一个双美元符号代替“$$”，这样 make 就知道它不是一个宏。那么花括号中的内容就是移除前缀的正常 bash 方式。但是这里的前缀是 make 宏/变量。唷…你看过电影《盗梦空间》吗？

# 让它自我记录

作为一个奖励，这里有一个经典的目标，可以获得您想从命令行调用的所有目标的摘要。

它只是扫描 Makefile 中带有双尖号“##”的行，这就是为什么我们的目标后面的所有注释都有 2 个尖号，而不是普通命令的 1 个。然后，当您运行`make help`时，它提取名称和注释以很好地显示它。

这不是我想出来的。这是一个你可以在互联网上找到的巧妙的技巧。

# 让它完整

以下是整个 Makefile 的要点供参考: