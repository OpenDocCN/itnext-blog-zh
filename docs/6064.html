<html>
<head>
<title>I wrote vuex — but for React! The challenges I faced and where you can get it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我写的是vuex——但是对于React！我所面临的挑战以及您可以从哪里获得这些挑战</h1>
<blockquote>原文：<a href="https://itnext.io/i-wrote-vuex-but-for-react-the-challenges-i-faced-and-where-you-can-get-it-d465985d8a5?source=collection_archive---------1-----------------------#2021-08-08">https://itnext.io/i-wrote-vuex-but-for-react-the-challenges-i-faced-and-where-you-can-get-it-d465985d8a5?source=collection_archive---------1-----------------------#2021-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4f24ce7a213db4f7ab9e2889c3c0f951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7DtvnFOCVZh-85-oRJEjuQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">vuex-但是-for-react</figcaption></figure><p id="9e57" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">发布后编辑:</p><blockquote class="la lb lc"><p id="e9fa" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">让我澄清一件可能被误解的事。我知道React还有其他的状态管理库。这篇文章的重点不是假装我是唯一创建这样一个库的人。</p><p id="2ab1" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">重点是让读者知道我在创建一个类似vuex的<em class="iq">用法</em>的库背后的想法和斗争，并解释我如何在每次值更新时使用React的上下文API和不必要的渲染来解决这个问题，同时尽可能地为用户保留样板文件。</p><p id="05f6" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">如果现有的状态管理解决方案非常适合您，并且您没有兴趣尝试任何新的东西，请继续阅读这篇文章，因为它可能不是为您编写的。</p></blockquote><p id="4e9d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi">—</p><p id="23e0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我是一个前端工程师，在Vue.js和React之间左右为难。如果你让我说Vue在哪些方面优于react，我肯定会说全局状态管理选项(和v-model！)，因为<code class="fe lh li lj lk b">vuex</code>已经接近完美了，至少从我的开发者的角度来看是这样的。我在React中使用过几个状态管理库，总是怀念<code class="fe lh li lj lk b">vuex</code>的简单性。</p><p id="a449" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">到目前为止，我认为React状态管理不可能达到同样的效果。不久前，我曾试图编写一个类似的实现，但是我的知识还不够。突然，我有了用我现在所知道的再次尝试的想法。</p><p id="41b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi">—</p><h1 id="9174" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">让我们从配置开始</h1><p id="1385" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">我有一个想法，将一个类似于<code class="fe lh li lj lk b">vuex</code>的配置提供给我的库提供的一个更高级的组件，它会处理所有的逻辑，所以最终用户只需要做很少的工作。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1503" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我还不知道我是否能让它工作，但我知道这是我希望用户编写的初始化类型。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e429" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi">—</p><h1 id="cb28" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">数据之争</h1><p id="7a7d" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">当我传递配置和根组件时，我开始考虑架构。</p><p id="fcd0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">我知道我希望用户使用<em class="ld">一个</em>钩子</strong>来使用getters。</p><p id="1bf4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我还不知道如何提供数据。</p><h2 id="30ec" class="mu lm iq bd ln mv mw dn lr mx my dp lv kn mz na lz kr nb nc md kv nd ne mh nf bi translated">如果我为数据使用一个上下文，每次我们的getters改变时更新它，然后使用一个定制的钩子来访问这个上下文，这是不够的。</h2><p id="da76" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">这是因为所有连接到getter的组件都会因为上下文变化而重新呈现，即使与它们无关。这通常可以通过使用更高阶的组件来解决，消费那里的值，并将子组件包装在<code class="fe lh li lj lk b">memo()</code>中，或者使用类似的解决方案来存储和更新它。</p><p id="f6ac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">在这一点上，用户的实现比仅仅使用一个钩子要困难得多。</strong>我不得不让他们用一个getter把每个组件包装在一个hoc中，这不仅对程序员不友好，而且</p><ul class=""><li id="9f6f" class="ng nh iq ke b kf kg kj kk kn ni kr nj kv nk kz nl nm nn no bi translated">引入不必要的样板文件</li><li id="eea3" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">让React在不必要的时候执行<code class="fe lh li lj lk b">memo()</code>操作(记住，这也要付出代价)</li></ul><h1 id="3499" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">解决方案想法</h1><p id="266c" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">当我处理我知道不会经常改变的值时，我已经知道要拆分上下文，并且我不想重新呈现整个组件树。此时，在花了一些时间思考之后，我知道我想要为每个getter 创建一个<em class="ld">新的上下文和一个提供者。<strong class="ke ir">我知道由</strong> <code class="fe lh li lj lk b"><strong class="ke ir">useGetter()</strong></code> <strong class="ke ir">钩子</strong>(它将在内部使用<code class="fe lh li lj lk b">useContext()</code>)<strong class="ke ir">获得的值</strong> <strong class="ke ir">将保持不变</strong>，假设我们将它连接到它自己的上下文，即使其他getter’提供的值可能已经改变。</em></p><p id="56fb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在的问题是——我能编码吗？我可以创建一个函数，将它的输出包装在一个新的上下文提供者中，直到到达getters的末尾吗？</p><h1 id="6e5c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">怎么做</h1><p id="02e6" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">让我们回到配置。这里有四个区域:<code class="fe lh li lj lk b">state</code>、<code class="fe lh li lj lk b">actions</code>、<code class="fe lh li lj lk b">mutations</code>和<code class="fe lh li lj lk b">getters</code>。</p><p id="f401" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该库正在创建和包装几个上下文:</p><ul class=""><li id="f235" class="ng nh iq ke b kf kg kj kk kn ni kr nj kv nk kz nl nm nn no bi translated">用于<strong class="ke ir">动作</strong>的上下文提供者，包装在<code class="fe lh li lj lk b">memo()</code>中以防止重新创建</li><li id="0c92" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">用于<strong class="ke ir">突变</strong>的上下文提供者，包装在<code class="fe lh li lj lk b">memo()</code>中以防止重新创建</li><li id="b4b1" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">一个用于<strong class="ke ir"> getter上下文</strong>集合的上下文提供者，被包装在<code class="fe lh li lj lk b">memo()</code>中以防止重新创建</li><li id="60e9" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">为<em class="ld">的每个getter</em>动态创建上下文(和提供者)。</li><li id="e9fc" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">在这些上下文中，有提供的<code class="fe lh li lj lk b">App</code>组件，它被包装在<code class="fe lh li lj lk b">memo()</code>中以防止重新创建。</li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/bb68c00194af44b4bc4ef009a2573cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lG2i1Vo2fMayigikrjv3Nw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">动态生成的提供程序</figcaption></figure><p id="e3c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这意味着用<code class="fe lh li lj lk b">useAction()</code>钩子执行一个动作或者用<code class="fe lh li lj lk b">useMutation()</code>钩子执行一个变异会返回一个不能重新创建的函数。</p><p id="f32b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">动作不能访问当前状态(你可以通过突变来改变它),而突变在内部使用React的<code class="fe lh li lj lk b">useState()</code>,它总是为我们提供先前的状态参数。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5f37" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于这一点，我们能够把它们放在组件树的顶层，确信它们被记忆了。</p><p id="2fef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这同样适用于getter上下文的集合。它是一个对象，具有与getter名称相同的键，每个键都有一个存储的上下文实例——没有它的值。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/70dbc254aad660405302aa74939f450e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHLpiBIFqbKIdcTreZ29ZA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">有上下文的提供者？？？</figcaption></figure><p id="3138" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来是动态部分，对于每个getter，您将获得当前返回值，并将其存储在getter的提供程序中。</p><p id="dd96" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lh li lj lk b">withStore()</code> hoc内部存储两种状态:</p><ul class=""><li id="51df" class="ng nh iq ke b kf kg kj kk kn ni kr nj kv nk kz nl nm nn no bi translated">数据的当前状态</li><li id="ac0b" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">当前getter值</li></ul><p id="cb00" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">每次状态更新时，我们运行配置getter函数来确定要更新哪个getter的提供者。</strong></p><p id="0ea8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi">—</p><h1 id="5661" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">魔力</h1><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e518" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是你使用吸气剂的方式。幕后发生的事情是，您访问具有getters上下文集合的上下文，并根据键名选择您的上下文。</p><pre class="mo mp mq mr gt nw lk nx ny aw nz bi"><span id="4a71" class="mu lm iq lk b gy oa ob l oc od">export const <em class="ld">useGetter </em>= (getterName) =&gt; {<br/>  const getters = <em class="ld">useContext</em>(gettersContext);<br/>  const value = <em class="ld">useContext</em>(getters[getterName])<br/><br/>  return value;<br/>}</span></pre><p id="df9c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于这一点，当有两个独立的组件— <code class="fe lh li lj lk b">&lt;Counter /&gt;</code>和<code class="fe lh li lj lk b">&lt;Posts /&gt;</code>并且每个都连接到自己的getter时，当另一个getter更新它的值时，它不会导致其他组件重新呈现。</p><h2 id="a11c" class="mu lm iq bd ln mv mw dn lr mx my dp lv kn mz na lz kr nb nc md kv nd ne mh nf bi translated">没有备忘录。没有高阶元件。简单地消费并仅在变化时呈现。</h2><p id="4532" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi">—</p><h1 id="1b70" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">和其他图书馆有什么区别？</h1><p id="9da5" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">我要说的是，用户为了让这一切正常工作，必须付出多少努力。</p><p id="97a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">config会处理你需要的一切，库会处理剩下的事情。用户实际上只需要3个钩子——<code class="fe lh li lj lk b">useAction</code>、<code class="fe lh li lj lk b">useMutation</code>和<code class="fe lh li lj lk b">useGetter</code>，同时由于库和上下文是如何设计的，保护了他们的组件免于不必要的渲染。</p><p id="c8d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它也是轻量级的——它唯一的依赖项是<code class="fe lh li lj lk b">react</code>、<code class="fe lh li lj lk b">@types/react</code>和<code class="fe lh li lj lk b">typescript</code>。您获得了对异步操作的本机支持，因此无需添加任何其他内容。</p><p id="8778" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi">—</p><h1 id="49e1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用</h1><p id="a92c" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated"><code class="fe lh li lj lk b">yarn add vuex-but-for-react</code>或<code class="fe lh li lj lk b">npm install vuex-but-for-react --save</code></p><p id="98bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在这里观看快速编码视频:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="oe mt l"/></div></figure><p id="e173" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你对更深一步感兴趣，你可以在我的GitHub中找到源代码和例子:<a class="ae of" href="https://github.com/DJanoskova/vuex-but-for-react" rel="noopener ugc nofollow" target="_blank">https://github.com/DJanoskova/vuex-but-for-react</a></p><p id="44ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi">—</p><p id="6511" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我以这样一句话来结束这篇文章:编写这个库是一种乐趣，我希望你使用它也是一种乐趣——我知道我会的！</p><p id="a6ac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在将库发布到NPM时，我发现这篇文章非常有帮助:<a class="ae of" href="https://prateeksurana.me/blog/react-library-with-typescript/" rel="noopener ugc nofollow" target="_blank">https://prateeksurana . me/blog/react-library-with-typescript/</a></p><p id="550b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢您的阅读，祝您编码愉快！</p></div></div>    
</body>
</html>