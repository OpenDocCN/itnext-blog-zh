<html>
<head>
<title>Converting Ultimate++ framework to Meson build system to make it externally consumable by others</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Ultimate++框架转换为介子构建系统，使其可供其他人外部使用</h1>
<blockquote>原文：<a href="https://itnext.io/converting-ultimate-framework-to-meson-build-system-to-make-it-externally-consumable-by-others-99b54bc25598?source=collection_archive---------2-----------------------#2022-07-18">https://itnext.io/converting-ultimate-framework-to-meson-build-system-to-make-it-externally-consumable-by-others-99b54bc25598?source=collection_archive---------2-----------------------#2022-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5b7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好，</p><p id="02bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很长时间以来，我一直在关注<a class="ae kl" href="https://www.ultimatepp.org/" rel="noopener ugc nofollow" target="_blank"> Ultimate++ framework </a>。</p><p id="1ed8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Ultimate++是一个框架，包括一个GUI和它自己的IDE，称为<em class="km">IDE</em>，允许你为主要的操作系统(Linux，Windows，MacOS)创建完整的多平台应用程序。对我来说，它是最受欢迎的框架之一。</p><p id="e7cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">IdE 包含了许多有助于提高工作效率的东西，从代码辅助到帮助、调试器和GUI RAD工具。</p><p id="8321" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它可以制作如下所示的复杂应用程序，有数据库连接API，包括OpenGL嵌入和所有可用的花哨东西。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/77144d2c680cdde8b2b26906baca9c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EaSCLdDtR1tMAEnkYG89g.png"/></div></div></figure><p id="6b60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，使Ultimate++脱颖而出的是，它使用C++的方式使编码风格非常高效:GUI RAD工具发出可以嵌入的常规C++，小部件只是具有正常范围的普通对象，它有助于非常直观的用户体验。SQL和其他图像嵌入使用完全相同的策略。最终，代码中的所有内容都是直接从RAD工具中嵌入的。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kz"><img src="../Images/1a2e7c44c103711bb7e8147d06ab667a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MaVf7fxzOW533Z7osC_L-g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Ultimate++中的Ide RAD工具</figcaption></figure><p id="98dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以通过查看它的应用页面<a class="ae kl" href="https://www.ultimatepp.org/www$uppweb$apps$en-us.html" rel="noopener ugc nofollow" target="_blank">这里</a>来了解这个框架允许的复杂程度。</p><h1 id="c0e2" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Ultimate++有什么问题？我想…</h1><p id="e889" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我渴望使用Ultimate++已经有一段时间了，但我一直被一个问题困扰着:你必须使用他们的IDE，所有的东西都以他们自己的方式打包。这给我的工作流程带来了很多摩擦，我猜对其他人来说也是如此。</p><p id="4071" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你做的所有工作都落入他们自己的环境。我并不反对他们的环境，但是这个包生成了一个他们自己的定制包系统，使它成为自己的工作领域。</p><p id="6d18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这与当今的其他构建系统并不兼容，例如CMake/Meson/PreMake和其他正在使用的构建系统，例如MsBuild、XCode等。</p><h1 id="9458" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">解决图书馆的消费问题(以及其他免费的东西)</h1><p id="8973" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我想知道如何解决包装消费的问题。我本可以添加一些<code class="fe mh mi mj mk b">.pc</code>文件到里面，然后就完事了。但我认为这还不够。</p><p id="93b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我非常熟悉Meson(实际上还有CMake)，我尝试了一下将Ultimate++转换成使用Meson需要多少时间。</p><p id="b5d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我转换它的时候，我可以得到一些额外的好处:</p><ul class=""><li id="7ed2" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">以多种模式编译:调试、发布、ASAN、静态/动态链接等。</li><li id="21ab" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated"><strong class="jp ir">建立Windows、Linux和Mac之间的系统统一</strong></li><li id="2a68" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">从其他操作系统交叉编译环境</li><li id="aefd" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated"><strong class="jp ir">发出pkg-config和。cmake文件供其库使用</strong></li><li id="31c4" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">使项目外部的协作更加容易</li><li id="62fa" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">一些嵌入的定制<strong class="jp ir">依赖可以被提取出来，透明地使用介子包裹/柯南依赖或者系统依赖</strong>。也就是说，由用户而不是由构建系统作者规定的正确的外部依赖项使用</li></ul><h1 id="c1a8" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将终极++转化为介子</h1><p id="4296" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我需要一个策略来开始。我决定在稳定的2022.2标签上进行转换。</p><p id="0572" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我看了一下<a class="ae kl" href="https://raw.githubusercontent.com/ultimatepp/ultimatepp/2022.2/Makefile" rel="noopener ugc nofollow" target="_blank">单个的单片Makefile </a>，它可以编译所有需要的东西。这个Makefile似乎编译了足够多的内容来构建【TheIDE。我做的第一件事是拿出我的Linux笔记本电脑，从那里开始。</p><p id="e15c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用原始构建系统进行编译，以便能够计算出输出并检查生成的库。我做了一些grepping来提取源文件，并为这个项目创建了一个顶级的介子文件。</p><p id="9f02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我希望介子转换也能在Windows和Mac上编译，所以依赖处理非常关键。我决定提取内部打包的依赖项，将它们指向构建系统，构建系统的用户可以透明地选择使用什么，无论是Ubuntu库、Meson wraps还是Conan下载的包。当我进行转换时，这对于能够在Windows中编译东西是很重要的，也提高了模块性。它还可以指向相同的依赖项。例如，如果某个包使用zlib，而另一个完全不同的依赖项使用zlib，您可以协调它，使它们指向相同的版本。</p><p id="b286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向介子的转换仍在进行中，但它已经在Linux中的静态库构建设置下工作了。它成功地编译了大量的库+<em class="km">ide</em>，并且可以在Ubuntu Linux 19.04下正确运行。</p><h1 id="97c2" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">是什么把它转化成介子的</h1><p id="4cd0" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">基本上，转换是相对简单的，我对依赖性处理的深思熟虑以及它与命令行的良好结合印象深刻。您可以使用系统依赖项，避免下载它们，即使安装了系统依赖项，也可以回退到子项目依赖项，逐个覆盖它们。</p><p id="e596" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了在Ultimate++框架中包含一些依赖项的方式上有一些问题之外，一切都很好。</p><p id="764e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我做了什么:</p><ul class=""><li id="089a" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">静态编译<em class="km">ide</em>并通过pkg-config公开所有依赖项(库)。仍然需要添加对从Meson生成的pkg配置的调用，但这是一行程序，与添加用于消费的<code class="fe mh mi mj mk b">.cmake</code>包相同</li><li id="88de" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">我提取并使用了最初嵌入在源代码中的包管理依赖项:liblzma、lzma sdk、zlib、xxhash、libpng、zstd和pcre。这些现在可以被构建系统中的介子逻辑检测到，并且可以根据用户的偏好被覆盖</li></ul></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="0d09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">项目声明和配置文件生成的处理如下所示:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8496" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这有几个作用。首先，它检测日期，主机名和whoami程序。之后，它运行一些命令来收集信息。它创建一个数据配置对象，并发出相应的配置文件。请注意，您不一定需要输入文件(但是您可以这样做并替换您自己的变量。在文件中)。文件将直接从配置中发出。当我使用windows时，我会找出使用什么程序来完成相同的任务，如果情况变得糟糕，我可以随时使用python脚本作为多平台程序。</p><h1 id="d882" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">图书馆汇编</h1><p id="a0da" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">基本上所有的库都是按照下面的模式编译的，并通过<code class="fe mh mi mj mk b">subdir</code>调用遍历目录结构:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4781" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些插件有一些外部依赖。而在这里介子可以帮上大忙。看看这个例子:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="176b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">zlib、liblzma和lzmasdk最初是嵌入式依赖项，在repo内部编译了自定义源代码。包含指向内部目录。</p><p id="6f31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在他们只是使用介子逻辑来检测依赖性。这意味着它们可能来自系统，来自另一个包管理器，比如Conan，或者来自一个包装器，并且和你的代码一起被编译。这是非常灵活的，使你的生活，尤其是在Windows中，变得更好。</p><p id="bf3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">介子是如何工作的，我必须做些什么来处理依赖性？</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="8d9b" class="le lf iq bd lg lh ni lj lk ll nj ln lo lp nk lr ls lt nl lv lw lx nm lz ma mb bi translated">介子包裹拯救</h1><p id="65d1" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated"><a class="ae kl" href="https://mesonbuild.com/Wrap-dependency-system-manual.html" rel="noopener ugc nofollow" target="_blank"> <em class="km">包裹</em> </a>是介子使用的包管理系统。这个想法是，你可以把<code class="fe mh mi mj mk b">yoursubproject.wrap</code>文件放在你的<code class="fe mh mi mj mk b">subprojects</code>目录中，然后介子会处理剩下的。这里有一些现成的包装供你选择。包裹可用的条件是包裹支持介子构建系统。由于大多数包不支持，因此有办法提供相应的补丁来添加介子支持，并从包装文件中指向这些补丁文件，这些文件将在下载/解包您的项目源代码后应用。在包装的情况下，子项目中的所有包都将从源代码与您的项目一起编译。</p><p id="b2ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Meson中，你应该展平所有的依赖项，使它们可见，因为在不同的子项目中，不同版本的依赖项嵌套在一起会导致各种各样的问题。如果您对两个子项目有一些依赖关系，它们应该都指向同一个版本(依赖关系(' somedep ')将自动为所有流程指向同一个依赖关系)。这避免了令人厌恶的错误，如意外违反ODR。</p><p id="f922" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文件可以来自档案库，来自<em class="km"> git </em>，<em class="km"> svn </em>，<em class="km"> hg </em>或者可以指向一个本地目录。支持修补文件。这很方便，因为大多数项目不提供介子构建系统。你可以在它们上面覆盖一层或几片。<code class="fe mh mi mj mk b">patch_*</code>文件实际上是覆盖图。对于真正的补丁文件，在你的<code class="fe mh mi mj mk b">.wrap</code>文件中使用<code class="fe mh mi mj mk b">diff_files</code>指令。</p><p id="629e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包装将下载，如果必要的话，提取，应用补丁/覆盖和编译依赖，虽然有开关，以避免下载和其他。</p><p id="93a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果您已经在系统中安装了那些依赖项，您可以使用<code class="fe mh mi mj mk b">--force-fallback=libpng,zstd</code>强制Meson使用选定的子项目依赖项，而不是系统依赖项。</p><p id="1655" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该系统是非常可定制的。</p><p id="31ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于liblzma，有一个可用的包装:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="bc84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个想法是你把。将文件包装在子项目目录中。在此之后，如果没有检测到系统依赖项，将默认使用这些选项。</p><p id="c42d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">liblzma</code>包装文件基本上说明了从哪里下载原始归档文件、覆盖文件(patch_url)以及它提供的依赖关系。如果在系统中找不到<code class="fe mh mi mj mk b">liblzma</code>，这个<code class="fe mh mi mj mk b">.wrap</code>文件将提供<code class="fe mh mi mj mk b">dependency('liblzma')</code>，并继续将它与您的项目一起编译。这由<code class="fe mh mi mj mk b">[provide]</code>部分指示。上面包装中的<code class="fe mh mi mj mk b">[provide]</code>部分列出了<code class="fe mh mi mj mk b">meson.build</code>文件中依赖变量的内部名称，以及调用<code class="fe mh mi mj mk b">dependency</code>时它映射到的名称。如果您有一些想要检测的可执行文件，您也可以提供<code class="fe mh mi mj mk b">program_names</code>。注意这只是一个过渡机制，更新的方法是从你的<code class="fe mh mi mj mk b">meson.build</code>文件中调用<code class="fe mh mi mj mk b">meson.override_dependency('depname', lib_dep)</code>。</p><p id="17e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果需要，你也可以用语法<code class="fe mh mi mj mk b">-Dmyproject:option=value</code>单独设置一些子项目选项，如果事情变得更复杂，也可以在<a class="ae kl" href="https://mesonbuild.com/Native-environments.html" rel="noopener ugc nofollow" target="_blank">机器文件</a>中设置。</p><p id="15d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe mh mi mj mk b">lzmasdk</code>,我就没那么幸运了，因为没有可用的包装文件:我从他们的网站下载文件，将它们解压到一个目录中，将几个<code class="fe mh mi mj mk b">meson.build</code>添加到包装文件指向的目录中，并将相应的包装文件添加到我的子项目中，以模仿已经嵌入到<code class="fe mh mi mj mk b">plugin/lib/</code>目录中的文件，该目录包含直接嵌入到构建系统中的<code class="fe mh mi mj mk b">lzmasdk</code>。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8acd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意现在在<code class="fe mh mi mj mk b">[provide]</code>部分的不同之处:我使用了依赖项的名称，而没有命名任何内部的<code class="fe mh mi mj mk b">meson.build</code>变量。这是因为在内部构建系统中使用了它<code class="fe mh mi mj mk b">meson.override_dependency('liblzmasdk', liblzmasdk_dep)</code>，介子会找到它。你可以对<code class="fe mh mi mj mk b">program_names</code>做同样的事情</p><p id="04fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些基本上是我为每个目录将Ultimate++转换成Meson构建系统所遵循的步骤。</p><p id="3339" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译时还有一些其他的注意事项。例如，缺省情况下，Meson包括目标的源目录和构建目录。这引发了一些<code class="fe mh mi mj mk b">#include</code>冲突，因为Ultimate++中的include被精确地命名为它们的库，例如`#include &lt; png.h &gt;`,它指向它们自己的内部<code class="fe mh mi mj mk b">png</code>,在那里进行编译。解决方案是用于碰撞的目标<code class="fe mh mi mj mk b">implicit_include_directories: false</code>去除意外夹杂物。</p><p id="b9a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，Meson能做的远不止这些，比如交叉编译，当你通过许多命令支持的<code class="fe mh mi mj mk b">native:bool</code>标志来编译一个要被<code class="fe mh mi mj mk b">host</code>或<code class="fe mh mi mj mk b">build</code>机器使用的程序时，这是非常清楚的。你可以只在一个环境中添加标志，而不会弄不清它会出现在哪里，语法几乎是Python化的，非常直观。</p><p id="03e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还有诸如<a class="ae kl" href="https://mesonbuild.com/Build-options.html#features" rel="noopener ugc nofollow" target="_blank">特性对象</a>和<a class="ae kl" href="https://mesonbuild.com/Disabler.html" rel="noopener ugc nofollow" target="_blank">禁用器</a>之类的东西，可以大大减少条件样板文件。例如，您可以通过使用禁用器来简化依赖于未检测到的依赖项的所有依赖项的构建，而无需更改构建代码的任何其他部分。</p><h1 id="5ab5" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">后续步骤</h1><p id="c620" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">接下来的步骤是:</p><ul class=""><li id="e380" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">让介子构建系统在Windows下工作</li><li id="b86c" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">让介子构建系统在Linux下工作</li><li id="080f" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">添加<code class="fe mh mi mj mk b">.pc</code>和<code class="fe mh mi mj mk b">.cmake</code>文件直接从介子中消耗</li><li id="c48c" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">创建一个从介子构建系统编译的柯南配方，这样就可以使用更多的生成器</li></ul><p id="0a94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还将明确区分公共依赖和私有依赖。仍然在计算它们是否排列正确，肯定有一些错误。</p><h1 id="8e8b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">最后的话</h1><p id="c574" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我花了大约8-9个小时完成全部转换，直到能够运行<code class="fe mh mi mj mk b">TheIde</code>并找出所有依赖项，等等。</p><p id="d3a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Linux已经编译的正在进行的工作可以在<a class="ae kl" href="https://github.com/germandiagogomez/ultimatepp/tree/feature/meson-build-system-based-on-2022.2" rel="noopener ugc nofollow" target="_blank">这里</a>找到。请注意，这是实验性的，它可能会在您的机器上失败，因为它没有经过彻底的测试。</p><p id="5178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很抱歉有任何打字错误/糟糕的写作，我匆忙写了这篇文章，只是为了能够揭露它，以防有人觉得它有趣/有用。</p><p id="0581" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！</p><p id="ab11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:请注意，除了对构建系统的改进感兴趣之外，我与Ultimate++项目没有任何关系，这里显示的所有内容都是出于我自己的兴趣，而不是其他。</p></div></div>    
</body>
</html>