<html>
<head>
<title>Modern C++ in Advent of Code: Day21</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++代码的出现:第21天</h1>
<blockquote>原文：<a href="https://itnext.io/modern-c-in-advent-of-code-day21-237edcc5034e?source=collection_archive---------2-----------------------#2021-12-21">https://itnext.io/modern-c-in-advent-of-code-day21-237edcc5034e?source=collection_archive---------2-----------------------#2021-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="eef8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是代码问世的第二十一天。今天，我们将模拟一个骰子游戏。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/24e28e272a47fdb39cd9ded1f8571252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNiO3eOKZi2e6YFu8ssciQ.png"/></div></div></figure><p id="6fa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，请先尝试解决问题，然后再看解决方案。对于这个系列的所有文章，<a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">看看这个列表</a>。</p><h1 id="d0ad" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第21天</h1><p id="f4a7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">对于第一部分，我们得到一个非常简单的任务。我们正在模拟一个骰子游戏:</p><ul class=""><li id="a4b3" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">棋盘上有十个空格和圆圈</li><li id="d029" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">每个玩家掷出三个骰子(或者，在我们的例子中，一个骰子掷三次)，然后移动掷出的空格总数</li><li id="b1d3" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">移动后，玩家分数增加空间的值(1..10)</li><li id="db5b" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">第一个达到1000分的玩家获胜</li></ul><p id="2ca0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到一个确定性的100面骰子，它将滚动单调递增的数字(从1开始)。我们的任务是确定赢家，并报告输家的分数和游戏掷骰子的次数。</p><p id="c1a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们正确地模拟这个游戏，为此，我们需要一个骰子:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5f76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现骰子有很多种方法。例如，一个生成器协程或<code class="fe mr ms mt mu b">std::ranges::views::iota</code>。然而，因为我们只有一个骰子，所以一个简单的静态函数将在这里工作。</p><p id="07ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了模拟游戏，我们进行迭代，直到达到获胜条件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="fbc0" class="mv kz iq bd la mw mx dn le my mz dp li jy na nb lm kc nc nd lq kg ne nf lu ng bi translated">多元宇宙</h2><p id="fac7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">对于问题的第二部分，我们得到了一个三面骰子，它在每一卷上将宇宙分成三个多元宇宙。给定他们的开始状态，我们必须计算两个玩家赢的宇宙的数量。</p><p id="f681" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们想一想，当我们掷出三次这个特殊的骰子时，会发生什么。掷骰子有27种可能的组合。但是，总和只会在3到9之间。因此，我们达到相同总和的宇宙将无法区分。</p><p id="ad35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们如何计算宇宙的数量呢？我们可以通过对所有可达到的状态求和来递归计算任何特定状态的宇宙数量，直到我们达到一个终止条件(其中一个玩家的分数为21或更多)。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6d06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种解决方案是可行的，但是非常慢。这是因为当我们在递归展开中通过不同的路径到达相同的状态时，我们不断地重新计算相同的状态很多次。但是，我们可以通过添加缓存来避免这种情况。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e95a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们利用对称性稍微简化了缓存，这允许我们不在缓存中存储“当前玩家”标志(并使计算更快)。但是，在使用player2(第45行和第69行)时，我们需要小心反转数据。</p><h1 id="f371" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">链接和技术说明</h1><p id="bfe0" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">每日解决方案存储库位于:<a class="ae kl" href="https://github.com/HappyCerberus/moderncpp-aoc-2021" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/moderncpp-aoc-2021</a>。</p><p id="8e9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看此列表，了解《代码降临日》的其他相关文章。</p><p id="8f2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请不要忘记亲自尝试一下<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">代码</a>的问世。</p><h1 id="0f72" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="49bd" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="9301" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还在T4的YouTube上发布视频。你有问题吗？在Twitter或LinkedIn上联系我。</p></div></div>    
</body>
</html>