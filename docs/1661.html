<html>
<head>
<title>Entity Framework Core: String Filter Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体框架核心:字符串过滤器提示</h1>
<blockquote>原文：<a href="https://itnext.io/entity-framework-core-string-filter-tips-768139b55ffd?source=collection_archive---------0-----------------------#2018-12-23">https://itnext.io/entity-framework-core-string-filter-tips-768139b55ffd?source=collection_archive---------0-----------------------#2018-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我一直在使用SQLite开发一个由Entity Framework Core支持的应用程序，在处理字符串过滤器时，我遇到了一些最初并不太清楚的事情。这篇文章将介绍如何设置一个示例应用程序，并演示在过滤器中使用字符串时需要记住的一些事情。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b31a0871e0ac1757cdaf75ab40e1fc2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sgrwu6Xj-R5wk0GnZg6IeA.png"/></div></div></figure><h2 id="4478" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">示例应用程序</h2><p id="e595" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">我使用带有个人身份验证的Razor Pages模板作为这个示例的基础，因为它附带的实体框架核心已经设置好并准备就绪。在希望创建示例项目的目录中，使用命令提示符运行以下命令。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="2142" class="kx ky iq lw b gy ma mb l mc md">dotnet new razor --auth Individual</span></pre><p id="bd9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您选择的编辑器中打开结果项目，并添加一个<strong class="jp ir"> Models </strong>文件夹。像往常一样，我将使用一个联系人作为我的示例，因此在Models文件夹中创建一个与以下内容匹配的<strong class="jp ir">联系人</strong>类。在<strong class="jp ir"> ToString </strong>上的覆盖只是为了在调试时容易看到结果。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="12c6" class="kx ky iq lw b gy ma mb l mc md">public class Contact<br/>{<br/>    public int Id { get; set; }<br/>    public string FirstName { get; set; }<br/>    public string LastName { get; set; }<br/>    public string Address { get; set; }<br/>    public string City { get; set; }<br/>    public string State { get; set; }<br/>    public string Zip { get; set; }<br/><br/>    public override string ToString()<br/>    {<br/>        return $"{Id} - {LastName}, {FirstName}";<br/>    }<br/>}</span></pre><p id="560c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，打开在<strong class="jp ir"> Data </strong>文件夹中找到的<strong class="jp ir"> ApplicationDbContext </strong>，并添加下面的<strong class="jp ir"> DbSet </strong>属性来公开我们的联系人。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="91d7" class="kx ky iq lw b gy ma mb l mc md">public DbSet&lt;Contact&gt; Contacts { get; set; }</span></pre><p id="6327" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将下面的<strong class="jp ir"> OnModelCreating </strong>函数添加到<strong class="jp ir"> ApplicationDbContext </strong>中，这将为我们创建一些测试数据。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="268c" class="kx ky iq lw b gy ma mb l mc md">protected override void OnModelCreating(ModelBuilder builder)<br/>{<br/>    builder.Entity&lt;Contact&gt;()<br/>           .HasData(new Contact<br/>                    {<br/>                        Id = 1,<br/>                        FirstName = "Bob",<br/>                        LastName = "Smith",<br/>                        Address = "123 Main Street",<br/>                        City = "Nashville",<br/>                        State = "TN",<br/>                        Zip = "35970"<br/>                    },<br/>                    new Contact<br/>                    {<br/>                        Id = 2,<br/>                        FirstName = "Sam",<br/>                        LastName = "Smith",<br/>                        Address = "1 Sun Lane",<br/>                        City = "Knoxville",<br/>                        State = "TN",<br/>                        Zip = "48909"<br/>                    },<br/>                    new Contact<br/>                    {<br/>                        Id = 3,<br/>                        FirstName = "Clark",<br/>                        LastName = "Swift",<br/>                        Address = "750 10th Street",<br/>                        City = "Chattanooga",<br/>                        State = "TN",<br/>                        Zip = "91590"<br/>                    }<br/>                   );<br/><br/>    base.OnModelCreating(builder);<br/>}</span></pre><p id="e3e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到命令提示符，在与<strong class="jp ir"> csproj </strong>文件相同的目录中运行以下命令，为我们的新联系模型创建一个迁移。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="64e2" class="kx ky iq lw b gy ma mb l mc md">dotnet ef migrations add Contacts</span></pre><p id="c551" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，运行以下命令将迁移应用到您的数据库。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="ca23" class="kx ky iq lw b gy ma mb l mc md">dotnet ef database update</span></pre><h2 id="dfb9" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">数据执行</h2><p id="d0a9" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">对于这个例子，我并不在乎在UI中显示结果，所以我使用了<strong class="jp ir">索引</strong>页面的<strong class="jp ir"> OnGetAsync </strong>来运行我的查询。下面是我的完整索引页面模型，带有一个返回所有联系人的查询。这篇文章的其余部分将只是展示查询数据库的LINQ语句，而不是整个页面模型。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="f1ee" class="kx ky iq lw b gy ma mb l mc md">public class IndexModel : PageModel<br/>{<br/>    private readonly ApplicationDbContext _context;<br/><br/>    public IndexModel(ApplicationDbContext context)<br/>    {<br/>        _context = context;<br/>    }<br/><br/>    public async Task&lt;IActionResult&gt; OnGetAsync()<br/>    {<br/>        var contacts = await _context.Contacts.ToListAsync();<br/><br/>        return Page();<br/>    }<br/>}</span></pre><p id="e0af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上结果导致所有植入的联系人都被退回。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="edaf" class="kx ky iq lw b gy ma mb l mc md">1 - Smith, Bob<br/>2 - Smith, Sam<br/>3 - Swit, Clark</span></pre><h2 id="ff86" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">喜欢的查询</h2><p id="0eb4" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">作为实体框架核心2.0版本的一部分。增加了像这样的函数，它允许使用通配符，而使用字符串函数翻译是不可能的，字符串函数翻译是以前唯一的选择。这个StackOverflow问题的答案很好地概述了好处。以下查询是使用like的示例。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="79f5" class="kx ky iq lw b gy ma mb l mc md">_context.Contacts<br/>        .Where(c =&gt; EF.Functions.Like(c.LastName, "S_i%"))<br/>        .ToListAsync();</span></pre><p id="23d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这在以前是可能的，但我认为查询会很糟糕，并且涉及到某种程度的客户端评估。查询的结果与上面相同。</p><h2 id="8bcf" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">大于/小于</h2><p id="bc98" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">使用<strong class="jp ir">字符串。比较</strong>或<strong class="jp ir">值。CompareTo </strong>将允许你对字符串进行大于或小于比较。比如说<strong class="jp ir">弦。比较(值)&gt; 0 </strong>给你一个大于和小于零的会为小于。例如，下面是一个字符串比较查询以及生成的SQL。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="c3c3" class="kx ky iq lw b gy ma mb l mc md">_context.Contacts<br/>        .Where(c =&gt; String.Compare(c.FirstName, "D") &gt; 0 )<br/>        .ToListAsync();<br/><br/>SELECT [c].[Id], [c].[Address], [c].[City], [c].[FirstName], [c].[LastName], [c].[State], [c].[Zip]<br/>FROM [Contacts] AS [c]<br/>WHERE [c].[FirstName] &gt; N'D'</span></pre><p id="9355" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的是不要尝试使用<strong class="jp ir">字符串的任何重载。比较</strong>,否则您将结束客户端对查询的评估。下面是一个使用重载之一和生成的SQL的查询。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="7c6d" class="kx ky iq lw b gy ma mb l mc md">_context.Contacts<br/>        .Where(c =&gt; String.Compare(c.FirstName, "D", StringComparison.Ordinal) &gt; 0)<br/>        .ToListAsync();<br/><br/>SELECT [c].[Id], [c].[Address], [c].[City], [c].[FirstName], [c].[LastName], [c].[State], [c].[Zip]<br/>FROM [Contacts] AS [c]</span></pre><p id="952f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，第一个查询有一个<strong class="jp ir"> Where </strong>子句，而第二个没有。这意味着第二个查询会将所有记录提取到客户端，然后应用过滤器。虽然这对于少量数据来说没有问题，但是对于在客户端进行评估的查询，请小心，因为它们可能会导致性能问题。</p><p id="cf8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上两个查询都返回以下结果。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="674a" class="kx ky iq lw b gy ma mb l mc md">2 - Smith, Sam</span></pre><h2 id="0128" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">包扎</h2><p id="d49f" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">这是对我提醒最多的帖子之一。我真的希望这能为你节省一些时间，让你明白实体框架核心是如何处理字符串的。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><p id="3ac3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ml">最初发表于</em> <a class="ae mm" href="https://elanderson.net/2018/12/entity-framework-core-string-filter-tips/" rel="noopener ugc nofollow" target="_blank"> <em class="ml">埃里克·安德森</em> </a> <em class="ml">。</em></p></div></div>    
</body>
</html>