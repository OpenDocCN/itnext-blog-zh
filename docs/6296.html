<html>
<head>
<title>Design Pattern: Federated Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:联邦客户端</h1>
<blockquote>原文：<a href="https://itnext.io/design-pattern-federated-client-91fce307db9c?source=collection_archive---------4-----------------------#2021-10-11">https://itnext.io/design-pattern-federated-client-91fce307db9c?source=collection_archive---------4-----------------------#2021-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="af02" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">模块联合设计模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a8a9b294b92ac4911c4590d06bc06478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3TAX9JTroSEk8flZy_Z8A.jpeg"/></div></div></figure><p id="966d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是关于模块联合设计模式的系列文章的第一部分。由于MF是一种新技术，还没有被很好地理解，这些模式可能有助于增加清晰度和刺激创新。</p><p id="5773" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前，MF是基于Javascript的，因此，<em class="ln">一些</em>模式只能在Javascript中实现，而其他模式是语言不可知的；但是在每一种情况下，模式本身，以及一般的MF，都可以从它的实现中分离出来考虑。因为我关注的是MF对服务器的应用，所以有些模式只适用于后端，有些是同构的。我会在每篇文章的开头强调这些品质。</p><p id="a47a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">联邦客户机</em>模式是同构的。它可以在浏览器或服务器上运行。这种模式做两件事:</p><ul class=""><li id="6ca0" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">封装集成逻辑</li><li id="01d6" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">防止重大变更</li></ul><p id="47d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您导入一个远程模块时，MF会确定该模块的依赖项，并将这些依赖项一起导入。在大多数情况下，导入远程模块并在本地调用它是一种有效的解决方案。但是，在其他情况下，该模块可能需要访问从您的位置无法访问的网络，或者它可能有太多的依赖项，因此导入不切实际。</p><p id="36eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，服务可以公布一个联邦包装器模块，该模块封装了一个API客户机并导出映射到它的函数。就导入这个模块的app而言，它只是进行本地的、进程内的函数调用。该模块包括用于将导出函数的自变量转换成通过网络传输的串行化有效载荷的逻辑。服务器可以动态地改变这个逻辑，将消费应用程序与负载格式或客户端本身的破坏性变化隔离开来。</p><p id="1627" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于服务提供商可以加载新的依赖关系并动态更新转换逻辑，因此不仅可以在几分钟内完成过去需要几个月才能完成的工作，还可以完成没有应用程序所有者参与的情况下不可能完成的工作(至少可以安排停机时间)，例如添加断路器、将客户端重新实现为WebAssembly模块或将传输协议从TCP切换到UDP。</p><p id="261d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个系列中寻找更多的模式。欢迎评论和提问。</p></div></div>    
</body>
</html>