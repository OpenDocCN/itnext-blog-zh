<html>
<head>
<title>A new approach to React Native development and team composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种反应本地开发和团队组成的新方法</h1>
<blockquote>原文：<a href="https://itnext.io/a-new-approach-to-react-native-development-and-team-composition-d6e3e3eb5184?source=collection_archive---------3-----------------------#2022-07-04">https://itnext.io/a-new-approach-to-react-native-development-and-team-composition-d6e3e3eb5184?source=collection_archive---------3-----------------------#2022-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="392c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将了解如何通过采用一种新的<em class="kl">双回购</em>方法来进行React Native开发，我们能够提高团队效率，并且还打开了许多其他选项的大门，这些选项之前由于React Native独特的三域性质而无法实现。</p><p id="e5f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新方法本身实现起来相对简单，因为大部分工作是将原生<code class="fe km kn ko kp b">/android</code>和<code class="fe km kn ko kp b">/ios</code>文件夹移动到项目的文件夹层次结构中更深的三层，这一微小变化的结果是<strong class="jp ir">能够在React Native中将React(JS)和原生(Android、iOS、builds)域分开，方法是将传统的单个交叉关注RN repo分成两个，一个repo用于原生部分，另一个用于JavaScript部分。</strong>正如我们将在本文中看到的，这一变化为各种规模的react-native项目带来了许多有益的好处。</p><h1 id="9de2" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">这种新的应用程序开发方法的起源</strong></h1><p id="a177" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">不久前，Wix Engineering <a class="ae lt" href="https://medium.com/wix-engineering/react-native-at-wix-the-architecture-ii-deep-dive-9cfcb3c2822c" rel="noopener">分享了他们的React原生应用架构的一瞥</a>，以提高他们由50多名React原生开发人员组成的大型团队的开发效率。虽然他们的原始文章从一个非常大的项目的角度(1%的RN项目)来看开发问题，但是在深入挖掘内部之后，我很快意识到，有些部分甚至可以被利用来有益于较小的开发团队(也就是我们——也就是99%)。</p><p id="40a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了验证我的假设，我决定在Wix的另一端测试这个新想法，通过在一个只有一个开发人员的React本地项目中完全实现它，最终结果令人惊讶地积极。</p><h1 id="8c2b" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">本文是两篇</strong>文章的第一部分</h1><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/278955eb3e3d06419730e4dd602b2fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKg-6ClXuYGfJn3PwJdZ5g.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">我们的变化是低水平的，因为我们是分裂成2个回购代码库！</figcaption></figure><p id="8871" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为<em class="kl">两次回购</em>方法的核心变更非常接近我们软件设计决策的基础水平，所以它影响了随后的许多叶子决策。为了解释这种新方法而不至于让每个人都感到信息过载，我决定把它分成两部分。在第一部分中，我们将主要从高层次的角度来看影响，这样我们就可以检查应用这一点来反应本地开发的各种<a class="ae lt" href="https://www.weskao.com/blog/second-and-third-order-consequences" rel="noopener ugc nofollow" target="_blank">二阶和三阶结果</a>。你可以认为第一部分是“什么和为什么”，而在未来的第二部分，我们将讨论“如何做X，Y，Z ”,我们将深入研究所有技术细节，从功能开发到使用<em class="kl">二次回复</em>设置在应用商店上线。</p><p id="fa56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些想在第二部分之前体验一下的人来说，在本文的最后，您会找到一个小的演示回购供您试用。</p><h1 id="37e8" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">新方法的30000英尺视角</h1><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi mk"><img src="../Images/9e51bc44befbe9e59f4e3a271b10306c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yUHsOeSnZXDWay4OE4w8w.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">一个交叉关注回购与两个专业回购</figcaption></figure><p id="4e3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前，最广泛采用的React本地项目结构与您第一次初始化RN应用程序时获得的默认项目设置有些不同。它基本上是一个包含React Native所有三个领域的单一回购:Android、iOS和JavaScript。我们的新方法通过拆分<strong class="jp ir"> <em class="kl"> React </em> </strong>和<strong class="jp ir"> <em class="kl">原生</em> </strong>部分，对当前的规范提出了挑战，我们将看看这个单一的决定如何影响React原生软件开发的许多其他方面。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ml"><img src="../Images/023f192ea47bc1c589b4ecc38ecdc9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W5ymD7fYaoUeeLJ4D72u4g.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">如果项目回购也以类似的方式构建，会有助于我们的心理模型吗？</figcaption></figure><p id="f674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们通过将原生文件夹移动三层来实现原生/JavaScript代码库的分离。在<em class="kl"> JavaScript-repo </em>中，我们没有在开发过程中构建原生二进制文件，而是引入预构建的二进制文件作为依赖项。对于开发人员来说，这个过程就像向JavaScript项目添加任何其他库一样。即<code class="fe km kn ko kp b">npm i lodash</code></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ml"><img src="../Images/cbe1f9249b03391198f52ee03bb7d6fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B8qj6Ba0XAFhotYmya-6iw.png"/></div></div></figure><h1 id="8a20" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">验证关于新方法的假设</strong></h1><p id="a563" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">为了实现确定这种<em class="kl">两次回购</em>方法在真实React本地开发中的可行性和实用性的主要目标，我建立了以下测试计划来验证这个想法，并使用我的一个真实React本地应用<a class="ae lt" href="https://apps.apple.com/gb/app/busdue/id1185327843" rel="noopener ugc nofollow" target="_blank"> BusDue </a>作为测试场地。</p><blockquote class="mm"><p id="54d4" class="mn mo iq bd mp mq mr ms mt mu mv kk dk translated">假设:<br/>对于绿地应用程序开发来说是可行且实用的</p></blockquote><p id="5ecb" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated"><strong class="jp ir">验证计划</strong> <br/>为了模拟绿地应用程序的开发，我决定完全重写BusDue，并在此过程中做一些大的改动，所以很多东西都是从头开始重新编写的。后端也在同一时间经历了类似的重写，因此我们更接近于早期绿地项目的快速变化的环境。</p><p id="2836" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，整个API从node/express迁移到GraphQL+AWS Lambda。前端代码从JS变成了完整的TypeScript。状态管理也经历了重新设计，将更多的状态委托给hooks或GraphQL客户端。一些应用程序功能的更改是当场进行的(我是产品/设计师/开发人员:P ),有时很快就恢复了，因为最终结果不是我想要的，这允许我在早期阶段测试东西，在那里一切都需要非常灵活，并对不断的需求变化做出快速反应。</p><blockquote class="mm"><p id="ffbf" class="mn mo iq bd mp mq mr ms mt mu mv kk dk translated">假设:<br/>这对于棕色地带的应用程序开发是可行且实用的</p></blockquote><p id="7825" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated"><strong class="jp ir">验证计划</strong> <br/>虽然BusDue应用的业务逻辑在很大程度上是重写的，但出于向后兼容的原因，仍然有一些部分和技术需要保持不变，为此，我需要一个移植并保持他们现有的行为，这样我就不会在他们升级到新版本时破坏应用的当前用户。例如，读取和写入存储在用户设备上的数据必须是向后兼容的。</p><blockquote class="mm"><p id="6623" class="mn mo iq bd mp mq mr ms mt mu mv kk dk translated">假设:<br/>这对于中小型团队来说是可行且实用的</p></blockquote><p id="bc7d" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated"><strong class="jp ir">验证计划</strong> <br/>我是BusDue上唯一的开发人员，由于Wix已经证明了这可以与50多名开发人员一起工作，如果我可以证明这可以与一名开发人员一起工作，我们就有很大的机会让中间的一切也可以工作。</p><p id="493b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论</strong></p><p id="c879" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在经历了使用新的<em class="kl">两次回购</em>设置重写和发布BusDue v5的整个过程后，我的结论是，这种新的开发方法为绿地和棕地项目提供了许多好处。最重要的是，这些好处不是一堆相互排斥的决策与令人兴奋的实践相冲突，而是可以逐渐地、可选地被采用，或者根据您的项目需求进一步定制。</p><h1 id="fecd" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">双回购开发方法的优势</h1><blockquote class="mm"><p id="fbef" class="mn mo iq bd mp mq mr ms mt mu mv kk dk translated">更多开发团队组成选项。<em class="nb">新的两次回购方法使得将JavaScript/React Web开发人员整合到您的项目中更加容易。</em></p></blockquote><figure class="nd ne nf ng nh lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nc"><img src="../Images/410a173f3b513da73d59861d092056af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYCDHZPb3KHB7abbLOTQwA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><em class="nb">在后期阶段，很少或没有本地任务的时期并不少见</em></figcaption></figure><p id="6e6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管React Native这个名字看起来要求开发人员具备所有三个领域的技能Android、iOS、JS以及一系列相关知识，如应用商店管理和移动CI/CD，但当我们实际查看更长时间内的整体工作负载时，我们可以看到它们并不完全是线性的。例如，原生工作负载在项目开始时占主导地位，然后随着时间的推移慢慢稳定下来，偶尔会出现需要立即关注的大峰值，例如修复阻塞的原生bug或由您的依赖项之一强制进行的大规模RN升级。</p><p id="1010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于大多数较小的项目来说，拥有2到3名具有良好本地技能的注册护士开发人员对于大多数本地工作来说应该是足够的，因为本地方面的工作量与功能/业务开发方面的工作量相比并不相称(见上图)，经历很少或没有本地变化的时期并不罕见。在开始时，您当然可以只与一个专注于本地的开发人员合作，但是从长远来看，如果您不复制团队的这一部分，您将增加开发总线因素问题的风险。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ni"><img src="../Images/de5450e161b617f37dd18103bb82b353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tYvCt6a3U4ocYUPfgEmLQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">支持只有少数开发人员的大型功能开发团队</figcaption></figure><p id="fe95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了本地方面的内容，开发团队的其他成员可以是RN或React/JavaScript开发人员的混合体，主要的特性开发几乎完全发生在JS方面。</p><blockquote class="mm"><p id="d665" class="mn mo iq bd mp mq mr ms mt mu mv kk dk translated">我们现在更好地定位于<strong class="ak">最大化</strong>React Native作为一项技术的独特优势——利用现有的大量JavaScript/React人才。</p></blockquote><p id="c4b4" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">对于能够接触到现有React web开发人员并希望让他们加入移动应用项目的团队来说，这种设置还提供了一种比单一回购设置中必须采取的学习曲线更精细的方法，这导致了一条<strong class="jp ir"> <em class="kl">更快的生产力之路</em> </strong>，而不管新开发人员决定首先关注哪个领域。</p><h1 id="428f" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">需要更少的思维导图就等于更好的诊断</h1><blockquote class="mm"><p id="0c6f" class="mn mo iq bd mp mq mr ms mt mu mv kk dk translated">能够只考虑一个领域(本地或JavaScript)是一个很大的DX改进</p></blockquote><p id="1e25" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">在DX中使用<em class="kl">双回购</em>设置有很大的好处。这是因为当在本机端工作时，您不必担心理解或意外破坏任何复杂的业务逻辑，因为本机回购不包含来自JavaScript-repo的任何代码。对于处理JavaScript-repo任务的开发人员来说也是如此，因为<strong class="jp ir">在开发期间用于运行应用程序的本机二进制文件是作为节点模块依赖关系</strong>导入的。您将始终得到保证，您使用的是与您的同事相同的经过良好测试的本机代码库，并且不需要修复在您必须用您的机器设置来构建二进制文件时出现的任何构建问题。</p><h1 id="069c" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">本机开发和调试改进</h1><p id="8c4a" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">如前一节所述，当开发任何与本机相关的东西时，开发人员只需要在本机环境中思考，而不必担心项目的JavaScript代码，由于这种明确的分离，<strong class="jp ir">我们还可以自由编写测试本机代码是否工作所需的任何类型的JavaScript代码</strong>。如果需要，我们甚至可以提交这些测试代码，它们只会在我们从本机回购运行应用程序时出现。例如，下面是一个典型的“添加本地库依赖项”任务的比较。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nj"><img src="../Images/dfbf6a367e5d3285f351815efa4bb77c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7iChsP5i2V5AYC6kmKLEQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">更快的交互周期，无需处理JS代码库错误</figcaption></figure><p id="38f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，从事这项原生任务的开发人员能够更快地迭代，因为他们能够<strong class="jp ir">启动一个小得多的RN应用</strong>。通过在我们的JavaScript代码库中不包含各种复杂性，我们还通过<strong class="jp ir">消除了通读UI代码以找出放置临时测试代码的适当位置的需要，从而节省了时间。随着时间的推移，这些小小的节省真的会越积越多。</strong></p><h1 id="dd33" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">JavaScript开发和调试改进</h1><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nk"><img src="../Images/9e99ce941cc0411efdd29fa3e95541d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MqpYhEqkvuTuLlphRKfmMA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">立即将JS加载到经过良好测试的二进制文件中，无需处理机器上的任何构建问题</figcaption></figure><p id="356a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里节省的时间和精力与上面的原生示例相似，但正好相反，<strong class="jp ir">我们消除了应用程序全新启动之间的原生二进制构建时间</strong>，并确保您正在工作的原生二进制与其他人的相同。</p><p id="e97f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于更大的项目，作为一个纯JavaScript repo意味着我们现在可以更好地利用其他许多已知的和经过测试的JS代码分割技术，如monorepo，或微前端开发。在旧的标准单一回购设置中，由于React本地项目中的额外本地元素，许多开发技术很难有效实现。</p><h2 id="24da" class="nl kr iq bd ks nm nn dn kw no np dp la jy nq nr le kc ns nt li kg nu nv lm nw bi translated">以后跳到“另一边”就容易多了</h2><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nx"><img src="../Images/32e9a87a899a14bb93359192e6e6d769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnB5ZmIKeL1VSs4rGAelvw.png"/></div></div></figure><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nx"><img src="../Images/656b15567a05e8763283afcdb3b9ae66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0cc-bG-FkgqU_gSE2XVuuw.png"/></div></div></figure><p id="0350" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们有JavaScript和本地代码库的明确分离，所以每个repo上的提交历史也将更紧密地与它们随时间的实际演变保持一致。这使得我们新的React/JavaScript开发人员一旦安顿下来，就可以更容易地首次涉足原生领域，反之亦然，更多面向原生的开发人员希望更深入地探索JavaScript世界。这也将有利于所有开发人员，因为它可以大大减少调试过程中的搜索区域。</p><h1 id="d56d" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">风险呢？</h1><p id="9d26" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">在考虑是否采纳这样的重大决定时，我们不仅需要评估其益处是否适用于我们自己的个人情况，还需要很好地理解我们可能遇到的各种潜在风险。</p><h2 id="1b7c" class="nl kr iq bd ks nm nn dn kw no np dp la jy nq nr le kc ns nt li kg nu nv lm nw bi translated">react-native停止支持自定义入口index.js路径怎么办？而其他RN库中的自定义路径支持呢？</h2><p id="da65" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">我认为RN取消对自定义文件路径的支持的可能性很小，因为这个概念本身并不新鲜，它是一个非常重要的功能，支持monorepo这样的设置。和AFAIK目前有许多React项目，它们都在某种monorepo结构中，每个项目可能都有自己的文件夹层次结构设计。</p><p id="2ba6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至于其他RN库，我的BusDue应用程序使用了许多流行的原生库，如react-native-maps、react-native-navigation、react-native-bugsnag等。尽管它们所在的节点模块在三层以上，但我还没有遇到任何问题。</p><p id="50fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，根据目前的经验，我认为我们可以有把握地假设，在可预见的未来，支持将会继续。</p><h2 id="8bae" class="nl kr iq bd ks nm nn dn kw no np dp la jy nq nr le kc ns nt li kg nu nv lm nw bi translated"><strong class="ak">这种方法会让react-native升级变得更加困难吗？</strong></h2><p id="1b51" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">这是新设置的一个胜利。</p><p id="5ba7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我不能说未来，但在写这篇文章的时候，我已经在这个双回购设置下经历了两次react-native升级。升级过程与您的标准设置没有什么不同，事实上，我会说<strong class="jp ir">在两个repo设置中升级react-native更容易</strong>，因为我们有更快的本机调试周期，因为我们不需要每次都加载巨大的JS代码库。</p><h2 id="0a9e" class="nl kr iq bd ks nm nn dn kw no np dp la jy nq nr le kc ns nt li kg nu nv lm nw bi translated">如果我不喜欢这种变化，我可以恢复吗？</h2><p id="ffd2" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">是的。正如您在<a class="ae lt" href="https://github.com/ywongweb/barebonePub/commit/7e90dfcd39781baa717068651ed8ff8548c66444" rel="noopener ugc nofollow" target="_blank">中看到的，这个示例提交了</a>整个变更基本上由两个主要部分组成，<em class="kl">“将原生文件夹下移3层”</em>和<em class="kl">“添加一些QoL脚本和工具来帮助开发”</em>。对于后者，它没有听起来那么神秘，所有的脚本和工具都只是助手函数，最终产生一行标准xcode或gradle命令行脚本，我们可以在标准终端中运行。</p><p id="b896" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们的<code class="fe km kn ko kp b">yarn build-ios</code>脚本简单地构造了一个<code class="fe km kn ko kp b">xcodebuild &lt;args...&gt;</code>命令来构建和ios存档，而<code class="fe km kn ko kp b">yarn ios</code>脚本构造了一个<code class="fe km kn ko kp b">xcrun simctrl</code>命令来在模拟器中启动应用程序。所有这些都是在正常的构建或运行过程中在控制台上打印出来的完全相同的命令。因此，如果你想恢复它，你需要做的就是将文件夹移回原来的位置，并从不同的路径设置中删除<code class="fe km kn ko kp b">../../..</code>,然后你将得到一个标准的React-Native项目。</p><h2 id="8b19" class="nl kr iq bd ks nm nn dn kw no np dp la jy nq nr le kc ns nt li kg nu nv lm nw bi translated">app store部署流程呢？</h2><p id="4c7b" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">部署过程主要是技术步骤，所以我的计划是将该部分推迟到第二部分。但是为了让你有个概念，下面是iOS发布应用商店二进制文件的一般步骤。</p><p id="41e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本地回购</p><ul class=""><li id="429d" class="ny nz iq jp b jq jr ju jv jy oa kc ob kg oc kk od oe of og bi translated">从原生repo创建应用商店二进制文件</li><li id="bd58" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">将二进制文件发布到github包</li></ul><p id="f4b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript-回购</p><ul class=""><li id="4b5c" class="ny nz iq jp b jq jr ju jv jy oa kc ob kg oc kk od oe of og bi translated">通过<code class="fe km kn ko kp b">npm</code>或<code class="fe km kn ko kp b">yarn</code>将二进制文件拉入JavaScript-repo</li><li id="9042" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">在JavaScript-repo中，提交所有您希望包含在发布中的代码，然后使用<code class="fe km kn ko kp b">react-native bundle</code>命令创建一个新的JS包。</li><li id="6995" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">提取app store原生二进制文件，并用新捆绑的文件替换其中的JS包</li><li id="c0fa" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">用<code class="fe km kn ko kp b">fastlane</code>重新签名应用商店二进制文件</li><li id="f08e" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">上传至Apple进行审查和发布</li></ul><p id="b2bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(Android的过程与使用Android等效命令的过程非常相似)</p><h1 id="6376" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">一个面向技术人员的小型演示项目</h1><p id="568c" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated"><a class="ae lt" href="https://github.com/ywongweb/barebonePub" rel="noopener ugc nofollow" target="_blank">原生回购示例</a>构建并发布您自己的原生二进制文件<br/> <a class="ae lt" href="https://github.com/ywongweb/bareboneFE" rel="noopener ugc nofollow" target="_blank">伴随JavaScript-repo </a>使用来自原生回购的二进制文件</p><p id="db29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，上面的演示项目是一个精简的ios专用版本。这不是我在BusDue应用程序中使用的最终设置，例如在我的BusDue应用程序中，每次我构建原生代码库时，我都能够输出任意数量的这些二进制文件以用于不同的目的。</p><ul class=""><li id="dddb" class="ny nz iq jp b jq jr ju jv jy oa kc ob kg oc kk od oe of og bi translated">开发环境模拟器/设备的iOS调试</li><li id="eaa8" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">生产环境模拟器/设备的iOS调试</li><li id="1655" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">面向开发环境设备的iOS专用</li><li id="ebb1" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">iOS专用于生产环境的设备</li><li id="8e9c" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">iOS应用商店</li><li id="b625" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">Android开发环境调试</li><li id="b892" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">针对生产环境的Android调试</li><li id="9a0d" class="ny nz iq jp b jq oh ju oi jy oj kc ok kg ol kk od oe of og bi translated">Android版本</li></ul><h1 id="6532" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">定论</h1><p id="4843" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">在这种架构下花时间开发和发布整个应用程序重写，然后比较我过去使用的旧流程，我真的很喜欢这种想法的简单性以及它带来的各种开发人员授权的好处，我肯定会在我当前和未来的项目中继续探索和完善这种设置。</p><p id="986b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在列出的所有好处中，我最喜欢的是<strong class="jp ir">我不再需要在调试过程中考虑一半的堆栈</strong>，由于90%的开发时间都花在各种形式的调试上，这确实为我腾出了大量时间和精力来做其他重要的事情。我真诚地相信，这种<em class="kl">两次回购</em>的开发流程是从今天开始的任何React本地项目的<strong class="jp ir">非常强大的替代方案</strong>,或者是由于我们讨论的各种棘手问题而遭遇瓶颈的棕色地带项目。</p><p id="d422" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这篇文章对你有用，并考虑在你的下一个项目中尝试一下<em class="kl">两次回购</em>设置。别忘了敲那个👏按钮几次，让这篇文章可以达到更多志同道合的人喜欢你！感谢阅读和快乐编码！</p></div></div>    
</body>
</html>