<html>
<head>
<title>Android: Intro Slider with state management using Arch components. (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android:使用Arch组件进行状态管理的介绍滑块。(第一部分)</h1>
<blockquote>原文：<a href="https://itnext.io/android-intro-slider-with-state-management-using-androidx-architecture-components-part-1-caeba1db7a32?source=collection_archive---------1-----------------------#2020-05-13">https://itnext.io/android-intro-slider-with-state-management-using-androidx-architecture-components-part-1-caeba1db7a32?source=collection_archive---------1-----------------------#2020-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="41b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这些系列中，我们将看看如何使用Android架构组件来管理视图状态，如<code class="fe kl km kn ko b">ViewModel</code>、<code class="fe kl km kn ko b">LiveData</code>和<code class="fe kl km kn ko b">Transformations</code>。我们还将在此过程中创建一个漂亮且可扩展的介绍滑块。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">简介滑块演示</figcaption></figure></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="a95d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使事情更简单，您可以:</p><ul class=""><li id="9ee8" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">签出GitHub 的<a class="ae lq" href="https://github.com/xzhorikx/slider-intro/tree/part-1-base" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="lr">part-1-base</em></strong><em class="lr"/>分支，该分支已经为您设置了<code class="fe kl km kn ko b">MainActivity</code>和所有资源</a></li><li id="81db" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated">或者自己建立一个空项目<a class="ae lq" href="https://github.com/xzhorikx/slider-intro/tree/master/app/src/main/res/values" rel="noopener ugc nofollow" target="_blank">在GitHub上抓取colors.xml、strings.xml、dimens.xml、styles . XML</a></li></ul><p id="180a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始所有酷的状态管理之前，我们需要实现intro slider 本身。我们先来看看背后的想法。如果你是一个有经验的开发者，你可能已经知道我们的介绍滑块只不过是一个嵌套在activity中的<a class="ae lq" href="https://developer.android.com/training/animation/screen-slide" rel="noopener ugc nofollow" target="_blank">视图分页器</a>。但是为了更好地理解，这里有一个小图，展示了所有视图元素在活动中是如何呈现的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/590e5e33e04596d44045751b4a9251aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*H5ooAKeqJxgsL4Vs01Wtgg.png"/></div></figure><p id="57ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要考虑的关键事项</p><ul class=""><li id="7d56" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">我们需要1个活动，1个查看页面和3个片段</li><li id="b4d3" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated">导航状态(<em class="lr">跳过</em>和<em class="lr">下一步</em>按钮，<em class="lr">圆点</em>)是活动视图的一部分，依赖于<code class="fe kl km kn ko b">ViewPager</code>状态</li><li id="d59b" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated">片段的内容只有颜色、图标和文本不同，所以我们可以使用一些通用的构造函数来创建它们</li></ul><p id="ebfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住这一点，是时候为主要活动创建一个基本视图了。在布局文件夹中创建<code class="fe kl km kn ko b">activity_main.xml</code>文件，用<code class="fe kl km kn ko b">onCreate()</code>方法将其设置为内容视图。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">主要活动基础结构</figcaption></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">查看主活动的XML</figcaption></figure><p id="f7a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们的活动将是空白的，但让我们仔细看看我们刚刚创建的内容。</p><ul class=""><li id="89e9" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated"><code class="fe kl km kn ko b">ViewPager</code> ( <em class="lr"> vpIntro </em>)将负责显示我们即将创建的片段列表</li><li id="938c" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated"><code class="fe kl km kn ko b">TextView</code>元素(<em class="lr"> tvIntroSkip </em>、<em class="lr"> tvIntroNext </em>、<em class="lr"> tvIntoFinish </em>)负责用户的手动导航。我们已经将<em class="lr"> tvIntroNext </em>和<em class="lr"> tvIntoFinish </em>分开，以便在不使用太多代码的情况下，在最后一个片段上创建它们之间良好的淡入/淡出动画。</li><li id="7d64" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated"><code class="fe kl km kn ko b">LinearLayout</code>对于导航点(<em class="lr"> containerIntroDots </em>)，当知道应该显示多少片段时，将动态地用视图填充。</li></ul></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="186a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当创建活动时，是时候包含我们的第一个架构组件了— <code class="fe kl km kn ko b"><a class="ae lq" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank">ViewModel</a></code>。<code class="fe kl km kn ko b">ViewModel</code>允许以生命周期意识的方式存储和管理UI相关数据，并允许数据在屏幕旋转等配置更改后仍然存在。简而言之，<code class="fe kl km kn ko b">ViewModel</code>为活动或片段创建一次，仅在视图的<code class="fe kl km kn ko b">onDestroy()</code>方法被调用后销毁。</p><p id="f678" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两个主要的公共类供ViewModels扩展:<code class="fe kl km kn ko b">ViewModel</code>和<code class="fe kl km kn ko b">AndroidViewModel</code>。两者之间的唯一区别是后者接受<em class="lr">应用程序上下文</em>作为其唯一的构造函数参数，这意味着在ViewModel的生命周期中，应用程序上下文将对子类可用。当您需要在<code class="fe kl km kn ko b">ViewModel</code>中访问字符串、维度或任何其他资源时，这很方便。</p><blockquote class="mb mc md"><p id="e9d7" class="jn jo lr jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">非常重要的注意事项:ViewModel决不能引用视图、生命周期或任何可能包含对活动上下文的引用的类。总是将<strong class="jp ir">应用上下文</strong>传递给AndroidViewModel。</p></blockquote><p id="e132" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创造<code class="fe kl km kn ko b">MainActivityViewModel</code></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">查看模型库</figcaption></figure><p id="2665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所知，Android中的许多组件必须有空的构造器(活动、片段等)。)并且ViewModel也不例外—默认情况下，它是使用空构造函数创建的。然而，我们刚刚创建的ViewModel接受<em class="lr">应用程序</em>作为它的参数，那么我们如何实例化它呢？</p><p id="9f4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答:一定要用<code class="fe kl km kn ko b"><a class="ae lq" href="https://developer.android.com/reference/androidx/lifecycle/ViewModelProvider.AndroidViewModelFactory" rel="noopener ugc nofollow" target="_blank">AndroidViewModelFactory</a></code>。工厂是创建类的一种常见架构方法，所以难怪Android利用这种机制来创建带有非空构造函数的视图模型。让我们创建我们的<code class="fe kl km kn ko b">MainAppActivityViewModelFactory</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">主活动视图模型工厂</figcaption></figure><p id="0b3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，为了在我们的活动中获得我们的<code class="fe kl km kn ko b">MainActivityViewModel</code>的实例，有必要再使用一个Android实用程序类:<code class="fe kl km kn ko b"><a class="ae lq" href="https://developer.android.com/reference/androidx/lifecycle/ViewModelProvider" rel="noopener ugc nofollow" target="_blank">ViewModelProvider</a></code> <strong class="jp ir">。这个类接受<code class="fe kl km kn ko b"><a class="ae lq" href="https://developer.android.com/reference/androidx/lifecycle/ViewModelStoreOwner" rel="noopener ugc nofollow" target="_blank">ViewModelStoreOwner</a></code>和<code class="fe kl km kn ko b"><a class="ae lq" href="https://developer.android.com/reference/androidx/lifecycle/ViewModelProvider.Factory" rel="noopener ugc nofollow" target="_blank">ViewModelProvider.Factory</a></code>作为它的参数，并允许我们通过它的类获得必要的<code class="fe kl km kn ko b">ViewModel</code>实例。不要害怕这些复杂的名字，只要看一看代码，一切都变得简单多了:</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma kv l"/></div></figure><p id="4116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来分解一下:</p><ul class=""><li id="49c5" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">我们创建对<code class="fe kl km kn ko b">MainAppActivityViewModel</code>及其工厂的类级引用。</li><li id="9949" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated">工厂有<code class="fe kl km kn ko b">lateinit</code> <em class="lr"> </em>修饰符<em class="lr"> </em>，因为它只有在<code class="fe kl km kn ko b">onCreate()</code>被调用时才会被初始化。我们会尽快初始化这个字段。</li><li id="c4c1" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated"><code class="fe kl km kn ko b">MainActivityViewModel</code>由kotlin的<code class="fe kl km kn ko b">lazy</code> <em class="lr"> </em>属性初始化，意味着该字段在第一次调用之前不会被初始化。我们需要这样做，因为创建<code class="fe kl km kn ko b">MainActivity</code>时工厂尚未初始化。</li></ul><p id="8e59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">检查站。</strong>运行应用程序，看看在这一点上是否有任何问题。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="df81" class="mh mi iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">是时候创建将显示给用户的片段了！</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/dd9b08bd7b09b5a416b9341b5739ae02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*7CuAqgUDNomtkTOKVWIMSg.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">在简介滑块中使用片段</figcaption></figure><p id="82fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，我们的应用程序中的片段仅在颜色、图标和文本上有所不同，所以我们可以使用一些通用的构造函数来创建它们。我更喜欢为此创建枚举，并将其传递给静态片段构造函数。在这里抓一个<code class="fe kl km kn ko b">fragment_slider.xml</code>布局:<a class="ae lq" href="https://github.com/xzhorikx/slider-intro/blob/master/app/src/main/res/layout/fragment_sldier.xml" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">片段创建</figcaption></figure><p id="2b98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们仔细看看:</p><ul class=""><li id="9f52" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">所有片段都具有相似的结构，因此不需要为此创建多个片段类。我们可以简单地通过向其构造函数传递一个参数来定义片段的状态。</li><li id="fd57" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated"><code class="fe kl km kn ko b">ScreenType</code> <em class="lr"> </em>是定义应该创建哪种片段的枚举。它还有引用用于背景色的资源颜色的<code class="fe kl km kn ko b">backroundColor</code>字段。</li><li id="8b0f" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated"><code class="fe kl km kn ko b">SliderFragment.newInstance(screenType: ScreenType)</code>允许我们创建所需类型的片段。这个工厂方法只是使用<code class="fe kl km kn ko b">arguments</code>包将<code class="fe kl km kn ko b">ScreenType</code>传递给片段。</li><li id="e634" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated"><code class="fe kl km kn ko b">private var screenType</code>是对传递的屏幕类型的可空引用。我们使它可空，因为不使用<code class="fe kl km kn ko b">newInstance()</code>方法仍然可以创建片段，因此不会传递<code class="fe kl km kn ko b">ScreenType</code>。后来保存它的<code class="fe kl km kn ko b">onSaveInstanceState()</code> <em class="lr"> </em>方法。</li></ul><p id="e968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们给屏幕添加一些内容。如果还没有做，g <a class="ae lq" href="https://github.com/xzhorikx/slider-intro/tree/master/app/src/main/assets" rel="noopener ugc nofollow" target="_blank"> rab资产图片从这里</a>，<a class="ae lq" href="https://github.com/xzhorikx/slider-intro/blob/master/app/src/main/res/values/strings.xml" rel="noopener ugc nofollow" target="_blank">字符串从这里</a>并把它们全部带到屏幕上！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">根据屏幕类型值填充片段的内容</figcaption></figure><p id="3010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果<code class="fe kl km kn ko b">screenType</code>不为空，那么我们可以在用户的屏幕上呈现标题、正文和图标。</p><p id="4b0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！我们的碎片已经可以使用了。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="3a44" class="mh mi iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">在ViewPager中显示片段</h1><p id="9ae3" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">现在我们需要在一个<code class="fe kl km kn ko b">ViewPager</code>中显示我们全新的片段。在<code class="fe kl km kn ko b">ViewModel</code>中拥有活动所需的所有字段是个好主意，但不幸的是，我们不能在这里初始化片段:</p><blockquote class="mb mc md"><p id="ba22" class="jn jo lr jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">ViewModel决不能引用视图、生命周期或任何可能包含对活动上下文的引用的类。</p></blockquote><p id="ef64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这个限制，我们将不得不保持对片段类型列表的引用。导航到<code class="fe kl km kn ko b">MainAppActivityViewModel</code> <em class="lr">，</em>我们将在这里进行一些更改:</p><ul class=""><li id="7c52" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">添加包含对所显示片段类型列表的引用的成员属性。</li><li id="1a05" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated">片段类型应保存在<code class="fe kl km kn ko b"><a class="ae lq" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>中，以便活动可以观察它们。</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">正在初始化视图模型中的片段类型列表</figcaption></figure><p id="aa52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍后将在<code class="fe kl km kn ko b">ViewPager</code>适配器中使用片段类型列表来初始化片段(<em class="lr">感谢</em><a class="ae lq" href="https://old.reddit.com/user/Canivek" rel="noopener ugc nofollow" target="_blank"><em class="lr">Canivek</em></a><em class="lr">对于此建议</em>)</p><p id="75c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需通过调用<em class="lr"> </em> <code class="fe kl km kn ko b">SliderFragment.newInstance()</code> <em class="lr">将<code class="fe kl km kn ko b">ScreenType</code>中的每个枚举值映射到<code class="fe kl km kn ko b">SliderFragment</code> <em class="lr"> </em>中即可。</em>通过这种方式，我们为片段创建创建了可扩展的解决方案。</p><p id="5a21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是观察<code class="fe kl km kn ko b">fragmentTypeListLiveData</code>主活动的时候了。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">主活动中的第一个实时数据观察者</figcaption></figure><p id="c869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次<code class="fe kl km kn ko b">fragmentTypeListLiveData</code>接收到新的值或者活动的配置改变时，<code class="fe kl km kn ko b">Observer { … }</code> <em class="lr"> </em>对象都会被调用一次。这是我们的用例初始化<code class="fe kl km kn ko b">ViewPager</code>的完美地方，因为我们知道片段的数量是静态的，在运行时不会改变。</p><blockquote class="mb mc md"><p id="6bad" class="jn jo lr jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">注意:将可变的LiveData类暴露给活动/片段被认为是一种不好的做法，所以要确保所有的公共getters总是返回不可变的LiveData实例。</p></blockquote><h2 id="abdd" class="nk mi iq bd mj nl nm dn mn nn no dp mr jy np nq mv kc nr ns mz kg nt nu nd nv bi translated"><strong class="ak">最后一步:</strong>为ViewPager创建<code class="fe kl km kn ko b"><em class="nw">SliderAdapter </em></code>。</h2><p id="e5fc" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">这里我们将保持简短——每个<code class="fe kl km kn ko b">ViewPager</code>都需要一个适配器来显示多个片段。在上面的代码中<code class="fe kl km kn ko b">SliderAdapter</code>被调用，下面是它的样子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">正在为视图页导航创建适配器</figcaption></figure><p id="73c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次调用<code class="fe kl km kn ko b">getItem()</code>时，都会用给定的<code class="fe kl km kn ko b">ScreenType</code>通过工厂方法创建新的<code class="fe kl km kn ko b">SliderFragment</code>。这样，片段总是在<code class="fe kl km kn ko b">ViewModel</code>范围之外初始化。</p><p id="b268" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查点:我们应该都准备好了，可以出发了！运行您的应用程序，查看<code class="fe kl km kn ko b">ViewPager</code>和<code class="fe kl km kn ko b">Fragments</code>的运行情况。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">我们的最终结果。</figcaption></figure></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="91f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一部分到此为止！让我们回顾一下我们所做的事情:</p><ul class=""><li id="4913" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">使用我们的第一个架构组件:<code class="fe kl km kn ko b">ViewModel</code>、<code class="fe kl km kn ko b">ViewModelProvider.Factory</code>和<code class="fe kl km kn ko b">LiveData</code></li><li id="5f59" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated">为片段创建创建了一个易于扩展的解决方案</li><li id="0c8a" class="lh li iq jp b jq ls ju lt jy lu kc lv kg lw kk lm ln lo lp bi translated">结合上述一切，创建一个介绍滑块的基础</li></ul><p id="3a9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加入我们的第2部分，我们将实现动态背景色、导航点动画以及更多！</p><p id="37f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对代码有任何问题，你可以看看GitHub 上的<a class="ae lq" href="https://github.com/xzhorikx/slider-intro/tree/part-2-base" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="lr"> part-2-base </em> </strong>分支。</a></p></div></div>    
</body>
</html>