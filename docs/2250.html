<html>
<head>
<title>Effective Secrets with Vault and Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vault和Kubernetes的有效秘密</h1>
<blockquote>原文：<a href="https://itnext.io/effective-secrets-with-vault-and-kubernetes-9af5f5c04d06?source=collection_archive---------0-----------------------#2019-04-24">https://itnext.io/effective-secrets-with-vault-and-kubernetes-9af5f5c04d06?source=collection_archive---------0-----------------------#2019-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a856a1ba64d54ab4e043ef3f2073eb28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cG1igNyPWIxDd1B_jRh1A.png"/></div></div></figure><h1 id="8541" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="8190" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Kubernetes是容器编排的事实上的标准，HashiCorp的Vault是秘密管理的事实上的标准。现在的问题是:如何将这些技术结合起来，在Kubernetes应用程序中使用中央保险库实例中的秘密？</p><p id="6571" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一个解决方案是使用<a class="ae lz" href="https://www.vaultproject.io/docs/auth/approle.html" rel="noopener ugc nofollow" target="_blank"> AppRole </a> auth方法。Boostport 提供了Kubernetes中AppRoles的出色集成。另一种可能是使用<a class="ae lz" href="https://www.vaultproject.io/docs/auth/kubernetes.html" rel="noopener ugc nofollow" target="_blank"> Kubernetes auth方法</a>。这种身份验证方法在Vault和您的Kubernetes集群之间建立信任关系，因此您可以使用服务帐户对Vault进行身份验证。您可以使用带有Kubernetes 的<a class="ae lz" href="https://learn.hashicorp.com/vault/identity-access-management/vault-agent-k8s" rel="noopener ugc nofollow" target="_blank"> Vault代理来获取和更新认证令牌。</a></p><p id="5c4c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在本文中，我将向您展示如何使用一些Go助手工具来实现相同的功能，这些工具可以验证和更新令牌，甚至更进一步，将预定义的机密子集从Vault同步到Kubernetes。</p><p id="a261" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="ma">等级:高级</em></p><h1 id="c279" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">先决条件</h1><p id="1881" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了简单起见，我做了一些选择:</p><ul class=""><li id="6c87" class="mb mc iq ky b kz lu ld lv lh md ll me lp mf lt mg mh mi mj bi translated">Kubernetes集群可以通过许多不同的方式建立。通常，<code class="fe mk ml mm mn b">minikube</code>用于测试或开发目的。我将使用<code class="fe mk ml mm mn b">kubeadm</code>,因为建立一个真正的<em class="ma">集群非常简单。</em></li><li id="cbff" class="mb mc iq ky b kz mo ld mp lh mq ll mr lp ms lt mg mh mi mj bi translated">在Kubernetes中，将使用<code class="fe mk ml mm mn b">default</code>名称空间。</li><li id="1a26" class="mb mc iq ky b kz mo ld mp lh mq ll mr lp ms lt mg mh mi mj bi translated">保险库将以<em class="ma">开发</em>模式运行。<em class="ma">生产中不要这样用！</em>确保相应地设置环境变量<code class="fe mk ml mm mn b">VAULT_ADDR</code>。</li><li id="0745" class="mb mc iq ky b kz mo ld mp lh mq ll mr lp ms lt mg mh mi mj bi translated">Ubuntu将用于所有代码示例。它们已经在GCE上的单个Ubuntu 18.10 VM上经过测试，具有2个vCPUs和7.5 GB。(看看GCP 300美元<a class="ae lz" href="https://cloud.google.com/free/" rel="noopener ugc nofollow" target="_blank">免费等级</a>，随便说说……)</li><li id="1f9e" class="mb mc iq ky b kz mo ld mp lh mq ll mr lp ms lt mg mh mi mj bi translated">除非另有说明，否则将使用Bash。</li></ul><h1 id="3086" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">库伯内特斯</h1><p id="49d0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们从一个简单的测试集群开始。下面是单节点安装的安装说明。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="8a71" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">跳跃</h1><h2 id="2046" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">装置</h2><p id="185b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Vault安装非常简单:下载并解压二进制文件:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="b9a5" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">运行Vault服务器</h2><p id="d763" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们将在<em class="ma">开发</em>模式下运行一个Vault服务器。同样，这非常简单。请注意，当启动一个dev服务器时，一个根令牌将被写入<code class="fe mk ml mm mn b">$HOME/.vault-token</code>，即使对于根用户也是如此。Vault进程将被放在带有<code class="fe mk ml mm mn b">&amp;</code>符号的背景中，这样我们就可以继续使用同一个shell。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="9f1f" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">配置Kubernetes身份验证方法</h2><p id="30ab" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在，我们必须确保Kubernetes能够通过启用Kubernetes auth方法与Vault通信。这在Kubernetes和Vault之间建立了信任关系。命名角色<code class="fe mk ml mm mn b">vault-demo-role</code>将映射策略并定义一个TTL。</p><p id="5188" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因为我们使用<code class="fe mk ml mm mn b">kubeadm</code>建立了我们的Kubernetes集群，所以很容易找到属性<code class="fe mk ml mm mn b">kubernetes_ca_cert</code>的认证中心(CA)商店。当使用云提供的Kubernetes安装时，这可能有点困难。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="9049" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">基于角色的访问控制(RBAC)</h2><p id="2b30" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在Kubernetes方面，我们现在必须建立相应的RBAC的东西。首先，我们将创建一个名为<code class="fe mk ml mm mn b">vault-serviceaccount</code>的服务帐户。然后，我们将添加一个名为<code class="fe mk ml mm mn b">vault-closterrolebinding</code>的集群角色绑定，这样我们新创建的服务帐户就可以使用默认的集群角色<code class="fe mk ml mm mn b">system:auth-delegator</code>执行委托身份验证请求。角色<code class="fe mk ml mm mn b">vault-secretadmin-role</code>和角色绑定<code class="fe mk ml mm mn b">vault-secreatadmin-rolebinding</code>也被绑定到<code class="fe mk ml mm mn b">vault-serviceaccount</code>，这样我们就能够同步秘密。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c2d3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们应用这些清单:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="398e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">准备完毕。现在我们可以开始我们的用例了。</p><h1 id="1aa0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">用例</h1><p id="0b35" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们将涵盖三个用例:</p><ul class=""><li id="b6a9" class="mb mc iq ky b kz lu ld lv lh md ll me lp mf lt mg mh mi mj bi translated">第一个示例将演示如何通过使用init容器对Vault进行身份验证并获取身份验证令牌。</li><li id="4a09" class="mb mc iq ky b kz mo ld mp lh mq ll mr lp ms lt mg mh mi mj bi translated">第二个例子将演示如何使用sidecar容器更新这个令牌。</li><li id="a179" class="mb mc iq ky b kz mo ld mp lh mq ll mr lp ms lt mg mh mi mj bi translated">第三个例子将演示如何将秘密从Vault同步到Kubernetes。</li></ul><p id="6366" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这三个用例都基于我在PostFinance的同事构建的三个Docker图像。特别要感谢Marc Sauter，他受Seth Vargo作品的启发编写了最初的实现。这三张图片都可以在<a class="ae lz" href="https://hub.docker.com/u/postfinance" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>上找到，它们都包含小Go助手工具，源代码可以在<a class="ae lz" href="https://github.com/postfinance/vault-kubernetes" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h2 id="cc89" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">使用Init容器进行身份验证</h2><p id="75dd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第一个例子将展示<code class="fe mk ml mm mn b">vault-kubernetes-authenticator</code>图像的用法(简称<em class="ma"> auther </em>)。auther在init容器中运行，使用服务帐户<code class="fe mk ml mm mn b">vault-serviceaccount</code>对Vault进行身份验证，并将Vault身份验证令牌写入<code class="fe mk ml mm mn b">/home/vault/.vault-token</code>。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a71e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们应用这个清单，然后我们将做一些测试来验证一切工作正常。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="abb4" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">用边车更新令牌</h2><p id="6a77" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第二个例子将展示<code class="fe mk ml mm mn b">vault-kubernetes-token-renewer</code>图像的用法(简称<em class="ma"> renewer </em>)。renewer在sidecar容器中运行，定期检查TTL，并相应地更新身份验证令牌。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b0d6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们同样应用此清单，并再次进行一些验证。(我删除了之前的部署。)</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="f59a" class="mz jz iq bd ka na nb dn ke nc nd dp ki lh ne nf km ll ng nh kq lp ni nj ku nk bi translated">将机密从Vault同步到Kubernetes</h2><p id="a562" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第三个例子将展示<code class="fe mk ml mm mn b">vault-kubernetes-synchronizer </code>(简称<em class="ma"> syncer </em>)的用法。同步器可以以不同的方式使用。在演示中，Kubernetes作业将用于从预定义的路径一次性同步Vault机密。保险库机密将被写入相应的Kubernetes机密。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3456" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">同样，让我们应用这个清单，并检查一切是否按预期工作:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="37e0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">同步程序也可以在Kubernetes cron作业中使用，以定期同步Vault机密，或者在Kubernetes部署中的另一个init容器中使用，以便机密总是最新的。</p><p id="2c1a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请注意，Kubernetes的秘密没有得到很好的保护。默认情况下，它们只是base64编码和存储，就像Seth Vargo在最近的FOSDEM <a class="ae lz" href="https://fosdem.org/2019/schedule/event/base64_not_encryption/" rel="noopener ugc nofollow" target="_blank">演讲</a>中指出的那样。您应该启用<a class="ae lz" href="https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/" rel="noopener ugc nofollow" target="_blank">静态秘密数据的加密</a>。另外，请确保您只同步那些被您的Kubernetes应用程序有效使用的机密，这些机密受到相应的保管库策略和指定角色的保护。除此之外，这种方法允许您以云本地的方式使用秘密。您的应用程序不必直接访问Vault，机密可以作为环境变量注入。</p><h1 id="48a7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="fb7a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Kubernetes和Vault这两种技术可以通过组合和集成以最佳方式使用。这种整合很重要，但仍然是可行的。在本文中，我向您展示了如何实现这种集成，希望对您也有所帮助。</p><p id="8c94" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您可能会问自己，既然可以使用官方的Vault映像来运行代理以实现相同的目的，为什么还要使用一些第三方映像。原因是:存储库代理需要一个配置文件而不是环境变量，这意味着您必须管理另一个配置映射。并且代理当前无法同步机密。此外，图像重量更轻。官方保险库映像的大小约为100 MB。auther和renewer映像大约为10 MB，syncer大约为40 MB。</p></div></div>    
</body>
</html>