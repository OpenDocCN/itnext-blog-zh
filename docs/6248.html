<html>
<head>
<title>Simple Functional Programming concepts in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中简单的函数式编程概念</h1>
<blockquote>原文：<a href="https://itnext.io/simple-functional-programming-concepts-in-javascript-d6204324e0df?source=collection_archive---------9-----------------------#2021-09-28">https://itnext.io/simple-functional-programming-concepts-in-javascript-d6204324e0df?source=collection_archive---------9-----------------------#2021-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8c7525fabc261062c495c047104d7062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDqz8xs_KTuDAENEKkkOKA.png"/></div></div></figure><p id="2137" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">学习函数式编程可能具有挑战性。它涉及到单子、函子等概念。最重要的是，你的团队必须应用函数式编程来获得好处。</p><p id="e1f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，有些课程你可以开始应用，而不需要理解更高级的概念，也不需要整个团队的认同。</p><p id="ea61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些来自函数式编程的技巧很容易理解，您可以马上开始使用它们来改进您的代码。</p><h1 id="8daa" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">转换漏斗</h1><p id="8f1c" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这有助于从转换数据的漏斗而不是一组命令性操作的角度来考虑您的函数。输入进来，然后应用一组转换并返回转换后的输出。</p><p id="6663" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也是函数链发挥作用的地方。函数链接是指通过使用前一个函数的输出来调用下一个函数，从而将一行中的多个函数链接起来。这类似于面向对象编程中的<a class="ae mc" href="https://en.wikipedia.org/wiki/Method_chaining#:~:text=Method%20chaining%2C%20also%20known%20as,to%20store%20the%20intermediate%20results." rel="noopener ugc nofollow" target="_blank">方法链</a>。</p><p id="0c85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数链通常会使你的代码更加整洁，减少重复。它在每一步都删除了额外的变量，这样你就不用为这些变量命名了。函数链通常对集合的转换非常有用，比如数组。</p><p id="b4e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看解决同一个问题的两种方法。让我们从使用<code class="fe md me mf mg b">for</code>循环的命令式开始:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/41ae8c242ee7481510e06015379f67ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqpuTY6PQeQmvksrO5Eo3w.png"/></div></div></figure><p id="6758" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看看使用函数链重写的同一个函数:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/96a6d9ebe9f39a5618d07232a1456151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*noRPs5QCJktS69wx5IexEA.png"/></div></div></figure><p id="a864" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所看到的，函数链接产生了更紧凑的代码，我们避免了中间的<code class="fe md me mf mg b">names</code>变量。</p><p id="52c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不是所有的函数都适合函数链，这没关系。尽可能地应用它，避免为了适应模式而过度设计代码。</p><h1 id="aafe" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">纯函数</h1><p id="56da" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">纯函数是在给定相同输入的情况下总是返回相同输出的函数。另一个与众不同的特点是它们在功能范围之外不会引起<a class="ae mc" href="https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29" rel="noopener ugc nofollow" target="_blank">副作用</a>。</p><p id="9ef3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">纯函数与<a class="ae mc" href="https://en.wikipedia.org/wiki/Immutable_object#:~:text=In%20object%2Doriented%20and%20functional,modified%20after%20it%20is%20created.&amp;text=Other%20benefits%20are%20that%20they,higher%20security%20than%20mutable%20objects." rel="noopener ugc nofollow" target="_blank">不变性</a>的概念密切相关。由于变异输入对象显然是一种副作用，如果您希望您的函数是纯净的，您应该避免它。解决这个问题的一个方法是在改变输入参数之前复制它们。这样，原始输入参数保持不变。</p><p id="b336" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">纯函数的优点:</p><ul class=""><li id="5e3e" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">可靠性——在给定相同输入的情况下，您总是可以依靠纯函数返回相同的输出。</li><li id="7cb3" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">可测试性——因为纯函数不会产生任何副作用或改变输入，所以您可以在测试中多次运行它们，而不用担心状态。</li></ul><h1 id="756e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">无点风格</h1><p id="9352" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">无点风格意味着函数的参数在被调用时不会被显式提及。</p><p id="8454" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您通过与转换数据的更简单的函数组合来创建函数。因此，您的函数更加模块化，您的代码最终更具声明性。</p><p id="fac3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本质上，您不需要描述函数如何工作，只需要描述它对输入做了什么。它还避免了可能导致混乱或错误的临时变量。</p><p id="6fbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当与函数链接结合使用时，无指针风格工作得非常好。</p><p id="667e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们重写前面的函数链示例，并应用无指针样式:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/42752bb61171e7ee43f2f7a0dc296e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSCbT1zfzULSnKje9FTNXg.png"/></div></div></figure><p id="3681" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意我们是如何传递<code class="fe md me mf mg b">getName</code>函数来映射和过滤，而没有显式指定它的输入参数。</p><p id="d84e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当你发现无要点风格时，可能会很想开始到处使用它来使你的代码简洁。只要记住它也伴随着权衡。</p><p id="b826" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果走得太远，无指针会损害代码的灵活性。在某些情况下，由于微小的需求变化，您可能不得不完全重构您的功能。</p><h1 id="ac5d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Currying</h1><p id="3420" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Currying是一种转换技术，它将带有多个参数的函数转换成链式函数，每个函数接受一个参数。这样做允许通过提前应用一些参数来创建更专门化的函数。</p><p id="29af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您有一个带有多个参数的函数，并且您发现自己多次重复一些参数时，您可以手动创建一个更专用的函数。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/dbbf055dabc58931a51f7119374af924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ns-W15dpcgBGVfwxpqrfwg.png"/></div></div></figure><h1 id="652f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="e537" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在这篇文章中，我们回顾了一些你可以立即开始应用的函数式编程概念。</p><p id="67bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">诚然，这篇文章的例子是为了让概念更容易理解。例如，我们手动创建了一个特定功能的定制版本，该版本通常无法扩展。</p><p id="17d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">借助函数式编程实用程序库，例如<a class="ae mc" href="https://ramdajs.com" rel="noopener ugc nofollow" target="_blank"> Rambda.js </a>，将函数式编程集成到您的项目中会容易得多。在许多其他有用的实用程序中，Rambda.js有一个<code class="fe md me mf mg b">curry</code>函数，可以帮助创建函数的可定制版本。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="e3b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ni">原载于2021年9月28日https://isamatov.com</em><a class="ae mc" href="https://isamatov.com/functional-programming-javascript/" rel="noopener ugc nofollow" target="_blank"><em class="ni"/></a><em class="ni">。</em></p></div></div>    
</body>
</html>