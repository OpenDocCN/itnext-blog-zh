<html>
<head>
<title>Get Rid of if-statements in your Angular App with OOP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用OOP去除Angular应用中的if语句</h1>
<blockquote>原文：<a href="https://itnext.io/get-rid-of-if-statements-in-your-angular-app-with-oop-1efdf91da577?source=collection_archive---------0-----------------------#2020-05-15">https://itnext.io/get-rid-of-if-statements-in-your-angular-app-with-oop-1efdf91da577?source=collection_archive---------0-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d159cefcf9f3886585e7d7eaf57df849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3axsvPw2MHlc7cyW-cWN5A.jpeg"/></div></div></figure><p id="49e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们第一次开始使用Angular时，我们很容易对Angular团队提供的开箱即用的功能感到惊讶。例如，用于状态管理的NgRx就像是它自己的小框架，存在于其中。还有，作为前端开发人员，我们需要赶上Bootstrap，Typescript，Javascript，Material，CSS预处理等。</p><blockquote class="kz la lb"><p id="c4ed" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated">当新技术淹没我们时，我们可能会忘记帮助我们向相关方封装逻辑的最佳软件工程范例之一:OOP。</p></blockquote><p id="777b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Angular是用Typescript构建的，这一事实降低了具有OOP <strong class="kd iu"> </strong>语言背景的开发人员的学习曲线。下面我们来看一个用例，如果觉得有帮助请跟我来。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="b68c" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">要求:</h1><h2 id="b9d9" class="ml lo it bd lp mm mn dn lt mo mp dp lx km mq mr mb kq ms mt mf ku mu mv mj mw bi translated">业务需求:</h2><p id="e604" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">我们正在建立一个广告网站，显示当地私人教师的课程。他希望以下内容成为MVP:</p><ol class=""><li id="66e9" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated">开设英语课程、历史课程、数学课程。</li><li id="3024" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">用蓝色突出显示英语课程</li><li id="df48" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">黄色的历史课程</li><li id="2768" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">红色的数学课程</li></ol><h2 id="fd5c" class="ml lo it bd lp mm mn dn lt mo mp dp lx km mq mr mb kq ms mt mf ku mu mv mj mw bi translated">其他:</h2><p id="8911" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">课程信息可以通过Web API获取。我们在演示应用程序中用http-data.service.ts来模拟它。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="b93f" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">解决方案:</h1><h2 id="397f" class="ml lo it bd lp mm mn dn lt mo mp dp lx km mq mr mb kq ms mt mf ku mu mv mj mw bi translated">方法1 -最简单和正确的解决方案:</h2><p id="e550" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">创建一个显示课程名称和价格的CourseComponent。在该组件中，我们用ngOnInit中的一些if检查来更改背景颜色。</p><figure class="nq nr ns nt gt ju"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">课程组件和测试用例</figcaption></figure><p id="2791" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lc">结果:</em></p><figure class="nq nr ns nt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/1baa697fdf4df2aff052bc08d2bf8e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGngrZ_bQEjO7YkjZ2IRJw.png"/></div></div></figure><p id="b965" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lc">完整app:</em><a class="ae ob" href="https://first-approach.stackblitz.io/" rel="noopener ugc nofollow" target="_blank">https://first-approach.stackblitz.io/</a><em class="lc"><br/>完整代码:</em><a class="ae ob" href="https://github.com/leopangchan/oop-ts-demo/tree/master/src/app" rel="noopener ugc nofollow" target="_blank">https://github . com/leopangchan/OOP-ts-demo/tree/master/src/app</a></p><p id="4285" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lc">这里的问题是什么:</em></p><ol class=""><li id="6fab" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated">CourseComponent的ngOnInit中的逻辑并不是一个接受输入，吐出输出的纯函数。在spec文件中，我们需要正确地设置组件来测试一个独立的逻辑。如果更多的逻辑进入ngOnInit，我们将无法单独测试依赖逻辑。</li><li id="fd5f" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">如果逻辑比着色更复杂，组件就不再具有代表性。</li></ol><h2 id="dbd2" class="ml lo it bd lp mm mn dn lt mo mp dp lx km mq mr mb kq ms mt mf ku mu mv mj mw bi translated"><strong class="ak">方法2——将逻辑移至服务:</strong></h2><p id="91ac" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">哦！我们有业务逻辑，想要一个更干净的组件？当然可以！我们可以把它转移到服务中。这样，很明显，逻辑只涉及CourseComponent，因为它位于由组件导入的CourseService中。它也变成了一个纯函数，更容易进行单元测试。</p><figure class="nq nr ns nt gt ju"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">带有服务的CourseComponent的重构版本</figcaption></figure><p id="b128" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lc">完整代码:</em><a class="ae ob" href="https://github.com/leopangchan/oop-ts-demo/tree/service-approach/src/app" rel="noopener ugc nofollow" target="_blank">https://github . com/leopangchan/OOP-ts-demo/tree/service-approach/src/app</a></p><p id="f7eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在看起来很不错。但是让我们问自己一个存在于所有软件工程师大脑中的问题:我们能做得更好吗？逻辑真的被封装在正确的地方了吗？</p><p id="5fff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lc">这里的问题是什么:</em></p><p id="098e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">if-check无法扩展。假设6个月后，导师发现他的市场合适，于是雇佣了更多的人。自然，他想在网站上提供更多的课程。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="9c38" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><em class="oc">新业务需求:</em></h1><ol class=""><li id="c207" class="nc nd it kd b ke mx ki my km od kq oe ku of ky nh ni nj nk bi translated">支持2种以上的课程</li><li id="5ba1" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">类型和价格改变背景颜色。</li></ol></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h2 id="9585" class="ml lo it bd lp mm mn dn lt mo mp dp lx km mq mr mb kq ms mt mf ku mu mv mj mw bi translated"><strong class="ak">方法2——将逻辑转移到服务中:</strong></h2><p id="9c9e" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">使用方法2，我们可以在CourseService的getColor()中再添加2个if-check。</p><figure class="nq nr ns nt gt ju"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">课程服务</figcaption></figure><p id="e3e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lc">完整代码:</em><a class="ae ob" href="https://github.com/leopangchan/oop-ts-demo/tree/service-approach-new-courses/src/app" rel="noopener ugc nofollow" target="_blank">https://github . com/leopangchan/OOP-ts-demo/tree/service-approach-new-courses/src/app</a></p><p id="043b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，它是可行的，并且是可单元测试的。</p><p id="bdb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lc">这里的问题是什么:</em></p><ol class=""><li id="5be0" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated">每个if块拥有不同的逻辑来获得背景色。尽管它是可行的并且是单元可测试的，但是if-check的列表可以扩展得更多，并且在每个块中可以有更多的嵌套if-check。</li><li id="9a90" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">如果将来我们有了除了着色之外的依赖于课程的逻辑，这个服务看起来就很难看了。</li></ol><h2 id="d975" class="ml lo it bd lp mm mn dn lt mo mp dp lx km mq mr mb kq ms mt mf ku mu mv mj mw bi translated"><strong class="ak">方法3:去掉带有多态性的if语句</strong></h2><p id="8f29" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">借助一些OOP直觉，我们可以快速指出父类——Course和子类(如EngCourse和HistCourse)之间的继承关系。我们可以在父节点中定义getColor()的默认实现，子节点可以根据需要覆盖它。所以，让我们一步一步地重构我们的应用程序:</p><p id="bfeb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">步骤1-创建父类和子类:</p><figure class="nq nr ns nt gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="eae1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我已经将课程界面更改为一个类，这允许我们拥有函数或类变量的值的默认实现。为了维护一个定义良好的API响应实体，我添加了一个CourseRes接口。</p><p id="755e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">步骤2 —创建课程实例:</p><p id="feed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据类型，我们需要不同的类实例。我已经重构了课程服务:</p><figure class="nq nr ns nt gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="954a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个工厂函数帮助我们利用四个OOP概念的基础:1 .抽象2。封装3。传承4。多态性。(鸣谢:在评论区大声喊出<a class="ae ob" href="https://medium.com/@muthuishere?source=responses---------2-----------------------" rel="noopener"> Muthukumaran </a>的建议。)</p><p id="fcd9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">步骤3 —使用工厂功能:</p><p id="5cc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们正在AppComponent中创建实例，以便将来其他组件可以重用它们。</p><figure class="nq nr ns nt gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4541" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一步—在课程组件中使用课程实例:</p><p id="9d21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在CourseComponent中调用getColor()。通过运行时多态性使用正确的实现。</p><figure class="nq nr ns nt gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9842" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lc">完整app:</em><a class="ae ob" href="https://oop-approach-2.stackblitz.io/" rel="noopener ugc nofollow" target="_blank">https://oop-approach-2.stackblitz.io/</a><em class="lc">T5】完整代码:</em><a class="ae ob" href="https://github.com/leopangchan/oop-ts-demo/tree/oop-approach/src/app" rel="noopener ugc nofollow" target="_blank">https://github . com/leopangchan/OOP-ts-demo/tree/OOP-approach/src/app</a></p><p id="7a9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lc">这种方法有什么好处:</em></p><ol class=""><li id="e449" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated">易于单元测试。因为它是用纯类和函数构建的，所以我们在编写测试时不需要模仿服务或组件(请查看完整代码以了解更多细节)。</li><li id="96e0" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">与外界高度隔绝</li><li id="31c0" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">CourseComponent是哑的/表示性的</li><li id="14e5" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">面向对象背景的开发人员易于阅读</li><li id="acc1" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">没有很长的假设检验列表</li></ol><h1 id="fe82" class="ln lo it bd lp lq og ls lt lu oh lw lx ly oi ma mb mc oj me mf mg ok mi mj mk bi translated">总结:</h1><p id="50d2" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">为了展示实现，业务需求被过度简化了。现实世界中的应用程序极有可能具有比这复杂100倍或更多的逻辑。那时，将逻辑封装到每个类类型是一个巨大的可伸缩性提升！</p></div></div>    
</body>
</html>