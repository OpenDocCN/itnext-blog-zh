<html>
<head>
<title>Accessing the DOM is not equal accessing the DOM — live vs. static element collections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">访问DOM不等于访问DOM——活动元素集合和静态元素集合</h1>
<blockquote>原文：<a href="https://itnext.io/accessing-the-dom-is-not-equal-accessing-the-dom-live-vs-static-element-collections-a4d8c4b9e50a?source=collection_archive---------4-----------------------#2018-03-30">https://itnext.io/accessing-the-dom-is-not-equal-accessing-the-dom-live-vs-static-element-collections-a4d8c4b9e50a?source=collection_archive---------4-----------------------#2018-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/31ceef6919f667ebf4efa4648a036fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKb9N-aXA8az3VKTBRTM1A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片:Unsplash.com伊姆基兰</figcaption></figure><blockquote class="kc kd ke"><p id="5d9e" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><a class="ae le" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Faccessing-the-dom-is-not-equal-accessing-the-dom-live-vs-static-element-collections-a4d8c4b9e50a%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="6e99" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">当浏览器接收到一个HTML文档时，它会创建<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" rel="noopener ugc nofollow" target="_blank">文档对象模型(DOM) </a>，这是一个文档的树形表示。还有一些DOM方法，允许我们作为前端开发人员以编程方式访问部分解析过的文档，并为网站添加功能。到目前为止一切顺利！</p><p id="8506" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">您很快会遇到的一种方法是<code class="fe li lj lk ll b">querySelectorAll</code>，它用于访问DOM中的元素。让我们快速看一下它是如何工作的。</p><h1 id="e171" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用<code class="fe li lj lk ll b">querySelectorAll</code>访问DOM</h1><pre class="mk ml mm mn gt mo ll mp mq aw mr bi"><span id="f688" class="ms ln iq ll b gy mt mu l mv mw">// &lt;html&gt;<br/>// &lt;head&gt;...&lt;/head&gt;<br/>// &lt;body&gt;<br/>//   &lt;ul&gt;<br/>//     &lt;li&gt;foo&lt;/li&gt;<br/>//     &lt;li&gt;bar&lt;/li&gt;<br/>//     &lt;li&gt;baz&lt;/li&gt;<br/>//   &lt;/ul&gt;<br/>// &lt;/body&gt;<br/>// &lt;/html&gt;</span><span id="f81e" class="ms ln iq ll b gy mx mu l mv mw">const listItems = document.querySelectorAll('li'); console.log(listItems);        // NodeList(3) [li, li, li] console.log(listItems.length); // 3</span><span id="9bc7" class="ms ln iq ll b gy mx mu l mv mw">for (let i = 0; i &lt; listItems.length; i++) { <br/>  console.log(listItems[i].innerText);<br/>} </span><span id="4291" class="ms ln iq ll b gy mx mu l mv mw">// foo<br/>// bar<br/>// baz</span></pre><p id="7c11" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">多亏了现在好的开发工具，当你把一个对象记录到控制台时，浏览器会显示它的类型。正如你在上面看到的，<code class="fe li lj lk ll b">document.querySelectorAll</code>的返回值是一个<code class="fe li lj lk ll b">NodeList</code>。</p><p id="89d0" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">在过去，与<code class="fe li lj lk ll b">NodeLists</code>打交道对我来说意味着一些惊喜。它们看起来像数组，但实际上不是，特定MDN文章中的一个大警告框清楚地描述了这一事实。</p><blockquote class="kc kd ke"><p id="6692" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><em class="iq">虽然NodeList不是一个数组，但是可以使用forEach()对其进行迭代。几个较老的浏览器还没有实现这个方法。也可以使用Array.from. </em>将其转换为数组</p></blockquote><p id="88de" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">让我惊讶的是今天<code class="fe li lj lk ll b">NodeLists</code>有一个定义好的<code class="fe li lj lk ll b">forEach</code>方法，因为当我开始从事web开发时，这个方法是缺失的，而这正是几年前我多次遇到的陷阱之一。<code class="fe li lj lk ll b">NodeLists</code>提供的其他方法有<code class="fe li lj lk ll b">item</code>、<code class="fe li lj lk ll b">entries</code>、<code class="fe li lj lk ll b">keys</code>和<code class="fe li lj lk ll b">values</code>。如果你想了解更多，我推荐你去看看<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList" rel="noopener ugc nofollow" target="_blank">MDN的文章</a>。</p><h1 id="5646" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">现场收藏的魔力</h1><p id="5ca0" class="pw-post-body-paragraph kf kg iq ki b kj my kl km kn mz kp kq lf na kt ku lg nb kx ky lh nc lb lc ld ij bi translated">当我上周阅读<code class="fe li lj lk ll b">NodeLists</code>的文档时，我注意到了一些我以前从未见过的东西:</p><blockquote class="kc kd ke"><p id="8f2c" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><em class="iq">在某些情况下，节点列表是一个活动集合[…] </em></p></blockquote><h1 id="ba07" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">等等，什么？现场收藏？在某些情况下？</h1><p id="d51c" class="pw-post-body-paragraph kf kg iq ki b kj my kl km kn mz kp kq lf na kt ku lg nb kx ky lh nc lb lc ld ij bi translated">结果是<code class="fe li lj lk ll b">NodeLists</code>的行为因你如何访问它们而异。让我们看看同一个文档，以不同的方式检索元素。</p><pre class="mk ml mm mn gt mo ll mp mq aw mr bi"><span id="e539" class="ms ln iq ll b gy mt mu l mv mw">// &lt;html&gt; <br/>// &lt;head&gt;...&lt;/head&gt;<br/>// &lt;body&gt;<br/>//   &lt;ul&gt;<br/>//     &lt;li&gt;foo&lt;/li&gt;<br/>//     &lt;li&gt;bar&lt;/li&gt;<br/>//     &lt;li&gt;baz&lt;/li&gt;<br/>//   &lt;/ul&gt;<br/>// &lt;/body&gt;<br/>// &lt;/html&gt;</span><span id="43e7" class="ms ln iq ll b gy mx mu l mv mw">// retrieve element using querySelectorAll<br/>const listItems_querySelectorAll = document.querySelectorAll('li'); console.log(listItems_querySelectorAll);<br/>// NodeList(3) [li, li, li] </span><span id="675d" class="ms ln iq ll b gy mx mu l mv mw">// retrieve element using childNodes<br/>const list = document.querySelector('ul');<br/>const listItems_childNodes = list.childNodes; console.log(listItems_childNodes);<br/>// NodeList(7) [text, li, text, li, text, li, text]</span></pre><p id="d102" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">明显的区别是，当您通过<code class="fe li lj lk ll b">childNodes</code>访问元素时，包含了更多的元素。该集合中的文本节点是您在HTML中看到的空格和换行符。</p><pre class="mk ml mm mn gt mo ll mp mq aw mr bi"><span id="0401" class="ms ln iq ll b gy mt mu l mv mw">console.log(listItems_childNodes[0].textContent) // "<br/> "</span></pre><p id="eea5" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">但我发现的不是这样。两个<code class="fe li lj lk ll b">NodeLists</code>的最大区别是<strong class="ki ir">一个是活动的，一个是静态的</strong>，当我向<code class="fe li lj lk ll b">ul</code>元素添加另一个列表项时，它就可见了。</p><pre class="mk ml mm mn gt mo ll mp mq aw mr bi"><span id="a67b" class="ms ln iq ll b gy mt mu l mv mw">list.appendChild(document.createElement('li'));</span><span id="5271" class="ms ln iq ll b gy mx mu l mv mw">// static NodeList via querySelectorAll console.log(listItems_querySelectorAll);<br/>// NodeList(3) [li, li, li]</span><span id="c800" class="ms ln iq ll b gy mx mu l mv mw">// live NodeList via childNodes<br/>console.log(listItems_childNodes);<br/>// NodeList(8) [text, li, text, li, text, li, text, li]</span></pre><p id="7f5b" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">😲如您所见，<code class="fe li lj lk ll b">listItems_childNodes</code>(通过<code class="fe li lj lk ll b">childNodes</code>访问的<code class="fe li lj lk ll b">NodeList</code>)反映了DOM的元素，即使添加或删除了元素。由<code class="fe li lj lk ll b">querySelectorAll</code>返回的集合保持不变。<strong class="ki ir">那对我来说完全是新消息！</strong></p><h1 id="af5a" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">不是每个查询DOM的方法都返回一个节点列表</h1><p id="7483" class="pw-post-body-paragraph kf kg iq ki b kj my kl km kn mz kp kq lf na kt ku lg nb kx ky lh nc lb lc ld ij bi translated">这变得更加令人困惑…你可能知道也有像<code class="fe li lj lk ll b">getElementsByClassName</code>和<code class="fe li lj lk ll b">getElementsByTagName</code>这样的方法可以让你访问DOM元素。原来这些方法返回不同的东西。</p><pre class="mk ml mm mn gt mo ll mp mq aw mr bi"><span id="83f6" class="ms ln iq ll b gy mt mu l mv mw">// &lt;html&gt;<br/>// &lt;head&gt;...&lt;/head&gt;<br/>// &lt;body&gt;<br/>//   &lt;ul&gt;<br/>//     &lt;li&gt;foo&lt;/li&gt;<br/>//     &lt;li&gt;bar&lt;/li&gt;<br/>//     &lt;li&gt;baz&lt;/li&gt;<br/>//   &lt;/ul&gt;<br/>// &lt;/body&gt;<br/>// &lt;/html&gt; </span><span id="175f" class="ms ln iq ll b gy mx mu l mv mw">const listItems_getElementsByTagName = document.getElementsByTagName('li');</span><span id="9cfa" class="ms ln iq ll b gy mx mu l mv mw">console.log(listItems_getElementsByTagName);<br/>// HTMLCollection(3) [li, li, li]</span></pre><p id="b53c" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">哦好吧…一个<code class="fe li lj lk ll b">HTMLCollection</code>。那么另一种类型是什么呢？它只包括匹配元素，不包括文本节点，它只提供两个方法(<code class="fe li lj lk ll b">item</code>和<code class="fe li lj lk ll b">namedItem</code>)和<strong class="ki ir">它是活动的</strong>，这意味着它还将包括添加的元素。</p><pre class="mk ml mm mn gt mo ll mp mq aw mr bi"><span id="438c" class="ms ln iq ll b gy mt mu l mv mw">listItems_getElementsByTagName[0].parentNode.appendChild(document.createElement('li'));</span><span id="d8cc" class="ms ln iq ll b gy mx mu l mv mw">// live HTMLCollection via getElementsByTagName console.log(listItems_getElementsByTagName);<br/>// HTMLCollection(4) [li, li, li, li]</span></pre><p id="382b" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">更复杂的是，当您使用<code class="fe li lj lk ll b">document.forms</code>(是的，您可以不查询DOM而访问表单)或通过元素的<code class="fe li lj lk ll b">children</code>属性访问子元素时，也会返回<code class="fe li lj lk ll b">HTMLCollections</code>。</p><pre class="mk ml mm mn gt mo ll mp mq aw mr bi"><span id="b2e4" class="ms ln iq ll b gy mt mu l mv mw">// &lt;html&gt;<br/>// &lt;head&gt;...&lt;/head&gt;<br/>// &lt;body&gt;<br/>//   &lt;ul&gt;<br/>//     &lt;li&gt;foo&lt;/li&gt;<br/>//     &lt;li&gt;bar&lt;/li&gt;<br/>//     &lt;li&gt;baz&lt;/li&gt;<br/>//   &lt;/ul&gt;<br/>// &lt;/body&gt;<br/>// &lt;/html&gt;</span><span id="2f51" class="ms ln iq ll b gy mx mu l mv mw">const list = document.querySelector('ul');<br/>const listItems = list.children;<br/>console.log(listItems); // HTMLCollection [li, li, li]</span></pre><p id="80ff" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">当你看的说明书<code class="fe li lj lk ll b"><a class="ae le" href="https://dom.spec.whatwg.org/#htmlcollection" rel="noopener ugc nofollow" target="_blank">HTMLCollection</a></code>时你会发现下面这句话:</p><blockquote class="kc kd ke"><p id="c192" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">HTMLCollection是我们无法摆脱的历史文物。虽然当然欢迎开发人员继续使用它，但是新的API标准设计人员不应该使用它[…] </p></blockquote><p id="5461" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">这种说法清楚地表明，在一定时间内<code class="fe li lj lk ll b">NodeList</code>和<code class="fe li lj lk ll b">HTMLCollection</code>是相互竞争的标准，而现在我们同时被这两种标准所困。</p><h1 id="247b" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">进化网络是复杂的</h1><p id="cc67" class="pw-post-body-paragraph kf kg iq ki b kj my kl km kn mz kp kq lf na kt ku lg nb kx ky lh nc lb lc ld ij bi translated">所以，今天我们在<code class="fe li lj lk ll b">children</code>(直播<code class="fe li lj lk ll b">HTMLCollection</code>)旁边有<code class="fe li lj lk ll b">childNodes</code>(直播<code class="fe li lj lk ll b">NodeList</code>)，在<code class="fe li lj lk ll b">getElementsByTagName</code>(直播<code class="fe li lj lk ll b">HTMLCollection</code>)旁边有<code class="fe li lj lk ll b">querySelectorAll</code>(静态<code class="fe li lj lk ll b">NodeList</code>)以及一些意想不到的边缘情况，这取决于你如何访问元素。</p><p id="d05d" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">就我个人而言，我很惊讶我以前从来没有听说过活动集合和静态集合，我认为在处理DOM时发现这一细节有一天会为我节省很多时间，因为找到由活动集合引起的bug肯定是很难找到的。</p><p id="be15" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated"><em class="kh">如果你想体验一下所描述的行为，你可以看看这个</em> <a class="ae le" href="https://codepen.io/stefanjudis/pen/NYXGbp" rel="noopener ugc nofollow" target="_blank"> <em class="kh">代码。</em></a></p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="a849" class="pw-post-body-paragraph kf kg iq ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated"><em class="kh">原载于www.stefanjudis.com</em><a class="ae le" href="https://www.stefanjudis.com/blog/accessing-the-dom-is-not-equal-accessing-the-dom/" rel="noopener ugc nofollow" target="_blank"><em class="kh"/></a><em class="kh">。</em></p></div></div>    
</body>
</html>