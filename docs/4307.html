<html>
<head>
<title>Introducing LeanSharp: A look at a different side of CSharp.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍LeanSharp:看看CSharp的另一面。</h1>
<blockquote>原文：<a href="https://itnext.io/introducing-leansharp-a-look-at-a-different-side-of-csharp-e6755942b1aa?source=collection_archive---------2-----------------------#2020-06-04">https://itnext.io/introducing-leansharp-a-look-at-a-different-side-of-csharp-e6755942b1aa?source=collection_archive---------2-----------------------#2020-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/148cb2cc4a6ec9eadbc369d0401cc6ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVm2phDL3NxB6OJsMaCp1w.jpeg"/></div></div></figure><p id="6d89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在成为面向对象编程(OOP)的粉丝十多年后，我发现了函数式编程，从那以后我看待软件开发的方式就再也不一样了。尽管我尽量不花时间说明一种范式比另一种更好。在这个世界上，事物都是相对的，每个人都有自己看待事物的方式，因此很容易做出相对的假设和陈述。</p><p id="3383" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我主要写函数式JavaScript，但说到C#，我喜欢函数式和OOP风格的结合。他们可以住在一起，事实上，他们可以成为很好的朋友。在JavaScript中使用函数式编程一段时间后(在真实的生产代码中)，我开始在C#中做同样的事情；在用C#主要做了一年的函数式/声明式编程之后，我决定创建一个Nuget包(和相关的公共Github库),它包含了所有的声明式/函数式结构，使我们的团队能够大大减少错误(当然，借助于一个好的测试策略)。在这一年中，我们犯了一些错误，我们学到了很多，我们完善了方法和技术。</p><p id="ff5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果，<strong class="ka ir">lean sharp</strong><a class="ae kw" href="https://github.com/ericrey85/LeanSharp/" rel="noopener ugc nofollow" target="_blank">https://github.com/ericrey85/LeanSharp/</a>，它也作为一个同名的Nuget包存在。这篇文章假装是一篇非常入门的文章，在那里我可以与其他C#开发人员分享，这些东西不是在理论上，而是在实践中，允许我们创建更好、更健壮的代码。我并不是说这种风格适合所有人，或者比你现在的风格更好，我只是认为它可能会向你展示你不知道的C#的一面，并且有一天，你可能会从中受益。</p><p id="0c25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用Github资源库上的<em class="kx">入门</em>会话来指导示例和解释。如果您从手机导航到Github，请确保点击README.md文件，否则您将无法看到该部分。</p><p id="2e2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">入门:</strong></p><p id="2df2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装LeanSharp Nuget包:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7e3c" class="lh li iq ld b gy lj lk l ll lm">Install-Package LeanSharp</span></pre><p id="77df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，确保在要开始使用的C#文件中添加一个名称空间引用:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="fa25" class="lh li iq ld b gy lj lk l ll lm">using LeanSharp;</span></pre><p id="ebbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">面向铁路的编程(ROP): </strong></p><p id="8976" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ROP是一种处理错误的函数式方法。它从一个<em class="kx">结果</em>开始，在任何给定的时间，它要么有一些数据(成功)，要么有一个错误(失败)。这种方法在函数式编程领域通常被称为要么单子，可能是右单子(成功)或左单子(错误)。这种方法，除了别的以外，允许我们摆脱异常的副作用。我相信ROP这个术语是由Scott Wlaschin创造的，他因https://fsharpforfunandprofit.com/的网站<a class="ae kw" href="https://fsharpforfunandprofit.com/" rel="noopener ugc nofollow" target="_blank">和他关于F#和函数式编程的演讲而闻名，尽管我第一次听说它是在https://www.youtube.com/watch?v=uM906cqdFWE</a>的<a class="ae kw" href="https://www.youtube.com/watch?v=uM906cqdFWE" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2b16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka ir"> LeanSharp </strong>，<strong class="ka ir"> </strong>中，与ROP相关的初始代码取自<a class="ae kw" href="https://github.com/habaneroofdoom/AltNetRop" rel="noopener ugc nofollow" target="_blank">https://github.com/habaneroofdoom/AltNetRop</a>，然后基于现实世界的使用，它成长(现在包括更多的方法和一个声明性的try/catch方法)到它当前的状态。</p><p id="c47b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">说够了，让我们看一些代码！</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="63c0" class="lh li iq ld b gy lj lk l ll lm">var firstResult = Result&lt;int, string&gt;.Succeeded(2);</span><span id="02d7" class="lh li iq ld b gy ln lk l ll lm">var secondResult = firstResult.Map(two =&gt; two + 3); // Success(5)</span><span id="7cde" class="lh li iq ld b gy ln lk l ll lm">var finalResult = secondResult<br/>     .Bind(five =&gt; Result&lt;int, string&gt;.Succeeded(five + 5));</span><span id="bdf7" class="lh li iq ld b gy ln lk l ll lm">// Success (10)</span></pre><p id="7f0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您发现自己用相同的泛型参数重复结果<s f="">,那么您可以将一个静态using语句添加到。cs文件，然后您就不必再重复它了。</s></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="132a" class="lh li iq ld b gy lj lk l ll lm">using static LeanSharp.Result&lt;int, string&gt;;</span></pre><p id="7abc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f944" class="lh li iq ld b gy lj lk l ll lm">Succeeded(2).Map(two =&gt; two + 3).Bind(five =&gt; Succeeded(five + 5))</span></pre><p id="37d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何将可能抛出异常的方法转换成不会抛出异常的方法？</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9877" class="lh li iq ld b gy lj lk l ll lm">public async Task&lt;Result&lt;Customer, Exception&gt;&gt; Insert(Customer customer)<br/>{<br/>  try<br/>  {<br/>    // Try to asynchronously insert the Customer into the DB.<br/>    // ...<br/>    return Result&lt;Customer, Exception&gt;.Succeeded(customer);<br/>  }<br/>  catch (Exception ex)<br/>  {<br/>    return Result&lt;Customer, Exception&gt;.Failed(ex);<br/>  }<br/>}</span></pre><p id="fd90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<strong class="ka ir"> LeanSharp </strong>您可以更进一步，将上面的try/catch语句转换为等价的声明性表达式，其中删除了样板catch逻辑和显式成功创建:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8991" class="lh li iq ld b gy lj lk l ll lm">public async Task&lt;Result&lt;Customer, Exception&gt;&gt; Insert(<br/> Customer customer)<br/>=&gt; await Try.ExpressionAsync(async () =&gt;<br/>{<br/>  // Try to asynchronously insert the Customer into the DB.<br/>  // ...<br/>  return customer;<br/>});</span></pre><p id="fff1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在获得结果(从任务内部)之后，可以链接像Map和Bind这样的方法，并且只有当结果包含成功时，传递给这些方法的委托才会运行。</p><p id="340f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们向Result添加了所有必要的方法，所以您也可以使用LINQ查询语法(不要忘记静态using语句来编译该代码):</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d38a" class="lh li iq ld b gy lj lk l ll lm">var result = from s1 in Succeeded(1)<br/>             from s2 in Succeeded(2)<br/>             from s3 in Succeeded(3)<br/>             select s1 + s2 + s3; // Success(6)</span></pre><h1 id="e06e" class="lo li iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">避免处理空值，可能的单子:</h1><p id="8309" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated"><strong class="ka ir"> LeanSharp </strong>中的Maybe monad摘自<a class="ae kw" href="https://gist.github.com/johnazariah/d95c03e2c56579c11272a647bab4bc38" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/johnazariah/d 95 c 03 e 2c 56579 c 11272 a 647 Bab 4 BC 38</a>，可以随意导航到那里查看各种示例和精彩的解释。</p><p id="f246" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看如何使用它:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="081a" class="lh li iq ld b gy lj lk l ll lm">public Maybe&lt;Order&gt; GetOrderById(int id)<br/>{<br/>  var order = GetOrderFromDB(id);<br/>  return Maybe&lt;Order&gt;.Some(order);<br/>}</span></pre><p id="c6a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在调用GetOrderById时不必处理null(或者忘记它并以NullReferenceException结束)，您可以在Maybe上执行安全操作，它们是安全的，因为如果没有找到订单，操作将不会执行，并且Maybe封装并集中了这样做的逻辑。此外，对于这个签名，GetOrderById是诚实的，它非常明确地表明订单可能找不到，这是一条非常重要的信息。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="299f" class="lh li iq ld b gy lj lk l ll lm">/* <br/>AssingOrderToCustomer returns a newly created Customer with the <br/>given order assgined to it.<br/>What if the order was not found? Leave that to the Maybe Monad. <br/>*/<br/><br/>var customerId = GetOrderById(5)<br/>  .Map(order =&gt; AssingOrderToCustomer(customer, order));<br/>  .GetOrElse(customer =&gt; customer.Id, 0);</span></pre><h1 id="b2e1" class="lo li iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">声明性处置(制成表达式):</h1><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1e66" class="lh li iq ld b gy lj lk l ll lm">var result = await Dispose.UsingAsync(() =&gt; new DisposableInstance, async disposableInstance =&gt;<br/>{<br/>  // Add in here whatever you need in the body of the dipose.<br/>  // ...<br/>  return disposableInstance.DoTheWork();<br/>});</span></pre><p id="d1a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，尽量支持表达式而不是语句。表达式是可重用的，它们可以从一个方法中返回或者传入一个方法。语句不能做到这些。这是一项如此强大的技术，以至于微软在C# 8中添加了使用表达式的<em class="kx">来处理一次性对象。并且他们用<em class="kx">开关</em>做了同样的表情。</em></p><p id="42e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在函数式编程的核心，你会发现映射函数。可以把它们想象成一个函数/方法，对输入数据进行一些转换，产生一些输出。一些代码？当然可以！但是首先，让我们看看在C#中这样做的传统和必要的方式:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="016f" class="lh li iq ld b gy lj lk l ll lm">var customer = GetCustomerById(id);<br/>var billModel = new BillModel<br/>{<br/>  CustomerId = customer.Id,<br/>  CustomerName = customer.FullName,<br/>  StreetName = customer.StreetName<br/>};</span></pre><p id="e86d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我说的那个地图怎么样？给你:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8ac3" class="lh li iq ld b gy lj lk l ll lm">var billModel = GetCustomerById(id).MapTo(c =&gt; new BillModel<br/>{<br/>  CustomerId = c.Id,<br/>  CustomerName = c.FullName,<br/>  StreetName = customer.StreetName<br/>});</span></pre><p id="19dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MapTo的命名是为了避免与Result类中的Map扩展方法和Maybe类中的instance方法发生名称冲突。</p><h1 id="87a1" class="lo li iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">管道(可组合管道):</h1><p id="c311" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">当我试图找到一种方法来编写同步和异步代码，同时支持延迟执行时，我想到了<em class="kx">管道</em>类。我在我的文章<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/fun-csharp-pure-lazy-and-async-pipeline-creation-204923eb6e14">https://it next . io/fun-cs harp-pure-lazy-and-async-pipeline-creation-204923 eb6e 14</a>中谈到了它们。请随意浏览该文章，以了解更多关于管道的信息。让我们看一些例子。</p><p id="8c23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用方法组成管道。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a648" class="lh li iq ld b gy lj lk l ll lm">int AddFour(int number) =&gt; number + 4;</span><span id="277b" class="lh li iq ld b gy ln lk l ll lm">var pipeline = CreatePipeline.With(() =&gt; 5).Select(AddFour);</span><span id="7558" class="lh li iq ld b gy ln lk l ll lm">var task = pipeline.Flatten(); // Task(9)</span></pre><p id="d43a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用另一个管道组成管道:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d4c9" class="lh li iq ld b gy lj lk l ll lm">var initialPipeline = CreatePipeline.With(() =&gt; 5);</span><span id="891b" class="lh li iq ld b gy ln lk l ll lm">var finalPipeline = initialPipeline.SelectMany(<br/>  five =&gt; CreatePipeline.With(() =&gt; five + 4));</span><span id="875f" class="lh li iq ld b gy ln lk l ll lm">var task = finalPipeline.Flatten(); // Task(9)</span></pre><p id="01fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">又是你好一元作文！</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9b5d" class="lh li iq ld b gy lj lk l ll lm">var firstPipeline = CreatePipeline.With(() =&gt; 5);<br/>var secondPipeline = CreatePipeline.With(() =&gt; 6);<br/>var thirdPipeline = CreatePipeline.With(() =&gt; 9);</span><span id="70d0" class="lh li iq ld b gy ln lk l ll lm">var finalPipeline = from firstValue in firstPipeline<br/>                    from secondValue in secondPipeline<br/>                    from thirdValue in thirdPipeline<br/>                    select firstValue + secondValue + thirdValue;</span><span id="bafd" class="lh li iq ld b gy ln lk l ll lm">var task = finalPipeline.Flatten();  // Task(20)</span></pre><p id="6478" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要查看使用管道的更真实的示例，可以查看<a class="ae kw" href="https://gist.github.com/ericrey85/da9671a22234ef981e5ee3653face4af" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ericrey 85/da 9671 a 22234 ef 981 e 5 ee 3653 face 4 af</a>。尽管请注意，我已经将名称从<em class="kx"> AzyncLazyPipeline </em>更改为简单的<em class="kx"> Pipeline </em>。</p><h1 id="ddb2" class="lo li iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">安全管道(可组合的无异常管道)</h1><p id="dadf" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在写了一年ROP代码后，我发现明显的缺点是为了等待链式任务(由异步方法产生)而产生了大量连续的await。为了让开发者免于此，我创建了<em class="kx">Pipeline；</em>但是有了它们，如果我想同时做ROP，就需要同时处理两个单子(管道和结果)。在看到多少次我用类似于<em class="kx">管道&lt;结果&lt;t成功，t失败&gt; &gt; </em>的东西来创建一个没有异常的管道后，我决定创建安全管道。</p><p id="78d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SafePipeline和Pipeline一样，是一个Monad，也是一个Monad Transformer，但它为您提供了一个封装ROP的管道，并知道如何根据底层值的成功或失败来采取行动。让我们看看用常规方法或另一个SafePipeline构建SafePipeline的几种方法。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a16d" class="lh li iq ld b gy lj lk l ll lm">async Task&lt;Result&lt;int, string&gt;&gt; GetFirstValue(int number) =&gt; await Result&lt;int, string&gt;.Succeeded(number + 4).AsTask();</span><span id="0780" class="lh li iq ld b gy ln lk l ll lm">async Task&lt;Result&lt;int, string&gt;&gt; GetSecondValue(int number) =&gt; await Result&lt;int, string&gt;.Succeeded(number + 5).AsTask();</span><span id="53eb" class="lh li iq ld b gy ln lk l ll lm">async Task&lt;int&gt; GetThirdValue(int number)<br/>=&gt; await (number + 4).AsTask();</span><span id="551f" class="lh li iq ld b gy ln lk l ll lm">int GetFourthValue(int number) =&gt; number + 5;</span><span id="36e1" class="lh li iq ld b gy ln lk l ll lm">SafePipeline&lt;int, Exception&gt; GetFithValue(int number) =&gt; <br/>CreateSafePipeline.TryWith(() =&gt; number + 6);</span><span id="7521" class="lh li iq ld b gy ln lk l ll lm">var firstPipe = CreateSafePipeline.With(() =&gt; GetFirstValue(5));<br/>var secondPipe = firstPipe.Select(GetSecondValue);<br/>var thirdPipe = secondPipe.Select(GetThirdValue);<br/>var fourthPipe = secondPipe.Select(GetFourthValue);<br/>var fithPipe = fourthPipe.SelectMany(<br/>  value =&gt; GetFithValue(value).ToStringFailure());</span><span id="d1f4" class="lh li iq ld b gy ln lk l ll lm">var finalPipeline = from firstValue in secondPipe<br/>                    from secondValue in thirdPipe<br/>                    from thirdValue in fithPipe<br/>                    select firstValue + secondValue + thirdValue;</span><span id="f083" class="lh li iq ld b gy ln lk l ll lm">var result = await finalPipeline.Flatten(); // Success (57)</span></pre><p id="64de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">抛出异常的操作现在可以安全使用了，如果出现异常，它会被封装在一个失败的结果中。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="df9a" class="lh li iq ld b gy lj lk l ll lm">int InvalidDivideByZeroOperation(int number) =&gt; number / 0;</span><span id="151c" class="lh li iq ld b gy ln lk l ll lm">async Task&lt;int&gt; GetValue(int number) =&gt; await (number + 4).AsTask();</span><span id="43d9" class="lh li iq ld b gy ln lk l ll lm">var firstPipeline = CreateSafePipeline.TryWith(<br/>  () =&gt; InvalidDivideByZeroOperation(5));</span><span id="742e" class="lh li iq ld b gy ln lk l ll lm">var finalPipeline = firstPipeline.Select(GetValue);</span><span id="c076" class="lh li iq ld b gy ln lk l ll lm">var result = await finalPipeline.Flatten(); // Failure (exception)</span></pre><p id="2587" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的一点是，SafePipeline是纯确定性的，不管调用多少次，只要传递相同的参数，就会得到相同的响应(在软件开发中有巨大的好处)，异常不会破坏这一点。</p><p id="d446" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以用<strong class="ka ir"> LeanSharp </strong>做很多事情。我希望这篇介绍是有帮助的，我也希望即使你不喜欢你在这篇文章中看到的思维转变，你至少喜欢C#的另一面，在那里声明性的方法被选择而不是命令性的方法，尽管没有说它们不能共存。在Github存储库中，您将能够找到超过100个单元测试，可以帮助您理解Nuget包中的类/方法是如何工作的。</p><p id="3d1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码快乐！</p></div></div>    
</body>
</html>