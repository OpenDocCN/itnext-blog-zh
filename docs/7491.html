<html>
<head>
<title>Retrofit : Detailed Analysis and Explanation - 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改装:详细分析和说明- 1</h1>
<blockquote>原文：<a href="https://itnext.io/retrofit-detailed-analysis-and-explanation-1-4e5a069423e2?source=collection_archive---------3-----------------------#2022-10-09">https://itnext.io/retrofit-detailed-analysis-and-explanation-1-4e5a069423e2?source=collection_archive---------3-----------------------#2022-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b0065d303e7415f363496c59f786adb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVKeFR1BJbhWaKbs0tnJfg.png"/></div></div></figure><p id="dd54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建Android应用程序时，HTTP请求用于连接服务器、上传或下载数据以及其他事情。众多开源的HTTP请求工具可用，包括<a class="ae kw" href="https://google.github.io/volley/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="kx"> Google的凌空</em> </strong> </a>，<a class="ae kw" href="https://loopj.com/android-async-http/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="kx"> loopj的Android异步Http </em> </strong> </a> <strong class="ka ir"> <em class="kx">，</em></strong><a class="ae kw" href="https://square.github.io/okhttp/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="kx">OkHttp</em></strong></a><strong class="ka ir"><em class="kx">，</em> </strong>以及<a class="ae kw" href="https://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank"> Square的<strong class="ka ir"> <em class="kx">改型</em></strong></a></p><p id="6f06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">改造，在我看来，毫无疑问是其中最伟大的几个，由于其独特和智能的设计。考虑到最少的改造代码，阅读它的源代码将是非常有益的。</p><h1 id="dc36" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">1.什么是翻新？</h1><p id="e492" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">根据改装官网:</p><blockquote class="mb mc md"><p id="525b" class="jy jz kx ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">Android和Java的类型安全HTTP客户端</p></blockquote><p id="126a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，它是一个基于OkHttp的RESTFUL API请求工具，在功能上与Google的凌空非常相似，但在用法上却截然不同。</p><p id="8170" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">凌空更基础，使用简单；当应用程序想要发送HTTP请求时，您需要创建一个请求对象，用GET、POST或其他方法指定请求，一个api地址和一个处理响应的回调。如果请求是POST，您必须另外设置请求对象内容，有时还需要设置标题。在将<em class="kx">请求</em>对象添加到<strong class="ka ir"> <em class="kx">请求队列</em> </strong>中、检查缓存并发送HTTP请求之后，凌空将协助您处理这种情况。如果一个应用程序有许多不同的API调用，代码将难以阅读，另一方面，翻新允许您调用Java方法以简单的方式请求API，因此应用程序中的代码将非常简洁，易于阅读</p><h1 id="dd5e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">2.如何使用改装</h1><p id="033a" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">比方说，你想请求一个API来查看来自一个网站的帖子信息，例如，我将在这里使用<em class="kx">jsonplaceholder</em></p><p id="231c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，您需要创建一个改造对象，并指定API的域名。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/7a67619191e927cd581d5e0c2ca652f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*11ASWyjuYAvb1d3D4W9JFA.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">图片:1</figcaption></figure><p id="5c42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要一个基于API调用的接口，这里将使用Java注释。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/87bb4dfb2c54bc8f7df546627335330b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*ffJFlNMphVV65qywwaXYSg.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">图片:2</figcaption></figure><p id="c520" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来改造对象(图1)将被用来创建一个<strong class="ka ir"><em class="kx">Jsonplaceholder</em></strong>对象</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/bcc5071791d1e6e6d808c0404801668e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*oYVeo8jmjXSN0XDk9zhu5g.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">图片:3</figcaption></figure><p id="601a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我们必须请求的API是<a class="ae kw" href="https://jsonplaceholder.typicode.com/posts" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts</a></p><p id="eb88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们创建一个调用对象来获取数据<strong class="ka ir"> <em class="kx">入队</em> </strong>方法用于异步发送请求，如果我们想以同步方式发送我们需要使用<strong class="ka ir"> <em class="kx">执行</em> </strong>方法。call对象还提供了其他方法，如<strong class="ka ir"> <em class="kx">取消</em> </strong>、<strong class="ka ir"> <em class="kx">取消</em> </strong>或其他方法来检查HTTP请求的状态等等。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/655705669e9a67e4e1563f980f5d1b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*2Dn9-GVLQsH-vl29_-9ivw.png"/></div></figure><p id="36d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看，Retrofit只需要构造一个接口来表示HTTP请求，然后它将允许我们请求一个API，就像我们调用Java方法一样。这不是很棒很不可思议吗？😀</p><h1 id="8ab9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.改造工作</h1><p id="28f0" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">从上面描述的对reference的使用中，可以清楚地看到，通过将Java接口转换成HTTP请求，然后通过OkHttp发送请求，reference起到了适配器的作用。</p><p id="c6ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AFAIK凌空创建一个<strong class="ka ir"> <em class="kx">请求</em> </strong> <em class="kx"> </em>对象，然后将它放入队列进行HTTP请求。请求通过<strong class="ka ir"><em class="kx">HttpUrlConnection</em></strong>放到单独的线程中</p><p id="a2ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以问题是:改造如何实现这一点？</p><p id="3549" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答案:Java动态代理</p><p id="b708" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在图3中，您可以看到Jsonplaceholder接口被传递给改型对象的create方法，作为回报，它给出Jsonplaceholder对象，然后该对象完成调用。</p><p id="09cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们深入研究一下create方法</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/4c120ce80f7821518debafc8c4f2006f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hPoNlW5M3bMcppxEvRGQg.png"/></div></div></figure><p id="41cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里得到代码<a class="ae kw" href="https://github.com/square/retrofit/blob/9b32c965ef31275627e35a862f584bcc7b9fa4e5/retrofit/src/main/java/retrofit2/Retrofit.java#L146-L168" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d7d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生了很多事情，所以让我们开始吧，</p><p id="903e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它通过执行函数<strong class="ka ir"><em class="kx">validateServiceInterface</em></strong>和<strong class="ka ir"><em class="kx">IllegalArgumentException</em></strong>初步验证提供的接口是否为有效接口，如果是无效接口则抛出。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/9c4ee02927f1ed26d24254919897b4f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CwSMr5f8OEatMW-jBd_KQ.png"/></div></div></figure><p id="f11e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来的create方法返回一个<strong class="ka ir"><em class="kx">proxy . newproxyinstance</em></strong>动态代理对象。现在的问题是:什么是动态代理？</p><p id="b79d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这本身就是一个高级的话题，你可以从其他地方了解它，但简单地说，它是Java代理设计模式的一部分，当程序需要扩展或修改现有类的某些功能时，它允许创建代理对象。在这种情况下，代理对象被实例化，而不是原始对象。代理类只创建一个代理，实际行为在其处理程序中被修改。处理程序完成它的扩展工作，然后继续调用原始方法，让它执行进一步的任务。当一个API <strong class="ka ir">接口</strong>实例被使用refuge创建时，从refuge返回的实例实际上是一个<strong class="ka ir">代理</strong>类，一个<strong class="ka ir">动态</strong>实现<strong class="ka ir">接口</strong>在<strong class="ka ir">运行时</strong>。</p><p id="c60e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主要要学习的是<strong class="ka ir"> <em class="kx"> InvocationHandler，</em> </strong>它是一个接口，允许我们拦截对对象的任何方法调用，并处理额外的行为。这个接口非常简单，只创建了一个需要被覆盖的方法<strong class="ka ir"> <em class="kx"> invoke </em> </strong></p><p id="86e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在回到改进<strong class="ka ir"><em class="kx">new proxy instance</em></strong>方法所需的3个参数</p><ol class=""><li id="25bc" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">传递了类的类加载器:(在我们的例子中是接口)，现在类加载器基本上是JRE的一部分，负责在运行时将<em class="kx"> Java </em>类动态加载到JVM。</li><li id="f8ad" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">类的接口列表:这是必需的，以便知道当调用这些接口的任何方法时，代理类将知道它。</li><li id="8d95" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><em class="kx">invocation handler</em><strong class="ka ir"><em class="kx">:这个</em> </strong>是实现<strong class="ka ir"><em class="kx">invocation handler</em></strong>和覆盖invoke方法的地方，这个invoke方法有3个参数:</li></ol><blockquote class="mb mc md"><p id="268c" class="jy jz kx ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">a.)代理对象:<em class="iq">在</em>上调用该方法的代理实例</p><p id="0469" class="jy jz kx ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">b.)方法:<em class="iq">对应于代理实例用来调用的接口方法的实例。声明方法的接口将是方法对象的声明类，该接口可以是代理类从其继承方法的代理接口的超接口。</em></p><p id="f117" class="jy jz kx ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">c.)args: <em class="iq">一个对象数组，或者</em> <strong class="ka ir"> null </strong> <em class="iq">如果接口方法不接受任何参数，则表示在代理实例上的方法调用中传递的参数值。适当的原语包装类的实例，如</em><strong class="ka ir">Java . lang . integer</strong><em class="iq">或</em><strong class="ka ir">Java . lang . boolean</strong><em class="iq">，用于封装原语类型的参数。</em></p></blockquote><p id="57ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来的改进使用<em class="kx"> java反射</em>来获取被调用方法的注释信息，并使用提供的参数创建一个<strong class="ka ir"> <em class="kx"> ServiceMethod </em> </strong>对象。</p><p id="5efa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">改造对象和方法对象被传递给ServiceMethod，然后service Method调用每个接口和解析器，并生成一个请求，其中包含API的域名、路径、HTTP请求方法、请求头、主体状态、是否为多部分等信息。<br/> OkHttpCall是Retrofit2中Call接口的默认实现，它默认使用OkHttp3作为Http请求客户端。</p><p id="28d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Java动态代理用于解析Java方法的注释，构建随后由OkHttp提交的请求，并拦截正在调用的Java方法。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/cd567f86fff1666a702e87f650d7c223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fu5DgNztANpW2GH0wmzYag.png"/></div></div></figure><p id="6866" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，对象进入调用方法，然后调用方法执行请求</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/56b57cf1d731492a3efe922e1ab00166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OF87sf0FW864W97cUXp0g.png"/></div></div></figure><h1 id="bfa1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">4.改造的四大支柱</h1><p id="dbdf" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">1️⃣ <strong class="ka ir"> <em class="kx">回调&lt; T &gt; </em> </strong>:这是改造返回其调用的地方，这里有两种方法:</p><ul class=""><li id="1315" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv nl nb nc nd bi translated"><code class="fe nm nn no np b">void onResponse(Response&lt;T&gt; response)</code></li><li id="a5d0" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv nl nb nc nd bi translated"><code class="fe nm nn no np b">void onFailure(Throwable t)</code></li></ul><p id="43c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2️⃣ <strong class="ka ir"> <em class="kx">转换器&lt; F，T &gt; : </em> </strong>其主要作用是将HTTP返回的数据解析成Java对象，主要是Xml、Json、protobuf等。创建改造对象时，您可以添加需要使用的转换器</p><p id="9989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3️⃣ <strong class="ka ir"> <em class="kx">调用&lt;&gt;</em></strong>:其主要作用是发送一个HTTP请求，默认实现的改型是<em class="kx"> OkHttpCall &lt; T &gt; </em>，你可以根据实际情况实现自己的调用类</p><p id="8d79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4️⃣<strong class="ka ir"><em class="kx">calladapter&lt;t&gt;:</em></strong>如上所述，<strong class="ka ir"> <em class="kx"> CallAdapter </em> </strong>只有一个<em class="kx"> responseType </em>属性和一个<strong class="ka ir"> <em class="kx"> &lt; R &gt; T adapt(调用&lt; R &gt; call) </em> </strong>方法，并且这个接口只有一个实现类，<strong class="ka ir"> <em class="kx"> DefaultCallAdapter这个类可能是为了支持RxJava而设计的</em></strong></p><h1 id="7c84" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">5.执行Http请求</h1><p id="4f73" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">如前所述，OkHttpCall实现了Call接口，并且是调用OkHttp3来提交Http请求的类。这个HTTP请求调用一个请求对象，该对象通过ServiceMethod的toRequest方法返回。</p><p id="10ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">综上，OkHttpCall调用ServiceMethod获取可能用于执行的请求对象，等待HTTP请求完成，然后将响应体传递给ServiceMethod，service method可以调用转换器接口将响应体转换成Java对象。</p><p id="9ae6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">综合以上，我们可以看到ServiceMethod几乎包含了一个API请求所需的所有信息，OkHttpCall需要从ServiceMethod获取一个请求对象，然后在收到应答后，还需要传入ServiceMethod，使用传递的转换器将其转换成Java对象</p><h1 id="afc7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi">~~ =&gt;</h1><p id="fe46" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">Retrofit非常巧妙的用注解来描述一个HTTP请求，把HTTP请求抽象成Java接口，然后用Java动态代理把接口的注解动态“解析”成HTTP请求，然后执行HTTP请求。</p><p id="74c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Retrofit的功能性很大程度上依赖于Java反射，代码中其实有很多细节，比如异常的捕捉、抛出和处理，还有很多工厂设计模式。</p><p id="a076" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">改型中的接口设计恰到好处，在创建改型对象时，给你更多更灵活的方式来处理你的需求，比如使用不同的转换器，使用不同的CallAdapter，这也给你提供了使用RxJava调用改型的可能性</p><p id="0ed0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我一直相信，一个没有读过好代码的人是不太可能写出好代码的。Picasso和retrieval是可扩展性强、耦合度低、易于插入的优秀代码的例子。</p><p id="4b10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">第2部分即将发布更多信息</em> …</p><p id="4228" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">🙂</p></div></div>    
</body>
</html>