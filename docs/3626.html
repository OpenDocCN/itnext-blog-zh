<html>
<head>
<title>Avoiding Parking Fines with Blazor and Geolocation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Blazor和地理定位功能避免停车罚款</h1>
<blockquote>原文：<a href="https://itnext.io/avoiding-parking-fines-with-blazor-and-geolocation-d45a9a831d93?source=collection_archive---------2-----------------------#2020-01-20">https://itnext.io/avoiding-parking-fines-with-blazor-and-geolocation-d45a9a831d93?source=collection_archive---------2-----------------------#2020-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4cdbb1bd76baf207d26189a137585726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOerMS-f37c-ywmxVAw_nQ.jpeg"/></div></div></figure><blockquote class="jy jz ka"><p id="7801" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://dev.to/ondrabus/how-to-build-an-interactive-spa-with-blazor-4k8n" rel="noopener ugc nofollow" target="_blank"> <em class="iq">上次</em> </a> <em class="iq">我们从头开始构建了一个带有交互式地图的客户端Blazor站点。但是对于帮助司机的网站来说，它需要更多的功能。它应该检查游客在哪里停车，并告诉他们在哪里可以支付多少钱。否则，他们会被罚款或者他们的车会被拖走。布拉佐能搞定吗？</em></p></blockquote><p id="15c2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在上一篇文章中，我开始建立一个网站，上面有我的家乡布尔诺的互动地图。该网站应该自动检查访客的位置，并解释在该地区停车的规则。如果适用，它应该在地图上显示最近的停车机器。</p><p id="efd5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我解释了数据模型和使用Blazor时需要的一些关键功能，比如Blazor模板、JS互操作、依赖注入和NuGet。</p><p id="adb3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">今天，我将解释更多的高级功能。该项目的剩余任务是:</p><ul class=""><li id="7f4e" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">通过游客的GPS坐标找到该区域</li><li id="15de" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">检查适用的限制</li><li id="d4d0" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">显示附近的停车机器</li></ul><h1 id="b8b8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">将GPS坐标与区域的多边形进行匹配</h1><p id="a453" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">我们知道网站的访问者站在哪里。坐标要么从他或她的移动设备中的GPS模块共享，要么通过点击交互式地图中的某个点来提供。在另一侧(即在CMS中),有其边界的所有区域和坐标。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/1ed99697f0d2c61425c091fad98dbecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z2iPuLEmtl9hPC4P.png"/></div></div></figure><p id="0ae8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">为了进行多边形内部的点计算，我创建了一个简单的辅助类<strong class="ke ir"> Helpers/ZoneHelper.cs </strong>。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="ac48" class="nf lt iq nb b gy ng nh l ni nj">public static class ZoneHelper {<br/>    public static bool IsPointInside(Location point, Zone zone)<br/>    {<br/>        // pre-check using a minimum bounding box<br/>        if (point.Latitude &lt; zone.LatMin || point.Latitude &gt; zone.LatMax || point.Longitude &lt; zone.LonMin || point.Longitude &gt; zone.LonMax)<br/>        {<br/>            return false;<br/>        }<br/><br/>        var polygon = zone.Points;<br/>        int i, j;<br/>        bool c = false;<br/>        for (i = 0, j = polygon.Count - 1; i &lt; polygon.Count; j = i++)<br/>        {<br/>            if ((((polygon[i].Latitude &lt;= point.Latitude) &amp;&amp; (point.Latitude &lt; polygon[j].Latitude)) || ((polygon[j].Latitude &lt;= point.Latitude) &amp;&amp; (point.Latitude &lt; polygon[i].Latitude))) &amp;&amp; (point.Longitude &lt; (polygon[j].Longitude - polygon[i].Longitude) * (point.Latitude - polygon[i].Latitude) / (polygon[j].Latitude - polygon[i].Latitude) + polygon[i].Longitude))<br/>            {<br/>                c = !c;<br/>            }<br/>        }<br/><br/>        return c;<br/>    }<br/> }</span></pre><p id="de35" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><em class="kd">注:多边形包含点的代码取自此处</em>  <em class="kd">的</em> <a class="ae la" href="https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html" rel="noopener ugc nofollow" target="_blank"> <em class="kd">。</em></a></p><p id="b070" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">您会看到这段代码已经为Zone使用了一个模型。它是<strong class="ke ir"> Models/Zone.cs </strong>中的一个POCO类(没有功能，只是数据的占位符):</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="1372" class="nf lt iq nb b gy ng nh l ni nj">public class Zone {<br/>   public decimal LatMin { get; set; }<br/>   public decimal LatMax { get; set; }<br/>   public decimal LonMin { get; set; }<br/>   public decimal LonMax { get; set; }<br/>   public List&lt;Location&gt; Points { get; set; }<br/>   public string Name { get; set; }<br/>}<!-- --> </span></pre><p id="1b15" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如果您还使用了一个headless CMS，那么您可以从存储在CMS中的内容类型定义中生成模型。然而，我更喜欢创建自己的模型并在实现中映射它们，因为它们更灵活。</p><p id="24a1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">为了从CMS获取区域数据，我创建了一个新服务<strong class="ke ir">Services/iclouddeliveryservice . cs</strong>。它是一个有意的接口，为我想使用的无头系统提供一些抽象。这让我有可能在未来转换到不同的供应商。</p><p id="9ade" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">此时，我正在使用Kontent存储所有数据。如果你对数据收集的实际实现感兴趣，可以看看<a class="ae la" href="https://github.com/ondrabus/dont-park-here-client/tree/065658749c1bf3e21077e574ef8cd30e8699efd7" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="de6e" class="nf lt iq nb b gy ng nh l ni nj">public interface ICloudDeliveryService<br/>{<br/>    Task&lt;IEnumerable&lt;T&gt;&gt; GetAllItems&lt;T&gt;();<br/>}</span></pre><p id="c45c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">云交付服务仅通过API收集数据。我们仍然需要获得这些区域的数据，并提供一种通过GPS坐标获得匹配区域的方法。当我们知道GPS位置或访问者点击地图时，前端会调用它。为此，我创建了<strong class="ke ir">服务/区域服务. cs </strong>。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="a8f2" class="nf lt iq nb b gy ng nh l ni nj">public class ZoneService<br/>{<br/>    private ICloudDeliveryService _cloudDeliveryService;<br/>    private static List&lt;Zone&gt; _zones = null;<br/><br/>    public ZoneService(ICloudDeliveryService cloudDeliveryService)<br/>    {<br/>        _cloudDeliveryService = cloudDeliveryService;<br/>    }<br/><br/>    public async Task&lt;IReadOnlyList&lt;Zone&gt;&gt; GetAllZonesAsync()<br/>    {<br/>        if (_zones == null)<br/>        {<br/>            _zones = await _cloudDeliveryService.GetAllItems&lt;Zone&gt;();<br/>        }</span><span id="d2f0" class="nf lt iq nb b gy nk nh l ni nj">        return _zones;<br/>    }</span><span id="85c2" class="nf lt iq nb b gy nk nh l ni nj">    public async Task&lt;Zone&gt; GetZoneByPoint(Location point)<br/>    {<br/>        var zones = await GetAllZonesAsync();<br/>        return zones.FirstOrDefault(z =&gt; ZoneHelper.IsPointInside(point, z));<br/>    }<br/>}</span></pre><p id="1563" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">前端将使用<code class="fe nl nm nn nb b">GetZoneByPoint</code>方法找到访问者所在的区域。所有服务都需要在<strong class="ke ir"> Startup.cs </strong>注册:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="1d06" class="nf lt iq nb b gy ng nh l ni nj">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    ...<br/>    services.AddSingleton&lt;ZoneService&gt;();<br/>    services.AddSingleton&lt;ICloudDeliveryService, KontentDeliveryService&gt;();<br/>}</span></pre><p id="ca97" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">最后，我们可以更新网站的前端部分。需要注入新的ZoneService:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="1602" class="nf lt iq nb b gy ng nh l ni nj">[Inject]<br/>protected ZoneService ZoneService { get; set; }</span></pre><p id="2805" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">让我们添加一个保存当前区域的属性。这使我们能够在页面上显示该区域的详细信息:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="acf3" class="nf lt iq nb b gy ng nh l ni nj">public Zone CurrentZone { get; set; }</span></pre><p id="37d3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">接下来，找到<code class="fe nl nm nn nb b">SetLocation</code>方法。每当点击地图时，即GPS坐标改变时，或者访问者的设备锁定了当前位置时，都会调用该方法。那时，我们要检查游客站在哪个区域。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="02b2" class="nf lt iq nb b gy ng nh l ni nj">protected async Task SetLocation(Location location)<br/>{<br/>    Console.WriteLine($"Check this position: {location.Latitude} {location.Longitude}");<br/>    Latitude = location.Latitude;<br/>    Longitude = location.Longitude;<br/>    CurrentZone = await ZoneService.GetZoneByPoint(location);<br/>    StateHasChanged();<br/>}</span></pre><p id="1242" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">并在页面上显示区域详细信息:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="12ba" class="nf lt iq nb b gy ng nh l ni nj">@if (CurrentZone != null)<br/>{<br/>    @:You are in the zone @CurrentZone.Name<br/>}<br/>else<br/>{<br/>    @:You can park here freely.<br/>}</span></pre><p id="3005" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在我们准备检查它在站点上是如何工作的。单击地图上市中心周围的任何地方，您应该会看到区域名称(如果有的话)。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/08cbc1282bde100ec5084b1c74fe8070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uZj1e1CVN3VoVWfN.png"/></div></div></figure><h1 id="b452" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">检查区域的限制</h1><p id="5813" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">尽管人口约为37万的布尔诺并不算大，而且分区只适用于市中心，但目前有许多停车区，以确保停车许可证只发放给居民居住的特定区域。但这不适用于游客。从他们的角度来看，只有3个区域——A、B和C——他们只定义了每小时停车需要支付的费用。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d41b7216f4ebb33b93b0edb480c43650.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/0*zOj8_c_IJy6TMRJ_.png"/></div></figure><p id="d06c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这几乎就像一个谜题。居民区是你需要放在一起的小块，游客区(A，B，C)是模板。我将游客区添加到CMS中，并将它们链接到各自的居民区(图中的1–02)。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/364659fe769b83ffee59bf0dd8fdb433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8OXqLsFrOhDoe19Z.png"/></div></div></figure><p id="6478" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">事实上，这个限制是一个字符串字段，它描述了我们需要向访问者显示的规则。因为这是一种新的内容类型，所以它需要在<strong class="ke ir">Models/visitor restriction . cs</strong>中拥有自己的模型:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="399c" class="nf lt iq nb b gy ng nh l ni nj">public class VisitorRestriction<br/>{<br/>    public string Description { get; set; }<br/>}</span></pre><p id="30e7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">当我将它链接到该区域时，它的模型也需要更新:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="3273" class="nf lt iq nb b gy ng nh l ni nj">public class Zone<br/>{<br/>    ...<br/>    public List&lt;VisitorRestriction&gt; VisitorRestrictions { get; set;} }</span></pre><p id="ea47" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">其余的数据收集和转换由映射配置处理，详情请查看<a class="ae la" href="https://github.com/ondrabus/dont-park-here-client/tree/065658749c1bf3e21077e574ef8cd30e8699efd7/Models/Generated/Mapping" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p><p id="fdaf" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">由于可能有多个限制，前端需要迭代所有限制并显示它们:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="e519" class="nf lt iq nb b gy ng nh l ni nj">...<br/>@if (CurrentZone != null)<br/>{<br/>    @:You are in the zone @CurrentZone.Name<br/>    @if (CurrentZone.VisitorRestrictions.Any())<br/>    {<br/>        @string.Join("&lt;br /&gt;", CurrentZone.VisitorRestrictions.Select(r =&gt; r.Description));<br/>    }<br/>}<br/>...</span></pre><p id="650d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">网站现在应该显示该区域的信息和停车规则:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/5bbf089a4779592aadeebc023da3a6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QZMi1LjR6u_toDpo.png"/></div></div></figure><h1 id="ba09" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">显示附近的停车机器</h1><p id="b75f" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">既然游客知道他们所站的地方有什么规则，那么最好把他们引导到最近的停车处，在那里他们需要登记他们的汽车。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/0f10720c62442fc2067f1d0473282c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-K1Oa28kfqr3ouZe.png"/></div></div></figure><p id="9e82" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如上图所示，停车机器及其GPS坐标已经存储在headless CMS中。我们将从与之前相同的例程开始—在<strong class="ke ir"> Models/ParkingMachine.cs </strong>中创建一个模型:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="ca58" class="nf lt iq nb b gy ng nh l ni nj">public class ParkingMachine<br/>{<br/>    public string Name { get; set; }<br/>    public Location Location { get; set; }<br/>}</span></pre><p id="a30a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">并添加一个新服务<strong class="ke ir">Services/parking machineservice . cs</strong>，用于从CMS获取停车机器:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="0f2d" class="nf lt iq nb b gy ng nh l ni nj">public class ParkingMachineService<br/>{<br/>    private ICloudDeliveryService _cloudDeliveryService;<br/>    private List&lt;ParkingMachine&gt; _parkingMachines = null;<br/><br/>    public ParkingMachineService(ICloudDeliveryService cloudDeliveryService)<br/>    {<br/>        _cloudDeliveryService = cloudDeliveryService;<br/>    }<br/>    public async Task&lt;List&lt;ParkingMachine&gt;&gt; GetAllParkingMachinesAsync()<br/>    {<br/>        if (_parkingMachines == null)<br/>        {<br/>            _parkingMachines = await _cloudDeliveryService.GetAllItems&lt;ParkingMachine&gt;();<br/>        }<br/>        return _parkingMachines;<br/>    }<br/>    public async Task&lt;List&lt;ParkingMachine&gt;&gt; GetNearestParkingMachines()<br/>    {<br/>        ...<br/>    }<br/>}</span></pre><p id="03e9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">你看，我们需要提供一个实现，将整套停车设备限制在两个最近的设备上。为了做到这一点，我们需要能够比较两个位置对象的距离——每个停车机器的GPS坐标和游客的位置。这是新的<strong class="ke ir"> Helpers/GeoHelper.cs </strong>的工作:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="d1ff" class="nf lt iq nb b gy ng nh l ni nj">public static class GeoHelper<br/>{<br/>    public static double GetDistanceTo(this Location source, Location target)<br/>    {<br/>        var sourceCoords = new GeoCoordinate(Convert.ToDouble(source.Latitude), Convert.ToDouble(source.Longitude));<br/>        var targetCoords = new GeoCoordinate(Convert.ToDouble(target.Latitude), Convert.ToDouble(target.Longitude));<br/>        return sourceCoords.GetDistanceTo(targetCoords);<br/>    }<br/>}</span></pre><p id="46e1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">GeoCoordinate类是。NET framework用于便携式设备，在web开发中不可用。为了克服这个问题，我安装了一个NuGet包<code class="fe nl nm nn nb b">GeoCoordinate.NetCore</code>,它是该库的1:1 API兼容实现。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/d42189b7bccf1549b265d5003ea0354f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iRIZo89uF_k3-zNV.png"/></div></div></figure><p id="5506" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">然后，我们可以根据到访问者的距离过滤列表:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="e357" class="nf lt iq nb b gy ng nh l ni nj">public async Task&lt;List&lt;ParkingMachine&gt;&gt; GetNearestParkingMachines(Location point)<br/>{<br/>    var parkingMachines = await GetAllParkingMachinesAsync();<br/>    return parkingMachines.OrderBy(p =&gt; p.Location.GetDistanceTo(point)).Take(2).ToList();<br/>}</span></pre><p id="7e20" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">和往常一样，我们需要在<strong class="ke ir"> Startup.cs </strong>中注册服务:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="27c8" class="nf lt iq nb b gy ng nh l ni nj">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    ...<br/>    services.AddSingleton&lt;ParkingMachineService&gt;();<br/>}</span></pre><p id="31e5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">因为我们希望在地图上显示停车机器，而不仅仅是用文本显示它们的GPS坐标，所以我们需要一点JavaScript来处理地图本身的任务。JS函数需要两个位置对象，您可以在这里探索它的实现<a class="ae la" href="https://github.com/ondrabus/dont-park-here-client/blob/065658749c1bf3e21077e574ef8cd30e8699efd7/wwwroot/js/map.js" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2848" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">Blazor端实现的重要步骤是获取最近的停车机器并调用JS函数。我们可以在每次位置更改时调用的<strong class="ke ir"> SetLocation </strong>方法内的<strong class="ke ir"> Map </strong>页面的代码隐藏中实现这一点:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="7d66" class="nf lt iq nb b gy ng nh l ni nj">[Inject]<br/>protected ParkingMachineService ParkingMachineService { get; set; }<br/>...<br/>protected async void SetLocation(Location location)<br/>{<br/>    ...<br/>    var parkingMachines = await ParkingMachineService.GetNearestParkingMachines(location);<br/>    if (parkingMachines.Count &gt; 1)<br/>    {<br/>        await JSRuntime.InvokeAsync&lt;object&gt;("mapSetParkingMachines", parkingMachines[0].Location, parkingMachines[1].Location);<br/>    }<br/>    StateHasChanged();<br/>}</span></pre><p id="cbc1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">当您在最后一步之后运行该站点时，无论何时单击地图，您都应该看到基本的游客区、停车限制的详细信息，并看到您需要注册汽车的两个最近停车机器的标记。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/6deaea5aa3a34b25450f6aeb07fb228a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CRQHkJWLEpgY95ks.png"/></div></div></figure><p id="f406" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">虽然一些功能，比如将GPS坐标与区域的多边形进行匹配，以及找到最近的停车机器，听起来很复杂，但使用Blazor并不难完成。从开发人员的角度来看，Blazor类似于WebForms(每个人都不喜欢web forms)。我个人真的很欣赏使用能力。NET代码和实践，这让我更有效率，并真正享受在项目中工作的乐趣。</p><p id="1eda" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如果你对这个项目感兴趣，我邀请你查看整个<a class="ae la" href="https://github.com/ondrabus/dont-park-here-client/tree/065658749c1bf3e21077e574ef8cd30e8699efd7" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>和<a class="ae la" href="https://dev.to/ondrabus" rel="noopener ugc nofollow" target="_blank">我的文章，在那里我描述了Blazor的其他特性</a>。</p><p id="0ce4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><strong class="ke ir">系列其他文章:</strong></p><ul class=""><li id="44e6" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/what-is-this-blazor-everyones-talking-about-34529a3e1419"> #1每个人都在谈论的这个Blazor是什么？</a></li><li id="2c5c" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-an-interactive-spa-with-blazor-a030bae66b68"> #2如何用Blazor打造互动SPA</a></li><li id="8050" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">#3使用Blazor和地理定位避免停车罚款(本文)</li></ul></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="566f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><em class="kd">最初发布于2020年1月20日</em><a class="ae la" href="https://dev.to/ondrabus/avoiding-parking-fines-with-blazor-and-geolocation-572o" rel="noopener ugc nofollow" target="_blank"><em class="kd">https://dev . to</em></a><em class="kd">。</em></p></div></div>    
</body>
</html>