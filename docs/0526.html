<html>
<head>
<title>Understanding Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解递归</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-recursion-2d159f8c9b27?source=collection_archive---------6-----------------------#2018-03-25">https://itnext.io/understanding-recursion-2d159f8c9b27?source=collection_archive---------6-----------------------#2018-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3058740061a2d6b5576e49a1998aa761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7nb-owwLC4MMYZTlyFZ7w.png"/></div></div></figure><p id="fd79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单来说，递归就是调用函数本身。它可以用来将复杂的问题分解成更小的可管理的类似单元，这些单元可以由同一个功能来处理。</p><h1 id="f847" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">递归与迭代</h1><p id="39f6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">迭代函数是循环重复代码的某个部分，递归函数是<strong class="ka ir">再次调用自己</strong>来重复代码。</p><p id="f328" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如计算一组数字的总和</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6cbd" class="mi kx iq me b gy mj mk l ml mm">function iterativeSum(arr) {<br/>    let sum = 0;<br/>    for (let i of arr) {<br/>        sum += i;<br/>    }<br/>    return sum;<br/>}<br/></span><span id="fa62" class="mi kx iq me b gy mn mk l ml mm">function recursiveSum(arr) {<br/>    if (arr.length === 0) {<br/>        return 0;<br/>    }<br/>    return arr[0] + recursiveSum(arr.slice(1));<br/>}</span><span id="cef3" class="mi kx iq me b gy mn mk l ml mm">/**<br/> *<br/> * iterativeSum([1,2,3]) =&gt; 1 + 2 + 3 =&gt; 6<br/> *<br/> * recursiveSum([1,2,3])<br/> *     =&gt; 1 + recursiveSum([2,3])<br/> *     =&gt;       2 + recursiveSum([3])<br/> *     =&gt;           3 + recursiveSum([])<br/> *     =&gt;               0<br/> *     =&gt; 0 + 3 + 2 + 1 =&gt; 6<br/> */</span><span id="dad9" class="mi kx iq me b gy mn mk l ml mm">console.log(iterativeSum([1,2,3])); //6<br/>console.log(recursiveSum([1,2,3])); //6</span></pre><h1 id="3479" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何使用递归</h1><h1 id="6958" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">基本条件是必须的</h1><p id="f73b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">使用没有基条件的递归会导致无限递归。当递归调用自身的函数时，基本条件指示何时终止进程。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="fa5c" class="mi kx iq me b gy mj mk l ml mm">function infiniteRecursion() {<br/>    // keeps calling itself without termination<br/>    return infiniteRecursion();<br/>}</span></pre><h1 id="0a4f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">将问题分解成功能本身可以处理的更小的单元。</h1><p id="d69f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">例如</p><p id="37b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">一个数组的</em>之和=第一个元素的值+ <em class="mo">数组其余部分的</em>之和。</p><p id="63ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们在上面的<em class="mo"> recursiveSum </em>例子中递归实现的方式。</p><h1 id="748b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">熟能生巧</h1><h1 id="4984" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">雌三醇环戊醚</h1><h2 id="6567" class="mi kx iq bd ky mp mq dn lc mr ms dp lg kj mt mu lk kn mv mw lo kr mx my ls mz bi translated">问题:</h2><p id="77e6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">从数字1开始，重复加5或乘3，可以产生无限多的新数字。写一个函数，给定一个数，试图找出产生这个数的一系列这样的加法和乘法。</p><h2 id="6d5a" class="mi kx iq bd ky mp mq dn lc mr ms dp lg kj mt mu lk kn mv mw lo kr mx my ls mz bi translated">想法:</h2><p id="85c0" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了找到一个数的解(姑且称之为<em class="mo"> A </em>)，我们尝试将当前数加5或乘3(姑且称之为<em class="mo"> B </em>)，并使用递归来检查结果是否有解(即<em class="mo"> B + 5 </em>或<em class="mo"> B \ </em> 3 <em class="mo">)。基础条件是当前数大于(boom！)或等于(找到解！)</em>一个*。</p><h2 id="2ca6" class="mi kx iq bd ky mp mq dn lc mr ms dp lg kj mt mu lk kn mv mw lo kr mx my ls mz bi translated">解决方案:</h2><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="dc4f" class="mi kx iq me b gy mj mk l ml mm">function findSolution(num) {<br/>    function find(start, history) {<br/>        if(start &gt; num) {<br/>            return null; // boom!<br/>        } else if (start === num) {<br/>            return history; //solution found<br/>        }<br/>        return find(start + 5, `(${history} + 5)`) || find(start * 3, `(${history} * 3)`);<br/>    }</span><span id="55ec" class="mi kx iq me b gy mn mk l ml mm">    return find(1, '1');<br/>}</span><span id="e112" class="mi kx iq me b gy mn mk l ml mm">console.log(findSolution(13)); //(((1 * 3) + 5) + 5)<br/>console.log(findSolution(20)); //null</span></pre><h1 id="6568" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Q2</h1><ul class=""><li id="4abe" class="na nb iq ka b kb lu kf lv kj nc kn nd kr ne kv nf ng nh ni bi translated">问题:<a class="ae nj" href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/" rel="noopener ugc nofollow" target="_blank">按</a>(左、右、上)顺序遍历二叉树</li><li id="bb11" class="na nb iq ka b kb nk kf nl kj nm kn nn kr no kv nf ng nh ni bi translated">解决办法</li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8ceb" class="mi kx iq me b gy mj mk l ml mm">class Node {<br/>    constructor(value, left=null, right=null) {<br/>        this.value = value;<br/>        this.left = left;<br/>        this.right = right;<br/>    }<br/>}</span><span id="3a6e" class="mi kx iq me b gy mn mk l ml mm">function inorder(node, fn) {<br/>    if(node == null) {<br/>        return;<br/>    }<br/>    inorder(node.left, fn);<br/>    fn(node);<br/>    inorder(node.right, fn);<br/>}</span><span id="09cf" class="mi kx iq me b gy mn mk l ml mm">function test() {<br/>    /**<br/>     *        A<br/>     *      /   \<br/>     *    B       C<br/>     *   / \       \<br/>     *  E   F       H <br/>     */<br/>    let E = new Node('E'),<br/>        F = new Node('F'),<br/>        H = new Node('H'),<br/>        B = new Node('B', E, F),<br/>        C = new Node('C', null, H),<br/>        A = new Node('A', B, C);<br/>    inorder(A, node =&gt; console.log(node.value)); // E B F A C H<br/>}<br/>test();</span></pre><h1 id="6aa8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">参考</h1><ul class=""><li id="8e67" class="na nb iq ka b kb lu kf lv kj nc kn nd kr ne kv nf ng nh ni bi translated"><a class="ae nj" href="https://www.amazon.com/Eloquent-JavaScript-2nd-Ed-Introduction/dp/1593275846" rel="noopener ugc nofollow" target="_blank">雄辩的JavaScript </a></li></ul><h1 id="68a5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">通知；注意</h1><ul class=""><li id="008c" class="na nb iq ka b kb lu kf lv kj nc kn nd kr ne kv nf ng nh ni bi translated">读书笔记系列如果想关注最新的新闻/文章，请<a class="ae nj" href="https://github.com/n0ruSh/the-art-of-reading" rel="noopener ugc nofollow" target="_blank">【观看】</a>订阅。</li></ul></div></div>    
</body>
</html>