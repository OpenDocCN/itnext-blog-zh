<html>
<head>
<title>Event-Driven Microservices with Spring Boot and ActiveMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring Boot和ActiveMQ的事件驱动微服务</h1>
<blockquote>原文：<a href="https://itnext.io/event-driven-microservices-with-spring-boot-and-activemq-5ef709928482?source=collection_archive---------0-----------------------#2019-08-07">https://itnext.io/event-driven-microservices-with-spring-boot-and-activemq-5ef709928482?source=collection_archive---------0-----------------------#2019-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f3e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">微服务之间的大多数通信要么通过HTTP请求-响应API，要么通过异步消息传递。虽然这两种机制是最常用的，但它们非常不同。知道何时使用哪种机制很重要。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/b8aa6902fee45df6b229c9268fca262e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*HvgtVsjd_2GRLhzy_UyEGQ.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">Spring Boot和ActiveMQ</figcaption></figure><p id="2b56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当跨多个微服务及其相关领域模型传播变更时，事件驱动的通信非常重要。这意味着当变化发生时，我们需要某种方法来协调不同模型之间的变化。这确保了可靠的通信以及微服务之间的松散耦合。</p><p id="89ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有多种模式可以实现事件驱动的架构。其中一个常见和流行的是消息模式。这是极其<strong class="js iu">可伸缩的</strong>，灵活且有保证的消息传递。有几个工具可以用于消息传递模式，比如RabbitMQ、ActiveMQ、Apache Kafka等等。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi la"><img src="../Images/e987658c12b8dc1c63bb6dc73df1b87f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/0*WEncHcv5oZVxWleb"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">消息模式</figcaption></figure><p id="7f28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将使用Spring Boot构建微服务，并且我们将设置ActiveMQ消息代理在微服务之间进行异步通信。</p><h1 id="6205" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构建微服务</h1><p id="9fcd" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">让我们创建两个Spring Boot项目“activemq发送者”和“activemq接收者”。下面是示例项目结构。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi me"><img src="../Images/2dfa3386eab228f7c53c3953055d14e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/0*9KQ-6New0Vj1QIIA"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">示例项目结构</figcaption></figure><p id="5944" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要添加maven依赖<em class="mf">spring-boot-starter-activemq</em>来启用ActiveMQ。下面是一个pom.xml示例。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="fd20" class="ml lc it mh b gy mm mn l mo mp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;project <br/>         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br/>         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br/>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/><br/>    &lt;groupId&gt;com.techshard.activemqsender&lt;/groupId&gt;<br/>    &lt;artifactId&gt;activemq-sender&lt;/artifactId&gt;<br/>    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br/><br/>    &lt;parent&gt;<br/>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br/>        &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;<br/>        &lt;relativePath /&gt;<br/>    &lt;/parent&gt;<br/><br/>    &lt;properties&gt;<br/>        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br/>        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;<br/>    &lt;/properties&gt;<br/><br/>    &lt;dependencies&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>        &lt;/dependency&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>            &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;<br/>        &lt;/dependency&gt;<br/>    &lt;/dependencies&gt;<br/><br/>&lt;/project&gt;</span></pre><h1 id="5df9" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">配置发布者</h1><p id="a0bb" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在项目<em class="mf"> activemq-sender </em>中，我们将首先配置一个队列。按如下方式创建JmsConfig类。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="5241" class="ml lc it mh b gy mm mn l mo mp">package com.techshard.activemq.configuration;</span><span id="5765" class="ml lc it mh b gy mq mn l mo mp">import org.apache.activemq.command.ActiveMQQueue;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.context.annotation.Configuration;<br/>import org.springframework.jms.annotation.EnableJms;</span><span id="7876" class="ml lc it mh b gy mq mn l mo mp">import javax.jms.Queue;</span><span id="ddc4" class="ml lc it mh b gy mq mn l mo mp">@Configuration<br/>public class JmsConfig {</span><span id="1c28" class="ml lc it mh b gy mq mn l mo mp">    @Bean<br/>    public Queue queue(){<br/>        return new ActiveMQQueue("test-queue");<br/>    }<br/>}</span></pre><p id="39dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的类只声明了一个bean <em class="mf">队列</em>，我们的队列名称应该是<em class="mf"> test-queue。</em>注意，队列名称也可以从应用程序属性中读取。这只是一个例子。</p><p id="e878" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们创建一个REST API，用于将消息发布到队列。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="723e" class="ml lc it mh b gy mm mn l mo mp">package com.techshard.activemq.controller;<br/><br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.jms.core.JmsTemplate;<br/>import org.springframework.web.bind.annotation.GetMapping;<br/>import org.springframework.web.bind.annotation.PathVariable;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;<br/><br/>import javax.jms.Queue;<br/><br/>@RestController<br/>@RequestMapping("/api")<br/>public class MessageController {<br/><br/>    @Autowired<br/>    private Queue queue;<br/><br/>    @Autowired<br/>    private JmsTemplate jmsTemplate;<br/><br/>    @GetMapping("message/{message}")<br/>    public ResponseEntity&lt;String&gt; publish(@PathVariable("message") final String message){<br/>        jmsTemplate.convertAndSend(queue, message);<br/>        return new ResponseEntity(message, HttpStatus.OK);<br/>    }<br/><br/>}</span></pre><p id="239a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在控制器中，我们将注入之前声明的bean队列，我们还将注入<em class="mf"> JmsTemplate。</em></p><p id="5379" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了通过JMS发送或接收消息，我们需要建立到JMS提供者的连接并获得会话<em class="mf">。JmsTemplate </em>是一个帮助器类，它简化了通过JMS发送和接收消息，并摆脱了样板代码。</p><p id="cded" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在已经创建了一个简单的API端点，它将接受string作为参数并将其放入队列。</p><h1 id="f652" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">配置消费者</h1><p id="ed5c" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在项目<em class="mf"> activemq-receiver </em>中，创建如下组件类:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="c9e1" class="ml lc it mh b gy mm mn l mo mp">package com.techshard.activemq.consumer;<br/><br/>import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/>import org.springframework.jms.annotation.EnableJms;<br/>import org.springframework.jms.annotation.JmsListener;<br/>import org.springframework.stereotype.Component;<br/><br/>@Component<br/>@EnableJms<br/>public class MessageConsumer {<br/><br/>    private final Logger logger = LoggerFactory.getLogger(MessageConsumer.class);<br/><br/>    @JmsListener(destination = "test-queue")<br/>    public void listener(String message){<br/>        logger.info("Message received {} ", message);<br/>    }<br/>}</span></pre><p id="f808" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个类中，我们已经用<em class="mf"> @JmsListener </em>注释了方法，并且我们已经传递了我们在发布者中配置的队列名称<em class="mf"> test-queue </em>。@JmsListener 用于监听任何放入队列<em class="mf">测试队列的消息。</em></p><p id="0f3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们用<em class="mf"> @EnableJms注释了类。</em>正如Spring文档中所说的<em class="mf"> " </em> <code class="fe mr ms mt mh b"><em class="mf">@EnableJms</em></code> <em class="mf">允许检测容器中任何Spring管理的bean上的</em> <code class="fe mr ms mt mh b"><a class="ae mu" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jms/annotation/JmsListener.html" rel="noopener ugc nofollow" target="_blank">JmsListener</a></code> <em class="mf">注释。</em>”</p><p id="c979" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有趣的一点是，即使没有<em class="mf"> @EnableJms </em>注释，Spring Boot也能检测到这些方法。此问题已在<a class="ae mu" href="https://stackoverflow.com/questions/45796021/how-does-spring-look-for-enablejms-methods-if-i-dont-have-class-marked-enable" rel="noopener ugc nofollow" target="_blank"><em class="mf">stack overflow</em></a>中报告。</p><h1 id="d6eb" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建Spring Boot应用程序</h1><p id="f94a" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在这两个项目中，创建一个用<em class="mf"> @SpringBootApplication </em>注释的<em class="mf">应用程序</em>类，如下所示。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="5cee" class="ml lc it mh b gy mm mn l mo mp">package com.techshard.activemq;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;<br/><br/>@SpringBootApplication<br/>public class Application extends SpringBootServletInitializer {<br/><br/>    public static void main(String[] args) {<br/>        SpringApplication.run(Application.class, args);<br/>    }<br/>}</span></pre><h1 id="a0cb" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装ActiveMQ</h1><p id="895b" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我在这里下载<a class="ae mu" href="https://activemq.apache.org/components/classic/download/" rel="noopener ugc nofollow" target="_blank">安装了ActiveMQ。我们也可以使用Spring Boot的嵌入式ActiveMQ进行测试。安装完成后，ActiveMQ服务器应该可以在</a><a class="ae mu" href="http://localhost:8161/admin" rel="noopener ugc nofollow" target="_blank">http://localhost:8161/admin</a>上找到，我们会看到下面的欢迎页面。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/e04793454346f082dcbf0115d0ba0100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/0*gSCqwNmUj5qcaarH"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">ActiveMQ主页</figcaption></figure><h1 id="00cf" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">配置ActiveMQ</h1><p id="b4dd" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在这两个项目中，创建<em class="mf"> application.properties </em>文件，并添加以下属性。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="512c" class="ml lc it mh b gy mm mn l mo mp">spring.activemq.broker-url=tcp://localhost:61616<br/>spring.activemq.user=admin<br/>spring.activemq.password=admin</span></pre><p id="815d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ActiveMQ支持多种<a class="ae mu" href="https://activemq.apache.org/protocols" rel="noopener ugc nofollow" target="_blank">协议</a>来连接到消息代理。在本例中，我们将使用OpenWire协议。</p><p id="7718" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！</p><h1 id="48ac" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试ActiveMQ</h1><p id="258f" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在运行应用程序之前，请确保更改其中一个项目的服务器端口。默认情况下，嵌入式tomcat服务器运行在端口8080上。</p><p id="795c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行这两个应用程序并运行URL<a class="ae mu" href="http://localhost:8080/api/message/Welcome%20to%20ActiveMQ!" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/API/message/Welcome to ActiveMQ！</a>在浏览器或任何REST API测试工具中。</p><p id="79ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在消费者应用程序中，我们将在控制台中看到以下日志。</p><p id="b1df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mf">2019–08–06 22:29:57.667 INFO 17608—[ener container-2]c . t . activemq . consumer . Message consumer:消息已收到欢迎使用ActiveMQ！</em></p><p id="6740" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">刚刚发生的是消息被放入队列。监听队列的消费者应用程序从队列中读取消息。</p><p id="8b92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在ActiveMQ仪表板中，导航到队列选项卡。我们可以看到详细信息，例如队列中的消费者数量、挂起、排队和出列的消息数量。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/c64cff5467bc44d9667c1de912dac641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXVZU8j2Vwyv7vc4PiMVAw.png"/></div></div></figure><p id="6956" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文的开始，我提到了消息代理保证消息的传递。假设消费者服务关闭，消息由发布者服务放到队列中。</p><p id="8a25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">停止应用程序<em class="mf"> activemq接收器</em>。再次运行这个网址<a class="ae mu" href="http://localhost:8080/api/message/Welcome%20to%20ActiveMQ!" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/API/message/欢迎使用ActiveMQ！</a>在浏览器中。</p><p id="9886" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">导航到ActiveMQ仪表板并注意队列状态。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nb"><img src="../Images/8ec1f119c7c62c752029f27e3692e634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0W-LWNcRPeMhmuohQ1-CNg.png"/></div></div></figure><p id="1188" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到一条消息正在等待处理和排队。再次启动应用程序<em class="mf"> activemq-receiver </em>。</p><p id="a005" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦应用程序启动，我们将在控制台中显示以下消息。</p><p id="18e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mf">2019–08–06 22:54:32.667 INFO 17608—[ener container-2]c . t . activemq . consumer . Message consumer:消息已收到欢迎使用ActiveMQ！</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nb"><img src="../Images/c65cd3d9f280d56747f433235a4ff62e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZXsJ4MYkA3H3T-yQFYGLQg.png"/></div></div></figure><p id="0101" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">挂起消息的数量现在设置为0，出列消息的数量设置为2。消息代理保证消息的传递。</p><h1 id="c7c1" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4c29" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在本文中，我们刚刚看到了一个简单的消息传递模式示例。消息传递系统负责将数据从一个服务传输到另一个服务，因此服务可以专注于它们需要共享的数据，而不必担心如何共享数据。</p><p id="2fc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你喜欢这篇文章。如果你有任何意见或建议，请随时告诉我。</p><p id="451d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和往常一样，完整的代码可以在我的<a class="ae mu" href="https://github.com/swathisprasad/event-driven-microservices-with-springboot-activemq" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><p id="6885" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mf">本文原载于</em><a class="ae mu" href="https://techshard.com/2019/08/07/event-driven-microservices-with-spring-boot-and-activemq/" rel="noopener ugc nofollow" target="_blank"><em class="mf">Techshard.com</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>