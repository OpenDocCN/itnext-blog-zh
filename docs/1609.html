<html>
<head>
<title>Async React using React Router &amp; Suspense</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React路由器和悬念进行异步React</h1>
<blockquote>原文：<a href="https://itnext.io/async-react-using-react-router-suspense-a86ade1176dc?source=collection_archive---------1-----------------------#2018-12-11">https://itnext.io/async-react-using-react-router-suspense-a86ade1176dc?source=collection_archive---------1-----------------------#2018-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/31d966ec54d9f80aa11223203c717e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXMZFbiUq9B4snPAr3eLvQ.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="541c" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">使用悬念和“懒惰”使React组件的异步加载像你期望的那样简单和直观。</h2></div><p id="1e1b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">几年前，我写了一篇关于React路由器v4  中的异步React组件的文章，从那以后，React走过了漫长的道路。</p><p id="01f9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在我们有了<code class="fe lo lp lq lr b">Suspense</code>和<code class="fe lo lp lq lr b">lazy</code>，但是我的老路子原创文章还是很受欢迎的。因为有一个本地解决方案可以解决这个问题，所以我决定写一篇关于如何用React v16.6做同样事情的新文章。</p><h1 id="2873" class="ls lt jb bd lu lv lw lx ly lz ma mb mc kh md ki me kk mf kl mg kn mh ko mi mj bi translated">设置</h1><ul class=""><li id="1f2e" class="mk ml jb ks b kt mm kw mn kz mo ld mp lh mq ll mr ms mt mu bi translated">反应:16.6.3</li><li id="285c" class="mk ml jb ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated">反应范围:16.6.3</li><li id="5119" class="mk ml jb ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated">react-router-dom: 4.3.1</li><li id="3c65" class="mk ml jb ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated">web pack:4 . 27 . 1(create-react-app 2 . 1 . 1也可以)</li></ul><h1 id="c84f" class="ls lt jb bd lu lv lw lx ly lz ma mb mc kh md ki me kk mf kl mg kn mh ko mi mj bi translated">创建测试组件</h1><p id="255b" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz na lb lc ld nb lf lg lh nc lj lk ll ij bi translated">首先，我们需要创建一个组件来呈现我们的应用程序。</p><p id="8b19" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我向你介绍，<code class="fe lo lp lq lr b">TestComponent</code>:</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="1874" class="ls lt jb bd lu lv lw lx ly lz ma mb mc kh md ki me kk mf kl mg kn mh ko mi mj bi translated">同步方式</h1><p id="37f2" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz na lb lc ld nb lf lg lh nc lj lk ll ij bi translated">传统上，这是同步加载组件的方式:</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7352" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它直接导入组件，并在加载<code class="fe lo lp lq lr b">App</code>时立即使用。这很好，但是如果我们有太多导入的模块不能正常显示的话，它会有使我们的包变大的副作用。</p><h1 id="9d16" class="ls lt jb bd lu lv lw lx ly lz ma mb mc kh md ki me kk mf kl mg kn mh ko mi mj bi translated">异步(懒惰)方式</h1><p id="96d9" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz na lb lc ld nb lf lg lh nc lj lk ll ij bi translated">相反，让我们只在<code class="fe lo lp lq lr b">App</code>加载之后获取<code class="fe lo lp lq lr b">TestComponent</code>的JS文件:</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6806" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这看起来很酷吧？我们从React调用<code class="fe lo lp lq lr b">lazy</code>函数，而不是<code class="fe lo lp lq lr b">import TestComponent</code>。它接受一个回调，在这个回调中，我们调用ESModule <code class="fe lo lp lq lr b">import</code>函数。</p><p id="b11c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这一切都要归功于<code class="fe lo lp lq lr b">Suspense</code>组件。因为<code class="fe lo lp lq lr b">Suspense</code>的工作方式，你需要加一个<code class="fe lo lp lq lr b">fallback</code>道具；一些组件，当你的组件还没有加载的时候显示出来。这就是为什么我们在<code class="fe lo lp lq lr b">TestComponent</code>被拉入之前添加了一个<code class="fe lo lp lq lr b">LoadingMessage</code>组件来显示。</p><p id="8a12" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用<code class="fe lo lp lq lr b">lazy</code>时，Webpack会自动对您的包进行代码分割。这可能是最大的好处，因为只需几行JavaScript代码，您的初始包大小就可以小很多。</p><p id="0284" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这与<a class="ae lm" href="https://medium.com/@Sawtaytoes/async-react-router-v4-components-c18792e6f331" rel="noopener">我们使用的旧方法</a>完全不同，我们手动创建承诺，监听响应组件，自己做<code class="fe lo lp lq lr b">Suspense</code>做的事情。</p><h2 id="1108" class="nj lt jb bd lu nk nl dn ly nm nn dp mc kz no np me ld nq nr mg lh ns nt mi nu bi translated">使用CommonJS中的“require”</h2><p id="2f99" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz na lb lc ld nb lf lg lh nc lj lk ll ij bi translated"><code class="fe lo lp lq lr b">import</code>并不总是可用的，而是特定于ESModules的。相反，您可能会使用CommonJS，所以您会想要使用<code class="fe lo lp lq lr b">require</code>来代替。事情是，你不能把一个换成另一个，因为<code class="fe lo lp lq lr b">import</code>返回一个承诺，而<code class="fe lo lp lq lr b">require</code>直接返回你的组件。</p><p id="cda3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这种情况下，您会想要做这样的事情:</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="ab42" class="ls lt jb bd lu lv lw lx ly lz ma mb mc kh md ki me kk mf kl mg kn mh ko mi mj bi translated">异步反应路由器</h1><p id="462d" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz na lb lc ld nb lf lg lh nc lj lk ll ij bi translated">理想情况下，我们只有在特定的路线上才会装载<code class="fe lo lp lq lr b">TestComponent</code>。为了处理这个用例，我们将使用<code class="fe lo lp lq lr b">TestComponent</code>，以及一些其他的测试组件，并将它们封装在仅当您在那些特定的路线上时才加载的路线中。</p><p id="364a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通过这种方式，我们可以发送一个非常小的初始JS包，并在事后考虑如何获取真正的内容。这与您可能在2-3年前看到的老式React路由器v1-v3的<code class="fe lo lp lq lr b">require.ensure</code>的行为相同。</p><p id="76ea" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是全部的装备:</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e265" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们像往常一样在交换机中创建路由组件。使用<code class="fe lo lp lq lr b">lazy</code>和<code class="fe lo lp lq lr b">import</code>就像我们在第一个例子中所做的那样，我们能够动态地加载这三个测试组件，只有当您已经访问了其中一个路由时。从这里开始，将其推广到其他组件和子路由应该很简单。</p><p id="7099" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">问题是，导入语法相当混乱。您可以通过创建自己的<code class="fe lo lp lq lr b">lazyImport</code>方法并使用它来清理它:</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9476" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Webpack需要静态编译，所以您需要完成我在这里展示的奇怪的模板字符串代码。但是如果你不想担心必须维护和实现你自己的解决方案，那么…这就变得棘手了。</p><p id="4d83" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">事情不像你想的那样。</p><p id="3405" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe lo lp lq lr b">import</code>的工作原理是从调用<code class="fe lo lp lq lr b">import</code>函数的地方检查文件的加载位置。这意味着如果我要为它写一个库(我试过了)，它将只对相对于我在<code class="fe lo lp lq lr b">node_modules/</code>中的库的目录的文件起作用，而不是在你的项目的根目录中，除非我直接传入<code class="fe lo lp lq lr b">import</code>函数，这样它就知道在哪里相对导入。</p><p id="ee5b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有很多其他解决方案可以做同样的事情，比如围绕<code class="fe lo lp lq lr b">lazy</code>和<code class="fe lo lp lq lr b">import</code>函数创建React组件，但是这超出了像这样的简单示例的范围。</p><h2 id="dd12" class="nj lt jb bd lu nk nl dn ly nm nn dp mc kz no np me ld nq nr mg lh ns nt mi nu bi translated">CommonJS问题再次罢工！</h2><p id="b2b4" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz na lb lc ld nb lf lg lh nc lj lk ll ij bi translated">虽然这是可行的，并且允许代码分割，因为<code class="fe lo lp lq lr b">import</code>允许动态字符串值，但它不会像您想象的那样使用<code class="fe lo lp lq lr b">require</code>工作。除非你使用的是<code class="fe lo lp lq lr b">require.ensure</code>，否则代码分割是不可能的，因为Webpack在幕后处理动态字符串导入的方式。</p><h1 id="60d3" class="ls lt jb bd lu lv lw lx ly lz ma mb mc kh md ki me kk mf kl mg kn mh ko mi mj bi translated">自己做</h1><p id="f907" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz na lb lc ld nb lf lg lh nc lj lk ll ij bi translated">这里有很多代码，但是您可以在<a class="ae lm" href="https://codesandbox.io/s/18rnr5p97q" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>亲自尝试一下:</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nv ni l"/></div></figure><h1 id="9711" class="ls lt jb bd lu lv lw lx ly lz ma mb mc kh md ki me kk mf kl mg kn mh ko mi mj bi translated">[编辑]</h1><p id="71f1" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz na lb lc ld nb lf lg lh nc lj lk ll ij bi translated">react-router 4 . 4 . 0目前有一个问题，它不能处理通过<code class="fe lo lp lq lr b">Route</code>上的<code class="fe lo lp lq lr b">component</code> prop传入的延迟加载或内存化组件的情况。</p><p id="f7d3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您将会收到如下错误消息:</p><blockquote class="nw nx ny"><p id="7652" class="kq kr ln ks b kt ku kc kv kw kx kf ky nz la lb lc oa le lf lg ob li lj lk ll ij bi translated">警告:失败的属性类型:提供给“Route”的“object”类型的属性“component”无效，应为“function”。</p></blockquote><p id="1206" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你可以在<a class="ae lm" href="https://github.com/ReactTraining/react-router/issues/6420" rel="noopener ugc nofollow" target="_blank">GitHub</a>:<br/><a class="ae lm" href="https://github.com/ReactTraining/react-router/issues/6420" rel="noopener ugc nofollow" target="_blank">https://github.com/ReactTraining/react-router/issues/6420</a>上找到更多关于这个问题的信息</p><p id="5c3b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">感谢<a class="oc od ep" href="https://medium.com/u/3aa9306ccdb5?source=post_page-----a86ade1176dc--------------------------------" rel="noopener" target="_blank">坤GEO </a>指出这一点！</p><h1 id="ed18" class="ls lt jb bd lu lv lw lx ly lz ma mb mc kh md ki me kk mf kl mg kn mh ko mi mj bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz na lb lc ld nb lf lg lh nc lj lk ll ij bi translated">如果您对与React相关的更多主题感兴趣，您应该查看我的其他文章:</p><ul class=""><li id="8971" class="mk ml jb ks b kt ku kw kx kz oe ld of lh og ll mr ms mt mu bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/an-emoji-lovers-guide-to-functional-programming-part-3-ef78e3156e">用减速器打造独角兽！</a></li><li id="b339" class="mk ml jb ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated"><a class="ae lm" href="https://medium.com/@Sawtaytoes/using-redux-reducers-in-react-components-4e92985dd9cb" rel="noopener">在React组件中使用Redux还原剂</a></li><li id="1105" class="mk ml jb ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated"><a class="ae lm" href="https://medium.com/@Sawtaytoes/why-you-shouldnt-need-connect-from-react-redux-498876de9e4e" rel="noopener">你不应该需要从React-Redux中“连接”</a></li><li id="21e8" class="mk ml jb ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated">使用Redux的秘密:createNamespaceReducer </li><li id="c67f" class="mk ml jb ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated"><a class="ae lm" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li></ul></div></div>    
</body>
</html>