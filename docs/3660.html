<html>
<head>
<title>User-Agent Sniffing Only Way to Deal With Upcoming SameSite Cookie Changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用户代理嗅探处理即将到来的SameSite Cookie更改的唯一方法</h1>
<blockquote>原文：<a href="https://itnext.io/user-agent-sniffing-only-way-to-deal-with-upcoming-samesite-cookie-changes-6f79a18e541?source=collection_archive---------3-----------------------#2020-01-26">https://itnext.io/user-agent-sniffing-only-way-to-deal-with-upcoming-samesite-cookie-changes-6f79a18e541?source=collection_archive---------3-----------------------#2020-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d24e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2020年2月4日，Chrome将对SameSite cookies的处理进行修改，要求任何人接受跨来源请求的cookies。新Chrome <strong class="jp ir">要求的cookie格式不能被相当一部分老浏览器读取。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e281882359b98addeee9972118edd0e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VxEm9fA1t5kr1_xB"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@noahbuscher?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诺亚·布舍尔</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4956" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决这个问题的一个建议是为每个cookie设置两个版本，但是如下所述，这种方法对于许多应用程序来说是不可行的。这使得用户代理嗅探成为web开发中最容易出错的做法，也是唯一兼容跨来源cookies的方法。出于这个原因，我们将以一个全面的指南来结束这篇文章，该指南将使用户代理嗅探正确，以一种处理不兼容浏览器的完整列表的方式综合主要参与者的建议，并在今天使用的超过40000个独特的真实世界用户代理字符串的数据集上验证它。</p><p id="de7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">十多年来，web开发人员社区尽最大努力避免在<em class="lc"> JavaScript </em>中进行用户代理嗅探，但是<em class="lc">服务器端</em>用户代理嗅探自90年代以来几乎没有进行过，即使在那时感觉也很糟糕。现在它又回来了，对于某些用例来说，它是强制性的。</p><p id="3141" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先让我们看看这是如何发生的。如果您只想了解如何可靠地解决这个问题，请向下滚动。</p><h1 id="b42c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">我们是怎么到这里的？</h1><ul class=""><li id="8f01" class="mb mc iq jp b jq md ju me jy mf kc mg kg mh kk mi mj mk ml bi translated">许多第三方登录的实现，如OAuth，要求您接受从另一个站点发起的请求，并读取该请求中的cookie。</li><li id="fbac" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><a class="ae lb" href="https://tools.ietf.org/html/draft-west-cookie-incrementalism-00#section-3.1" rel="noopener ugc nofollow" target="_blank">2019 same site标准</a>强制要求不得在其他站点的帖子请求中发送cookies，除非它们标有<code class="fe mr ms mt mu b">SameSite=None; Secure</code>。如果没有设置这个属性，cookie将默认为<code class="fe mr ms mt mu b">SameSite=Lax;</code>，这意味着不会在跨源帖子上发送cookie。<code class="fe mr ms mt mu b">SameSite=None</code>必须与<code class="fe mr ms mt mu b">Secure</code>属性一起设置，这意味着这些请求必须发生在HTTPS。这将在Chrome 80中实现，Chrome 80将于2020年2月4日为用户自动安装。Firefox和Edge已经表示，他们也将采用这些变化，但尚未确定发布日期。</li><li id="ca12" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">【2016年4月SameSite标准的一个草案不知道<code class="fe mr ms mt mu b">SameSite=None</code>，并规定当遇到未知值时(例如“None”)，cookie应该被忽略。这是在<a class="ae lb" href="https://www.chromium.org/updates/same-site/incompatible-clients" rel="noopener ugc nofollow" target="_blank"> Chrome 51-66 </a>中实现的，以及从它派生的任何东西，比如Android WebView或Chrome。Android上的UC浏览器&lt; 12.13.2部分版本也有这种行为。</li><li id="54d1" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">【2016年1月的SameSite标准草案规定未知的SameSite值(例如“无”)应被视为<code class="fe mr ms mt mu b">SameSite=Strict</code>。这个行为在iOS 12 上的<a class="ae lb" href="https://github.com/aspnet/AspNetCore/issues/14996" rel="noopener ugc nofollow" target="_blank">任何浏览器和MacOS 10.14 (Mojave)上的Safari上实现。Chrome团队坚持认为这种行为是一个bug，但它实际上符合这个特定版本的规范。</a></li><li id="93e5" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">对于iOS 12上的任何浏览器和MacOS 10.14上的Safari，这种行为都与操作系统相关联——用户必须更新操作系统才能获得新的行为。苹果<a class="ae lb" href="https://bugs.webkit.org/show_bug.cgi?id=198181#c19" rel="noopener ugc nofollow" target="_blank">不会将修复</a>回移植到iOS 12。在iOS 12上的iPhone 5S、iPhone 6/6 Plus和第6代iPod Touch的用户在任何情况下都无法升级到iOS 13，因此他们必须购买新的设备才能获得新的cookie行为。</li></ul><h1 id="b2d9" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">这对跨产地的饼干意味着什么</h1><ul class=""><li id="4968" class="mb mc iq jp b jq md ju me jy mf kc mg kg mh kk mi mj mk ml bi translated">如果需要在Chrome 80中从跨站点请求中读取cookies，需要用<code class="fe mr ms mt mu b">SameSite=None; Secure</code>显式设置。就其本身而言，这是cookie行为的一个突破性变化。</li><li id="9600" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">如果你需要在iOS 12、MacOS 10.14上的Safari、Chrome 51–66或没有same site属性的UC浏览器&lt; 12.13.2 for Android, you need to set them <em class="lc">上读取跨站点请求的cookies。</em></li><li id="84e4" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">这两种行为是不相容的。因为一长串浏览器将<code class="fe mr ms mt mu b">SameSite=None</code>视为<code class="fe mr ms mt mu b">SameSite=Strict</code>或可以忽略的东西，所以没有办法设置一个跨站点请求发送的cookie，既适用于这些浏览器，也适用于Chrome 80。您必须在设置它时进行用户代理嗅探，或者采用双cookie方法，如下所述。在一个浏览器中有效的东西，在其他浏览器中就会失效。</li><li id="0cbd" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">如果您通过OpenIdConnect、SAML 2.0、WsFederation或任何其他方式使用第三方身份验证，并且需要读取在不同站点发起的请求中发布到您站点的cookie，您会受到影响。</li></ul><h1 id="aa2d" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">为什么会这样？</h1><p id="77cf" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">Chrome引入的变化的重点是在默认情况下获得更强的跨站点请求伪造保护。这些变化本身就是突破性的——不管旧浏览器在做什么，Chrome推动的变化意味着<code class="fe mr ms mt mu b">SameSite=None; Secure</code>将不得不设置为有意的跨站点cookie传递，以处理POST请求。这些变化极大地降低了意外引入CSRF漏洞的可能性，因此它们显然有一定的价值。如果在Netscape 1.0中引入了这一点，提倡这一点是显而易见的。当这些突破性的改变在cookies引入四分之一世纪后被引入时，很明显会有很多东西因此而被打破。</p><p id="2653" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更大的问题是，原来旧版本的规范与新版本的不兼容。一堆较旧的Chrome版本，以及iOS 12上所有遵循2016年标准的浏览器版本<code class="fe mr ms mt mu b">SameSite=None</code>要么被忽略，要么被视为<code class="fe mr ms mt mu b">SameSite=Strict</code>。2019年规范的作者也是2016年规范的作者，但不清楚这些规范的互斥性是否被理解。</p><h1 id="a468" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">浏览器使用份额</h1><p id="d31c" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">根据w3counter的数据，4.75%的网页流量来自一台iOS 12设备。Caniuse.com提供了每个Chrome版本的使用份额细分，并表示Chrome 51-66占总网络流量的0.75%。根据来源不同，UC浏览器被列为拥有0.3-2.9%的全球市场份额，尽管这在不同国家有很大差异。例如，据报道它在印度占有22%的份额。对于UC浏览器，源代码不会根据版本号进行区分。总之，使用2019年12月的统计数据，大约有<strong class="jp ir"> 6%的网络流量</strong>将无法处理<code class="fe mr ms mt mu b">SameSite=None; Secure</code>。即将到来的2月4日，自动更新的Chrome安装，约占网络流量的55%，如果没有设置T4，将拒绝跨来源传递cookies。</p><h1 id="8056" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">谁需要关心这个？</h1><p id="2609" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">首先，想想你是否需要从第三方的帖子中读取cookies。如果没有，可以将cookies设置为<code class="fe mr ms mt mu b">SameSite=Lax</code>(或者不设置，默认为SameSite=Lax行为)。如果您需要防止跨站点GET请求，请使用<code class="fe mr ms mt mu b">SameSite=Strict</code>。</p><p id="8506" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你真的需要来自其他网站的cookies，你需要采取特殊的步骤。下面将解释两种处理方法。</p><h1 id="9b0f" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">有警告的解决方案:双饼干</h1><p id="4575" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">解决这个问题的一种方法是读写两个不同的cookie，一个有<code class="fe mr ms mt mu b">SameSite=None; Secure</code>，一个没有，并在处理cookie时检查两者。您的HTTP应该是这样的。</p><pre class="km kn ko kp gt my mu mz na aw nb bi"><span id="cda7" class="nc le iq mu b gy nd ne l nf ng">HTTP/1.1 200 OK<br/>Date: Fri, 17 Jan 2020 10:10:01 GMT<br/>Content-Type: text/html; charset=utf-8<br/>Set-Cookie: myCookie1=value; SameSite=None; Secure<br/>Set-Cookie: myCookie2=value; Secure</span></pre><p id="de15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个<em class="lc">可能</em>对你来说是一个可行的解决方案，但是有几个原因说明这可能不是一个好主意，你应该三思而行。</p><ol class=""><li id="5584" class="mb mc iq jp b jq jr ju jv jy nh kc ni kg nj kk nk mj mk ml bi translated">你要瞄准的浏览器之一，iOS 12上的Safari，对每个域的cookie大小有严格的限制。Safari允许每个域总共有大约4KB。如果您设置了两个cookies，就将可用空间减半，很可能您会超过这个限制。这完全取决于你在饼干里储存了什么。</li><li id="f3c6" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk nk mj mk ml bi translated">改变饼干的制作方式<em class="lc">设定</em>有点复杂，但是很可能会集中到一个地方。然而，更改cookie的位置是<em class="lc">读取</em>可能会分散到代码库的更大部分。您还需要更改删除cookie的任何位置，并且在每种情况下，您都需要确保处理其中一个cookie存在、另一个cookie存在，或者两者都存在，或者都不存在的情况。总之，这有很大的复杂性，这种复杂性很可能与身份验证有关。那不是你想到处闯荡和冒险的地方。</li></ol><p id="ef08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然双cookie方法是谷歌推荐的<a class="ae lb" href="https://web.dev/samesite-cookie-recipes/" rel="noopener ugc nofollow" target="_blank"/>，但是<a class="ae lb" href="https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/" rel="noopener ugc nofollow" target="_blank">ASP.NET团队得出了另外一个结论</a>——他们发现采用用户代理嗅探方法将是更安全的方法。用户代理嗅探很难做对。很难涵盖所有相关的浏览器，而且很难做到在某种程度上你可以合理地确定它不会在未来的用户代理中被破坏。但是，当有人做对了，这就变成了一个任何人都可以使用的容易复制的解决方案。</p><h1 id="5006" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">另一个解决方案:用户代理嗅探</h1><p id="e45f" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">解析用户代理字符串很难，因为它实际上不遵循任何特定的格式，还因为每个浏览器都谎称自己是谁，并声明自己是许多其他浏览器。浏览器撒谎的原因是为了避开在解析用户代理字符串时做错事的糟糕代码。因此，因为用户代理字符串解析本来就很难，所以现在整个世界都在合谋让它变得更加困难。对于如何解析它们，真的没有规则，你必须依靠统计证据来看你是否得到了正确的结果。您需要对照已知的用户代理变体检查您的代码，并且足够具体地检查版本号，以便您可以确信它不会在未来的版本中崩溃。</p><p id="4892" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通常会不惜一切代价避免用户代理嗅探，这是有充分理由的。然而，这些相同地点的问题是极端的，它可能是导致最少破坏的解决方案。</p><p id="0316" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个JavaScript错误记录服务，<a class="ae lb" href="https://catchjs.com/" rel="noopener ugc nofollow" target="_blank"> CatchJS </a>拥有大量关于用户代理的数据，以及一些解析这些数据的专业知识。以下是基于此的一些建议。首先，我们将概述如何可靠地检测iOS 12、MacOS 10.14上的Safari和Chrome版本51-66上的任何浏览器。然后，我们将对此进行扩展，以包括已知的不兼容浏览器的完整列表。</p><ul class=""><li id="4342" class="mb mc iq jp b jq jr ju jv jy nh kc ni kg nj kk mi mj mk ml bi translated">您可以通过在用户代理中查找子字符串“iPhone OS 12_”来可靠地检测运行iOS 12服务器端的iPods和iPhone。</li><li id="bb4f" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">您可以通过查找子字符串“iPad；来可靠地检测运行iOS 12服务器端的iPad。CPU OS 12_”。</li><li id="f44d" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">上述两项检查也将可靠地检测iOS 12上的Chrome。它通常还包括iOS 12上的网页浏览量，至少包括来自脸书、Instagram、Snapchat和Shopify的应用。</li><li id="6361" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">MacOS 10.14上的Safari可以通过查找<em class="lc">所有</em>的子字符串“OS X 10_14_”、“版本/”和“Safari”来可靠检测。</li><li id="0d54" class="mb mc iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">通过检查子字符串“Chrome/5”和“Chrome/6 ”,可以避免在Chrome 50-69上出现<code class="fe mr ms mt mu b">SameSite=None</code>。我们只关心Chrome 51-66，但是包括更多的版本是好的，因为这些在任何情况下都不会与<code class="fe mr ms mt mu b">SameSite=None</code>有任何关系。还会包括Chrome &gt; = 500。假设目前的发布时间表是每八周发布一个主要版本，那么在这成为问题之前，你还有大约64年的时间。</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fc85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码可以检测几乎所有的<code class="fe mr ms mt mu b">SameSite=None</code>不兼容的浏览器，如果你想要一个覆盖99的低复杂度的解决方案，这是很好的。正在使用的浏览器的X%。如果你想覆盖罕见的浏览器的长尾，下面的段落显示了如何。</p><p id="31b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面忽略的一个浏览器组是在Android上安装的较旧的UC浏览器。在大多数市场，这可能没问题。检测它需要更昂贵的解析来提取版本号。浏览器通常会自动更新，并且在大多数市场的使用份额相对较低，因此对于许多网站来说，来自未更新的UC浏览器的访问份额非常小。然而，在一些亚洲国家，UC浏览器是巨大的，你可能无法忽略旧的安装。在这种情况下，您可以使用下面的代码来可靠地检测不应该获得<code class="fe mr ms mt mu b">SameSite=None</code>cookie的安装。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a3af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在包括UC浏览器的检查之后，我们仍然忽略了Chromium的旧安装，以及MacOS 10.14上的嵌入式web视图。这些是条纹，但是可以被探测到。检测Chromium的方法与我们检测Chrome的方法类似，可以通过检查用户代理字符串是否包含“OS X 10_14_”并以“(KHTML，like Gecko)”结尾来检测Mac嵌入式浏览器。最后，给出了一个有点长，但完整的检查如下。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2836" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以与其他来源给出的用户代理嗅探建议进行比较。</p><p id="1f2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ASP.NET博客<a class="ae lb" href="https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/" rel="noopener ugc nofollow" target="_blank">提供了Azure Active Directory团队使用的样本代码</a>来做这件事。它与我们上面的轻量级版本非常一致，因为它使用子串检查，并且只涵盖了旧的Chrome、iOS 12和MacOS 10.14的情况。</p><p id="fd57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Chrome团队提供了一个用户代理嗅探的<a class="ae lb" href="https://www.chromium.org/updates/same-site/incompatible-clients" rel="noopener ugc nofollow" target="_blank">伪代码实现，它检测已知不兼容浏览器的完整列表。它依赖于运行多个正则表达式来提取和读取版本号。一个快速的非正式基准测试显示它大约慢了2.5倍。这可能根本不重要，取决于你的负载量。</a></p><p id="d9f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在40000个不同的真实世界用户代理的数据集上比较了谷歌版本和我们版本的结果。它们的区别只是在边缘的边缘:例如，谷歌的regex要求在Chrome/[versionNumber]之后有一个空格，因此不会识别(几乎没有使用过的)Chromium衍生版本Vivo浏览器6.0，该版本将Chrome/[versionNumber]放在用户代理字符串的末尾。我们的版本需要在“iPhone OS 12_”中添加下划线，以便将来针对iOS 120进行验证，但因此错过了iOS 12上谷歌地图应用程序的嵌入式web视图，该视图报告自己为“iPhone OS 12.n”(带点)。这两者的使用份额基本为零。在支持未来的iOS 120与支持iOS 12上的谷歌地图web视图和完整版本号解析之间做出权衡，是受虐读者的一项练习。对大多数人来说，这两种解决方案都足够好了。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="60aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc">最初发表于</em><a class="ae lb" href="https://catchjs.com/Blog/SameSiteCookies" rel="noopener ugc nofollow" target="_blank"><em class="lc">【https://catchjs.com】</em></a><em class="lc">。</em></p></div></div>    
</body>
</html>