<html>
<head>
<title>Decouple object interaction with a ‘Mediator’ like pattern in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ruby中类似“中介者”的模式解耦对象交互</h1>
<blockquote>原文：<a href="https://itnext.io/decouple-object-interaction-with-a-mediator-like-pattern-in-ruby-a9ee1e61c491?source=collection_archive---------5-----------------------#2019-05-17">https://itnext.io/decouple-object-interaction-with-a-mediator-like-pattern-in-ruby-a9ee1e61c491?source=collection_archive---------5-----------------------#2019-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc32" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">减少通信对象之间的耦合和依赖。事件驱动的方法。</h2></div><p id="5bdb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设计模式是软件设计[1]中给定上下文中常见问题的可重用解决方案。一般来说，牢记设计模式是一个好习惯，但是应该避免从一开始就应用它们。思考好的设计是一件好事，但是一直应用它会伤害你的软件、维护和一些人为了理解一个类做了什么而需要付出的努力。在我看来，一直应用模式，特别是对于简单的任务，会使事情变得复杂，我们会以过度工程化的解决方案和不必要的软件复杂性而告终。</p><p id="0cab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将介绍<strong class="kk iu">中介</strong> <strong class="kk iu">设计模式</strong>【2】，以及一个如何使用它来降低多个对象之间通信复杂性的实例。我们将引入一个协调器类(中介器),它将处理不同类之间的所有通信，以便通过促进松散耦合来支持代码的轻松维护。</p><p id="5310" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图显示了中介模式的UML图。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/77c69eee1417993a8ffaccecdd00fc66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/0*hLF2YSpIyHwjq-cz.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">中介设计模式UML图[3]。</figcaption></figure><p id="794c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，我们有以下几点:</p><ul class=""><li id="98b7" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated"><strong class="kk iu">组件(同事):</strong>是包含一些业务逻辑的各种类。每个组件都有一个对中介的引用，但是它不知道使用了哪个中介以及原因。这为我们提供了更好的可重用组件。</li><li id="5ac2" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu">中介器</strong>:中介器定义了一个方法，这个方法将被每个传递上下文对象的组件调用。注意，在接收者和发送者之间(组件之间)不应该发生耦合。</li></ul><p id="2021" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面可以看出，每个组件不应该知道系统中的其他组件。一旦收到消息，中介将负责处理不同对象之间的<strong class="kk iu">通信和交互</strong>。</p><p id="205c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">高级架构和系统设计中的中介可以被视为封装不同组件之间通信的消息代理或服务总线。组件之间的每次通信都可以通过<strong class="kk iu">传递事件</strong> ( <a class="ae me" href="https://en.wikipedia.org/wiki/Event-driven_architecture" rel="noopener ugc nofollow" target="_blank">事件驱动架构</a>)并将调用路由到不同的消费者来完成。中介可以包含一些逻辑(如管道和过滤器)以满足一个用例，或者它可以只包含相关组件的初始化逻辑和错误处理。我更喜欢后者，倾向于让中介尽可能的精简，除了一些错误处理(如果需要的话)之外，没有太多的逻辑，并且只充当从不同组件接收的消息之间的路由器。</p><p id="07e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说了以上，下面来看一个假设的例子:</p><pre class="lf lg lh li gt mf mg mh mi aw mj bi"><span id="1688" class="mk ml it mg b gy mm mn l mo mp">class <em class="mq">RequestCompletedService<br/>  </em>attr_reader :request</span><span id="6831" class="mk ml it mg b gy mr mn l mo mp">  def initialize(<em class="mq">request</em>)<br/>    @request = <em class="mq">request<br/>  </em>end</span><span id="39a1" class="mk ml it mg b gy mr mn l mo mp">  def call<br/>    if request.empty? &amp;&amp; request.acknowledged?<br/>      return UserService.put(DataBuilder.null)<br/>    end</span><span id="1120" class="mk ml it mg b gy mr mn l mo mp">    if !rules_applied?<br/>      return request.error("Invalid request!")<br/>    end</span><span id="d80d" class="mk ml it mg b gy mr mn l mo mp">    <em class="mq">request_data </em>= RequestService.get_details(request)<br/>    if <em class="mq">request_data</em>.empty?<br/>      return request.error("Missing request data")<br/>    end</span><span id="8db9" class="mk ml it mg b gy mr mn l mo mp">    <em class="mq">localized_request_data </em>= LocalizedRequestFormatter.call(<em class="mq">request_data</em>)</span><span id="4135" class="mk ml it mg b gy mr mn l mo mp">    if <em class="mq">localized_request_data</em>.size &gt; TOTAL_PAYLOAD_THREASHOLD<br/>      @upload_url = RequestUploader.call(<em class="mq">localized_request_data</em>)<br/>    end</span><span id="8d3b" class="mk ml it mg b gy mr mn l mo mp">    <em class="mq">some_other_service_payload </em>= DataBuilder.build(<br/>      data: <em class="mq">localized_request_data</em>,<br/>      attachment: @upload_url<br/>    )</span><span id="027b" class="mk ml it mg b gy mr mn l mo mp">    UserService.put(<em class="mq">some_other_service_payload</em>)<br/>    request.complete!<br/>  rescue LocalizedRequestFormatter::Error<br/>    request.error!("Formatting error")<br/>  rescue UserService::NotFoundError<br/>    request.destroy!<br/>  rescue UserService::BadRequestError<br/>    request.error!("Malformed request created.")<br/>  end</span><span id="25e8" class="mk ml it mg b gy mr mn l mo mp">private</span><span id="3a4e" class="mk ml it mg b gy mr mn l mo mp">def rules_applied?<br/>    # ...<br/>  end</span><span id="e8d6" class="mk ml it mg b gy mr mn l mo mp">end</span></pre><p id="f99e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很有逻辑。上面代码的最初意图是将逻辑保存在一个地方。我们看到一些业务规则(如“应用的规则”?或者如果请求为空并被确认)，然后是一些处理逻辑，包括获取一些请求细节并为不同的服务构建另一个请求——在我们的例子中是<em class="mq">用户服务</em>。</p><p id="5b38" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">上面的课怎么了？</strong></p><ol class=""><li id="aee7" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld ms lw lx ly bi translated">显而易见的是，它有太多的责任，因此它违反了<a class="ae me" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>。</li><li id="99fc" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld ms lw lx ly bi translated">忽略<a class="ae me" href="https://www.infoq.com/news/2014/10/ddd-onion-architecture" rel="noopener ugc nofollow" target="_blank">洋葱架构</a>和<a class="ae me" href="https://www.infoq.com/news/2014/10/ddd-onion-architecture" rel="noopener ugc nofollow" target="_blank"> DDD原则</a>，现在还不清楚我们的领域应该专注于什么？它应该是我们的请求实体的状态和业务用例吗？我们的域规则还是外部服务调用？</li><li id="7206" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld ms lw lx ly bi translated">很难测试。</li><li id="e487" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld ms lw lx ly bi translated">我们使用异常来处理控制流和做出决策。</li></ol><p id="5e7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管上述用例中的每个组件似乎都有一个简单的逻辑(格式化数据、获取数据或构建相关数据)，但在不模仿实现的情况下，<em class="mq">RequestCompletedService</em>中的逻辑很难单独测试。</p><p id="0af1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们能做得更好吗？</p><p id="b5e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看如何通过保持<em class="mq">RequestCompletedService</em>尽可能的精简来分离上述类中的职责，并且只知道如何在所涉及的组件之间路由不同的消息。我们将像中介对象一样使用<em class="mq">RequestCompletedService</em>,以便根据发生的不同事件协调系统中不同组件之间的请求。</p><p id="69ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看我们需要做出的改变:</p><ol class=""><li id="2338" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld ms lw lx ly bi translated">每个组件都需要一个对中介的引用</li><li id="b30b" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld ms lw lx ly bi translated">中介将初始化每个组件，并定义一个“notify”方法，每个组件将调用该方法来通知它一个事件。</li><li id="8013" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld ms lw lx ly bi translated">中介将“监听”这些事件，并根据它引发的事件采取不同的行动。</li><li id="4aec" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld ms lw lx ly bi translated">操作将是调用负责处理事件的正确组件。</li></ol><p id="b092" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看第二个版本的<em class="mq"> RequestCompletedService </em>:</p><pre class="lf lg lh li gt mf mg mh mi aw mj bi"><span id="1d39" class="mk ml it mg b gy mm mn l mo mp">class <em class="mq">RequestCompletedService<br/>  </em>attr_reader :request, <br/>              :request_policy, <br/>              :request_service, <br/>              :formatter, <br/>              :uploader, <br/>              :data_builder, <br/>              :user_service</span><span id="26c3" class="mk ml it mg b gy mr mn l mo mp">  def initialize(<em class="mq">request</em>)<br/>    @request = <em class="mq">request<br/>    </em>@request_policy = RequestPolicy.new(<em class="mq">request</em>)<br/>    @request_policy.mediator = self</span><span id="f4e5" class="mk ml it mg b gy mr mn l mo mp">    @request_service = RequestService.new<br/>    @request_service.mediator = self</span><span id="3af2" class="mk ml it mg b gy mr mn l mo mp">    @formatter = LocalizedRequestFormatter.new<br/>    @formatter.mediator = self</span><span id="1579" class="mk ml it mg b gy mr mn l mo mp">    @uploader = RequestUploader.new<br/>    @uploader.mediator = self</span><span id="602d" class="mk ml it mg b gy mr mn l mo mp">    @data_builder = DataBuilder.new<br/>    @data_builder.mediator = self</span><span id="2dc7" class="mk ml it mg b gy mr mn l mo mp">    @user_service = UserService.new<br/>    @user_service.mediator = self<br/>  end</span><span id="683f" class="mk ml it mg b gy mr mn l mo mp">def call<br/>    request_policy.call<br/> end</span><span id="dd5b" class="mk ml it mg b gy mr mn l mo mp">def notify(<em class="mq">event</em>)<br/>    case <em class="mq">event</em>.type<br/>    when EmptyRequestAcknowledged<br/>      user_service.put(data_builder.null)<br/>    when EmptyRequest<br/>      request.error!(<em class="mq">event</em>.data.reason)<br/>    when RequestReadyToBeProcessed<br/>      request_service.get_details(request.id)<br/>    when FetchRequestDataCompleted<br/>      formatter.call(<em class="mq">event</em>.data.request_details)<br/>    when DataFormatted<br/>      uploader.call(<em class="mq">event</em>.data.formatted_data)<br/>    when DataUploaded, DataUploadSkipped<br/>      DataBuilder.build(<br/>        data: <em class="mq">event</em>.data.formatted_data,<br/>        attachment: <em class="mq">event</em>.data.remote_url<br/>      )<br/>    when UserDataBuildCompleted<br/>      UserService.put(<em class="mq">event</em>.data.user_data)<br/>    when UserServiceNotFound<br/>      request.destroy<br/>    when FormatDataError, UserServiceBadRequest, GetRequestDataError<br/>      request.error!(<em class="mq">event</em>.data.reason)<br/>    end<br/>  end<br/>end</span></pre><p id="7474" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好极了。看起来有点像Redux reducer —:)，但是让我们看看我们实现了什么:</p><ul class=""><li id="03b1" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated">我们仍然将业务用例的处理逻辑放在一个地方，这是我们最初的意图。</li><li id="a21a" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><em class="mq"> RequestCompletedService </em>现在只对事件做出反应，并且只在组件之间路由和发送消息。</li><li id="f7fa" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">服务内部用例的单一来源。</li><li id="1515" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">组件可以在不同的中介实现中重用。</li><li id="eccf" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">我认为代码现在更容易理解和推理，因为如果你至少知道一些关于用例及其背后的过程，查看事件，你可以立即看到发生了什么以及你如何对它做出反应。</li><li id="7a69" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">更容易测试和更好的隔离。请记住，在前面的实现中调用服务可能会对每次调用产生不同的副作用。现在，当<strong class="kk iu">基于被调度的<strong class="kk iu">事件</strong>应用</strong>时，我们只有<strong class="kk iu"> 1副作用</strong>。</li><li id="22b7" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu">领域事件</strong>是<strong class="kk iu">业务</strong>【4】和<strong class="kk iu">建模</strong>的一个重要方面，我认为在代码中使用它们是一个巨大的优势，尤其是当你与利益相关者和产品所有者交谈时。例如，当你阅读一段写有<code class="fe mt mu mv mg b">if a &amp;&amp; b</code>的代码，并试图理解a &amp; &amp; b的意思，而不是阅读<code class="fe mt mu mv mg b">if CONTRACT_ENDED</code>时，情况就不同了。它立即给你意图和你对此的反应。它对涉众来说更加透明，尤其是如果你遵循DDD原则，并试图在你的基于无处不在的语言的代码中应用它们。</li><li id="d5a3" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">当“if else”语句变得复杂时，我们可以很容易地将它们提取到一个<a class="ae me" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank">策略</a>或<a class="ae me" href="https://en.wikipedia.org/wiki/State_pattern" rel="noopener ugc nofollow" target="_blank">状态模式</a>中，但我认为现在这样做有些过头了。</li><li id="5504" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">将<strong class="kk iu">松耦合</strong>和<strong class="kk iu">高内聚</strong>提升到该具体用例中。</li><li id="7319" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">它可能会更好，但我认为我们已经迈出了更好的一步。</li></ul><p id="3554" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看下面的一些组件实现。</p><p id="3518" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们上面看到的第一个组件叫做<em class="mq"> RequestPolicy </em>，它将负责通过发出正确的事件来实例化我们的处理逻辑。在我们开始处理请求之前，它还将确保请求处于正确的状态，并在我们无法处理请求时引发错误(请注意，应该引发此错误，因为它是我们的<strong class="kk iu">域</strong>中的未知错误)。这是我们无法处理的例外情况)。</p><pre class="lf lg lh li gt mf mg mh mi aw mj bi"><span id="dba8" class="mk ml it mg b gy mm mn l mo mp"># class <em class="mq">RequestPolicy will be the component responsible to handle # # our `rules_applied?` validation logic.<br/># It is also our initial component that will be called first from the<br/># mediator. All other interactions will be based on the events that # are raised after the first call.</em></span><span id="8763" class="mk ml it mg b gy mr mn l mo mp">class <em class="mq">RequestPolicy<br/>  </em>include Colleague</span><span id="643f" class="mk ml it mg b gy mr mn l mo mp"><em class="mq">UnknownRequestState </em>= Class.new(StandardError)</span><span id="38ee" class="mk ml it mg b gy mr mn l mo mp">  attr_reader :request</span><span id="87dc" class="mk ml it mg b gy mr mn l mo mp">  def initialize(request)<br/>    @request = request<em class="mq"><br/>  </em>end</span><span id="d4cd" class="mk ml it mg b gy mr mn l mo mp">  def call<br/>    if request.empty? &amp;&amp; request.acknowledged?<br/>       notify(EmptyRequestAcknowledged)<br/>    elsif request.empty?<br/>      notify(EmptyRequest, data: { reason: empty request" })<br/>    elsif request.completed?<br/>      notify(RequestReadyToBeProcessed)<br/>    else<br/>      raise UnknownRequestState<br/>  end<br/>end</span></pre><p id="dd65" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单。我们从这个组件的初始服务中移除了验证和前提条件逻辑。在开始处理之前，我们确保前提条件得到满足，并且我们还检查请求中的一些确认的逻辑。根据请求的状态，发出不同的事件。</p><p id="42a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还在上面的组件中包含了一个名为<code class="fe mt mu mv mg b">Colleague(the name is bad but will stick with it for our examples)</code>的助手模块，以便提供一些像notify这样的助手方法。让我们看看下面的模块定义:</p><pre class="lf lg lh li gt mf mg mh mi aw mj bi"><span id="8c73" class="mk ml it mg b gy mm mn l mo mp">module <em class="mq">Colleague<br/>  </em>def self.included(<em class="mq">base</em>)<br/>    <em class="mq">base</em>.class_eval do<br/>      attr_reader :mediator<br/>    end</span><span id="f38c" class="mk ml it mg b gy mr mn l mo mp">    super<br/>  end</span><span id="5af6" class="mk ml it mg b gy mr mn l mo mp">  def mediator=(<em class="mq">mediator</em>)<br/>    @mediator = <em class="mq">mediator<br/>  </em>end</span><span id="4775" class="mk ml it mg b gy mr mn l mo mp">  def notify(<em class="mq">type</em>, <em class="mq">data</em>: {})<br/>    mediator.notify(event(<em class="mq">type</em>, data: <em class="mq">data</em>))<br/>  end</span><span id="b27d" class="mk ml it mg b gy mr mn l mo mp">  private</span><span id="e32c" class="mk ml it mg b gy mr mn l mo mp">  def event(<em class="mq">type</em>, <em class="mq">data</em>: {})<br/>    Events::Base.new(<em class="mq">type</em>, data: <em class="mq">data</em>)<br/>  end<br/>end</span></pre><p id="d742" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单，它提供了一个setter方法来设置mediator和一些helper方法来通知和创建事件逻辑。</p><p id="c762" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看另一个组件，<em class="mq"> RequestService </em>，它负责获取请求细节。请注意，下面的异常不再委托给中介，而是通过事件进行通信。</p><pre class="lf lg lh li gt mf mg mh mi aw mj bi"><span id="e6b2" class="mk ml it mg b gy mm mn l mo mp">class RequestService<br/>  include Colleague</span><span id="5a8f" class="mk ml it mg b gy mr mn l mo mp">def initialize(client: HttpClient; @client = client; end</span><span id="66d0" class="mk ml it mg b gy mr mn l mo mp">def get_details(id)<br/>     client.get!(path, id: id) # imaginary call</span><span id="7e49" class="mk ml it mg b gy mr mn l mo mp">rescue SomeExternalException<br/>       notify(GetRequestDataError, data: { reason: "get request details failed"})</span><span id="2b7c" class="mk ml it mg b gy mr mn l mo mp">end</span><span id="0d92" class="mk ml it mg b gy mr mn l mo mp">end</span></pre><p id="5421" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的组件逻辑很简单，我们可能有像下面这样逻辑更复杂的组件:</p><pre class="lf lg lh li gt mf mg mh mi aw mj bi"><span id="8c29" class="mk ml it mg b gy mm mn l mo mp">class DataBuilder<br/>  include Colleague<br/>  <br/>  include OtheRelatedModule</span><span id="dbbe" class="mk ml it mg b gy mr mn l mo mp">def null; {}; end</span><span id="0d55" class="mk ml it mg b gy mr mn l mo mp">def build(data: , attachment: nil)<br/>    assert_required_attibutes!(data)<br/>    assert_optional_attibutes!(data)</span><span id="b85e" class="mk ml it mg b gy mr mn l mo mp">user_data = create_domain_data(data) # "complex logic"</span><span id="35fc" class="mk ml it mg b gy mr mn l mo mp">notify(UserDataBuildCompleted, data: { user_data: user_data})<br/>    <br/>    rescue InternalErrorA, InternalErrorB =&gt; ex<br/>      notify(BuildDataError, data: { reason: ex.message })</span><span id="c460" class="mk ml it mg b gy mr mn l mo mp">end</span><span id="2115" class="mk ml it mg b gy mr mn l mo mp">end</span></pre><p id="e693" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以类似的方式，所有其他组件都被定义为上面的组件，每个组件都有自己的实现，并向其中介发送事件。</p><p id="98f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在想象一下，您需要创建一个具有自己逻辑的新组件。只需在中介中进行新的初始化，并监听正确的事件，就可以调用新的组件。组件本身要么终止处理逻辑(不再发出事件),要么发出一个已经存在的或新的事件，以便根据场景调用正确的组件。上面一个简单的例子是一个通知组件，当数据被发送到用户服务或者请求被删除时，它会发送一个通知消息。这里的关键是域事件<strong class="kk iu">。</strong></p><p id="dd98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">缺点</strong></p><ul class=""><li id="601b" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated">降低组件之间的复杂性会增加中介本身的复杂性，尤其是在中介中有逻辑的情况下。</li><li id="4c78" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">增加中介器的复杂性与没有中介器的设计是一样的。</li></ul><p id="b82e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">相似模式</strong>:</p><ul class=""><li id="e1df" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated"><a class="ae me" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者</a></li><li id="64a0" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><a class="ae me" href="https://en.wikipedia.org/wiki/Facade_pattern" rel="noopener ugc nofollow" target="_blank">立面</a></li></ul><h1 id="bec2" class="mw ml it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">结论</h1><p id="5eb5" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">我们采取了不同的方法，通过使用事件驱动的架构和引入中介对象来封装一组对象如何交互，来实现用例。我们从这种方法中获得了很多好处，最重要的是有更好的测试和更透明的领域逻辑。将域事件引入我们的代码库使得代码更具可读性，也更容易推理。通过应用领域事件，与涉众和产品所有者的交叉交流得到了改善，并使我们进一步应用DDD和其他架构模式，如<a class="ae me" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank"> Clean Architecture </a>。</p><h1 id="306a" class="mw ml it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">参考</h1><p id="364e" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">【1】【https://en.wikipedia.org/wiki/Software_design_pattern<br/>【2】<a class="ae me" href="https://en.wikipedia.org/wiki/Mediator_pattern" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Mediator_pattern</a><br/>【3】<a class="ae me" href="https://refactoring.guru/design-patterns/mediator" rel="noopener ugc nofollow" target="_blank">https://refactoring.guru/design-patterns/mediator</a><br/>【4】<a class="ae me" href="https://en.wikipedia.org/wiki/Domain-driven_design" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Domain-driven_design</a></p></div></div>    
</body>
</html>