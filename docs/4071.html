<html>
<head>
<title>Adding data to the Vert.X web layer from your Quarkus application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向垂直方向添加数据。来自Quarkus应用程序的X web层</h1>
<blockquote>原文：<a href="https://itnext.io/adding-data-to-the-vert-x-web-layer-from-your-quarkus-application-da817e328a5f?source=collection_archive---------3-----------------------#2020-04-21">https://itnext.io/adding-data-to-the-vert-x-web-layer-from-your-quarkus-application-da817e328a5f?source=collection_archive---------3-----------------------#2020-04-21</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="3b60" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我在我的<a class="ae km" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a> <a class="ae km" href="https://github.com/RedHatInsights/policies-ui-backend" rel="noopener ugc nofollow" target="_blank">应用</a>中创建了一个访问日志过滤器，作为Vert.x web路由器层的一个处理程序。现在，我需要将数据从JAX-RS层的业务逻辑传递到这个访问日志。这篇文章展示了一个可能的解决方案。</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj kn"><img src="../Images/49fa10d2cfcba5a8dc6fa36670d23216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1QXJZZrOM4TqtagNuiq0eg.jpeg"/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">由<a class="ae km" href="https://pixabay.com/de/users/Amigos3D-2257343/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2059775" rel="noopener ugc nofollow" target="_blank">让-保罗·詹德利</a>在<a class="ae km" href="https://pixabay.com/de/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2059775" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>连接管道</figcaption></figure><p id="71c1" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在我的前两篇文章(<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/how-to-mangle-http-headers-in-quarkus-d91a904adea7"> 1 </a>、<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/how-to-rewrite-http-request-paths-in-quarkus-aa85c3400d95"> 2 </a>)中，我谈到了如何在Vert.x web路由器层修改HTTP-requests，这对于上层是透明的。</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div class="gi gj ld"><img src="../Images/209e8a95d770f49122b5a6c8b907e41b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*jaGytm0er0xzCANK1z_xtA.png"/></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">我的代码的请求流(红色)和数据流(绿色)</figcaption></figure><p id="078c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这次我需要向下传输数据(上图中的绿色箭头)。我可以将它添加到HTTP响应的头中，但是由于这些数据不应该发送到客户端，所以这不是一个选项。</p><p id="f573" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我的业务代码位于JAX-RS <a class="ae km" href="https://github.com/RedHatInsights/policies-ui-backend/blob/master/src/main/java/com/redhat/cloud/policies/app/auth/IncomingRequestFilter.java" rel="noopener ugc nofollow" target="_blank">容器请求过滤器</a>中，在对一个头字段进行一些处理后，从传入的请求中提取accountId:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="198e" class="lj lk ir lf b gz ll lm l ln lo">@PreMatching<br/>@Provider<br/>public class MyFilter implements <strong class="lf is">ContainerRequestFilter</strong> {</span><span id="fffc" class="lj lk ir lf b gz lp lm l ln lo">  @Override<br/>  public void filter(ContainerRequestContext <strong class="lf is">requestContext</strong>) <br/>         throws IOException {<br/><br/>    String xrhid_header = <strong class="lf is">requestContext<br/>               </strong>.getHeaderString("x-rh-identity");</span><span id="fa74" class="lj lk ir lf b gz lp lm l ln lo">    String accountId = getAccountId(xrhid_header); // see below</span></pre><p id="7634" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">但是我现在如何将它转发给我在Vert.x层的日志处理程序呢？</p><h2 id="af57" class="lj lk ir bd lq lr ls dn lt lu lv dp lw jz lx ly lz kd ma mb mc kh md me mf mg bi translated">CDI拥有一切</h2><p id="187f" class="pw-post-body-paragraph jo jp ir jq b jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ml kj kk kl ik bi translated">Quarkus在CDI中提供了大量资源，随时可以注入到您的代码中。其中一个资源是当前HTTP请求的Vert.x <em class="mm"> RoutingContext </em>。这个上下文有一个方法<em class="mm"> put(key，value) </em>来沿着处理程序和RouteFilters链转发任意内容。我们可以通过这个助手获得上下文:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="a9e7" class="lj lk ir lf b gz ll lm l ln lo">CurrentVertxRequest <strong class="lf is">request()</strong> {<br/>  if (currentVertxRequest == null) {<br/>    currentVertxRequest = CDI.<em class="mm">current</em>()<br/>          .select(CurrentVertxRequest.class).get();<br/>  }<br/>  return currentVertxRequest;<br/>}</span></pre><p id="36aa" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">然后在我们的容器请求过滤器中使用它:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="16db" class="lj lk ir lf b gz ll lm l ln lo">RoutingContext routingContext = <strong class="lf is">request()</strong>.getCurrent();<br/>routingContext.put("x-rh-account", accountId);</span></pre><p id="1f7d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">之后，我们可以在我们的<a class="ae km" href="https://github.com/RedHatInsights/policies-ui-backend/blob/master/src/main/java/com/redhat/cloud/policies/app/JsonAccessLoggerHandler.java" rel="noopener ugc nofollow" target="_blank">日志处理程序</a>中再次从路由上下文中检索数据:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="94f3" class="lj lk ir lf b gz ll lm l ln lo">void log(RoutingContext <strong class="lf is">context</strong>, ...  {<br/>    String acctId = <strong class="lf is">context</strong>.get("x-rh-account");</span></pre><h2 id="6c6f" class="lj lk ir bd lq lr ls dn lt lu lv dp lw jz lx ly lz kd ma mb mc kh md me mf mg bi translated">结论</h2><p id="231a" class="pw-post-body-paragraph jo jp ir jq b jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ml kj kk kl ik bi translated">上述代码位于代码库中的几个不同位置。上面是一个缩略版本，你可以在GitHub的链接类中看到完整的代码。您仍然可以看到如何从Quarkus代码中更高的更面向业务的层访问Vert.x web路由层，并使业务数据对Vert.x web层可用。</p></div></div>    
</body>
</html>