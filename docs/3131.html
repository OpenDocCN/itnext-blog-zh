<html>
<head>
<title>Java Generics: Intersection Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java泛型:交集类型</h1>
<blockquote>原文：<a href="https://itnext.io/java-generics-intersection-types-23b2fbdddfbb?source=collection_archive---------3-----------------------#2019-10-09">https://itnext.io/java-generics-intersection-types-23b2fbdddfbb?source=collection_archive---------3-----------------------#2019-10-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="cf3f" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">Java 5中的未知特性以及Java 8和10中的一些改进</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/f7248946aa3b082ef1f9ca169cc388bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFy84eXNDFtzAfr5ltERjA.jpeg"/></div></div></figure><p id="2867" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">泛型是在<strong class="kx iv">Java 5</strong>(2004年)中作为杀手级特性引入的，从那以后被Java开发人员广泛使用，但是泛型中有一个特性叫做<code class="fe lr ls lt lu b">Intersection Types</code>，很多Java开发人员都不知道。在本文中，我将介绍这一特性及其在泛型类和方法中的用法，以及它在用于类型推断的<strong class="kx iv"> Java 8 </strong> lambda表达式和<strong class="kx iv"> Java 10 </strong> <code class="fe lr ls lt lu b">var</code>关键字中的用法和改进。</p><h1 id="1a85" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">到底什么是交集类型？</h1><p id="efd8" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">让我们假设我们想要设计一个新的日志聚合器系统作为数据类型，以便它可以读取和流式传输日志，根据<a class="ae ms" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank">接口分离原则(ISP) </a>在<a class="ae ms" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">固体原则</a>中，最好将这两个概念定义到两个单独的接口中，而不是一个接口中:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mt mu l"/></div></figure><p id="943d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在我们想实现一个名为<code class="fe lr ls lt lu b">streamLog</code>的方法，它只接受同时实现LogReader和LogStreamer接口的日志聚合器系统。我们做什么呢</p><h2 id="90a2" class="mv lw iu bd lx mw mx dn mb my mz dp mf le na nb mh li nc nd mj lm ne nf ml ng bi translated">第一种方法:定义新的接口</h2><p id="275c" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">通过定义一个名为<code class="fe lr ls lt lu b">LogReaderStreamer</code>的新接口，我们可以将输入参数限制为我们想要的类型:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mt mu l"/></div></figure><p id="b709" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在我们可以这样实现<code class="fe lr ls lt lu b">streamLog</code>方法:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mt mu l"/></div></figure><h2 id="2285" class="mv lw iu bd lx mw mx dn mb my mz dp mf le na nb mh li nc nd mj lm ne nf ml ng bi translated">第二种方法:使用交叉点类型</h2><p id="e982" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">定义一个新的接口并不是一个好主意，而且会产生大量的样板代码。交集类型是Java中泛型类型的一种形式，它在泛型类型参数中使用<code class="fe lr ls lt lu b">&amp;</code>语法，看起来像这个<code class="fe lr ls lt lu b">&lt;T extends TypeA &amp; TypeB&gt;</code>，其中<code class="fe lr ls lt lu b">T</code>是一个类型参数，<code class="fe lr ls lt lu b">TypeA</code>和<code class="fe lr ls lt lu b">TypeB</code>是两种类型。这个泛型类型表示<code class="fe lr ls lt lu b">T</code>应该扩展<code class="fe lr ls lt lu b">TypeA</code>和<code class="fe lr ls lt lu b">TypeB</code>。通过使用交集类型，我们不需要定义新的接口，可以像这样实现<code class="fe lr ls lt lu b">streamLog</code>方法:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mt mu l"/></div></figure><p id="375c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">第二种方法更具可扩展性和可维护性。</p><h1 id="65b1" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">使用Java 8中的交集类型强制转换lambda表达式</h1><p id="860f" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">在Java 8中，我们可以使用交集类型将lambda表达式转换为几种类型，并向其添加其他行为。在我们之前的例子中<code class="fe lr ls lt lu b">LogReader</code>和<code class="fe lr ls lt lu b">LogStreamer</code>是函数接口，假设我们需要使它们可序列化，为此我们可以这样使用交集类型:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mt mu l"/></div></figure><p id="f22a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">通过使用交集类型强制转换lambda表达式，我们使<code class="fe lr ls lt lu b">LogReader</code> lambda表达式可序列化，但在使用交集类型声明变量时有一个小问题，logReader变量类型应该是<code class="fe lr ls lt lu b">LogReader</code>或<code class="fe lr ls lt lu b">Serializable</code>，然后当我们想要将它发送给仅获得<code class="fe lr ls lt lu b">Serializable</code>类型的<code class="fe lr ls lt lu b">serializeIt</code>方法时，我们应该将其强制转换为<code class="fe lr ls lt lu b">Serializable</code>。</p><h1 id="c677" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated"><em class="nh">使用Java 10 var捕捉交集类型</em></h1><p id="41b5" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">由于在Java 10中引入了局部变量类型推断，我们可以在局部变量级别做同样的事情，让编译器推断类型:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mt mu l"/></div></figure><p id="0e46" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在，我们可以将logger变量发送给<code class="fe lr ls lt lu b">serializeIt</code>方法，而无需强制转换。</p><h1 id="4f58" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">结论</h1><p id="7ba4" class="pw-post-body-paragraph kv kw iu kx b ky mn jv la lb mo jy ld le mp lg lh li mq lk ll lm mr lo lp lq in bi translated">交集类型是泛型特性的一部分，是在<strong class="kx iv">Java 5</strong>(2004年)中引入的，但是一些Java开发人员并不知道它。在需要从两种或更多种类型扩展，但又不想为此定义新的接口或类的情况下，这可能是一个很好的解决方案。</p><p id="32de" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">通过在Java 8中引入lambda表达式和在Java 10中引入局部变量类型推断，交集类型的使用得到了很大的改进。</p></div></div>    
</body>
</html>