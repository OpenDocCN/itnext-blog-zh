<html>
<head>
<title>Simple solution structure for Azure Functions &amp; Table Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure函数和表存储的简单解决方案结构</h1>
<blockquote>原文：<a href="https://itnext.io/simple-solution-structure-for-azure-functions-table-storage-f07f78998e92?source=collection_archive---------1-----------------------#2021-12-27">https://itnext.io/simple-solution-structure-for-azure-functions-table-storage-f07f78998e92?source=collection_archive---------1-----------------------#2021-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/09ebe4e72fbba7b13e7bf65b050411e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WyGM3q4yX-XShoI3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@kaleidico?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">万花筒</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fe3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自从我开始倾向于Azure，我发现创建和管理资源是多么容易。然而，我不得不承认，云上的大多数选项对于大中型企业来说都是负担得起的。每个云提供商也为他们的一些服务提供免费层，但他们并不打算持有重要的东西(他们中的大多数是出于沙盒的目的)。</p><p id="37ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望我的项目能够轻松实现云计算。并且，我认为如果我使用<strong class="kf ir"> Azure Functions </strong>作为Web Api &amp; <strong class="kf ir">表存储</strong>作为数据库，我的钱包会很安全。但是我也不想依赖Azure。因此，万一出现意外情况，我需要能够将我的数据库和应用程序切换到其他地方。</p><p id="5d0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我基本上实现了一个类似于<em class="lb">干净架构的</em>结构，将业务从数据库和API端点中分离出来。</p><blockquote class="lc ld le"><p id="b709" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><strong class="kf ir">TLDR；</strong>这篇文章解释了一个解决方案结构，我使用来实现Azure功能，使用表存储作为基于Clean架构和中介模式的数据库。</p></blockquote><p id="7cb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">→关于“清洁架构”的详细信息，请查看Github上的这个</em> <a class="ae kc" href="https://github.com/jasontaylordev/CleanArchitecture" rel="noopener ugc nofollow" target="_blank"> <em class="lb">回购</em> </a></p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="af2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我计划有一个这样的解决方案:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="26b8" class="ly lz iq lu b gy ma mb l mc md">Solution<br/>|--App.Functions<br/>|--App.Application<br/>|--App.Domain<br/>|--App.Infrastructure</span></pre><h2 id="4464" class="ly lz iq bd me mf mg dn mh mi mj dp mk ko ml mm mn ks mo mp mq kw mr ms mt mu bi translated">1) App。功能</h2><p id="86ee" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">将名为<code class="fe na nb nc lu b">App.Functions</code>的新<strong class="kf ir"> Azure Function </strong>项目添加到解决方案中。在向导中选择<code class="fe na nb nc lu b">Http Trigger</code>。它将为我们创建一个示例函数。但是我们需要为解决方案做一些安排。</p><p id="f519" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> —依赖注入</strong></p><p id="1049" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往，我们需要做的第一件事是准备依赖注入。在模板中，没有启动类。首先，我们要创建一个名为<code class="fe na nb nc lu b">Startup.cs</code>的文件</p><p id="81a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看下面的例子:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="147e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性<code class="fe na nb nc lu b">[assembly:FunctionStartup(typeof(App.Function.Startup))]</code>告诉应用程序这个类将被用作初始化器(web API项目中的<code class="fe na nb nc lu b">startup.cs </code>也是如此)。</p><p id="e3a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在<code class="fe na nb nc lu b">builder.Services</code>对象上使用<code class="fe na nb nc lu b">.AddScoped&lt;&gt;</code>、<code class="fe na nb nc lu b">.AddSingletion&lt;&gt;</code>和其他方法来准备您的服务。我们将在接下来的步骤中装饰这个类。</p><p id="e3c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> —中介</strong></p><p id="9eac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MediatR是一个帮助我们在Clean架构中实现CQRS模式的库。我们将定义命令、查询&amp;处理程序来实现应用程序业务。</p><p id="de57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用NuGet包管理器或使用dotnet CLI添加包<code class="fe na nb nc lu b">MediaTr</code></p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="cb15" class="ly lz iq lu b gy ma mb l mc md">dotnet add package MediatR</span></pre><h2 id="1963" class="ly lz iq bd me mf mg dn mh mi mj dp mk ko ml mm mn ks mo mp mq kw mr ms mt mu bi translated">2) App。应用</h2><p id="4aaf" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我们将使用<code class="fe na nb nc lu b">App.Application</code>项目来支持我们的应用业务。这个项目将保留MediatR对象的实现。</p><p id="e2d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个名为<code class="fe na nb nc lu b">DIConfig.cs</code>的类，创建一个扩展方法来注册服务&amp;mediator对象。</p><p id="54c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加这些库以使用MediatR</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="472c" class="ly lz iq lu b gy ma mb l mc md">dotnet add package MediatR<br/>dotnet add package <!-- -->MediatR.Extensions.Microsoft.DependencyInjection</span></pre><p id="deb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它应该看起来像下面这样。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8b64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第9行:向服务注册MediatR元素。(需要安装<code class="fe na nb nc lu b">MediatR.Extensions.Microsoft.DependencyInjection</code>包才能使用<code class="fe na nb nc lu b">.AddMediatR</code>扩展。</p><p id="6927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后使用这个扩展将<code class="fe na nb nc lu b">App.Application</code>注册到函数中。</p><h2 id="0419" class="ly lz iq bd me mf mg dn mh mi mj dp mk ko ml mm mn ks mo mp mq kw mr ms mt mu bi translated">3) App。基础设施</h2><p id="f066" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我们将在这里保留表存储库，并且我们将在这里使用<em class="lb"> Azure表存储</em>。</p><p id="2aef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将以下包添加到您的项目中</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="0014" class="ly lz iq lu b gy ma mb l mc md">dotnet add package Azure.Data.Tables</span></pre><p id="4456" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表存储的基本用法如下所示:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="fa69" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">TableServiceClient </strong>serviceClient <br/>                = new <strong class="lu ir">TableServiceClient</strong>("&lt;connection-string&gt;");</span><span id="fada" class="ly lz iq lu b gy nf mb l mc md">var <strong class="lu ir">tableClient </strong>= client.<strong class="lu ir">GetTableClient</strong>("&lt;table-name&gt;");</span><span id="c4bf" class="ly lz iq lu b gy nf mb l mc md">tableClient.AddEntity&lt;User&gt;(user);</span></pre><p id="b300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们要让它看起来很好&amp;有条理。</p><p id="f901" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，创建一个<code class="fe na nb nc lu b">DIConfig.cs</code>来注册服务&amp;准备<code class="fe na nb nc lu b">TableServiceClient</code></p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0d68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我将为<em class="lb">表存储</em>创建一个通用存储库</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="2f72" class="ly lz iq bd me mf mg dn mh mi mj dp mk ko ml mm mn ks mo mp mq kw mr ms mt mu bi translated">4) App。领域</h2><p id="2fb7" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">正如你所猜测的，这是我们开赌场的地方。我们在这里没有什么花招。</p><p id="4920" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我只有这样的<code class="fe na nb nc lu b">EntityBase.cs</code>和<code class="fe na nb nc lu b">TRef.cs</code>类型:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b8ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe na nb nc lu b">EntityBase</code>保持从ITableEntity实现的属性。我不打算使用API模型&amp; DTO在这里。我最期望的是，我可能需要一个用于表示层的API模型&amp;你知道这个练习的其余部分。</p><p id="ebed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe na nb nc lu b">TRef</code>只是防止我在一个关系的情况下拥有两个不同的属性。</p><p id="0708" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> —结论</strong></p><p id="4777" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许创建一个分层结构是不合适的，因为azure函数的原因是保持它的简单&amp;原子性。但正如我在开始时所说的，这是关于使用云的能力和灵活性，如果它以某种方式开始威胁我的钱包，我必须能够从功能切换到web API &amp;开始使用另一个数据库。这只是我的实践，我想解释一下。</p><p id="e90c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这个<a class="ae kc" href="https://github.com/mehmetural/FunctionDemo" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上查看我的演示。并且，如果你想使用这个结构，你可以在Visual Studio上安装<a class="ae kc" href="https://github.com/mehmetural/FunctionDemo/blob/master/SolutionTemplate.zip" rel="noopener ugc nofollow" target="_blank">这个解决方案模板</a>来启动你自己的项目(1)。</p><p id="8c18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(1)安装zip文件并将其移动到<code class="fe na nb nc lu b"> C:\Users&lt;your-user&gt;\Documents\Visual Studio 2022\Templates\ProjectTemplates</code>，然后搜索“<em class="lb">Clean architecture for Azure functions</em>”。在一些默认模板之后应该会看到。</p></div></div>    
</body>
</html>