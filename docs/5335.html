<html>
<head>
<title>GraphQL Partial Update</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL部分更新</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-partial-update-783bf533a7fc?source=collection_archive---------1-----------------------#2021-02-12">https://itnext.io/graphql-partial-update-783bf533a7fc?source=collection_archive---------1-----------------------#2021-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ecb5f944fe86e70b5acc716f778a1337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1M1THoZDElugCoVBCuyJaQ.png"/></div></div></figure><p id="54fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我们决定将<a class="ae kw" href="https://aws.amazon.com/amplify/" rel="noopener ugc nofollow" target="_blank"> AWS Amplify </a>用于我们目前正在开发的一款产品。</p><p id="cb6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://aws.amazon.com/amplify/" rel="noopener ugc nofollow" target="_blank"> AWS Amplify </a>可以让你通过使用<a class="ae kw" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST </a>或<a class="ae kw" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>相对快速地原型化你的后端API。我们决定使用<a class="ae kw" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>，因为在最后的迭代中，产品应该有不同的前端，并且理论上，由于<a class="ae kw" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>的灵活性，只获取您需要的数据应该更容易。</p><p id="d226" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果你使用过<a class="ae kw" href="https://aws.amazon.com/amplify/" rel="noopener ugc nofollow" target="_blank"> AWS Amplify </a>和<a class="ae kw" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>，你就会知道它不支持部分更新，这对我们来说是一个障碍，因为我们有多个流，我们必须将部分数据推送到后端。</p><p id="46e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在网上做了简短的调查后，我在这里找到了Arnaud Bezan的一篇非常酷的文章</p><p id="003d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我真的很喜欢他做事的方式，但是我懒惰的天性想要一个更通用的(不一定是更好的)解决方案。所以，我的想法是:因为我只发送部分数据到后端，但是它期望从我这里得到整个<code class="fe kx ky kz la b">{ input }</code>对象，我将把现有的数据和新的数据合并，并把它推到后端。</p><p id="5f8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不过，您必须考虑的另一件事是删除模式中任何自动生成/更新的字段——在我的例子中是<code class="fe kx ky kz la b">createdAt/updatedAt</code></p><p id="9533" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，下面你会看到一种快速而肮脏的方法。</p><p id="cd93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我使用<code class="fe kx ky kz la b">email</code>作为我们<code class="fe kx ky kz la b">user</code>模型的<code class="fe kx ky kz la b">key</code>。除此之外，您必须总是将整个带有所有字段的<code class="fe kx ky kz la b">user</code>对象发送给更新变异——这意味着当您调用<code class="fe kx ky kz la b">getUser</code>时，它应该获取带有所有字段的<code class="fe kx ky kz la b">user</code>对象。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="fbd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<code class="fe kx ky kz la b">email</code>被用作<code class="fe kx ky kz la b">user</code>模型的<code class="fe kx ky kz la b">key</code>，它必须作为<code class="fe kx ky kz la b">{ input }</code>对象的一部分传递给<code class="fe kx ky kz la b">createOrUpdate</code>函数。每当我必须创建或更新用户时，我们必须将<code class="fe kx ky kz la b">email</code>添加到<code class="fe kx ky kz la b">input</code>中，然后调用<code class="fe kx ky kz la b">createOrUpdate(input);</code></p><pre class="lb lc ld le gt lh la li lj aw lk bi"><span id="07c2" class="ll lm iq la b gy ln lo l lp lq">const { email } = user;<br/>const input = { email, …payload };</span><span id="f942" class="ll lm iq la b gy lr lo l lp lq">try {<br/>  ...<br/>  await createOrUpdate(input);<br/>  ...<br/>} catch (error) {<br/>  throw new Error(error);<br/>}</span></pre><p id="3654" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是一种有效的方式，因为它会在更新之前从你的后端获取数据，但这样你就不必手动操作或考虑你想要更新的值。</p><p id="af53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是所有的乡亲。</p></div></div>    
</body>
</html>