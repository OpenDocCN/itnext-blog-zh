<html>
<head>
<title>Configurable themes and styles for big projects and monorepos(Angular example)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大型项目和monorepos的可配置主题和风格(角度示例)</h1>
<blockquote>原文：<a href="https://itnext.io/configurable-themes-and-styles-for-big-projects-and-monorepos-angular-example-24be595ff2f8?source=collection_archive---------3-----------------------#2022-12-05">https://itnext.io/configurable-themes-and-styles-for-big-projects-and-monorepos-angular-example-24be595ff2f8?source=collection_archive---------3-----------------------#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a0ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于大型前端项目，主题化的问题以及依赖于上下文的低级组件样式自然会出现。在任何给定的项目中，都有一个自定义的按钮组件、一张卡片和一个根据它们出现的页面使它们看起来不同的要求。组合这些基本组件的组件也是如此，以此类推。如果这敲响了警钟，这里有一个简单而有效的方法来处理这种情况，最精简的非黑客方式。</p><p id="ae45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工作实例在<a class="ae kl" href="https://github.com/amdor/monorepo-dynamic-styles-example" rel="noopener ugc nofollow" target="_blank">https://github.com/amdor/monorepo-dynamic-styles-example</a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/0ac0d87519e15499b0ffce2b3691df68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Oq4cpgZglLpRzNXS"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae kl" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pawel Czerwinski </a>在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="37f2" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">一个普通样式的包</h1><p id="de61" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">需要同样几行代码的常见CSS问题应该被提取出来。省略就是一个例子。它总是这样</p><pre class="kn ko kp kq gt mm mn mo bn mp mq bi"><span id="1d72" class="mr lk iq mn b be ms mt l mu mv">white-space: nowrap;<br/>overflow: hidden;<br/>text-overflow: ellipsis;</span></pre><p id="5a99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理这个问题的一个简单方法是创建一个npm包，添加一个<code class="fe mw mx my mn b">main.scss</code>作为“公共API ”,并通过暴露的<a class="ae kl" href="https://sass-lang.com/documentation/at-rules/mixin" rel="noopener ugc nofollow" target="_blank"> mixins </a>包含所需的代码片段。这甚至可以应用于重复的<em class="mz">相似的</em> CSS片段，它们只是在值上不同。</p><p id="ec01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为SASS很好地处理了导入，所以没有其他事情可做。发布软件包，将其添加到您想要使用它的应用程序中，然后执行<code class="fe mw mx my mn b">@use package-name as whatever;</code>，您就可以像这样自由地<code class="fe mw mx my mn b">@include whatever.ellipsis;</code>。</p><p id="2d7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例包:<a class="ae kl" href="https://github.com/amdor/monorepo-dynamic-styles-example/tree/master/common-styles" rel="noopener ugc nofollow" target="_blank">https://github . com/amdor/mono repo-dynamic-styles-example/tree/master/common-styles</a></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="613f" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">其他包装中的可定制组件(在monorepo中)</h1><p id="b950" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">很多时候，我们需要创建一些组件，根据屏幕、平台，甚至是使用的组件，这些组件需要有不同的外观(❗️不依赖于❗️，这是针对预定义的静态场景)。如果仅仅是字体大小、颜色之类的差异，那么这只是简单的主题化，但也可能有其他情况。不仅如此，它们可能在不同的包装中。</p><h2 id="fec8" class="na lk iq bd ll nb nc dn lp nd ne dp lt jy nf ng lx kc nh ni mb kg nj nk mf nl bi translated">错误的解决方案:</h2><p id="f25e" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">我们可以向组件添加一个输入。然后在组件代码内部，根据输入，比方说，不同的类被应用到组件的HTML中的元素，这触发了相关的CSS部分。</p><p id="2e4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么不呢？这不仅是多余的(专门为此目的使用JS、HTML和CSS)，而且违反了最佳实践，例如单一责任。</p><h2 id="b41a" class="na lk iq bd ll nb nc dn lp nd ne dp lt jy nf ng lx kc nh ni mb kg nj nk mf nl bi translated">更好的解决方案:</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8169a829eaa38cb5aa4b97b89c3a3ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*Q-ksy9zVyi40hMX_3pSmrA.png"/></div></figure><p id="4c7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，包含组件的包公开了SCSS mixin接口来控制整个应用程序和单个组件的样式。</p><ul class=""><li id="3203" class="nn no iq jp b jq jr ju jv jy np kc nq kg nr kk ns nt nu nv bi translated">该组件创建一个mixin，它接受一个配置作为参数，并使用它来覆盖该组件的样式。</li></ul><pre class="kn ko kp kq gt mm mn mo bn mp mq bi"><span id="64c2" class="mr lk iq mn b be ms mt l mu mv">@mixin card-component-dynamic($config) {<br/>  $component-config: map-merge(<br/>    (<br/>      lib-card-border: null,<br/>    ),<br/>    $config<br/>  );<br/><br/>  .lib-card {<br/>    border: map-get($component-config, lib-card-border);<br/>  }<br/>}</span></pre><ul class=""><li id="aac4" class="nn no iq jp b jq jr ju jv jy np kc nq kg nr kk ns nt nu nv bi translated">这是通过组件上一级的<code class="fe mw mx my mn b">_main.scss</code>进行<code class="fe mw mx my mn b">@forward</code>处理的，之后的所有内容都通过根<code class="fe mw mx my mn b">main.scss</code>转发给包消费者。这些层是必需的，因此当发生变化时，只需要修改一个文件，并且这个文件不会太大。</li></ul><p id="63f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">_main.scss</p><pre class="kn ko kp kq gt mm mn mo bn mp mq bi"><span id="408e" class="mr lk iq mn b be ms mt l mu mv">@forward './card/card.component.dyn';<br/>@forward './button/button.component.dyn';</span></pre><ul class=""><li id="4dd1" class="nn no iq jp b jq jr ju jv jy np kc nq kg nr kk ns nt nu nv bi translated">市电旁边有<code class="fe mw mx my mn b">_dyn.scss</code>档。这些是包含混合，包括每一个可配置的混合下一层。</li></ul><p id="9f11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">_dyn.scss</p><pre class="kn ko kp kq gt mm mn mo bn mp mq bi"><span id="e999" class="mr lk iq mn b be ms mt l mu mv">@use "./card/card.component.dyn" as card;<br/>@use "./button/button.component.dyn" as button;<br/><br/>@mixin lib($config) {<br/>  @include card.card-component-dynamic($config);<br/>  @include button.button-component-dynamic($config);<br/>}</span></pre><p id="b606" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主网站</p><pre class="kn ko kp kq gt mm mn mo bn mp mq bi"><span id="126b" class="mr lk iq mn b be ms mt l mu mv">@forward './src/lib/main';<br/>@forward './dyn';</span></pre><p id="76e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些使得在我们想要使用的地方直接<code class="fe mw mx my mn b">@include</code>组件的mixin成为可能，而且，通过像<code class="fe mw mx my mn b">@lib</code>这样的mixin，我们可以定义一个应用程序级的配置来为所有组件提供一个基本主题。这很像<a class="ae kl" href="https://github.com/angular/components/blob/fd5afe7038ad8d69648eaae80c7f07ac71f3a4c8/src/material/core/_core-theme.scss#L72" rel="noopener ugc nofollow" target="_blank">棱角分明的材料是如何构成的</a>，只是稍微简单一点。</p><p id="a13c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在应用程序中使用所有这些(在组件中)</p><pre class="kn ko kp kq gt mm mn mo bn mp mq bi"><span id="575a" class="mr lk iq mn b be ms mt l mu mv">@use "common-styles" as theme;<br/>@use "components/main" as components;<br/><br/>.app-component {<br/>  &amp;-first-container &gt; p {<br/>    max-width: 200px;<br/>    @include theme.ellipsis;<br/>    @include theme.round-dotted-border(5px);<br/>  }<br/><br/>  &amp;-card-container {<br/>    max-width: 300px;<br/>    margin: 12px 0;<br/>    @include components.card-component-dynamic((lib-card-border: 1px dotted blue));<br/>  }<br/>}</span></pre></div></div>    
</body>
</html>