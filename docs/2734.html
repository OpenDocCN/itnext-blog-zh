<html>
<head>
<title>Why using hash based urls in your React SPA will save you more time than you think?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么在React SPA中使用基于散列的URL会比你想象的节省更多时间？</h1>
<blockquote>原文：<a href="https://itnext.io/why-using-hash-based-urls-in-your-react-spa-will-save-you-more-time-than-you-think-a21e2c560879?source=collection_archive---------0-----------------------#2019-07-24">https://itnext.io/why-using-hash-based-urls-in-your-react-spa-will-save-you-more-time-than-you-think-a21e2c560879?source=collection_archive---------0-----------------------#2019-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f94c3b3bbd2e982ee96be485a6e26980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*40la6c_a7sAP-HkM"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="00d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你开发你的单页应用程序时，有时你也需要设计url结构。</p><p id="7625" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常开发者使用两种类型的url…</p><h1 id="2c67" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正式网址</h1><p id="28ed" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">这是我们习惯看到的url，用正常的路径，像这样:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="9c19" class="mv lc iq mr b gy mw mx l my mz">https://myspa.com/app/login<br/>https://myspa.com/app/dashboard</span></pre><p id="3011" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种url具有SEO的优势，但是您必须创建与应用程序路由一样多的后端端点，以避免在重新加载url或将url传递给其他人时出现404错误代码消息。</p><h1 id="d59b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">基于哈希的Url</h1><p id="a875" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">这个url有一个唯一的应用程序端点<code class="fe na nb nc mr b">/app/</code>,由一个单一的后端动作和多个定义SPA路由的Javascript管理的hashtags控制。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ee58" class="mv lc iq mr b gy mw mx l my mz">https://myspa.com/app/<strong class="mr ir">#/login</strong><br/>https://myspa.com/app/<strong class="mr ir">#/dashboard</strong></span></pre><p id="28a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们只需要为应用程序创建一个控制器。这样做前端团队只会使用后端API，分离前端和后端逻辑，保持<strong class="kf ir"> <em class="nd">清晰整体结构</em> </strong>！另一方面，SEO更难管理(但这是相对的，当我们谈论SPA时)。</p><h1 id="bdfc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在React中实现基于散列的Url</h1><p id="1420" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">为了在我们的SPA中用React实现基于<em class="nd">散列的url </em>，我选择使用<a class="ae kc" href="https://github.com/supasate/connected-react-router" rel="noopener ugc nofollow" target="_blank">连接的React路由器</a>库。</p><p id="a51b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该库可以:</p><ul class=""><li id="abe5" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated">通过单向流将路由器状态与redux存储同步</li><li id="706c" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">支持React路由器v4和v5</li><li id="aedc" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">支持功能组件热重装，同时保留状态</li><li id="8588" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">历史方法调度(<code class="fe na nb nc mr b">push</code>、<code class="fe na nb nc mr b">replace</code>、<code class="fe na nb nc mr b">go</code>、<code class="fe na nb nc mr b">goBack</code>、<code class="fe na nb nc mr b">goForward</code>)对<a class="ae kc" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>和<a class="ae kc" href="https://github.com/yelouafi/redux-saga" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>都有效</li><li id="b5a6" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">还有更多！</li></ul><p id="7e6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以首先我们需要安装它</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7475" class="mv lc iq mr b gy mw mx l my mz">yarn add connected-react-router</span></pre><p id="25ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，我们需要用特定的键<code class="fe na nb nc mr b"><strong class="kf ir">router</strong></code>创建一个减速器</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="48c5" class="mv lc iq mr b gy mw mx l my mz">// reducers.js<br/>import { combineReducers } from 'redux'<br/>import { connectRouter } from 'connected-react-router'<br/><br/>export default (history) =&gt; combineReducers({<br/>  router: connectRouter(history),<br/>  ... // rest of your reducers<br/>})</span></pre><p id="dc14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们添加相关的中间件，这样我们就可以调度历史动作</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0f2b" class="mv lc iq mr b gy mw mx l my mz">// configureStore.js<br/>...<br/>import { createHashHistory } from 'history'<br/>import { applyMiddleware, compose, createStore } from 'redux'<br/>import { routerMiddleware } from 'connected-react-router'<br/>import createRootReducer from './reducers'<br/>...<br/><strong class="mr ir">export const history = createHashHistory({<br/>    hashType: 'slash',<br/>    getUserConfirmation: (message, callback) =&gt; callback(window.confirm(message))<br/>});</strong><br/><br/>export default function configureStore(preloadedState) {<br/>  const store = createStore(<br/>    createRootReducer(history), // root reducer with router state<br/>    preloadedState,<br/>    compose(<br/>      applyMiddleware(<br/>        routerMiddleware(history), // for dispatching history actions<br/>        // ... other middlewares ...<br/>      ),<br/>    ),<br/>  )<br/><br/>  return store<br/>}</span></pre><p id="cb45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe na nb nc mr b">history</code>包提供了3种不同的方法来创建一个<code class="fe na nb nc mr b">history</code>对象，这取决于你的环境。</p><ul class=""><li id="c2a4" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated"><code class="fe na nb nc mr b">createBrowserHistory</code>用于支持<a class="ae kc" href="http://diveintohtml5.info/history.html" rel="noopener ugc nofollow" target="_blank"> HTML5历史API </a>的现代网络浏览器中(参见<a class="ae kc" href="http://caniuse.com/#feat=history" rel="noopener ugc nofollow" target="_blank">跨浏览器兼容性</a>)</li><li id="3a61" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated"><code class="fe na nb nc mr b">createMemoryHistory</code>用作参考实现，也可以用于非DOM环境，比如<a class="ae kc" href="https://facebook.github.io/react-native/" rel="noopener ugc nofollow" target="_blank"> React Native </a>或tests</li><li id="2dfd" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated"><code class="fe na nb nc mr b">createHashHistory</code>用于传统的网络浏览器</li></ul><p id="897d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<em class="nd"> createHashHistory </em>而不是<em class="nd"> createBrowserHistory </em>，以便使用基于散列的URL<em class="nd">。</em></p><p id="7420" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后检索ConnectedRouter，并将创建的历史传递给它。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e71b" class="mv lc iq mr b gy mw mx l my mz">// index.js<br/>...<br/>import { Provider } from 'react-redux'<br/>import { Route, Switch } from 'react-router' // react-router v4/v5<br/>import { ConnectedRouter } from 'connected-react-router'<br/>import configureStore, { history } from './configureStore'<br/>...<br/>const store = configureStore(/* provide initial state if any */)<br/><br/>ReactDOM.render(<br/>  &lt;Provider store={store}&gt;<br/>    &lt;<strong class="mr ir">ConnectedRouter history={history}</strong>&gt; { /* place ConnectedRouter under Provider */ }<br/>      &lt;&gt; { /* your usual react-router v4/v5 routing */ }<br/>        &lt;Switch&gt;<br/>          &lt;Route exact path="/" render={() =&gt; (&lt;div&gt;Match&lt;/div&gt;)} /&gt;<br/>          &lt;Route render={() =&gt; (&lt;div&gt;Miss&lt;/div&gt;)} /&gt;<br/>        &lt;/Switch&gt;<br/>      &lt;/&gt;<br/>    &lt;/ConnectedRouter&gt;<br/>  &lt;/Provider&gt;,<br/>  document.getElementById('react-root')<br/>)</span></pre><p id="7d15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽情享受吧！😉</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="12f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读，如果你喜欢这篇文章，请留下评论，不要忘记鼓掌！😃</p></div></div>    
</body>
</html>