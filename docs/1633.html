<html>
<head>
<title>Speed Up JavaScript Array Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速JavaScript数组处理</h1>
<blockquote>原文：<a href="https://itnext.io/speed-up-javascript-array-processing-8d601c57bb0d?source=collection_archive---------0-----------------------#2018-12-17">https://itnext.io/speed-up-javascript-array-processing-8d601c57bb0d?source=collection_archive---------0-----------------------#2018-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9f2cdf48cc2033fd51a36075db9ee667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZW20spgDZU9KbBAf"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@crisovalle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Cris Ovalle </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><div class=""><h2 id="f50b" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">使用RxJS作为同步传感器库</h2></div><p id="82ed" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您只有几个项目时，JavaScript数组是很棒的，但是当您有大量数据或者想要通过大量的<code class="fe lr ls lt lu b">map</code>、<code class="fe lr ls lt lu b">filter</code>和<code class="fe lr ls lt lu b">reduce</code>方法调用来进行复杂的转换时，您会发现使用<code class="fe lr ls lt lu b">Array.prototype</code>方法会显著降低性能。</p><p id="d517" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以这个简单的<code class="fe lr ls lt lu b">map</code>为例:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="6a95" class="md me jg lu b gy mf mg l mh mi">initialArray<br/>.map(String)</span></pre><p id="02de" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使像单个阵列<code class="fe lr ls lt lu b">map</code>这样简单的东西，使用传感器也可以快几个数量级。正如您将在我的性能分析中看到的，最终的数字令人难以置信地惊讶。</p><h1 id="bea2" class="mj me jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">问题是</h1><p id="2661" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">在您提高速度之前，您可能甚至不会意识到速度有多慢，但是也有极少数情况下，您要么要处理大量数据，要么要处理大量转换，并且需要提高性能。</p><p id="fb36" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们使用<code class="fe lr ls lt lu b">Array.prototype.map</code>对1000万个项目做一个简单的性能测试:</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="62ee" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后让我们将其与本机<code class="fe lr ls lt lu b">for</code>循环进行比较:</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6f6d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个测试我运行7次，取平均值。在我的超频<a class="ae jd" href="https://ark.intel.com/products/75123/Intel-Core-i7-4770K-Processor-8M-Cache-up-to-3-90-GHz-" rel="noopener ugc nofollow" target="_blank">英特尔酷睿i7–4770k</a>上，我们的阵列方法平均为1281毫秒，而我们的<code class="fe lr ls lt lu b">for</code>循环平均为323毫秒。难以置信吧？多好的性能提升啊！但是<code class="fe lr ls lt lu b">for</code>循环是10年前的事了。在进行复杂的转换时，它们很难编写，也很难推理。</p><p id="317a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们如何解决这几乎300%的性能差异，但仍然保持我们的代码可读？</p><h1 id="3bc4" class="mj me jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">传感器来救援了！</h1><p id="c99d" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">转换是一种在输出一个值之前，通过将数组包装在一组递归的归约函数中，对数组中每个单独的项进行一系列逻辑处理的方法。这与JavaScript <code class="fe lr ls lt lu b">Array</code>方法的工作方式不同，因为数组中的每一项都是用一个单独的<code class="fe lr ls lt lu b">map</code>、<code class="fe lr ls lt lu b">filter</code>或<code class="fe lr ls lt lu b">reduce</code>方法处理的，然后继续下一步，并且每一步都在创建全新的数组来存放数据。</p><p id="e635" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有很多用于处理转导的库，也有很多关于如何用它来代替原生<code class="fe lr ls lt lu b">Array</code>方法的文章，但是我想回顾一下我在我的一个家庭项目中尝试的一个实验，它使用RxJS代替JavaScript的原生<code class="fe lr ls lt lu b">Array</code>方法。</p><p id="59a0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我相信学好一件事比不得不学习一大堆其他事情更容易，也更便宜。虽然为正确的工作使用正确的工具很重要，但我一直在探索为一堆不同的工作使用相同工具的方法，因为它可以最小化团队的学习成本，并显著降低项目的实施成本。</p><p id="6a54" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就像我的关于RxJS中背压的文章一样，这个实现是实验性的。通常，我会写一些关于我在生产中遇到的事情的文章，但这两篇文章是关于我想出的扩展RxJS功能的想法。</p><p id="0fce" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想深入了解传感器，<a class="ae jd" href="https://medium.com/@_ericelliott" rel="noopener"> Eric Elliot </a>有一篇精彩的文章可以帮你入门:</p><div class="ip iq gp gr ir nh"><a href="https://medium.com/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jh gy z fp nm fr fs nn fu fw jf bi translated">转换器:JavaScript中高效的数据处理管道</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">注意:这是学习函数式编程和组合软件的“组合软件”系列的一部分…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ix nh"/></div></div></a></div><h1 id="03d5" class="mj me jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">RxJS传感器</h1><p id="5b26" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">转换器像RxJS流一样通过一组函数来运行单个项目，这一点现在尤其重要，因为RxJS用他们的<code class="fe lr ls lt lu b">pipe</code>方法和lettable操作符实现了转换器模式，可能有一种方法可以使它们兼容。</p><p id="718a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果RxJS已经是你的项目的一部分，我会将它用于同步传感器来代替数组方法，但是有一些注意事项。</p><p id="bc7c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，不管出于什么原因，RxJS不像其他转换器库那样实现转换器接口，所以它与它们的开箱即用不兼容。如果你用的只是RxJS，这没什么大不了的。</p><p id="5aaf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其次，RxJS依赖于使用回调的<code class="fe lr ls lt lu b">subscribe</code>方法。<code class="fe lr ls lt lu b">Array</code>方法返回数组，而不是包含数组值的可观察值。那你是做什么的？除非你正在使用<code class="fe lr ls lt lu b">BehaviorSubject</code>，否则你不能拉一个同步值，即使使用它，你也不能确定你得到的值将会是你所期望的。</p><p id="fcaa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最重要的是，RxJS观察值没有区分异步和同步操作符。您可以围绕您的逻辑创建一个同步包装器，但是它只能在运行时保护您。</p><h1 id="052f" class="mj me jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">一些实验</h1><p id="ed1c" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">由于RxJS的<code class="fe lr ls lt lu b">BehaviorSubject</code>接近我们想要的，让我们看一个使用它的实现:</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="92dd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">呸！这不是我想在我的代码库中反复做的事情。订阅后还得记得退订？每次都记得<code class="fe lr ls lt lu b">mergeMap</code>？你一定是在开玩笑。</p><p id="c559" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还要注意，<strong class="kx jh">这个连</strong>都不行。您的<code class="fe lr ls lt lu b">value</code>是您传入的原始数组，而不是经过管道的数组。你只能通过传递一个句柄给<code class="fe lr ls lt lu b">subscribe</code>来获得你转换后的<code class="fe lr ls lt lu b">value</code>，所以<code class="fe lr ls lt lu b">BehaviorSubject</code>被证明是非常没有价值的。</p><p id="5f68" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们使用<code class="fe lr ls lt lu b">from</code>，我们可以模仿同样的行为，让它工作，并且使用更少的代码:</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="87cb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个非常干净的工具，现在<code class="fe lr ls lt lu b">value</code>是正确的，但是它仍然有和以前一样的问题:难以维护，难以编写(而且很恶心)。如果它只是你代码库中的一个点，没问题，但不止于此？开始想更好的办法。</p><h1 id="7883" class="mj me jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">解决方案</h1><p id="c283" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">我们需要的是一种方法来消除我们对<code class="fe lr ls lt lu b">subscribe</code>方法的依赖，以同步生成一个可观察的函数并返回一个值。在这种情况下，我们需要一个数组。</p><p id="4175" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了得到一个值，我们需要在我们的可观测值上有这样的东西:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="176e" class="md me jg lu b gy mf mg l mh mi">source$<br/>.execute = () =&gt; {<br/>  // do transducer logic<br/>  <br/>  return value<br/>}</span></pre><p id="c52b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这是一个目前RxJS中不存在的方法，但它绝对是我们可以在自己的项目中添加的东西。</p><p id="35ad" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">RxJS有一个类似于我们虚构的<code class="fe lr ls lt lu b">execute</code>的方法，叫做<code class="fe lr ls lt lu b">forEach</code>，但是它的设计类似于<code class="fe lr ls lt lu b">Array.prototype.forEach</code>，除了它不是返回<code class="fe lr ls lt lu b">undefined</code>，而是返回一个承诺。promise <code class="fe lr ls lt lu b">then</code>方法不返回任何东西，但是它会告诉你什么时候你的可观察性是完整的。如果它出错，<code class="fe lr ls lt lu b">catch</code>将会触发。这是一个非常漂亮的设置，但是当我们试图复制<code class="fe lr ls lt lu b">Array</code>的同步操作时就没用了。</p><p id="8fc6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们处理的是一个数组，没有随时间变化的值。RxJS已经处理了这个问题，并在到达列表末尾时完成了可观察性。如果我们将<code class="fe lr ls lt lu b">subscribe</code>包装在<code class="fe lr ls lt lu b">execute</code>函数中，我们可以让它返回一个同步值，类似于async-await的工作方式，而不需要您重写整个应用程序。</p><h1 id="d308" class="mj me jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">履行</h1><p id="161b" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">这是我想象我们如何使用<code class="fe lr ls lt lu b">execute</code>:</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="54c7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过这个特殊的实现，我能够在异步代码运行时捕获错误:</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="be65" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意我们的值是<code class="fe lr ls lt lu b">undefined</code>，但是我们仍然能够在一段时间后看到关于它的用法的错误。因为它是异步的，所以我们不能使用try-catch来发现错误，但是我们<em class="nw">可以在运行时将它记录到控制台，这样您就可以意识到有问题了。</em></p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3efc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是这个实现有一个缺陷，您可能有一个从不退订并且只记录错误的异步观察对象。</p><p id="9da6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，我们需要在执行后立即取消订阅，但是我们将无法知道我们的可观察对象是否有异步操作符:</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f4f2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唯一的另一种方法是添加一个<code class="fe lr ls lt lu b">take(1)</code>操作符，并且只在抛出错误后才取消订阅，但是因为您不能用一个永远不会触发的可观察对象来确定这种内存泄漏，所以这也可能不是一个好的实现。</p><p id="73da" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我认为自动退订更符合你的预期。这样，即使你错过了一些有用的“你搞砸了”的错误，你也不会因为使用<code class="fe lr ls lt lu b">execute</code>而出现内存泄漏的情况。</p><p id="df83" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我自己使用函数组合并订阅可观察对象，而不是扩展类，这个实现会干净得多，但是我想模仿它在RxJS中实现的样子。</p><p id="251f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个API可以通过使用<code class="fe lr ls lt lu b">from</code>进一步改进。消费<code class="fe lr ls lt lu b">createExecutableObservable</code>的时候就少了一样进口的东西。</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="f805" class="mj me jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">性能影响</h1><p id="84d9" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">现在，我们已经创建了传感器逻辑，让我们使用之前所做的相同比较来运行性能测试:</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4af9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它在<code class="fe lr ls lt lu b">for</code>循环中使用了更干净的API，但是比原始的<code class="fe lr ls lt lu b">map</code>测试多了很多代码，所以正如你所料，这可能会花费更长的时间。我的意思是，与这个怪物相比，本机示例只是一个方法调用。</p><p id="ed74" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我运行性能测试时，我惊讶地发现平均速度为371毫秒。这比我们的<code class="fe lr ls lt lu b">map</code>测试快了240%,只比我们的<code class="fe lr ls lt lu b">for</code>循环慢了13%。我认为这对我来说已经足够好了，但是如果您在嵌入式系统中工作并且有非常严格的处理约束，可能就不够好了。</p><p id="4a32" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了可读性，您是愿意编写一个<code class="fe lr ls lt lu b">for</code>循环还是使用您现有的RxJS传感器知识？哪个更容易维护，尤其是当你可能再过3-4年才能看到另一个<code class="fe lr ls lt lu b">for</code>循环的时候？</p><h2 id="2da7" class="md me jg bd mk nx ny dn mo nz oa dp ms le ob oc mu li od oe mw lm of og my oh bi translated">真实的故事</h2><p id="5f69" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">传感器并不都是桃子和奶油。当你有很少的项目时，传感器比任何一种解决方案都慢。寻找大多数机器的折衷点超出了本文的范围，但是让我们用一组3个项目重新进行这些性能测试。</p><ul class=""><li id="1de0" class="oi oj jg kx b ky kz lb lc le ok li ol lm om lq on oo op oq bi translated">阵列方法:0.33毫秒</li><li id="1e46" class="oi oj jg kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated">对于循环:0.22毫秒</li><li id="f830" class="oi oj jg kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated">传感器:3.06毫秒</li></ul><p id="5ca2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">突然间，形势发生了逆转。3件物品3毫秒？这比其他两种解决方案要长一个数量级。你在开玩笑吗？显然不是。</p><p id="14cb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有这些传感器逻辑都是有代价的。该设置虽然在大型操作中速度很快，但在处理少量数据时速度极慢。</p><p id="2a5a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是“为正确的工作使用正确的工具”发挥作用的地方。如果你有一个小数组，使用内置方法。你失去了那些令人惊讶的RxJS操作符的好处，例如<code class="fe lr ls lt lu b">tap</code>(只需使用<code class="fe lr ls lt lu b">filter</code>)，但是你获得了惊人的速度，并且不必用你的换能器模式偷工减料地使用有充分证明的<code class="fe lr ls lt lu b">Array</code>方法。</p><p id="d434" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当你已经在RxJS转换器管道中时，真正的困境就来了。当您在可观察数组执行和同步数组执行之间切换映射时，您使用哪个？我认为这取决于你的团队和所需的处理。如果需要RxJS操作符，就使用它们。如果没有，只要没有大量的条目或复杂的转换，就可以安全地使用JavaScripts原生的<code class="fe lr ls lt lu b">Array</code>方法。</p><h1 id="8f9e" class="mj me jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">其他集合类型</h1><p id="c150" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">转换器是通用的，不关心集合本身，只关心每个转换器的进出值(RxJS操作符)。这意味着理论上我们可以对其他集合使用同样的方法，比如迭代器。</p><p id="2c6d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们使用我上一篇关于RxJS  中的<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/lossless-backpressure-in-rxjs-b6de30a1b6d4"> <em class="nw">无损反压的文章中的生成器，但是没有异步反压处理程序:</em></a></p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9049" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很酷吧？这样做的唯一原因是因为RxJS遍历整个生成器的值，创建数组，并通过管道一个接一个地推送值。</p><p id="157e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更复杂的主题处理，比如我写的背压迭代器函数，不会像你期望的那样工作，会让你工作到深夜。如果说这整个设计中有一个缺陷，那就是你不能确定你的管道是否是异步的。</p><h1 id="9341" class="mj me jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">结论</h1><p id="82c1" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">虽然RxJS可以用作转换器库，这确实会显著加快大型数据集的执行时间，但偷工减料地使用<code class="fe lr ls lt lu b">subscribe</code>函数肯定不是它的本意。</p><p id="6f33" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我很想看看将来是否有更好的方法来做到这一点，但是这个用例大大简化了它，而不必拆除、维护和学习另一个库。</p><h1 id="5b79" class="mj me jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">如果你对更多与RxJS相关的话题感兴趣，你应该看看我的其他文章:</p><ul class=""><li id="6ac0" class="oi oj jg kx b ky kz lb lc le ok li ol lm om lq on oo op oq bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/using-transducers-to-speed-up-javascript-arrays-92677d000096">使用转换器加速JavaScript数组</a></li><li id="286f" class="oi oj jg kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated">函数式编程的表情爱好者指南:第一部分</li><li id="1105" class="oi oj jg kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/handling-cache-and-ajax-race-conditions-4cb152db8764">处理缓存和AJAX竞争条件</a></li><li id="5076" class="oi oj jg kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/lossless-backpressure-in-rxjs-b6de30a1b6d4">RxJS中的无损背压</a></li><li id="8598" class="oi oj jg kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li></ul></div></div>    
</body>
</html>