<html>
<head>
<title>Polling using RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RxJS进行轮询</h1>
<blockquote>原文：<a href="https://itnext.io/polling-using-rxjs-b56cd3531815?source=collection_archive---------1-----------------------#2018-09-10">https://itnext.io/polling-using-rxjs-b56cd3531815?source=collection_archive---------1-----------------------#2018-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6f3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着observables在JavaScript中越来越受欢迎，我们希望使用它们来完成我们的日常任务，并评估它们是否真的值得大肆宣传。您可能会发现自己正在做的一项任务是轮询后端，以了解一个更长时间运行的任务是否已经完成。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d4006110cdaeac75a3b111aeebadbe2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yoQ4-LmrJU_8A1Ie"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">由<a class="ae lb" href="https://unsplash.com/@chrisabney?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯·阿布尼</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的溪流照片</figcaption></figure><p id="cb45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将浏览这样一个场景的例子，并使用RxJS实现一个解决方案。在路上，我们将学习RxJS的一些基本操作符，一些技巧以及如何避免一两个陷阱。最后，我将展示一个真实的例子，向您展示如何在一个特定的场景中实现我们所学的内容。</p><p id="32b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你应该带着对Streams / <a class="ae lb" href="http://reactivex.io/documentation/observable.html" rel="noopener ugc nofollow" target="_blank"> Observables </a>的基本理解以及扎实的JavaScript基础来享受这篇文章。在这篇文章的其余部分，我将把Stream和Observable视为同一事物的可互换词。虽然我们将涵盖许多基本的东西，但它们主要是RxJS细节，而不是关于流的基础知识。如果你正在寻找一个一般性的介绍，考虑一下要点标题“<a class="ae lb" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" rel="noopener ugc nofollow" target="_blank">你一直错过的反应式编程介绍</a>”。</p><p id="ce8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的代码是用RxJS 6.2.0测试的。</p><h1 id="c36d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">方案</h1><p id="7df2" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">假设我们有一个后端，它公开了一个端点/tasks/[taskId],您可以查询它来了解特定任务的状态。它返回这样一个对象:</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="e600" class="mk ld iq mg b gy ml mm l mn mo">{<br/>  // Whether the task is still running<br/>  processing: boolean;<br/>  // A unique ID for this task<br/>  taskId: string;<br/>}</span></pre><p id="9112" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们开始轮询，我们希望每秒两次获得该任务的当前状态，并在处理一次后停止轮询=== false。</p><h1 id="1b70" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">程序化解决方案</h1><p id="1ca5" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先，我们来看看这个问题的程序性解决方案。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5746" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，每当后端仍在处理时，我们简单地调用一个新的超时。</p><h1 id="cd6c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用RxJS</h1><p id="69c1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在我们将使用RxJS实现相同的行为。</p><p id="9ab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要一些东西在每次<em class="mr"> x </em>的时候发出一个事件。RxJS为此提供了两个功能:</p><ul class=""><li id="6d02" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">间隔</li><li id="e81d" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">计时器</li></ul><p id="25a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mr">间隔</em>在给定时间后发出第一个事件，然后以相同的间隔连续发出，而<em class="mr">计时器</em>在给定时间后开始每隔<em class="mr"> x </em>次发出事件。对于每秒两次更新，我们可以从使用timer(0，500)开始。这将从蝙蝠的右边开始触发事件，之后每秒两次。</p><p id="365c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们首先通过在控制台上记录一些东西来看看实际情况。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="3794" class="mk ld iq mg b gy ml mm l mn mo">import { timer } from 'rxjs'</span><span id="f9f0" class="mk ld iq mg b gy ng mm l mn mo">timer(0, 500)<br/>  .subscribe(() =&gt; console.log('polling'))</span></pre><p id="7694" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您应该看到您的控制台每秒钟打印两次“轮询”。</p><blockquote class="nh ni nj"><p id="f9fa" class="jn jo mr jp b jq jr js jt ju jv jw jx nk jz ka kb nl kd ke kf nm kh ki kj kk ij bi translated">注意从正确的包中导入(rxjs或rxjs/operators)。遗憾的是，RxJS文档可能跟不上您正在使用的版本。</p></blockquote><p id="68e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们想把这些“滴答”变成对我们后端的请求。我们将使用上面的相同提取，但这次<strong class="jp ir">将承诺转化为可观察到的</strong>。幸运的是RxJS为此提供了便捷的功能，即从开始的<em class="mr">。使用它，我们现在可以创建一个可观察对象(或流),表示每个时钟周期对后端的请求，并继续使用它。</em></p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="a760" class="mk ld iq mg b gy ml mm l mn mo">import { timer, from } from 'rxjs'<br/>import { map } from 'rxjs/operators'</span><span id="1216" class="mk ld iq mg b gy ng mm l mn mo">timer(0, 500)<br/>  .pipe(from(fetch(`/tasks/${taskId}`)).pipe(map(response =&gt; response.json())))</span></pre><p id="933d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">。管道</strong>是RxJS指定转换将在流上发生的方式。通过将操作符提取到它们自己的导入中，RxJS实现了比重载的Observable实现更好的树摇动，更多上下文参见<a class="ae lb" href="https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md" rel="noopener ugc nofollow" target="_blank">这个解释</a>。</p><blockquote class="nn"><p id="745b" class="no np iq bd nq nr ns nt nu nv nw kk dk translated">Pipe是RxJS对应用于事件流的转换的包装。</p></blockquote><p id="09d5" class="pw-post-body-paragraph jn jo iq jp b jq nx js jt ju ny jw jx jy nz ka kb kc oa ke kf kg ob ki kj kk ij bi translated">这样的结果将是一个<strong class="jp ir">流的流</strong>。每个发射值本身都是可观测的。为了管理混乱，我们可以通过<em class="mr"> concatMap </em>将所有的流合并成一个包含嵌套值的流。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="20ae" class="mk ld iq mg b gy ml mm l mn mo">import { timer, from } from 'rxjs'<br/>import { map, concatMap } from 'rxjs/operators'</span><span id="5a33" class="mk ld iq mg b gy ng mm l mn mo">timer(0, 500)<br/>  .pipe(concatMap(() =&gt; from(fetch(`/tasks/${taskId}`))<br/>    .pipe(map(response =&gt; response.json())))<br/>  )</span></pre><h1 id="4a66" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">完成轮询</h1><p id="fb66" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">最后，我们真正关心的是获得一个事件，告诉我们后端处理已经完成，我们的轮询已经完成。我们可以通过过滤后端不再处理的事件并只取其中的第一个事件来实现这一点。通过使用<em class="mr"> take(1) </em>我们指定我们只关心一个(第一个)告诉我们处理已经完成的事件。一旦后端处理完任务，这将停止我们的轮询。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="368b" class="mk ld iq mg b gy ml mm l mn mo">import { timer, from } from 'rxjs'<br/>import { map, concatMap, filter, take } from 'rxjs/operators'</span><span id="05fd" class="mk ld iq mg b gy ng mm l mn mo">timer(0, 500)<br/>  .pipe(concatMap(() =&gt; from(fetch(`/tasks/${taskId}`))<br/>    .pipe(map(response =&gt; response.json())))<br/>  )<br/>  .pipe(<!-- -->filter(backendData =&gt; backendData.processing === false)<!-- -->)<br/>  .pipe(take(1))</span></pre><h1 id="1533" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">把所有的放在一起</h1><p id="1acc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在是时候把它们放在一起，并使用新的基于RxJS的代码从上面替换我们的函数了。最后一点是在我们的流末尾使用<em class="mr"> subscribe </em>来处理我们的流发出的单个事件。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="567b" class="mk ld iq mg b gy ml mm l mn mo">import { timer, from } from 'rxjs'<br/>import { map, concatMap, filter, take } from 'rxjs/operators'</span><span id="2190" class="mk ld iq mg b gy ng mm l mn mo">pollUntilTaskFinished(taskId) {<br/>  timer(0, 500)<br/>    .pipe(concatMap(() =&gt; from(fetch(`/tasks/${taskId}`))<br/>      .pipe(map(response =&gt; response.json())))<br/>    )<br/>    .pipe(<!-- -->filter(backendData =&gt; backendData.processing === false)<!-- -->)<br/>    .pipe(take(1))<br/>    .subscribe(() =&gt; pollingFinishedFor(taskId))<br/>}</span></pre><p id="ffa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能不希望在完成后调用函数，而是使用可观察对象的输出来呈现你的UI。通过使用合并，将两个流合并在一起，我们可以将我们的轮询映射到两个状态，并将输出直接用于我们的UI。</p><p id="ec78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，我们将把上面的流和一个初始值合并在一起，我们使用中的<em class="mr">把它变成一个流。</em></p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="841f" class="mk ld iq mg b gy ml mm l mn mo">import { timer, from, merge, of } from 'rxjs'<br/>import { map, concatMap, filter, take } from 'rxjs/operators'</span><span id="c273" class="mk ld iq mg b gy ng mm l mn mo">const loadingEmoji = merge(<br/>  of(true),<br/>  timer(0, 500)<br/>    .pipe(concatMap(() =&gt; from(fetch(`/tasks/${taskId}`))<br/>      .pipe(map(response =&gt; response.json())))<br/>    )<br/>    .pipe(<!-- -->filter(backendData =&gt; backendData.processing === false)<!-- -->)<br/>)<br/>    .pipe(take(2))<br/>    <!-- -->.pipe(map(processing =&gt; processing ? '⏳' : '✅'));</span></pre><p id="03ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们使用<em class="mr"> map </em>将来自后端的响应映射到处理属性上之后，我们可以将结果映射到表情符号上以显示给我们的用户。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="e979" class="lc ld iq bd le lf oj lh li lj ok ll lm ln ol lp lq lr om lt lu lv on lx ly lz bi translated">真实世界的例子</h1><p id="d1ac" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">理论总是好的，但现实世界通常会对一个写得很好、内容丰富的教程提出不同的挑战。让我向您介绍一个问题的解决方案，这个问题是我们在构建关于使用RxJS进行轮询的知识时遇到的。</p><p id="239c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">情况:我们有一个Angular应用程序，我们使用<a class="ae lb" href="https://ngxs.gitbook.io/ngxs" rel="noopener ugc nofollow" target="_blank"> NGXS </a>作为状态管理器。与Redux类似，它使用动作来表示改变状态的事件。</p><p id="a24d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实证明，NGXS提供了一个调度所有动作的流，作为我们可以挂钩的可观察对象。这是我们最终的解决方案，轮询后端处理每个<em class="mr">文档</em><em class="mr"/>添加到状态中的状态，并在后端完成处理后更新状态。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b3b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些注意事项:</p><ul class=""><li id="570f" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated"><strong class="jp ir">环境</strong>是一个角度环境，为我们的应用提供配置。</li><li id="d767" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">后端是一个提供连接到我们后端的服务。它插入了一些必需的头等等。</li><li id="fe94" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">这使用了TypeScript，因此polledDocument: Document描述了一个名为“polledDocument”的变量，该变量遵循类型“Document”。</li></ul><p id="fb78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里一件棘手的事情是，我们需要为每个添加到我们状态的文档创建一个新的“轮询流”。起初，我们尝试将逻辑放入一个单独的级别，但最终我们只能在每次页面加载时轮询一个文档，因为take(1)会阻止所有未来轮询的流。</p><h1 id="333f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">包扎</h1><p id="1474" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">今天，我们使用RxJS构建了我们的第一个轮询逻辑，并了解了这个伟大的库。我们还看了一个真实世界的例子，看看它能让我们的代码变得多么有表现力。</p><p id="4879" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，走出去，应用你的新知识。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/ad5eee9363a455b30096b87ee2a251c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/0*cJGdKu6pdTG8teb0"/></div></figure></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="34de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">其他重大资源</strong></p><p id="5227" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://blog.strongbrew.io/rxjs-polling/" rel="noopener ugc nofollow" target="_blank">https://blog.strongbrew.io/rxjs-polling/</a></p><p id="6644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://www.sitepoint.com/angular-rxjs-create-api-service-rest-backend/" rel="noopener ugc nofollow" target="_blank">https://www . site point . com/angular-rxjs-create-API-service-rest-back end/</a></p><p id="7ef7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://www.learnrxjs.io/recipes/http-polling.html" rel="noopener ugc nofollow" target="_blank">https://www.learnrxjs.io/recipes/http-polling.html</a></p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="4082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原载于2018年8月30日<a class="ae lb" href="https://makeitnew.io/polling-using-rxjs-8347d05e9104" rel="noopener ugc nofollow" target="_blank"> makeitnew.io </a>。</p></div></div>    
</body>
</html>