<html>
<head>
<title>What about promises in loops?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">循环中的承诺呢？</h1>
<blockquote>原文：<a href="https://itnext.io/https-medium-com-popov4ik4-what-about-promises-in-loops-e94c97ad39c0?source=collection_archive---------0-----------------------#2018-05-24">https://itnext.io/https-medium-com-popov4ik4-what-about-promises-in-loops-e94c97ad39c0?source=collection_archive---------0-----------------------#2018-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/a6bb46bb07c720dde009164c8717ff41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*FPrqVBzMrhdiCtYfyOGwgA.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">彬彬有礼的绅士</figcaption></figure><p id="e407" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我听说人们“并不真正理解承诺”，每个月至少几次，每次我都认为我不是那些人之一。</p><p id="d0a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我将描述我的团队最近面临的一个案例及其解决方式。只是说，虽然我不是回调和实现承诺的“老方法”的大粉丝，但我确实喜欢<em class="kw">异步/等待</em>方式。</p><p id="0533" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将会有我们已经经历的步骤的描述，所以如果你需要<strong class="ka ir">最终解决方案</strong>——滚动到文章的结尾。</p><h1 id="72cf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">问题描述</h1><p id="ff63" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">那么首先，我来描述一下这个问题。我们有一个值数组，我们需要迭代这个数组，并将数组的每个元素作为参数之一传递给一个函数(函数返回一个<em class="kw">承诺</em>)。第二个参数是数据库连接。最后，我们需要将一组值(不是承诺)传递给另一个函数。此外，该函数返回一个对象，该对象的值将在同一个循环中使用。主要目的是获得最佳的性能结果和良好的代码可读性。</p><h1 id="027e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">初始版本</h1><p id="1a2f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">第一版代码:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="d60c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的例子有一个很好的<em class="kw">异步/等待</em>语法，而我们假装使用<em class="kw">承诺</em>。<strong class="ka ir"> asyncForEach() </strong>正在等待回调，立即解析它，并将解析的值推送到finalArray。在这种情况下，来自<strong class="ka ir"> asyncFunction() </strong>的值被立即解析，因此我们并没有真正从<em class="kw">承诺</em>中受益。这里我们有一个漂亮的主流<em class="kw">异步/等待</em>语法:)为了提高性能，我们需要将所有的<em class="kw">承诺</em>推送到一个数组中，然后一次性解决，就像这里的<a class="ae mg" href="https://hackernoon.com/async-await-essentials-for-production-loops-control-flows-limits-23eb40f171bd" rel="noopener ugc nofollow" target="_blank">所示的</a>。</p><p id="259d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在这种情况下，我们的代码看起来会像这样:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="41f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法会稍微提高性能。然而，可读性会更差，并且会出现额外的代码(另一个循环)。此外，我们仍然没有获得最佳性能(迭代解析的值需要额外的时间/资源)。所以，它决定不实现它，并试图想出一个更“promisified”的方式。</p><h1 id="5aec" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">回调时间到了？</h1><p id="7c3b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">更好的做法是给<em class="kw">一个承诺</em>一个一旦解决就需要做的行动的指示。<strong class="ka ir">来了然后()</strong>。我们可以将函数调用推送到一个数组中而不解析它，并将值操作的指令包含到回调中。这意味着一旦<em class="kw">承诺</em>将被解析(在<strong class="ka ir"> forEach() </strong>循环之后),我们真的不需要担心另一个循环来迭代每个值，因为在解析期间它已经在那里了。这是代码:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="ac5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回调得到一个<em class="kw">承诺</em>，一旦到达<strong class="ka ir"> Promise.all() </strong>，回调就被解决。没有额外的循环，没有时间浪费，没有额外的代码。这种情况下的性能明显好于最初的情况。</p><p id="de05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果它仍然不工作，不要担心:可能你仍然在使用一个<em class="kw"> MySQL </em>连接<em class="kw"> Promises </em>。使用<em class="kw">池</em>代替。每次循环迭代时都打开连接，考虑到<strong class="ka ir"> asyncFunction() </strong>与<strong class="ka ir"> myArray </strong>的每个元素并行(几乎)运行，这是不“健康”的。使用<strong class="ka ir"> createPool() </strong>将同时有许多到数据库的连接，并将重用已经完成前一次运行的连接。<em class="kw">池</em>是异步操作的完美解决方案(除非你不考虑限制和/或试图终止应用程序与<em class="kw"> MySQL </em>数据库的连接)。但是<strong class="ka ir"> then() </strong>是“老办法”，所以不够好。</p><h1 id="3044" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最终解决方案</h1><p id="b0c2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">那么如何才能摆脱回调，提高可读性，保持性能不变呢？以下是最终解决方案:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="dca0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="696a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢添加新的npm包，看看<a class="ae mg" href="https://www.npmjs.com/package/bluebird" rel="noopener ugc nofollow" target="_blank"> <em class="kw">蓝鸟</em> </a>，它有<strong class="ka ir"> Promise.map() </strong>，这两个包都可以做——<strong class="ka ir">promise . all()</strong>和<strong class="ka ir"> map() </strong>。</p><h1 id="c6cf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="3a75" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最终的解决方案具有最好的性能，代码可读性足够好，并且没有额外的代码。这个案例帮助我更好地理解了<em class="kw">承诺</em>，但我仍然不确定我是否是“真正理解承诺”的人之一。</p></div></div>    
</body>
</html>