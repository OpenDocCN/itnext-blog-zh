<html>
<head>
<title>Happy users uploading files with Rails 5, Shrine, and Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快乐的用户用Rails 5、Shrine和Vue.js上传文件</h1>
<blockquote>原文：<a href="https://itnext.io/happy-users-uploading-files-with-rails-5-shrine-and-vue-js-bbcc470a327f?source=collection_archive---------0-----------------------#2018-09-04">https://itnext.io/happy-users-uploading-files-with-rails-5-shrine-and-vue-js-bbcc470a327f?source=collection_archive---------0-----------------------#2018-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4a57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我花了很长时间才弄明白。我在这里的目标是通过告诉你我如何实现产品服务器就绪上传的故事来为你省下难以置信的痛苦。上传文件是会议中的一件小事，很快就会变成十六条腿的章鱼。一旦应用程序开始接受和操作文件，就会有许多实现细节发生变化并需要安全强化。</p><ul class=""><li id="68fe" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">我是否从我的应用服务器上完全卸载上传/接收文件？(通常称为“直接上传”)</li><li id="5b0d" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我需要为应用程序上传的内容创建几个版本吗？</li><li id="e804" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我应该在哪里缓存文件，以便在保持性能的同时经济高效地存储它们？</li><li id="97e8" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我该如何处理现有的上传文件？</li><li id="e3f4" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我需要允许哪些类型的文件，接受它们作为有效附件有什么限制？</li></ul><p id="4c27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这六个问题是与应用程序的利益相关者讨论了几天的结果。在会议和设计实现之间，有大量关于我们可以使用的工具的教程和讨论。没有人真正告诉任何人如何从头开始做这件事。</p><p id="c206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们忙起来吧！</p><h2 id="4c2e" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">堆栈里有什么？</h2><ul class=""><li id="8d15" class="kl km iq jp b jq ls ju lt jy lu kc lv kg lw kk kq kr ks kt bi translated">API模式下的Rails 5</li><li id="bb4f" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae lx" href="https://jcupitt.github.io/libvips/" rel="noopener ugc nofollow" target="_blank">用于图像处理的libvips </a></li><li id="573e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae lx" href="https://github.com/mperham/sidekiq" rel="noopener ugc nofollow" target="_blank"> Sidekiq </a>进行后台处理</li><li id="ef00" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae lx" href="http://nuxtjs.org" rel="noopener ugc nofollow" target="_blank">前端的Nuxt </a> /Vue</li><li id="f783" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae lx" href="http://shrinerb.com/" rel="noopener ugc nofollow" target="_blank"> Shrine.rb </a>上传与Rails的集成</li></ul><h2 id="281f" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">项目设置</h2><p id="7175" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">按照<a class="ae lx" href="https://jcupitt.github.io/libvips/install.html" rel="noopener ugc nofollow" target="_blank">说明</a>安装libvps。制作两个名为<code class="fe mb mc md me b">backend</code>和<code class="fe mb mc md me b">frontend</code>的文件夹。</p><h2 id="758d" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">后端:</h2><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="cd19" class="kz la iq me b gy mn mo l mp mq">rails new --api --skip-active-storage --skip-action-cable -d postgresql .</span></pre><p id="4b00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开gem文件并添加以下条目:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="1e7d" class="kz la iq me b gy mn mo l mp mq">gem 'aws-sdk-s3' # for connecting to an S3 bucket<br/>gem 'bcrypt', '~&gt; 3.1.7' # use has_secure_password<br/>gem 'fastimage' # <em class="mr">finds the size or type of an image given its uri.</em><br/>gem 'image_processing' # you guessed it<br/>gem 'jb' # a faster json templating system than jbuilder<br/>gem 'knock' # json web tokens (JWT) for authentication<br/>gem 'rack-cors' # handling CORS requests<br/>gem 'redis', '~&gt; 4.0' # fast keystore perfect for offloading async job state<br/>gem 'redis-rails' # connector and helpers for redis in rails<br/>gem 'ruby-vips' # image manipulation bindings in Ruby<br/>gem 'sidekiq' # background job framework<br/>gem 'shrine' # our uploading toolkit</span></pre><p id="9a25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续运行<code class="fe mb mc md me b">bundle install</code>来安装这些依赖项。</p><p id="9d19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过运行<code class="fe mb mc md me b">rails g knock:install</code>来使用Knock进行一些认证。对于Rails 5.2，您需要在初始化器中添加这一行:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="0432" class="kz la iq me b gy mn mo l mp mq"><em class="mr">config</em>.token_secret_signature_key = -&gt; { Rails.application.credentials.fetch(:secret_key_base) <br/>}</span></pre><p id="27ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为从Rails 5.1到5.2，secrets.yml api被迁移到了credentials，而Knock中的缺省值仍然反映了5.1的实现。</p><p id="dd90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们希望我们的API处理CORS请求，所以打开<code class="fe mb mc md me b">initializers/cors.rb</code>,取消那里的内部注释:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="9e06" class="kz la iq me b gy mn mo l mp mq">Rails.application.config.middleware.insert_before 0, Rack::Cors <strong class="me ir">do<br/>  </strong>allow <strong class="me ir">do<br/>    </strong>origins '*'<br/><br/>    <em class="mr">resource </em>'*',<br/>             headers: :any,<br/>             methods: [:get, :post, :put, :patch, :delete, :options, :head]<br/>  <strong class="me ir">end<br/>end</strong></span></pre><p id="16c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在请记住，这是一个非常通用的策略，因此您可能希望在部署时仅将它限制在前端域，而不是使用<code class="fe mb mc md me b">*</code>。还在<code class="fe mb mc md me b">Gemfile</code>中取消对<code class="fe mb mc md me b">gem rack-cors</code>的注释。</p><p id="c0ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们要在初始化器中设置一个神龛。Shrine是非常模块化的，很容易覆盖初始化器中的任何内容。您甚至可以选择根本没有，而是将所有内容放入我们接下来将创建的uploader类中。这取决于你。我试着在<code class="fe mb mc md me b">initializers/shrine.rb</code>中保留全局使用的配置项，并保持上传类较小。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="5d63" class="kz la iq me b gy mn mo l mp mq">require 'shrine'<br/>require 'shrine/plugins/activerecord'<br/>require 'shrine/plugins/backgrounding'<br/>require 'shrine/plugins/data_uri'<br/>require 'shrine/plugins/delete_promoted'<br/>require 'shrine/plugins/delete_raw'<br/>require 'shrine/storage/s3'<br/>require 'shrine/storage/file_system'<br/>require 'shrine/plugins/logging'<br/>require 'shrine/plugins/determine_mime_type'<br/>require 'shrine/plugins/store_dimensions'<br/>require 'shrine/plugins/cached_attachment_data'<br/>require 'shrine/plugins/restore_cached_data'<br/>require 'shrine/plugins/validation_helpers'<br/>require 'shrine/plugins/pretty_location'<br/>require 'shrine/plugins/processing'<br/>require 'shrine/plugins/versions'<br/><br/>Shrine.plugin :activerecord<br/>Shrine.plugin :backgrounding<br/>Shrine.plugin :cached_attachment_data<br/>Shrine.plugin :data_uri<br/>Shrine.plugin :determine_mime_type<br/>Shrine.plugin :logging<br/>Shrine.plugin :restore_cached_data<br/>Shrine.plugin :store_dimensions<br/>Shrine.plugin :validation_helpers<br/>Shrine.plugin :versions<br/><br/><strong class="me ir">def </strong>production_storages<br/>  s3_options = {<br/>    access_key_id: Rails.application.credentials.digitalocean_spaces_key,<br/>    secret_access_key: Rails.application.credentials.digitalocean_spaces_secret,<br/>    bucket: Rails.application.credentials.digitalocean_spaces_bucket,<br/>    endpoint: 'https://nyc3.digitaloceanspaces.com',<br/>    region: 'nyc3'<br/>  }<br/><br/>  <em class="mr"># Your probably want the directory to be in a shared location so its persisted between deployments<br/>  </em>{<br/>    cache: Shrine::Storage::FileSystem.new('public/uploads', prefix: 'cache'), <em class="mr"># temporary<br/>    </em>store: Shrine::Storage::S3.new(prefix: 'store', upload_options: { acl: 'public-read' }, **s3_options)<br/>  }<br/><strong class="me ir">end<br/><br/>def </strong>development_storages<br/>  {<br/>    cache: Shrine::Storage::FileSystem.new('public', prefix: 'uploads/cache'), <em class="mr"># temporary<br/>    </em>store: Shrine::Storage::FileSystem.new('public', prefix: 'uploads'), <em class="mr"># permanent<br/>  </em>}<br/><strong class="me ir">end<br/><br/></strong>Shrine.storages = Rails.env.production? ? production_storages : development_storages<br/><em class="mr"># Shrine.storages = production_storages</em></span></pre><p id="b220" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Shrine使用两个地方来存储文件，一个缓存和一个永久存储。这是您将在那里找到的最常见的配置，但是可以通过向散列添加另一个键并调用正确的Shrine::Storage子类来添加额外的存储。我还添加了两种方法来返回本地开发配置散列的配置。</p><p id="7756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的例子中，我们使用了数字海洋的空间功能。从各方面来看，这都是一个S3桶，没有任何特殊的外部情况是<code class="fe mb mc md me b">aws-sdk-s3</code>无法独立处理的。如果你是使用Rails ' T5 '的新手，那么我建议你读一读这篇文章。</p><p id="6614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将搭建一个附有照片的小部件:</p><p id="ac4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mb mc md me b">cd backend &amp;&amp; rails g scaffold widget title:string photo_data:string</code></p><p id="6ae0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">搭建中的关键是用后缀<code class="fe mb mc md me b">_data</code>命名附件数据，其类型是string。我起初错误地将其设置为JSON，然后Shrine试图解析一个hash并抛出一个异常。</p><p id="5bc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为<code class="fe mb mc md me b">photo_data</code>将作为一个json对象发送到控制器，我们需要改变接受参数的方式。打开<code class="fe mb mc md me b">app/controllers/widgets_controller.rb</code>并将<code class="fe mb mc md me b">widget_params</code>方法更改如下:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="70ca" class="kz la iq me b gy mn mo l mp mq"><strong class="me ir">def </strong>widget_params<br/>  params.require(:widget).permit(:title, photo_data: {})<br/><strong class="me ir">end</strong></span></pre><p id="f8e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个小部件模型，我们可以给它附加一个照片上传器。模型<code class="fe mb mc md me b">app/models/widget.rb</code>应该是这样的:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="29a4" class="kz la iq me b gy mn mo l mp mq"><strong class="me ir">class </strong><em class="mr">Widget </em>&lt; ApplicationRecord<br/>  include ImageUploader[:photo]<br/><strong class="me ir">end</strong></span></pre><p id="8863" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Shrine将寻找一个<code class="fe mb mc md me b">app/uploaders</code>文件夹，所以让我们来创建一个ImageUploader类:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="832c" class="kz la iq me b gy mn mo l mp mq"># app/uploaders/image_uploader.rb</span><span id="8ad9" class="kz la iq me b gy ms mo l mp mq"><strong class="me ir">class </strong><em class="mr">ImageUploader </em>&lt; Shrine<br/>  include ImageProcessing::Vips<br/>  plugin :backgrounding<br/>  <em class="mr"># The determine_mime_type plugin allows you to determine and store the actual MIME type of the file analyzed from file content.<br/>  </em>plugin :determine_mime_type<br/>  <em class="mr"># The store_dimensions plugin extracts and stores dimensions of the uploaded image using the fastimage gem, which has built-in protection against image bombs.<br/>  </em>plugin :store_dimensions<br/>  <em class="mr"># The validation_helpers plugin provides helper methods for validating attached files.<br/>  </em>plugin :validation_helpers<br/>  <em class="mr"># The pretty_location plugin attempts to generate a nicer folder structure for uploaded files.<br/>  </em>plugin :pretty_location<br/>  <em class="mr"># Allows you to define processing performed for a specific action.<br/>  </em>plugin :processing<br/>  <em class="mr"># The versions plugin enables your uploader to deal with versions, by allowing you to return a Hash of files </em><strong class="me ir"><em class="mr">when </em></strong><em class="mr">processing.<br/>  </em>plugin :versions<br/>  <em class="mr"># The delete_promoted plugin deletes files that have been promoted, after the record is saved. This means that cached files handled by the attacher will automatically get deleted once they're uploaded to store. This also applies to any other uploaded file passed to </em><strong class="me ir">Attacher</strong><em class="mr">#</em><strong class="me ir">promote</strong><em class="mr">.<br/>  </em>plugin :delete_promoted<br/>  <em class="mr"># The delete_raw plugin will automatically delete raw files that have been uploaded. This is especially useful </em><strong class="me ir"><em class="mr">when </em></strong><em class="mr">doing processing, to ensure that temporary files have been deleted after upload.<br/>  </em>plugin :delete_raw<br/>  <em class="mr"># The cached_attachment_data plugin adds the ability to retain the cached file across form redisplays, which means the file doesn't have to be reuploaded in </em><strong class="me ir"><em class="mr">case </em></strong><em class="mr">of validation errors.<br/>  </em>plugin :cached_attachment_data<br/>  plugin :logging<br/>  plugin :recache<br/><br/>  <em class="mr"># Define validations<br/>  # For a complete list of all validation helpers, see AttacherMethods. </em><strong class="me ir"><em class="mr">http://shrinerb.com/rdoc/classes/Shrine/Plugins/ValidationHelpers/AttacherMethods.html<br/>  </em></strong>Attacher.validate <strong class="me ir">do<br/>    </strong>validate_max_size 15.megabytes, message: 'is too large (max is 15 MB)'<br/>    validate_mime_type_inclusion %w[image/jpeg image/jpg image/png image/gif]<br/>  <strong class="me ir">end<br/><br/>  </strong><em class="mr"># Process additional versions in background.<br/>  </em>process(:store) <strong class="me ir">do </strong>|<em class="mr">io</em>|<br/>    versions = {original: <em class="mr">io</em>}<br/>    <em class="mr">io</em>.download <strong class="me ir">do </strong>|<em class="mr">original</em>|<br/>      pipeline = ImageProcessing::Vips.<em class="mr">source</em>(<em class="mr">original</em>)<br/>      versions[:large] = pipeline.resize_to_limit!(1200, 1200)<br/>      versions[:medium] = pipeline.resize_to_limit!(640,640)<br/>      versions[:small] = pipeline.resize_to_limit!(320,320)<br/>      versions[:lg_square] = pipeline.resize_to_fill!(1200, 1200)<br/>      versions[:md_square] = pipeline.resize_to_fill!(640, 640)<br/>      versions[:sm_square] = pipeline.resize_to_fill!(320, 320)<br/>    <strong class="me ir">end<br/>    </strong>versions<br/>  <strong class="me ir">end<br/><br/>  </strong>Attacher.promote { |<em class="mr">data</em>| ShrineBackgrounding::PromoteJob.perform_async(<em class="mr">data</em>) }<br/>  Attacher.delete { |<em class="mr">data</em>| ShrineBackgrounding::DeleteJob.perform_async(<em class="mr">data</em>) }<br/><strong class="me ir">end</strong></span></pre><p id="2d7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要创建后台作业来处理图像。Shrine将使它们在缓存中立即可用，并且一旦它们被处理，它将使用我们的S3/空间桶的URL更新模型。</p><p id="0e10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mb mc md me b">app/jobs/shrine_backgrounding</code>中，我们创建了一个<code class="fe mb mc md me b">PromoteJob</code>和<code class="fe mb mc md me b">DeleteJob</code>类:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="9a56" class="kz la iq me b gy mn mo l mp mq"><strong class="me ir"># app/jobs/shrine_backgrounding/promote_job.rb<br/>module </strong><em class="mr">ShrineBackgrounding<br/>  </em><strong class="me ir">class </strong><em class="mr">PromoteJob<br/>    </em>include Sidekiq::Worker<br/><br/>    <strong class="me ir">def </strong>perform(<em class="mr">data</em>)<br/>      Shrine::Attacher.promote(<em class="mr">data</em>)<br/>    <strong class="me ir">end<br/>  end<br/>end</strong></span><span id="b336" class="kz la iq me b gy ms mo l mp mq"><strong class="me ir"># app/jobs/shrine_backgrounding/delete_job.rb<br/>module </strong><em class="mr">ShrineBackgrounding<br/>  </em><strong class="me ir">class </strong><em class="mr">DeleteJob<br/>    </em>include Sidekiq::Worker<br/><br/>    <strong class="me ir">def </strong>perform(<em class="mr">data</em>)<br/>      Shrine::Attacher.delete(<em class="mr">data</em>)<br/>    <strong class="me ir">end<br/>  end<br/>end</strong></span></pre><p id="52d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在要在后台执行这些作业，我们需要运行Sidekiq。对于开发环境，只需使用<code class="fe mb mc md me b">bundle exec sidekiq</code>，但对于生产环境，我们使用systemd脚本:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="c537" class="kz la iq me b gy mn mo l mp mq"># /etc/systemd/system/sidekiq.service<br/># https://raw.githubusercontent.com/mperham/sidekiq/master/examples/systemd/sidekiq.service<br/># systemd unit file for CentOS 7, Ubuntu 15.04<br/>#<br/># Customize this file based on your bundler location, app directory, etc.<br/># Put this in /usr/lib/systemd/system (CentOS) or /lib/systemd/system (Ubuntu).<br/># Run:<br/>#   - systemctl enable sidekiq<br/>#   - systemctl {start,stop,restart} sidekiq<br/>#<br/># This file corresponds to a single Sidekiq process.  Add multiple copies<br/># to run multiple processes (sidekiq-1, sidekiq-2, etc).<br/>#<br/># See Inspeqtor's Systemd wiki page for more detail about Systemd:<br/># https://github.com/mperham/inspeqtor/wiki/Systemd<br/>#<br/>[Unit]<br/>Description=sidekiq<br/># start us only once the network and logging subsystems are available,<br/># consider adding redis-server.service if Redis is local and systemd-managed.<br/>After=syslog.target network.target<br/><br/># See these pages for lots of options:<br/># http://0pointer.de/public/systemd-man/systemd.service.html<br/># http://0pointer.de/public/systemd-man/systemd.exec.html<br/>[Service]<br/>Type=simple<br/>WorkingDirectory=/home/deploy/apps/app/current/backend<br/># If you use rbenv:<br/>ExecStart=/bin/bash -lc '/home/deploy/.rbenv/shims/bundle exec sidekiq -e production -q backend_production_mailers -q default -q mailers'<br/># If you use the system's ruby:<br/># ExecStart=/usr/local/bin/bundle exec sidekiq -e production<br/>User=deploy<br/>Group=deploy<br/>UMask=0002<br/><br/># Greatly reduce Ruby memory fragmentation and heap usage<br/># https://www.mikeperham.com/2018/04/25/taming-rails-memory-bloat/<br/>Environment=MALLOC_ARENA_MAX=2<br/>Environment=RAILS_ENV=production<br/>Environment=RAILS_MASTER_KEY=[YOUR MASTER KEY]<br/>Environment=APP_DATABASE=app_production<br/>Environment=APP_DATABASE_HOST=127.0.0.1<br/>Environment=APP_DATABASE_USERNAME=[YOUR DB]<br/>Environment=APP_DATABASE_PASSWORD=[DB PW]<br/><br/># if we crash, restart<br/>RestartSec=1<br/>Restart=on-failure<br/><br/># output goes to /var/log/syslog<br/>StandardOutput=syslog<br/>StandardError=syslog<br/><br/># This will default to "bundler" if we don't specify it<br/>SyslogIdentifier=sidekiq<br/><br/>[Install]<br/>WantedBy=multi-user.target</span></pre><p id="8613" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个脚本中的关键是sidekiq需要处理的队列是在ExecStart命令中定义的。如果您通过<code class="fe mb mc md me b">config/sidekiq.yml </code>配置队列，那么相应地调整命令。还要注意需要设置的环境变量，以便sidekiq可以访问数据库并解密凭证。</p><p id="8a53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望后端的最后一部分是一个可以立即上传文件到缓存的地方。为了安全地做到这一点，不要遵循Shrine的建议，将他们的上传者端点安装为机架应用程序。这将不允许你认证上传，并有效地把你的S3桶变成公共存储。相反，我们想创造一个<code class="fe mb mc md me b">UploadsController</code>。这里我将跳过认证部分，但是我强烈建议对基于API的Rails后端使用<a class="ae lx" href="https://github.com/nsarno/knock" rel="noopener ugc nofollow" target="_blank"> Knock </a>。现在我显示注释掉的before_action。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="5ed3" class="kz la iq me b gy mn mo l mp mq"><strong class="me ir">class </strong><em class="mr">UploadsController </em>&lt; ApplicationController<br/>  <em class="mr"># before_action </em>:authenticate_admin<br/><br/>  <strong class="me ir">def </strong>create<br/>    uploader = ImageUploader.new(:cache)<br/>    @file = uploader.upload(upload_params[:file])<br/>    render json: @file<br/>  <strong class="me ir">end<br/><br/>  </strong>protected<br/><br/>  <strong class="me ir">def </strong>upload_params<br/>    params.require(:upload).permit(:file)<br/>  <strong class="me ir">end<br/>end</strong></span></pre><p id="181e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向UploadsController添加路由:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="4e0f" class="kz la iq me b gy mn mo l mp mq">post 'uploads' <em class="mr">=&gt; </em>'uploads#create', defaults: { format: :json }</span></pre><p id="1d0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将我们的上传放到缓存中，使我们的UI不必在表单提交时上传文件，也不会阻塞用户交互。当我们完成上传后，我们将获取photo_data并在提交时将其添加到表单中。</p><p id="ed5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大量代码进入我们的后端。我希望你还和我们在一起。现在是制作UI的时候了！</p><h2 id="6d9f" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">前端:</h2><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="6969" class="kz la iq me b gy mn mo l mp mq">npm i -g <a class="ae lx" href="http://twitter.com/vue/cli" rel="noopener ugc nofollow" target="_blank">@vue/cli</a> <a class="ae lx" href="http://twitter.com/vue/cli-init" rel="noopener ugc nofollow" target="_blank">@vue/cli-init</a><br/>cd frontend &amp;&amp; vue init nuxt-community/starter-template .<br/>yarn install</span></pre><p id="4f01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这给了我们一个基本的基于nuxtjs的起点。继续，用<code class="fe mb mc md me b">yarn run dev</code>启动它。</p><p id="daf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我在项目中添加了<a class="ae lx" href="https://axios.nuxtjs.org/setup.html" rel="noopener ugc nofollow" target="_blank"> nuxt-axios </a>和<a class="ae lx" href="https://bootstrap-vue.js.org/docs" rel="noopener ugc nofollow" target="_blank"> bootstrap-vue </a>。我还想在端口3001上运行Rails，这样Nuxt就可以在端口3000上运行。nuxt.config.js文件:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="6533" class="kz la iq me b gy mn mo l mp mq">module.exports = {<br/>  /*<br/>  ** Headers of the page<br/>  */<br/>  head: {<br/>    title: 'uploader-example',<br/>    meta: [<br/>      {charset: 'utf-8'},<br/>      {name: 'viewport', content: 'width=device-width, initial-scale=1'},<br/>      {hid: 'description', name: 'description', content: 'Nuxt.js project'}<br/>    ],<br/>    link: [<br/>      {rel: 'icon', type: 'image/x-icon', href: '/favicon.ico'}<br/>    ]<br/>  },<br/>  /*<br/>  ** Customize the progress bar color<br/>  */<br/>  loading: {color: '#3B8070'},<br/>  /*<br/>  ** Build configuration<br/>  */<br/>  build: {<br/>    /*<br/>    ** Run ESLint on save<br/>    */<br/>    extend(config, {isDev, isClient}) {<br/>      /* configure bootstrap-vue image paths */<br/>      <strong class="me ir">const </strong>vueLoader = config.module.rules.find((rule) =&gt; rule.loader === 'vue-loader');<br/>      vueLoader.options.transformToRequire = {<br/>        'img': 'src',<br/>        'image': 'xlink:href',<br/>        'b-img': 'src',<br/>        'b-img-lazy': ['src', 'blank-src'],<br/>        'b-card': 'img-src',<br/>        'b-card-img': 'img-src',<br/>        'b-carousel-slide': 'img-src',<br/>        'b-embed': 'src'<br/>      };<br/><br/>      <strong class="me ir">if </strong>(isDev &amp;&amp; isClient) {<br/>        config.module.rules.push({<br/>          enforce: 'pre',<br/>          test: /\.(js|vue)$/,<br/>          loader: 'eslint-loader',<br/>          exclude: /(node_modules)/<br/>        })<br/>      }<br/>    }<br/>  },<br/>  modules: [<br/>    'bootstrap-vue/nuxt',<br/>    '@nuxtjs/axios'<br/>  ],<br/>  axios: {<br/>    /* set API_URL environment variable to configure access to the API<br/>    */<br/>    baseURL: process.env.API_URL || 'http://localhost:3001/',<br/>    redirectError: {<br/>      401: '/login',<br/>      404: '/notfound'<br/>    }<br/>  }<br/>}</span></pre><p id="22d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在构建部分，我还添加了一个webpack规则来支持带有bootstrap-vue的nuxt映像路径。</p><p id="aa66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将制作几个组件，并使用Vuex来处理它们之间的通信。我们的第一个组件是<code class="fe mb mc md me b">components/uploader.vue</code></p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="10e9" class="kz la iq me b gy mn mo l mp mq">&lt;template&gt;<br/>  &lt;b-form-group&gt;<br/>    &lt;b-form-file ref="file"<br/>                 v-model="file"<br/>                 :state="Boolean(file)"<br/>                 placeholder="Choose a file..."<br/>                 @input="sendFile"<br/>                 :accept="accept"&gt;&lt;/b-form-file&gt;<br/>    &lt;b-progress v-show="uploadPercentage &gt; 0 &amp;&amp; uploadPercentage !== 100"<br/>                striped<br/>                animated<br/>                :max="100"<br/>                class="mt-3"<br/>                :value="uploadPercentage"&gt;&lt;/b-progress&gt;<br/>  &lt;/b-form-group&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>  <strong class="me ir">export default </strong>{<br/>    props: {<br/>      accept: {<br/>        type: String,<br/>        <strong class="me ir">default</strong>: 'image/*'<br/>      },<br/>      apiUrl: {<br/>        type: String,<br/>        <strong class="me ir">default</strong>: '/uploads'<br/>      }<br/>    },<br/>    data() {<br/>      <strong class="me ir">return </strong>{<br/>        file: <strong class="me ir">null</strong>,<br/>        presigned: {},<br/>        uploadPercentage: 0,<br/>      }<br/>    },<br/>    methods: {<br/>      sendFile() {<br/>        <strong class="me ir">let </strong>vm = <strong class="me ir">this</strong>;<br/>        <strong class="me ir">let </strong>formData = <strong class="me ir">new </strong>FormData;<br/>        formData.append('upload[file]', vm.file);<br/>        <strong class="me ir">this</strong>.$axios.post(vm._props.apiUrl, formData, {<br/>            onUploadProgress: <strong class="me ir">function </strong>(progressEvent) {<br/>              vm.$emit('uploading');<br/>              vm.uploadPercentage = Math.round((progressEvent.loaded * 100) / progressEvent.total);<br/>            }<br/>          })<br/>          .then(resp =&gt; vm.$emit('presigned', resp.data))<br/>          .catch(<strong class="me ir">function </strong>(errors) {<br/>            console.log(errors)<br/>          })<br/>          .finally(resp =&gt; vm.$emit('done'));<br/>        <strong class="me ir">this</strong>.toDataUrl()<br/>      },<br/>      toDataUrl() {<br/>        <strong class="me ir">let </strong>vm = <strong class="me ir">this</strong>;<br/>        <strong class="me ir">let </strong>reader = <strong class="me ir">new </strong>FileReader();<br/>        reader.addEventListener("load", <strong class="me ir">function </strong>() {<br/>          <strong class="me ir">let </strong>dataUrl = reader.result;<br/>          vm.$emit('image', dataUrl);<br/>          vm.$store.commit('image_preview/set', dataUrl)<br/>        }.bind(vm), <strong class="me ir">false</strong>);<br/>        <strong class="me ir">if </strong>(/\.(jpe?g|png|gif)$/i.test(vm.file.name)) {<br/>          reader.readAsDataURL(vm.file);<br/>        }<br/>      }<br/>    }<br/>  }<br/>&lt;/script&gt;</span></pre><p id="8bec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们处理对<code class="fe mb mc md me b">UploadsController</code>的上传，发出一个“预设计”事件来捕获我们需要在小部件表单中发送的数据。我们将文件对象解析为数据uri，然后我们可以立即预览我们在<code class="fe mb mc md me b">components/image-preview.vue</code>组件中上传的内容:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="f906" class="kz la iq me b gy mn mo l mp mq">&lt;template&gt;<br/>  &lt;b-img thumbnail fluid :src="image" v-show="validate(image)"&gt;&lt;/b-img&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>  <strong class="me ir">export default </strong>{<br/>    name: 'image-preview',<br/>    computed: {<br/>      image() {<br/>        <strong class="me ir">return this</strong>.$store.state.image_preview.image;<br/>      }<br/>    },<br/>    methods: {<br/>      validate(img) {<br/>        <strong class="me ir">return </strong>img &amp;&amp; (img.match(/jpg|gif|png|jpeg/) || img.match(/^data:image/))<br/>      }<br/>    },<br/>    mounted() {<br/>      <strong class="me ir">return this</strong>.validate(<strong class="me ir">this</strong>.image) ? <strong class="me ir">this</strong>.show = <strong class="me ir">true </strong>: <strong class="me ir">this</strong>.show = <strong class="me ir">false</strong>;<br/>    }<br/>  }<br/>&lt;/script&gt;</span></pre><p id="75b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到，在这些组件中，我们从<code class="fe mb mc md me b">store/image_preview.js</code> vuex存储中设置和检索一个值:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="ac13" class="kz la iq me b gy mn mo l mp mq"><strong class="me ir">export const </strong>state = () =&gt; ({<br/>  image: <strong class="me ir">null<br/></strong>})<br/><br/><strong class="me ir">export const </strong>mutations = {<br/>  set(state, image) {<br/>    state.image = image<br/>  }<br/>};</span></pre><p id="b33a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它处理了我们在缓存中存储文件、预览文件、甚至上传进度条所需要的一切。很棒吧？</p><p id="2b97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在剩下的实际上与您想通过JSON键/值对提交给RESTful后端的任何其他表单没有什么不同。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="8b92" class="kz la iq me b gy mn mo l mp mq">...<br/>&lt;b-card class="text-left"&gt;<br/>  &lt;h5&gt;New Widget&lt;/h5&gt;<br/>  &lt;b-form ref="form" @submit.prevent="newWidget"&gt;<br/>    &lt;b-form-group label="Title"&gt;<br/>      &lt;b-form-input v-model="title"&gt;&lt;/b-form-input&gt;<br/>    &lt;/b-form-group&gt;<br/>    &lt;uploader v-model="photo" @presigned="photo_data = $event"&gt;&lt;/uploader&gt;<br/>    &lt;image-preview&gt;&lt;/image-preview&gt;<br/>    &lt;b-btn type="submit" variant="primary"&gt;Create Widget&lt;/b-btn&gt;<br/>  &lt;/b-form&gt;<br/>&lt;/b-card&gt;<br/>...<br/>&lt;script&gt;<br/>...<br/>data() {<br/>  <strong class="me ir">return </strong>{<br/>    photo: <strong class="me ir">null</strong>,<br/>    photo_data: <strong class="me ir">null</strong>,<br/>    title: <strong class="me ir">null<br/>  </strong>}<br/>},<br/>methods: {<br/>  newWidget() {<br/>    <strong class="me ir">this</strong>.$axios.post('/widgets', {<br/>      widget: {<br/>        photo_data: <strong class="me ir">this</strong>.photo_data,<br/>        title: <strong class="me ir">this</strong>.title<br/>      }<br/>    }).then((resp) =&gt; {<br/>      <strong class="me ir">if</strong>(resp.status === 201) {<br/>        alert('success!');<br/>        <strong class="me ir">this</strong>.$refs.form.reset();<br/>        <strong class="me ir">this</strong>.$store.commit('image_preview/set', <strong class="me ir">null</strong>)<br/>      }<br/>    })<br/>  }<br/>}<br/>...</span></pre><p id="927e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果都完成了，您最终会得到如下所示的结果:</p><figure class="mf mg mh mi gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mt"><img src="../Images/e66fb8d6d82ec5579f24fe4a3f2b6b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oC_PQucmE5jubCj2P7V2kA.png"/></div></div></figure><h1 id="763d" class="nb la iq bd lb nc nd ne le nf ng nh lh ni nj nk lk nl nm nn ln no np nq lq nr bi translated">结论</h1><p id="c4f6" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我希望这篇教程能让人们对构建web应用程序感到兴奋。我认为处理文件上传总是很难，虽然有很多工具可以让它变得更容易，但在阅读如何做到这一点时，仍然有很多困惑和遗留问题。我希望我达到了目标，并且你能够兴奋地阅读本教程，使用Rails和Shrine进行上传，并使用Nuxt和Bootstrap构建出色的用户界面。许多现代web应用程序都遵循这种类型的架构。我希望你到此为止，并很好地理解在一个宁静的世界上传是如何工作的。</p><p id="a344" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我把这些都放在一个应用程序里，你可以在Github上下载并查看:<a class="ae lx" href="https://github.com/toadkicker/uploader-example" rel="noopener ugc nofollow" target="_blank">https://github.com/toadkicker/uploader-example</a></p><p id="5d82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码快乐！</p></div></div>    
</body>
</html>