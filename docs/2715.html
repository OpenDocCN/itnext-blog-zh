<html>
<head>
<title>TimingLogger: An idiomatic Android approach to measuring execution time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TimingLogger:一种测量执行时间的惯用Android方法</h1>
<blockquote>原文：<a href="https://itnext.io/timinglogger-an-idiomatic-android-approach-to-measuring-execution-time-8ac10a8fa0ba?source=collection_archive---------4-----------------------#2019-07-17">https://itnext.io/timinglogger-an-idiomatic-android-approach-to-measuring-execution-time-8ac10a8fa0ba?source=collection_archive---------4-----------------------#2019-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="948e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">通过实例学习</h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div class="gh gi jz"><img src="../Images/177c9fc6dc5b6dccaf0b5894c00702e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*c4iJb0CvOnuOo6Nc8Cg_5g.png"/></div></figure><p id="6206" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">在你作为Android开发人员的职业生涯中，你最终会遇到一些性能不佳的代码。也许这是你创作的代码，也许这是你继承的代码，但它的起源并不重要。代码现在在你的管理下，你的团队和你的用户都在看着你，这个完美的Android摇滚明星，来解决困扰应用的性能问题。</p><p id="e9c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开发Android代码的开发人员可以采用几种不同的方法来衡量代码块的性能。由于许多Android开发人员都有Java编程背景，您将看到的一种更常见的策略是通过调用<code class="fe ln lo lp lq b"><a class="ae lr" href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#nanoTime()" rel="noopener ugc nofollow" target="_blank">System.nanoTime()</a></code>来包围可疑代码，如下所示:</p><pre class="ls lt lu lv gt lw lq lx ly aw lz bi"><span id="6c61" class="ma mb it lq b gy mc md l me mf"><em class="mg">// capture the start time<br/></em><strong class="lq jd">val </strong>startTime = System.nanoTime()<br/><br/><em class="mg">// suspiciously long running block of code<br/></em><strong class="lq jd">var </strong>number = 0L<br/><strong class="lq jd">for </strong>(x <strong class="lq jd">in </strong>0..10_000_000)<br/>    number += x<br/><br/><em class="mg">// capture the end time<br/></em><strong class="lq jd">val </strong>endTime = System.nanoTime()<br/><br/><em class="mg">// dump the execution time out<br/></em>Log.d(<strong class="lq jd">"TimingLoggerDemo"</strong>,<strong class="lq jd">"${</strong>TimeUnit.<strong class="lq jd">MILLISECONDS</strong>.convert(endTime -<br/>        startTime, TimeUnit.<strong class="lq jd">NANOSECONDS</strong>)<strong class="lq jd">} ms, (1)"</strong>)</span></pre><p id="4245" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很好，而且它肯定会完成工作，但是在大多数情况下，您正在分析的方法中会有多个潜在的调用或代码块，它们可能是执行时间接收器的来源。下面的例子演示了使用<code class="fe ln lo lp lq b"><a class="ae lr" href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#nanoTime()" rel="noopener ugc nofollow" target="_blank">System.nanoTime()</a></code>或者它的一个变体(例如<code class="fe ln lo lp lq b">System.elapsedTime()</code>)会很快变得难以使用:</p><pre class="ls lt lu lv gt lw lq lx ly aw lz bi"><span id="d155" class="ma mb it lq b gy mc md l me mf"><em class="mg">// capture the start time<br/></em><strong class="lq jd">var </strong>startTime = System.nanoTime()<br/><br/><em class="mg">// suspiciously long running block of code<br/></em><strong class="lq jd">var </strong>number = 0L<br/><strong class="lq jd">for </strong>(x <strong class="lq jd">in </strong>0..10_000_000)<br/>    number += x<br/><br/><em class="mg">// capture the end time<br/></em><strong class="lq jd">var </strong>endTime = System.nanoTime()<br/><br/><em class="mg">// dump the execution time out<br/></em>Log.d(<strong class="lq jd">"TimingLoggerDemo"</strong>,<strong class="lq jd">"${</strong>TimeUnit.<strong class="lq jd">MILLISECONDS</strong>.convert(endTime -<br/>        startTime, TimeUnit.<strong class="lq jd">NANOSECONDS</strong>)<strong class="lq jd">} ms, (1)"</strong>)<br/><br/><em class="mg">// capture the start time<br/></em>startTime = System.nanoTime()<br/><br/><em class="mg">// another suspiciously long running block of code<br/></em>callSomeMethod()<br/><br/><em class="mg">// capture the end time<br/></em>endTime = System.nanoTime()<br/><br/><em class="mg">// dump the execution time out again<br/></em>Log.d(<strong class="lq jd">"TimingLoggerDemo"</strong>,<strong class="lq jd">"${</strong>TimeUnit.<strong class="lq jd">MILLISECONDS</strong>.convert(endTime -<br/>        startTime, TimeUnit.<strong class="lq jd">NANOSECONDS</strong>)<strong class="lq jd">} ms, (2)"</strong>)</span><span id="4504" class="ma mb it lq b gy mh md l me mf"><br/>...and on and on for each possible culprit</span></pre><p id="1dd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">令人欣慰的是，Android的实用程序包中有一个更简单、更简洁、更惯用的类，可以用来分析像上面这样有问题的方法。引入<a class="ae lr" href="https://developer.android.com/reference/android/util/TimingLogger" rel="noopener ugc nofollow" target="_blank"> TimingLogger </a>类(或者<em class="mg">重新引入</em>，因为它从API Level 1开始就可用了)！</p><figure class="ls lt lu lv gt kd"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">人群听到计时日志类时的反应</figcaption></figure><p id="f411" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们重写上面的示例，但是这次我们将利用<a class="ae lr" href="https://developer.android.com/reference/kotlin/android/util/TimingLogger.html" rel="noopener ugc nofollow" target="_blank"> TimingLogger </a>类来捕获执行时间度量。我们走吧。是的，是的，我们会:</p><pre class="ls lt lu lv gt lw lq lx ly aw lz bi"><span id="a7d9" class="ma mb it lq b gy mc md l me mf"><em class="mg">// instantiate a timing logger<br/></em><strong class="lq jd">val </strong>timingLogger = TimingLogger(<strong class="lq jd">"TimingLoggerDemo"</strong>, <strong class="lq jd">""</strong>)<br/><br/><em class="mg">// suspiciously long running block of code<br/></em><strong class="lq jd">var </strong>number = 0L<br/><strong class="lq jd">for </strong>(x <strong class="lq jd">in </strong>0..10_000_000)<br/>    number += x<br/>timingLogger.addSplit(<strong class="lq jd">"(1)"</strong>)<br/><br/><em class="mg">// another suspiciously long running block of code<br/></em>callSomeMethod()<br/>timingLogger.addSplit(<strong class="lq jd">"(2)"</strong>)<br/><br/><em class="mg">// dump all of the execution times out<br/></em>timingLogger.dumpToLog()</span></pre><p id="ea28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行上述代码的输出如下:</p><figure class="ls lt lu lv gt kd gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/2cd7932e60ac372136a05bbeaa8b0714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*6HqMqCWXG58ET0AhHbX9aw.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">定时日志输出</figcaption></figure><p id="3c2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以基本上你只需要实例化一个<a class="ae lr" href="https://developer.android.com/reference/kotlin/android/util/TimingLogger.html" rel="noopener ugc nofollow" target="_blank"> TimingLogger </a>对象，然后为你想要测量的每段代码调用<code class="fe ln lo lp lq b"><a class="ae lr" href="https://developer.android.com/reference/kotlin/android/util/TimingLogger.html#addsplit" rel="noopener ugc nofollow" target="_blank">addSplit(<em class="mg">split-label)</em></a></code>方法。一旦你把所有的<a class="ae lr" href="https://www.braums.com/wp-content/uploads/2018/06/BananaSpit.jpg" rel="noopener ugc nofollow" target="_blank">香蕉船</a>都准备好了，你就调用<code class="fe ln lo lp lq b"><a class="ae lr" href="https://developer.android.com/reference/kotlin/android/util/TimingLogger.html#dumptolog" rel="noopener ugc nofollow" target="_blank">dumpToLog()</a></code>把测量结果写到<a class="ae lr" href="https://developer.android.com/studio/command-line/logcat" rel="noopener ugc nofollow" target="_blank"> logcat </a>中。</p><p id="dd01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">🔔<a class="ae lr" href="https://developer.android.com/reference/kotlin/android/util/TimingLogger.html" rel="noopener ugc nofollow" target="_blank"> TimingLogger </a>类的一个常见缺陷是，默认情况下，它不会产生任何输出。要查看输出，必须将类实例化期间指定的标记的日志记录级别设置为VERBOSE。在我们的示例代码中，我们指定了一个标记“TimingLoggerDemo ”,因此下面的命令必须通过终端执行，以便查看我们示例的输出。</p><pre class="ls lt lu lv gt lw lq lx ly aw lz bi"><span id="2bd6" class="ma mb it lq b gy mc md l me mf">adb shell setprop log.tag.TimingLoggerDemo VERBOSE</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="d27a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jd">结论<br/>因此，如果你发现自己在与一个麻烦的、性能差的方法争论，那么希望你能记住这个非常有用的类。</strong></p><p id="c18e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的关注！托马斯·桑德兰</p><div class="mw mx gp gr my mz"><a href="https://www.linkedin.com/in/thomas-sunderland/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">托马斯·桑德兰-安卓开发者| LinkedIn</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">加入LinkedIn我叫Thomas Sunderland，是一名软件工程师，专注于原生Android开发。我…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">www.linkedin.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ke mz"/></div></div></a></div></div></div>    
</body>
</html>