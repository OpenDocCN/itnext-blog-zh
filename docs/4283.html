<html>
<head>
<title>DevSecOps: Automatically detecting bearer tokens being passed in clear-text inside Kubernetes clusters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DevSecOps:自动检测Kubernetes集群中以明文形式传递的不记名令牌</h1>
<blockquote>原文：<a href="https://itnext.io/devsecops-automatically-detecting-clear-text-bearer-tokens-inside-kubernetes-cc1cd0827391?source=collection_archive---------3-----------------------#2020-05-29">https://itnext.io/devsecops-automatically-detecting-clear-text-bearer-tokens-inside-kubernetes-cc1cd0827391?source=collection_archive---------3-----------------------#2020-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="04de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">DevSecOps的一个重要部分是授权团队自动检测安全错误配置，这里有一个自动化的例子。</h2></div><p id="c6c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着令人兴奋的服务网格的兴起，更多的微服务被取出并推入网格。一个这样的例子是使用<a class="ae lb" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>添加传输中加密的能力，而无需改变您的工作负载。</p><p id="1da9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在pod之间启用相互TLS(MTL ),确保它们的通信是安全和机密的，并使集群中的其他组件难以窃听它们。</p><p id="8922" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种魔法的负面影响是，您的应用程序可能会忘记这些功能的状态。如果它们被意外禁用，您的应用程序将继续正常运行，但现在在集群内以明文形式发送数据，这对于某些用例来说可能是不可接受的。</p><p id="4c73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我决定自动检测这种情况，以确保如果有人意外禁用了mTLS，或者某些组件没有使用网格，我将能够检测到它，而不需要手动干预。</p><h1 id="7b4d" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak"> Beargrabz！</strong></h1><p id="3f23" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在的趋势是，你想解决一个问题，你就去为它创建一个golang应用程序，所以我做了！该应用程序名为“<a class="ae lb" href="https://github.com/pjbgf/beargrabz" rel="noopener ugc nofollow" target="_blank"> beargrabz </a>”，它以混杂模式接入主机网络，检查所有TCP数据包，寻找明文形式的授权令牌。</p><p id="3bfd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个包含一些额外组件的端到端示例:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/5877138c9dd7e879e4a74b999faeaf9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YInp3P3zn3KskTztFYY9iQ.png"/></div></div></figure><h1 id="8fd2" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">成分</h1><ol class=""><li id="14ac" class="ml mm iq kh b ki lu kl lv ko mn ks mo kw mp la mq mr ms mt bi translated"><strong class="kh ir"> httpbin </strong> : web服务器监听端口80。</li><li id="63bf" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><strong class="kh ir"> httpbin </strong>:服务监听端口8000，重定向到pod httpbin:80。</li><li id="1010" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><strong class="kh ir"> api-client </strong>:持续查询httpbin发送承载令牌的<code class="fe mz na nb nc b">alpine</code>容器；</li></ol><pre class="ma mb mc md gt nd nc ne nf aw ng bi"><span id="0949" class="nh ld iq nc b gy ni nj l nk nl">watch -n 1 timeout 1 wget --header "<strong class="nc ir">Authorization: Bearer SUPERTOKEN</strong>" -O- http://httpbin:8000</span></pre><p id="2195" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.<strong class="kh ir"> beargrabz </strong>:实际的应用程序，它只记录找到了承载令牌的请求。</p><h1 id="3cff" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">运行示例</h1><p id="a577" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">可以使用以下命令部署整个示例:</p><pre class="ma mb mc md gt nd nc ne nf aw ng bi"><span id="84df" class="nh ld iq nc b gy ni nj l nk nl">kubectl apply -f <a class="ae lb" href="https://raw.githubusercontent.com/pjbgf/beargrabz/master/sample/playground.yml?token=ABJTJMPD4RPANFZFRPHE6XK62D6EI" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/pjbgf/beargrabz/master/sample/playground.yml?token=ABJTJMPD4RPANFZFRPHE6XK62D6EI</a></span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nm"><img src="../Images/a48e29042350f4a5c2c1a5e12c5b511e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_gn6BEPS8N2aGyPHYrznpg.png"/></div></div></figure><p id="a67e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浏览beargrabz日志，我们可以看到目前为止捕获的令牌:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nn"><img src="../Images/cc1b5e8368f705c2d704f44fa79dc3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r5JVlcQGCDvdykdE3_MCXQ.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">令牌被截断，因为您不希望整个令牌到处乱飞。:)</figcaption></figure><h1 id="179c" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">后续行动</h1><p id="c809" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这种应用程序可以按需执行——如果您有一个好的GitOps管道，还可以进行E2E测试。或者只是部署到集群中，并插入到您的日志记录/监控堆栈中，这样您就可以在违规时发出警报。</p><p id="50dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欲了解更多信息，请查看github 。</p></div></div>    
</body>
</html>