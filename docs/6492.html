<html>
<head>
<title>Modern C++ in Advent of Code: Day2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++代码的出现:第二天</h1>
<blockquote>原文：<a href="https://itnext.io/modern-c-in-advent-of-code-day2-ca0af5bf0182?source=collection_archive---------1-----------------------#2021-12-02">https://itnext.io/modern-c-in-advent-of-code-day2-ca0af5bf0182?source=collection_archive---------1-----------------------#2021-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="79ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是代码问世的第二天。今天我们将学习一个结构，看看宇宙飞船操作符。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/fe8195b10a5f87ce55f7c7340ccdf06a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DIhLtuukvAgXnf1SElQduA.png"/></div></div></figure><p id="552b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，请先尝试解决问题，然后再看解决方案。对于本系列中的所有文章，<a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">查看这个列表</a>。</p><h1 id="9d51" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第二天:第一部分</h1><p id="205c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们收到了文本形式的指令。该格式基于行，每行有一个命令，每个命令由一个方向和一个数值组成。</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="eeb3" class="mg kz iq mc b gy mh mi l mj mk">forward 10<br/>down 2<br/>up 1</span></pre><p id="75fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解析文本是C++标准库不擅长的领域之一。高级设施效率不是很高，低级设施也不是特别好用。我将坚持使用高级工具，但会指出代码中效率特别低的地方。</p><p id="c298" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们解析输入时，我们需要一种方法来跟踪位置。最简单的方法是创建一个包含两个字段的简单结构:<code class="fe ml mm mn mc b">depth</code>使用<code class="fe ml mm mn mc b">up</code>和<code class="fe ml mm mn mc b">down</code>命令进行调整，而<code class="fe ml mm mn mc b">distance</code>使用<code class="fe ml mm mn mc b">forward</code>命令进行调整。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5a65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以为我们简化问题，孤立处理每一行。因为每个命令都转换成一个位置增量，所以我们可以解析一行并返回一个<code class="fe ml mm mn mc b">Position</code>。然后，外部代码可以将增量添加到运行位置。</p><p id="eac3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和第一天一样，我们将从编写这个行解析函数的测试开始:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ca97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，这段代码现在要求<code class="fe ml mm mn mc b">Position</code>是可比较的，因为<code class="fe ml mm mn mc b">EXEPECT_EQ</code>。我们可以通过在结构中添加一个默认的飞船操作符来快速解决这个问题。默认实现提供了一个字典式比较器，但是我们只需要<code class="fe ml mm mn mc b">==</code>和<code class="fe ml mm mn mc b">!=</code>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2522" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是实现行解析的时候了:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="209b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先从数字中找到分隔命令的空格(第2行)，然后将数字转换为整数(第3行)，并基于命令返回不同的位置增量。</p><p id="dad5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们真的关心性能，我们会使用<code class="fe ml mm mn mc b">std::string_view</code>。不幸的是，标准库目前不提供将<code class="fe ml mm mn mc b">std::string_view</code>转换成数字(直接)的功能，我们必须写一个关于<code class="fe ml mm mn mc b">std::from_chars</code>的包装器。</p><p id="b610" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，当我们强制复制<code class="fe ml mm mn mc b">std::string</code>时，我们正在解析的所有命令都应该很好地适应小字符串优化。因此，即使有副本，我们也不应该造成内存分配，成本应该相当于使用<code class="fe ml mm mn mc b">std::string_view</code>。</p><p id="7125" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解析整个输入，我们现在逐行调用我们的行解析代码。但是首先，测试代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="8f2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们仍然缺少的一件事是将位置增量加在一起的方法。我们可以将<code class="fe ml mm mn mc b">operator+=</code>添加到我们的<code class="fe ml mm mn mc b">Position</code>结构中，这样我们就不必手动处理添加的内容。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="859e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了行解析器和支持<code class="fe ml mm mn mc b">operator +=</code>的<code class="fe ml mm mn mc b">Position</code>，完整的解析代码变得非常简单:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="28eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们逐行进行，直到到达文件的末尾，在每一行应用我们的行解析器，并将结果添加到运行总数中。</p><h1 id="0ed5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第二天:第二部分</h1><p id="3f1c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">问题的第二部分引入了一个有趣的转折。代替代表直接移动的<code class="fe ml mm mn mc b">up</code>和<code class="fe ml mm mn mc b">down</code>，它们改变方向，然后<code class="fe ml mm mn mc b">forward</code>应用这个方向。</p><p id="de15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们的代码是无状态的，每一行都被孤立地解释。方向的引入改变了<code class="fe ml mm mn mc b">forward</code>的含义。因此，我们必须通过将我们的行解析代码改为有状态来跟踪方向。但是让我们从调整我们的<code class="fe ml mm mn mc b">Position</code>结构开始。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5d4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将原始操作转移到成员函数中会使我们的解析代码更容易阅读。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="86eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个测试还决定了我们如何向行解析器提供状态的接口。我们有其他选择，例如，这个解析代码也可以是我们的位置结构的成员函数:<code class="fe ml mm mn mc b">pos.parse(line)</code>。</p><p id="72d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些准备，我们的行解析器与第1部分的版本非常相似:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="9b78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以非常相似的方式把所有这些放在一起:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="def1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们仍然像以前一样在每一行上调用行解析器。然而，这一次，我们传递了保存在所有调用中的状态。</p><p id="39d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，由于我没有在第1部分展示它，让我们看看我们的主函数，它与Day1非常相似。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="3462" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">链接和技术说明</h1><p id="c4eb" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">每日解决方案存储库位于:<a class="ae kl" href="https://github.com/HappyCerberus/moderncpp-aoc-2021" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/moderncpp-aoc-2021</a>。</p><p id="66bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于《代码降临》中其他日子的文章，<a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">请看这个列表</a>。</p><p id="0b99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请不要忘记亲自尝试<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">降临码</a>。</p><h1 id="0c5c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="bcb7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="1d65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还在T2的YouTube上发布视频。你有问题吗？在<a class="ae kl" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae kl" href="https://www.linkedin.com/in/simontoth" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>