<html>
<head>
<title>Contrasting NATS with Apache Kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NATS与阿帕奇·卡夫卡的对比</h1>
<blockquote>原文：<a href="https://itnext.io/contrasting-nats-with-apache-kafka-1d3bdb9aa767?source=collection_archive---------1-----------------------#2020-09-02">https://itnext.io/contrasting-nats-with-apache-kafka-1d3bdb9aa767?source=collection_archive---------1-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/40b1a0921ba58d309c337dab870edd40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWQ7tDR579MwYDnQmsZl2g.jpeg"/></div></div></figure><div class=""/><p id="0e7b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">TL；卡夫卡博士是一个<em class="kz">事件流平台</em>，而NATS更接近于传统的<em class="kz">消息队列</em>。Kafka围绕新兴的<em class="kz">事件驱动架构</em>的独特需求进行了优化，这些架构用强大的排序和持久语义丰富了传统的发布-订阅模型。相反，NATS围绕发布-订阅拓扑进行了高度优化，并且是解耦系统的优秀平台，在这些系统中，消息顺序和可靠的交付不是问题。</strong></p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="3914" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将在这篇文章的开头指出，还有另一个产品——<strong class="kd jf">NATS流媒体</strong>——这是一个不同的野兽，更接近卡夫卡。如果你在寻找一个替代的活动流媒体平台，你可能会想绕道去NATS流媒体；否则，请继续阅读。</p><h1 id="b9cc" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">订阅</strong></h1><p id="77bb" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">其核心是，<strong class="kd jf"> NATS是关于发布和监听信息的</strong>。这些在很大程度上依赖于<strong class="kd jf">主题</strong>，它们将消息划分为流或主题。消费者或者逐字订阅主题(精确匹配主题名)，或者使用通配符。下图是NATS出版商、受试者和消费者之间的关系。</p><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mk"><img src="../Images/6ad1e1e674054cd88ff02541e8539fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*TVIVugK0aEIpZLbL"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">信用:<a class="ae mt" href="https://nats.io/" rel="noopener ugc nofollow" target="_blank">https://nats.io/</a></figcaption></figure><p id="749b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从表面上看，这与卡夫卡并不截然相反，卡夫卡也通过<strong class="kd jf">主题</strong>的方式将生产者和消费者分离。然而，它们的语义不同。卡夫卡将其主题组织成<strong class="kd jf">分区</strong>——无界的、完全有序的<strong class="kd jf">记录流</strong>(卡夫卡对信息的替代术语)。一个主题包含一个或多个分区，并呈现出<strong class="kd jf">偏序</strong>。(换句话说，虽然记录在其各自的分区内是完全有序的，但是它们在分区间的顺序是任意的。)这种灵活的安排使得<strong class="kd jf"> Kafka非常适合于秩序很重要的应用</strong>；例如，状态机复制、事件源、日志传送、日志聚合、SEDA(分阶段事件驱动架构)和CEP(复杂事件处理)。</p><p id="6f06" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">说到主题，等价的NATS主题是一个轻量级的构造，它是基于需求(订阅)自动创建的，当需求停止时会自动删除。创建NATS主题的成本很低，这使得它们非常适合分层组织的数据，允许细粒度的订阅模型。任何使用过MQTT风格的代理(比如HiveMQ)的人都应该对NATS有宾至如归的感觉。相比之下，卡夫卡的主题是重量级的实体，需要时间来旋转，缺乏NATS的技巧。因此，Kafka消费者必须在本地执行大量必要的数据过滤——从所有分配的分区中消费记录，并悄悄地丢弃那些被认为不相关的记录。</p><p id="8713" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">卡夫卡式的分割在生物学意义上就像一条动脉——从源头抽离出来，供给下游器官——<em class="kz">消费者</em>。一条记录有一个<strong class="kd jf">偏移量</strong>，也可能有一个<strong class="kd jf">键</strong>和一个<strong class="kd jf">值</strong>；两者都是字节数组，都是可选的。记录的键会影响它的排序——共享一个公共键的记录肯定会占用同一个分区，从而保持它们的内在顺序。分区、记录和偏移量的概念如下所示。</p><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/137b536e57240d2f6bb4b639e9cc4360.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/0*VsBQh8Mix1R6i1uu"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">信用:<a class="ae mt" href="https://kafka.apache.org/documentation" rel="noopener ugc nofollow" target="_blank">https://kafka.apache.org/documentation</a></figcaption></figure><h1 id="9bc0" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">负载均衡</strong></h1><p id="42b2" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">为了进一步明确这两个平台之间的差异，让我们考虑一下NATS和卡夫卡是如何处理负载平衡的——这是任何面向消息的中间件的一个基本特征。</p><p id="8413" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">NATS可以选择在一组订户之间平衡消息传递，这可用于提供应用程序容错和扩展工作负载处理。为了创建队列订阅，订阅者注册一个<strong class="kd jf">队列名</strong>。具有相同队列名称的所有用户形成相应的<strong class="kd jf">队列组</strong>。当关于注册主题的消息被发布时，<em class="kz">组中的一个成员被随机选择来接收消息</em>。尽管队列组可能有多个订阅者，但每个消息只由一个订阅者使用。下图说明了这一点。</p><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b8ecb6bd43b0c6a37b588c5a4162dda1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/0*_KaDE2matxSLRaRq"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">信用:<a class="ae mt" href="https://nats.io/" rel="noopener ugc nofollow" target="_blank">https://nats.io/</a></figcaption></figure><p id="4126" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然NATS提供了低至消息级别的细粒度消费者可伸缩性，但这是以牺牲消息排序为代价的。消息可能会在两个或更多不同的订阅者处被无序地并发处理，这使得它不适合于对顺序敏感的应用程序。(注:NATS流媒体解决了这一问题，但如前所述，它本身是一种不同的产品。)</p><p id="ddac" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">卡夫卡的消费者订阅一个主题，作为一个包罗万象的消费者群体的一部分。当组中的第一个消费者加入主题时，它将接收该主题中的所有分区。当第二个消费者随后加入时，它将获得大约一半的分区，从而减轻第一个消费者先前一半的负载。当消费者离开(通过断开连接或超时)时，该过程反向运行，剩余的消费者将吸收更多的分区。所以一个消费者组平衡分区负载；添加的消费者越多，每个消费者收到的分区就越少。添加比分区更多的消费者会使一些消费者处于空闲状态；<strong class="kd jf"> Kafka永远不会将一个分区分配给同一个组的多个消费者</strong>。所以，虽然卡夫卡的负载平衡方案比NATS的更粗粒度；它设法在消费者节点保持记录的顺序。下图说明了生产者、主题、分区、消费者和消费者群体之间的关系。请注意，从记录流和负载平衡的角度来看，使用者组在逻辑上是隔离的。</p><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/5dac295a46324f89390550a68c57d774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*GBTCnNr8IbkbZVMN"/></div></figure><h1 id="409d" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">交货保证</strong></h1><p id="a80e" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">另一个重要的区别是<em class="kz">持久性</em>。<strong class="kd jf"> Kafka是一个持久的数据存储库，提供至少一次交付语义</strong>。使用者读取记录的行为并不会删除该记录，它只是将一个内部指针指向分区中的下一条记录。这被称为<strong class="kd jf">提交</strong>偏移。如果消费者在成功处理记录之前崩溃，Kafka将重新交付最后一组记录(尚未提交补偿)。因为记录会保留一段时间(根据可配置的保留策略)，所以消费者可以随意处理在其保留期之前很久发布的记录。</p><p id="db18" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相比之下，NATS实施的是通常所说的<strong class="kd jf">最多一次交付</strong>。NATS努力保持并提供一个“拨号音”。然而，如果订户退出，它将不会接收到消息，因为基本的NATS平台是简单的发布-订阅传输系统，仅提供TCP级的可靠性。(这使得NATS与更传统的MQ代理略有不同，传统的MQ代理倾向于为了那些在发布点之前注册了兴趣的订阅者的利益而持久保存消息，在消息被传递到所有端点之后删除消息。)简而言之，NATS并不是被设计成一个长期的活动商店；它最适合用作面向订阅、以消息为中心的传输层，而不是数据存储。</p><h1 id="4d2c" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">运营问题</strong></h1><p id="19f1" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">从操作角度来看，差异也很明显。卡夫卡是一个庞然大物。它的部署拓扑由混合的<strong class="kd jf">代理</strong>和<strong class="kd jf">动物园管理员</strong>节点组成，有数百个(如果不是数千个的话)可调的“旋钮”，控制着它行为的各个方面。(还有一些是相当危险的，在没文化的手里。)</p><p id="e6f2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这方面，NATS集群要简单得多，参数也少得多——这并不奇怪，因为它缺乏持久性。</p><h1 id="3aad" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">总结</strong></h1><p id="ecae" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">所以你有它。这两者之间的差异现在应该很明显了。以上观点并不意味着一个比另一个更好；这不是A <em class="kz">对</em> B的讨论。虽然可以客观地说，Kafka通过迎合更广泛的消息传递和事件场景提供了更大的整体灵活性，但它的配置和维护也相应地更加复杂，并且在某些场景中可能是多余的。NATS是一个更简单的解决方案，它更容易上手和操作。我们不要忘记，后者非常重要。使用最简单的平台，满足您当前和预期的需求，并与您组织中当前流行的技能组合保持良好的一致性。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="0ce8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章对你有用吗？我很想听听你的反馈，所以不要退缩。如果你对Kafka，Kubernetes，微服务，或者事件流感兴趣，或者只是有什么疑问， <a class="ae mt" href="https://twitter.com/i/user/562466177" rel="noopener ugc nofollow" target="_blank"> <em class="kz">在Twitter上关注我</em> </a> <em class="kz">。我也是</em><a class="ae mt" href="https://github.com/obsidiandynamics/kafdrop" rel="noopener ugc nofollow" target="_blank"><em class="kz">Kafdrop</em></a><em class="kz">的维护者和</em> <a class="ae mt" href="https://www.apachekafkabook.com/" rel="noopener ugc nofollow" target="_blank"> <em class="kz">有效卡夫卡</em> </a> <em class="kz">的作者。</em></p></div></div>    
</body>
</html>