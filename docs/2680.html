<html>
<head>
<title>Creating a reading progress bar in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中创建阅读进度条</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-reading-progress-bar-in-react-95729b533af8?source=collection_archive---------7-----------------------#2019-07-09">https://itnext.io/creating-a-reading-progress-bar-in-react-95729b533af8?source=collection_archive---------7-----------------------#2019-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5de68261575d2ab4948765100ed84180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwXpqkIhuz3kIBm0byA3NA.png"/></div></div></figure><p id="cb2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">阅读进度条，就像你可以在我的博客上的单篇文章顶部找到的那种，是一个很好的小补充，可以提供读者在当前文章上进展的详细信息。滚动条在这方面并没有真正的意义；它包括你的整个页面，这意味着你的页眉，评论，页脚等。是迹象的一部分。</p><p id="540d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个阅读进度条，告诉你React中当前文章内容的实际进度是非常容易的——特别是使用钩子，这使得我们的组件更小。</p><h1 id="325d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">ReadingProgress组件</h1><p id="a92e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们的<code class="fe lz ma mb mc b">ReadingProgress</code>组件将做以下事情:</p><ul class=""><li id="f9a0" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated">利用钩子，它将负责阅读和设置我们的阅读进度</li><li id="c8ed" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated">利用钩子来处理滚动事件，并正确地更新我们的进度条</li><li id="122c" class="md me iq ka b kb mm kf mn kj mo kn mp kr mq kv mi mj mk ml bi translated">以适当的宽度返回阅读进度条</li></ul><p id="fed3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们直接进入实现:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="7b90" class="mz kx iq mc b gy na nb l nc nd">const ReadingProgress = ({ target }) =&gt; {<br/>  const [readingProgress, setReadingProgress] = useState(0);<br/>    <br/>  return &lt;div className={`reading-progress-bar`} style={{width: `${readingProgress}%` }} /&gt;<br/>};</span></pre><p id="08e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们组件的基础。<code class="fe lz ma mb mc b">readingProgress</code>将作为进度条的宽度(百分比)。我们组件的唯一支柱是<code class="fe lz ma mb mc b">target</code>，它将引用我们post的DOM容器——稍后会详细介绍。</p><p id="de91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先让我们实现我们的监听器，它将更新滚动事件的进度条:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="8587" class="mz kx iq mc b gy na nb l nc nd">const scrollListener = () =&gt; {<br/>    if (!target.current) {<br/>      return;<br/>    }</span><span id="f594" class="mz kx iq mc b gy ne nb l nc nd">const element         = target.current;<br/>    const totalHeight     = element.clientHeight - element.offsetTop;<br/>    const windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;</span><span id="fd11" class="mz kx iq mc b gy ne nb l nc nd">if (windowScrollTop === 0) {<br/>      return setReadingProgress(0);<br/>    }</span><span id="2b54" class="mz kx iq mc b gy ne nb l nc nd">if (windowScrollTop &gt; totalHeight) {<br/>      return setReadingProgress(100);<br/>    }<br/>    <br/>    console.log(windowScrollTop);</span><span id="2d58" class="mz kx iq mc b gy ne nb l nc nd">setReadingProgress((windowScrollTop / totalHeight) * 100);<br/>  };</span></pre><p id="c50e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lz ma mb mc b">windowScrollTop</code>尝试一系列不同的值，为某些浏览器(如Safari)修复<code class="fe lz ma mb mc b">undefined</code>值。</p><p id="1225" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种实现有一个问题:只有当我们滚动<em class="nf">超过</em>我们的目标时，才能达到100%的阅读进度。这不太可能是真的(除非你在读完一行后滚动一行，这会让你很奇怪)——所以我们需要稍微调整一下如何计算我们的阅读进度:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="20c1" class="mz kx iq mc b gy na nb l nc nd">const totalHeight = element.clientHeight - element.offsetTop - window.innerHeight;</span></pre><p id="b9dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这应该会产生一个更准确的结果，当条形图显示结束时。</p><p id="c080" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将把我们的监听器放到一个<code class="fe lz ma mb mc b">useEffect</code>钩子中，这使得我们的整个组件看起来像这样:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="5c91" class="mz kx iq mc b gy na nb l nc nd">const ReadingProgress = ({ target }) =&gt; {<br/>  const [readingProgress, setReadingProgress] = useState(0);<br/>  const scrollListener = () =&gt; {<br/>    if (!target.current) {<br/>      return;<br/>    }</span><span id="4cdb" class="mz kx iq mc b gy ne nb l nc nd">const element         = target.current;<br/>    const totalHeight     = element.clientHeight - element.offsetTop - (window.innerHeight);<br/>    const windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;</span><span id="9f3c" class="mz kx iq mc b gy ne nb l nc nd">if (windowScrollTop === 0) {<br/>      return setReadingProgress(0);<br/>    }</span><span id="47aa" class="mz kx iq mc b gy ne nb l nc nd">if (windowScrollTop &gt; totalHeight) {<br/>      return setReadingProgress(100);<br/>    }</span><span id="6fe6" class="mz kx iq mc b gy ne nb l nc nd">setReadingProgress((windowScrollTop / totalHeight) * 100);<br/>  };<br/>  <br/>  useEffect(() =&gt; {<br/>    window.addEventListener("scroll", scrollListener);<br/>    return () =&gt; window.removeEventListener("scroll", scrollListener);<br/>  });</span><span id="8402" class="mz kx iq mc b gy ne nb l nc nd">return &lt;div className={`reading-progress-bar`} style={{width: `${readingProgress}%`}} /&gt;;<br/>};</span></pre><p id="2393" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从我们的<code class="fe lz ma mb mc b">useEffect</code>钩子返回的函数基本上就是组件被卸载时发生的事情(参见文档中的<a class="ae ng" href="https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup" rel="noopener ugc nofollow" target="_blank">效果和清理</a>)。</p><p id="3bb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但同样重要的是，我们需要在某个地方使用我们的组件。此时，我们需要在目标容器上创建一个ref，并简单地将它传递给我们的<code class="fe lz ma mb mc b">ReadingProgress</code>组件:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="8b80" class="mz kx iq mc b gy na nb l nc nd">function App() {<br/>  const target = React.createRef();<br/>  return (<br/>    &lt;&gt;<br/>      &lt;ReadingProgress target={target} /&gt;<br/>      &lt;div className={`post`} ref={target}&gt;post content&lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="d825" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有关<code class="fe lz ma mb mc b">createRef</code>的更多信息，请参见<a class="ae ng" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="6e53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你的阅读进度条应该工作得很好了——除了你看不到它，因为它没有高度。通过添加一些CSS来解决这个问题:</p><pre class="mr ms mt mu gt mv mc mw mx aw my bi"><span id="1b73" class="mz kx iq mc b gy na nb l nc nd">.reading-progress-bar {<br/>  position: sticky;<br/>  height: 5px;<br/>  top: 0;<br/>  background-color: #ff0000;<br/>}</span></pre><p id="eee7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">搞定！</strong>现在，你的读者不再会迷失在你的帖子的无尽长度中，并且总是知道它什么时候会结束。</p><p id="2e2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要查看一个完整的工作示例，你可以看看这个代码笔:【https://codepen.io/nehalist/pen/agRNYZ<a class="ae ng" href="https://codepen.io/nehalist/pen/agRNYZ" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="bf36" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第三方软件包</h1><p id="0d7d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">有一些第三方软件包可以处理这个问题。据我所知，它们中的大部分都已经过时和/或不再维护——但此时更重要的是:对于一个只有大约30行代码的非常简单的组件，您真的需要第三方依赖吗？嗯，老实说，<em class="nf">我不这么认为</em>。</p><h1 id="79f0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="acd4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">正如你所看到的，在React中实现一个阅读进度条非常容易。多亏了钩子，我们可以将这个组件实现为一个非常小的功能组件，几乎没有开销。</p><p id="c708" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你在实现方面有任何改进，或者认为可以做得更好，请在评论中告诉我！</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="3480" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，请留下👏，关注我上 <a class="ae ng" href="https://twitter.com/nehalist" rel="noopener ugc nofollow" target="_blank"> <em class="nf">推特</em> </a> <em class="nf">并订阅</em> <a class="ae ng" href="https://nehalist.io/newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="nf">我的快讯</em> </a> <em class="nf">。原载于2019年7月9日</em><a class="ae ng" href="https://nehalist.io/creating-a-reading-progress-bar-in-react" rel="noopener ugc nofollow" target="_blank"><em class="nf">https://nehalist . io</em></a><em class="nf">。</em></p></div></div>    
</body>
</html>