<html>
<head>
<title>Building Reactive UIs with LiveData and SavedStateHandle (or equivalent approaches like Rx)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用LiveData和SavedStateHandle(或类似Rx的等效方法)构建反应式ui</h1>
<blockquote>原文：<a href="https://itnext.io/building-reactive-uis-with-livedata-and-savedstatehandle-or-equivalent-approaches-4e934487035f?source=collection_archive---------0-----------------------#2020-10-04">https://itnext.io/building-reactive-uis-with-livedata-and-savedstatehandle-or-equivalent-approaches-4e934487035f?source=collection_archive---------0-----------------------#2020-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/10de6e75002d39478551bf6c4f54bb4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_Rg-QNfjIR0nT5t4I60qA.png"/></div></div></figure><p id="9c65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">也可以关注/r/android_devs </em> 上的 <a class="ae kx" href="https://www.reddit.com/r/android_devs/comments/j55e1x/building_reactive_uis_with_livedata_and/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">相关讨论线程。</em></a></p><p id="ef18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> LiveData </strong>是被误解的猛兽。您经常会看到类似“LiveData不属于存储库”的评论，或者由于RxJava、协程通道或协程流的存在——根本没有理由使用LiveData。</p><p id="f396" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这些库中有一些组件具有重叠的职责(BehaviorRelay、ConflatedBroadcastChannel、MutableStateFlow)，但这并不意味着LiveData是无用的。</p><p id="90eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着Jetpack相对较新的增加，例如<code class="fe ky kz la lb b">liveData {</code>协程生成器，LiveData实际上非常有趣。</p><h1 id="32b6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是LiveData？</h1><p id="d2ad" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">如果你试图找到LiveData的定义，你会发现它是一个“反应性的、可观察的、生命周期感知的数据持有者”。</p><p id="ace1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道它是可以被观察到的，并且我们知道它保存1个数据值，这个数据值将被重新发送给任何新的观察者(对它所做的任何更改也会被发送)，就像任何BehaviorRelay一样。但是它有什么特别之处呢？</p><p id="b3cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于LiveData的生命周期意识，它有自己的“激活状态”(<code class="fe ky kz la lb b">onActive</code>和<code class="fe ky kz la lb b">onInactive</code>)。它让你知道什么时候有一个活动的观察者，什么时候不再有任何活动的观察者。</p><p id="f36d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">诀窍在于，这使它远远不只是“一个日常数据的持有者”。<strong class="ka ir">这允许LiveData</strong><strong class="ka ir">表示<em class="kw">反应数据源</em> </strong>。</p><p id="d863" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我甚至敢打赌，如果Room的<code class="fe ky kz la lb b">ComputableLiveData</code>是一个指示的话，那么<strong class="ka ir"> <em class="kw">这个</em> </strong>就是创建LiveData的最初目的(因为它也依赖于<code class="fe ky kz la lb b">onActive</code>来触发查询结果的刷新，如果对它的一个写操作使表无效的话)。</p><h1 id="8179" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">为什么我需要反应式数据源？</h1><p id="078a" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">如果您的数据或状态会随着时间而变化，那么通知<em class="kw">变化</em>要比轮询可能的变化容易得多(如果我们试图在错误的时间获取数据，可能会错过变化)。</p><p id="5134" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着通过使用“观察者”(或更改监听器)，我们可以在发生更改时接收更新，从而不会与我们的数据或状态“不同步”——特别是如果这些更改是异步进行的(例如，仅当网络可用时)。</p><p id="f610" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去，人们一直使用event bus来实现这一点，但在大多数情况下这实际上是不必要的——特别是如果您的数据层(例如，Room的<code class="fe ky kz la lb b">LiveData&lt;List&lt;T&gt;&gt;</code>)允许这种自动失效事件。</p><h1 id="e8eb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">LiveData有什么帮助？</h1><p id="eac7" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">查看ComputableLiveData的实现:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="8289" class="mn ld iq lb b gy mo mp l mq mr">/* <br/>* Copyright (C) 2017 The Android Open Source Project <br/>* Licensed under the Apache License<br/>*/<br/>mLiveData = <strong class="lb ir">new </strong>LiveData&lt;T&gt;() {<br/>    @Override<br/>    <strong class="lb ir">protected void </strong>onActive() {<br/>        mExecutor.execute(mRefreshRunnable);<br/>    }<br/>};</span><span id="2b14" class="mn ld iq lb b gy ms mp l mq mr"><strong class="lb ir">final </strong>Runnable <strong class="lb ir">mInvalidationRunnable </strong>= <strong class="lb ir">new </strong>Runnable() {<br/>    @MainThread<br/>    @Override<br/>    <strong class="lb ir">public void </strong>run() {<br/>        <strong class="lb ir">boolean </strong>isActive = mLiveData.hasActiveObservers();<br/>        <strong class="lb ir">if </strong>(mInvalid.compareAndSet(<strong class="lb ir">false</strong>, <strong class="lb ir">true</strong>)) {<br/>            <strong class="lb ir">if </strong>(isActive) {<br/>                mExecutor.execute(mRefreshRunnable);<br/>            }<br/>        }<br/>    }</span></pre><p id="4cfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当失效发生时，Room能够强制刷新当前加载的数据。</p><p id="3a8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是房间独有的。我们可以很容易地为Firebase编写自己的代码:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="12b6" class="mn ld iq lb b gy mo mp l mq mr"><strong class="lb ir">private </strong>val <strong class="lb ir">db </strong>= FirebaseDatabase.getInstance().reference<strong class="lb ir"><em class="kw"><br/><br/></em></strong>fun getDeviceData(deviceId: String) : LiveData&lt;Device&gt; {<br/>  <strong class="lb ir">return </strong>object: MutableLiveData&lt;Device&gt;() {<br/>    <strong class="lb ir">private </strong>val mutableLiveData = <strong class="lb ir">this<br/><br/>    private </strong>var query: Query? = <strong class="lb ir">null<br/>    private </strong>val listener: ValueEventListener = <br/>      object: ValueEventListener {<br/>        <strong class="lb ir">override</strong> fun onDataChange(dataSnapshot: DataSnapshot) {<br/>          val device = dataSnapshot.getValue(Device::<strong class="lb ir">class</strong>.java)<br/>          mutableLiveData.value = device<br/>        }<br/><br/>        <strong class="lb ir">override</strong> fun onCancelled(dataError: DatabaseError) {<br/>        }<br/>      }<br/><br/>    <strong class="lb ir">override</strong> fun onActive() {<br/>      query?.removeEventListener(listener)<br/>      val query = <strong class="lb ir">db</strong>.child(deviceId).child(<strong class="lb ir">"config/device"</strong>)<br/>      <strong class="lb ir">this</strong>.query = query<br/>      query.addValueEventListener(listener)<br/>    }<br/><br/>    <strong class="lb ir">override</strong> fun onInactive() {<br/>      query?.removeEventListener(listener)<br/>      query = <strong class="lb ir">null<br/>    </strong>}<br/>  }<br/>}</span></pre><p id="a806" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这种方式，我们能够将任何反应性数据源包装为LiveData。当LiveData处于活动状态时，我们观察数据集的变化，当它不活动时，我们停止观察。</p><h1 id="571f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">用LiveData建模用户界面状态</h1><p id="d57a" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">之前，我已经提到过“数据”或“状态”。我们大部分时间都在谈论数据，但是状态呢？毕竟，通常数据是基于当前状态提取的(想想活动数据过滤器)。</p><p id="5b02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的模型中(例如，一个Jetpack ViewModel，或者类似的模型)，我们可以为值创建字段，当它们被修改时，这些字段会通知我们发生了变化。</p><p id="182a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以用<code class="fe ky kz la lb b">MutableLiveData</code>、<code class="fe ky kz la lb b">ConflatedBroadcastChannel</code>、<code class="fe ky kz la lb b">MutableStateFlow</code>或<code class="fe ky kz la lb b">BehaviorRelay</code>来做这件事——毕竟，从架构的角度来看，它们是同一件事。</p><p id="ecc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象一个电子表格。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/a839599567c0125bc4b4ceb7aa484e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*UPO_DdM3y4L7RRi8TgIn7Q.png"/></div></figure><p id="14af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们有<code class="fe ky kz la lb b">B1</code>、<code class="fe ky kz la lb b">B2</code>、<code class="fe ky kz la lb b">B3</code>、<code class="fe ky kz la lb b">B4</code>、<code class="fe ky kz la lb b">B5</code>作为我们模型的字段。我们有一个到<code class="fe ky kz la lb b">C3</code>的转换，它组合了5个值，并将它们映射到一起相乘。</p><p id="15cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在想象一下Kotlin中相同的代码，除了同时处理进程死亡(当然)。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="9e43" class="mn ld iq lb b gy mo mp l mq mr"><strong class="lb ir">private val b1 </strong>= <strong class="lb ir">savedStateHandle</strong>.getLiveData(<strong class="lb ir">"b1"</strong>, 1)<br/><strong class="lb ir">private val b2 </strong>= <strong class="lb ir">savedStateHandle</strong>.getLiveData(<strong class="lb ir">"b2"</strong>, 2)<br/><strong class="lb ir">private val b3 </strong>= <strong class="lb ir">savedStateHandle</strong>.getLiveData(<strong class="lb ir">"b3"</strong>, 3)<br/><strong class="lb ir">private val b4 </strong>= <strong class="lb ir">savedStateHandle</strong>.getLiveData(<strong class="lb ir">"b4"</strong>, 4)<br/><strong class="lb ir">private val b5 </strong>= <strong class="lb ir">savedStateHandle</strong>.getLiveData(<strong class="lb ir">"b5"</strong>, 5)<br/><br/><strong class="lb ir">private val c3 </strong>= <em class="kw">combineTupleNonNull</em>(<strong class="lb ir">b1</strong>, <strong class="lb ir">b2</strong>, <strong class="lb ir">b3</strong>, <strong class="lb ir">b4</strong>, <strong class="lb ir">b5</strong>)<br/>                    .<em class="kw">map </em><strong class="lb ir">{ </strong>(b1, b2, b3, b4, b5) <strong class="lb ir">-&gt;<br/>                        </strong>b1 * b2 * b3 * b4 * b5<br/>                    <strong class="lb ir">}</strong></span></pre><p id="e1f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<code class="fe ky kz la lb b">combineTupleNonNull</code>是来自<a class="ae kx" href="https://github.com/Zhuinden/livedata-combinetuple-kt" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="kw">LiveData-combine tuple-Kt</em></strong></a>的帮助器函数。<code class="fe ky kz la lb b">combineTuple</code>和<code class="fe ky kz la lb b">combineTupleNonNull</code>帮助器利用<code class="fe ky kz la lb b">MediatorLiveData</code>，这是LiveData的组成元素，允许描述任意操作符。这也是引擎盖下<code class="fe ky kz la lb b">map</code>和<code class="fe ky kz la lb b">switchMap</code>的基础。除了内部操作符，你通常不需要在你的代码中把<code class="fe ky kz la lb b">MediatorLiveData</code>看作<code class="fe ky kz la lb b">MediatorLiveData</code>，只有当它的转换完成后才作为<code class="fe ky kz la lb b">LiveData</code>公开。</p><p id="a5cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事后，现在我们能做的</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="18ab" class="mn ld iq lb b gy mo mp l mq mr"><strong class="lb ir">viewModel.c3</strong>.observe(viewLifecycleOwner) { c3 -&gt;<br/>    println("$c3")<br/>}</span></pre><p id="8bd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们可以做</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="556e" class="mn ld iq lb b gy mo mp l mq mr"><strong class="lb ir">b1</strong>.value = 5</span></pre><p id="fc75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当它改变时，我们将立即获得最新的值:接收基于我们的状态的组合值，通过包装在可观察值容器中的不可变值建模。就像Excel一样！享受玻璃钢！</p><p id="da28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们甚至不需要使用<code class="fe ky kz la lb b">copy</code>😏</p><p id="b8d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">警告:</strong> <code class="fe ky kz la lb b"><strong class="ka ir">savedStateHandle.getLiveData("key", initialValue)</strong></code> <strong class="ka ir">有一个bug，即初始值没有持久化到Bundle中。要解决这个问题，您可以做:</strong></p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="c2c0" class="mn ld iq lb b gy mo mp l mq mr">savedStateHandle.getLiveData("key", <strong class="lb ir">initialValue</strong>).apply { <br/>    <strong class="lb ir">if</strong>(<strong class="lb ir">value</strong> === <strong class="lb ir">initialValue</strong>) {<br/>        <strong class="lb ir">value</strong> = <strong class="lb ir">initialValue </strong><em class="kw">// call setValue()<br/>    </em>}<br/>}</span></pre><h1 id="badd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用反应状态建模进行验证</h1><p id="ed61" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">当我们的州使用多个LiveDatas时，我们获得了简化验证的额外好处。</p><p id="6c5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们可以组合任意数量的实时数据，我们可以将输入映射到条件，然后以反应的方式评估这些条件是<code class="fe ky kz la lb b">true</code>还是<code class="fe ky kz la lb b">false</code>。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="7c9b" class="mn ld iq lb b gy mo mp l mq mr"><strong class="lb ir">val isLoginEnabled </strong>= <em class="kw">validateBy</em>(<br/>    <strong class="lb ir">username</strong>.<em class="kw">map </em><strong class="lb ir">{ it</strong>.<em class="kw">isNotBlank</em>() <strong class="lb ir">}</strong>, <br/>    <strong class="lb ir">password</strong>.<em class="kw">map </em><strong class="lb ir">{ it</strong>.<em class="kw">isNotBlank</em>() <strong class="lb ir">}<br/></strong>)</span></pre><p id="937c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个代码片段中，我使用了助手函数<a class="ae kx" href="https://github.com/Zhuinden/livedata-validateby-kt/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="kw">LiveData-validate by-Kt</em></strong></a>。不涉及魔法，只是组合然后映射进来的<code class="fe ky kz la lb b">LiveData&lt;Boolean&gt;</code>看看它们是否都是真的。</p><p id="5f1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以大大简化输入验证。</p><h1 id="958c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用LiveData和协同例程进行异步数据加载</h1><p id="5d69" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">当然，状态本身比数据更容易管理——毕竟，数据是异步加载的。</p><p id="ac53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，管理这个场景并不困难，因为LiveData已经随<code class="fe ky kz la lb b">Transformations.switchMap</code>一起提供了。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="8bc7" class="mn ld iq lb b gy mo mp l mq mr"><strong class="lb ir">private val </strong>selectedUserId<strong class="lb ir"> </strong>= <strong class="lb ir">savedStateHandle</strong>.getLiveData(<strong class="lb ir">"selectedUserId"</strong>)</span><span id="48f7" class="mn ld iq lb b gy ms mp l mq mr"><strong class="lb ir">private val</strong> selectedUser = selectedUserId.<strong class="lb ir"><em class="kw">switchMap</em></strong> { userId -&gt;<br/>    dao.findUserById(userId)<br/>}</span></pre><p id="e176" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这本身就已经确保了无论何时所选的用户ID发生变化，最终都会加载并提供正确的数据。</p><p id="1430" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在某些情况下，可能需要执行多个后台操作来获取数据，而不是直接读取作为LiveData公开的数据源。在这种情况下，<code class="fe ky kz la lb b">liveData {</code>协程构建器会有所帮助，因为它可以在后台线程上运行任何挂起函数，将结果发送到UI线程，但确保使用<code class="fe ky kz la lb b">emit</code>和<code class="fe ky kz la lb b">emitSource</code>正确取消后台操作(或忽略其结果)。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="a5ac" class="mn ld iq lb b gy mo mp l mq mr"><strong class="lb ir">private val </strong>someValue<strong class="lb ir"> </strong>= <strong class="lb ir">savedStateHandle</strong>.getLiveData(<strong class="lb ir">"someValue"</strong>)</span><span id="1b59" class="mn ld iq lb b gy ms mp l mq mr"><strong class="lb ir">private val</strong> someData = someValue.<strong class="lb ir"><em class="kw">switchMap</em></strong> { value -&gt;<br/>    <strong class="lb ir"><em class="kw">liveData</em></strong> {<br/>        val someFetchedValue = suspendingCall(value)<br/>        <strong class="lb ir"><em class="kw">emit</em></strong>(someFetchedValue) <em class="kw">// one-off async fetch</em><br/>    }<br/>}</span></pre><p id="1094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在更复杂的情况下，我们甚至可以使用<code class="fe ky kz la lb b">emitSource</code>来“连接到一个新的LiveData包装的反应式数据源”。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="f283" class="mn ld iq lb b gy mo mp l mq mr"><strong class="lb ir">private val </strong>someValue<strong class="lb ir"> </strong>= <strong class="lb ir">savedStateHandle</strong>.getLiveData(<strong class="lb ir">"someValue"</strong>)</span><span id="0bd6" class="mn ld iq lb b gy ms mp l mq mr"><strong class="lb ir">private val</strong> someData = someValue.switchMap { value -&gt;<br/>    <strong class="lb ir"><em class="kw">liveData</em></strong> {<br/>        val profile = getProfile(value)<em class="kw"> // suspending call</em><br/>        <strong class="lb ir"><em class="kw">emitSource</em></strong>(dao.getDataWithChanges(profile.username))<br/>    }<br/>}</span></pre><p id="4745" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的是，当不再观察到LiveData时(<code class="fe ky kz la lb b">onInactive</code>),<code class="fe ky kz la lb b">liveData {</code>协程构建器会超时取消其中的块，默认值为5秒。</p><p id="b257" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，通过使用由<code class="fe ky kz la lb b">emitSource</code>返回的<code class="fe ky kz la lb b">DisposableHandle</code>，可以在<code class="fe ky kz la lb b">liveData {</code>块内创建更复杂的逻辑，这允许交换到<code class="fe ky kz la lb b">liveData {</code>块内的“不同订阅”。这可以用来创建类似于<code class="fe ky kz la lb b"><a class="ae kx" href="https://github.com/android/architecture-components-samples/blob/b553addbd2b4e233094bb7d309dd9a78d606e1a5/GithubBrowserSample/app/src/main/java/com/android/example/github/repository/NetworkBoundResource.kt#L39-L126" rel="noopener ugc nofollow" target="_blank">NetworkBoundResource</a></code>的东西，除了在协程的背面。</p><p id="3cf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(虽然我个人建议<em class="kw">不要</em>将“本地数据源读取”与“网络数据源读取”结合起来，因为本地数据源通常不会失败，而另一方面，网络连接是不可靠的——这样，我们可以只担心LiveData中的“成功案例”,而我们可以将<em class="kw">错误</em>保留在单独的流中)。</p><h1 id="3c2e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="1db1" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">希望本文有助于寻找如何反应性地公开我们的数据的方法，这样我们就不需要担心手动缓存失效或使用EventBus在正确的时间手动分派事件。而只是“订阅数据，最终接收数据”。</p><p id="7805" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这已经可以通过LiveData或RxJava实现了(尽管本质上，这意味着即使是常规的Observer模式也可以实现)。</p><p id="aa28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有关LiveData协同程序构建器及其与协同程序、流和其他LiveData的交互的更多信息，请参见2019年Android Dev Summit的<a class="ae kx" href="https://www.youtube.com/watch?v=B8ppnjGPAGE" rel="noopener ugc nofollow" target="_blank">“LiveData with Coroutines and Flow”演讲。</a></p><p id="a512" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于想独占使用Flow的，一般可以使用<code class="fe ky kz la lb b">Flow</code>，然后依靠<code class="fe ky kz la lb b">asLiveData()</code>获得最新项的预期缓存行为。例如，这甚至允许流与<code class="fe ky kz la lb b">emitSource</code>互操作。</p><p id="c497" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至于<code class="fe ky kz la lb b">MutableStateFlow</code>如何改变事情，我们将拭目以待，尽管这不会使<code class="fe ky kz la lb b">SavedStateHandle.getLiveData()</code>消失，这是<a class="ae kx" href="https://github.com/Zhuinden/jetpack-navigation-ftue-sample/blob/hilt/app/src/main/java/com/zhuinden/jetpacknavigationdaggersavedstatehandleftueexperiment/features/registration/RegistrationViewModel.kt#L51-L52" rel="noopener ugc nofollow" target="_blank">当前Jetpack-given的方式</a>来简化创建反应式ui，并在进程死亡时进行适当的状态恢复。</p><p id="2ddd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前面提到的助手也可以在Rx和Flow中找到:</p><ul class=""><li id="d1fc" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated"><a class="ae kx" href="https://github.com/Zhuinden/rx-combinetuple-kt" rel="noopener ugc nofollow" target="_blank"> RxCombineTupleKt </a></li><li id="0ffb" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated"><a class="ae kx" href="https://github.com/Zhuinden/rx-validateby-kt" rel="noopener ugc nofollow" target="_blank"> RxValidateByKt </a></li><li id="0dcb" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated"><a class="ae kx" href="https://github.com/Zhuinden/livedata-combinetuple-kt" rel="noopener ugc nofollow" target="_blank"> LiveDataCombineTupleKt </a></li><li id="e26c" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated"><a class="ae kx" href="https://github.com/Zhuinden/livedata-validateby-kt" rel="noopener ugc nofollow" target="_blank"> LiveDataValidateByKt </a></li><li id="73b2" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated"><a class="ae kx" href="https://github.com/Zhuinden/flow-combinetuple-kt" rel="noopener ugc nofollow" target="_blank">流量组合函数</a></li><li id="7720" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated"><a class="ae kx" href="https://github.com/Zhuinden/flow-validateby-kt" rel="noopener ugc nofollow" target="_blank"> FlowValidateByKt </a></li></ul><p id="c0a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您被困在Java上，您仍然可以使用:</p><ul class=""><li id="8e01" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated"><a class="ae kx" href="https://github.com/Zhuinden/livedata-combineutil-java" rel="noopener ugc nofollow" target="_blank">LiveDataCombineUtilJava</a></li></ul><p id="61d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">更多相关讨论，请查看/r/android_devs </em>  <em class="kw">的</em> <a class="ae kx" href="https://www.reddit.com/r/android_devs/comments/j55e1x/building_reactive_uis_with_livedata_and/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">讨论线程。</em></a></p></div></div>    
</body>
</html>