<html>
<head>
<title>MVVM and Blazor : Components and StateHasChanged()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVVM和布拉索:组件和状态已经改变()</h1>
<blockquote>原文：<a href="https://itnext.io/mvvm-and-blazor-components-and-statehaschanged-a31be365638b?source=collection_archive---------0-----------------------#2019-04-26">https://itnext.io/mvvm-and-blazor-components-and-statehaschanged-a31be365638b?source=collection_archive---------0-----------------------#2019-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8686cfd665f32462b6a7ba17426b12e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-wx9Fsh2nXJ6qAiXqz3KA.png"/></div></div></figure><p id="fd6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我撰写的关于在客户端Blazor中实现模型视图视图模型模式的一种方法的系列文章中的第六篇。如果您想从头开始阅读本系列的第一篇文章，请点击此处:</p><div class="kw kx gp gr ky kz"><a rel="noopener  ugc nofollow" target="_blank" href="/a-simple-mvvm-implementation-in-client-side-blazor-8c875c365435"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">客户端Blazor中一个简单的MVVM实现。</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">本文是我将介绍我目前计划如何创建Blazor客户端的系列文章的第一篇…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">itnext.io</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><p id="b08a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本系列的所有代码都存储在GitHub上的。我将在本文开头使用的代码是ArticleFive分支和4.5版本。本文末尾的代码将是ArticleSix和4.6版本。</p><h1 id="4841" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">组件之间是如何通信的？</h1><p id="d989" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">正如MVVM允许我们将视图模型和模型分解成多个小的可重用的类一样，Blazor允许我们将视图分解成多个小的可重用的组件。在本文中，我们将讨论组件在页面中的行为，以及使用组件时可能遇到的潜在显示问题。</p><p id="6109" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将扩展我们在前一篇文章中开始构建的购物车。我们将为购物车添加一些交互性，允许用户调出一个库存目录，并将该目录中的商品添加到购物车中。我们将把购物车重构为一个单独的组件，然后作为一个组件添加到库存目录中。完成后，我们将有一个包含两个子视图的父视图，这将让我们检查Blazor组件的行为。</p><p id="e91a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还将借此机会讨论Blazor如何决定何时将更新呈现给View。我们将回顾一下<code class="fe mr ms mt mu b">StageHasChanged()</code>方法以及您想要手动调用它的时间。</p><h1 id="6e48" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">是时候重构我们的购物车了</h1><p id="3c6e" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">为了达到我们测试组件行为的目的，我们需要做一些改变。我们希望有一个库存的产品，我们可以拉，以及购物车，我们把这些项目。为了正确识别我们正在处理的项目，我们不能坚持使用我们在上一篇文章中使用的<code class="fe mr ms mt mu b">List&lt;InventoryItem&gt;</code>,所以我们要改为一个<code class="fe mr ms mt mu b">Dictionary&lt;int, InventoryItem&gt;</code>,它将给每个项目一个唯一的标识符。我们将创建两个模型类<code class="fe mr ms mt mu b">Inventory_Model.cs</code>来表示我们的可用库存，创建<code class="fe mr ms mt mu b">ShoppingCart_Model.cs</code>来表示我们购物车中当前的商品。我们坚持使用<code class="fe mr ms mt mu b">_Model</code>命名，以利用我们在第四篇文章中构建的模型的自动服务注册。下面是我们的库存模型和界面:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="02df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们只是声明我们的库存，并使用构造函数来设置可用的项目和数量以及价格。我们现在有一个公共方法，让我们检查一个项目是否有请求数量的可用项目。</p><p id="81fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">购物车模型也非常简单。下面列出的代码还存储了购物车中商品的字典，并有一个添加商品的方法和一个删除商品的方法。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="709f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加这两个模型以及对字典的更改几乎完全重写了我们的购物车视图模型。请看看下面的代码:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3c89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经更新了构造函数，注入了两个新的模型类。我们还改变了向购物车添加商品的方式，使用商品Id并在模型中调用<code class="fe mr ms mt mu b">AddItem()</code>。我们有一个全新的方法<code class="fe mr ms mt mu b">UpdateCart()</code>,它使用购物车的最新内容(包括总数量和价格)来更新视图模型。最后，我们将<code class="fe mr ms mt mu b">DisplayPrice()</code>移出作为一个扩展方法，这样我们就可以在名称空间的任何地方使用它，并提高视图中代码绑定的可读性。</p><p id="9794" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们必须为视图更新类背后的代码，以便像我们在上一篇文章中所做的那样填充我们的起始购物车。新的代码如下所示:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="08a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以简单地通过Id添加它们，然后在完成后调用<code class="fe mr ms mt mu b">UpdateCart()</code>。</p><h1 id="0a51" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">添加第一个组件</h1><p id="48ec" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">对于购物车组件，我们将把购物车的内容移到它自己的组件中。在组件文件夹中创建一个新的视图<code class="fe mr ms mt mu b">CartContents.razor</code>。给它一个ViewModels名称空间的<code class="fe mr ms mt mu b">using</code>语句，并将整个<code class="fe mr ms mt mu b">&lt;table&gt;</code>从我们的父模型移动到组件中。对于这个组件，我们将演示如何将父视图模型传递给组件，因此我们需要添加一个为<code class="fe mr ms mt mu b">IShoppingCartModel</code>提供参数的<code class="fe mr ms mt mu b">functions{}</code>块。我们还需要在绑定中进行语法修改，以使用我们的<code class="fe mr ms mt mu b">DisplayPrice()</code>扩展方法。有了所有这些，我们的组件将如下所示:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e87c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的父视图现在几乎是空的。要使用组件，我们只需将它与绑定一起添加，以将父视图模型向下传递给组件:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="012e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成所有这些更改后，我们可以启动我们的应用程序，并看到我们的购物车显示再次工作，并显示我们期望的样本数据。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/d53d855eca6f39ae7b3fc8a28de90775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RexmhU6vYASkGpawcusdwA.png"/></div></div></figure><h1 id="af4f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">在我们添加另一个视图模型之前</h1><p id="a5df" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">对于库存目录组件，我将从父组件传入一个子视图模型。因为我将来肯定会创建额外的视图模型，所以我会更新我们的<code class="fe mr ms mt mu b">Startup.cs</code>来自动注册我的新视图模型。我将在<code class="fe mr ms mt mu b">ConfigureServices()</code>中添加一行代码来获取任何名称包含<code class="fe mr ms mt mu b">_ViewModel</code>的类，并在启动时自动注册这些类。更新后的代码块现在如下所示:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="d8f8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">从库存中选择项目的组件</h1><p id="3f66" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">现在我们可以自动注册任何新的视图模型，让我们利用这一点，在我们的视图模型文件夹中创建一个新的类<code class="fe mr ms mt mu b">InventoryCatalog_ViewModel.cs</code>。该类的内容遵循我们在本系列文章中介绍的MVVM实现。我们将为这个视图模型需要公开的任何内容创建公共属性和方法，然后创建一个包含所有这些公共成员的公共接口。</p><p id="2b06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目录本身将是一个带有附加到数据行的<code class="fe mr ms mt mu b">onclick</code>方法的表。最初显示组件时，不会呈现表格，只会显示或隐藏目录表格的单个按钮。此按钮通过委托调用父视图模型，并填充或清空目录表。一旦表中的一个项目被选中，将有一个按钮将选中的项目添加到我们的购物车(通过委托返回到父视图模型)和一个按钮取消选择。</p><p id="5e1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到黑暗时代，当我学习编程时，我们必须首先声明委托的定义，然后声明委托，然后给它们分配方法。英寸Net Framework 2.0增加了泛型委托<code class="fe mr ms mt mu b">Action&lt;T&gt;</code>，它允许我们创建不返回值的泛型委托，并为它们分配一个方法。</p><p id="ef20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在我们的视图模型中使用这个通用接口两次，并将其拉至接口。您可以在下面看到，我们有一个不带参数的方法和一个带<code class="fe mr ms mt mu b">int</code>的方法:</p><pre class="mv mw mx my gt nc mu nd ne aw nf bi"><span id="5b3d" class="ng lp iq mu b gy nh ni l nj nk">public Action AddItemsButtonClickDelegate { get; set; }</span><span id="139f" class="ng lp iq mu b gy nl ni l nj nk">public Action&lt;int&gt; AddSelectedItemToCartDelegate { get; set; }</span></pre><p id="5720" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的catalog ViewModel类和接口的代码如下所示:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a76b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建视图模型后，我们可以将组件放在一起，并将其传递给。在组件文件夹中创建一个新的razor视图<code class="fe mr ms mt mu b">InventoryCatalog.razor</code>。这是另一个相对简单的视图，唯一值得注意的是它有两个条件渲染块。如果<code class="fe mr ms mt mu b">CatalogItems</code>中没有项目，则不呈现目录表，如果没有<code class="fe mr ms mt mu b">SelectedItem</code>，则不显示添加和取消按钮。新组件的完整代码如下所示:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在它已经创建好了，我们只需要将它添加到我们的视图和视图模型中。我们可以给<code class="fe mr ms mt mu b">ShoppingCart.razor</code>添加一行</p><pre class="mv mw mx my gt nc mu nd ne aw nf bi"><span id="09f7" class="ng lp iq mu b gy nh ni l nj nk">&lt;BlazorMVVM.Client.Components.InventoryCatalog ViewModel="@ViewModel.InventoryCatalogViewModel" /&gt;</span></pre><p id="c617" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在ViewModel中，我们需要添加一些常用的组件。我们需要一个私有变量、一个公共属性和构造函数注入。我们还将添加两个新方法<code class="fe mr ms mt mu b">AddItemsButtonClick()</code>和<code class="fe mr ms mt mu b">CheckInventoryAndAddItemToCart()</code>，并将它们分配给子视图模型中的代理。已经添加的每个公共成员也需要被拉至接口。在所有这些添加之后，我们的类和接口现在看起来像这样:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="70b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们现在运行我们的应用程序并单击Display/Hide按钮，我们将看到我们的库存目录显示出来。单击目录中的一个项目，我们将看到添加和取消按钮。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/3944d8e9b82d4619408f7f353edc8b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whvRV1HUUnlCcVP4EWCNjg.png"/></div></div></figure><h1 id="b6ff" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">运行中的组件</h1><p id="2f8b" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">现在，我们已经构建了两个组件，并在页面中工作，是时候看看我们的劳动成果了。单击库存目录中的任何商品，然后单击“添加到购物车”按钮。当我们这样做的时候，我们可以看看我们的购物车，看到它是…没有更新。到底是怎么回事？我们的代码有问题吗？我们在最新的Blazor预览版中发现了一个bug吗？答案是，这种意料之外的行为实际上是意料之中的行为。为了理解为什么我们需要讨论一下Blazor如何更新Razor组件。</p><p id="5894" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个Razor组件(别忘了页面也是组件)都被编译成一个渲染树。渲染树是一个编译好的C#类，它是从我们的视图中自动生成的。如果我们看一下为我们的<code class="fe mr ms mt mu b">InventoryCatalog.razor</code>生成的代码，这个类的开头看起来像这样:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8bfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您将上面的代码与我们的视图进行比较，就很容易匹配。您还可以看到它在何处根据项目计数有条件地决定是否添加catalog items表的呈现。</p><p id="1232" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当事情发生变化时，Blazor用来“神奇地”更新显示的过程由几个步骤组成。第一步是最重要的一步。每当一个组件处理一个事件时，它就会触发该组件被呈现。一旦渲染被触发，Blazor就会在渲染树上做一个diff来查看发生了什么变化，并更新DOM，这样我们就可以在屏幕上看到我们的变化。</p><p id="3889" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们从目录中添加商品时，为什么我们的购物车没有更新？答案是我们的<code class="fe mr ms mt mu b">onclick()</code>事件是由我们的<code class="fe mr ms mt mu b">InventoryCatalor.razor</code>组件处理的。事件被处理，组件随后呈现自身。对我们来说，问题是我们的<code class="fe mr ms mt mu b">CartContents.razor</code>组件也被更新了，但是它在更新后没有被渲染。通过在代码中添加一些调试语句，我们可以观察到这种行为是如何发生的。在所有三个视图中添加下面的覆盖方法(为每个视图使用正确的名称)。</p><pre class="mv mw mx my gt nc mu nd ne aw nf bi"><span id="259f" class="ng lp iq mu b gy nh ni l nj nk">protected override void OnAfterRender()<br/>{<br/>   base.OnAfterRender();<br/>   Console.WriteLine("CartContents View OnAfterRender");<br/>}</span></pre><p id="766c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这些代码并使用浏览器调试控制台，我们可以看到，只要导航到页面，所有三个视图都会呈现出来。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/77f23d2f4abdb2a6953053d46fe72b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EFT2Wc3Prh8QcRRW1Q4e1A.png"/></div></div></figure><p id="b0e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们对目录采取的任何操作只会导致目录呈现。您可以在控制台窗口中看到，父视图和购物车视图从未被重绘。我们如何避免出现这样的情况:我们更新了视图模型，但是用户看不到视图中反映的变化？有许多选择。</p><h1 id="06dd" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">选项1:不使用组件</h1><p id="231c" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我觉得这是一个可怕的建议，我不会给任何人，但它会工作。如果每个页面都是一个组件，那么每个被处理的事件都会导致整个页面被渲染。</p><h1 id="f9dc" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">选项2:实现INotifyPropertyChanged</h1><p id="fb85" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">很多人都非常熟悉这个选项。您在ViewModel上实现了这个接口，它实际上包括向您的类添加一个事件:</p><pre class="mv mw mx my gt nc mu nd ne aw nf bi"><span id="2879" class="ng lp iq mu b gy nh ni l nj nk">public event PropertyChangedEventHandler PropertyChanged;</span></pre><p id="5abc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您将进入您的公共属性的设置器，并添加额外的代码来调用事件(如果处理程序不为空)。对于<code class="fe mr ms mt mu b">Cart</code>,代码如下所示:</p><pre class="mv mw mx my gt nc mu nd ne aw nf bi"><span id="6e98" class="ng lp iq mu b gy nh ni l nj nk">PropertyChanged?.Invoke(this, <br/>   new PropertyChangedEventArgs(nameof(Cart)));</span></pre><p id="b2d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">连接之后，我们只需要添加一个事件处理程序。在<code class="fe mr ms mt mu b">Oninit()</code>方法的<code class="fe mr ms mt mu b">ShoppingCart.razor.cs</code>中添加这行代码:</p><pre class="mv mw mx my gt nc mu nd ne aw nf bi"><span id="cf4e" class="ng lp iq mu b gy nh ni l nj nk">ViewModel.PropertyChanged += (o, e) =&gt; StateHasChanged();</span></pre><p id="44cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mr ms mt mu b">StateHasChanged()</code>是告诉视图需要重新渲染的方法。很像生命周期方法，它是特定于视图的，所以它只在<code class="fe mr ms mt mu b">functions{}</code>块或我们后面的代码中可用。</p><p id="560f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们现在启动实现了<code class="fe mr ms mt mu b">INotifyPropertyChanged</code>的应用程序，我们会看到，从我们的目录中选择和添加一个商品会导致我们的购物车实际上更新了正确的商品、数量和价格。</p><p id="b90a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mr ms mt mu b">INotifyProperyChanged</code>的唯一问题是我们必须注意它实际上在做什么。如果有人对它很熟悉，并且第一次看Blazor，他们可能会认为在ViewModel中更新<code class="fe mr ms mt mu b">Cart</code>只是更新了一个绑定，并且在DOM中做了一个简单的改变。实际发生的是<code class="fe mr ms mt mu b">StateHasChanged()</code>被设置在组件上，它为自己以及所有的子组件(如果有的话)运行完整的渲染过程。这种差异可能不会有任何实际影响，也不会导致任何错误，但理解正在发生的事情是有好处的。</p><h1 id="0214" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">选项3:使用委托</h1><p id="baf8" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这与<code class="fe mr ms mt mu b">INotifyProperyChanged</code>的工作方式没有太大区别，但执行方式略有不同。如果Blazor只在事件被处理后才呈现组件，并且总是呈现完整的组件及其子组件，为什么我们需要用事件调用填充我们的属性设置器呢？也许我们应该把它集中到一个单一的委托中，我们的视图模型可以在任何需要的时候调用它。</p><p id="4769" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将再次使用<code class="fe mr ms mt mu b">Action</code>通用委托。我们将在我们的<code class="fe mr ms mt mu b">ShoppingCartViewModel.cs</code>中为该代表添加一个公共属性</p><pre class="mv mw mx my gt nc mu nd ne aw nf bi"><span id="cc95" class="ng lp iq mu b gy nh ni l nj nk">public Action StateHasChangedDelegate { get; set; }</span></pre><p id="081c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">把它拉到界面上。现在我们可以在视图中的<code class="fe mr ms mt mu b">OnInit()</code>中分配这个委托，就像我们之前对事件处理程序所做的那样:</p><pre class="mv mw mx my gt nc mu nd ne aw nf bi"><span id="2569" class="ng lp iq mu b gy nh ni l nj nk">ViewModel.StateHasChangedDelegate = StateHasChanged;</span></pre><p id="18fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，要将我们的新委托付诸实施，请转到我们的ViewModel中的<code class="fe mr ms mt mu b">UpdateCart()</code>方法，并在该方法的末尾添加一条语句，以便在委托不为空时调用我们的委托:</p><pre class="mv mw mx my gt nc mu nd ne aw nf bi"><span id="2411" class="ng lp iq mu b gy nh ni l nj nk">StateHasChangedDelegate?.Invoke();</span></pre><p id="1b0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的示例再次正确更新。无论我们使用<code class="fe mr ms mt mu b">INotifyPropertyChanged</code>还是代表，在这一点上可能会归结为个人偏好，因为它们在功能上没有太大的不同。</p><h1 id="bd6d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">选项4:不要在家里(或工作场所)尝试这种方法</h1><p id="0d49" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">另一个可行的方法是将视图的渲染链接在一起，但我目前没有这样做。在我们当前的示例代码中，我可以轻松地使用委托方法调用，让<code class="fe mr ms mt mu b">InventoryCatalog.razor</code>中的<code class="fe mr ms mt mu b">OnAfterRender()</code>为<code class="fe mr ms mt mu b">CartContents.razor</code>调用<code class="fe mr ms mt mu b">StateHasChanged()</code>。这将工作，并将导致购物车正确更新时，我从目录中添加项目。如果有用，为什么我建议不要这么做？如果我处理的下一个项目是在购物车中添加或删除项目时调整库存，会发生什么情况？为了使我的更新生效，我将添加一个新的委托，名为<code class="fe mr ms mt mu b">StateHasChanged()</code>，向另一个方向移动。<code class="fe mr ms mt mu b">OnAfterRender()</code>在每次渲染后触发，所以如果我有两个方向的代理，A将导致B渲染，这将导致A渲染，我现在已经创建了我的第一个Blazor无限循环。还要记住，渲染父组件也会渲染所有子组件，因此以这种方式设置的从子组件到父组件的单个委托也会导致无限循环。</p><p id="62e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果Blazor有一些额外的生命周期方法，我们可以像OnBeforeRender或OnStateHasChanged那样挂钩，可能会有一种方式在组件之间进行链式更新。仍然有可能有人会想出一种创新的方法来做这件事，或者Blazor的新发展将使它成为可能。</p><h1 id="ed6a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">选项5: EventCallback(使用这个)</h1><p id="4776" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">英寸增加了网芯3预告3 <code class="fe mr ms mt mu b">EventCallback</code>和<code class="fe mr ms mt mu b">EventCallback&lt;T&gt;</code>。这个新委托的工作方式与<code class="fe mr ms mt mu b">Action</code>非常相似，只是发生了一些编译器魔术，使得不再需要调用<code class="fe mr ms mt mu b">StateHasChanged</code>。使用这个特性，我们现在可以让一个子组件触发父组件上的rendertree diff，并让我们的应用程序正常工作。</p><p id="c43d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这一点，我们将向我们的<code class="fe mr ms mt mu b">InventoryCatalog.razor</code>添加一个新参数:</p><pre class="mv mw mx my gt nc mu nd ne aw nf bi"><span id="2138" class="ng lp iq mu b gy nh ni l nj nk">[Parameter]<br/>EventCallback&lt;int&gt; AddSelectedItemToCart { get; set; }</span></pre><p id="e326" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了利用这一点，我们现在将从父视图向目录组件传递一个公共方法。返回到<code class="fe mr ms mt mu b">ShoppingCart.razor</code>并更新它，将<code class="fe mr ms mt mu b">CheckInventoryAndAddItemToCart()</code>方法传递给组件。该方法也需要被拉至ViewModel接口；以前我们通过委托访问它，但现在我们将通过<code class="fe mr ms mt mu b">EventCallback</code>直接访问它。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ef75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成这项工作的最后一步是更新我们的组件，使用<code class="fe mr ms mt mu b">EventCallback</code>代替委托。返回<code class="fe mr ms mt mu b">InventoryCatalog.razor</code>并按如下方式更新表格:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="35da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe mr ms mt mu b">onlick</code>属性现在使用<code class="fe mr ms mt mu b">EventCallback</code>的<code class="fe mr ms mt mu b">InvokeAsync()</code>方法回调ViewModel。如果我们现在运行我们的应用程序，我们可以看到从目录中添加商品正确地更新了购物车，而没有利用我们在视图模型中创建的委托来调用<code class="fe mr ms mt mu b">StateHasChanged()</code>。我们现在可以删除不需要的属性和委托。</p><h1 id="1c3a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">最后</h1><p id="0a49" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">在本文中，我们对购物车进行了重构并添加了一些功能，以便更好地理解Blazor中组件和组件呈现的工作方式。我们回顾了我们的组件实际刷新和不刷新显示的时间，以及确保它们在我们需要时更新的策略。最后，我们看到<code class="fe mr ms mt mu b">EventCallback</code>提供了一种在使用子组件时刷新视图的机制，而无需实现事件或委托。</p><p id="969e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想讨论这篇文章或者Blazor，你可以在Twitter @LouisHendricks上找到我，或者加入Gitter上aspnet/Blazor房间的社区。</p><p id="34ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本系列的下一篇文章现已发表。这篇新文章介绍了如何使用客户端Blazor和MVVM构建一个向导。</p><div class="kw kx gp gr ky kz"><a href="https://medium.com/@haywireiv/building-a-wizard-in-blazor-with-components-and-mvvm-96219a7b221c" rel="noopener follow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">用组件和MVVM在Blazor中构建向导。</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">这是关于在客户端Blazor中实现MVVM的一种方法的系列文章中的第七篇。如果你愿意…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">medium.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div></div></div>    
</body>
</html>