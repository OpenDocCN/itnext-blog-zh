<html>
<head>
<title>Load balancing goroutines in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的负载平衡goroutines</h1>
<blockquote>原文：<a href="https://itnext.io/load-balancing-goroutines-in-go-57e0896c7f86?source=collection_archive---------3-----------------------#2020-01-03">https://itnext.io/load-balancing-goroutines-in-go-57e0896c7f86?source=collection_archive---------3-----------------------#2020-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/30fa4622e8ff78700d47e17602098384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*le6J6RU91y3NPv6DlHDhBA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图为<a class="ae kf" href="https://unsplash.com/@loicleray?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">洛伊克·勒雷</a>在<a class="ae kf" href="https://unsplash.com/s/photos/balance?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="c2d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Golang以其对使用<code class="fe le lf lg lh b">goroutines</code>、<code class="fe le lf lg lh b">channels</code>、<code class="fe le lf lg lh b">select</code>语句、竞争和死锁检测的并发模型的语言原生支持而闻名。但是在多处理器系统中，这总是伴随着<a class="ae kf" href="https://www.usenix.org/system/files/conference/hotos15/hotos15-paper-mcsherry.pdf" rel="noopener ugc nofollow" target="_blank">成本</a>(优于单线程的配置)。</p><h2 id="4b6f" class="li lj it bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated">背景:多进程调度</h2><p id="328e" class="pw-post-body-paragraph kg kh it ki b kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">回顾我们的CS课程，我们知道每个多处理器系统的核心都是优化处理器利用率，操作系统通过实施高效的调度算法在不同处理器之间分配负载来实现这一点。这些方法包括:</p><ol class=""><li id="d2b1" class="mg mh it ki b kj kk kn ko kr mi kv mj kz mk ld ml mm mn mo bi translated"><strong class="ki iu">对称和非对称调度</strong>:当有一个主处理器为其他进程编排调度时，对称调度很常见。当每个处理器都有自己的就绪队列，也许还有一个全局队列来处理它们的作业时，就会出现对称调度</li><li id="6d82" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated"><strong class="ki iu">处理器关联性:</strong>当不同处理器的资源使用行为不一致时，例如不同处理器不一致地访问高速缓存或内存时，使用此机制(<a class="ae kf" href="https://en.wikipedia.org/wiki/Non-uniform_memory_access" rel="noopener ugc nofollow" target="_blank"> NUMA </a>)</li><li id="5ad0" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated"><strong class="ki iu">负载共享/负载平衡:</strong>当处理器负载不均匀时，使用这种机制，其中一些负载过重，而另一些负载空闲。这在拥有自己的<em class="mu">就绪队列的对称系统中很常见。</em>这可以通过以下两种方式之一实现:</li></ol><ul class=""><li id="de73" class="mg mh it ki b kj kk kn ko kr mi kv mj kz mk ld mv mm mn mo bi translated"><strong class="ki iu">推送迁移</strong>:一个单独的进程定期运行，将任务从过载处理器的就绪队列中推送到全局队列或其他未过载的处理器中</li><li id="eb28" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld mv mm mn mo bi translated"><strong class="ki iu">拉式迁移</strong>:空闲的处理器将任务从全局队列拉至它们自己的就绪队列</li></ul><p id="a8ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Golang在其运行时使用基于<strong class="ki iu"> <em class="mu">拉迁移的负载均衡调度</em> </strong>来优化资源利用率。让我们把下面的图表看作一个典型的go运行时在任何给定时间点的调度</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/885a223321362f9acdd755c2a258af36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*2o9fS2rEJltFYom65wAIyw.jpeg"/></div></figure><p id="1414" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在图中，<code class="fe le lf lg lh b">G0</code>、<code class="fe le lf lg lh b">G1</code>……<code class="fe le lf lg lh b">G9</code>是运行在一台双核机器上的goroutines，该机器有两个处理器<code class="fe le lf lg lh b">P0</code>和<code class="fe le lf lg lh b">P1</code>。上下文中的系统有一个全局队列，队列中有4个goroutines。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="36af" class="li lj it bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated">Goroutine负载均衡</h2><p id="af7d" class="pw-post-body-paragraph kg kh it ki b kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">Go的<code class="fe le lf lg lh b">goroutine</code>负载平衡算法通过以如下方式实现基于<a class="ae kf" href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/proc.go#L31-L80" rel="noopener ugc nofollow" target="_blank">停放/未停放的工作窃取调度</a>来工作:</p><ol class=""><li id="fa90" class="mg mh it ki b kj kk kn ko kr mi kv mj kz mk ld ml mm mn mo bi translated">每个处理器都从自己的本地运行队列中运行<code class="fe le lf lg lh b">goroutines</code>。因此，在上述情况下，P0和P1将分别运行goroutines G0、G1和G2、G3、G6、G7</li><li id="c390" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated">如果一个处理器不在它自己的本地运行队列(空闲状态)中执行，它将从全局队列中提取工作</li><li id="ef17" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated">如果处理器无法在全局队列中找到要执行的goroutines，那么它会尝试从<code class="fe le lf lg lh b">netpoller</code>中提取工作</li><li id="b181" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated">如果它仍然找不到要执行的goroutines，它将检查其他处理器的运行队列，并从它们的运行队列中窃取<code class="fe le lf lg lh b">goroutines</code>的一半</li></ol><p id="67b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基于此，假设我们有一个go程序，其状态如下，其中P0过载，而P1空闲</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/c5aa71e72225d67803b9613f212b7414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*9Bqr1c5LEMk-AWaKVjfJxQ.jpeg"/></div></figure><p id="1d07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，Go runtime scheduler将执行以下步骤，以确保尽可能高效地利用硬件(多处理器)</p><ol class=""><li id="2cfd" class="mg mh it ki b kj kk kn ko kr mi kv mj kz mk ld ml mm mn mo bi translated">P1将检查本地运行队列，发现它是空的。</li><li id="91cb" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated">它检查全局运行队列，发现有两个goroutines要执行:G8和G9</li><li id="aa34" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated">它<em class="mu">将它们停放</em>在其本地运行队列中，并开始执行它们</li><li id="3fff" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated">假设过了一段时间，它完成了这两个goroutines的执行，而P1仍然忙于执行一个满运行队列</li><li id="bb4a" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated">P1检查了一下<code class="fe le lf lg lh b">netpoller</code>，发现它也是空的。当全局队列和<code class="fe le lf lg lh b">netpoller</code>队列都为空时，这在Go运行时调度器的底层实现中被称为线程的<a class="ae kf" href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/proc.go#L55-L63" rel="noopener ugc nofollow" target="_blank">旋转状态</a></li><li id="04ba" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated">在这种状态下，P1现在<em class="mu">从P0: G4和G5窃取<em class="mu">工作</em>的一半</em>。系统状态看起来是这样的，它平衡了处理器之间的负载，并有效地利用了硬件</li></ol><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/bfe059273654c9d289baaf98e83c5ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*H-K-JcurmeZvG3Sla8xWgA.jpeg"/></div></figure><p id="077b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你感兴趣，2012年写的可伸缩Go调度器的设计文档<a class="ae kf" href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit" rel="noopener ugc nofollow" target="_blank">更深入地捕捉了所有这些细节。</a></p></div></div>    
</body>
</html>