<html>
<head>
<title>SuperGloo to the Rescue! Making it easier to write extensions for Service Mesh</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超级英雄来救援了！使得为服务网格编写扩展变得更加容易</h1>
<blockquote>原文：<a href="https://itnext.io/supergloo-to-the-rescue-making-it-easier-to-write-extensions-for-service-mesh-4b78fd0e2415?source=collection_archive---------3-----------------------#2019-05-18">https://itnext.io/supergloo-to-the-rescue-making-it-easier-to-write-extensions-for-service-mesh-4b78fd0e2415?source=collection_archive---------3-----------------------#2019-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b0a3d78edb2114463a5a0bbe753868f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/0*stehjDK0teBe1L0p.png"/></div></div></figure><p id="86eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">SuperGloo是一个大规模服务网格编排的开源项目。SuperGloo提供了一个自以为是的抽象层，简化了一个或多个服务网格的安装、管理和操作，如部署在本地、云中的<a class="ae kz" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>、<a class="ae kz" href="https://aws.amazon.com/app-mesh/" rel="noopener ugc nofollow" target="_blank"> AWS App Mesh </a>、<a class="ae kz" href="https://linkerd.io/" rel="noopener ugc nofollow" target="_blank"> Linkerd </a>和<a class="ae kz" href="https://www.consul.io/" rel="noopener ugc nofollow" target="_blank">hashi corp consult</a>或您需要的任何组合。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/b25f08072f3d3022db9f3bfb2a0a1a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNE1JhKm12fCM-EZP2biBQ.png"/></div></div></figure><p id="7752" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有越来越多的文章讨论SuperGloo的原因，如<a class="ae kz" href="https://blog.christianposta.com/" rel="noopener ugc nofollow" target="_blank"> Christian Posta的</a><a class="ae kz" href="https://medium.com/solo-io/solo-io-streamlines-service-mesh-and-serverless-adoption-for-enterprises-in-google-cloud-c93b8aa04d81" rel="noopener">“solo . io简化了谷歌云中企业的服务网格和无服务器采用”</a>。本文将关注SuperGloo如何帮助像<a class="ae kz" href="https://github.com/weaveworks/flagger" rel="noopener ugc nofollow" target="_blank"> Weaveworks Flagger </a>这样的软件包在多个服务网格上工作，如Istio和AWS App Mesh，它们都支持流量转移。</p><p id="ee2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Flagger是一个很酷的开源项目，可以自动推广Kubernetes服务的Canary部署。您将Flagger Canary Kubernetes自定义资源(CRD)与您的部署相关联，Flagger将遵循您定义的规则来帮助推出新版本。它检测何时部署了新版本的服务，与现有版本并行实例化新版本，在两个版本之间缓慢转移请求流量，并使用您定义的Prometheus metric健康检查来确定Flagger是应该继续将更多流量转移到新版本还是回滚到旧版本。由于金丝雀CRD是一个YAML文件，这为您提供了一种声明性的方式来确保您的所有服务升级都遵循您指定的复杂部署策略，并补充了在<a class="ae kz" href="https://github.com/weaveworks/flux" rel="noopener ugc nofollow" target="_blank"> Weave Flux </a>和<a class="ae kz" href="https://jenkins-x.io/" rel="noopener ugc nofollow" target="_blank"> JenkinsX </a>中使用的GitOps管道。</p><p id="c7da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更多关于金丝雀部署和交通转移的信息在下面的帖子里。<a class="ae kz" href="https://gloo.solo.io/" rel="noopener ugc nofollow" target="_blank"> Gloo </a>使用与Istio相同的底层数据平面技术<a class="ae kz" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank"> Envoy </a>，提供Flagger和Knative使用的流量转移功能。Gloo是一个API/功能网关，而不是一个全服务网格，因此Gloo可以用于不需要全服务网格实现的所有能力和重量的用例。</p><ul class=""><li id="c7eb" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated"><a class="ae kz" href="https://scott.cranton.com/canary-deployments-with-weighted-routes.html" rel="noopener ugc nofollow" target="_blank">使用加权目的地的Gloo功能网关的Canary部署</a></li><li id="89d9" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><a class="ae kz" href="https://scott.cranton.com/knative-and-gloo.html" rel="noopener ugc nofollow" target="_blank">通过Knative和Solo.io Gloo实现服务自动化</a></li><li id="4299" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><a class="ae kz" href="https://jenkins-x.io/developing/knative/" rel="noopener ugc nofollow" target="_blank"> Jenkins X无服务器应用</a></li></ul><p id="8f37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文快速介绍了如何使用Istio在SuperGloo上设置Flagger <code class="fe lt lu lv lw b">podinfo</code>示例应用程序，这样大家就可以看到其中涉及的内容，如果愿意的话也可以自己尝试一下。</p><h1 id="f41a" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">安装Kubernetes和头盔</h1><p id="9db5" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">我们旅程的第一步是运行一个基本的本地Kubernetes集群。我的朋友Christian Hernandez向我介绍了Kubernetes sig测试团队的kind(T21)。假设您有一个本地运行的Docker副本，例如Docker Desktop，这是一种快速、轻量级的方法来加速/减速本地集群。如果您愿意，这个例子在<code class="fe lt lu lv lw b">minikube</code>中也同样适用。下面的代码完成了大多数Kubernetes集群所需的基本工作。</p><ul class=""><li id="5d02" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">创建一个具有一个控制平面节点和一个工作节点的<code class="fe lt lu lv lw b">kind</code>集群</li><li id="d968" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">将<code class="fe lt lu lv lw b">KUBECONFIG</code>配置为<code class="fe lt lu lv lw b">kind</code>为每个<code class="fe lt lu lv lw b">kind</code>集群创建一个单独的<code class="fe lt lu lv lw b">kubeconfig</code>文件</li><li id="19ce" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">安装舵杆和舵杆，并为舵杆提供服务账户</li></ul><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="7602" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">使用SuperGloo安装和配置Istio</h1><p id="0ad8" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">神奇的事情发生了，所以让我们花点时间梳理一下由于这几行代码而发生的所有事情。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9ee1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个命令<code class="fe lt lu lv lw b">supergloo init</code>将SuperGloo安装到您的Kubernetes集群中，这相当于使用Helm安装SuperGloo。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c02e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个命令<code class="fe lt lu lv lw b">kubectl --namespace supergloo-system rollout status deployment/supergloo --watch=true</code>是一个等到SuperGloo部署完全部署并运行的工具。这类似于在安装头盔时使用<code class="fe lt lu lv lw b">--wait</code>选项。</p><p id="d823" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lt lu lv lw b">supergloo install istio ...</code>命令声明一个定制资源，SuperGloo控制器按照声明安装和配置Istio。在这种情况下，我们使用Istio的Prometheus安装来安装Istio版本1.0.6，并使用Istio在标签为<code class="fe lt lu lv lw b">istio-injection=enabled</code>的名称空间内的所有pod中部署sidecars，即<a class="ae kz" href="https://scott.cranton.com/kubectl%20--namespace%20supergloo-system%20rollout%20status%20deployment/supergloo%20--watch=true" rel="noopener ugc nofollow" target="_blank"> Istio自动注入sidecars的默认行为</a>。这个命令性的<code class="fe lt lu lv lw b">supergloo install istio</code>命令创建了下面的清单，如果您愿意，您可以<code class="fe lt lu lv lw b">kubectl apply</code>创建。更多细节请参考完整的<code class="fe lt lu lv lw b"><a class="ae kz" href="https://supergloo.solo.io/v1/github.com/solo-io/supergloo/api/v1/install.proto.sk#istioinstall" rel="noopener ugc nofollow" target="_blank">Install</a></code>规格。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="bc5a" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">安装Weaveworks Flagger</h1><p id="e1e7" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">以下安装Flagger及其相关部件。以下是安装Flagger的快速总结。更多详情请访问<a class="ae kz" href="https://docs.flagger.app/" rel="noopener ugc nofollow" target="_blank"> Flagger Doc网站</a>。</p><ol class=""><li id="bd43" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky nc ll lm ln bi translated">添加对Flagger helm repo的引用</li><li id="2ed0" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky nc ll lm ln bi translated">等待舵柄完全运转。只有从头开始创建Kubernetes集群的快速脚本有问题</li><li id="1250" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky nc ll lm ln bi translated">创建允许Flagger修改SuperGloo/Istio资源的群集角色绑定</li><li id="ed0c" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky nc ll lm ln bi translated">参考Istio提供的Prometheus安装核心Flagger，并告诉Flagger that SuperGloo是网格控制器</li><li id="2787" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky nc ll lm ln bi translated">安装Flagger的Grafana仪表盘，该仪表盘不在本演示中使用</li><li id="adb5" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky nc ll lm ln bi translated">安装Flagger的LoadTester，如果没有足够的用户流量，它可以帮助在Canary部署期间生成测试流量</li></ol><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="2229" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">安装Weaveworks Flagger示例应用程序</h1><p id="1e3b" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">示例应用程序<code class="fe lt lu lv lw b"><a class="ae kz" href="https://github.com/stefanprodan/k8s-podinfo" rel="noopener ugc nofollow" target="_blank">podinfo</a></code>是简单的golang web应用程序。它配备了Prometheus，因此我们可以判断它的性能是否良好，这有助于我们的Canary部署验证新版本是否能够处理传入流量。如果您想让部署显式失败，示例应用程序还提供了钩子来允许您生成错误，以查看Flagger Canary如何处理这种情况。关于Flagger示例应用程序选项的全部细节在此处<a class="ae kz" href="https://docs.flagger.app/usage/progressive-delivery" rel="noopener ugc nofollow" target="_blank"/>。以下是安装步骤的摘要。</p><ol class=""><li id="c32f" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky nc ll lm ln bi translated">安装一个<code class="fe lt lu lv lw b">test</code>名称空间、示例Kubernetes部署清单和一个(可选的)水平pod自动缩放器</li><li id="e2ba" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky nc ll lm ln bi translated">为示例应用程序部署Canary策略。稍后会有更多的细节</li><li id="fcb7" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky nc ll lm ln bi translated">等待金丝雀控制器报告它已经完全准备好了，这意味着Istio和Flagger已经完全部署好并正在运行</li></ol><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3633" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Canary清单有一个将它与podinfo部署相关联的目标引用。Canary分析称，每增加一个<code class="fe lt lu lv lw b">interval</code> (1分钟)标记，新版本的请求流量就会增加<code class="fe lt lu lv lw b">stepWeight</code> (10%)，直到<code class="fe lt lu lv lw b">maxWeight</code> (50%)，只要<code class="fe lt lu lv lw b">metrics</code>保持在定义的健康范围内。如果超过<code class="fe lt lu lv lw b">threshold</code> (5)个健康检查失败，则回滚到旧版本的100%流量，并删除新版本部署。还有一个可选部分，允许Flagger loadtester生成额外的流量，以帮助验证新的Canary版本，即，如果新版本没有处理任何请求，很难知道新版本是否工作。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="16a7" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">部署新的映像版本，并观察canary部署</h1><p id="7691" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">首先，我们检查当前部署的映像版本，并将其打印出来，以帮助我们验证测试是否如我们所期望的那样更新了服务；应该是<code class="fe lt lu lv lw b">quay.io/stefanprodan/podinfo:1.4.0</code>。然后，为了使更改更加明显，我们触发一个后台进程，在五秒钟的延迟后将图像版本更新为<code class="fe lt lu lv lw b">quay.io/stefanprodan/podinfo:1.4.1</code>。然后，我们循环并打印出podinfo的更改事件，以查看流量权重的变化，直到Canary报告成功。如果您想尝试引入错误来查看Canary回滚，您需要更改这个循环。最后，我们将打印出图像版本，应该是<code class="fe lt lu lv lw b">quay.io/stefanprodan/podinfo:1.4.1</code>一切顺利。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="1e97" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">清理Kubernetes</h1><p id="82de" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">最后一步是清理Kubernetes集群，在我们的例子中，这意味着通过运行<code class="fe lt lu lv lw b">kind delete cluster</code>并取消设置<code class="fe lt lu lv lw b">KUBECONFIG</code>环境变量来删除kind集群。</p><h1 id="6fb9" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">一起看一切</h1><p id="2118" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">这里有一个<a class="ae kz" href="https://asciinema.org/" rel="noopener ugc nofollow" target="_blank">asci NEMA</a>的屏幕记录，记录了整个示例脚本的运行，如果您想亲自尝试，之后您可以看到整个脚本。Asciinema记录器可以加速任何长时间运行的命令，也就是说，如果一个命令需要两秒以上的时间来执行，则回放会延迟两秒。这种加速将运行时间从15分钟以上减少到大约两分钟。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><a href="https://asciinema.org/a/hUwE6wzhmEkw2KIK74dtNiIfd"><div class="gh gi nd"><img src="../Images/617c2787cef1d8593a386145e97dcd38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnh17yK8OfqDs9Kz5A7lcw.png"/></div></a></figure><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="e853" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">摘要</h1><p id="db73" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">希望这个例子让您了解了SuperGloo是如何支持Flagger这样的金丝雀部署引擎的。在SuperGloo之前，你要么需要学习如何自己安装所有的Istio，要么只能使用GKE或AWS的托管Istio或App Mesh安装。这些都是很好的托管产品，但是它们将您的选择限制在它们当前支持的版本和配置上。</p><p id="64e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">SuperGloo提供了一个很好的抽象和管理层来帮助扩展利用一个或多个服务网格，而不需要深入到任何一个网格(如Istio或App Mesh)的巨大API表面区域中。SuperGloo使应用程序可以轻松地使用底层网格中他们需要的东西。根据我听到的反馈，这有助于在服务网格上的采用，也就是说，许多人目前正在试验Istio或App Mesh或Linkerd的on功能，通常是流量转移或相互TLS，他们发现很难管理和配置整个网格，即使他们没有使用这些其他功能。SuperGloo的救援，以帮助更容易地使用服务网格的部分增值今天，并允许您添加更多的，因为你需要它包括混合和匹配多个服务网格轻松获得最大的投资回报。</p><p id="da3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我强烈建议你自己多学习，因为学习新技术很有趣，尤其是那些能帮助你解决复杂挑战并加速你部署更大更复杂系统的技术。</p><ul class=""><li id="580d" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">超级Gloo</li><li id="d7a4" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><a class="ae kz" href="https://docs.flagger.app/" rel="noopener ugc nofollow" target="_blank">旗手</a></li><li id="f860" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><a class="ae kz" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a></li><li id="bc95" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><a class="ae kz" href="https://servicemeshhub.io" rel="noopener ugc nofollow" target="_blank">服务网状集线器</a></li></ul></div></div>    
</body>
</html>