<html>
<head>
<title>Introduction to JavaScript iterator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript迭代器简介</h1>
<blockquote>原文：<a href="https://itnext.io/introduction-to-javascript-iterator-eac78849e0f7?source=collection_archive---------3-----------------------#2018-03-28">https://itnext.io/introduction-to-javascript-iterator-eac78849e0f7?source=collection_archive---------3-----------------------#2018-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3058740061a2d6b5576e49a1998aa761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7nb-owwLC4MMYZTlyFZ7w.png"/></div></div></figure><h1 id="eb31" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">符号</a></h1><p id="30ec" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">ES6引入了一种叫做<em class="lv">的新类型符号</em>。<em class="lv">符号</em>函数返回类型为<em class="lv">符号</em>的值。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e78b" class="mf jz iq mb b gy mg mh l mi mj">const symbol1 = Symbol();<br/>const symbol2 = Symbol('hi');</span><span id="d603" class="mf jz iq mb b gy mk mh l mi mj">console.log(typeof symbol1); //symbol</span><span id="1c24" class="mf jz iq mb b gy mk mh l mi mj">console.log(symbol3.toString()); //Symbol(foo)</span><span id="4181" class="mf jz iq mb b gy mk mh l mi mj">// each symbol value created by Symbol function is unique<br/>console.log(Symbol('foo') === Symbol('foo'));  // false</span><span id="9ff0" class="mf jz iq mb b gy mk mh l mi mj">// Symbol itself is a function<br/>console.log(typeof Symbol); //function</span></pre><h1 id="534a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank">迭代器</a></h1><p id="7879" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">一个<em class="lv">迭代器</em>是一个提供<em class="lv"> next </em>方法的对象，该方法返回序列中的下一项。该方法返回一个具有两个属性的对象:<em class="lv">完成</em>和<em class="lv">值</em>。对于一个要成为<em class="lv">可迭代</em>的对象，它必须有一个带有<em class="lv"> Symbol.iterator </em>键的function属性，它为每个调用返回一个新的<em class="lv">迭代器</em>。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a423" class="mf jz iq mb b gy mg mh l mi mj">// Array has build-in iteration support<br/>function forOf(arr) {<br/>    for(let i of arr) {<br/>        console.log(i);<br/>    }<br/>}</span><span id="edf9" class="mf jz iq mb b gy mk mh l mi mj">/**<br/> * for...of loops is based on iterator<br/> * so forOf implementation above is basically:<br/> */<br/>function iterating(arr) {<br/>    let iterator = arr[Symbol.iterator](); //get the iterator for the array<br/>    let next = iterator.next();<br/>    while(!next.done) {<br/>        console.log(next.value);<br/>        next = iterator.next();<br/>    }<br/>}</span></pre><h1 id="40e9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使对象可迭代</h1><p id="6743" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><em class="lv">对象</em>没有内置迭代支持。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3392" class="mf jz iq mb b gy mg mh l mi mj">let obj = {a: 'b', c: 'd'}<br/>for(let i of obj) {<br/>    //Uncaught TypeError: obj is not iterable<br/>    console.log(i);<br/>}</span></pre><p id="afca" class="pw-post-body-paragraph kx ky iq kz b la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu ij bi translated">为了使<em class="lv">对象</em>可迭代，我们必须将<em class="lv"> Symbol.iterator </em>添加到实例或原型中。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3b8c" class="mf jz iq mb b gy mg mh l mi mj">Object.defineProperty(Object.prototype, Symbol.iterator, {<br/>    value: function() {<br/>        let keys = Object.keys(this);<br/>        let index = 0;<br/>        return {<br/>            next: () =&gt; {<br/>                let key = keys[index++];<br/>                return {<br/>                    value: `${key}-${this[key]}`,<br/>                    done: index &gt; keys.length<br/>                }<br/>            }<br/>        };<br/>    },<br/>    enumerable: false<br/>});</span><span id="0bff" class="mf jz iq mb b gy mk mh l mi mj">let obj = {a: 'b', c: 'd'}<br/>for(let i of obj) {<br/>    console.log(i); // a-b c-d<br/>}</span></pre><h1 id="3d70" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank">发电机</a></h1><p id="75b9" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">函数<em class="lv">声明定义了一个</em>生成器函数<em class="lv">，其返回值为</em>生成器对象<em class="lv">。</em>生成器对象<em class="lv">符合</em>迭代器协议<em class="lv">。注意</em>发生器函数*本身就是一个函数。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2509" class="mf jz iq mb b gy mg mh l mi mj">//generator function<br/>function* generatorFn() {<br/>    yield 1;<br/>    return 2;<br/>}</span><span id="69aa" class="mf jz iq mb b gy mk mh l mi mj">// generator object - iterator<br/>let generatorObj = generatorFn();<br/>let nextItem = generatorObj.next(); </span><span id="5dc0" class="mf jz iq mb b gy mk mh l mi mj">console.log(typeof generatorFn); //function<br/>console.log(typeof generatorObj); //object<br/>console.log(typeof generatorObj.next); //function<br/>console.log(nextItem); //{value: 1, done: false}</span></pre><p id="7734" class="pw-post-body-paragraph kx ky iq kz b la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu ij bi translated">因此，为了使<em class="lv">对象</em>可迭代，我们可以用<em class="lv">生成器函数</em>定义它的<em class="lv"> Symbol.iterator </em>。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="895f" class="mf jz iq mb b gy mg mh l mi mj">Object.defineProperty(Object.prototype, Symbol.iterator, {<br/>    value: function*() {<br/>        let keys = Object.keys(this);<br/>        for(let key of keys) {<br/>            yield `${key}-${this[key]}`;<br/>        }<br/>    },<br/>    enumerable: false<br/>});</span><span id="42b7" class="mf jz iq mb b gy mk mh l mi mj">let obj = {a: 'b', c: 'd'};<br/>for(let kv of obj) {<br/>    console.log(kv); // a-b c-d<br/>}</span></pre><h1 id="713c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在实践中</h1><p id="5eaf" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">有了这种技术，我们可以使定制数据类型可迭代。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a13b" class="mf jz iq mb b gy mg mh l mi mj">class Group {<br/>    constructor() {<br/>        this._data = [];<br/>    }</span><span id="4f2f" class="mf jz iq mb b gy mk mh l mi mj">    add(it) {<br/>        this._data.push(it);<br/>    }</span><span id="7544" class="mf jz iq mb b gy mk mh l mi mj">    delete(it) {<br/>        let index = this._data.indexOf(it);<br/>        if(index &gt;= 0) {<br/>            this._data.splice(index, 1);<br/>        }<br/>    }</span><span id="add5" class="mf jz iq mb b gy mk mh l mi mj">    has(it) {<br/>        return this._data.includes(it);<br/>    }</span><span id="d552" class="mf jz iq mb b gy mk mh l mi mj">    [Symbol.iterator]() {<br/>        let index = 0;<br/>        return {<br/>            next: () =&gt; ({<br/>                value: this._data[index++],<br/>                done: index &gt; this._data.length<br/>            })<br/>        };<br/>    }</span><span id="5544" class="mf jz iq mb b gy mk mh l mi mj">    static from(iterable) {<br/>        let group = new Group();<br/>        for(let item of iterable) {<br/>            group.add(item);<br/>        }<br/>        return group;<br/>    }<br/>}</span><span id="a0ca" class="mf jz iq mb b gy mk mh l mi mj">let group = Group.from(['a', 'b', 'c']);<br/>console.log(group)</span><span id="4dc7" class="mf jz iq mb b gy mk mh l mi mj">for (let value of group) {<br/>    console.log(value);<br/>}</span><span id="b96c" class="mf jz iq mb b gy mk mh l mi mj">console.log([...group]);</span></pre></div></div>    
</body>
</html>