<html>
<head>
<title>Tips for Writing Better React Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更好的React代码的技巧</h1>
<blockquote>原文：<a href="https://itnext.io/tips-for-writing-better-react-code-ceb49e929001?source=collection_archive---------0-----------------------#2022-09-16">https://itnext.io/tips-for-writing-better-react-code-ceb49e929001?source=collection_archive---------0-----------------------#2022-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b46" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你知道那些窍门吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1fd5d06d7e3c5dca80e028f25d9ceab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pZN0TRzcvMbCXZ5UwWof-A.png"/></div></div></figure><h1 id="f028" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">为什么？</h1><p id="a756" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你的代码应该尽可能的干净和可维护。</p><p id="3d3d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要成为一名优秀的开发人员，你不一定要写出有用的代码，<strong class="lo iu">你必须写出有用的好代码。</strong></p><p id="eb7e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里有一些有用的技巧，我希望我以前在我的反应之旅中学过。</p><h1 id="525b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用片段</h1><p id="79c3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在React中，你不能从一个组件中返回多个子组件，如果你尝试的话，你会得到错误:“<strong class="lo iu">相邻的JSX元素必须被包围在一个封闭标签</strong>中”。</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="9d80" class="ms kv it mo b be mt mu l mv mw">const LoginForm = () =&gt; {<br/>  return (<br/>      &lt;UserInput /&gt;<br/>      &lt;PasswordInput /&gt;<br/>  );<br/>};</span></pre><p id="578f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一个常见的<strong class="lo iu">(不是最好的)</strong>解决方案是将您的孩子包装在一个div组件中，如下例所示:</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="a500" class="ms kv it mo b be mt mu l mv mw">const LoginForm = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;UserInput /&gt;<br/>      &lt;PasswordInput /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><h2 id="2fce" class="mx kv it bd kw my mz dn la na nb dp le lv nc nd lg lz ne nf li md ng nh lk ni bi translated"><strong class="ak">如果不需要就不要用div</strong>，用react片段代替。</h2><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="9269" class="ms kv it mo b be mt mu l mv mw">const LoginForm = () =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;UserInput /&gt;<br/>      &lt;PasswordInput /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="2f67" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">为什么你更喜欢片段而不是div？</strong></p><p id="4058" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你不需要div，片段总是更好的选择，因为片段不会在<strong class="lo iu"> DOM </strong>中产生任何元素，这意味着片段的子组件将在没有任何包装<strong class="lo iu"> DOM </strong>节点的情况下呈现。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="b1e6" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">传播算子</h1><p id="5644" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果您必须将许多道具传递给子组件，如下所示:</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="278e" class="ms kv it mo b be mt mu l mv mw">const Parent = (props) =&gt; {<br/>  return (<br/>    &lt;Child<br/>      firstName={props.firstName}<br/>      lastName={props.lastName}<br/>      age={props.age}<br/>      email={props.email}<br/>      address={props.address}<br/>      phone={props.phone}<br/>      work={props.work}<br/>    /&gt;<br/>  );<br/>};</span></pre><p id="b8cf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用<code class="fe nv nw nx mo b">spread operator (...)</code>可能会更好，使代码更简洁，就像这样:</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="25c7" class="ms kv it mo b be mt mu l mv mw">const Parent = (props) =&gt; {<br/>  return &lt;Child {...props} /&gt;;<br/>};</span></pre><p id="5192" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">小心:散布道具会让代码不那么清晰，所以只有在你有很多需要传递的道具的情况下才使用。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="290f" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">自动结束标签</h1><p id="eaab" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在React中，只有当组件有子组件时，才需要编写结束标记，就像这样</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="ea1b" class="ms kv it mo b be mt mu l mv mw">&lt;Component&gt; ... &lt;/Component&gt;</span></pre><p id="7764" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果没有子组件，你可以像这样简洁地编写组件</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="d7c0" class="ms kv it mo b be mt mu l mv mw">&lt;Component /&gt;</span></pre></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="6722" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">使用咖喱功能</h1><p id="dc3a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">大多数React开发者都不知道Curry函数，但是相信我，你会喜欢它们的。</p><p id="ee03" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在解释什么是curry函数之前，我需要添加一些上下文。</p><p id="c870" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">假设我们想要创建一个组件，为用户数组中的每个用户呈现一个按钮，并在单击按钮时向用户显示一个警告。</p><p id="2856" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">通常的做法是这样的:</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="6d45" class="ms kv it mo b be mt mu l mv mw">const LoginForm = (props) =&gt; {<br/>  const selectUser = (user) =&gt; {<br/>    alert(`You selected ${user}`);<br/>  };<br/><br/>  return (<br/>    &lt;&gt;<br/>      {users.map((user) =&gt; (<br/>        &lt;button onClick={() =&gt; selectUser(user)}&gt;Select {user}&lt;/button&gt;<br/>      ))}<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="e31e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">基本上，在<code class="fe nv nw nx mo b">onClick</code>内部，我们定义了一个匿名函数来调用<code class="fe nv nw nx mo b">selectUser</code>函数。</p><p id="0b46" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">还有一个更好的办法，就是拍马屁。</p><p id="3fca" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">Currying就是把一个带<strong class="lo iu">X</strong>T21s参数的函数分解成<strong class="lo iu">X</strong>T25】函数，每个函数只带<strong class="lo iu">一个参数</strong>。</p><p id="20bd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是一个简单的例子，说明如何编写一个curried add函数:</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="a308" class="ms kv it mo b be mt mu l mv mw">const add = (a, b) =&gt; {<br/>  return a + b;<br/>};<br/><br/>// Becomes<br/><br/>const add = (a) =&gt; (b) =&gt; {<br/>  return a + b;<br/>};</span></pre><p id="277e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在我们可以用一个curry函数重写上面的例子，如下所示:</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="08aa" class="ms kv it mo b be mt mu l mv mw">const LoginForm = (props) =&gt; {<br/>  const selectUser = (user) =&gt; (e) =&gt; {<br/>    alert(`You selected ${user}`);<br/>  };<br/><br/>  return (<br/>    &lt;&gt;<br/>      {users.map((user) =&gt; (<br/>        &lt;button onClick={selectUser(user)}&gt;Select {user}&lt;/button&gt;<br/>      ))}<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="5c50" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在onClick代码更加简洁了。</p><p id="7f71" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在我们的例子中，curry函数就像一个“工厂”,它生产其他函数来“冻结”我们为进一步调用而传递的用户值。</p><p id="b4f5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要了解幕后发生了什么，您可以尝试运行以下代码:</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="40b5" class="ms kv it mo b be mt mu l mv mw">const users = ["kliton", "medium", "devs"];<br/>const LoginForm = (props) =&gt; {<br/>  const selectUser = (user) =&gt; {<br/>    console.log(<br/>      `I'm creating a selecUser function with the user value: ${user}`<br/>    );<br/>    return (e) =&gt; {<br/>      alert(`You selected ${user}`);<br/>    };<br/>  };<br/><br/>  return (<br/>    &lt;&gt;<br/>      {users.map((user) =&gt; (<br/>        &lt;button key={`btn-${user}`} onClick={selectUser(user)}&gt;<br/>          Select {user}<br/>        &lt;/button&gt;<br/>      ))}<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="042f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">…并查看日志。这将是日志输出:</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="5928" class="ms kv it mo b be mt mu l ny mw">I'm creating a selecUser function with the user value: kliton<br/>I'm creating a selecUser function with the user value: medium<br/>I'm creating a selecUser function with the user value: devs</span></pre></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="7d16" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">消除JSX的内联功能</h1><p id="5300" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">通过尽可能简单地将JavaScript代码和HTML代码分开，可以提高代码的可读性和清晰性。</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="6052" class="ms kv it mo b be mt mu l mv mw">// ❌❌❌❌❌ Bad one<br/>const LoginForm = (props) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;button<br/>        onClick={() =&gt; {<br/>          const result = login();<br/>          {<br/>            /* ... other code .... */<br/>          }<br/>        }}<br/>      /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};<br/><br/>// ✔️✔️✔️ Good one<br/>const LoginForm = (props) =&gt; {<br/>  const handleLogin = () =&gt; {<br/>    const result = login();<br/>    {<br/>      /* ... other code .... */<br/>    }<br/>  };<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={() =&gt; handleLogin()} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="ecca" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">对列表项使用唯一键属性</h1><p id="f5fb" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">React使用<code class="fe nv nw nx mo b">key</code>属性在<strong class="lo iu">组件</strong>和<strong class="lo iu"> DOM元素</strong>之间创建一个<strong class="lo iu">关系</strong>。</p><p id="d5f0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">键有助于识别哪些项目已经更改(添加或删除)。</p><p id="e66b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">例如，如果您正在呈现具有id属性的数据，如果id属性是唯一的，则可以将其用作键。</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="6c7f" class="ms kv it mo b be mt mu l mv mw">const users = [<br/>  {<br/>    id: 1,<br/>    first_name: "Janella",<br/>  },<br/>  {<br/>    id: 2,<br/>    first_name: "Cleveland",<br/>  },<br/>  {<br/>    id: 3,<br/>    first_name: "Joellyn",<br/>  },<br/>];<br/><br/>const UserList = (props) =&gt; {<br/>  return (<br/>    &lt;ul&gt;<br/>      {users.map((user) =&gt; (<br/>        &lt;li key={user.id}&gt;User: {user.first_name}&lt;/li&gt;<br/>      ))}<br/>    &lt;/ul&gt;<br/>  );<br/>};</span></pre></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="d3b2" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">避免使用索引作为关键道具</h1><p id="a1a8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你知道数组不是静态的，就不要使用数组的索引作为键属性。</p><p id="c0ca" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你对数组中的一个元素重新排序，React将会混淆并重新呈现不正确的元素。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="eef2" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">使用HOCS(高阶元件)</h1><p id="e13f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">HoC是避免代码重复的好模式，因为HoC是一个纯函数，它不会改变任何组件。</p><p id="6bbd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">React文档中的定义:“<strong class="lo iu">具体地说，高阶组件是一个函数，它接受一个组件并返回一个新组件。”</strong></p><p id="fc09" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">例如，我们可以创建一个高阶组件，向我们的组件添加一个auth guard，并且只在用户通过身份验证时才显示它。</p><p id="7e5c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe nv nw nx mo b">AuthGuard</code>组件检查用户是否登录，如果没有登录，它将代替组件呈现null。</p><p id="ecfe" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们的<code class="fe nv nw nx mo b">withAuthGuard</code> HoC是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">高阶分量</figcaption></figure><p id="9a7c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">rAnd然后我们可以使用withAuthGuard HoC来保护我们的组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">我们使用AuthGuard HoC保护自定义组件</figcaption></figure></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="d316" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">对象析构</h1><p id="ca6d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">析构使代码更加可读和清晰。</p><p id="3f0a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">ES6中引入了对象析构。</p><p id="1e3c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">析构是一种只获取某些项(从数组中)或某些属性(从对象中)的方法。</p><p id="aece" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在引入析构之前，属性的提取是这样完成的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c05f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用析构，您可以通过以下方式提取名字和电子邮件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="304c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">析构也适用于数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">在ES6的破坏性介绍之前</figcaption></figure><p id="a476" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">变成了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">使用ES6析构</figcaption></figure><h2 id="37f1" class="mx kv it bd kw my mz dn la na nb dp le lv nc nd lg lz ne nf li md ng nh lk ni bi translated">那么，为什么析构使我的代码更易读、更简洁呢？</h2><ul class=""><li id="6697" class="of og it lo b lp lq ls lt lv oh lz oi md oj mh ok ol om on bi translated">您可以将自己的变量名称分配给从道具或其他对象提取的属性</li><li id="f23d" class="of og it lo b lp oo ls op lv oq lz or md os mh ok ol om on bi translated">提高代码的可持续性和可读性</li><li id="7a34" class="of og it lo b lp oo ls op lv oq lz or md os mh ok ol om on bi translated">有助于减少应用程序中使用的代码量。</li></ul><p id="4248" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">析构道具示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="70bf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">额外信息:你有没有想过为什么<code class="fe nv nw nx mo b">useState</code>钩子有这样的语法？</p><pre class="kj kk kl km gt mn mo ot ou aw ov bi"><span id="0280" class="mx kv it mo b gy ow ox l ny mw">const [value, setValue] = useState();</span></pre><p id="da83" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">你猜对了:<code class="fe nv nw nx mo b">useState</code>返回一个数组，我们正在析构它。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="7811" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">当您有复杂的状态逻辑时，请使用useReducer而不是useState</h1><pre class="kj kk kl km gt mn mo ot ou aw ov bi"><span id="65f0" class="mx kv it mo b gy ow ox l ny mw">const [state, dispatch] = useReducer(reducer, initialState);</span></pre><h2 id="0166" class="mx kv it bd kw my mz dn la na nb dp le lv nc nd lg lz ne nf li md ng nh lk ni bi translated">什么是？</h2><p id="44cd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe nv nw nx mo b">useReducer</code>是React提供的一个钩子(像<code class="fe nv nw nx mo b">useState</code>)。</p><p id="31e3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在内部,<code class="fe nv nw nx mo b">useState</code>使用<code class="fe nv nw nx mo b">useReducer</code>,这意味着你可以使用<code class="fe nv nw nx mo b">useReducer</code>做任何你可以用<code class="fe nv nw nx mo b">useState</code>做的事情。</p><h2 id="0499" class="mx kv it bd kw my mz dn la na nb dp le lv nc nd lg lz ne nf li md ng nh lk ni bi translated">在什么情况下更可取？</h2><p id="330f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你有一个复杂的状态形状，<code class="fe nv nw nx mo b">useReducer</code>比<code class="fe nv nw nx mo b">useState</code>提供更多可预测的状态转换。</p><p id="933e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一个很好的经验法则是，当您不再管理原始数据，即字符串、整数或布尔值，而是必须管理复杂的对象时。</p><h2 id="e6f5" class="mx kv it bd kw my mz dn la na nb dp le lv nc nd lg lz ne nf li md ng nh lk ni bi translated">显示优点的东西</h2><p id="7280" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一个todo-list应用程序，我们可以在其中添加任务并将其标记为完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="2034" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">布尔变量名称</h1><p id="8234" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当您要创建布尔变量时，请使用以下前缀之一:</p><ul class=""><li id="cfed" class="of og it lo b lp mi ls mj lv oy lz oz md pa mh ok ol om on bi translated"><strong class="lo iu">是</strong></li><li id="f241" class="of og it lo b lp oo ls op lv oq lz or md os mh ok ol om on bi translated"><strong class="lo iu">有</strong></li><li id="634b" class="of og it lo b lp oo ls op lv oq lz or md os mh ok ol om on bi translated"><strong class="lo iu">可以</strong></li></ul><p id="9db2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">例如，<code class="fe nv nw nx mo b">isVisible</code>比<code class="fe nv nw nx mo b">visible</code>更适合作为布尔值的名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="a39d" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">字符串属性不需要花括号</h1><p id="4c9b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">您可以使用引号将字符串文字指定为属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="34a3" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">使用可选的链接运算符(？)</h1><p id="ca1f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">可选的链接运算符<strong class="lo iu">(？。)</strong>使您能够读取位于连接对象链深处的属性值，而不必检查链中的每个引用是否有效。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="d9f9" class="ku kv it bd kw kx nq kz la lb nr ld le jz ns ka lg kc nt kd li kf nu kg lk ll bi translated">这里有一些我写的其他文章，我想你会觉得有用</h1><div class="pb pc gp gr pd pe"><a href="https://www.klitonbare.com/blog/animate-svg-with-framer" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">用React和帧运动制作SVG动画</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">你好👋在这篇文章中，我将向你展示我是如何为我的博客标识创建一个绘制效果的。在这里你将得到什么(你可以…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">www.klitonbare.com</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="https://medium.com/@barekliton/reactjs-salaries-how-much-developers-earn-around-the-globe-1f1ef03d42b2" rel="noopener follow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">ReactJS的薪水:全球开发者的收入</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">你的呢？</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">medium.com</p></div></div><div class="pn l"><div class="pt l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="https://betterprogramming.pub/how-i-improved-my-react-code-readability-and-maintainability-with-conditional-rendering-94b32448bc70" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">不使用条件呈现操作符编写更好的React代码</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">避免使用使代码不可读的三元运算</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">better编程. pub</p></div></div><div class="pn l"><div class="pu l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a rel="noopener  ugc nofollow" target="_blank" href="/best-books-that-every-software-developer-must-know-8b96faff180d"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">每个软件开发人员都必须知道的最佳书籍！</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">你的书架上有这些书吗？</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">itnext.io</p></div></div><div class="pn l"><div class="pv l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a rel="noopener  ugc nofollow" target="_blank" href="/best-vscode-extensions-by-a-full-stack-developer-in-2022-f730037b6e0b"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">2022年全栈开发者评选的最佳VsCode扩展</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">作为一名完整的堆栈开发人员，以下是我挑选的最好的VS代码扩展！</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">itnext.io</p></div></div><div class="pn l"><div class="pw l pp pq pr pn ps ks pe"/></div></div></a></div></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="dd95" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="px">更多内容请看</em><a class="ae py" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lo iu"><em class="px">plain English . io</em></strong></a><em class="px">。报名参加我们的</em> <a class="ae py" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu"> <em class="px">免费周报</em> </strong> </a> <em class="px">。关注我们关于</em><a class="ae py" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lo iu"><em class="px">Twitter</em></strong></a><a class="ae py" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lo iu"><em class="px">LinkedIn</em></strong></a><strong class="lo iu"><em class="px"/></strong><a class="ae py" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lo iu"><em class="px">YouTube</em></strong></a><strong class="lo iu"><em class="px">，以及</em></strong><em class="px"/><a class="ae py" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="lo iu"><em class="px">不和</em> </strong> </a>  <em class="px">对成长黑客感兴趣？检查</em> <a class="ae py" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu"> <em class="px">电路</em> </strong> </a> <strong class="lo iu"> <em class="px">。</em> </strong></p></div></div>    
</body>
</html>