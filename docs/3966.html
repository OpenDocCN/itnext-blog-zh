<html>
<head>
<title>JSX For Angular Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">棱角分明的开发者的JSX</h1>
<blockquote>原文：<a href="https://itnext.io/jsx-for-angular-developers-23f9d1f21259?source=collection_archive---------2-----------------------#2020-04-03">https://itnext.io/jsx-for-angular-developers-23f9d1f21259?source=collection_archive---------2-----------------------#2020-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b59" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Stencil或React中为Angular开发人员简要介绍JSX</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb4a12807c111f2b588ccddd8edeb58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GcEjTmqI8Rq_tPJGMywfnw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@maelrenau?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae ky" href="https://unsplash.com/s/photos/free?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的雷诺</a></figcaption></figure><p id="9859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我每天分享<a class="ae ky" href="https://medium.com/@david.dalbusco/one-trick-a-day-d-34-469a0336a07e" rel="noopener">一个窍门</a>直到2020年4月19日新冠肺炎隔离期结束。离希望中的好日子还有16天。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="cf56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，当我在用<a class="ae ky" href="https://stenciljs.com" rel="noopener ugc nofollow" target="_blank">模板</a>开发我的第一个Web组件时发现了<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/jsx.html" rel="noopener ugc nofollow" target="_blank"> JSX </a>语法时，我并不那么喜欢它。我错过了<a class="ae ky" href="https://angular.io" rel="noopener ugc nofollow" target="_blank">有角度的</a> HTML模板。</p><p id="6cd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时下？将来我可能会再次改变我的想法，但是在开发了像<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>这样的生态系统，甚至学会了<a class="ae ky" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>之后，我可以肯定地说，我实际上感觉完全相反，我爱JSX ❤️.甚至可能更多，因为我每周都在开发Angular客户的项目。</p><p id="4117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我有这个想法写一个非常简短的，我希望初学者友好的介绍JSX，因为在模板或反应角度的开发人员使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="09b7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">JSX与HTML模板</h1><p id="b5ba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你写一个Angular应用程序，通常是将你的组件分层，甚至可能是三个独立的文件:代码(类型脚本)，样式(CSS)和模板(HTML，GUI)。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="aeb9" class="ne md it na b gy nf ng l nh ni">import {Component} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'app-my-component',<br/>  templateUrl: './my-component.component.html',<br/>  styleUrls: ['./my-component.component.scss']<br/>})<br/>export class MyComponentComponent {<br/><br/>}</span></pre><p id="a5d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和相关模板:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1e6f" class="ne md it na b gy nf ng l nh ni">&lt;div&gt;Hello, World!&lt;/div&gt;</span></pre><p id="a823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用JSX，不管是Stencil还是React，你也有这种分离的问题，但是你不会把你的模板和代码分离到两个独立的文件中。所有的东西通常都打包在一个文件中，甚至在同一个<code class="fe nj nk nl na b">class</code>或<code class="fe nj nk nl na b">function</code>中。</p><p id="e897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关注点的分离发生在代码端。如果你有一个<code class="fe nj nk nl na b">class</code>，你将不得不公开一个方法<code class="fe nj nk nl na b">render()</code>，它返回应该呈现的内容。简而言之:“一个呈现你的HTML代码的方法”。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ed79" class="ne md it na b gy nf ng l nh ni">import {Component, h} from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'my-component',<br/>  styleUrl: 'my-component.css'<br/>})<br/>export class MyComponent {<br/><br/>  render() {<br/>    return &lt;div&gt;Hello, World!&lt;/div&gt;;<br/>  }<br/>  <br/>}</span></pre><p id="770e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有一个<code class="fe nj nk nl na b">function</code>，那么你将有一个遵循相同行为的<code class="fe nj nk nl na b">return</code>方法，而不是<code class="fe nj nk nl na b">render</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8e35" class="ne md it na b gy nf ng l nh ni">import React from 'react';<br/><br/>const MyComponent: React.FC = () =&gt; {<br/><br/>    return (<br/>        &lt;div&gt;Hello, World!&lt;/div&gt;<br/>    );<br/>};<br/><br/>export default MyComponent;</span></pre><p id="94b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Stencil和React都支持<code class="fe nj nk nl na b">class</code>或<code class="fe nj nk nl na b">function</code>。我认为，由于使用和引入了<code class="fe nj nk nl na b">Hooks</code>，最后一种类型在React中变得非常流行，我不打算在本文中介绍。如果你有兴趣在一个单独的职位，平我！我还有很多帖子要写，以完成我的挑战😆。</p><p id="27e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，在本文的其余部分，我将使用<code class="fe nj nk nl na b">class</code>显示模板示例，使用<code class="fe nj nk nl na b">functions</code>显示React示例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="beca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">根元素</h1><p id="af87" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个重要的区别是根元素的概念。在Angular中，你并不真正关心是否。如果您的模板包含一个或多个根元素，它在任何情况下都可以编译。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cfea" class="ne md it na b gy nf ng l nh ni">&lt;div&gt;Hello, World!&lt;/div&gt;<br/><br/>&lt;div&gt;<br/>  &lt;p&gt;Salut&lt;/p&gt;<br/>  &lt;p&gt;Hallo&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="63dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，在JSX，这很重要。应该开发您的组件来处理这种情况。</p><p id="da31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的第一个解决方案可能是将我们的孩子分组到一个HTML节点下。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c24c" class="ne md it na b gy nf ng l nh ni">import {Component, h} from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'my-component',<br/>  styleUrl: 'my-component.css'<br/>})<br/>export class MyComponent {<br/><br/>  render() {<br/>    return &lt;div&gt;<br/>      &lt;div&gt;Hello, World!&lt;/div&gt;<br/><br/>      &lt;div&gt;<br/>        &lt;p&gt;Salut&lt;/p&gt;<br/>        &lt;p&gt;Hallo&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;;<br/>  }<br/><br/>}</span></pre><p id="ac3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是可行的，但这会导致在我们的DOM中添加一个不需要的<code class="fe nj nk nl na b">div</code>标签，即父标签。这就是为什么Stencil和React对这个问题都有各自相似的解决方案。</p><p id="5dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Stencil中，你可以使用一个<code class="fe nj nk nl na b">Host</code>元素。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0c6b" class="ne md it na b gy nf ng l nh ni">import {Component, h, Host} from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'my-component',<br/>  styleUrl: 'my-component.css'<br/>})<br/>export class MyComponent {<br/><br/>  render() {<br/>    return &lt;Host&gt;<br/>      &lt;div&gt;Hello, World!&lt;/div&gt;<br/><br/>      &lt;div&gt;<br/>        &lt;p&gt;Salut&lt;/p&gt;<br/>        &lt;p&gt;Hallo&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    &lt;/Host&gt;;<br/>  }<br/><br/>}</span></pre><p id="b5b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React中，你可以使用所谓的<a class="ae ky" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">片段</a>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6920" class="ne md it na b gy nf ng l nh ni">import React from 'react';<br/><br/>const MyComponent: React.FC = () =&gt; {<br/><br/>    return (<br/>        &lt;&gt;<br/>            &lt;div&gt;Hello, World!&lt;/div&gt;<br/><br/>            &lt;div&gt;<br/>                &lt;p&gt;Salut&lt;/p&gt;<br/>                &lt;p&gt;Hallo&lt;/p&gt;<br/>            &lt;/div&gt;<br/>        &lt;/&gt;<br/>    );<br/>};<br/><br/>export default MyComponent;</span></pre><p id="ab5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在Stencil中，如果你不想使用这样的容器，你可以返回一个<code class="fe nj nk nl na b">array</code>元素。但是我觉得，主要是因为样式的原因，到目前为止我更经常使用上面的解决方案。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bf48" class="ne md it na b gy nf ng l nh ni">import {Component, h} from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'my-component',<br/>  styleUrl: 'my-component.css'<br/>})<br/>export class MyComponent {<br/><br/>  render() {<br/>    return [<br/>      &lt;div&gt;Hello, World!&lt;/div&gt;,<br/>      &lt;div&gt;<br/>        &lt;p&gt;Salut&lt;/p&gt;<br/>        &lt;p&gt;Hallo&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    ];<br/>  }<br/><br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aa68" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">状态和属性</h1><p id="89f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Angular <code class="fe nj nk nl na b">public</code>中，变量是模板中使用的变量，任何变化都会触发新的渲染(“变化应用于GUI”)。</p><p id="8664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">制造的变量<code class="fe nj nk nl na b">private</code>是组件内部使用的变量，不需要新的渲染。</p><p id="0b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，还有<a class="ae ky" href="https://angular.io/api/core/Input" rel="noopener ugc nofollow" target="_blank">输入</a>装饰器，用于将变量作为组件的属性公开。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="98e7" class="ne md it na b gy nf ng l nh ni">import {Component, Input} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'app-my-component',<br/>  templateUrl: './my-component.component.html',<br/>  styleUrls: ['./my-component.component.scss']<br/>})<br/>export class MyComponentComponent {<br/><br/>  @Input()<br/>  count = 0;<br/><br/>  odd = false;<br/><br/>  private even = false;<br/><br/>  inc() {<br/>    // Render again<br/>    this.count++;<br/>    this.odd = this.count % 2 === 1;<br/><br/>    // Do not trigger a new render<br/>    this.even = this.count % 2 === 0;<br/><br/>}</span></pre><p id="1acd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和相应的模板:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ba2e" class="ne md it na b gy nf ng l nh ni">&lt;div&gt;Hello, World!&lt;/div&gt;<br/><br/>&lt;div&gt;{{odd}} {{count}}&lt;/div&gt;</span></pre><p id="825c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JSX，你会发现相同的方法，但分为两类，<code class="fe nj nk nl na b">state</code>和<code class="fe nj nk nl na b">properties</code>，对于这两类，任何改变都会触发组件的新渲染。另一方面，如果你有一个变量不是这两者之一，那么就不会再次触发渲染。</p><p id="2b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">properties</code>是与<code class="fe nj nk nl na b">@Input()</code>字段相对应的概念，这些是组件的公开属性。</p><p id="4e9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">states</code>是一种没有被标记为输入的角度<code class="fe nj nk nl na b">public</code>变量。</p><p id="39f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，在模版中你使用<code class="fe nj nk nl na b">decorator</code>来达到这个目的。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9a0c" class="ne md it na b gy nf ng l nh ni">import {Component, h, Host, Prop, State} from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'my-component',<br/>  styleUrl: 'my-component.css'<br/>})<br/>export class MyComponent {<br/><br/>  @Prop()<br/>  count = 0;<br/><br/>  @State()<br/>  private odd = false;<br/><br/>  even = false;<br/><br/>  inc() {<br/>    // Render again<br/>    this.count++;<br/>    this.odd = this.count % 2 === 1;<br/>    <br/>    // Do not trigger a new render<br/>    this.even = this.count % 2 === 0;<br/>  }<br/><br/>  render() {<br/>    return &lt;Host&gt;<br/>        &lt;div&gt;{this.odd} {this.count}&lt;/div&gt;<br/>      &lt;/Host&gt;<br/>    ;<br/>  }<br/><br/>}</span></pre><p id="7d73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React函数中，你将使用<code class="fe nj nk nl na b">hooks</code>来处理状态，使用<code class="fe nj nk nl na b">interfaces</code>来声明你的属性。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6602" class="ne md it na b gy nf ng l nh ni">import React, {useEffect, useState} from 'react';<br/><br/>interface MyProps {<br/>    count: number;<br/>}<br/><br/>const MyComponent: React.FC&lt;MyProps&gt; = (props: MyProps) =&gt; {<br/><br/>    const [odd, setOdd] = useState&lt;boolean&gt;(false);<br/>    let even = false;<br/><br/>    useEffect(() =&gt; {<br/>        // Render again<br/>        props.count++;<br/>        setOdd(props.count % 2 === 1);<br/><br/>        // Do not trigger a new render<br/>        even = props.count % 2 === 0;<br/>    }, [props.count]);<br/><br/>    return (<br/>        &lt;&gt;<br/>            &lt;div&gt;{odd} {props.count}&lt;/div&gt;<br/>        &lt;/&gt;<br/>    );<br/>};<br/><br/>export default MyComponent;</span></pre><p id="b4d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我说过我不会在本文中讨论钩子，因此让我们把它们总结为异步函数，它观察或应用一个变量的变化，在钩子专用于状态的情况下，<code class="fe nj nk nl na b">useState</code>，如果一个变化被应用到观察到的变量，触发一个新的渲染。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3242" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">条件渲染</h1><p id="63e1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Angular exposes是自己的标签，必须在模板中使用，以执行任何逻辑操作，特别是用于条件渲染的<code class="fe nj nk nl na b">*ngIf</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cd1c" class="ne md it na b gy nf ng l nh ni">&lt;div&gt;Hello, World!&lt;/div&gt;<br/><br/>&lt;div <em class="nm">*</em>ngIf="odd"&gt;{{count}}&lt;/div&gt;</span></pre><p id="aca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JSX的一个优点是你不用模板开发，所以你可以像写代码一样使用语句。</p><p id="158c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，一个<code class="fe nj nk nl na b">if</code>就是一个<code class="fe nj nk nl na b">if</code>😉。</p><p id="972d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于条件渲染，需要记住的唯一重要的事情是:总是返回一些东西！这就是为什么，如果你不想渲染任何东西，我建议返回<code class="fe nj nk nl na b">undefined</code>,这样对DOM没有任何影响。</p><p id="b529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带模板:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="55b4" class="ne md it na b gy nf ng l nh ni">render() {<br/>  return &lt;Host&gt;<br/>    {<br/>      this.odd ? &lt;div&gt;{this.odd} {this.count}&lt;/div&gt; : undefined<br/>    }<br/>  &lt;/Host&gt;;<br/>}</span></pre><p id="3a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者用React:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c5c7" class="ne md it na b gy nf ng l nh ni">return (<br/>    &lt;&gt;<br/>        {<br/>            odd ? &lt;div&gt;{odd} {props.count}&lt;/div&gt; : undefined<br/>        }<br/>    &lt;/&gt;<br/>);</span></pre><p id="f993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以像上面一样内联您的条件，或者在拆分呈现方法中明智地使用它。</p><p id="83db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如该模板示例所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="de40" class="ne md it na b gy nf ng l nh ni">render() {<br/>  return &lt;Host&gt;<br/>    {this.renderLabel()}<br/>  &lt;/Host&gt;;<br/>}<br/><br/>private renderLabel() {<br/>  return this.odd ? &lt;div&gt;{this.odd} {this.count}&lt;/div&gt; : undefined;<br/>}</span></pre><p id="db9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者在这个反应中:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8163" class="ne md it na b gy nf ng l nh ni">return (<br/>    &lt;&gt;<br/>        {renderLabel()}<br/>    &lt;/&gt;<br/>);<br/><br/>function renderLabel() {<br/>    return odd ? &lt;div&gt;{odd} {props.count}&lt;/div&gt; : undefined;<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a193" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="c752" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">还有很多要说的和要描述的，但不幸的是，我不得不在一个有用的，特别是在这些特殊的日子里，我为一个客户开发的移动应用程序上向前迈进。</p><p id="4346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这道开胃菜让你渴望从一个角度更多地了解JSX，请告诉我。我真的很乐意在几篇博文中进一步发展它。就像我说的，我还需要更多来完成我的挑战😃。</p><p id="fb33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呆在家里，注意安全！</p><p id="cafa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大卫</p></div></div>    
</body>
</html>