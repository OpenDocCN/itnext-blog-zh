<html>
<head>
<title>How to properly test React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何正确测试React组件</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-properly-test-react-components-9f090969cb6f?source=collection_archive---------0-----------------------#2018-10-25">https://itnext.io/how-to-properly-test-react-components-9f090969cb6f?source=collection_archive---------0-----------------------#2018-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5fa9f30c4fc7bb550b233d7481b3c0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AesMA3F0ivTq0trIXCSU5Q.jpeg"/></div></div></figure><div class=""/><p id="49b2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你的测试会因为一点点代码的改变而失败吗？你嘲笑严重吗？您是否一直在测试函数调用和组件状态？嗯，你可能做错了。</p><blockquote class="kw kx ky"><p id="c52a" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="jb">我们构建壮观的应用程序，检查</em><strong class="ka jc"><em class="jb"/></strong><a class="ae ld" href="https://auriosoftware.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="jb">【auriosoftware.com】</em></strong></a></p></blockquote><p id="1f84" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我读过很多关于如何测试React组件的文章，大多数时候我觉得应该有更好的方法。在本文中，我将借助<a class="ae ld" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>和<a class="ae ld" href="https://github.com/airbnb/enzyme" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>来解决一些常见问题。</p><p id="2719" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们从最重要的建议开始。</p><h1 id="55b6" class="le lf jb bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">测试行为，不是实现细节！</strong></h1><p id="fcff" class="pw-post-body-paragraph jy jz jb ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">看看下面的例子。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d9fb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">刚开始看起来还可以。我有一个电子邮件输入，我想测试<em class="kz">“当我更改电子邮件输入时，新值将出现在我的状态中”</em>。</p><p id="d4b7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是您正在测试实现细节，特别是内部组件状态。当您将测试与实现细节结合起来时，您的测试就会变得脆弱。</p><p id="827d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看属性<strong class="ka jc"> <em class="kz">邮件</em> </strong>中的状态。每当您重命名该属性或重构组件时，<strong class="ka jc">您的测试将会失败！</strong></p><p id="ef29" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你在问“但是如果我不测试这个，我怎么知道这个输入是否有效”让我告诉你你实际上不需要这个测试。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h2 id="8b7c" class="mu lf jb bd lg mv mw dn lk mx my dp lo kj mz na ls kn nb nc lw kr nd ne ma nf bi translated">创建特征</h2><p id="571a" class="pw-post-body-paragraph jy jz jb ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">假设我们需要一个闪亮的新功能，这是一个简单的订阅表单，用户可以写电子邮件，订阅我们产品的新闻。</p><p id="343b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我假装是一个专业人士，我在做TDD，所以让我写我们的第一个失败的测试。</p><p id="ed56" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">"<strong class="ka jc">当填写了有效的电子邮件并提交了表单时，它应该使用正确的电子邮件订阅新闻</strong></p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="583c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们填写电子邮件输入并点击提交按钮，我们期望使用输入中的电子邮件调用<em class="kz"> subscribe </em>函数。</p><p id="c9bb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">我们在测试行为！不是实现。</strong></p><p id="12d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们运行了测试，但是失败了，因为我们还没有任何实现。因此，让我们编写足够的生产代码来通过测试。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="ab5a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让它通过，我们创建了带有“<strong class="ka jc"> <em class="kz"> email </em> </strong>”属性的状态对象，并在email输入上实现了<strong class="ka jc"> <em class="kz"> onChange </em> </strong>处理程序。之后，我们在提交按钮上创建了<strong class="ka jc"> <em class="kz"> onSubmit </em> </strong>处理程序，并从状态用<strong class="ka jc"> <em class="kz"> email </em> </strong>调用subscribe函数。</p><p id="ff94" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们再做一次测试。它过去了。</p><p id="f975" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的高级用例迫使我们编写代码！这些用例是您应该测试的组件契约。我们不会测试实现细节，比如组件的内部状态以及它是如何变化的，因为它是易变的。</p><p id="82cc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">结论。</strong>避免测试组件状态，不要为了找到一些你需要测试的元素而潜入DOM(<em class="kz">ex:div&gt;foo&gt;input</em>)，因为无论何时你改变你的DOM，你的测试都会失败。我们希望依赖稳定的东西，就像生活中一样，在软件开发中也是如此。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="17ca" class="le lf jb bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">什么是单元测试？</h1><p id="930b" class="pw-post-body-paragraph jy jz jb ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">这是另一个重要的话题，因为很多人对什么是真正的单元有点困惑，这种误解对你的测试有很大的影响。</p><p id="22ba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过扩展前面的例子来尝试解决这个问题。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a7e9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">过了一段时间，我们的组件变大了，我们将一些逻辑封装到不同的组件中。我们为电子邮件输入、提交按钮和包含一些文本和徽标的营销内容创建了一个组件。</p><p id="bd3f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的问题是<strong class="ka jc">我们应该如何改变订阅组件的测试？</strong></p><p id="e5e2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答案很简单，<strong class="ka jc">我们不会改变</strong> <strong class="ka jc">任何东西！</strong></p><p id="3c65" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，我们的测试仍然通过。我们在移动、创建和更改东西，我们的测试仍然正常工作，因为我们没有将我们的测试与实现细节结合起来！</p><p id="4b2e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会问自己。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/979e0e6e93a22f406ac8c59532ae0d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*NaGJ_IL0wwMI0kvZE_I_Qw.jpeg"/></div></figure><p id="026b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是整合测试吗？答案是否定的！让我们从罗伯特·c·马丁那里拿来一些定义。</p><blockquote class="kw kx ky"><p id="293d" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka jc">单元测试。</strong>程序员编写的测试，目的是确保生产代码做程序员期望它做的事情。</p><p id="a969" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka jc">集成测试。</strong>由架构师和/或技术负责人编写的测试，目的是确保系统组件的子组件正确运行。这些是<em class="jb">管道</em>测试。<strong class="ka jc">他们是<em class="jb">而不是</em>业务规则测试</strong>。他们的目的是确认子组件已正确集成和配置。</p><p id="6e24" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka jc">微测。在非常小的范围内编写的单元测试。目的是测试单个功能或一小组功能。</strong></p><p id="3b93" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka jc">功能测试</strong>:在较大范围内编写的单元测试，对较慢的组件进行适当的模拟。</p></blockquote><p id="ce8b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你在一个单元测试的定义里看到一个词<strong class="ka jc"> <em class="kz"> class </em> </strong>？</p><p id="2319" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以把一个单元想象成一个模块。<strong class="ka jc"> </strong>我们要测试如果我们给模块输入<em class="kz"> a，</em>它应该返回输出<em class="kz"> b </em>。该模块是一个黑盒，我们只测试他的公共API。</p><p id="ee8e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多人把单元测试的概念理解为孤立地测试一个类(组件)。为了孤立地测试这个类，您必须在这个类周围设置严格的界限，并模仿它的所有合作者。但是当你嘲笑所有的合作者时，每次他们改变，你的测试也必须改变。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="2a14" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再看看我们之前的测试。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="be4b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以把我们的测试看作是一个<strong class="ka jc">功能测试。</strong>这不是集成测试，因为:</p><ol class=""><li id="0526" class="nm nn jb ka b kb kc kf kg kj no kn np kr nq kv nr ns nt nu bi translated">我们正在测试商业规则，</li><li id="f075" class="nm nn jb ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated">我们嘲笑我们的慢组件，更具体地说是<em class="kz">订阅</em>调用，因为这个函数的产品实现可能会调用某个HTTP端点，</li><li id="439c" class="nm nn jb ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated">测试范围较大，因为我们测试的是整个订阅组件，包括层次结构中的子表示组件。</li></ol><p id="3414" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这给了我们力量，因为我们甚至可以改变库，如材料设计、引导或其他，我们的<strong class="ka jc">测试仍然会通过</strong>，因为它们不依赖于特定的API。</p><h2 id="740e" class="mu lf jb bd lg mv mw dn lk mx my dp lo kj mz na ls kn nb nc lw kr nd ne ma nf bi translated">订阅组件测试的错误示例</h2><p id="a5a2" class="pw-post-body-paragraph jy jz jb ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">如果您过度指定您的测试，这就是<em class="kz">订阅</em>示例的样子。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">不要这样！</figcaption></figure><p id="10e6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们耦合了实现细节，如<em class="kz">营销内容</em>、<em class="kz">电子邮件输入</em>和<em class="kz">提交表单</em>组件。如果我们把道具“onChange”改成“handleChange”呢？如果我们改变这些组件的名称会怎么样？如果我们移除<em class="kz"> MarketingContent </em>并将该逻辑移动到父组件会怎么样？</p><p id="c4b3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的测试会失败！</p><p id="9524" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但这不是唯一的问题。现在我们还必须测试所有这些组件！我向你保证，有一天我们会忘记一些测试，所有这些测试都变得无用，因为，在一天结束时，我们的代码不起作用，因为我们忘记调用层次结构中的一些子组件中的一些方法。</p><h2 id="67f9" class="mu lf jb bd lg mv mw dn lk mx my dp lo kj mz na ls kn nb nc lw kr nd ne ma nf bi translated"><strong class="ak">总结</strong></h2><p id="df59" class="pw-post-body-paragraph jy jz jb ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">测试很难，不要让它更难。试着不要过分指定你的测试，试着依赖稳定的东西。<strong class="ka jc"> </strong>是的，当你在做TDD的时候会有趣得多。</p><h2 id="2f47" class="mu lf jb bd lg mv mw dn lk mx my dp lo kj mz na ls kn nb nc lw kr nd ne ma nf bi translated">一些有用的链接。</h2><p id="d1bb" class="pw-post-body-paragraph jy jz jb ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">来自Robert C. Martin的测试定义—<a class="ae ld" href="https://blog.cleancoder.com/uncle-bob/2017/05/05/TestDefinitions.html" rel="noopener ugc nofollow" target="_blank">https://blog . clean coder . com/uncle-bob/2017/05/05/test definitions . html</a></p><p id="8b1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TDD:哪里出了问题——https://www.youtube.com/watch?v=EZ05e7EMOLM</p><p id="cbc3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ld" href="http://foobarbaz.club/" rel="noopener ugc nofollow" target="_blank">我博客上的更多文章<strong class="ka jc">foobarbaz . club</strong>T29】</a></p></div></div>    
</body>
</html>