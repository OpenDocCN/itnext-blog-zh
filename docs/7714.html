<html>
<head>
<title>Securely Ingressing into Bare Metal Kubernetes Clusters with Gateway API and Tailscale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用网关API和Tailscale安全地进入裸机Kubernetes集群</h1>
<blockquote>原文：<a href="https://itnext.io/securely-ingressing-into-bare-metal-kubernetes-clusters-with-gateway-api-and-tailscale-cc68299b646a?source=collection_archive---------1-----------------------#2022-12-30">https://itnext.io/securely-ingressing-into-bare-metal-kubernetes-clusters-with-gateway-api-and-tailscale-cc68299b646a?source=collection_archive---------1-----------------------#2022-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e677e789b25e863502b7995e9ebb802f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iytCszU_LvTawUoJMMDz4w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由树莓皮4制成的裸机Kubernetes集群</figcaption></figure><p id="1ba8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">避免将带有敏感数据的互联网应用程序暴露给公众是一项基本的安全实践，即使应用程序使用任何类型的身份验证，也应该始终保持这种做法。为了实现这一点，您可以设置一个虚拟专用网，并在本地DNS中解析专用负载平衡器的IP，这样只有您的VPN用户才能将流量路由到您的应用程序。</p><p id="06db" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您在AWS中运行您的平台，有像<a class="ae ld" href="https://aws.amazon.com/privatelink/" rel="noopener ugc nofollow" target="_blank"> AWS PrivateLink </a>这样的托管服务提供托管私有连接服务，因此您可以从外部VPC安全地访问您的私有NLB。但是，如果您有裸机集群，实现这种模式可能会有困难，因为您必须自己处理物理网络。</p><p id="5e28" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本文的目的是提供一个解决方案，通过利用具有免费层的开放源码技术来私有地访问裸机Kubernetes集群，所以您不会花一分钱！</p><p id="11ef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将使用<a class="ae ld" href="https://gateway-api.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">网关API </a>的实现来声明性地定义访问集群所需的网络资源。如果您熟悉Kubernetes，您可能知道在API网关中公开您的应用程序的<a class="ae ld" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口API </a>。为了克服它的局限性，<a class="ae ld" href="https://github.com/kubernetes/community/tree/master/sig-network" rel="noopener ugc nofollow" target="_blank"> SIG network </a>最近推出了它的继任者Gateway API。</p><h1 id="285a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是网关API？</h1><p id="5fd3" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">这个新的API引入了一组新的网络资源，可以在您的组织中更好地划分职责:</p><ul class=""><li id="b397" class="mh mi it kh b ki kj km kn kq mj ku mk ky ml lc mm mn mo mp bi translated"><code class="fe mq mr ms mt b"><a class="ae ld" href="https://gateway-api.sigs.k8s.io/api-types/gatewayclass/" rel="noopener ugc nofollow" target="_blank">GatewayClass</a></code>:定义一个<code class="fe mq mr ms mt b">Gateway</code>类的集群作用域资源，类似于它的前辈<a class="ae ld" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-class" rel="noopener ugc nofollow" target="_blank"> IngressClass </a>。它通常由基础设施提供商管理，以提供不同的网关风格，例如公共或私有。</li><li id="473c" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><code class="fe mq mr ms mt b"><a class="ae ld" href="https://gateway-api.sigs.k8s.io/api-types/gateway/" rel="noopener ugc nofollow" target="_blank">Gateway</a></code>:包含负载平衡基础设施配置的集群范围的资源，例如网络协议和TLS。平台团队负责维护所有应用程序共享的<code class="fe mq mr ms mt b">Gateway</code>资源，以路由流量。</li><li id="c4af" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><code class="fe mq mr ms mt b"><a class="ae ld" href="https://gateway-api.sigs.k8s.io/api-types/httproute/" rel="noopener ugc nofollow" target="_blank">HTTPRoute</a></code>:由应用程序团队管理，这个资源包含将HTTP流量映射到Kubernetes <code class="fe mq mr ms mt b">Service</code>资源的路由配置。</li></ul><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/2ee899a2fe8ed89afa7ad8608d32884b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XMgU2bZsTuv-qJsU.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用网关API资源的职责分离。网关API文档提供的图像</figcaption></figure><p id="cc2c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我们的例子中，这个想法是让两个不同的<code class="fe mq mr ms mt b">GatewayClass</code>对象能够声明我们是否希望<code class="fe mq mr ms mt b">Gateway</code>将其<code class="fe mq mr ms mt b">HTTPRoutes</code>暴露给互联网或Tailscale VPN。这样，在<code class="fe mq mr ms mt b">GatewayClass</code>和<code class="fe mq mr ms mt b">Gateway</code>资源中抽象出了为应用程序提供连接所需的网络细节，因此不会向开发人员公开，因此他们可以专注于配置他们的应用程序。反之亦然，平台工程师能够在不干扰应用团队的情况下执行他们的操作，例如，他们能够在应用团队没有注意的情况下配置新的TLS证书。</p><h1 id="93be" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">需求和架构</h1><p id="dafc" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">我们的集群将有两种不同类型的用户:</p><ul class=""><li id="c900" class="mh mi it kh b ki kj km kn kq mj ku mk ky ml lc mm mn mo mp bi translated"><strong class="kh iu">内部:</strong>使用本地网络或Tailscale VPN访问集群，该用户将能够访问内部和外部应用程序。</li><li id="85ec" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><strong class="kh iu">外部</strong>:位于网络外部，该用户将使用我们的公共IP路由到集群，只能访问外部应用程序。</li></ul><p id="ae51" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们应该为用户提供适当的DNS解析，这样他们就可以顺利地进入我们的集群，而不必记住IP地址。更准确地说，我们将提供这些DNS名称:</p><ul class=""><li id="634b" class="mh mi it kh b ki kj km kn kq mj ku mk ky ml lc mm mn mo mp bi translated"><strong class="kh iu">internal.mmontes.duckdns.org</strong>:它将由本地DNS服务器解析到我们内部的负载均衡器IP。</li><li id="c05b" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><strong class="kh iu">mmontes.duckdns.org</strong>:它会被一个公共DNS服务器解析到我们的外部负载均衡器IP。</li></ul><p id="66da" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的通信应该使用TLS加密，以避免<a class="ae ld" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank"> MITM </a>攻击并保证机密性，因此我们将使用Let's Encrypt为内部和外部端点颁发证书。</p><p id="b92a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">考虑到所有这些需求，这是我们解决方案的高级架构。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/3fb50cea08cff89b1f594db851a7a1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VL05eNLDC26cNLsB722rjg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我们目标体系结构的网络图</figcaption></figure><p id="7ba5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将放大每个组件以提供更多细节。</p><h1 id="c3fc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">尾秤</h1><p id="9f3e" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">为了能够从任何网络对我们的设备进行私有寻址，我们将引入<a class="ae ld" href="https://tailscale.com/" rel="noopener ugc nofollow" target="_blank"> Tailscale </a>，这是一种VPN服务，与其他集中式解决方案不同，它通过使用<a class="ae ld" href="https://www.wireguard.com/" rel="noopener ugc nofollow" target="_blank"> Wireguard </a>协议，实现您的设备之间的加密点对点连接。与传统的集中式VPN相比，这导致了更低的延迟。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/152a50728f8b0a5cb4b334d8c91ef437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XEGuobvjawJKiWAW.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用Tailscale的加密点对点连接。图片由Tailscale docs提供</figcaption></figure><p id="0ee4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Tailscale将为您创建一个虚拟专用网络，也称为<code class="fe mq mr ms mt b">tailnet</code>，在这里您可以安全地路由到您的设备。它还将在每台设备上创建一个网络接口，每当它向<code class="fe mq mr ms mt b">tailnet</code>中的一个IP发送流量时都会使用这个接口。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="e2b5" class="nk lf it mt b be nl nm l nn no">mmontes@k8s-worker0:~$ ifconfig<br/>...<br/>tailscale0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 1280<br/>        inet 100.80.97.21  netmask 255.255.255.255  destination 100.80.97.21<br/>        inet6 fe80::522b:a1ae:f74a:b97c  prefixlen 64  scopeid 0x20&lt;link&gt;<br/>        inet6 fd7a:115c:a1e0:ab12:4843:cd96:6250:6115  prefixlen 128  scopeid 0x0&lt;global&gt;<br/>        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 500  (UNSPEC)<br/>        RX packets 71147  bytes 31066579 (31.0 MB)<br/>        RX errors 0  dropped 0  overruns 0  frame 0<br/>        TX packets 62171  bytes 8793662 (8.7 MB)<br/>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span></pre><p id="f748" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了解析DNS名称，Tailscale有一个名为<a class="ae ld" href="https://tailscale.com/kb/1081/magicdns/" rel="noopener ugc nofollow" target="_blank"> MagicDNS </a>的功能，可以自动为<code class="fe mq mr ms mt b">tailnet</code>中的设备配置DNS名称。您也可以配置自己的DNS服务器，但是我们将在后面介绍。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="63c4" class="nk lf it mt b be nl nm l nn no">mmontes@raspi-ramallal:~ $ nslookup k8s-worker0<br/>Server:         100.100.100.100<br/>Address:        100.100.100.100#53<br/><br/>Name:   k8s-worker0.tail03db8.ts.net<br/>Address: 100.80.97.21</span></pre><p id="cb3e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">到目前为止，我们已经介绍了安装了Tailscale的设备的私有连接，但是，可能有一些设备无法运行Tailscale守护程序，但它们在您的本地网络中有一个IP，例如物联网设备。我们能从VPN解决这些问题吗？足够幸运的是，Tailscale已经覆盖了你，它们允许你配置设备作为<a class="ae ld" href="https://tailscale.com/kb/1019/subnets/" rel="noopener ugc nofollow" target="_blank">子网路由器</a>。您可以选择运行Tailscale的设备在<code class="fe mq mr ms mt b">tailnet</code>中通告您本地网络的CIDR。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="8dd8" class="nk lf it mt b be nl nm l nn no">#!/bin/bash<br/><br/>curl -fsSL https://pkgs.tailscale.com/stable/ubuntu/jammy.noarmor.gpg | tee /usr/share/keyrings/tailscale-archive-keyring.gpg &gt;/dev/null<br/>curl -fsSL https://pkgs.tailscale.com/stable/ubuntu/jammy.tailscale-keyring.list | tee /etc/apt/sources.list.d/tailscale.list<br/><br/>apt update<br/>apt install -y tailscale<br/><br/>tailscale up --advertise-routes=192.168.0.0/24</span></pre><p id="698e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们在这里宣传的是<code class="fe mq mr ms mt b">192.168.0.0/24</code> CIDR，因此我们将能够从生活在<code class="fe mq mr ms mt b">tailnet</code>的设备寻址该范围内的任何IP，即使它们不在同一个本地网络中。这将是我们设置的一个关键特性，因为我们需要在<code class="fe mq mr ms mt b">tailnet</code>中公布不能自己运行Tailscale的<code class="fe mq mr ms mt b">LoadBalancer</code>IP。</p><h1 id="ae97" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">引导集群</h1><p id="1c08" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">一旦连接就绪，接下来的事情将是配置主机并使用<a class="ae ld" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" rel="noopener ugc nofollow" target="_blank"> kubeadm </a>引导Kubernetes集群，但不幸的是这是一个广泛的主题，不适合本文(也许另一篇？)，所以这里是回购如果你想看看。</p><div class="np nq gp gr nr ns"><a href="https://github.com/mmontes11/k8s-bootstrap" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">GitHub—mmontes 11/k8s—引导程序:🚀使用kubeadm的Kubernetes集群引导</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">使用kubeadm的Kubernetes集群引导。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og jz ns"/></div></div></a></div><h1 id="fc99" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">流量</h1><p id="2c05" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">我们将遵循<a class="ae ld" href="https://opengitops.dev/" rel="noopener ugc nofollow" target="_blank"> GitOps </a>方法将工作负载部署到我们的集群。这意味着一组Kubernetes控制器将不断地协调git存储库的清单，因此我们实际上不需要手动操作集群，相反，我们只需声明所需的状态，控制器将确保实际状态符合我们的要求。</p><p id="75f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了实现这一点，我们将使用他们方便的<a class="ae ld" href="https://fluxcd.io/flux/cmd/" rel="noopener ugc nofollow" target="_blank"> CLI </a>安装<a class="ae ld" href="https://fluxcd.io/" rel="noopener ugc nofollow" target="_blank"> Flux </a>，它提供了一个<code class="fe mq mr ms mt b">bootstrap</code>子命令来快速启动控制平面并开始协调git repo。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="d778" class="nk lf it mt b be nl nm l nn no">mmontes@k8s-master:~$ flux bootstrap github \<br/>  --owner=mmontes11 \<br/>  --repository=mmontes11/k8s-infrastructure \<br/>  --branch=main \<br/>  --path=./clusters/production \<br/>  --personal \<br/>  --private=false</span></pre><p id="56c4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">运行该命令后，您将看到在<code class="fe mq mr ms mt b">flux-system</code>名称空间中出现流量控制平面，并且<code class="fe mq mr ms mt b">Kustomization</code>和<code class="fe mq mr ms mt b">HelmRelease</code>资源开始协调。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="cc06" class="nk lf it mt b be nl nm l nn no">mmontes@k8s-master:~$ kubectl get pods -n flux-system<br/>NAME                                       READY   STATUS    RESTARTS   AGE<br/>helm-controller-59f8b44dd5-sln4l           1/1     Running   0          7d11h<br/>kustomize-controller-7d475476b4-qhl8b      1/1     Running   0          7d11h<br/>notification-controller-677cf654b9-99kfp   1/1     Running   0          7d11h<br/>source-controller-dc97b975b-cwv88          1/1     Running   0          7d11h<br/><br/>mmontes@k8s-master:~$ kubectl get kustomizations -A<br/>NAMESPACE         NAME                             AGE     READY   STATUS<br/>flux-system       cert-manager                     12d     True    Applied revision: main/04437305d3780aca25115d5fe77ae193c48a3cc2<br/>flux-system       cert-manager-issuers             3h9m    True    Applied revision: main/04437305d3780aca25115d5fe77ae193c48a3cc2<br/>flux-system       dns                              12d     True    Applied revision: main/04437305d3780aca25115d5fe77ae193c48a3cc2<br/>flux-system       flux-system                      12d     True    Applied revision: main/04437305d3780aca25115d5fe77ae193c48a3cc2<br/>flux-system       gateway-api                      12d     True    Applied revision: main/04437305d3780aca25115d5fe77ae193c48a3cc2<br/>flux-system       kube-prometheus-stack            12d     True    Applied revision: main/04437305d3780aca25115d5fe77ae193c48a3cc2<br/>flux-system       kube-prometheus-stack-monitors   3h15m   True    Applied revision: main/04437305d3780aca25115d5fe77ae193c48a3cc2<br/>flux-system       metallb                          12d     True    Applied revision: main/04437305d3780aca25115d5fe77ae193c48a3cc2<br/>flux-system       networking                       12d     True    Applied revision: main/04437305d3780aca25115d5fe77ae193c48a3cc2<br/>flux-system       traefik                          12d     True    Applied revision: main/04437305d3780aca25115d5fe77ae193c48a3cc2<br/>flux-system       traefik-config                   3h15m   True    Applied revision: main/04437305d3780aca25115d5fe77ae193c48a3cc2<br/>...<br/><br/>mmontes@k8s-master:~$ kubectl get helmrelease -A<br/>NAMESPACE         NAME                         AGE    READY   STATUS<br/>dns               duckdns                      12d    True    Release reconciliation succeeded<br/>dns               pihole                       12d    True    Release reconciliation succeeded<br/>monitoring        kube-prometheus-stack        12d    True    Release reconciliation succeeded<br/>networking        metallb                      12d    True    Release reconciliation succeeded<br/>networking        traefik-external             10d    True    Release reconciliation succeeded<br/>networking        traefik-internal             10d    True    Release reconciliation succeeded<br/>pki               cert-manager                 12d    True    Release reconciliation succeeded<br/>pki               letsencrypt                  3h8m   True    Release reconciliation succeeded<br/>...</span></pre><p id="d24e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里是Flux正在协调的回购协议，接下来的部分将介绍安装和配置所有可用的网络组件，不过您可以随意查看。</p><div class="np nq gp gr nr ns"><a href="https://github.com/mmontes11/k8s-infrastructure" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">GitHub-mmontes 11/k8s-基础设施:🏗使用Flux的️基础设施和租户引导</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">使用Flux的基础设施和租户引导。当…时，Flux使用的每个簇的入口点</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og jz ns"/></div></div></a></div><h1 id="76a8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">金属lb</h1><p id="34c2" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">为了提高可用性，我们将使用<code class="fe mq mr ms mt b">LoadBalancer</code>服务进入我们的集群。与托管Kubernetes产品不同，IP不会自动提供给<code class="fe mq mr ms mt b">LoadBalancer</code>服务，它们将保持待定状态。在裸机集群中自动配置这些IP不是很好吗？这是Kubernetes控制器<a class="ae ld" href="https://metallb.universe.tf/" rel="noopener ugc nofollow" target="_blank"> Metallb </a>的使命，它为您的<code class="fe mq mr ms mt b">LoadBalancer</code>服务提供和分配IP地址，与云提供商的做法相同。</p><p id="0e1f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将使用<code class="fe mq mr ms mt b">HelmRelease</code>在集群中安装Metallb。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="aaee" class="nk lf it mt b be nl nm l nn no">apiVersion: helm.toolkit.fluxcd.io/v2beta1<br/>kind: HelmRelease<br/>metadata:<br/>  name: metallb<br/>spec:<br/>  chart:<br/>    spec:<br/>      chart: metallb<br/>      sourceRef:<br/>        kind: HelmRepository<br/>        name: metallb<br/>      version: "0.13.7"<br/>  interval: 1h0m0s<br/>  values:<br/>    prometheus:<br/>      rbacPrometheus: true<br/>      serviceAccount: metallb<br/>      namespace: networking<br/>      serviceMonitor:<br/>        enabled: true<br/>        controller:<br/>          additionalLabels:<br/>            release: kube-prometheus-stack<br/>        speaker:<br/>          additionalLabels:<br/>            release: kube-prometheus-stack</span></pre><p id="253f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后，我们将声明一个<code class="fe mq mr ms mt b">IPAddressPool</code>来提供一系列IP供<code class="fe mq mr ms mt b">LoadBalancer</code>服务稍后使用。正如我们之前提到的，Tailscale的子网路由器在VPN中通告了<code class="fe mq mr ms mt b">192.168.0.0/24</code> CIDR，我们需要确保<code class="fe mq mr ms mt b">IPAddressPool</code>中声明的IP覆盖了这个范围，以便它们可以从VPN寻址。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="a8fd" class="nk lf it mt b be nl nm l nn no">apiVersion: metallb.io/v1beta1<br/>kind: IPAddressPool<br/>metadata:<br/>  name: load-balancer<br/>spec:<br/>  addresses:<br/>    - 192.168.0.50-192.168.0.99</span></pre><p id="ac30" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">默认情况下，这个IP池不会在本地网络中公布，我们需要创建一个<code class="fe mq mr ms mt b">L2Advertisement</code>来这样做。否则，流量不会被路由到这些IP。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="c0c8" class="nk lf it mt b be nl nm l nn no">apiVersion: metallb.io/v1beta1<br/>kind: L2Advertisement<br/>metadata:<br/>  name: l2advertisement<br/>spec:<br/>  ipAddressPools:<br/>    - load-balancer</span></pre><p id="4ca9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你想知道Metallb是如何在幕后做L2广告的，看看这些<a class="ae ld" href="https://metallb.universe.tf/configuration/_advanced_l2_configuration/" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><h1 id="d963" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">DuckDNS</h1><p id="8619" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">下一步将是建立一个公共DNS记录来解析我们的公共IP，这样我们就可以从外部网络寻址我们的集群。这将使我们能够解决DNS01挑战，以便稍后使用“让我们加密”来颁发TLS证书。我们将使用<a class="ae ld" href="https://www.duckdns.org/" rel="noopener ugc nofollow" target="_blank"> DuckDNS </a>，一个免费提供<code class="fe mq mr ms mt b">duckdns.org</code>子域名的DNS提供商。</p><p id="9cc9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为我有一个动态的IP地址，所以我需要定期更新DNS记录，这有可能通过<a class="ae ld" href="https://hub.docker.com/r/linuxserver/duckdns" rel="noopener ugc nofollow" target="_blank"> linuxserver/duckdns </a>映像自动完成。它在内部创建一个crontab，使用DuckDNS API定期更新您的公共IP。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="a47d" class="nk lf it mt b be nl nm l nn no">apiVersion: helm.toolkit.fluxcd.io/v2beta1<br/>kind: HelmRelease<br/>metadata:<br/>  name: duckdns<br/>spec:<br/>  releaseName: duckdns<br/>  chart:<br/>    spec:<br/>      chart: duckdns<br/>      sourceRef:<br/>        kind: HelmRepository<br/>        name: mmontes<br/>        namespace: flux-system<br/>      version: "0.3.0"<br/>  interval: 5m<br/>  values:<br/>    image:<br/>      repository: linuxserver/duckdns<br/>      pullPolicy: IfNotPresent<br/>      tag: 0168fda3-ls117<br/><br/>    subdomains:<br/>      - mmontes.duckdns.org<br/>    ...<br/>    secretRef:<br/>      name: duckdns</span></pre><h1 id="fd29" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">证书管理器</h1><p id="9edd" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">如果不正确地自动化TLS证书的颁发和轮换，会使您的群集操作变得非常复杂。为此，我们将使用<a class="ae ld" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank"> cert-manager </a>，它是一个Kubernetes操作者，负责在您的Kubernetes集群中颁发和更新x.509证书。</p><p id="5173" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它支持多个证书源，包括集群内CAs、Hashicorp Vault、Venafi和Let's Encrypt。由于我们想要一个由所有客户端都信任的公共CA颁发的证书，我们将使用自动化证书管理环境(<a class="ae ld" href="https://cert-manager.io/docs/configuration/acme/" rel="noopener ugc nofollow" target="_blank"> ACME </a>)颁发者在<a class="ae ld" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">让我们加密</a>中颁发证书。</p><p id="3e49" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一件事将是使用另一个<code class="fe mq mr ms mt b">HelmRelease</code>资源安装cert-manager。请注意，我们已经启用了一个实验性的特性gate来与Gateway API集成，我们将在后面进行介绍。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="0c93" class="nk lf it mt b be nl nm l nn no">apiVersion: helm.toolkit.fluxcd.io/v2beta1<br/>kind: HelmRelease<br/>metadata:<br/>  name: cert-manager<br/>spec:<br/>  chart:<br/>    spec:<br/>      chart: cert-manager<br/>      sourceRef:<br/>        kind: HelmRepository<br/>        name: jetstack<br/>      version: "1.10.1"<br/>  interval: 1h0m0s<br/>  values:<br/>    installCRDs: true<br/>    featureGates: "ExperimentalGatewayAPISupport=true"<br/>    prometheus:<br/>      enabled: true<br/>      servicemonitor:<br/>        enabled: true<br/>        prometheusInstance: kube-prometheus-stack<br/>        labels:<br/>          release: kube-prometheus-stack</span></pre><p id="889c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mq mr ms mt b">Certificate</code>资源是与证书管理器交互的方式。它们引用了<code class="fe mq mr ms mt b">Issuer</code>或<code class="fe mq mr ms mt b">ClusterIssuer</code>资源，这就是我们将要配置的。我们将为Let's创建一个<code class="fe mq mr ms mt b">ClusterIssuer</code>,用<a class="ae ld" href="https://cert-manager.io/docs/configuration/acme/dns01/" rel="noopener ugc nofollow" target="_blank"> DNS01挑战求解器</a>进行加密，以便发布通配符证书。这个解算器在DuckDNS中创建了一个TXT记录，所以我们可以验证我们是这个域名的合法所有者。</p><p id="df6f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不幸的是，证书管理器本身不支持DuckDNS，所以我们需要使用<a class="ae ld" href="https://cert-manager.io/docs/configuration/acme/dns01/webhook/" rel="noopener ugc nofollow" target="_blank"> webhook </a>解算器。这个<a class="ae ld" href="https://github.com/ebrianne/cert-manager-webhook-duckdns/tree/master/deploy/cert-manager-webhook-duckdns" rel="noopener ugc nofollow" target="_blank">舵图</a>很好的抽象了<code class="fe mq mr ms mt b">ClusterIssuer</code>和准入webhook服务器的创建。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="9a97" class="nk lf it mt b be nl nm l nn no">apiVersion: helm.toolkit.fluxcd.io/v2beta1<br/>kind: HelmRelease<br/>metadata:<br/>  name: letsencrypt<br/>spec:<br/>  chart:<br/>    spec:<br/>      chart: cert-manager-webhook-duckdns<br/>      sourceRef:<br/>        kind: HelmRepository<br/>        name: letsencrypt<br/>      version: "v1.2.4"<br/>  interval: 1h0m0s<br/>  values:<br/>    fullnameOverride: letsencrypt<br/>    groupName: mmontes.io<br/><br/>    certManager:<br/>      namespace: pki<br/>      serviceAccountName: cert-manager<br/><br/>    secret:<br/>      existingSecret: true<br/>      existingSecretName: "duckdns"<br/><br/>    clusterIssuer:<br/>      email: martin11lrx@gmail.com<br/>      staging:<br/>        create: true<br/>      production:<br/>        create: true</span></pre><p id="05d9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一旦一切就绪并开始运行，您应该能够看到您的<code class="fe mq mr ms mt b">ClusterIssuer</code>资源已经准备好发布证书。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="49ee" class="nk lf it mt b be nl nm l nn no">mmontes@k8s-master:~$ kubectl get clusterissuer -n pki -o wide<br/>NAME                     READY   STATUS                                                 AGE<br/>letsencrypt-production   True    The ACME account was registered with the ACME server   21h<br/>letsencrypt-staging      True    The ACME account was registered with the ACME server   21h</span></pre><h1 id="92e8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">网关API</h1><p id="0066" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">由于Gateway API仍处于早期阶段，它还没有与Kubernetes一起开箱即用。正如在<a class="ae ld" href="https://gateway-api.sigs.k8s.io/guides/#install-experimental-channel" rel="noopener ugc nofollow" target="_blank">文档</a>中所描述的，我们需要安装一个包含CRD和许可webhook服务器的清单包来验证它们。在我们的例子中，我们可以通过协调这个指向我们的回购路径的<code class="fe mq mr ms mt b">Kustomization</code>来安装它们。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="ce1d" class="nk lf it mt b be nl nm l nn no">apiVersion: kustomize.toolkit.fluxcd.io/v1beta2<br/>kind: Kustomization<br/>metadata:<br/>  name: gateway-api<br/>  namespace: flux-system<br/>spec:<br/>  interval: 5m<br/>  sourceRef:<br/>    kind: GitRepository<br/>    name: flux-system<br/>  path: ./infrastructure/gateway-api<br/>  prune: true<br/>  timeout: 5m</span></pre><p id="bd77" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们完成时，我们将配置<code class="fe mq mr ms mt b">GatewayClass</code>和<code class="fe mq mr ms mt b">Gateway</code>资源。正如我们之前提到的，我们的目标是抽象我们正在建立的连接，因此应用程序开发人员只需要决定他们是在他们的<code class="fe mq mr ms mt b">HTTPRoute</code>资源中引用内部的还是外部的<code class="fe mq mr ms mt b">Gateway</code>。</p><p id="b3ee" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">关于平台方面的事情，cert-manager可以自动为我们的<code class="fe mq mr ms mt b">Gateway</code>资源颁发TLS证书，我们只需要添加<code class="fe mq mr ms mt b">cert-manager.io/cluster-issuer</code>注释来指示我们想要使用哪个<code class="fe mq mr ms mt b">ClusterIssuer</code>。在这些场景下，cert-manager将监视带注释的<code class="fe mq mr ms mt b">Gateway</code>资源，并为<code class="fe mq mr ms mt b">listeners</code>数组下的<code class="fe mq mr ms mt b">hostname</code>字段颁发证书。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="b6e0" class="nk lf it mt b be nl nm l nn no">apiVersion: gateway.networking.k8s.io/v1alpha2<br/>kind: GatewayClass<br/>metadata:<br/>  name: traefik-external<br/>  labels:<br/>    gatewayclass.mmontes.io/type: traefik-external<br/>spec:<br/>  controllerName: traefik.io/gateway-controller<br/>---<br/>apiVersion: gateway.networking.k8s.io/v1beta1<br/>kind: Gateway<br/>metadata:<br/>  name: traefik-external<br/>  annotations:<br/>    cert-manager.io/cluster-issuer: letsencrypt-production<br/>spec:<br/>  gatewayClassName: traefik-external<br/>  listeners:<br/>    - name: websecure<br/>      port: 8443<br/>      protocol: HTTPS<br/>      hostname: "*.mmontes.duckdns.org"<br/>      allowedRoutes:<br/>        namespaces:<br/>          from: All<br/>      tls:<br/>        mode: Terminate<br/>        certificateRefs:<br/>          - name: websecure-external-tls<br/>            kind: Secret<br/>            group: core</span></pre><p id="350b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要另一个专用于内部流量的<code class="fe mq mr ms mt b">Gateway</code>和<code class="fe mq mr ms mt b">GatewayClass</code>实例。唯一的区别是<code class="fe mq mr ms mt b">Gateway</code>将匹配<code class="fe mq mr ms mt b">internal.mmontes.duckdns.org</code>主机名。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="3d37" class="nk lf it mt b be nl nm l nn no">apiVersion: gateway.networking.k8s.io/v1alpha2<br/>kind: GatewayClass<br/>metadata:<br/>  name: traefik-internal<br/>  labels:<br/>    gatewayclass.mmontes.io/type: traefik-internal<br/>spec:<br/>  controllerName: traefik.io/gateway-controller<br/>---<br/>apiVersion: gateway.networking.k8s.io/v1beta1<br/>kind: Gateway<br/>metadata:<br/>  name: traefik-internal<br/>  annotations:<br/>    cert-manager.io/cluster-issuer: letsencrypt-production<br/>spec:<br/>  gatewayClassName: traefik-internal<br/>  listeners:<br/>    - name: websecure<br/>      port: 8443<br/>      protocol: HTTPS<br/>      hostname: "*.internal.mmontes.duckdns.org"<br/>      allowedRoutes:<br/>        namespaces:<br/>          from: All<br/>      tls:<br/>        mode: Terminate<br/>        certificateRefs:<br/>          - name: websecure-internal-tls<br/>            kind: Secret<br/>            group: core</span></pre><p id="ba5a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">值得注意的是，已安装的<code class="fe mq mr ms mt b">Gateway</code>资源没有在我们的集群中运行的实现，因此它们将保持未就绪状态，直到我们提供一个实现。</p><h1 id="4c14" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">特拉菲克</h1><p id="dcf8" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">安装网关API资源后，我们将安装<a class="ae ld" href="https://doc.traefik.io/traefik/providers/kubernetes-gateway/" rel="noopener ugc nofollow" target="_blank"> Traefik </a>来协调它们，并配置集群的入口。正如我们在前面的章节中所描述的，目标架构将有两个Traefik实例来满足我们的连接需求:<code class="fe mq mr ms mt b">traefik-internal</code>和<code class="fe mq mr ms mt b">traefik-external</code>。</p><p id="0ed5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">前一个将使用来自<code class="fe mq mr ms mt b">traefik-internal</code> <code class="fe mq mr ms mt b">Gateway</code>的配置，并将通过在<code class="fe mq mr ms mt b">192.168.0.50</code> IP中公布的<code class="fe mq mr ms mt b">LoadBalancer</code>公开，稍后将由本地DNS解析。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="09e7" class="nk lf it mt b be nl nm l nn no">apiVersion: helm.toolkit.fluxcd.io/v2beta1<br/>kind: HelmRelease<br/>metadata:<br/>  name: traefik-internal<br/>spec:<br/>  chart:<br/>    spec:<br/>      chart: traefik<br/>      sourceRef:<br/>        kind: HelmRepository<br/>        name: traefik<br/>      version: "20.8.0"<br/>  interval: 1h0m0s<br/>  values:<br/>    ...<br/>    additionalArguments:<br/>      - "--experimental.kubernetesgateway"<br/>      - "--providers.kubernetesgateway"<br/>      - "--providers.kubernetesgateway.labelselector=gatewayclass.mmontes.io/type=traefik-internal"<br/>    service:<br/>      annotations:<br/>        metallb.universe.tf/loadBalancerIPs: 192.168.0.50<br/>    deployment:<br/>      enabled: true<br/>      kind: DaemonSet<br/>    resources:<br/>      requests:<br/>        cpu: "300m"<br/>        memory: "200Mi"<br/>      limits:<br/>        memory: "200Mi"</span></pre><p id="dc8c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">而后者将使用在<code class="fe mq mr ms mt b">traefik-external</code> <code class="fe mq mr ms mt b">Gateway</code>资源中提供的配置，并通过在<code class="fe mq mr ms mt b">192.168.0.90</code> IP中公布的<code class="fe mq mr ms mt b">LoadBalancer</code>公开，稍后我们将通过路由器中的端口转发向互联网公开。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="e33e" class="nk lf it mt b be nl nm l nn no">apiVersion: helm.toolkit.fluxcd.io/v2beta1<br/>kind: HelmRelease<br/>metadata:<br/>  name: traefik-external<br/>spec:<br/>  chart:<br/>    spec:<br/>      chart: traefik<br/>      sourceRef:<br/>        kind: HelmRepository<br/>        name: traefik<br/>      version: "20.8.0"<br/>  interval: 1h0m0s<br/>  values:<br/>    ...<br/>    additionalArguments:<br/>      - "--serverstransport.insecureskipverify"<br/>      - "--experimental.kubernetesgateway"<br/>      - "--providers.kubernetesgateway"<br/>      - "--providers.kubernetesgateway.labelselector=gatewayclass.mmontes.io/type=traefik-external"<br/>    service:<br/>      annotations:<br/>        metallb.universe.tf/loadBalancerIPs: 192.168.0.90<br/>    deployment:<br/>      enabled: true<br/>      kind: DaemonSet<br/>    resources:<br/>      requests:<br/>        cpu: "300m"<br/>        memory: "200Mi"<br/>      limits:<br/>        memory: "200Mi"</span></pre><p id="627b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当Traefik实例启动并运行时，<code class="fe mq mr ms mt b">Gateway</code>资源应该准备好了。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="363b" class="nk lf it mt b be nl nm l nn no">mmontes@k8s-master:~$ kubectl get gateway -n networking<br/>NAME               CLASS              ADDRESS   READY   AGE<br/>traefik-external   traefik-external             True    11d<br/>traefik-internal   traefik-internal             True    11d</span></pre><h1 id="b277" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">应用程序</h1><p id="6ae7" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">此时，我们能够配置<code class="fe mq mr ms mt b">HTTPRoute</code>资源，以便通过新的<code class="fe mq mr ms mt b">Gateways</code>公开我们的应用程序。第一个将是<a class="ae ld" href="https://github.com/mmontes11/github-explorer" rel="noopener ugc nofollow" target="_blank"> GitHub explorer </a>，它将对公共互联网上的任何人开放。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="76aa" class="nk lf it mt b be nl nm l nn no">apiVersion: gateway.networking.k8s.io/v1beta1<br/>kind: HTTPRoute<br/>metadata:<br/>  name: github-explorer<br/>spec:<br/>  hostnames:<br/>    - github-explorer.mmontes.duckdns.org<br/>  parentRefs:<br/>    - group: gateway.networking.k8s.io<br/>      kind: Gateway<br/>      name: traefik-external<br/>      namespace: networking<br/>  rules:<br/>    - backendRefs:<br/>      - kind: Service<br/>        name: github-explorer<br/>        port: 80</span></pre><p id="d931" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另一个将是Grafana，但在这种情况下，它将只在内部曝光。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="7924" class="nk lf it mt b be nl nm l nn no">apiVersion: gateway.networking.k8s.io/v1beta1<br/>kind: HTTPRoute<br/>metadata:<br/>  name: grafana<br/>spec:<br/>  parentRefs:<br/>    - name: traefik-internal<br/>      namespace: networking<br/>  hostnames:<br/>    - "grafana.internal.mmontes.duckdns.org"<br/>  rules:<br/>    - backendRefs:<br/>      - kind: Service<br/>        name: kube-prometheus-stack-grafana<br/>        port: 80</span></pre><h1 id="7f81" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">皮霍尔</h1><p id="b97e" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">既然<code class="fe mq mr ms mt b">traefik-internal</code>正在为<code class="fe mq mr ms mt b">192.168.0.50</code> IP上的流量提供服务，我们需要在我们的VPN中配置一个本地DNS来将<code class="fe mq mr ms mt b">internal.mmontes.duckdns.org</code>解析到那个IP。为此，我们将部署一个<a class="ae ld" href="https://pi-hole.net/" rel="noopener ugc nofollow" target="_blank"> Pihole </a>作为我们的本地DNS服务器。</p><pre class="na nb nc nd gt ng mt nh bn ni nj bi"><span id="7bf0" class="nk lf it mt b be nl nm l nn no">apiVersion: helm.toolkit.fluxcd.io/v2beta1<br/>kind: HelmRelease<br/>metadata:<br/>  name: pihole<br/>spec:<br/>  releaseName: pihole<br/>  chart:<br/>    spec:<br/>      chart: pihole<br/>      sourceRef:<br/>        kind: HelmRepository<br/>        name: pihole<br/>      version: "2.11.0"<br/>  interval: 1h0m0s<br/>  values:<br/>    image:<br/>      repository: "pihole/pihole"<br/>      pullPolicy: IfNotPresent<br/><br/>    serviceDns:<br/>      mixedService: false<br/>      type: LoadBalancer<br/>      port: 53<br/>      externalTrafficPolicy: Local<br/>      annotations:<br/>        metallb.universe.tf/loadBalancerIPs: 192.168.0.53<br/>        metallb.universe.tf/allow-shared-ip: pihole-dns-tcp,pihole-dns-udp<br/>    ...    <br/>    dnsmasq:<br/>      customDnsEntries:<br/>        - address=/internal.mmontes.duckdns.org/192.168.0.50</span></pre><p id="6fa3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如您所知，本地DNS服务器将在<code class="fe mq mr ms mt b">192.168.0.53</code> IP上可用，这也是Tailscale子网路由器通告的。现在我们能够配置Tailscale来使用这个DNS服务器。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/cb70d1344471a3534b0ac0e7185ff6ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6A11hf_Eh-qsJYr4PoM1rA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Tailscale DNS配置。在DNS &gt;添加名称服务器&gt;自定义中可用</figcaption></figure><h1 id="cc60" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">路由器</h1><p id="b040" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">最后但同样重要的是，我们需要将<code class="fe mq mr ms mt b">192.168.0.90</code>公开给互联网，以使<code class="fe mq mr ms mt b">traefik-external</code>公开的应用程序可用。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/344f7da21692d6580b3a0eaf3e56869a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTUfd1yZU7wcU9KkL8gL-w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在路由器中配置端口转发</figcaption></figure><p id="ab12" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">可选地，本地DNS可以被配置为本地网络的DNS，这样本地网络内部的设备不需要连接到VPN来访问内部应用。另一个好处是，Pihole将在DNS级别阻止广告。</p><h1 id="deb0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测试连通性</h1><p id="1761" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">最后，关键时刻到了，我们将在不同的场景中测试访问外部应用程序<code class="fe mq mr ms mt b"><a class="ae ld" href="https://github-explorer.mmontes.duckdns.org/" rel="noopener ugc nofollow" target="_blank">https://github-explorer.mmontes.duckdns.org</a></code>和内部应用程序<code class="fe mq mr ms mt b"><a class="ae ld" href="https://grafana.internal.mmontes.duckdns.org/" rel="noopener ugc nofollow" target="_blank">https://grafana.internal.mmontes.duckdns.org</a></code>的连接性。</p><p id="f550" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们从Tailscale VPN内部访问:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/af34dfed8cef2212808629863270e81d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*44yzkjsSimW8En2rPVaZOg.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">从Tailscale VPN成功访问外部应用程序</figcaption></figure><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/ec9a280a1bdcc0d388acc364042b2f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JROuJzpw1EkEr1EEi9Mtsw.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">从Tailscale VPN成功访问内部应用程序</figcaption></figure><p id="2437" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过使用Tailscale DNS服务器<code class="fe mq mr ms mt b">100.100.100.100</code>解析它们的DNS名称，我们成功地连接到了这两个应用程序。让我们再试一次，但这次是从外部网络连接。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/2f2e2efcc610749a33ff312eae283a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5mE39LAW81ZW1Tnqa6-oig.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">从外部网络成功访问外部应用程序</figcaption></figure><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/3e60e4a7aedb290293cb8f7701f839bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Uu8FDweLOfH4V1-d8Fk1RA.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">试图从外部网络访问内部应用程序</figcaption></figure><p id="81fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们设法连接到外部应用程序，但在尝试连接到内部应用程序时，我们得到了一个404错误，这是预期的行为。在引擎盖下，内部应用程序DNS被解析为我们的公共IP，因此正在点击<code class="fe mq mr ms mt b">traefik-external</code>，它没有注册内部应用程序。</p><h1 id="2deb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包扎</h1><p id="5feb" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">我们已经释放了新的网关API的力量来设计一个解决方案，实现平台和应用程序团队之间更好的协作。我们抽象了<code class="fe mq mr ms mt b">Gateway</code>资源中的平台细节，因此应用团队只需在<code class="fe mq mr ms mt b">HTTPRoutes</code>中声明他们的应用需要哪种连接模型。</p><p id="c91f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了给那些<code class="fe mq mr ms mt b">Gateways</code>提供连接，我们通过使用Metallb和Tailscale的一些出色功能，设法从我们的VPN内部寻址我们的<code class="fe mq mr ms mt b">LoadBalancer</code>IP。这实现了到我们在Kubernetes中运行的工作负载的加密点对点连接，与传统的集中式VPN解决方案相比，延迟更低。</p><p id="bc93" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">黑客快乐！感谢阅读。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><h1 id="0eee" class="le lf it bd lg lh os lj lk ll ot ln lo lp ou lr ls lt ov lv lw lx ow lz ma mb bi translated">资源</h1><div class="np nq gp gr nr ns"><a href="https://github.com/mmontes11/k8s-bootstrap" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">GitHub - mmontes11/k8s-bootstrap:🚀使用kubeadm的Kubernetes集群引导</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">使用kubeadm的Kubernetes集群引导。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og jz ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://github.com/mmontes11/k8s-infrastructure" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">GitHub-mmontes 11/k8s-基础设施:🏗使用Flux的️基础设施和租户引导</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">使用Flux的基础设施和租户引导。当…时，Flux使用的每个簇的入口点</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og jz ns"/></div></div></a></div><ul class=""><li id="ff65" class="mh mi it kh b ki kj km kn kq mj ku mk ky ml lc mm mn mo mp bi translated"><a class="ae ld" href="https://github.com/kubernetes/community/tree/master/sig-network" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/community/tree/master/SIG-network</a></li><li id="0691" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><a class="ae ld" href="https://gateway-api.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">https://gateway-api.sigs.k8s.io/</a></li><li id="aea6" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><a class="ae ld" href="https://tailscale.com/" rel="noopener ugc nofollow" target="_blank">https://tailscale.com/</a></li><li id="8029" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><a class="ae ld" href="https://tailscale.com/kb/1081/magicdns/" rel="noopener ugc nofollow" target="_blank">https://tailscale.com/kb/1081/magicdns/</a></li><li id="a9c4" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><a class="ae ld" href="https://tailscale.com/kb/1019/subnets/" rel="noopener ugc nofollow" target="_blank">https://tailscale.com/kb/1019/subnets/</a></li><li id="3a79" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><a class="ae ld" href="https://traefik.io/" rel="noopener ugc nofollow" target="_blank">https://traefik.io/</a></li><li id="afc6" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><a class="ae ld" href="https://doc.traefik.io/traefik/providers/kubernetes-gateway/" rel="noopener ugc nofollow" target="_blank">https://doc . trae fik . io/trae fik/providers/kubernetes-gateway/</a></li><li id="521f" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><a class="ae ld" href="https://metallb.universe.tf/" rel="noopener ugc nofollow" target="_blank">https://metallb.universe.tf/</a></li><li id="26e4" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><a class="ae ld" href="https://metallb.universe.tf/configuration/_advanced_l2_configuration/" rel="noopener ugc nofollow" target="_blank">https://metal lb . universe . TF/configuration/_ advanced _ L2 _ configuration/</a></li><li id="6946" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><a class="ae ld" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank">https://cert-manager.io/</a></li><li id="9b6b" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated">https://cert-manager.io/docs/configuration/acme/dns01/<a class="ae ld" href="https://cert-manager.io/docs/configuration/acme/" rel="noopener ugc nofollow" target="_blank"/></li><li id="9626" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated">【https://pi-hole.net/ T4】</li><li id="3c56" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><a class="ae ld" href="https://www.duckdns.org/" rel="noopener ugc nofollow" target="_blank">https://www.duckdns.org/</a></li><li id="047d" class="mh mi it kh b ki mu km mv kq mw ku mx ky my lc mm mn mo mp bi translated"><a class="ae ld" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">https://letsencrypt.org/</a></li></ul></div></div>    
</body>
</html>