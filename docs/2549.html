<html>
<head>
<title>Handling data with Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web组件处理数据</h1>
<blockquote>原文：<a href="https://itnext.io/handling-data-with-web-components-9e7e4a452e6e?source=collection_archive---------0-----------------------#2019-06-13">https://itnext.io/handling-data-with-web-components-9e7e4a452e6e?source=collection_archive---------0-----------------------#2019-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/65949d7799265cbbae71c054ea537ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HE2iWxwtz4uuSYFz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@dnevozhai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Denys Nevozhai </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ddcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您在过去几年中没有生活在岩石下，您可能听说过术语Web组件，这是一个API集合，用于轻松扩展现有的HTML，并且用于构建可重用的组件，而不需要像React这样的框架。</p><p id="44f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，大多数开发人员倾向于支持上述框架，因为它们给了他们更多的工具和灵活性。像数据绑定和状态管理这样的东西，对于构建数据驱动的交互式ui来说无疑是很重要的。</p><p id="d1a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React的例子中，还有另一个很棒的概念:<a class="ae kc" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank">道具</a>。它的API提供了一种将数据从父组件传递到其子组件的简单而直接的方式。这个数据实际上可以是任何东西；字符串、数字、对象甚至函数。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e7e8" class="lk ll iq lg b gy lm ln l lo lp">&lt;MyComponent<br/>  variant="primary"<br/>  onUpdate={functionCallback)}<br/>  items={[1, 2, 3]}<br/>/&gt;</span></pre><p id="dea4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> Web组件</a>，或者更确切地说<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements" rel="noopener ugc nofollow" target="_blank">定制元素</a>，有一个类似的概念叫做属性和特性。然而，不幸的是，它们使用起来略有不同，不如React道具舒适。</p><p id="a271" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看如何通过4种不同的方式实现同样的事情——将复杂的数据传递到我们的自定义元素中，好吗？</p><h1 id="ef57" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">#1 —使用属性</h1><p id="471c" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">属性是将数据传递到自定义元素的最简单方法:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0d5f" class="lk ll iq lg b gy lm ln l lo lp">&lt;custom-list filter="some filter"&gt;&lt;/custom-list&gt;</span></pre><p id="2309" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">定制元素的属性与我们已经知道并喜欢的属性没有什么不同:<code class="fe ms mt mu lg b">class</code>、<code class="fe ms mt mu lg b">value</code>、<code class="fe ms mt mu lg b">label</code>以及更多我们每天在HTML中使用的属性。甚至还有一个所有可用标准属性的列表<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes" rel="noopener ugc nofollow" target="_blank">作为参考。让我们看一些代码:</a></p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4ad8" class="lk ll iq lg b gy lm ln l lo lp">&lt;img src="image-1.jpg" alt="Some image"&gt;</span><span id="9add" class="lk ll iq lg b gy mv ln l lo lp">&lt;script&gt;<br/>  var img = document.getElementsByTagName("img")[0];</span><span id="fbfc" class="lk ll iq lg b gy mv ln l lo lp">  img.getAttribute("src"); // -&gt; "image-1.jpg"<br/>  img.getAttribute("alt"); // -&gt; "Some image"<br/>&lt;/script&gt;</span></pre><p id="8224" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们创建了一个新的图像元素，并传递了一些属性，比如<code class="fe ms mt mu lg b">src</code>和<code class="fe ms mt mu lg b">alt</code>。使用<code class="fe ms mt mu lg b">getAttribute()</code>函数，可以在JavaScript中访问所有这些属性。</p><p id="4b23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您使用过DOM，您可能知道有一种方法不仅可以获取属性，还可以设置属性:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0b27" class="lk ll iq lg b gy lm ln l lo lp">img.setAttribute("src", "new-image.jpg");</span></pre><p id="0e44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们用一个不同的图像源替换了旧的图像源，如果您的网站上有这个图像，它将会继续从新的路径下载。</p><p id="bbdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样的概念也适用于定制元素，但是您可以自由选择如何命名每个属性。因为自定义元素必须总是扩展<code class="fe ms mt mu lg b">HTMLElement</code>，所以我们可以免费获得这个行为。</p><p id="3c36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从上面看一下<code class="fe ms mt mu lg b">custom-list</code>元素的实现:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c780" class="lk ll iq lg b gy lm ln l lo lp">class CustomList extends HTMLElement {<br/>  constructor() {<br/>    super();</span><span id="b9c7" class="lk ll iq lg b gy mv ln l lo lp">    console.log(this.getAttribute("filter"));<br/>  }<br/>}</span><span id="38ad" class="lk ll iq lg b gy mv ln l lo lp">customElements.define("custom-list", CustomList);</span></pre><ul class=""><li id="fb6f" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">你首先会注意到的是构造函数，我们称之为<code class="fe ms mt mu lg b">super()</code>。您不必总是使用构造函数，因此可以省去这段代码，但在某些情况下，构造函数非常有用，例如在初始化属性、状态、事件侦听器或其他与元素相关的内容时。请记住:一旦使用了构造函数，就需要调用<code class="fe ms mt mu lg b">super()</code>来让定制元素正常工作。</li><li id="0473" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">下面，我们记录了<code class="fe ms mt mu lg b">this.getAttribute("filter")</code>，它将打印出我们在HTML中赋予<code class="fe ms mt mu lg b">filter</code>的任何值。</li><li id="c031" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">在最后一行，我们只需注册定制元素，使其在全球范围内可用。</li></ul><p id="5ce1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了查看结果，您现在可以使用这个定制元素并为<code class="fe ms mt mu lg b">filter</code>属性赋值:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0e8c" class="lk ll iq lg b gy lm ln l lo lp">&lt;custom-list filter="Hello World"&lt;/custom-list&gt;</span></pre><p id="5629" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在浏览器的控制台中，应该会显示“Hello World”。</p><p id="551b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们可以更进一步，在JavaScript中以编程方式设置和获取任何属性:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="953c" class="lk ll iq lg b gy lm ln l lo lp">var list = document.querySelector("custom-list");</span><span id="113a" class="lk ll iq lg b gy mv ln l lo lp">list.getAttribute("filter"); // -&gt; "Hello World"<br/>list.setAttribute("filter", "A new value");<br/>list.getAttribute("filter"); // -&gt; "A new value"</span><span id="1f85" class="lk ll iq lg b gy mv ln l lo lp">list.setAttribute("whatever", "Suprise");<br/>list.getAttribute("whatever"); // -&gt; "Suprise"</span></pre><p id="48eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会看到展示的行为与标准HTML元素相同，但是您可以自由决定使用哪些属性以及如何命名它们。</p><h2 id="c55b" class="lk ll iq bd lr nk nl dn lv nm nn dp lz ko no np md ks nq nr mh kw ns nt ml nu bi translated">访问元素内部的属性</h2><p id="b49a" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">到目前为止，我已经向您展示了如何在自定义元素的外部设置和获取属性。但是在许多情况下，您可能需要访问自定义元素中的这些属性，否则，它们将毫无用处，对吗？</p><p id="9693" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了与定制元素中的属性进行交互，我们使用相同的方法<code class="fe ms mt mu lg b">getAttribute</code>和<code class="fe ms mt mu lg b">setAttribute</code>，如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="958e" class="lk ll iq lg b gy lm ln l lo lp">class CustomList extends HTMLElement {<br/>  render() {</span><span id="708b" class="lk ll iq lg b gy mv ln l lo lp">    this.innerHTML = `<br/>      &lt;p&gt;The filter is: ${this.getAttribute("filter")}<br/>    `;<br/>  }<br/>}</span></pre><p id="6784" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这次的不同之处在于，您需要使用<code class="fe ms mt mu lg b">this</code>关键字，它指的是自定义元素本身。JavaScript中的<code class="fe ms mt mu lg b">this</code>可能有点混乱，但谢天谢地<a class="ae kc" href="https://medium.com/quick-code/understanding-the-this-keyword-in-javascript-cb76d4c7c5e8" rel="noopener">中有很多关于救援的解释</a>。</p><h2 id="c8b6" class="lk ll iq bd lr nk nl dn lv nm nn dp lz ko no np md ks nq nr mh kw ns nt ml nu bi translated">观察属性</h2><p id="1cbc" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">很好，我们已经了解了如何设置和获取自定义元素的属性。但是如果一个属性在页面生命周期中发生了变化，比如用户在输入中输入了一些东西，那该怎么办呢？</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c6cc" class="lk ll iq lg b gy lm ln l lo lp">&lt;input type="text"&gt;</span><span id="ae4d" class="lk ll iq lg b gy mv ln l lo lp">&lt;script&gt;<br/>  var list = document.querySelector("custom-list");<br/>  var input = document.querySelector("input");</span><span id="b0f9" class="lk ll iq lg b gy mv ln l lo lp">  input.onchange = (evt) =&gt; {<br/>    list.setAttribute("filter", evt.target.value);<br/>  }<br/>&lt;/script&gt;</span></pre><p id="bd81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Web组件规范得到了您的支持:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a920" class="lk ll iq lg b gy lm ln l lo lp">class CustomList extends HTMLElement {<br/>  static get observedAttributes() {<br/>    return ["filter"];<br/>  }</span><span id="572f" class="lk ll iq lg b gy mv ln l lo lp">  attributeChangedCallback(name, oldValue, newValue) {<br/>    // do something when an attribute has changed<br/>  }<br/>}</span></pre><p id="25d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu lg b">observedAttributes</code>是一个静态getter方法，它总是需要返回我们想要观察的所有属性的数组。在这个例子中，它只观察到了<code class="fe ms mt mu lg b">filter</code>属性(当然也可能有更多)。</p><p id="27a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是第一步。下面，你会看到一个叫做<code class="fe ms mt mu lg b">attributeChangedCallback</code>的方法，它是Web组件<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks" rel="noopener ugc nofollow" target="_blank">生命周期</a>的一部分。每当我们观察到的任何属性发生变化时，这个方法就会运行，并执行您在内部定义的任何逻辑。它接收三个参数:已更改属性的名称、旧值和新值。</p><p id="c33b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免不必要的重新渲染，最好的做法是检查值是否真的改变了。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="cdf3" class="lk ll iq lg b gy lm ln l lo lp">attributeChangedCallback(name, oldValue, newValue) {<br/>  if (oldValue === newValue) {<br/>   return;<br/> }<br/>    <br/>  console.log(`The attribute ${name} has changed`);<br/>}</span></pre><p id="e4bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们检查新值是否与旧值不同。如果不是，我们停止执行，其他什么也不会发生。如果确实不同，我们就可以运行任何代码，比如计算、重新渲染或者你需要的任何东西。</p><h2 id="61cc" class="lk ll iq bd lr nk nl dn lv nm nn dp lz ko no np md ks nq nr mh kw ns nt ml nu bi translated">但是像对象这样的复杂数据呢？</h2><p id="b47d" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">不过，有一点需要注意:传递属性只适用于字符串。甚至像<code class="fe ms mt mu lg b">items="2"</code>这样传递的数字也会被转换成一个字符串。传递对象、数组或函数就更不可能了。</p><p id="1020" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传递对象的一种(相当难看的)方法是使用<code class="fe ms mt mu lg b">JSON.stringify</code>将它转换成字符串:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c179" class="lk ll iq lg b gy lm ln l lo lp">&lt;custom-list items="[{id:1},{id:2}]"&gt;&lt;/custom-list&gt;</span><span id="2545" class="lk ll iq lg b gy mv ln l lo lp">&lt;script&gt;<br/>  var list = document.querySelector("custom-list");</span><span id="bad2" class="lk ll iq lg b gy mv ln l lo lp">  list.setAttribute("items", JSON.stringify(...));<br/>&lt;/script&gt;</span></pre><p id="bde1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，您的自定义元素需要将该字符串解析回一个对象:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9f8c" class="lk ll iq lg b gy lm ln l lo lp">render() {<br/>  try {<br/>    JSON.parse(this.getAttribute("items"));<br/>  } catch (ex) {...}<br/>}</span></pre><p id="d204" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这种方法将复杂数据传递到Web组件中是不可取的，如果可能的话，应该避免使用这种方法。让我们看看更好的方法。</p><h1 id="3328" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">#2 —使用属性</h1><p id="0b17" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我不知道你，属性和性质的区别一开始让我很困惑。我花了一些时间才明白过来，所以让我试着解释一下。</p><p id="8e90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看这个简单的<code class="fe ms mt mu lg b">img</code>元素。属性是我们在HTML中设置的，比如:<code class="fe ms mt mu lg b">&lt;img src="image-1.jpg"&gt;</code>。这个元素现在有一个名为<code class="fe ms mt mu lg b">src</code>的属性，也可以设置许多其他属性，比如<code class="fe ms mt mu lg b">alt</code>或<code class="fe ms mt mu lg b">width</code>。</p><p id="98bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性赋予元素以意义，在语义上很重要。它们主要被屏幕阅读器、搜索引擎和其他人用来理解你的HTML结构。</p><p id="ffcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦浏览器解析了您的HTML，它会将<code class="fe ms mt mu lg b">img</code>(连同所有其他元素)转换成一个<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement" rel="noopener ugc nofollow" target="_blank"> DOM元素对象</a>，在本例中是一个<code class="fe ms mt mu lg b">HTMLImageElement</code>。对于每个HTML标签，都有一个DOM对象来定义它的行为、外观等等。好奇看看有多少？<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement" rel="noopener ugc nofollow" target="_blank">看这里</a>。这些物体有一大堆属性，我们当时只使用了其中的几个:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9859" class="lk ll iq lg b gy lm ln l lo lp">var HTMLImageElement = {<br/>  src: "image-1.jpg",<br/>  alt: null,<br/>  accessKey: null,<br/>  ...<br/>};</span></pre><p id="8104" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性就像绑定到对象的变量。</p><p id="9edc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当浏览器在渲染期间创建所有这些DOM元素对象时，其属性将反映HTML属性。这就是为什么image-1.jpg的<code class="fe ms mt mu lg b">src</code>是<em class="nv"/>，但是其他属性仍然被设置为<code class="fe ms mt mu lg b">null</code>(我们在HTML中没有用到它们)。这意味着<code class="fe ms mt mu lg b">src</code>属性反映了<code class="fe ms mt mu lg b">src</code>属性。浏览器在幕后为我们创建并同步这两个。</p><p id="19af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，这比我刚才解释的要复杂得多。如果你有兴趣了解细节，在StackOverflow的这个帖子中有一个很好的<a class="ae kc" href="https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html" rel="noopener ugc nofollow" target="_blank">解释。</a></p><h2 id="e3cd" class="lk ll iq bd lr nk nl dn lv nm nn dp lz ko no np md ks nq nr mh kw ns nt ml nu bi translated">Getters和setters</h2><p id="921d" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在我们可以在自定义元素中使用属性之前，我们需要理解<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" rel="noopener ugc nofollow" target="_blank">getter</a>和<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" rel="noopener ugc nofollow" target="_blank">setter</a>的概念。</p><p id="a632" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在类或函数中使用Getters和setters来设置和获取这些属性。看看这个例子:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="69c7" class="lk ll iq lg b gy lm ln l lo lp">class User {<br/>  constructor() {<br/>    this._name = "John Doe";<br/>    this._age = 25;<br/>  }</span><span id="a484" class="lk ll iq lg b gy mv ln l lo lp">  get name() {<br/>    return this._name;<br/>  }</span><span id="50e0" class="lk ll iq lg b gy mv ln l lo lp">  set name(name) {<br/>    this._name = name;<br/>  }</span><span id="b1e4" class="lk ll iq lg b gy mv ln l lo lp">  get age() {<br/>    return `This user is ${this._age} years old`;<br/>  }</span><span id="9c7f" class="lk ll iq lg b gy mv ln l lo lp">  set age(age) {<br/>    if (age &lt; 18) {<br/>      throw new RangeError("User must at least be 18 years old!");<br/>    }</span><span id="7f4f" class="lk ll iq lg b gy mv ln l lo lp">    this._age = age;<br/>  }<br/>}</span></pre><ul class=""><li id="44d4" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">我们有一个名为<code class="fe ms mt mu lg b">User</code>的类，它拥有两个属性:<code class="fe ms mt mu lg b">_name</code>和<code class="fe ms mt mu lg b">_age</code>。请注意这两个属性是如何以下划线开头的；这不是强制性的，但被认为是实现类似<a class="ae kc" href="https://stackoverflow.com/questions/44734399/what-is-the-underscore-in-javascript" rel="noopener ugc nofollow" target="_blank">私有变量</a>的最佳实践。</li><li id="e2f3" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">在第7行，您将看到第一个getter <code class="fe ms mt mu lg b">name</code>，它只返回分配给<code class="fe ms mt mu lg b">_name</code>的值。这是最简单的吸气剂形式。</li><li id="24f9" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">在下面的第11行，您将遇到第一个setter <code class="fe ms mt mu lg b">name</code>，它用于为属性<code class="fe ms mt mu lg b">_name</code>赋值。因此，它需要接收一个参数。</li><li id="a78d" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">下一个getter基本上做了同样的事情，但是在这里我把一些文本放在了用户的年龄上。这应该向您展示，您可以从getter返回任何内容，而不仅仅是属性值。但不要对它太着迷。</li><li id="4968" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">最后，<code class="fe ms mt mu lg b">_age</code>的最后一个设置器包括一些基本的验证——我们不接受18岁以下的用户，所以如果有人试图设置更小的年龄，我们会抛出一个异常。</li></ul><p id="7204" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想和这个类互动，你应该这样做:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6097" class="lk ll iq lg b gy lm ln l lo lp">var user = new User();</span><span id="a28b" class="lk ll iq lg b gy mv ln l lo lp">console.log(user.name); // -&gt; "John Doe"<br/>console.log(user.age); // -&gt; "This user is 25 years old"</span><span id="22d9" class="lk ll iq lg b gy mv ln l lo lp">user.name = "Jane Doe";</span><span id="a9ab" class="lk ll iq lg b gy mv ln l lo lp">console.log(user.name); // -&gt; "Jane Doe"</span><span id="6901" class="lk ll iq lg b gy mv ln l lo lp">user.age = 17; // Ka-bumm!</span></pre><p id="144a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管您可以这样做，但直接访问这些属性并不是一个好的做法:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5049" class="lk ll iq lg b gy lm ln l lo lp">var user = new User();</span><span id="e123" class="lk ll iq lg b gy mv ln l lo lp">console.log(user._name) // -&gt; "John Doe"<br/>// (°_°)</span></pre><h2 id="8f11" class="lk ll iq bd lr nk nl dn lv nm nn dp lz ko no np md ks nq nr mh kw ns nt ml nu bi translated">自定义元素中的属性</h2><p id="69fc" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">你还在吗？太好了，你已经通过了干燥理论。让我们看看这些知识如何帮助我们实现定制元素。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6de5" class="lk ll iq lg b gy lm ln l lo lp">class CustomList extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>   <br/>    this._items = [];<br/>  }</span><span id="c3b9" class="lk ll iq lg b gy mv ln l lo lp">  set items(value) {<br/>    this._items = value;<br/>  }<br/>  <br/>  get items() {<br/>    return this._items;<br/>  }<br/>}</span></pre><p id="cb44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们定义了getter和setter方法，我们希望传递给自定义元素的每个属性都需要这些方法。</p><p id="4eb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经将<code class="fe ms mt mu lg b">items</code>声明为元素的可配置属性，我们可以使用JavaScript传递它:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="43b9" class="lk ll iq lg b gy lm ln l lo lp">var list = document.querySelector("custom-list");</span><span id="5e10" class="lk ll iq lg b gy mv ln l lo lp">list.items = [1, 2, 3];</span><span id="9219" class="lk ll iq lg b gy mv ln l lo lp">console.log(list.items); // -&gt; [1, 2, 3]</span></pre><p id="20ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意到我们没有使用HTML传递属性了吗？没错，只有属性可以用HTML传递，其他的都需要用JavaScript来完成。</p><p id="a4f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，您不一定需要getter和setter，可以直接访问属性，但我不鼓励这样做。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="56a3" class="lk ll iq lg b gy lm ln l lo lp">list._items = [1, 2, 3];</span><span id="65b5" class="lk ll iq lg b gy mv ln l lo lp">console.log(list._items); // -&gt; [1, 2, 3]<br/>// (°_°)</span></pre><p id="46c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，我们并不局限于使用数组。每种数据类型都可以传递，比如这个函数:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a2b7" class="lk ll iq lg b gy lm ln l lo lp">list.callback = () =&gt; console.log("Hello World");</span><span id="0c9f" class="lk ll iq lg b gy mv ln l lo lp">list.callback(); // -&gt; "Hello World"</span></pre><p id="6522" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们在自定义元素中处理复杂数据的方式。还不算太糟，是吧？但是等等，还有更多。</p><h1 id="0195" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">#3 —使用事件</h1><p id="8222" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">使用属性和特性是很好的，但是如果您想要基于某些事件做出反应呢？几乎所有的HTML元素都有我们可以监听的事件，比如<code class="fe ms mt mu lg b">input</code>:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5167" class="lk ll iq lg b gy lm ln l lo lp">var input = document.querySelector("input");</span><span id="9e5f" class="lk ll iq lg b gy mv ln l lo lp">input.addEventListener("keydown", handleKeyDown);</span></pre><p id="5742" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu lg b">input</code>元素内置了逻辑，每当用户按下一个键时就会发出<code class="fe ms mt mu lg b">keydown</code>事件。我们不能为自定义元素使用类似的东西吗？是的，我们可以！</p><p id="b607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们不能依赖像<code class="fe ms mt mu lg b">keydown</code>或<code class="fe ms mt mu lg b">click</code>这样的事件，它们是特定标准元素的JavaScript规范的一部分。相反，我们必须构建自己的事件，同时利用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events" rel="noopener ugc nofollow" target="_blank">自定义事件API </a>。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8db6" class="lk ll iq lg b gy lm ln l lo lp">class ClickCounter extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    <br/>    this._timesClicked = 0;<br/>    <br/>    var button = document.createElement("button");<br/>    button.textContent = "Click me";<br/>    button.onclick = (evt) =&gt; {<br/>      this._timesClicked++;<br/>      <br/>      this.dispatchEvent(new CustomEvent("clicked", {<br/>        detail: this._timesClicked<br/>      }));<br/>    };<br/>    <br/>    this.append(button);<br/>  }<br/>};</span><span id="bae9" class="lk ll iq lg b gy mv ln l lo lp">customElements.define("click-counter", ClickCounter);</span><span id="22fe" class="lk ll iq lg b gy mv ln l lo lp">var counter = document.querySelector("click-counter");</span><span id="a9c5" class="lk ll iq lg b gy mv ln l lo lp">counter.addEventListener("clicked", (evt) =&gt; {<br/>  console.log(evt.detail);<br/>});</span></pre><p id="4f44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码示例中有很多事情要做。深呼吸，伸展你的手臂，让我们开始吧。</p><ul class=""><li id="c22e" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">在第1行，我们创建了一个名为<code class="fe ms mt mu lg b">ClickCounter</code>的新定制元素类。</li><li id="58ce" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">然后我们定义构造函数并调用<code class="fe ms mt mu lg b">super()</code>来继承<code class="fe ms mt mu lg b">HTMLElement</code>。</li><li id="e201" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">现在，在第5行，我们定义了属性<code class="fe ms mt mu lg b">_timesClicked</code>，它作为元素的本地状态。我们希望用户每点击一次按钮就增加1。</li><li id="1467" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">在第7行和第8行，我们创建了一个新按钮并设置了一些文本内容。</li><li id="b8c7" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">在第9行，我们为<code class="fe ms mt mu lg b">onclick</code>定义了一个函数，每次用户点击按钮时都会调用这个函数。在这个事件回调中，我们首先将计数器加1，然后调度一个自定义事件。</li><li id="ef39" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">这个定制事件被称为<code class="fe ms mt mu lg b">clicked</code>，但是它可以是你喜欢的任何名字。作为第二个参数，我们传递一个选项来配置这个自定义事件。<code class="fe ms mt mu lg b">detail</code>属性用于传递我们自己的数据和事件。这可以是一个对象，数组，字符串，甚至是一个函数。稍后，我们将使用<code class="fe ms mt mu lg b">detail</code>属性来获取用户点击按钮的次数。</li><li id="2aaf" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">下面，我们将按钮添加到自定义元素的DOM中。</li><li id="7088" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">在第23行，我们使用<code class="fe ms mt mu lg b">document.querySelector</code>获取元素的引用，并将其保存到一个变量中。最后，我们添加一个事件监听器，它监听我们前面定义的完全相同的事件，并添加一个回调函数。这个函数接收<code class="fe ms mt mu lg b">evt</code>对象作为唯一的参数，这个对象的一部分是属性<code class="fe ms mt mu lg b">detail</code>，在其中我们可以访问某人点击按钮的次数。</li></ul><p id="480c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个相当简单的例子应该让您对如何将事件侦听器附加到自定义元素有一个基本的了解。事件的触发时间和方式以及随事件一起提交的数据都由您决定。</p><p id="d0cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是有一个问题:这种技术在有许多不同的Web组件需要相互通信的应用程序中并不真正起作用(也不能扩展)。您不希望为每个组件监听许多不同的事件，这会使您的代码不可读且复杂。让我们来看看如何解决这种情况。</p><h1 id="bf25" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">#4 —使用事件总线</h1><p id="8e95" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">最后一种技术也利用了自定义事件API，但是我们没有监听组件上的本地事件，而是定义了一个应用程序范围的全局总线，该总线传输我们的事件并使它们随处可访问。</p><p id="19b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据您的需要，事件总线可能会变得相当复杂。在下面的例子中，我想保持简单，这样你就可以完全理解这个概念背后的想法。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4634" class="lk ll iq lg b gy lm ln l lo lp">class EventBus {<br/>  constructor() {<br/>    this._bus = document.createElement('div');<br/>  }<br/><br/>  register(event, callback) {<br/>    this._bus.addEventListener(event, callback);<br/>  } <br/>    <br/>  remove(event, callback) {<br/>    this._bus.removeEventListener(event, callback);<br/>  }</span><span id="165c" class="lk ll iq lg b gy mv ln l lo lp">  fire(event, detail = {}) {<br/>    this._bus.dispatchEvent(new CustomEvent(event, { detail }));<br/>  }<br/>}</span><span id="b53a" class="lk ll iq lg b gy mv ln l lo lp">var bus = new EventBus();</span><span id="1ba6" class="lk ll iq lg b gy mv ln l lo lp">export default bus;</span></pre><p id="f5b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码示例是受这篇文章启发的<a class="ae kc" href="https://pineco.de/creating-a-javascript-event-bus/" rel="noopener ugc nofollow" target="_blank">，这篇文章更加详细。</a></p><p id="9033" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，我们创建了一个新的JavaScript类。一旦这个类被初始化，我们就创建一个新的HTML元素(它不会被追加，也不会在DOM中使用)。这个HTML元素是必需的，因为自定义事件需要绑定到实际的HTML元素。</p><p id="048f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们定义3种方法:</p><ul class=""><li id="f9aa" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">允许我们向总线添加新的事件监听器。事件名称以及回调由您决定。</li><li id="17af" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe ms mt mu lg b">remove</code>从总线上删除一个现有的事件监听器。</li><li id="60d3" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">最后，<code class="fe ms mt mu lg b">fire</code>分派一个事件(同样，您可以选择名称)，我们可以使用<code class="fe ms mt mu lg b">detail</code>参数附加额外的数据。</li></ul><p id="d74b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后3行确保我们初始化总线并导出它的引用。</p><p id="f1af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在整个应用程序中，您最有可能使用许多不同的文件，因此需要注册或触发事件的每个文件现在都可以导入它:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="43b3" class="lk ll iq lg b gy lm ln l lo lp">import EventBus from "./event-bus.js";</span><span id="1e2b" class="lk ll iq lg b gy mv ln l lo lp">EventBus.register("someevent", (evt) =&gt; {...});</span><span id="d853" class="lk ll iq lg b gy mv ln l lo lp">EventBus.fire("someevent");</span></pre><p id="57fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们只导出和导入实例(<code class="fe ms mt mu lg b">var bus = new EventBus()</code>)，所以我们确保所有的事件都由同一个总线处理。</p><p id="9d40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，如果您不想导出/导入事件总线，您可以将其附加到全局<code class="fe ms mt mu lg b">window</code>对象(我不建议这样做):</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a812" class="lk ll iq lg b gy lm ln l lo lp">class EventBus {...}</span><span id="7514" class="lk ll iq lg b gy mv ln l lo lp">window.EventBus = new EventBus;</span></pre><p id="e909" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！我们可以使用这种技术来允许我们的定制元素之间的通信。</p><h1 id="dc87" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="d6b4" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在本文中，我有幸向您介绍了将数据传递到定制元素的4种不同方式。让我们回顾一下:</p><h2 id="02cc" class="lk ll iq bd lr nk nl dn lv nm nn dp lz ko no np md ks nq nr mh kw ns nt ml nu bi translated">属性</h2><ul class=""><li id="1989" class="mw mx iq kf b kg mn kk mo ko nw ks nx kw ny la nb nc nd ne bi translated">可以通过HTML和JavaScript设置，使用<code class="fe ms mt mu lg b">getAttribute</code>和<code class="fe ms mt mu lg b">setAttribute</code>。</li><li id="1050" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">只处理字符串。</li><li id="979a" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">可以观察到。</li><li id="9870" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">非常容易和直接使用。</li></ul><h2 id="3639" class="lk ll iq bd lr nk nl dn lv nm nn dp lz ko no np md ks nq nr mh kw ns nt ml nu bi translated">性能</h2><ul class=""><li id="a1e1" class="mw mx iq kf b kg mn kk mo ko nw ks nx kw ny la nb nc nd ne bi translated">只能在JavaScript中使用。</li><li id="27b3" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">可以处理所有数据类型。</li><li id="7e0d" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">非常适合在自定义元素中获取复杂数据。</li><li id="988a" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">定制元素应该有getters和setters来正确处理它们。</li></ul><h2 id="9e90" class="lk ll iq bd lr nk nl dn lv nm nn dp lz ko no np md ks nq nr mh kw ns nt ml nu bi translated">事件</h2><ul class=""><li id="53be" class="mw mx iq kf b kg mn kk mo ko nw ks nx kw ny la nb nc nd ne bi translated">非常适合从定制元素中获取数据。</li><li id="67d9" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">使用自定义事件API。</li><li id="6f5c" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">当在许多事件中使用许多不同的元素时会变得混乱。</li></ul><h2 id="25b5" class="lk ll iq bd lr nk nl dn lv nm nn dp lz ko no np md ks nq nr mh kw ns nt ml nu bi translated">事件总线</h2><ul class=""><li id="d063" class="mw mx iq kf b kg mn kk mo ko nw ks nx kw ny la nb nc nd ne bi translated">非常适合组件之间的通信。</li><li id="6c34" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">不同的通信通道可以有多条总线。</li><li id="feb6" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">建造这辆公共汽车需要一些努力。</li></ul><p id="8160" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你选择用什么方法工作应该取决于你需要达到什么目的。在一个应用程序中结合一些或所有这些技术并不少见。</p><p id="53a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有任何问题，请在评论中告诉我。编码快乐！</p></div></div>    
</body>
</html>