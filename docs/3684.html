<html>
<head>
<title>Railroad Programming in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿中的铁路规划</h1>
<blockquote>原文：<a href="https://itnext.io/railroad-programming-in-typescript-21d69f486f6e?source=collection_archive---------1-----------------------#2020-02-02">https://itnext.io/railroad-programming-in-typescript-21d69f486f6e?source=collection_archive---------1-----------------------#2020-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/707b53737b08950f385b01e97b7eb0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vt_MChFHO0-JM9q90yyJEQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@drc1948?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼斯·奇克</a>在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8785" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多开发人员都会同意，编程最难的部分之一是考虑所有潜在的结果。起初听起来微不足道的任务可能会有各种各样的情况需要考虑。以在网站上显示用户姓名的任务为例，该任务基于名和姓字段。有登录的用户吗？用户有名字吗？我们如何格式化这个名字？如果其中一个字段为空，该怎么办？可能的实现如下所示:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="8022" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们看到我们必须检查<code class="fe lh li lj lk b">null</code>和空字符串。无论是谁调用这个函数，都必须考虑到<code class="fe lh li lj lk b">Error</code>和空字符串的可能性。这将导致<code class="fe lh li lj lk b">try-catch</code>块和更多的if语句。这也导致了TypeScript的另一个特殊性:抛出东西。你可以抛出任何你想抛出的东西，而不仅仅是错误。然后，我们发现TypeScript在catch块上没有模式匹配，这使得您只能捕获您关心的“东西”,就像您可能从Java或C#中知道的那样。这可能会导致<code class="fe lh li lj lk b">catch-block</code>内部复杂的逻辑来计算您到底得到了什么。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这些都是有效的，甚至在打字稿的打字范围内</figcaption></figure><p id="e579" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当看到这一切时，人们不得不考虑是否有更好的方法来处理不愉快的路径和潜在的无效数据。来自函数式编程世界的一种可能的方法是铁路编程。</p><h1 id="76ca" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">铁路规划</h1><p id="7f2d" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">铁路规划从回归(功能)规划的基础开始。每个函数都是一个箭头，有些输入在左边，有些输出在右边。没有附加条件，所以现在抛出错误。想想看，错误不也是函数的有效输出吗？“错误”只是一个不如我们想要的积极的输出，但并没有改变输入→输出的概念。为了更加实用，我们可以为可能失败的函数定义一种类型:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="a952" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这些类型，我们可以定义一些构造函数并重写<code class="fe lh li lj lk b">renderUser</code>函数:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="12df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你现在调用<code class="fe lh li lj lk b">renderUser</code>，你的错误会得到完全的类型安全，迫使你相应地处理它们。当代码库不断增长，并且在用户在屏幕上看到错误之前，错误会通过多层抽象冒出来，这就有了巨大的优势。</p><h1 id="bdf5" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">作文</h1><p id="a439" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">下一步是重新定义<code class="fe lh li lj lk b">getUser</code>函数来使用我们的类型化错误系统。下面显示了一种可行的方法。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="47b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里你可以注意到，我们已经移除了抛出错误的类型不安全性，但是被迫在每个可能返回错误的函数后编写一个if语句。虽然这是增加安全性的一个合乎逻辑的、可以说是积极的结果(不会有更多的错误无法处理)，但它会使按顺序调用一堆函数变得很笨拙。</p><p id="4bb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是为此，我们可以以附加函数的形式定义公共操作。第一个是<code class="fe lh li lj lk b">map</code>:如果有结果，它会对a结果应用一个函数。这用于运行一个可能首先失败的函数，然后对结果做一些事情(如果有的话)。另一个是<code class="fe lh li lj lk b">join</code>:它将嵌套的结果解包成一个结果。如果某个东西在一个<code class="fe lh li lj lk b">Result</code>中返回了一个<code class="fe lh li lj lk b">Result</code>，这将是一个非常方便的工具。最后一个是<code class="fe lh li lj lk b">then</code>:它将一个可能失败的函数的潜在输出输入到另一个也可能失败的函数中。这将创建一个流程管道，所有流程都可能失败，但其中没有显式的错误处理。和一个<code class="fe lh li lj lk b">Promise</code>上的<code class="fe lh li lj lk b">then</code>很有可比性。它们的实现如下:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="bee8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些函数起初看起来有点难懂和抽象，但是当你开始使用它们时，它们变得非常实用(习惯于函数编程的人已经认识到<code class="fe lh li lj lk b">Result</code>是单子)。让我们看几个使用这些函数的例子:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="8c65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，所有的功能都变得难以置信的简单和简短。我们可以只是将函数组合在一起，而不关心过程中潜在的错误。但是，如果我们想从铁路中提取结果，编译器将迫使我们处理我们积累的所有潜在错误。</p><p id="1631" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将向您展示的最后一件事是一个函数，它允许您在组合函数时使用流畅的编程风格，这看起来比函数式TypeScript经常结束的无休止的参数嵌套更具可读性。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><h1 id="4bd3" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="cda7" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在本文中，我们已经看到了小型类型和函数在为TypeScript的一个较小部分组合成更大的解决方案时是多么强大。如果你对此感兴趣，可以看看斯科特·沃斯钦的<a class="ae kc" href="https://www.slideshare.net/ScottWlaschin/railway-oriented-programming?ref=https://fsharpforfunandprofit.com/rop/" rel="noopener ugc nofollow" target="_blank">幻灯片</a>，它对F#有更详细的解释。所有代码示例也可以在<a class="ae kc" href="https://github.com/WimJongeneel/ts-railroad-programming" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><p id="2dec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何看待TypeScript / JavaScript实现了errors和<code class="fe lh li lj lk b">try-cactch</code>？你是否同意<code class="fe lh li lj lk b">throw</code>和<code class="fe lh li lj lk b">catch</code>周围的不安全类型是一种遗憾，可以更愉快地合作？在TypeScript中，您最喜欢的错误处理方式是什么？</p></div></div>    
</body>
</html>