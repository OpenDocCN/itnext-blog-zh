<html>
<head>
<title>Data Structures in JS. Part 2: Double Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS中的数据结构。第2部分:双向链表</h1>
<blockquote>原文：<a href="https://itnext.io/data-structures-in-js-part-2-double-linked-lists-150facd7a90d?source=collection_archive---------4-----------------------#2018-06-16">https://itnext.io/data-structures-in-js-part-2-double-linked-lists-150facd7a90d?source=collection_archive---------4-----------------------#2018-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/21887e0b2fda954bbf7b81ff9df4bdec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipP9zOk__u9z0L75kmNTDQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">双链表React App截图</figcaption></figure><p id="00fd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是关于JS中的数据结构系列的第二部分。以下列表恢复了所有部分:</p><ul class=""><li id="7772" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/data-structures-in-js-hash-tables-app-with-react-b28b02a9e6b5">第1部分(散列表)</a></li><li id="eba0" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/@alonso.oliverio/data-structures-in-js-part-2-double-linked-lists-150facd7a90d" rel="noopener">第二部分(双向链表)</a></li><li id="0eac" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/@alonso.oliverio/data-structures-in-js-binary-trees-react-app-5443b951a46b" rel="noopener">第三部(二叉树)</a></li></ul><p id="e6e4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和上一篇文章一样，我将开始解释这个结构的基础。这就是节点。在这种情况下，双链接节点。</p><p id="b28a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个节点有三个数据元素:</p><ul class=""><li id="3598" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><strong class="ke ir"> Value </strong>:节点存储的值。使用无类型语言，JS或其他类似C++的模板允许这个元素是任何类型。</li><li id="65ec" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">前一个</strong>:列表中的前一个元素。</li><li id="a940" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">下一个</strong>:列表中的下一个元素。</li></ul><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/37f6775dd29e1537014ff1a80e850820.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*HUSam8RVWGXZGJ58vBYRrQ.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">双重链接节点</figcaption></figure><p id="4365" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很简单，对吧？让我们从列表本身开始吧。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="eaf6" class="lz ma iq lv b gy mb mc l md me">class DLList {</span><span id="cf87" class="lz ma iq lv b gy mf mc l md me">  constructor(values) {</span><span id="b0ef" class="lz ma iq lv b gy mf mc l md me">    this.header = new DLListNode(null, null, null);</span><span id="429f" class="lz ma iq lv b gy mf mc l md me">    this.tail = new DLListNode(this.header, null, null);</span><span id="7b54" class="lz ma iq lv b gy mf mc l md me">    this.header.setNext(this.tail);</span><span id="5844" class="lz ma iq lv b gy mf mc l md me">    this.elements = 0;</span><span id="63d6" class="lz ma iq lv b gy mf mc l md me">  }</span><span id="fbf6" class="lz ma iq lv b gy mf mc l md me">  // Cost: O(1)</span><span id="d0ae" class="lz ma iq lv b gy mf mc l md me">  erase(pos) {</span><span id="cb79" class="lz ma iq lv b gy mf mc l md me">    if (pos.assertIsValid()) {</span><span id="7ef1" class="lz ma iq lv b gy mf mc l md me">      let curr = pos.current();</span><span id="7787" class="lz ma iq lv b gy mf mc l md me">      const prev = curr.getPrev();</span><span id="2016" class="lz ma iq lv b gy mf mc l md me">      const next = curr.getNext();</span><span id="6182" class="lz ma iq lv b gy mf mc l md me">      prev.setNext(next);</span><span id="4ed7" class="lz ma iq lv b gy mf mc l md me">      next.setPrev(prev);</span><span id="c290" class="lz ma iq lv b gy mf mc l md me">      curr = null;</span><span id="21f2" class="lz ma iq lv b gy mf mc l md me">      this.elements--;</span><span id="3379" class="lz ma iq lv b gy mf mc l md me">      return DLListIterator[Symbol.iterator](next, this);</span><span id="21d1" class="lz ma iq lv b gy mf mc l md me">    }</span><span id="51d3" class="lz ma iq lv b gy mf mc l md me">  }</span><span id="e8c3" class="lz ma iq lv b gy mf mc l md me">  // Cost: O(1)</span><span id="f824" class="lz ma iq lv b gy mf mc l md me">  insert(pos, val) {</span><span id="6d10" class="lz ma iq lv b gy mf mc l md me">    const endVal = this.end().current();</span><span id="5a2c" class="lz ma iq lv b gy mf mc l md me">    if (</span><span id="dfe7" class="lz ma iq lv b gy mf mc l md me">      (pos.assertIsValid() || pos.current() === endVal) &amp;&amp;</span><span id="96dc" class="lz ma iq lv b gy mf mc l md me">      this.find(val).current() === endVal</span><span id="b39d" class="lz ma iq lv b gy mf mc l md me">    ) {</span><span id="abf8" class="lz ma iq lv b gy mf mc l md me">      const curr = pos.current();</span><span id="563f" class="lz ma iq lv b gy mf mc l md me">      const prev = curr.getPrev();</span><span id="85e9" class="lz ma iq lv b gy mf mc l md me">      const newNode = new DLListNode(prev, val, curr);</span><span id="6d26" class="lz ma iq lv b gy mf mc l md me">      prev.setNext(newNode);</span><span id="9b03" class="lz ma iq lv b gy mf mc l md me">      curr.setPrev(newNode);</span><span id="1b8d" class="lz ma iq lv b gy mf mc l md me">      this.elements++;</span><span id="467a" class="lz ma iq lv b gy mf mc l md me">      return DLListIterator[Symbol.iterator](newNode, this);</span><span id="49cf" class="lz ma iq lv b gy mf mc l md me">    }</span><span id="7533" class="lz ma iq lv b gy mf mc l md me">    return DLListIterator[Symbol.iterator](null, this);</span><span id="07c4" class="lz ma iq lv b gy mf mc l md me">  }</span><span id="2395" class="lz ma iq lv b gy mf mc l md me">  // Cost: O(n)</span><span id="c306" class="lz ma iq lv b gy mf mc l md me">  find(item) {</span><span id="702a" class="lz ma iq lv b gy mf mc l md me">    const iterator = this.begin();</span><span id="8ee0" class="lz ma iq lv b gy mf mc l md me">    while (iterator.current() !== this.end().current()) {</span><span id="c5dc" class="lz ma iq lv b gy mf mc l md me">      if (iterator.current() !== null &amp;&amp;       iterator.current().getValue() === item)</span><span id="40ad" class="lz ma iq lv b gy mf mc l md me">        break;</span><span id="6d00" class="lz ma iq lv b gy mf mc l md me">      iterator.next();</span><span id="c6a6" class="lz ma iq lv b gy mf mc l md me">    }</span><span id="a0d0" class="lz ma iq lv b gy mf mc l md me">    return iterator;</span><span id="4ddc" class="lz ma iq lv b gy mf mc l md me">  }</span><span id="2ba0" class="lz ma iq lv b gy mf mc l md me">  // Cost: O(1)</span><span id="d38f" class="lz ma iq lv b gy mf mc l md me">  end() {</span><span id="e27a" class="lz ma iq lv b gy mf mc l md me">    return DLListIterator[Symbol.iterator](this.tail, this);</span><span id="ef1d" class="lz ma iq lv b gy mf mc l md me">  }</span><span id="76ed" class="lz ma iq lv b gy mf mc l md me">... more methods<br/>}</span></pre><p id="017b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是G <a class="ae lj" href="https://github.com/boxgames1/double-linked-list-app" rel="noopener ugc nofollow" target="_blank"> ithub repo </a>的链接，里面有这个应用的所有工作代码。</p><p id="8799" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">双向链表是一个类，它聚合形成它自己的链接节点。它不允许重复值，正如您所看到的，该列表包含以下元素:</p><ul class=""><li id="d12a" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><strong class="ke ir"> Header </strong>:列表的第一个节点，迭代器的入口点。</li><li id="6077" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir"> Tail </strong>:类似表头但在另一边的节点。拥有一些像end()这样的具有恒定复杂度的通用方法会有所帮助。</li><li id="f8bb" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir"> Elements </strong>:一个简单的计数器，对列表中的当前元素进行快速廉价的检查。</li></ul><p id="b961" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">头部和尾部不像普通节点那样计数，因为它们不是可擦除的。</p><p id="53bf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">尽管在单节点中，在双节点中，我们可以得到具有恒定复杂度的前一个，因此插入、擦除和结束方法也具有O(1)复杂度。在这个结构中，仍然具有O(n)复杂度的唯一方法是find和clear。让我们做一个小比较:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="74ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最常见的基本方法(插入和擦除)现在具有恒定的复杂度，代价是在每个节点中添加对先前的引用。值得！现在唯一重要的部分来了:</p><h1 id="ea01" class="mi ma iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">什么时候以及如何使用双向链表？</h1><p id="6296" class="pw-post-body-paragraph kc kd iq ke b kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz ij bi translated">正如前面指出的，这个列表不允许重复的元素，所以这是您的第一个限制。在查找存储数据时，数组通常是您考虑的第一个结构。列表以更低的成本为您提供更多的功能。在我看来，大多数JS开发人员丢弃(或忽略)了其他数据结构。</p><p id="5f84" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我开发的这个列表是建立适合你的项目的更好列表的基础。例如，如果您正在使用一个通常具有唯一id的关系数据库，那么您可以转换这个列表的值，将其转换为一个键值对，同时考虑到这个列表的“唯一”限制。这是一个典型的例子，你应该使用列表而不是数组，因为基类的方法复杂度是O(1)而不是O(n)。</p><p id="4e01" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在一个前端逻辑管理着大约1000个元素的网页中，你看不出有什么不同。但是，对于数百万条记录，您应该注意管理数据的最佳数据结构和策略。</p><p id="907c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以在此测试React应用程序:</p><div class="nk nl gp gr nm nn"><a href="https://fathomless-river-23726.herokuapp.com/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">双链表React App @boxgames1</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">编辑描述</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">fathomless-river-23726.herokuapp.com</p></div></div></div></a></div><p id="8143" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Github Repo的所有代码:</p><div class="nk nl gp gr nm nn"><a href="https://github.com/boxgames1/double-linked-list-app" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">box games 1/双向链表应用程序</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">这个应用程序展示了双向链表的行为</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob jw nn"/></div></div></a></div><p id="bc7e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在推特上联系我<a class="ae lj" href="https://twitter.com/Oliver_AP" rel="noopener ugc nofollow" target="_blank"> (@Oliver_ap) </a></p></div></div>    
</body>
</html>