<html>
<head>
<title>Decodable with dynamic keys in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可通过Swift中的动态密钥解码</h1>
<blockquote>原文：<a href="https://itnext.io/decodable-with-dynamic-keys-in-swift-78f4293f5654?source=collection_archive---------1-----------------------#2019-08-26">https://itnext.io/decodable-with-dynamic-keys-in-swift-78f4293f5654?source=collection_archive---------1-----------------------#2019-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e0a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自Swift 4.0以来，可解码和可编码协议是我最喜欢的功能。你可以在这里查看我第一篇关于Swift中的Codable enum的文章:<a class="ae kl" href="https://blog.untitledkingdom.com/codable-enums-in-swift-3ab3dacf30ce?gi=4c150f2a90ff" rel="noopener ugc nofollow" target="_blank">https://blog . untitled kingdom . com/Codable-enums-in-Swift-3a B3 dacf 30 ce？gi=4c150f2a90ff </a>。在本文中，我将介绍如何以一种非常简便的方式处理内部带有动态键的JSON响应。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7ffb4f5509a9c83e5e9224d6c64ef2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ectWuUYOGvbkZHNUNTRdVA.jpeg"/></div></div></figure><h1 id="7a68" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">情况</h1><p id="66b5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在我们的应用程序中，我们需要处理用户JSON表示，它可以通过两种不同的方式发送:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="bdfd" class="mg kz iq mc b gy mh mi l mj mk">{</span><span id="d0df" class="mg kz iq mc b gy ml mi l mj mk">"name": "Jon",</span><span id="5c2b" class="mg kz iq mc b gy ml mi l mj mk">"surname": "Doe",</span><span id="fabe" class="mg kz iq mc b gy ml mi l mj mk">"age": 42,</span><span id="47af" class="mg kz iq mc b gy ml mi l mj mk">"isAdmin": true</span><span id="4265" class="mg kz iq mc b gy ml mi l mj mk">}</span></pre><p id="8145" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="b2f7" class="mg kz iq mc b gy mh mi l mj mk">{</span><span id="0a3d" class="mg kz iq mc b gy ml mi l mj mk">"name": "Jan",</span><span id="fefc" class="mg kz iq mc b gy ml mi l mj mk">"surname": "Kowalski",</span><span id="c1f4" class="mg kz iq mc b gy ml mi l mj mk">"age": 42,</span><span id="27c8" class="mg kz iq mc b gy ml mi l mj mk">"isViewer": true</span><span id="6c5b" class="mg kz iq mc b gy ml mi l mj mk">}</span></pre><p id="d8f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它可以是一些遗留的API契约，它可以是来自第三方设备(如BLE设备)的一些响应，或者可能只是一些类似字符串的通信方式，无论如何，我们需要处理它，并且我们需要知道给定用户的角色。</p><p id="6724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从定义用户模型开始</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="2525" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JSONSerialization-way:</h1><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="5499" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它更像Obj-C代码，我们从将JSON字符串对象解析到Swift字典(类型为[String: Any])开始，然后根据字典中的值动态提取适当的角色和所有其他属性，如姓名和年龄。当然，这是可行的，但也有一些缺点。</p><p id="0021" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优点:</p><ul class=""><li id="7931" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">易于阅读和理解</li><li id="bda0" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">易于实施</li></ul><p id="d23c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong>:</p><ul class=""><li id="fa9b" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">重用性差</li><li id="5b75" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">不适用于通用解决方案(编码、映射)</li></ul><h1 id="b088" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">救援解码！</h1><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="146a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们将所有的键提取到DynamicKey对象中，然后我们在容器中匹配所有的键，寻找“isAdmin”或“isViewer”键。如果我们找到了给定的键，我们需要检查这个键的布尔值，然后我们可以存储适当的用户角色。</p><p id="4536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于所有其他键，我们使用传统的编码键枚举编码解决方案。</p><p id="8b87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> DynamicKey </strong>实现应该是这样的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4b71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点:</strong></p><ul class=""><li id="8236" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">通用和可重用(可解码)</li><li id="7716" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">可编码很容易被采用</li><li id="924b" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">您可以使用不同的序列化类型(JSON、XML)</li></ul><p id="61ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点:</strong></p><ul class=""><li id="16fc" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">更难阅读和理解</li></ul><h1 id="a3cf" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论:</h1><p id="5161" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在这篇文章中，我们再次看到可解码(和可编码)的协议比我们想象的更强大。有时，值得考虑实现“init(from: decoder)”实现，而不是采用映射或JSONSerialization路径。</p><p id="25b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这么快乐的代码！🚀</p></div></div>    
</body>
</html>