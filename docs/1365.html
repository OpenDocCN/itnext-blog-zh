<html>
<head>
<title>JavaScript Promises vs. RxJS Observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript承诺vs. RxJS观察值</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-promises-vs-rxjs-observables-de5309583ca2?source=collection_archive---------0-----------------------#2018-09-25">https://itnext.io/javascript-promises-vs-rxjs-observables-de5309583ca2?source=collection_archive---------0-----------------------#2018-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2b1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较JavaScript异步编程技术</h2></div><p id="c663" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不久前，我写了一篇关于JavaScript promises和Node.js的文章，在这篇文章中，我比较了在<strong class="kk iu"> ES6 </strong>中引入的原生JavaScript <strong class="kk iu"> promises </strong>和由<a class="ae le" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> RxJS </strong> </a>库提供的<strong class="kk iu"> observables </strong>。</p><p id="d704" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重点是强调承诺和可观察的差异和相似之处。目标是让你更容易理解那些你已经知道的承诺(反之亦然)。出于这个原因，我不在本文中讨论RxJS操作符，因为对于承诺来说，没有什么可以与这些操作符相比。</p><p id="c24f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，本文基于2018年4月24日<a class="ae le" href="https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md#600-2018-04-24" rel="noopener ugc nofollow" target="_blank">发布的最新版本RxJS的<strong class="kk iu"> RxJS 6 </strong>。</a></p><h1 id="455b" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">内容</h1><h2 id="b21d" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated"><a class="ae le" href="#ca20" rel="noopener ugc nofollow">JavaScript中的异步编程</a></h2><ul class=""><li id="aa3a" class="mj mk it kk b kl ml ko mm kr mn kv mo kz mp ld mq mr ms mt bi translated"><a class="ae le" href="#f41a" rel="noopener ugc nofollow"> <strong class="kk iu">回调</strong> </a></li><li id="7546" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#1430" rel="noopener ugc nofollow"> <strong class="kk iu">承诺</strong> </a></li><li id="1d35" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#2404" rel="noopener ugc nofollow"> <strong class="kk iu">异步/等待</strong> </a></li><li id="b03d" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#7056" rel="noopener ugc nofollow"> <strong class="kk iu"> RxJS可观测量</strong> </a></li></ul><h2 id="059c" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated"><a class="ae le" href="#62e1" rel="noopener ugc nofollow"> <strong class="ak">承诺与可观察到的事物</strong> </a></h2><ul class=""><li id="3d54" class="mj mk it kk b kl ml ko mm kr mn kv mo kz mp ld mq mr ms mt bi translated"><a class="ae le" href="#192d" rel="noopener ugc nofollow"> <strong class="kk iu">创作</strong> </a></li><li id="8482" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#e3be" rel="noopener ugc nofollow"> <strong class="kk iu">【创建(带错误处理)</strong> </a></li><li id="83db" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#0b4b" rel="noopener ugc nofollow"> <strong class="kk iu">用法</strong> </a></li><li id="a850" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#3c8e" rel="noopener ugc nofollow"> <strong class="kk iu">用法(带错误处理)</strong> </a></li><li id="fa90" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#5cb9" rel="noopener ugc nofollow"> <strong class="kk iu">创作+使用:例</strong> </a></li><li id="b2ca" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#aebe" rel="noopener ugc nofollow"> <strong class="kk iu">单值与多值</strong> </a></li><li id="c3f3" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#19c4" rel="noopener ugc nofollow"> <strong class="kk iu">急切vs .</strong></a></li><li id="4498" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#77f3" rel="noopener ugc nofollow"> <strong class="kk iu">不可撤销与可撤销</strong> </a></li><li id="b127" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#8838" rel="noopener ugc nofollow"> <strong class="kk iu">多播与单播</strong> </a></li><li id="b75b" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#1b97" rel="noopener ugc nofollow"> <strong class="kk iu">异步处理程序与同步处理程序</strong> </a></li></ul><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi mz"><img src="../Images/c4f5469e6392de2b02141a447c8debf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_By60RXqLLf_t7g2LS9cA.jpeg"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated"><a class="ae le" href="https://unsplash.com/photos/AQ6urd0B3xc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾瑞克·佩雷斯</a>在<a class="ae le" href="https://unsplash.com/search/photos/view?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</figcaption></figure><h1 id="ca20" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">JavaScript中的异步编程</h1><p id="de2f" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">首先，让我们回忆一下承诺和可观察性是怎么回事:处理异步执行。JavaScript中有不同的方法来创建异步代码。最重要的如下:</p><ul class=""><li id="29f8" class="mj mk it kk b kl km ko kp kr ns kv nt kz nu ld mq mr ms mt bi translated"><a class="ae le" href="#f41a" rel="noopener ugc nofollow"> <strong class="kk iu">回调</strong> </a></li><li id="1a75" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#1430" rel="noopener ugc nofollow"> <strong class="kk iu">承诺</strong> </a></li><li id="1a3a" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#2404" rel="noopener ugc nofollow"> <strong class="kk iu">异步/等待</strong> </a></li><li id="2cc6" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#7056" rel="noopener ugc nofollow"><strong class="kk iu">RxJS</strong></a></li></ul><p id="804e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面分别简单介绍一下。</p><h2 id="f41a" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">复试</h2><p id="9b25" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">这是异步编程的老式经典方法。您将一个函数作为参数提供给另一个执行异步任务的函数。当异步任务完成时，执行函数调用回调函数。</p><p id="114c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种方法的主要缺点发生在当你有多个链接的异步任务时，这需要你在回调函数内的回调函数内定义回调函数…这叫做<strong class="kk iu"> </strong> <a class="ae le" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">回调地狱</strong> </a>。</p><h2 id="1430" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">承诺</h2><p id="9513" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">在<a class="ae le" href="https://www.ecma-international.org/ecma-262/6.0/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">ES6</strong></a>【2015】中引入了承诺，允许比回调更可读的异步代码。</p><p id="4d07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回调和承诺的主要区别在于，使用回调，你<em class="nv"> </em> <strong class="kk iu">告诉执行函数</strong>当异步任务完成时做什么，而使用承诺，执行函数返回一个特殊对象给你(承诺)，然后你<strong class="kk iu">告诉承诺</strong>当异步任务完成时做什么。</p><p id="be5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上，这看起来像这样:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="23b8" class="lx lg it nx b gy ob oc l od oe">const promise = asyncFunc();</span><span id="9e84" class="lx lg it nx b gy of oc l od oe">promise.then(result =&gt; {<br/>    console.log(result);<br/>});</span></pre><p id="d104" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也就是说，与提供一个函数引用作为<code class="fe og oh oi nx b">asyncFunc</code>的参数不同(就像回调一样)，<code class="fe og oh oi nx b">asyncFunc</code>立即向您返回一个承诺，然后您向这个承诺提供异步任务完成时要采取的动作(通过它的<code class="fe og oh oi nx b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank">then</a></code>方法)。</p><h2 id="2404" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">异步/等待</h2><p id="0791" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">Async/await已经在<a class="ae le" href="https://www.ecma-international.org/ecma-262/8.0/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> ES8 </strong> </a> (2017)中引入。这个技巧应该列在<em class="nv">承诺</em>下，因为它只是处理承诺的语法糖。然而，这是一个真正值得一看的语法糖。</p><p id="b503" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上，你可以声明一个函数为<code class="fe og oh oi nx b">async</code>，这允许你在函数体中使用<code class="fe og oh oi nx b">await</code>关键字。关键字<code class="fe og oh oi nx b">await</code>可以放在计算结果为<em class="nv">承诺</em>的表达式前面。关键字<code class="fe og oh oi nx b">await</code>暂停<code class="fe og oh oi nx b">async</code>函数的执行，直到承诺被解决。当这种情况发生时，整个<code class="fe og oh oi nx b">await</code>表达式计算出承诺的结果值，然后<code class="fe og oh oi nx b">async</code>函数继续执行。</p><p id="3fed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，<code class="fe og oh oi nx b">async</code>函数本身也返回一个承诺，该承诺在函数体执行完成时被解析。</p><p id="7d3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过下面的例子来看看这在实践中是怎样的:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="5b45" class="lx lg it nx b gy ob oc l od oe">function asyncTask(i) {<br/>    return <strong class="nx iu">new Promise</strong>(resolve =&gt; resolve(i + 1));<br/>}</span><span id="6fd5" class="lx lg it nx b gy of oc l od oe"><strong class="nx iu">async</strong> function runAsyncTasks() {<br/>    const res1 = <strong class="nx iu">await</strong> asyncTask(0);<br/>    const res2 = <strong class="nx iu">await</strong> asyncTask(res1);<br/>    const res3 = <strong class="nx iu">await</strong> asyncTask(res2);<br/>    return "Everything done"<br/>}</span><span id="1d3f" class="lx lg it nx b gy of oc l od oe">runAsyncTasks().then(result =&gt; console.log(result));</span></pre><p id="fa7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe og oh oi nx b">asyncTask</code>函数实现一个异步任务，该任务接受一个参数并返回一个结果。该函数返回一个承诺，该承诺在异步任务完成时得到解决。这个函数没有什么特别的，它只是一个返回承诺的普通函数。</p><p id="d86b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面,<code class="fe og oh oi nx b">runAsyncTasks</code>函数被声明为<code class="fe og oh oi nx b">async</code>,这样<code class="fe og oh oi nx b">await</code>关键字就可以在函数体中使用。这个函数调用<code class="fe og oh oi nx b">asyncTask</code>三次，每次参数必须是前面调用<code class="fe og oh oi nx b">asyncTask</code>的结果(即我们链接了三个异步任务)。</p><p id="5355" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个<code class="fe og oh oi nx b">await</code>关键字使<code class="fe og oh oi nx b">runAsyncTasks</code>的执行停止，直到<code class="fe og oh oi nx b">asyncTask(0)</code>返回的承诺得到解决。然后，整个<code class="fe og oh oi nx b">await asyncTask(0)</code>表达式计算出已解析承诺的结果值，并分配给<code class="fe og oh oi nx b">res1</code>。此时，<code class="fe og oh oi nx b">asyncTask(res1)</code>被调用，第二个<code class="fe og oh oi nx b">await</code>关键字导致<code class="fe og oh oi nx b">runAsyncTasks</code>的执行再次停止，直到<code class="fe og oh oi nx b">asyncTask(res1)</code>返回的承诺被解决。这一直持续到最后执行完<code class="fe og oh oi nx b">runAsyncTasks</code>函数体中的所有语句。</p><p id="aaba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所述，<code class="fe og oh oi nx b">async</code>函数返回一个承诺本身，当函数体的执行完成时，这个承诺用函数的返回值来解决。因此，换句话说，<code class="fe og oh oi nx b">async</code>函数本身就是一个异步任务(通常管理其他异步任务的执行)。这可以在最后一行中看到，我们在返回的承诺上调用<code class="fe og oh oi nx b">then</code>函数来打印出<code class="fe og oh oi nx b">async</code>函数的返回值。</p><p id="da4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您在<code class="fe og oh oi nx b">runAsyncTasks</code>函数中的每个赋值语句后添加日志语句，那么输出将如下所示:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="21ed" class="lx lg it nx b gy ob oc l od oe">1<br/>2<br/>3<br/>Everything done</span></pre><p id="ed0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我声称async/await只是承诺的语法糖。如果这是真的，那么我们必须能够用纯粹的承诺来实现上面的例子。是的，我们可以，看起来是这样的:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="3f34" class="lx lg it nx b gy ob oc l od oe">function asyncTask(i) {<br/>    return new Promise(resolve =&gt; resolve(i + 1));<br/>}</span><span id="5b01" class="lx lg it nx b gy of oc l od oe">function runAsyncTasks() {<br/>    <strong class="nx iu">return asyncTask</strong>(0)<br/>        .<strong class="nx iu">then</strong>(res1 =&gt; { <strong class="nx iu">return</strong> <strong class="nx iu">asyncTask</strong>(res1); })<br/>        .<strong class="nx iu">then</strong>(res2 =&gt; { <strong class="nx iu">return</strong> <strong class="nx iu">asyncTask</strong>(res2); })<br/>        .<strong class="nx iu">then</strong>(res3 =&gt; { return "Everything done"; });<br/>}</span><span id="8417" class="lx lg it nx b gy of oc l od oe">runAsyncTasks().then(result =&gt; console.log(result));</span></pre><p id="fe71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码相当于async/await版本，如果您在匿名函数体中添加适当的日志语句，那么它会产生与async/await版本相同的输出。</p><p id="621f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一改变的是<code class="fe og oh oi nx b">runAsyncTasks</code>功能。它现在是一个常规函数(不是<code class="fe og oh oi nx b">async</code>)，它使用<code class="fe og oh oi nx b">then</code>来链接<code class="fe og oh oi nx b">asyncTask</code>(而不是<code class="fe og oh oi nx b">await</code>)返回的承诺。</p><p id="5695" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为async/await版本比promise版本可读性更好，也更容易理解，这一点不用多说。事实上，async/await的主要创新是允许编写看起来像同步代码的异步代码。</p><h2 id="7056" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">RxJS可观测量</h2><p id="c781" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">首先，RxJS是<a class="ae le" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">react vex</strong></a>项目的JavaScript实现。ReactiveX项目旨在为不同的编程语言提供异步编程的API。</p><p id="51d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">react vex的基本范例是四人帮的<a class="ae le" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">观察者模式</strong></a><strong class="kk iu"/>(react vex甚至用完成和错误通知扩展了观察者模式)。因此，所有ReactiveX实现的核心抽象是可观察的<strong class="kk iu"/>。你可以在这里阅读更多关于react vex<a class="ae le" href="http://reactivex.io/intro.html" rel="noopener ugc nofollow" target="_blank">的基本概念。</a></p><p id="83af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ReactiveX API以各种编程语言实现。如前所述，<strong class="kk iu"> RxJS </strong>是ReactiveX的JavaScript实现。除此之外，还有，例如，<strong class="kk iu"> RxJava </strong> (Java)、<strong class="kk iu"> RxKotlin </strong> (Kotlin)、<strong class="kk iu"> Rx.rb </strong> (Ruby)、<strong class="kk iu"> RxPY </strong> (Python)、<strong class="kk iu"> RxSwift </strong> (Swift)、<strong class="kk iu">Rx.NET</strong>(c#)实现，还有很多更多(此处见概述<a class="ae le" href="http://reactivex.io/languages.html" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="baca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着，如果你理解了RxJS中的可观测量，那么你也理解了RxJava或Rx.NET或任何其他实现中的可观测量，你可以使用这些库，而不必学习新概念。</p><p id="9580" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，现在我们知道RxJS是什么，但是<strong class="kk iu">什么是可观测？让我们试着从两个维度来描述它，并与其他已知的抽象进行比较。尺寸为<strong class="kk iu">同步/异步</strong>和<strong class="kk iu">单值/多值</strong>。</strong></p><p id="6693" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于一个<strong class="kk iu">可观测的</strong>，我们可以说以下是真实的:</p><ul class=""><li id="9eea" class="mj mk it kk b kl km ko kp kr ns kv nt kz nu ld mq mr ms mt bi translated"><strong class="kk iu">发射多倍数值</strong></li><li id="f7b7" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><strong class="kk iu">异步发出其值(“推送”)</strong></li></ul><p id="e617" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们将这与我们刚刚在上一个小节中介绍的<strong class="kk iu">承诺</strong>进行对比:</p><ul class=""><li id="0b57" class="mj mk it kk b kl km ko kp kr ns kv nt kz nu ld mq mr ms mt bi translated"><strong class="kk iu">发出单值</strong></li><li id="f923" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><strong class="kk iu">异步发出其值(“推送”)</strong></li></ul><p id="751b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们来看一个<strong class="kk iu">可迭代</strong>。这是一种抽象，存在于许多编程语言中，可用于遍历集合数据结构(如数组)的所有元素。对于iterable，以下情况成立:</p><ul class=""><li id="268d" class="mj mk it kk b kl km ko kp kr ns kv nt kz nu ld mq mr ms mt bi translated"><strong class="kk iu">发出多个值</strong></li><li id="84a0" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><strong class="kk iu">同步发出其值(“拉”)</strong></li></ul><p id="fd9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，对于s <em class="nv">同步/拉取</em>和<em class="nv">异步/推取</em>，我的意思是:<strong class="kk iu">同步/拉取</strong>意味着客户端代码<em class="nv">从抽象中请求</em>一个值，并且<em class="nv">阻塞</em>直到这个值被返回。<strong class="kk iu">异步/推送</strong>意味着抽象<em class="nv">通知</em>客户端代码正在发出一个新值，客户端代码<em class="nv">处理</em>这个通知。</p><p id="54b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们沿着维度图形化地排列这些抽象，我们会得到下面的图片(取自<a class="ae le" href="http://reactivex.io/intro.html" rel="noopener ugc nofollow" target="_blank"> ReactiveX </a>):</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oj"><img src="../Images/e72dbc64f0dc256486555c7640c7bf2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmssYb_HK2vWz4bN-0l1mA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">注意，在一些编程语言中，承诺被称为<em class="ok">未来</em>(例如在Java中)。</figcaption></figure><p id="6a8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们还没有提到<strong class="kk iu"> Get </strong>，但这仅代表普通的数据访问操作，如常规的函数调用。</p><p id="c743" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看上图，我们可以说一个<em class="nv">可观察的</em>对于一个<em class="nv">可重复的</em>就像一个<em class="nv">承诺</em>对于一个<em class="nv">得到</em>的操作。或者说<em class="nv">承诺</em>类似于<em class="nv">异步get </em>操作，而<em class="nv">可观察</em>类似于<em class="nv">异步可迭代</em>。</p><p id="1334" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以说，承诺和可观察之间的主要区别是，承诺只发出一个值，而可观察发出多个值。</p><p id="6f0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是让我们更详细地看一下。通过一个简单的<strong class="kk iu"> get </strong>操作，例如一个函数调用，调用代码请求一个单一的值，然后等待或阻塞，直到函数返回这个值(调用代码<em class="nv">拉取</em>这个值)。</p><p id="8a8b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，有了<strong class="kk iu">承诺</strong>，调用代码也请求单个值，但是它不会阻塞，直到值被返回。它只是开始计算，然后继续执行自己的代码。当promise完成值的计算时，它将值发送给调用代码，然后调用代码处理该值(该值被<em class="nv">推送到</em>调用代码)。</p><p id="ef7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们来看看一个<strong class="kk iu">可迭代的</strong>。在许多编程语言中，我们可以从一个集合数据结构中创建一个iterable，比如一个数组。iterable通常有一个<code class="fe og oh oi nx b">next</code>方法，它从集合中返回下一个未读的值。然后调用代码可以重复调用<code class="fe og oh oi nx b">next</code>来读取集合的所有值。每个<code class="fe og oh oi nx b">next</code>调用基本上都是一个同步阻塞<em class="nv"> get </em>操作，如上所述(调用代码反复<em class="nv">拉</em>值)。</p><p id="b8d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<strong class="kk iu">可观测的</strong>把这个可测量的东西带到了异步世界。像iterable一样，observable计算并发出一串值。然而，与iterable不同，对于observable，调用代码不会同步地<em class="nv">拉取</em>每个值，而是observable异步地<em class="nv">将每个值(一旦可用)推送到调用代码。为此，调用代码向可观察对象提供一个处理函数，在RxJS中称为<code class="fe og oh oi nx b">next</code>，然后可观察对象为它计算的每个值调用这个函数。</em></p><p id="32f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个可观察对象发出的值可以是任何东西:数组的元素、HTTP请求的结果(如果一个可观察对象只发出一个值也可以，不一定总是多个值)、用户输入事件，比如鼠标点击，等等。这使得observables非常灵活。此外，由于可观察对象也只能发出单一值，因此可观察对象可以做承诺可以做的一切，但反之则不成立。</p><p id="7ac5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除此之外，ReactiveX observables提供了大量所谓的<strong class="kk iu">运算符</strong>。这些是可以应用于可观察对象的函数，以便修改一组发射值。常见的运算符类别有<em class="nv">组合</em>、<em class="nv">过滤器</em>和<em class="nv">转换</em>。</p><p id="30a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，有一个<code class="fe og oh oi nx b">map</code>操作符，我们可以配置如下:<code class="fe og oh oi nx b">map(value =&gt; 2 * value)</code>，然后我们可以将这个操作符应用于一个可观察对象。其效果是，可观察对象发出的每个值在被推送到调用代码之前都要乘以2。</p><p id="f78c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RxJS中操作员的完整列表可在处<a class="ae le" href="https://rxjs-dev.firebaseapp.com/api?query=operators" rel="noopener ugc nofollow" target="_blank">找到。然而，在这篇文章中，我不讨论操作符，因为这篇文章的重点是比较承诺和可观察的，而承诺没有任何东西可以和可观察的操作符相比。</a></p><p id="5447" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个简短的代码示例，展示了RxJS可观察对象的创建和使用(创建和使用可观察对象的语法将在下一节解释):</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="34e5" class="lx lg it nx b gy ob oc l od oe">// Creation<br/>const<strong class="nx iu"> </strong>observable = new<strong class="nx iu"> </strong>Observable(observer =&gt; {<br/>  for<strong class="nx iu"> </strong>(let<strong class="nx iu"> </strong>i = 0; i &lt; 3; i++) {<br/>    observer.next(i);<br/>  }<br/>});</span><span id="0e66" class="lx lg it nx b gy of oc l od oe">// Usage<br/>observable.subscribe(value =&gt; console.log(value));</span></pre><p id="c832" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就结束了我们对JavaScript异步编程技术的概述。我们已经看到有<strong class="kk iu">回调</strong>，这是老式的，<strong class="kk iu">承诺</strong>，可以用来异步获取单个值，<strong class="kk iu">异步/等待</strong>，这是承诺的语法糖，以及RxJS <strong class="kk iu">可观察值</strong>，可以用来异步获取值流。</p><p id="fe43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一节中，我们将特别强调承诺和可观察到的事物之间的异同。</p><h1 id="62e1" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">承诺与观察</h1><p id="7ab3" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">在这一节中，我们将承诺和可观察到的事物放在一起比较，并强调它们的不同和相似之处。</p><p id="34b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，如果您想要运行下面包含observables的代码示例，您必须安装并导入RxJS库。</p><p id="fc82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以按如下方式安装RxJS:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="3ece" class="lx lg it nx b gy ob oc l od oe">npm install --save rxjs</span></pre><p id="6cff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在代码文件中导入<code class="fe og oh oi nx b">Observable</code>构造函数(这就是这些例子所需要的),如下所示:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="bccd" class="lx lg it nx b gy ob oc l od oe">import<strong class="nx iu"> </strong>{ Observable } from<strong class="nx iu"> </strong>'rxjs';</span></pre><p id="5dff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您使用Node.js，您必须以如下不同的方式进行导入(因为Node.js还不支持<code class="fe og oh oi nx b">import</code>语句):</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="a21f" class="lx lg it nx b gy ob oc l od oe">const { Observable } = require('rxjs');</span></pre><p id="8ea5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下所有代码片段都省略了这些导入语句。</p><h2 id="192d" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">创造</h2><p id="4294" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">让我们看看如何创造一个承诺与如何创造一个可观察的。为了简单起见，我们将首先忽略错误，只考虑承诺和可观察到的“成功”执行。我们将在下一小节中介绍错误。</p><p id="6809" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，承诺和可观察性都有两面性:<strong class="kk iu">创造</strong>和<strong class="kk iu">使用</strong>。承诺/可观察是首先需要由某人<em class="nv">创造</em>的对象。在它被创建之后，它通常被传递给使用它的其他人。创建定义了承诺/可观察的行为和发出的值，使用定义了对这些发出的值的处理。</p><p id="309a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个典型的用例是承诺/可观察值由API函数<em class="nv">创建</em>并返回给API的用户。API的用户然后<em class="nv">使用</em>这些承诺/可观察到的。所以，如果你使用一个API，你通常只需要<em class="nv">使用</em>承诺/可观察到的东西，而如果你是一个API的作者，你也必须<em class="nv">创建</em>承诺/可观察到的东西。</p><p id="7873" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下文中，我们将首先看看承诺/可观察的<em class="nv">创造</em>，我们将在随后的<a class="ae le" href="#0b4b" rel="noopener ugc nofollow">小节</a>中看看它们的<em class="nv">用法</em>。</p><p id="724d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">承诺:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="16fc" class="lx lg it nx b gy ob oc l od oe">new Promise(executorFunc);</span><span id="2dac" class="lx lg it nx b gy of oc l od oe">function executorFunc(resolve) {<br/>    // Some code...<br/>    resolve(value);<br/>}</span></pre><p id="bf69" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创建一个承诺，你调用<code class="fe og oh oi nx b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>构造函数，并把一个所谓的<em class="nv">执行函数</em>作为参数传递给它。创建承诺时，系统会调用executor函数，并将其作为参数传递给一个特殊的<code class="fe og oh oi nx b">resolve</code>函数(您可以随意命名该参数，只需记住executor函数的第一个<em class="nv">参数是resolve函数，您必须像这样使用<em class="nv"> </em>)。</em></p><p id="d48f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您调用executor函数体中的<code class="fe og oh oi nx b">resolve</code>函数时，承诺被转换为<em class="nv">已履行</em>状态，并且您作为参数传递给<code class="fe og oh oi nx b">resolve</code>函数的值被“发出”(承诺被解析)。</p><p id="44ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，这个发出的值将被用作<em class="nv">未完成的</em>函数的参数，您将它作为第一个参数传递给承诺的<em class="nv">用法</em>方的承诺的<code class="fe og oh oi nx b">then</code>函数，我们将在后面的中看到<a class="ae le" href="#0b4b" rel="noopener ugc nofollow">。</a></p><p id="42f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">可观测量:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="7af6" class="lx lg it nx b gy ob oc l od oe">new Observable(subscriberFunc);</span><span id="117a" class="lx lg it nx b gy of oc l od oe">function subscriberFunc(observer) {<br/>    // Some code...<br/>    observer.next(value);<br/>}</span></pre><p id="8708" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创建一个可观察对象，您调用<code class="fe og oh oi nx b"><a class="ae le" href="https://rxjs-dev.firebaseapp.com/api/index/class/Observable" rel="noopener ugc nofollow" target="_blank">Observable</a></code>构造函数，将一个所谓的<em class="nv">订户函数</em>作为参数传递给它。每当一个新用户订阅该可观察对象时，系统就调用订阅者函数。订户函数获得一个<em class="nv">观察者</em>对象作为参数。这个对象有一个方法<code class="fe og oh oi nx b">next</code>，当这个方法被调用时，<em class="nv">会发出</em>你作为参数从可观察对象传递给它的值。</p><p id="d2c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，调用<code class="fe og oh oi nx b">next</code>后，订阅者函数保持运行，还可以再调用<code class="fe og oh oi nx b">next</code>很多次。这是与promises的一个重要区别，在promises中，调用<code class="fe og oh oi nx b">resolve</code>后，executor函数被终止。承诺最多可以发出一个值，而可观察值可以发出任意数量的值。</p><h2 id="e3be" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">创建(带错误处理)</h2><p id="11cc" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">上面的例子还没有显示承诺和可观察的全部能力。错误可能发生在承诺/可观察的执行过程中，这两种技术都提供了向“使用”它们的代码指出这种错误的方法。</p><p id="1128" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面用错误处理能力扩展了上面的解释。</p><p id="1445" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">承诺:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="bb11" class="lx lg it nx b gy ob oc l od oe">new Promise(executorFunc);</span><span id="bf31" class="lx lg it nx b gy of oc l od oe">function executorFunc(resolve, reject) {<br/>    // Some code...<br/>    resolve(value);<br/>    // Some code...<br/>    reject(error);<br/>}</span></pre><p id="a396" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">传递给<code class="fe og oh oi nx b">Promise</code>构造函数的executor函数实际上获得了第二个参数，即<code class="fe og oh oi nx b">reject</code>函数。<code class="fe og oh oi nx b">reject</code>功能用于指示承诺执行中的错误。当你调用它时，executor函数被中止，承诺转移到<em class="nv">拒绝</em>状态。</p><p id="6041" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用方面，这将导致<em class="nv">on被弹出的</em>函数(您可以将其传递给<code class="fe og oh oi nx b">catch</code>方法)被执行。</p><p id="678f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">可观测量:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="fbe8" class="lx lg it nx b gy ob oc l od oe">new Observable(subscriberFunc);</span><span id="9bd5" class="lx lg it nx b gy of oc l od oe">function subscriberFunc(observer) {<br/>    // Some code...<br/>    observer.next(value);<br/>    // Some code...<br/>    observer.error(error);<br/>}</span></pre><p id="2fe2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为参数传递给订阅者函数的observer对象实际上还有一个方法:<code class="fe og oh oi nx b">error</code>方法。调用此方法会向可观察对象的订阅者指示一个错误。</p><p id="24c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与<code class="fe og oh oi nx b">next</code>不同，调用<code class="fe og oh oi nx b">error</code>方法也会终止订户函数，从而终止可观察对象。这意味着<code class="fe og oh oi nx b">error</code>在一个可观察对象的生命周期内最多只能被调用一次。</p><p id="cbf2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe og oh oi nx b">next</code>和<code class="fe og oh oi nx b">error</code>仍然不是全部的真相。传递给订阅者函数的observer对象还有一个方法:<code class="fe og oh oi nx b">complete</code>。其用法如下所示:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="a33b" class="lx lg it nx b gy ob oc l od oe">new Observable(subscriberFunc);</span><span id="6a46" class="lx lg it nx b gy of oc l od oe">function subscriberFunc(observer) {<br/>    // Some code...<br/>    observer.next(value);<br/>    // If there is an error...<br/>    observer.error(error);<br/>    // If all successful...<br/>    observer.complete();<br/>}</span></pre><p id="9ebe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个可观察对象成功“完成”时，应该调用<code class="fe og oh oi nx b">complete</code>方法。完成意味着没有更多的工作要做，也就是说，所有的值都已经发出。像<code class="fe og oh oi nx b">error</code>方法一样，<code class="fe og oh oi nx b">complete</code>方法终止了订阅者函数的执行，这意味着<code class="fe og oh oi nx b">complete</code>方法在一个可观察对象的生命周期内最多只能被调用一次。</p><p id="d557" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，建议调用可观察执行的<code class="fe og oh oi nx b">conplete</code>方法，但不是强制的。</p><h2 id="0b4b" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">使用</h2><p id="ae2d" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">在介绍了<em class="nv"> </em>的<em class="nv">创造</em>和可观察到的之后，现在让我们看看它们的<em class="nv">用法</em>。使用promise或observable意味着“订阅”它，这又意味着用promise或observable注册一个处理函数，该函数将为每个发出的值(promise的一个值，observable的任意多个值)调用。</p><p id="7d3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">处理函数的注册是通过promise或observable对象的特殊方法来完成的。这些方法分别是:</p><ul class=""><li id="f572" class="mj mk it kk b kl km ko kp kr ns kv nt kz nu ld mq mr ms mt bi translated"><strong class="kk iu">许诺:</strong> <code class="fe og oh oi nx b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">then</strong></a></code></li><li id="2e62" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><strong class="kk iu">可观察:</strong> <code class="fe og oh oi nx b"><a class="ae le" href="https://rxjs-dev.firebaseapp.com/api/index/class/Observable#subscribe-" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">subscribe</strong></a></code></li></ul><p id="7ff4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下文中，我们将展示这些方法在承诺和可观察方面的基本用法。同样，我们将首先考虑忽略错误处理的基本情况，然后在下一小节中添加错误处理。</p><p id="f919" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，在下面的代码片段中，我们假设承诺或可观察对象已经存在。因此，如果您想运行代码，您必须在它前面加上一个promise或observable creation语句，例如:</p><ul class=""><li id="a51a" class="mj mk it kk b kl km ko kp kr ns kv nt kz nu ld mq mr ms mt bi translated"><code class="fe og oh oi nx b">const promise = new Promise(/*...*/);</code></li><li id="22ed" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe og oh oi nx b">const observable = new Observable(/*...*/)</code></li></ul><p id="e6ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">承诺:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="9d7f" class="lx lg it nx b gy ob oc l od oe">promise.then(onFulfilled);</span><span id="3d92" class="lx lg it nx b gy of oc l od oe">function onFulfilled(value) {<br/>    // Do something with value...<br/>}</span></pre><p id="13fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">给定一个promise对象，我们调用这个对象的<code class="fe og oh oi nx b">then</code>方法，并传递给它一个<em class="nv"> onFulfilled </em>函数作为参数。<em class="nv">on completed</em>函数采用单个参数。这个参数就是承诺的结果值，也就是已经传递给承诺内部的<code class="fe og oh oi nx b">resolve</code>函数的值。</p><p id="c044" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">可观测量:</strong></p><p id="ad96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用一个可观察对象意味着订阅它，这是通过一个可观察对象的<code class="fe og oh oi nx b">subscribe</code>方法来完成的。使用<code class="fe og oh oi nx b">subscribe</code>方法实际上有两种等效的方式。在下文中，我们将介绍这两者:</p><p id="8686" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">备选方案1: </em></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="b07f" class="lx lg it nx b gy ob oc l od oe">observable.subscribe(nextFunc);</span><span id="894d" class="lx lg it nx b gy of oc l od oe">function nextFunc(value) {<br/>    // Do something with value...<br/>}</span></pre><p id="e9b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们调用一个可观察对象的<code class="fe og oh oi nx b">subscribe</code>方法，并传递给它一个<em class="nv"> next </em>函数作为参数。这个<em class="nv">下一个</em>函数接受一个参数。每当可观察对象发出一个值时，该参数就是当前发出的值。</p><p id="a52c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，每当可观察对象的内部订户函数调用<code class="fe og oh oi nx b">next</code>方法时，您的<em class="nv">下一个</em>函数将被调用，其值将被传递给<code class="fe og oh oi nx b">next</code>(从而将值从可观察对象发送到您的处理函数)。</p><p id="6bba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">选项2: </em></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="d186" class="lx lg it nx b gy ob oc l od oe">observable.subscribe({<br/>    next: nextFunc<br/>});</span><span id="1d8d" class="lx lg it nx b gy of oc l od oe">function nextFunc(value) {<br/>    // Do something with value...<br/>    console.log(value);<br/>}</span></pre><p id="ddba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个选项可能看起来有点奇怪，但实际上它更好地显示了幕后发生的事情。</p><p id="4615" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们调用<code class="fe og oh oi nx b">subscribe</code>不是用函数作为参数，而是用一个对象。该对象有一个属性，带有一个名为<code class="fe og oh oi nx b">next</code>的键和一个函数值。这个函数不是别的，就是我们上面的老<em class="nv">下一个</em>函数。</p><p id="e630" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他都保持不变，我们只是在一个对象内部传递下一个函数，而不是直接作为参数。但是为什么我们要在将处理函数传递给<code class="fe og oh oi nx b">subscribe</code>方法之前将它包装在一个对象中呢？</p><p id="b96f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样可以传递给<code class="fe og oh oi nx b">subscribe</code>的对象实际上是实现了<code class="fe og oh oi nx b"><a class="ae le" href="https://rxjs-dev.firebaseapp.com/api/index/interface/Observer" rel="noopener ugc nofollow" target="_blank">Observer</a></code>接口的对象。也许你还记得，当我们在前面的小节中创建observables时，我们曾经定义了一个订阅者函数，这个订阅者函数有一个我们称之为<code class="fe og oh oi nx b">observer</code>的参数。特别是，我们使用了这样的代码:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="40ae" class="lx lg it nx b gy ob oc l od oe">new Observable(subscriberFunc);</span><span id="1d98" class="lx lg it nx b gy of oc l od oe">function subscriberFunc(observer) {<br/>    // Some code...<br/>    observer.next(value);<br/>}</span></pre><p id="745e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">subscriber函数的<code class="fe og oh oi nx b">observer</code>参数直接对应我们上面传递给<code class="fe og oh oi nx b">subscribe</code>的对象(实际上，传递给<code class="fe og oh oi nx b">subscribe</code>的对象在传递给subscriber函数之前，先从类型<code class="fe og oh oi nx b"><a class="ae le" href="https://rxjs-dev.firebaseapp.com/api/index/interface/Observer" rel="noopener ugc nofollow" target="_blank">Observer</a></code>转换为<code class="fe og oh oi nx b"><a class="ae le" href="https://rxjs-dev.firebaseapp.com/api/index/class/Subscriber" rel="noopener ugc nofollow" target="_blank">Subscriber</a></code>，<code class="fe og oh oi nx b">Subscriber</code>实现<code class="fe og oh oi nx b">Observer</code>接口)。</p><p id="2b0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，使用选项2，我们已经创建了一个对象，它形成了将被传递到可观察对象的订阅者函数中的实际对象的基础，而使用选项1，我们仅仅提供了将被用作该对象的方法的函数。</p><p id="d5a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这两个选项中的哪一个是个人喜好和编码风格的问题。请注意，如果使用选项2，下一个函数<em class="nv">的<em class="nv">的对象属性键必须被强制调用</em>。这由该对象需要实现的<code class="fe og oh oi nx b"><a class="ae le" href="https://rxjs-dev.firebaseapp.com/api/index/interface/Observer" rel="noopener ugc nofollow" target="_blank">Observer</a></code>接口决定。</em></p><h2 id="3c8e" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">用法(带错误处理)</h2><p id="3184" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">像以前一样，我们现在扩展使用示例，以包括错误处理。在这种情况下，错误处理意味着提供一个特殊的处理函数来处理由承诺或可观察到的潜在错误(除了处理从承诺或可观察到的“常规”值的“常规”处理函数之外)。</p><p id="73c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于承诺和可观察值，在两种情况下都会发出错误:</p><ol class=""><li id="2e74" class="mj mk it kk b kl km ko kp kr ns kv nt kz nu ld ol mr ms mt bi translated">promise或observable实现分别调用<code class="fe og oh oi nx b">reject</code>函数或<code class="fe og oh oi nx b">error</code>方法(参见上面的)。</li><li id="df2e" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld ol mr ms mt bi translated">promise或observable实现用关键字<code class="fe og oh oi nx b">throw</code>抛出一个错误。</li></ol><p id="f1a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看如何处理承诺和可观察到的这些类型的错误。</p><p id="6f45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">承诺:</strong></p><p id="507c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上有两种方法来处理从承诺发出的错误。第一个使用了<code class="fe og oh oi nx b">then</code>方法的第二个参数，第二个使用了方法链接。在接下来的文章中，我们将介绍这两种方法。</p><p id="ffde" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">选项1(</em><code class="fe og oh oi nx b"><em class="nv">then</em></code><em class="nv">的第二个自变量):</em></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="a3fb" class="lx lg it nx b gy ob oc l od oe">promise.then(onFulfilled, onRejected);</span><span id="cbcb" class="lx lg it nx b gy of oc l od oe">function onFulfilled(value) {<br/>    // Do something with value...<br/>}</span><span id="f7b2" class="lx lg it nx b gy of oc l od oe">function onRejected(error) {<br/>    // Do something with error...<br/>}</span></pre><p id="ef0e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">promise的<code class="fe og oh oi nx b">then</code>方法接受第二个函数参数，这是被抛出的函数的<em class="nv">。当promise的executor函数调用<code class="fe og oh oi nx b">reject</code>函数时，或者当promise的executor函数抛出一个带有<code class="fe og oh oi nx b">throw</code>关键字的错误时，就会调用这个函数。</em></p><p id="dc43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提供一个<em class="nv"> onRejected </em>函数允许你处理这样的错误。如果您不提供它，那么错误仍然可能发生，但是您的代码不会处理它们。</p><p id="427a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">选项2(方法链接):</em></p><p id="cecc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个选项使用了一个链式<code class="fe og oh oi nx b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">catch</strong></a></code> <strong class="kk iu"> </strong>方法，看起来是这样的:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="ed3c" class="lx lg it nx b gy ob oc l od oe">promise.then(onFulfilled).catch(onRejected);</span><span id="0b95" class="lx lg it nx b gy of oc l od oe">function onFulfilled(value) {<br/>    // Do something with value...<br/>}</span><span id="e0ff" class="lx lg it nx b gy of oc l od oe">function onRejected(error) {<br/>    // Do something with error...<br/>}</span></pre><p id="f762" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也就是说，我们并没有将<em class="nv">未完成的</em>和<em class="nv">未完成的</em>函数都提供给<code class="fe og oh oi nx b">then</code>方法，而是只将<em class="nv">未完成的</em>方法提供给<code class="fe og oh oi nx b">then</code>，然后调用<code class="fe og oh oi nx b">then</code>返回的承诺的<code class="fe og oh oi nx b">catch</code>方法，并将<em class="nv">未完成的</em>函数传递给这个<code class="fe og oh oi nx b">catch</code>方法。注意，在这种情况下，我们调用<code class="fe og oh oi nx b">catch</code> on(并由<code class="fe og oh oi nx b">then</code>返回)的承诺与初始承诺相同。</p><p id="9400" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe og oh oi nx b">catch</code>的第二个选项实际上比第一个选项更常见。它利用了重要的<strong class="kk iu">链接</strong>承诺的能力。对承诺链的讨论超出了本文的范围，但是例如，在这里的<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#Chaining#Chaining" rel="noopener ugc nofollow" target="_blank">中有所描述。</a></p><p id="44b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于链接需要注意的重要一点是<code class="fe og oh oi nx b">then</code>和<code class="fe og oh oi nx b">catch</code>总是返回一个承诺，这允许在同一个语句中重复调用这些方法，如上所示。返回的承诺要么与上一个承诺相同，要么是新的承诺。后一种情况允许嵌套的异步任务(如果我们使用回调，这将导致回调地狱)在没有任何嵌套形式的情况下被“简单地”处理。顺便说一下，这是承诺相对于回调的主要优势之一。</p><p id="7b02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个值得一提的是，<code class="fe og oh oi nx b">catch</code>实际上并没有什么特别之处。事实上，<code class="fe og oh oi nx b">catch</code>方法只是对<code class="fe og oh oi nx b">then</code>方法的某种调用的语法糖。特别是，调用<code class="fe og oh oi nx b">catch</code>时将<em class="nv"> onRejected </em>函数作为它唯一的参数相当于调用<code class="fe og oh oi nx b">then</code>时将<code class="fe og oh oi nx b">undefined</code>作为第一个参数，将<em class="nv"> onRejected </em>作为第二个参数。</p><p id="a57f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，以下两个语句是等价的:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="1db2" class="lx lg it nx b gy ob oc l od oe">promise.then(onFulfilled).catch(onRejected);<br/>promise.then(onFulfilled).then(undefined, onRejected);</span></pre><p id="b69a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以在概念上将<code class="fe og oh oi nx b">then</code>和<code class="fe og oh oi nx b">catch</code>的链简化为<code class="fe og oh oi nx b">then</code>的纯链，这使得有时更容易对它们进行推理。</p><p id="89d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">可观测量:</strong></p><p id="d347" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如上一小节已经提到的，有两种方法可以调用一个可观察对象的<code class="fe og oh oi nx b">subscribe</code>方法。一个使用对象(实现<code class="fe og oh oi nx b">Observer</code>)作为参数，另一个使用函数作为参数。</p><p id="a492" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我们将介绍这两种风格。</p><p id="6dc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">选项1(函数参数):</em></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="4b22" class="lx lg it nx b gy ob oc l od oe">observable.subscribe(nextFunc, errorFunc);</span><span id="1bdc" class="lx lg it nx b gy of oc l od oe">function nextFunc(value) {<br/>    // Do something with value...<br/>}</span><span id="d53c" class="lx lg it nx b gy of oc l od oe">function errorFunc(error) {<br/>    // Do something with error...<br/>}</span></pre><p id="d13d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与前一小节中没有错误处理的情况的唯一区别是，我们将第二个函数参数传递给了<code class="fe og oh oi nx b">subscribe</code>方法。第二个参数是<em class="nv"> error </em>函数，每当可观察对象的订阅者函数调用其传递的观察者参数的<code class="fe og oh oi nx b">error</code>方法，或者用<code class="fe og oh oi nx b">throw</code>抛出错误时，都会调用这个函数。</p><p id="d002" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">选项2(对象自变量):</em></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="b8bd" class="lx lg it nx b gy ob oc l od oe">observable.subscribe({<br/>    next: nextFunc,<br/>    error: errorFunc<br/>});</span><span id="cdb5" class="lx lg it nx b gy of oc l od oe">function nextFunc(value) {<br/>    // Do something with value...<br/>}</span><span id="727c" class="lx lg it nx b gy of oc l od oe">function errorFunc(error) {<br/>    // Do something with error...<br/>}</span></pre><p id="393b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里与没有错误处理的情况的唯一区别是我们传递给<code class="fe og oh oi nx b">subscribe</code>方法的对象中的额外的<code class="fe og oh oi nx b">error</code>属性。该属性的值是错误处理函数。</p><p id="021d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上还有第三个函数可以传递给<code class="fe og oh oi nx b">subscribe</code>方法:<code class="fe og oh oi nx b">complete</code>(我们在前面的小节中已经提到过)。这个函数既可以作为第三个参数传递给<code class="fe og oh oi nx b">subscribe</code>(选项1)，也可以作为observer对象中名为<code class="fe og oh oi nx b">complete</code>的附加属性传递给<code class="fe og oh oi nx b">subscribe</code>(选项2)。</p><p id="7fa4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，这三个函数中每一个的规范都是可选的。如果您不提供它，那么将不会对相应的事件执行任何操作。总而言之，这给了你以下几种调用<code class="fe og oh oi nx b">subscribe</code>的方法:</p><ol class=""><li id="e06f" class="mj mk it kk b kl km ko kp kr ns kv nt kz nu ld ol mr ms mt bi translated"><strong class="kk iu">带函数参数:</strong>一个、两个或三个函数。</li><li id="547e" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld ol mr ms mt bi translated"><strong class="kk iu">带对象参数:</strong>包含可选函数属性<code class="fe og oh oi nx b">next</code>、<code class="fe og oh oi nx b">error</code>和<code class="fe og oh oi nx b">complete</code>的对象。</li></ol><h2 id="5cb9" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">创建+使用:示例</h2><p id="365a" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">在这一小节中，我们将把上一小节中的所有概念应用到一个实际的例子中，我们用承诺和可观察性来实现这个例子。</p><p id="32a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在任何JavaScript引擎上运行这些示例。对于可观察的例子，只需记住首先安装RxJS库，并在源代码文件的顶部添加适当的<code class="fe og oh oi nx b">import</code>或<code class="fe og oh oi nx b">require</code>语句，如本节的<a class="ae le" href="#62e1" rel="noopener ugc nofollow">简介</a>中所述。</p><p id="4f42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">承诺:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="64fb" class="lx lg it nx b gy ob oc l od oe">// Creation<br/>const promise = new Promise(executorFunc);</span><span id="64ee" class="lx lg it nx b gy of oc l od oe">function executorFunc(resolve, reject) {<br/>    const value = Math.random();<br/>    if (value &lt;= 1/3.0)<br/>        resolve(value);<br/>    else if (value &lt;= 2/3.0)<br/>        reject("Value &lt;= 2/3 (reject)");<br/>    else<br/>        throw "Value &gt; 2/3 (throw)"<br/>}</span><span id="25ee" class="lx lg it nx b gy of oc l od oe">// Usage<br/>promise.then(onFulfilled).catch(onRejected);</span><span id="d0cd" class="lx lg it nx b gy of oc l od oe">function onFulfilled(value) {<br/>    console.log("Got value: " + value);<br/>}</span><span id="2eda" class="lx lg it nx b gy of oc l od oe">function onRejected(error) {<br/>    console.log("Caught error: " + error);<br/>}</span></pre><p id="1c13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码创建了一个promise，它生成一个介于0和1之间的随机数。如果该数字小于或等于1/3，则用该值解析承诺(该值为“已发出”)。如果该数字大于1/3但小于或等于2/3，则拒绝该承诺。最后，如果这个数字大于2/3，JavaScript关键字<code class="fe og oh oi nx b">throw</code>会抛出一个错误。</p><p id="5dfd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该程序有三种可能的输出:</p><p id="455d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">输出1: </em></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="769a" class="lx lg it nx b gy ob oc l od oe">Got value: 0.2109261758959049</span></pre><p id="dc86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">输出2: </em></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="fe9a" class="lx lg it nx b gy ob oc l od oe">Caught error: Value &lt;= 2/3 (reject)</span></pre><p id="3605" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">输出3: </em></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="0353" class="lx lg it nx b gy ob oc l od oe">Caught error: Value &gt; 2/3 (throw)</span></pre><p id="d580" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当承诺被定期解决时，输出1出现(使用<code class="fe og oh oi nx b">resolve</code>功能)。这使得<code class="fe og oh oi nx b">onFulfilled</code>处理函数以解析后的值执行。</p><p id="11ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当承诺被明确拒绝(使用<code class="fe og oh oi nx b">reject</code>函数)时，输出2出现。这将导致<code class="fe og oh oi nx b">onRejected</code>处理器功能被执行。</p><p id="671f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，当在执行承诺的过程中出现错误时，会出现输出3。与明确拒绝承诺一样，这会导致执行<code class="fe og oh oi nx b">onRejected</code>处理函数。</p><p id="2b24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用了相对冗长的语法，因为我们使用了命名函数。使用匿名函数是很常见的，这使得代码更加简洁。在这方面，我们可以将上面的代码等价地重写如下:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="4442" class="lx lg it nx b gy ob oc l od oe">// Creation<br/>const promise = new Promise((resolve, reject) =&gt; {<br/>    const value = Math.random();<br/>    if (value &lt;= 1/3.0)<br/>        resolve(value);<br/>    else if (value &lt;= 2/3.0)<br/>        reject("Value &lt;= 2/3 (reject)");<br/>    else<br/>        throw "Value &gt; 2/3 (throw)"<br/>});</span><span id="f98a" class="lx lg it nx b gy of oc l od oe">// Usage<br/>promise<br/>    .then(value =&gt; console.log("Got value: " + value))<br/>    .catch(error =&gt; console.log("Caught error: " + error));</span></pre><p id="ce45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们用observables实现同一个例子。</p><p id="613f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">可观测量:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="20b5" class="lx lg it nx b gy ob oc l od oe">// Creation<br/>const observable = new Observable(subscriberFunc);</span><span id="841d" class="lx lg it nx b gy of oc l od oe">function subscriberFunc(observer) {<br/>    const value = Math.random();<br/>    if (value &lt;= 1/3.0)<br/>        observer.next(value);<br/>    else if (value &lt;= 2/3.0)<br/>        observer.error("Value &lt;= 2/3 (error)");<br/>    else<br/>        throw "Value &gt; 2/3 (throw)"<br/>    observer.complete();<br/>}</span><span id="af84" class="lx lg it nx b gy of oc l od oe">// Usage<br/>observable.subscribe(nextFunc, errorFunc, completeFunc);</span><span id="f558" class="lx lg it nx b gy of oc l od oe">function nextFunc(value) {<br/>    console.log("Got value: " + value);<br/>}</span><span id="7b4b" class="lx lg it nx b gy of oc l od oe">function errorFunc(error) {<br/>    console.log("Caught error: " + error);<br/>}</span><span id="6372" class="lx lg it nx b gy of oc l od oe">function completeFunc() {<br/>    console.log("Completed");<br/>}</span></pre><p id="5d05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这和上面的承诺是同一个例子。如果随机值小于或等于1/3，则可观察对象用传递的观察者对象的<code class="fe og oh oi nx b">next</code>方法发出该值。如果该值大于1/3但小于或等于2/3，则表明observer对象的<code class="fe og oh oi nx b">error</code>方法有错误。最后，如果该值大于2/3，它会抛出一个带有<code class="fe og oh oi nx b">throw</code>关键字的错误。在subscriber函数的末尾，observer对象的<code class="fe og oh oi nx b">complete</code>方法被调用。</p><p id="2db8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序也有三种可能的输出:</p><p id="18e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">输出1: </em></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="d29c" class="lx lg it nx b gy ob oc l od oe">Got value: 0.24198168409429077<br/>Completed</span></pre><p id="6a3d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">输出2: </em></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="1708" class="lx lg it nx b gy ob oc l od oe">Caught error: Value &lt;= 2/3 (error)</span></pre><p id="58ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nv">输出3: </em></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="055a" class="lx lg it nx b gy ob oc l od oe">Caught error: Value &gt; 2/3 (throw)</span></pre><p id="431e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个规则值从可观察对象发出时，输出1发生。它导致<code class="fe og oh oi nx b">nextFunc</code>处理函数被执行。因为可观察对象的订户函数也调用其主体最末端的<code class="fe og oh oi nx b">complete</code>，所以<code class="fe og oh oi nx b">completeFunc</code>处理函数也被执行。</p><p id="aca7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当可观察对象调用观察者对象的<code class="fe og oh oi nx b">error</code>方法时，输出2发生。这使得<code class="fe og oh oi nx b">errorFunc</code>处理函数被执行。请注意，这也会导致可观察对象的订户函数的执行被中止。因此，订户函数体末尾的<code class="fe og oh oi nx b">complete</code>方法不会被调用，这意味着<code class="fe og oh oi nx b">completeFunc</code>处理函数也不会被执行。您可以看到这一点，因为没有像输出1中那样的<code class="fe og oh oi nx b">Completed</code>输出线。</p><p id="4500" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果observable的subscriber函数抛出一个带有关键字<code class="fe og oh oi nx b">throw</code>的错误，就会出现输出3。这与调用<code class="fe og oh oi nx b">error</code>方法的效果相同，即执行<code class="fe og oh oi nx b">errorFunc</code>处理函数，中止可观察对象的订阅函数的执行(不调用<code class="fe og oh oi nx b">complete</code>方法)。</p><p id="a3c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与promise示例一样，我们可以用一种等效的更简洁的符号来重写这个示例:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="ca84" class="lx lg it nx b gy ob oc l od oe">// Creation<br/>const observable = new Observable(observer =&gt; {<br/>    const value = Math.random();<br/>    if (value &lt;= 1/3.0)<br/>        observer.next(value);<br/>    else if (value &lt;= 2/3.0)<br/>        observer.error("Value &lt;= 2/3 (error)");<br/>    else<br/>        throw "Value &gt; 2/3 (throw)"<br/>    observer.complete();<br/>});</span><span id="f4b5" class="lx lg it nx b gy of oc l od oe">// Usage<br/>observable.subscribe({<br/>    next(value) { console.log("Got value: " + value) },<br/>    error(err) { console.log("Caught error: " + err) },<br/>    complete() { console.log("Completed"); }<br/>});</span></pre><p id="332d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，这里我们使用了<code class="fe og oh oi nx b">subscribe</code>方法的另一种用法，它将一个对象作为参数，并将处理函数作为其属性。另一种方法是使用带有三个匿名函数作为参数的<code class="fe og oh oi nx b">subscribe</code>方法，但是在一个参数列表中有多个匿名函数通常是不实用和不可读的。然而，这两种用法完全相同，你可以选择你想要的。</p><p id="84e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，我们比较了承诺和可观察的创造和使用。在这一节的剩余部分，我们将会看到承诺和可观察到的行为之间的一些额外的区别。</p><h2 id="aebe" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">单值与多值</h2><ul class=""><li id="f102" class="mj mk it kk b kl ml ko mm kr mn kv mo kz mp ld mq mr ms mt bi translated">一个承诺只能发出一个值。之后，它处于<em class="nv">完成</em>状态，只能用于查询该值，而不能再计算和发出新值。</li><li id="5e64" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated">一个可观测量可以产生任意数量的值。</li></ul><p id="e18c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">承诺:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="036c" class="lx lg it nx b gy ob oc l od oe">const promise = new Promise(resolve =&gt; {<br/>    resolve(1);<br/>    resolve(2);<br/>    resolve(3);<br/>});</span><span id="0d58" class="lx lg it nx b gy of oc l od oe">promise.then(result =&gt; console.log(result));</span></pre><p id="4166" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="bb53" class="lx lg it nx b gy ob oc l od oe">1</span></pre><p id="4e79" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有对executor函数中的<code class="fe og oh oi nx b">resolve</code>的第一次调用被执行，并解析出值为1的承诺。之后，承诺转换为“已履行”状态，结果值不再改变。</p><p id="76ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">可观测量:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="0e78" class="lx lg it nx b gy ob oc l od oe">const observable = new Observable(observer =&gt; {<br/>    observer.next(1);<br/>    observer.next(2);<br/>    observer.next(3);<br/>});</span><span id="717f" class="lx lg it nx b gy of oc l od oe">observable.subscribe(result =&gt; console.log(result));</span></pre><p id="4740" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="9aee" class="lx lg it nx b gy ob oc l od oe">1<br/>2<br/>3</span></pre><p id="0351" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对订户函数中的<code class="fe og oh oi nx b">observer.next</code>的每次调用都会生效，并导致发出一个值和执行处理程序函数。</p><h2 id="19c4" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">渴望与懒惰</h2><ul class=""><li id="1420" class="mj mk it kk b kl ml ko mm kr mn kv mo kz mp ld mq mr ms mt bi translated">承诺是<strong class="kk iu">急切的</strong>:一旦创建了承诺，就会调用executor函数。</li><li id="1926" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated">可观察对象是<strong class="kk iu">惰性的</strong>:只有当客户端订阅可观察对象时，才会调用订阅者函数。</li></ul><p id="5f0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">承诺:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="b681" class="lx lg it nx b gy ob oc l od oe">const promise = new Promise(resolve =&gt; {<br/>    console.log("- Executing");<br/>    resolve();<br/>});</span><span id="f72c" class="lx lg it nx b gy of oc l od oe">console.log("- Subscribing");<br/>promise.then(() =&gt; console.log("- Handling result"));</span></pre><p id="1552" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="4365" class="lx lg it nx b gy ob oc l od oe">- Executing<br/>- Subscribing<br/>- Handling result</span></pre><p id="d764" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，在任何人订阅该承诺之前，executor函数已经被执行了。</p><p id="6b48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果根本没有人签署承诺，遗嘱执行人的职能甚至会被执行。如果您输出最后两行，您可以看到这一点:输出仍然是<code class="fe og oh oi nx b">— Executing</code>。</p><p id="b133" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">可观测量:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="9036" class="lx lg it nx b gy ob oc l od oe">const observable = new Observable(observer =&gt; {<br/>    console.log("- Executing");<br/>    observer.next();<br/>});</span><span id="3638" class="lx lg it nx b gy of oc l od oe">console.log("- Subscribing");<br/>observable.subscribe(() =&gt; console.log("- Handling result"));</span></pre><p id="ea25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="52d1" class="lx lg it nx b gy ob oc l od oe">- Subscribing<br/>- Executing<br/>- Handling result</span></pre><p id="50bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，subscriber函数仅在创建了对可观察对象的订阅之后执行。</p><p id="89c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您输出最后两行，那么将不会有任何输出，因为订阅者函数将永远不会被执行。</p><p id="00f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于可观察对象在定义时不被执行，只有在其他代码使用时才被执行，所以也被称为<strong class="kk iu">声明性</strong> <em class="nv"> </em>(你<em class="nv">声明</em>一个可观察对象，但它是<em class="nv">使用时才执行</em>)。</p><h2 id="77f3" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">不可取消与可取消</h2><ul class=""><li id="c0d6" class="mj mk it kk b kl ml ko mm kr mn kv mo kz mp ld mq mr ms mt bi translated">一旦您用<code class="fe og oh oi nx b">then</code>“订阅”了一个承诺，那么您传递给<code class="fe og oh oi nx b">then</code>的处理函数将被调用，无论如何。一旦承诺开始执行，就不能告诉承诺取消调用结果处理函数。</li><li id="9f13" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated">用<code class="fe og oh oi nx b">subscribe</code>订阅一个可观察对象后，可以随时通过调用<code class="fe og oh oi nx b">subscribe</code>返回的<code class="fe og oh oi nx b"><a class="ae le" href="https://rxjs-dev.firebaseapp.com/api/index/class/Subscription" rel="noopener ugc nofollow" target="_blank">Subscription</a></code>对象的<code class="fe og oh oi nx b">unsubscribe</code>方法来取消这个订阅。在这种情况下，您传递给<code class="fe og oh oi nx b">subscribe</code>的处理函数将不再被调用。</li></ul><p id="6355" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">承诺:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="95ca" class="lx lg it nx b gy ob oc l od oe">const promise = new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>        console.log("Async task done");<br/>        resolve();<br/>    }, 2000);<br/>});</span><span id="48ed" class="lx lg it nx b gy of oc l od oe">promise.then(() =&gt; console.log("Handler"));</span><span id="7f9c" class="lx lg it nx b gy of oc l od oe">// Oops, can't prevent handler from being executed anymore.</span></pre><p id="2de4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印(2秒钟后):</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="39bf" class="lx lg it nx b gy ob oc l od oe">Async task done<br/>Handler</span></pre><p id="4829" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们调用了<code class="fe og oh oi nx b">then</code>，我们就无法阻止传递给<code class="fe og oh oi nx b">then</code>的处理函数被调用(即使我们有2秒钟的时间这么做)。因此，2秒钟后，当承诺被解析时，处理程序被执行。</p><p id="529e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">可观测量:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="5bf1" class="lx lg it nx b gy ob oc l od oe">const observable = new Observable(observer =&gt; {<br/>    setTimeout(() =&gt; {<br/>        console.log("Async task done");<br/>        observer.next();<br/>    }, 2000);<br/>});</span><span id="3976" class="lx lg it nx b gy of oc l od oe">subscription = observable.subscribe(() =&gt; console.log("Handler"));<br/>subscription.unsubscribe();</span></pre><p id="d159" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印(2秒钟后):</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="261d" class="lx lg it nx b gy ob oc l od oe">Async task done</span></pre><p id="817f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们订阅了可观察对象，向它注册了一个处理函数，但紧接着我们又取消了对可观察对象的订阅。效果是2秒钟后，当可观察对象发出它的值时，我们的处理函数被<em class="nv">而不是</em>调用。</p><p id="46ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意<code class="fe og oh oi nx b">Async task done</code>还是打印的。取消订阅本身并不意味着可观察对象正在执行的任何异步任务被中止。取消订阅只是实现了对订阅者函数中的<code class="fe og oh oi nx b">observer.next</code>(以及<code class="fe og oh oi nx b">observer.error</code>和<code class="fe og oh oi nx b">observer.complete</code>)的调用不会触发对您的处理函数的调用。但是其他一切仍然运行，好像你不会调用<code class="fe og oh oi nx b">unsubscribe</code>。</p><h2 id="8838" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">多播与单播</h2><ul class=""><li id="3f69" class="mj mk it kk b kl ml ko mm kr mn kv mo kz mp ld mq mr ms mt bi translated">承诺的执行者功能只执行一次(在创建承诺时)。这意味着对一个给定的promise对象的所有对<code class="fe og oh oi nx b">then</code>的调用只是“接入”正在执行的executor函数，并最终获得结果值的副本。因此，promises执行<strong class="kk iu">多播</strong>，因为相同的执行和结果值用于多个“订户”。</li><li id="97ef" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated">可观察对象的订阅者函数在每次调用该可观察对象上的<code class="fe og oh oi nx b">subscribe</code>时执行。因此，observables执行<strong class="kk iu">单播</strong>，因为每个订户都有单独的执行和结果值。</li></ul><p id="728d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">承诺:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="96d5" class="lx lg it nx b gy ob oc l od oe">const promise = new Promise(resolve =&gt; {<br/>    console.log("Executing...");<br/>    resolve(Math.random());<br/>});</span><span id="bc2a" class="lx lg it nx b gy of oc l od oe">promise.then(result =&gt; console.log(result));<br/>promise.then(result =&gt; console.log(result));</span></pre><p id="aa1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印(例如):</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="204a" class="lx lg it nx b gy ob oc l od oe">Executing...<br/>0.1951561731912439<br/>0.1951561731912439</span></pre><p id="b3c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，executor函数只执行一次，结果值由两个<code class="fe og oh oi nx b">then</code>订阅共享。</p><p id="0df8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">可观测量:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="7195" class="lx lg it nx b gy ob oc l od oe">const observable = new Observable(observer =&gt; {<br/>    console.log("Executing...");<br/>    observer.next(Math.random());<br/>});</span><span id="471e" class="lx lg it nx b gy of oc l od oe">observable.subscribe(result =&gt; console.log(result));<br/>observable.subscribe(result =&gt; console.log(result));</span></pre><p id="4b17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印(例如):</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="d637" class="lx lg it nx b gy ob oc l od oe">Executing...<br/>0.5884515904517829<br/>Executing...<br/>0.7974144930327094</span></pre><p id="46e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，subscriber函数是为每个订户单独执行的，每个订户都获得自己的结果值。</p><h2 id="1b97" class="lx lg it bd lh ly lz dn ll ma mb dp lp kr mc md lr kv me mf lt kz mg mh lv mi bi translated">异步处理程序与同步处理程序</h2><ul class=""><li id="0c6b" class="mj mk it kk b kl ml ko mm kr mn kv mo kz mp ld mq mr ms mt bi translated">承诺的处理函数异步执行<strong class="kk iu"/>。也就是说，它们是在主程序或当前函数中的所有代码都执行完之后执行的。</li><li id="d5c2" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated">观察值的处理函数同步执行<strong class="kk iu"/>。也就是说，它们在当前函数或主程序的流程中执行。</li></ul><p id="b185" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">承诺:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="f3cd" class="lx lg it nx b gy ob oc l od oe">console.log("- Creating promise");<br/>const promise = new Promise(resolve =&gt; {<br/>    console.log("- Promise running");<br/>    resolve(1);<br/>});</span><span id="8fe5" class="lx lg it nx b gy of oc l od oe">console.log("- Registering handler");<br/>promise.then(result =&gt; console.log("- Handling result: " + result));</span><span id="7204" class="lx lg it nx b gy of oc l od oe">console.log("- Exiting main");</span></pre><p id="5454" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印以下输出消息序列:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="0a11" class="lx lg it nx b gy ob oc l od oe">- Creating promise<br/>- Promise running<br/>- Registering handler<br/>- Exiting main<br/>- Handling result: 1</span></pre><p id="d4f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先创建承诺，然后直接执行(因为承诺是<em class="nv">急切的</em>，参见上面的<a class="ae le" href="#19c4" rel="noopener ugc nofollow"/>)。承诺也是立马解决。之后，我们通过调用它的<code class="fe og oh oi nx b">then</code>方法用承诺注册一个处理函数。此时承诺已经被解决(即处于<em class="nv">已履行</em>状态)，然而，此时我们的处理函数是<strong class="kk iu">而不是</strong>被执行。相反，首先执行主程序中所有剩余的代码，只有在之后的<em class="nv">才会调用我们的处理函数。</em></p><p id="aadb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为承诺的履行(或拒绝)是作为一个<strong class="kk iu">异步</strong>事件来处理的。这意味着，当一个承诺被解决(或拒绝)时，相应的处理函数将作为一个单独的项放入JavaScript <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-promises-with-node-js-e8ca827e0ea3#95d0">事件队列</a>。这意味着只有在事件队列中所有先前的项都被执行后，处理程序才会被执行，在我们的例子中，有一个这样的先前项，它是主程序。</p><p id="0ddd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">可观测量:</strong></p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="dded" class="lx lg it nx b gy ob oc l od oe">console.log("- Creating observable");<br/>const observable = new Observable(observer =&gt; {<br/>    console.log("- Observable running");<br/>    observer.next(1);<br/>});</span><span id="2835" class="lx lg it nx b gy of oc l od oe">console.log("- Registering handler");<br/>observable.subscribe(v =&gt; console.log("- Handling result: " + v));</span><span id="37e8" class="lx lg it nx b gy of oc l od oe">console.log("- Exiting main");</span></pre><p id="37c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印以下输出消息序列:</p><pre class="na nb nc nd gt nw nx ny nz aw oa bi"><span id="bf06" class="lx lg it nx b gy ob oc l od oe">- Creating observable<br/>- Registering handler<br/>- Observable running<br/>- Handling result: 1<br/>- Exiting main</span></pre><p id="ef2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，创建可观察对象(但它还没有被执行，因为可观察对象是<em class="nv">懒惰的</em>，见上面的<a class="ae le" href="#19c4" rel="noopener ugc nofollow"/>，然后我们通过调用可观察对象的<code class="fe og oh oi nx b">subscribe</code>方法向它注册一个处理程序。此时，可观察对象开始运行，并立即发出它的第一个也是唯一的值。现在我们的处理函数<strong class="kk iu">被</strong>执行，最后主程序退出。</p><p id="1d9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与promises不同，handler函数是在主程序还在运行的时候运行的。这是因为observables的处理函数在当前执行的代码中被同步调用<strong class="kk iu"/>，而不是像promises的处理函数那样作为异步事件。</p><h1 id="2608" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">结论</h1><p id="13cd" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">在本文中，我们首先介绍了JavaScript中不同的异步编程技术，其中最重要的是:</p><ul class=""><li id="cd59" class="mj mk it kk b kl km ko kp kr ns kv nt kz nu ld mq mr ms mt bi translated"><a class="ae le" href="#f41a" rel="noopener ugc nofollow"> <strong class="kk iu">回调</strong> </a></li><li id="2428" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#1430" rel="noopener ugc nofollow"> <strong class="kk iu">承诺</strong> </a></li><li id="a4c6" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#2404" rel="noopener ugc nofollow"> <strong class="kk iu">异步/等待</strong> </a></li><li id="16f1" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#7056" rel="noopener ugc nofollow">T22【RxJS】可观测量T24】</a></li></ul><p id="bb98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们并排比较了承诺和可观察到的情况。特别是，我们强调了以下方面的差异和相似之处:</p><ul class=""><li id="575b" class="mj mk it kk b kl km ko kp kr ns kv nt kz nu ld mq mr ms mt bi translated"><a class="ae le" href="#192d" rel="noopener ugc nofollow"> <strong class="kk iu">创作</strong> </a></li><li id="06da" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#0b4b" rel="noopener ugc nofollow"> <strong class="kk iu">用法</strong> </a></li><li id="1afb" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#aebe" rel="noopener ugc nofollow"> <strong class="kk iu">单值与多值</strong> </a></li><li id="b6d8" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#19c4" rel="noopener ugc nofollow"> <strong class="kk iu">急切vs .</strong></a></li><li id="c77f" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#77f3" rel="noopener ugc nofollow"> <strong class="kk iu">不可撤销与可撤销</strong> </a></li><li id="edbc" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#8838" rel="noopener ugc nofollow"> <strong class="kk iu">多播与单播</strong> </a></li><li id="afe9" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="#1b97" rel="noopener ugc nofollow"> <strong class="kk iu">异步处理程序与同步处理程序</strong> </a></li></ul><h1 id="c1f7" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">参考</h1><ul class=""><li id="92f9" class="mj mk it kk b kl ml ko mm kr mn kv mo kz mp ld mq mr ms mt bi translated"><a class="ae le" href="https://www.academind.com/learn/javascript/callbacks-vs-promises-vs-rxjs-vs-async-awaits/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">https://www . academind . com/learn/JavaScript/callbacks-vs-promises-vs-rxjs-vs-async-waits/</strong></a></li><li id="7f97" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="https://medium.com/@mpodlasin/promises-vs-observables-4c123c51fe13" rel="noopener"><strong class="kk iu">https://medium . com/@ mpodlasin/promises-vs-observables-4c 123 c 51 Fe 13</strong></a></li><li id="0e59" class="mj mk it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="http://reactivex.io/intro.html" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">http://reactivex.io/intro.html</strong></a></li></ul></div></div>    
</body>
</html>