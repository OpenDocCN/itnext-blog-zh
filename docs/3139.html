<html>
<head>
<title>How to avoid callbacks in Node.js?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中如何避免回调？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-avoid-callbacks-in-node-js-babaff47719c?source=collection_archive---------5-----------------------#2019-10-10">https://itnext.io/how-to-avoid-callbacks-in-node-js-babaff47719c?source=collection_archive---------5-----------------------#2019-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4359" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就我个人而言，我不喜欢回调，因为它们是混乱的，不可读的，并且会导致回调地狱。所以我对回调的热爱是没有任何边界的，但有时候人们还是要用。在本文中，我将尝试展示何时必须使用回调，以及如何“限制”它们，甚至用更好的东西替换它们(是的，<em class="kl"> async/await </em>就是这样)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/1326fdebe978e982bf06e93f63c54abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*DfRHLgkmM3srIIQJd7xZIg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">不要到处“打电话”</figcaption></figure><p id="35f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">文件操作</strong></p><p id="10f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了进行文件操作，你可能会使用内置的node.js函数，比如<strong class="jp ir"> fs.readFile </strong>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="069b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面的基本示例中我们可以看到典型的回调，变量<strong class="jp ir"> <em class="kl">数据</em> </strong> <em class="kl"> </em>仅在<strong class="jp ir"> readFile </strong> <em class="kl"> </em>函数的第二个参数中可用(这是回调)。一旦我们需要对这些数据做一些事情，所有的操作都将在同一个回调内部完成(因为在外部数据将不可用)，这将使它变得不可读和丑陋，基本上是地狱。</p><p id="7017" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">外部模块</strong></p><p id="b8c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在node.js中，使用外部库(有时是内部构建的库)是很常见的，您可能会被迫使用回调，因为这些库不允许<em class="kl"> async/await </em>。例如，<a class="ae la" href="https://www.npmjs.com/package/mysql" rel="noopener ugc nofollow" target="_blank"><em class="kl">MySQL</em></a><em class="kl"/>模块不允许<em class="kl"> async/await </em>语法，所以你必须使用回调(好的替代方案是<a class="ae la" href="https://www.npmjs.com/package/mysql2" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> mysql2 </em> </a> <em class="kl">，</em>支持<em class="kl"> async/await </em>)。</p><p id="4d0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">现有代码库</strong></p><p id="c8d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有争议，但是我会试着解释为什么使用回调是有原因的。您可能需要使用一个现有的项目，一个已经在生产环境中运行的功能齐全的产品(是的，有时我们不从头开始项目/服务，而是维护现有的项目/服务:)。在给定的情况下，如果您的代码哲学与现有的不一致，那么推行它并不是一个好主意。想象一下，如果项目没有一个async/await，而是到处使用回调，然后您使用<em class="kl"> async/await </em>实现一些功能或修复一个bug。如果你这样做了，那么维护这个项目的人可能不会非常感激，因为开发人员将需要在同一服务范围内的不同实现风格之间切换，甚至可能是功能/类。</p><p id="6ea2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">那么让我们看看我们实际上可以对所描述的情况做些什么</strong></p><p id="6376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">刚刚回报新的承诺</strong></p><p id="8916" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中一个选项是将回调函数包装成<em class="kl"> new Promise </em>并返回。这样你就涵盖了以上三点:它符合现有代码库的风格，并且你避免了回调地狱，可以在任何地方访问结果值。然而，请记住，将数百个回调封装到一个<em class="kl"> new Promise </em>中并不是一个好主意，因为内存泄漏或破坏应用程序和调试的可能性会更高，这不会给spagetti带来多少快乐。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="ceee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续寻找其他的选择。</p><p id="7e08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为你的特殊情况使用一些外部库</strong></p><p id="c04e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，对于文件操作，可以使用npm包<a class="ae la" href="https://www.npmjs.com/package/await-fs" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> await-fs </em> </a>并将回调转换为普通的<em class="kl"> async/await </em>函数。为了使用它，你只需要需要这个模块而不是<em class="kl"> fs </em>模块，并像使用<em class="kl"> fs </em>一样使用它。让我们看一些代码。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="9dac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切都好，工作正常，看起来不错。但是有一件小事引起了我的注意:在幕后，这个库只是导出了一个新函数，该函数返回包装在node.js标准回调中的<em class="kl"> new Promise </em>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="9e7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以问题是:如果你自己可以轻松返回<em class="kl"> new Promise </em>为什么我要使用一些外部库呢？也许是为了让你的代码库更小更干净。</p><p id="b695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看给定列表中的最后一个选项是什么，以及它如何优于所描述的选项。</p><p id="b8e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Promisify </p><p id="d1bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Promisify是node.js内置库<em class="kl"> util、</em>的函数形式，意思是不需要添加到package.json中，只需要它就可以了。它有助于将任何没有<em class="kl"> async/await </em>支持的函数转换成有支持的函数，你只需要给出函数的名字。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="3c6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而这里似曾相识，因为<em class="kl"> promisify </em>正在引擎盖下返回<em class="kl"> new Promise </em>(查看util的源代码)。</p><p id="d546" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论</strong></p><p id="1588" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，有几种方法可以最小化或避免回调以及在node.js项目中出现回调地狱的可能性。我个人更喜欢<em class="kl">Promise rify</em>函数，但是有时候，比如在现有代码库有自己风格的情况下，我就用<em class="kl"> new Promise。如果我错过了一些你不得不使用回调或限制或完全避免回调的情况，请随意写下评论。</em></p></div></div>    
</body>
</html>