<html>
<head>
<title>A deep analysis into isomorphic, autonomous cross-framework usage #MicroFrontends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入分析同构、自治的跨框架使用#微前端</h1>
<blockquote>原文：<a href="https://itnext.io/a-deep-analysis-into-isomorphic-autonomous-cross-framework-usage-microfrontends-364271dc5fa9?source=collection_archive---------3-----------------------#2020-03-17">https://itnext.io/a-deep-analysis-into-isomorphic-autonomous-cross-framework-usage-microfrontends-364271dc5fa9?source=collection_archive---------3-----------------------#2020-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/134a495bab51876412ed6a8262d2a1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eN-klwk9XdsHxNBBUqGoPg.jpeg"/></div></div></figure><div class=""/><p id="2b9a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章可能被认为不容易读懂。所以，慢慢来，集中精力👌如果你想了解框架、它们的SSR和WebComponents的连接的深层问题，以及你在“解决所有问题的Web组件微前端”(这显然是一种讽刺性的夸张)中遇到的问题，通读是至关重要的。</p><p id="f6f8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> Vue </em> </a> <em class="kx">将用于大多数样本，但是这些原理也适用于其他框架。</em></p><h2 id="d18b" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">序言:</h2><p id="ba34" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">每个人都在谈论#微前端。每个人都有自己的观点——这很好。但我喜欢更多的事实。利弊，潜在的技术需求和问题。无论是在私人场合还是在梅赛德斯-奔驰的工作中，我都喜欢思考自主部件的复杂性。这篇文章将试图阐明以下问题</p><h1 id="cff4" class="lw kz jb bd la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm bi translated">如何将WebComponents与不同的框架集成在一起，同时能够进行SSR？</h1><blockquote class="mv mw mx"><p id="5769" class="jy jz kx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">本文不会解释<strong class="ka jc">为什么</strong>要使用WebComponents或SSR。这是一篇关于可行性、陷阱和技术细节的架构文章。为了更深入地挖掘各自的细节，我在最后添加了一些资料。</p></blockquote><h2 id="0530" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">同构的短途旅行(如果你知道同构，跳过)</h2><p id="aa12" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">进行服务器端渲染的主要需求是在服务器上渲染将在客户端上渲染的内容——这被称为<a class="ae kw" href="https://www.lullabot.com/articles/what-is-an-isomorphic-application" rel="noopener ugc nofollow" target="_blank">同构</a>。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0465" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码示例是同构的——服务器和客户端都应该返回<code class="fe nh ni nj nk b">&lt;strong&gt;The default greeting text&lt;/strong&gt;</code></p><p id="cf78" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">为什么同构如此重要？</strong></p><p id="d032" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">框架试图<strong class="ka jc">不</strong>重新呈现任何通过SSR提交的HTML。只有额外的步骤，如<code class="fe nh ni nj nk b">addEventListener</code>，当你没有相等的输出(=没有同构)，那么大多数框架将<strong class="ka jc">完全重新渲染— </strong>这是非常昂贵的。所以你会失去水合作用的关键点。查看下面的可视化图表。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/2d4e0d14447e8da2e182ce36397982e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPxjvJimn9FpOfVKJW5QAg.png"/></div></div></figure><h2 id="227f" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">到web组件的短途旅行</h2><p id="e801" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">一些人喜欢讨论一个WebComponent 的定义是否包括ShadowDOM等等。我们不要吹毛求疵，将术语<a class="ae kw" href="https://www.webcomponents.org/introduction" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">web component</strong></a><strong class="ka jc"/>定义为</p><blockquote class="nm"><p id="2e4f" class="nn no jb bd np nq nr ns nt nu nv kv dk translated">由<code class="fe nh ni nj nk b">customElements</code> API定义的元素。</p></blockquote><figure class="nw nx ny nz oa is"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated"><strong class="ak">一个简单的例子:</strong>现在你可以在你的HTML中使用&lt;我的组件&gt;/我的组件&gt;</figcaption></figure><p id="7bd4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在无论你在哪里使用<code class="fe nh ni nj nk b">&lt;my-component&gt;</code>，它都会自动初始化并说<code class="fe nh ni nj nk b">I am a simple component</code>。</p><p id="5adc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着你变得<strong class="ka jc">独立于框架</strong>(和DOM独立)，因为你不需要依赖你显式初始化的现有元素(比如经常看到的<code class="fe nh ni nj nk b">render('#app')</code>)，而是就地初始化🥰:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="2e34" class="ky kz jb nk b gy oj ok l ol om">connectedCallback() {<br/> ...<br/> render(&lt;Component /&gt;, this) // this = &lt;my-component&gt; instance<br/>}</span></pre></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><h2 id="abf7" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">让我们来看看基于框架的web组件</h2><p id="75da" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">这将是一次深度潜水。WebComponents客户端的实际使用往往非常容易。请看这里的反应例子:<a class="ae kw" href="https://reactjs.org/docs/web-components.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/web-components.html</a>。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ou"><img src="../Images/3f1beed8d3af16ea04bb294083643195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bUMyoWFgO8Tj7drPboerQ.png"/></div></div></figure><p id="7e71" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，默认情况下，这些流行的框架没有一个是同构的(<a class="ae kw" href="https://stenciljs.com/docs/prerendering" rel="noopener ugc nofollow" target="_blank"> Stencil </a>可能是个例外，但我还没有将它纳入研究)。</p><p id="fc0d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">为什么WC+SSR提供头痛:</strong></p><p id="d430" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在服务器上，您需要定义一个呈现web组件的组件，以便它可以在客户机上初始化。现在，当客户端初始化时，它需要呈现框架组件。但是我们定义了那个框架组件来扮演一个web组件:<strong class="ka jc">你最终陷入了一个无限循环。</strong></p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="1a51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们研究一下如何避免无限循环</p><p id="9537" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果在客户端(前端)使用组件<code class="fe nh ni nj nk b">my-component </code>，那么它必须作为<code class="fe nh ni nj nk b">customElement</code>对浏览器可用。所以在前端有一个<code class="fe nh ni nj nk b">customElements.define(‘my-component’, …)</code>是前提。</p><p id="44e6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，让我们定义一个底层的<code class="fe nh ni nj nk b">Vue.component</code>:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6757" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个<code class="fe nh ni nj nk b">Vue.component</code>定义，它将简单地呈现以下内容</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="d19e" class="ky kz jb nk b gy oj ok l ol om">&lt;my-component&gt;<br/>  &lt;div&gt;Foobar&lt;/div&gt;<br/>&lt;/my-component&gt;</span></pre><p id="bf1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了能够补充水分，我们需要在Vue中注册。<br/>简单:<code class="fe nh ni nj nk b">Vue.component(‘my-component’, Component);</code></p><p id="126e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">恭喜你！我们创造了前面提到的无限循环。<code class="fe nh ni nj nk b">my-component</code>会渲染<code class="fe nh ni nj nk b">my-component</code>从而渲染<code class="fe nh ni nj nk b">my-component</code> …</p><p id="ce00" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vue有一个官方的Web组件包装器。你为什么不用它？使用官方组件包装器不是一个选项，因为它也不是同构的。你已经可以从它的定义类型看出:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="aef0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它实际上是一个仅在客户端运行组件的包装器。而且他们很长一段时间都没有发展。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/2608cc1b900bab77cbbcc41bc6632512.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*Fkxb0-MweejhXOjL1khhAg.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">截至撰写本文之日，官方包装的最后一次提交是在2019年1月</figcaption></figure></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="a77d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要找到一种解决方案来实现以下目标:</p><p id="78aa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的创作系统(static site、Drupal、AEM、Hybris等)会播放下面的HTML，我们将呈现这些HTML:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="bc01" class="ky kz jb nk b gy oj ok l ol om">&lt;my-component&gt;<br/>  &lt;my-component&gt;<br/>    Hello encapsulation<br/>  &lt;my-component&gt;<br/>&lt;/my-component&gt;</span></pre><p id="68e5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上所述，我们不能定义一个与其WebComponent具有相同标记名的Vue组件。</p><p id="8ebd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，下一个方法是，每个组件都有一个特定的应用程序前缀，该前缀仅在客户端用于<code class="fe nh ni nj nk b">customElements.define</code>，因为我们可以推断相应的<code class="fe nh ni nj nk b">Vue.component</code>具有相同的名称，但没有前缀(以避免无限循环)。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ow"><img src="../Images/825b3d8d9230c41b8d0c269df0e995be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQ-k8jtyIvkPE815POceww.png"/></div></div></figure><p id="8384" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据这个逻辑，我们总是能够推断出<code class="fe nh ni nj nk b">app-my-component</code>对应于组件<code class="fe nh ni nj nk b">my-component</code>。让我们来试试:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f58d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在这会呈现下面的嵌套示例</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="a52b" class="ky kz jb nk b gy oj ok l ol om">&lt;app-my-component&gt;<br/>  &lt;app-my-component&gt;<br/>    Hello encapsulation<br/>  &lt;app-my-component&gt;<br/>&lt;/app-my-component&gt;</span></pre><p id="7682" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到第一级-只有一个，没有子节点，也没有“Hello封装部分”:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="0b4f" class="ky kz jb nk b gy oj ok l ol om">&lt;my-component&gt;<br/>  &lt;div&gt;<br/>    Hello<br/>  &lt;/div&gt;<br/>&lt;/my-component&gt;</span></pre><p id="2408" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们失去了内部子组件，因为在这个例子中我们无法访问子组件(我们稍后将讨论Vue <code class="fe nh ni nj nk b">slot</code>)。结果是<strong class="ka jc">在前端没有水合</strong>，因为我们没有注册名为<code class="fe nh ni nj nk b">my-component</code>的<code class="fe nh ni nj nk b">customElement</code>。(如果你问自己为什么，那么重读关于无限循环的部分)。</p><p id="68f7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过使用匿名组件来摆脱这种命名思维。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="76be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在渲染时，我们期望来自<code class="fe nh ni nj nk b">my-app-component</code>的childNode出现在Vue模板中<code class="fe nh ni nj nk b">&lt;slot&gt;</code>所在的位置。因此，我们必须在WebComponent中获取childNode，并将其提供给Vue。</p><p id="b80f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这个<a class="ae kw" href="https://codesandbox.io/s/vue-simple-ssrcsr-no-nesting-raw-html-template-e8hjb?fontsize=14&amp;hidenavigation=1&amp;theme=dark" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">沙盒示例</strong> </a>中找到演示。您将看到输出不是同构的。事实上，SSR one什么也没做。它接受字符串，添加<code class="fe nh ni nj nk b">data-server-rendered="true"</code>(因为Vue把它添加到所有通过<code class="fe nh ni nj nk b">renderToString</code>的内容中)就这样。但是为什么呢？</p><p id="ab34" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在向服务器发送这个:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="4bbc" class="ky kz jb nk b gy oj ok l ol om">&lt;app-my-component&gt;<br/>  &lt;strong&gt;I am Foo&lt;/strong&gt;<br/>&lt;/app-my-component&gt;</span></pre><p id="d803" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在从上面检查我们的代码。你看到<code class="fe nh ni nj nk b">Vue.component('app-my-component', ..)</code>的定义了吗？没有吗？是的，这就是问题所在。希望你还记得为什么我们没有它:无限循环避免。你可能会像我一样头脑发热:</p><blockquote class="nm"><p id="f363" class="nn no jb bd np nq nr ns nt nu nv kv dk translated"><em class="ox">所以我只是将</em> <code class="fe nh ni nj nk b"><em class="ox">app-my-component</em></code> <em class="ox">定义为一个Vue组件，但只是在服务器上，这样客户端就不会出现无限循环！？</em></p></blockquote><p id="d346" class="pw-post-body-paragraph jy jz jb ka b kb oy kd ke kf oz kh ki kj pa kl km kn pb kp kq kr pc kt ku kv ij bi translated">为了简单起见，我想说:试试看。但我可以提前告诉你:行不通。为了让客户端工作并识别组件，您需要在<code class="fe nh ni nj nk b">app-my-component</code> Vue组件中呈现一个<code class="fe nh ni nj nk b">app-my-component</code>标签。所以你遇到了完全相同的问题…</p><p id="5c5f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们试着在下一步运行SSR one。下一个沙箱包含了我们所知道的知识，即<code class="fe nh ni nj nk b">app-my-component</code>有一个叫做<code class="fe nh ni nj nk b">anonymous-app-my-component</code>的底层Vue定义。因此，对于SSR，我们将标记替换为Vue标记。现在Vue可以渲染了。但是它仍然会替换标签。所以我们需要用组件标签名再次包装它。见<a class="ae kw" href="https://codesandbox.io/s/vue-simple-ssrcsr-no-nesting-raw-html-template-2ren8" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">沙盒示例此处</strong> </a>。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pd"><img src="../Images/db272a54858cb19daaa8a75ec3e56470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xgkKXLjOd3qWOrHPM4Tgg.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">tldr:将<em class="ox"> my-component </em>重写为<code class="fe nh ni nj nk b"><em class="ox">anonymous-my-component,</em></code> render，然后再次用<code class="fe nh ni nj nk b"><em class="ox">my-component</em></code>手动包装成同构的HTML。</figcaption></figure><p id="f7d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这适用于这个简单的组件，但不适用于嵌套其他组件的情况，因为这样你只能手动添加外层包装，但所有内层包装都将丢失(再次引起:Vue渲染并替换它们)。同样，当我们添加包装器时，Vue中的<code class="fe nh ni nj nk b">data-server-rendered</code>突然出现在里面。</p><p id="d22c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要做的是定义一个仅在服务器端使用的<code class="fe nh ni nj nk b">Vue.component</code>,然后将其渲染回一个在客户端称为<code class="fe nh ni nj nk b">CustomElement</code>的标签。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="aec1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我们使用为服务器重命名<code class="fe nh ni nj nk b">tagName</code>的方法，但是我们将其重命名为客户端永远不会看到的名称。演示中SSR之前的预处理</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="7d5e" class="ky kz jb nk b gy oj ok l ol om">const htmlStringBeforeSSR = ... ;</span><span id="8afb" class="ky kz jb nk b gy pe ok l ol om">const ssrableString = htmlStringBeforeSSR.replace(<br/>  new RegExp("app-my-component", "g"),<br/>  "server-app-my-component"<br/>)</span></pre><p id="7dd7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请参见此处的 工作和可嵌套的<a class="ae kw" href="https://codesandbox.io/s/vue-simple-ssrcsr-no-nesting-raw-html-template-auto-ssr-fix-qb4sk" rel="noopener ugc nofollow" target="_blank">沙盒示例。🥳:在我们进一步评估之前，让我们深呼吸一下，消化一下。</a></p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="pf ng l"/></div></figure></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="fea8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止(没有深入到所有可能的用例中),这将解决无限循环的问题，我们可以像看起来那样有同构。</p><p id="785a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，这还不是解决方案:</p><ol class=""><li id="4f06" class="pg ph jb ka b kb kc kf kg kj pi kn pj kr pk kv pl pm pn po bi translated">我们现在只有集成的Vue</li><li id="27fa" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pl pm pn po bi translated">不幸的是，我们集成的Vue部分只有<strong class="ka jc">部分同构，因此在真实用例</strong>中不可用。<strong class="ka jc"> </strong>如果我们用SSR渲染<code class="fe nh ni nj nk b">slots</code>，我们就失去了位置是HTML的哪一部分的上下文。您实际上是在向客户端呈现纯本地HTML。现在，您如何识别作为<code class="fe nh ni nj nk b">&lt;slot&gt;</code>替换提供给服务器的子节点是什么？我们需要能够在客户机上识别来自服务器的原始子节点，从服务器渲染的DOM中克隆它们，将它们作为渲染子节点放回组件实例，以便能够进行<code class="fe nh ni nj nk b">hydrate</code>。稍后会有更多的细节。</li><li id="085d" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pl pm pn po bi translated">slot子组件可以再次成为web组件，因此它们可以自己触发一个init进程，并自主地更改它们的html结构(因为它们也是呈现模板的基础)。因此，父组件将与其子组件不同步，因为子组件中的DOM更改不是由父组件处理和呈现的，而是在子web组件的实例中。🧐</li></ol><h1 id="a444" class="lw kz jb bd la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm bi translated">为什么还要同构？我们能不能简化一下，用木偶师？</h1><p id="41a9" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">如果你想为SEO进行预渲染，这实际上是一个非常好的主意。但是对于我们的用例来说，这是行不通的:</p><p id="b2e4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.异步呈现的组件，尤其是那些具有加载状态的组件，可能会使无头浏览器呈现的组件处于损坏状态(尽管这可能是可以避免的)。</p><p id="c5c4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.一些框架需要一些SSR的标识(例如<code class="fe nh ni nj nk b">data-server-rendered=true</code>)。当CSR发生在木偶师身上时，不会添加它们。所以我们必须对它们进行后处理(理论上我们可以用变通的方法来做，但是这里已经变得很乱了)。</p><p id="3c5e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.对于有子元素的元素来说，水合作用会是什么样子？因为孩子不容易被识别(正如我们在上述所有文本中所分析的)。</p><p id="af18" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用木偶师不会给我们带来任何额外的好处。</p><h2 id="63ec" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">让我们更深入地了解我们所面临的<code class="fe nh ni nj nk b">children</code>问题。</h2><p id="54e8" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">看看下面服务器上的渲染图(再反应一下):</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c1de" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">水合作用要求客户机上的参数与服务器上的参数相同。这允许框架构建一个可以区分的虚拟DOM树。简而言之，我们需要</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="e26a" class="ky kz jb nk b gy oj ok l ol om">.hydrate(<br/>  &lt;CoolComponent&gt;<br/>   &lt;strong&gt;hello&lt;/strong&gt;<br/>  &lt;/CoolComponent&gt;<br/>)</span></pre><p id="9a96" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们<strong class="ka jc">甚至不知道我们应该在此时渲染这个</strong>。我们的<code class="fe nh ni nj nk b">CoolComponent</code>通过以下方式反映在客户身上</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="0c39" class="ky kz jb nk b gy oj ok l ol om">// pseudo-code 🔽<br/>customElements.define('cool-component', ...<br/>  <br/>  hydrate/render(&lt;CoolComponent&gt;$children&lt;/CoolComponent&gt;)</span><span id="1fc1" class="ky kz jb nk b gy pe ok l ol om">);</span></pre><p id="92a8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SSR为我们提供了完整的HTML</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="d014" class="ky kz jb nk b gy oj ok l ol om">&lt;cool-component&gt;<br/>  &lt;div&gt;foo&lt;strong&gt;hello&lt;/strong&gt;bar&lt;/div&gt;<br/>&lt;/cool-component&gt;</span></pre><p id="0ff4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nh ni nj nk b">cool-component</code>只知道是a引用为<code class="fe nh ni nj nk b">CoolComponent</code>。所以我们能做的就是:<code class="fe nh ni nj nk b">hydrate(&lt;CoolComponent /&gt;)</code>。但是我们不知道<code class="fe nh ni nj nk b">$children</code>是什么。我们应该放一个<code class="fe nh ni nj nk b">&lt;strong&gt;hello&lt;/strong&gt;</code>，但是你在<code class="fe nh ni nj nk b">cool-component</code>哪里有这个信息？那么你会在根级别查询一个<code class="fe nh ni nj nk b">strong</code>标签，取出它，然后使用<code class="fe nh ni nj nk b">JSX.parseFromStrin(strongTagThatIfound)</code>，再把它放回<code class="fe nh ni nj nk b">render</code>函数中吗？然后筑巢呢？思想他妈的对吗？⚡️</p><p id="4b05" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们的问题是:当你只有结果HTML时，你如何预先知道哪一个是服务器上呈现的<code class="fe nh ni nj nk b">CoolComponent</code>的子组件？你看看就知道了。但是程序化？我们做SSR的时候孩子信息丢了。你可以在没有孩子的情况下渲染组件，然后在有孩子的情况下进行不同的渲染，但这听起来像是用硝化甘油做的实验😶</p><p id="083d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更进一步，将需要标识的子组件作为一个定制元素，以便我们在SSR之后知道哪个是作为子组件提供的:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1470" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以查询<code class="fe nh ni nj nk b">.wc-comp</code>来识别子节点。然而，我们<strong class="ka jc">不能</strong>使用<code class="fe nh ni nj nk b">querySelectorAll</code>，因为我们只想匹配直接子节点，而不是子节点。子进程应该由子进程来处理，而不是由<code class="fe nh ni nj nk b">this</code>来处理，否则你会将错误的子进程匹配到错误的父进程，并开始在HTML中混日子。这就是问题再次出现的地方。如果在中我们没有一个带有<code class="fe nh ni nj nk b">.wc-comp</code>的子节点，但是在一个不属于这个实例的嵌套子节点中呢？</p><p id="8ae6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">示例:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="8536" class="ky kz jb nk b gy oj ok l ol om">const MyComp = <br/>&lt;wc-without-own-children&gt;<br/>  &lt;a-sub-web-component&gt;<br/>    {props.children}<br/>  &lt;a-sub-web-component&gt;<br/>&lt;wc-without-own-children&gt;</span></pre><p id="8499" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以事实上被创造的<code class="fe nh ni nj nk b">&lt;MyComp /&gt;</code>确实带走了孩子。但是它会立即将它们传递给<code class="fe nh ni nj nk b">&lt;a-sub-web-component&gt;.</code>a,<code class="fe nh ni nj nk b">props.children</code>内标有<code class="fe nh ni nj nk b">class="wc-comp"</code>的子节点将由<code class="fe nh ni nj nk b">a-sub-web-component</code>处理，因此应该从该引用中获取。但是父组件将首先触发，并将这个<code class="fe nh ni nj nk b">props.children</code>提供给<code class="fe nh ni nj nk b">MyComp</code>，幸好<code class="fe nh ni nj nk b">MyComp</code>在正确的位置提供了正确的标记，但是它仍然会让子组件再次触发自身进行渲染。双重工作，多余处理。</p><p id="eed3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以假设你可以把它拿出来，作为一个实际的孩子提供给框架。</p><p id="bd6f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回想一下我们头脑中的同构:React、Vue和其他框架做了一个<strong class="ka jc"> 1:1 </strong>的比较，以水合完全有意义的组件。如果SSR DOM不同于客户端DOM，大多数框架会放弃并重新呈现。</p><p id="be3e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在它变得有趣了，因为我们正在讨论跨框架的使用。假设<code class="fe nh ni nj nk b">my-strong</code>是一个web组件。它有自己的生命周期，可以包含也可以不包含框架(这在这里并不重要)。它呈现如下:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="81a0" class="ky kz jb nk b gy oj ok l ol om">&lt;my-strong class="wc-comp"&gt;hello&lt;/my-strong&gt;</span></pre><p id="bb2f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对此</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="524a" class="ky kz jb nk b gy oj ok l ol om">&lt;my-strong class="wc-comp"&gt;&lt;strong&gt;hello&lt;/strong&gt;&lt;/my-strong&gt;</span></pre><p id="6dce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们努力实现的一个完全合理的设想。作为一个孩子，我们最初在render函数中赋予框架的是</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="4123" class="ky kz jb nk b gy oj ok l ol om">&lt;my-strong class="wc-comp"&gt;hello&lt;/my-strong&gt;</span></pre><p id="a69b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，即使我们能够正确地识别原始的子节点并提取它，然后在下一个渲染周期中(每当你改变父组件的状态时)，渲染父组件的框架可能会发现一个差异，因为现在它突然看到一个它不知道的<code class="fe nh ni nj nk b">strong</code>标签。它知道外在的<code class="fe nh ni nj nk b">&lt;my-strong&gt;</code>，却不知道内在的<code class="fe nh ni nj nk b">strong</code>。在这一点上，渲染生命周期变得<strong class="ka jc">不同步</strong>(用技术术语来说，这是一个不想要的副作用)<strong class="ka jc">。</strong></p><p id="bae1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说:组件之间互不了解。它们总是可以(例如通过交互)改变它们的状态，并因此单独改变DOM。并且组件会突然失去同步，这是由这些组件的独立性决定的。</p><p id="833e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使您提出<em class="kx">“我将只使用两者共享的存储，因此它们的状态是同步的”</em>那么您将会注意到它们仍然会不同步💩。我来告诉你为什么:中间的WebComponent层(<code class="fe nh ni nj nk b">customElement</code>)是你从父组件的角度做改变的接口，所以父组件永远不能告诉为什么它自己的子组件的内部html突然改变了。</p><p id="b464" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个有警告的以牙还牙的世界里。React检测到它正在被不同的渲染器重新渲染。但是React不了解其他框架！tldr: React在这种“不同步”(至少是我使用的版本16)方面非常可靠。</p><blockquote class="mv mw mx"><p id="1c0a" class="jy jz kx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">作为一个补充说明:嵌套和html复制的负面影响是子组件可能已经触发自身初始化——因为浏览器识别它们(例如，添加事件侦听器),然后再次移动(失去事件侦听器)只是为了再次初始化。因此，即使复制是一种解决方案，也会导致性能下降。我们不希望大量增加的复杂性只会恶化客户端的CPU负载。</p></blockquote><blockquote class="nm"><p id="cc86" class="nn no jb bd np nq pu pv pw px py kv dk translated">正如我们已经看到的，复制初始HTML，然后用任何动态框架呈现都不是要考虑的选项，因为使用给定的方法，我们既不能正确地识别子组件，也不能正确地通知父组件子组件树已经改变。</p></blockquote><p id="0112" class="pw-post-body-paragraph jy jz jb ka b kb oy kd ke kf oz kh ki kj pa kl km kn pb kp kq kr pc kt ku kv ij bi translated">一般来说，问题是我们试图将“未知”的预编译内容放在“静态”的上下文中，但实际上是动态的。我们正试图在不同框架的生命周期中处理特定于浏览器的生命周期(<code class="fe nh ni nj nk b">connectedCallback</code>等)，所有这些都有可能<em class="kx">无限</em>嵌套。这是一个棘手的难题。</p><h1 id="37b1" class="lw kz jb bd la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm bi translated">我们定义了这么多问题，我们能有一些解决方案吗？</h1><h2 id="6b21" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">提案1(琐碎)</h2><blockquote class="nm"><p id="92e1" class="nn no jb bd np nq nr ns nt nu nv kv dk translated">不要处理WebComponents中的子级。</p></blockquote><p id="5522" class="pw-post-body-paragraph jy jz jb ka b kb oy kd ke kf oz kh ki kj pa kl km kn pb kp kq kr pc kt ku kv ij bi translated">按照这种逻辑，你只需要处理顶层的渲染就可以了，因为你不需要识别子组件。</p><p id="edde" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个建议对于一个非常简单的网站来说可能是可以的，但是对于我们大多数人来说，这不是一个解决方案，因为自定义元素嵌套子元素是完全正常的，所以这个建议看起来没什么用，但是也许它适合你。</p><h2 id="7536" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">提案2影子DOM</h2><p id="89d0" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">让我们再一次把需求放在一起:</p><ul class=""><li id="0660" class="pg ph jb ka b kb kc kf kg kj pi kn pj kr pk kv pz pm pn po bi translated">我们想要渲染已经定义的子元素，例如<code class="fe nh ni nj nk b">&lt;my-wc&gt; &lt;children…&gt; &lt;/my-wc&gt;</code></li><li id="3eb1" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated">我们希望有多种不同的框架</li><li id="2f26" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated">我们想要SSR</li><li id="3db6" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated">我们想要网络组件</li></ul><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="qa ng l"/></div></figure><p id="8a48" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些巨大的需求可能会被影子DOM满足。我个人倾向于尽可能不使用影子DOM，但这不是我的观点，而是找到一个解决方案。</p><p id="e9fb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">影子DOM从同一个文档继承了CustomElements，这很好，因为这意味着在影子DOM范围内，我们可以使用在它之外定义的<code class="fe nh ni nj nk b">customElements</code>。</p><p id="e15d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们仔细看看它是如何把我们提升到一个解决方案的。</p><p id="89b2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的第一个示例是一个WebComponent的实现，它使用React进行呈现，并且有一个我们没有复制到呈现函数中的子组件:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b138" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请看这里的运行示例<a class="ae kw" href="https://codesandbox.io/s/react-web-component-with-slot-jutdt" rel="noopener ugc nofollow" target="_blank">https://code sandbox . io/s/react-we B- component-with-slot-judt</a>。</p><p id="5834" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们开始框架渲染之前，<code class="fe nh ni nj nk b">customElement</code> <code class="fe nh ni nj nk b">my-component</code>中的所有子节点都被移出了阴影DOM。他们仍然坐在<code class="fe nh ni nj nk b">my-component</code>里，但是现在他们在光明世界里。由于React只呈现原生的<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">HTMLSlotElement</strong></a>它不存在需要知道孩子的问题，浏览器会处理这些问题。它们就在那里，它们可以是它们想要的任何东西(来自SSR ),因为React组件保持同构，只呈现<code class="fe nh ni nj nk b">&lt;slot&gt;</code>标记。</p><p id="9c46" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，这实际上很好，因为它有助于保持一致性。浏览器不会将任何内容复制到slot元素中。它只引用插槽所在的元素，就像它在那里一样。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2121" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你选择<code class="fe nh ni nj nk b">this.shadowRoot.innerHTML</code>，它将返回:<code class="fe nh ni nj nk b">&lt;div&gt;&lt;slot&gt;&lt;/div&gt;&lt;/slot&gt;</code>。这完全符合预期，因为slot是一个占位符，浏览器不会将slotted元素放在那里。它只是引用它。</p><p id="eb93" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，innerHTML保持一致😲🤩。记住一致性是同构的关键。</p><p id="98d9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们通过使用影子DOM的方法再次尝试解决上面的问题。</p><h2 id="4d6e" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">影子DOM嵌套(无SSR)</h2><p id="dd89" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">假设这是你的CMS播放的HTML:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="99a3" class="ky kz jb nk b gy oj ok l ol om">&lt;wc-slider&gt;<br/>  &lt;wc-slider-elem&gt;<br/>    &lt;img src="test.jpg" /&gt;<br/>  &lt;/wc-slider-elem&gt;<br/>  &lt;wc-slider-elem&gt;<br/>    &lt;img src="test2.jpg" /&gt;<br/>  &lt;/wc-slider-elem&gt;<br/>&lt;/wc-slider&gt;</span></pre><p id="0682" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们之前的分析表明，所有作为孩子被给与<code class="fe nh ni nj nk b">customElement</code>的孩子都必须表现得静止不变。</p><p id="785e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">框架期望它不知道的东西具有一致性。我们可以认为任何具有影子DOM槽的原子组件都是静态的，因为<code class="fe nh ni nj nk b">customElement</code>的子节点不会不知不觉地改变——只有WebComponent子节点的<code class="fe nh ni nj nk b">shadowRoot.innerHTML</code>会改变——但这从外部/父节点是看不到的。如果开槽组件有子组件，那么子组件应该在它们的影子DOM范围内再次开槽，这样它们就在框架呈现的范围之外。所以那些行为是“静态的”,因为同样的原则也适用于它们。#递归#思维爆炸🤓</p><blockquote class="mv mw mx"><p id="57bf" class="jy jz kx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated"><strong class="ka jc">重要提示:</strong> Vue使用与实际<code class="fe nh ni nj nk b">HTMLSlotElement</code>相同的<a class="ae kw" href="https://vuejs.org/v2/guide/components-slots.html" rel="noopener ugc nofollow" target="_blank">元素标记名</a>作为其模板处理的子元素，因此我们不能简单地使用<code class="fe nh ni nj nk b">&lt;slot&gt;</code>，因为在我们的例子中它只会使其为空(“嘿，你没有为我提供Vue子元素，所以我只是为你移除了<code class="fe nh ni nj nk b">slot</code>)。</p><p id="1bdc" class="jy jz kx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">Vue实际上不赞成使用属性用法的<code class="fe nh ni nj nk b">slot</code>，而赞成使用<code class="fe nh ni nj nk b">v-slot</code>。</p><p id="41a2" class="jy jz kx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">“在所有未来的2.x版本中，将继续支持<code class="fe nh ni nj nk b">slot</code>和<code class="fe nh ni nj nk b">slot-scope</code>属性，但官方已弃用，最终将在Vue 3中删除”</p><p id="5f9a" class="jy jz kx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">不幸的是，这个改变并没有解决与原生<code class="fe nh ni nj nk b">&lt;slot&gt;</code> <br/>元素的冲突。</p></blockquote><p id="ad5c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用插槽<em class="kx">嵌套而不使用</em> SSR似乎相当容易。但是首先我们需要在Vue中找到一种方法来将<code class="fe nh ni nj nk b">&lt;slot&gt;</code>渲染到HTML中，这样我们就可以在影子DOM中使用它。</p><p id="7318" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想到了这个:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d783" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用<strong class="ka jc"> Vue和React together</strong>:<a class="ae kw" href="https://codesandbox.io/s/vue-shadowdom-native-slot-sample-with-consisten-dynamic-changes-with-react-and-vue-16brq" rel="noopener ugc nofollow" target="_blank">https://code sandbox . io/s/Vue-shadow DOM-native-slot-sample-with-consistence-dynamic-changes-with-React-and-Vue-16 brq</a>建立了一个广泛但可理解的自治web组件示例。</p><p id="4e42" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些的核心是使用插槽和这部分代码:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2d0e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现一致性，我们需要我们的子节点被开槽，但是开槽的元素存在于阴影DOM之外的光DOM中。因此，通过在附加阴影DOM之后调用<code class="fe nh ni nj nk b">this.appendChild</code>，我们在触发框架渲染之前将子节点从阴影DOM ( <code class="fe nh ni nj nk b">this.shadowRoot</code>)移动到<code class="fe nh ni nj nk b">customElement</code> ( <code class="fe nh ni nj nk b">this</code>)的根。</p><p id="f88e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以更直观的方式，会发生以下情况:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6321" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来的一步是在中渲染<strong class="ka jc">阴影DOM，它将渲染一个<code class="fe nh ni nj nk b">HTMLSlotElement</code>，这样我们移出的子节点就可以在里面看到了。</strong></p><p id="1c1d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是Vue的通用代码片段。请注意，Vue会替换它所挂载的元素，这就是为什么会创建一个额外的“ghost”div:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e667" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是反应的等式:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e756" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这太棒了。因为即使我们改变了Light DOM中的内容，Shadow DOM中的<code class="fe nh ni nj nk b">.innerHTML</code>我们的框架组件仍然保持一致！🤩🤩这是一个巨大的成就。谁会想到这只是几行代码呢？</p><p id="3f4b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，我们的第一点终于解决了:嵌套(不同的)框架，包括web组件。哇，花了点时间。</p><p id="9ade" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们还没有解决SSR。</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><h2 id="c300" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">带SSR +嵌套的阴影DOM</h2><p id="30d9" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">快速回顾:在不使用Shadow DOM 的情况下，将WebComponents与一个有自己生命周期的框架(React、Vue等等)相互嵌套使用似乎是不可能的。这种说法甚至只适用于一个将自定义元素嵌套在一起的框架。</p><p id="1d0a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在的问题是，在服务器上没有影子DOM或CustomElement这样的东西。所以我们不能在服务器端发布影子DOM。</p><p id="0968" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将不得不接受的事实是，我们需要影子DOM，并且影子DOM(到目前为止)不能以声明方式实现(也许将来我们会有一个<code class="fe nh ni nj nk b">shadowDOM</code>属性甚至一个<code class="fe nh ni nj nk b">&lt;ShadowFragment&gt;</code>标签？).</p><p id="adb6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先取一个未嵌套的SSR样本:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="74d1" class="ky kz jb nk b gy oj ok l ol om">&lt;my-component&gt;<br/>  &lt;img src="test.jpg" /&gt;<br/>&lt;/my-component&gt;</span></pre><p id="6512" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让所需的渲染结果成为</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="30f5" class="ky kz jb nk b gy oj ok l ol om">&lt;my-component&gt;<br/>  #shadowDom 🔽<br/>  &lt;div&gt;<br/>   &lt;slot @ref={&lt;img ..&gt;}&gt;&lt;/slot&gt;<br/>  &lt;/div&gt;<br/>  #shadowDom 🔼</span><span id="1d45" class="ky kz jb nk b gy pe ok l ol om">  #lightDOM 🔽<br/>  &lt;img src="test.jpg" /&gt;<br/>  #lightDOM 🔼<br/>&lt;/my-component&gt;</span></pre><p id="2ad5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要SSR来传递这个结果。</p><h2 id="6b18" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">SSR影子DOM /方法1:琐碎。</h2><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="85f6" class="ky kz jb nk b gy oj ok l ol om">&lt;my-component <br/> ssr="true" <br/> shadowDomHtml="&lt;...&gt;" <br/> lightDomHtml="&lt;...&gt;"&gt;<br/>...<br/>&lt;/my-component&gt;</span></pre><p id="61d9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以立即废弃这个解决方案，因为您将获得一些预呈现的HTML，但您将看不到它，直到WebComponent被执行并将其移动到正确的位置。因此，您在服务器端做的事情只有在JavaScript执行时才起作用。这听起来一点也不像SSR的目的。这个解决方案有更多的问题，但是给出的理由应该足够了。</p><h2 id="5abe" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">SSR影子DOM /方法2:隐藏槽。</h2><p id="e347" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">嵌套组件必须被开槽(如上所述)，因此不在父组件的渲染路径内，而是在父组件的渲染路径外(根据槽的定义)。</p><p id="a564" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着您的组件需要嵌套为其父组件的兄弟组件。这听起来有些矛盾，但对于插槽来说是完全正常的，并且符合插槽的定义。但是只要影子DOM还没有被附加(所以JS还没有被执行),这些槽就不是活动的。子节点作为父节点的兄弟而不是实际的子节点在技术上和语义上都是错误的(想想你的CSS样式)。当从服务器作为兄弟提供时，它们实际上处于错误的位置。</p><p id="9a26" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们仍然有好处，我们的HTML是预先呈现的。如果我们确保错误放置的插槽被隐藏，那么我们可能有SSR优势，而<em class="kx">相对</em>劣势较小。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ab31" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，我们正在玩一个slider父元素，它的内部有<code class="fe nh ni nj nk b">.slider</code> div和它的“子节点”<code class="fe nh ni nj nk b">.wc-slider</code>作为兄弟。<code class="fe nh ni nj nk b">data-ssr</code>帮助我们认识到我们应该补充水分。</p><p id="0adc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要为每个web组件提取“slottables ”:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="83fe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于某些用例来说，这是可行的。但是，如果您嵌套了多个组件，那么最上层的父组件也会选择所有不属于它但属于另一个子组件中的插槽的可开槽子组件(在最后一节“<strong class="ka jc">附加信息</strong>”中，您会找到WebComponents初始化的顺序)。我们可以通过使用一个约定来解决这个问题:每个<code class="fe nh ni nj nk b">customElement</code>都需要一个内部有特定<code class="fe nh ni nj nk b">className</code>的包装器，这样我们就可以使用<code class="fe nh ni nj nk b">.wrapperClass &gt; [unslotted="true"]</code>直接子选择器。</p><p id="e38f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以每个组件在渲染时看起来总是这样:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="7f75" class="ky kz jb nk b gy oj ok l ol om">&lt;some-component&gt;<br/>  &lt;div class="some-component-wrapper"&gt;<br/>   ...<br/>   &lt;slot /&gt;<br/>   ...<br/>  &lt;/div&gt;<br/>&lt;/some-component</span></pre><p id="2cf1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里找到一个演示实现:<a class="ae kw" href="https://codesandbox.io/s/nested-shadowdom-ssr-slots-1kehq" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/nested-shadowdom-ssr-slots-1kehq</a>。</p><h2 id="392a" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">SSR Shadow DOM /方法3:就地渲染，而不是作为兄弟，以获得最佳的初始结果</h2><p id="deb8" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">方法3遵循方法2，但是将组件精确地呈现在它在语义上应该在的地方——而不是在技术上。它将它精确地呈现在<code class="fe nh ni nj nk b">slot</code>标签的旁边，这样它就处于“正确的”DOM位置，以获得正确的视觉外观(CSS正确适用)。</p><p id="f57b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，当JS被执行时，我们添加一个影子DOM，将开槽子对象的DOM引用移到影子DOM之外，我们得到了预期的结果。</p><p id="1176" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里找到使用该方法的演示:<a class="ae kw" href="https://codesandbox.io/s/nested-shadowdom-ssr-slots-step-2-improved-xuvwy" rel="noopener ugc nofollow" target="_blank">https://code sandbox . io/s/nested-shadow DOM-SSR-slots-step-2-improved-xuvwy</a>。你可以看到你没有看到任何闪烁。可爱的❤️</p><p id="944c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这个没有陷阱，那就太容易了，对吗？没错。当一个框架可以1:1地呈现相同的客户端和服务器端时，同构就产生了。在这个例子中我们没有。</p><p id="aa27" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我解释一下为什么。服务器返回:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="cf9f" class="ky kz jb nk b gy oj ok l ol om">&lt;wc-slider-elem&gt;<br/>  &lt;div class="slider-elem"&gt;<br/>    &lt;slot&gt;&lt;/slot&gt;<br/>    <br/>    &lt;div unslotted="true"&gt;<br/>     some text<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/wc-slider-elem&gt;</span></pre><p id="63d3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的客户端代码对其进行了调整，使其具有适当的封装，并使其:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="3fac" class="ky kz jb nk b gy oj ok l ol om">&lt;wc-slider-elem&gt;<br/>  #shadowDom 🔽<br/>  &lt;div class="slider-elem"&gt;<br/>    &lt;slot&gt;&lt;/slot&gt;<br/>  &lt;/div&gt;<br/>  #shadowDom 🔼</span><span id="dcb8" class="ky kz jb nk b gy pe ok l ol om">  #lightDom 🔽<br/>  &lt;div unslotted="false"&gt;<br/>   some text<br/>  &lt;/div&gt;<br/>  #lightDom 🔼<br/>&lt;/wc-slider-elem&gt;</span></pre><p id="93fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们的框架将在影子DOM 内部呈现<strong class="ka jc">，同构的问题是，一旦我们水合，它将试图呈现这个:</strong></p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="0f7e" class="ky kz jb nk b gy oj ok l ol om">&lt;wc-slider-elem&gt;<br/>  #shadowDom 🔽<br/>  &lt;div class="slider-elem"&gt;<br/>    &lt;slot&gt;&lt;/slot&gt;<br/>    <br/>    &lt;div unslotted="true"&gt;<br/>      some text<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>  #shadowDom 🔼</span><span id="3bc8" class="ky kz jb nk b gy pe ok l ol om">  #lightDom 🔽<br/>  &lt;div unslotted="false"&gt;<br/>   some text<br/>  &lt;/div&gt;<br/>  #lightDom 🔼<br/>&lt;/wc-slider-elem&gt;</span></pre><p id="6b6e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在同构突然成了我们的问题。🤓🤯</p><p id="5bbf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们的问题是我们的框架(Vue，React，无论什么)需要在服务器上呈现不同于客户端的东西。所以你实际上需要在不同的地方播放DOM元素，这取决于它们是呈现在服务器上还是客户端上。</p><p id="65ab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">示例:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8395" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">🔼以上是一个理论世界的例子。它有点让你的代码变得复杂，带有一点肮脏的味道。我们让组件<strong class="ka jc">同等地</strong>呈现SSR和CSR，并为<strong class="ka jc">所需的差异使用后处理器，如何？</strong></p><p id="4470" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个示例显示，我们对SSR使用了与客户端上相同的组件，但是我们在将子位置发送到客户端之前对其进行了后处理，以使“初始视图/绘制”看起来正确——之后在客户端上将它移回Light DOM:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="23a1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">真了不起！同构，检查✅。但是在这种移动DOM的情况下，后处理也做了一些让人感觉不干净的事情。</p><h1 id="fce1" class="lw kz jb bd la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm bi translated">90%清洁有效的解决方案🤓</h1><p id="59cf" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">用Vue检查这个例子:<a class="ae kw" href="https://codesandbox.io/s/brave-chatelet-pql3y" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/brave-chatelet-pql3y</a>。它有一个循序渐进的方法，可能是90%的解决方案。您将在控制台中看到一个错误，我们将在本文的最后5%部分清除它，但现在不用担心它。我们还得谈谈另外5%的人。</p><p id="1229" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">这一切都归结为3个关键点:</strong></p><ul class=""><li id="1038" class="pg ph jb ka b kb kc kf kg kj pi kn pj kr pk kv pz pm pn po bi translated"><strong class="ka jc">匿名框架组件</strong>(如本文上文所述)</li><li id="71af" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated"><strong class="ka jc">用<code class="fe nh ni nj nk b">.module-className</code>包装器检测直接<code class="fe nh ni nj nk b">[unslotted=”true”]</code>子对象的影子DOM </strong></li><li id="9dcd" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated">与<code class="fe nh ni nj nk b">&lt;framework-slot /&gt;</code>一起使用<code class="fe nh ni nj nk b">&lt;native-html-slot /&gt;</code></li><li id="ce3f" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated">web组件到框架组件的映射<strong class="ka jc"/></li></ul></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="29df" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">先决条件:</strong></p><p id="9bcd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个组件都需要有一个匿名定义，它们各自的客户机/服务器都继承了这个匿名定义:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="3909" class="ky kz jb nk b gy oj ok l ol om">MyAnonymousComponent := <br/>&lt;div&gt;<br/>  &lt;framework-slot /&gt;<br/>  &lt;native-html-slot /&gt;<br/>&lt;/div&gt;;</span><span id="0d75" class="ky kz jb nk b gy pe ok l ol om">MyClientComponent := &lt;MyAnonymousComponent /&gt; </span><span id="e9b9" class="ky kz jb nk b gy pe ok l ol om">MySSRComponent := <br/>&lt;my-component&gt;<br/>  &lt;MyAnonymousComponent&gt;<br/>    ... // potential nesting<br/>  &lt;/MyAnonymousComponent&gt;<br/>&lt;/my-component&gt;</span></pre><p id="275d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有这个要求，因为我们需要在服务器端播放实际的<code class="fe nh ni nj nk b">customElement</code>标签，而不是在客户端播放(还记得无限循环吗？).</p><blockquote class="nm"><p id="ee2e" class="nn no jb bd np nq nr ns nt nu nv kv dk translated">此外，在客户端，我们永远不会有真正的框架子框架，因为我们的子框架本来就是有插槽的。</p></blockquote><p id="74ef" class="pw-post-body-paragraph jy jz jb ka b kb oy kd ke kf oz kh ki kj pa kl km kn pb kp kq kr pc kt ku kv ij bi translated">这也是为什么服务器上的<code class="fe nh ni nj nk b">framework-slot</code>实际上会将HTML放在那里(这是我们进行正确的SSR所需要的),而<code class="fe nh ni nj nk b">native-html-slot</code>只播放一个实际的<code class="fe nh ni nj nk b">HTMLSlotElement</code> <code class="fe nh ni nj nk b">&lt;slot&gt;</code>。</p><p id="81bc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的Vue示例中，它看起来像这样:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="fe81" class="ky kz jb nk b gy oj ok l ol om">&lt;div&gt;<br/>  &lt;SlotFactory /&gt;<br/>  &lt;slot&gt;&lt;/slot&gt;<br/>&lt;/div&gt;</span></pre><p id="964d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从我的Vue 2.6.11版本开始，<code class="fe nh ni nj nk b">&lt;slot&gt;</code>不是<code class="fe nh ni nj nk b">HTMLSlotElement</code>而是Vue占位符，所以我使用我的<code class="fe nh ni nj nk b">SlotFactory</code> Vue组件来创建一个实际的本机插槽，Vue不会将它视为Vue占位符。</p><p id="0a76" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们将使用上面描述的在子元素上具有属性<code class="fe nh ni nj nk b">unslotted</code>的系统，并且我们在组件内部为每个包装器使用适当的<code class="fe nh ni nj nk b">className</code>。我们附加了阴影DOM，然后我们可以找到直接的子元素，并把它们从阴影DOM移到亮DOM。</p><p id="a4d2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们快到了！😯</p><p id="c64e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我提到的<strong class="ka jc">映射</strong>是怎么回事呢？</p><p id="1a64" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个通用的、自主的微前端世界中，我会将这个发送给SSR服务:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="4b00" class="ky kz jb nk b gy oj ok l ol om">&lt;my-component&gt;<br/>  &lt;whatever /&gt;<br/>&lt;/my-component&gt;</span></pre><p id="55fb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<code class="fe nh ni nj nk b">my-component</code>是一个客户端独有的东西(<code class="fe nh ni nj nk b">customElement</code>)，服务器会立即返回我们的输入作为输出，没有任何渲染的变化，因为它根本不知道那个组件。在Vue中定义该组件不是一个选项，因为我必须注意它永远不会出现在客户端，否则我们不仅会打破同构，还会有一个无限循环(我们已经详细讨论过这个问题)。</p><p id="8767" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">所以我想出了这个:</strong></p><ol class=""><li id="a238" class="pg ph jb ka b kb kc kf kg kj pi kn pj kr pk kv pl pm pn po bi translated">HTML到达SSR服务</li><li id="de2a" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pl pm pn po bi translated">HTML通过XMLParser运行</li><li id="0880" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pl pm pn po bi translated">被定义为<code class="fe nh ni nj nk b">customElement</code>的HTML元素被映射回它们在服务器上各自的<code class="fe nh ni nj nk b">Vue.component</code>，这样Vue就可以渲染它，并再次用我合适的自定义元素标记名返回它(在我的演示中点击<code class="fe nh ni nj nk b">ssrService.js</code>查看)</li></ol><p id="9fcd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以在我的例子中，一切都归结于这个映射</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="caf3" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">陷阱1:为什么是90%的解决方案？另外10%在哪里</h2><p id="ed3e" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">这是第一个陷阱，我喜欢称之为<strong class="ka jc">前5%。</strong> <br/>如果插槽被提供为WebComponent的直接子插槽，则上述解决方案解决了子插槽。如果您在它周围添加另一个div，它将找不到直接的子元素。因此，它可能会解决您的用例，但也可能不会。</p><p id="0e56" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这个问题也有解决的方法。例如，如果你说<code class="fe nh ni nj nk b">wc-slider</code>中的可开槽子节点必须有类<code class="fe nh ni nj nk b">.wc-slider-elem</code>，并且不能有另一个<code class="fe nh ni nj nk b">wc-slider</code>或<code class="fe nh ni nj nk b">wc-slider-elem</code>递归嵌套，那么你可以省略直接子节点<code class="fe nh ni nj nk b">.wrapper &gt; [unslotted=true]</code>选择，而是通过<code class="fe nh ni nj nk b">.wrapper .wc-slider-elem[unslotted=true]</code>搜索你的插槽。这是可行的，但也使你的<code class="fe nh ni nj nk b">customElement</code>变得非常具体，并且需要大量的文档和精神负担，因为它不是一个通用的解决方案。</p><p id="d550" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我猜想只要有足够的文档，比如“这个<code class="fe nh ni nj nk b">wc-slider</code>只能包含<code class="fe nh ni nj nk b">wc-slider-elem</code>组件”，它就可以工作得很好。</p><h2 id="29f3" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">缺陷2:由于textNode缺陷，丢失了另外5%</h2><p id="c83a" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">提供的解决方案会出现一个非常奇怪(但合乎逻辑)的问题:这是Vue在我的<code class="fe nh ni nj nk b">customElement</code>初始化之前为我呈现的一个代码示例。</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="1ad2" class="ky kz jb nk b gy oj ok l ol om">slot<br/>#textNode(empty)<br/>div.slottable<br/>#textNode(empty)<br/>comment</span></pre><p id="aff4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对用户来说，视觉上只有以下内容</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="1aec" class="ky kz jb nk b gy oj ok l ol om">div.slottable</span></pre><p id="9acc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们附加阴影DOM并将<code class="fe nh ni nj nk b">slottableNode</code>提取到光照DOM中时，阴影DOM看起来像这样:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="7300" class="ky kz jb nk b gy oj ok l ol om">slot<br/>#textNode(empty)<br/>#textNode(empty)<br/>comment</span></pre><p id="4d3d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">灯光DOM看起来像这样:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="d6b7" class="ky kz jb nk b gy oj ok l ol om">div.slottable</span></pre><p id="ee9e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来没什么问题。但是Vue抱怨不能<code class="fe nh ni nj nk b">hydrate</code>和bails的水化有利于重新渲染。如果你深究，就会发现:</p><p id="bb39" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">客户端Vue将呈现两个的<strong class="ka jc">一个</strong> textNode，这是完全符合逻辑的。但是我们只是把一个组件<code class="fe nh ni nj nk b">div.slottable</code>移到了外面，剩下的就留在服务器上。这构成了存在于ShadowDOM中的两个<em class="kx"># textNode</em>，而对于给定的架构，Vue只会找到一个连续的文本(因为两个相邻的文本是一个text node)。所以存在文本节点不匹配的情况。</p><p id="5692" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我长话短说:你需要找到相邻的文本节点，并将它们连接成你的<code class="fe nh ni nj nk b">customElement</code>中的一个文本节点，以获得适当的水合作用。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qb"><img src="../Images/55bf39f29733ca92acbedc6442be0bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Svu8Q1kTaLq3hhSJ__UYdw.png"/></div></div></figure><h1 id="f3e9" class="lw kz jb bd la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm bi translated">结论/ IMHO</h1><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="qc ng l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">这是我分析后的感受。</figcaption></figure><p id="3a9d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望WebComponents实现自治，SSR实现更好的UX和性能。同构是SSR的必备。通过使用WebComponents，我们在两者之间添加了另一个生命周期层，它是<strong class="ka jc">而不是</strong>内置在框架中的。如果您设置了一些规则(参见“陷阱1…”和文档)，您可以让<code class="fe nh ni nj nk b">customElements</code>与SSR一起工作，如所述。</p><p id="2d15" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而:<strong class="ka jc">你想要那样吗？</strong></p><p id="a1f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理解为什么提出的影子DOM解决方案被认为是主流的，尽管影子DOM在服务器上并不存在，以及为什么其他解决方案似乎不能一致地工作而没有巨大的缺点和副作用，这是非常重要的。</p><p id="8660" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，您需要问问自己，在SSR+CSR的复杂性基础上增加的总体复杂性是否值得实现。此外，你应该想出一些约定，使整个过程更加通用，比如你不需要一直手动定义一个新的<code class="fe nh ni nj nk b">customElement</code>。</p><p id="68f9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最有可能的是，为什么<strong class="ka jc"> Nuxt.js </strong>和<strong class="ka jc"> Next.js </strong>存在而<strong class="ka jc">all frameworks together . js</strong>不存在是有原因的(也许我应该开发那个)。</p><p id="8936" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有些事情我们没有详细讨论:如果我们SSR一个包含Vue组件的React组件会怎么样？如果Vue分量输出反作用分量，反作用分量输出Vue分量呢？那么我们是应该只做<code class="fe nh ni nj nk b">ssrVue(ssrReact(ssrVue(ssrReact(...))))</code>还是应该创建一个递归，当它不再找到任何匹配的web组件时就停止？以及如何以及何时加载外部化的库？我相信你可以找到更多的问题，但目前就这些了。我受够了——暂时的。</p><p id="08d1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你真的想使用这个解决方案，那么我建议只为你选择的一个框架实现这个解决方案，并允许其他人连接到相同的机制客户端，而不是服务器端。这样你就享受到了你的主框架被ssr'ed的奢侈，同时还能把WebComponents和其他框架一起放在那里(只支持CSR)。</p><p id="31b2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，把你的头转过去，在评论区给我提供你的意见。</p><h1 id="a848" class="lw kz jb bd la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm bi translated">附加说明</h1><p id="14f3" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">还不足以阅读？还有一些细节需要了解。我分析了初始化的方式和顺序。了解浏览器如何初始化自定义元素是值得的。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="df37" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">具备上述条件会触发以下情况:</p><pre class="nb nc nd ne gt of nk og oh aw oi bi"><span id="4018" class="ky kz jb nk b gy oj ok l ol om">logs &gt;</span><span id="0b1d" class="ky kz jb nk b gy pe ok l ol om">x-foo triggered<br/>x-bar triggered<br/>x-boo triggered<br/>x-faa triggered</span></pre><p id="8957" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这意味着自定义元素是由内向外、自顶向下初始化的。或者tldr:从外向内从上到下。</p><p id="f25b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着最外面的自定义元素将首先触发初始化。</p><p id="341c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到嵌套框架的一致性(不使用插槽)，这种情况很糟糕。因为如果它是从内向外的，那么最外面的元素将能够获得所有正确的内部呈现的子元素(假设它们被立即呈现)。然而，由外向内(浏览器就是这样做的)的意思正好相反:首先，最父组件知道子结构，然后子结构改变-&gt;不同步。</p><blockquote class="mv mw mx"><p id="7e06" class="jy jz kx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">你可以尝试通过构建一个orchestrator来克服这种不一致性，以克服浏览器初始化的方式，但我再次问你，如果你正在改变它们的核心行为，你为什么还要费心使用CustomElements呢？那么我宁愿“建议”您使用一个可变的Observer并构建您自己的CustomElements，而不是使用这种奇怪的副作用很大的编排方法。</p></blockquote><h2 id="5d3d" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">来源</h2><ul class=""><li id="a2cb" class="pg ph jb ka b kb lr kf ls kj qd kn qe kr qf kv pz pm pn po bi translated"><a class="ae kw" href="https://developers.google.com/web/tools/puppeteer/articles/ssr" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/web/tools/puppeter/articles/SSR</a></li><li id="88af" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated"><a class="ae kw" href="https://github.com/vuejs/vue/issues/11211" rel="noopener ugc nofollow" target="_blank">https://github.com/vuejs/vue/issues/11211</a></li><li id="1521" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated"><a class="ae kw" href="https://ssr.vuejs.org/#what-is-server-side-rendering-ssr" rel="noopener ugc nofollow" target="_blank">https://ssr.vuejs.org/#what-is-server-side-rendering-ssr</a></li><li id="533e" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated"><a class="ae kw" href="https://vuejs.org/v2/guide/render-function.html" rel="noopener ugc nofollow" target="_blank">https://vuejs.org/v2/guide/render-function.html</a></li><li id="5e37" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated">https://reactjs.org/docs/react-dom.html#hydrate<a class="ae kw" href="https://reactjs.org/docs/react-dom.html#hydrate" rel="noopener ugc nofollow" target="_blank"/></li><li id="5ef2" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/HTML/Element/slot</a></li><li id="705e" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/HTMLSlotElement</a></li><li id="086f" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated"><a class="ae kw" href="https://www.mosaic9.org/" rel="noopener ugc nofollow" target="_blank">https://www.mosaic9.org/</a></li><li id="0cc3" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated"><a class="ae kw" href="https://www.webcomponents.org/introduction" rel="noopener ugc nofollow" target="_blank">https://www.webcomponents.org/introduction</a></li><li id="ee7c" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated"><a class="ae kw" href="https://dev.to/devalnor/running-jsx-in-your-browser-without-babel-1agc" rel="noopener ugc nofollow" target="_blank">https://dev . to/deval nor/running-jsx-in-your-browser-without-babel-1 AGC</a></li><li id="846f" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated"><a class="ae kw" href="https://stenciljs.com/docs/hydrate-app" rel="noopener ugc nofollow" target="_blank">https://stenciljs.com/docs/hydrate-app</a></li><li id="ae0c" class="pg ph jb ka b kb pp kf pq kj pr kn ps kr pt kv pz pm pn po bi translated">由<a class="ae kw" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae kw" href="https://unsplash.com/s/photos/connect?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</li></ul></div></div>    
</body>
</html>