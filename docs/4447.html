<html>
<head>
<title>The world’s simplest Kubernetes dashboard: k1s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">世界上最简单的Kubernetes仪表板:k1s</h1>
<blockquote>原文：<a href="https://itnext.io/the-worlds-simplest-kubernetes-dashboard-k1s-4246e03191df?source=collection_archive---------0-----------------------#2020-07-03">https://itnext.io/the-worlds-simplest-kubernetes-dashboard-k1s-4246e03191df?source=collection_archive---------0-----------------------#2020-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8cfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我实现了由50行Bash代码组成的“世界上最简单的Kubernetes仪表板”。它叫做<a class="ae ko" href="https://github.com/weibeld/k1s" rel="noopener ugc nofollow" target="_blank"> k1s </a>，这篇文章解释了如何使用它以及它是如何工作的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/8050e2964754cd8ef35e1b1f88bb079c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qsIfZt_BefKEl-8d9a0eQ.png"/></div></div></figure><blockquote class="lb lc ld"><p id="b0cd" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">当然，“世界最简单”并不是一个严肃的说法。<em class="it">😉</em></p></blockquote><p id="89e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在GitHub上的<a class="ae ko" href="https://github.com/weibeld/k1s" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"><em class="le">Wei eld/k1s</em></strong></a><strong class="js iu"><em class="le"/></strong>资源库<strong class="js iu"> <em class="le"> </em> </strong>中找到k1s的完整代码和详细使用说明。</p><h1 id="0dc6" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">内容</h1><ul class=""><li id="15b2" class="mg mh it js b jt mi jx mj kb mk kf ml kj mm kn mn mo mp mq bi translated"><a class="ae ko" href="#861d" rel="noopener ugc nofollow"> <strong class="js iu">概述</strong> </a></li><li id="03df" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae ko" href="#00a0" rel="noopener ugc nofollow"> <strong class="js iu">安装</strong> </a></li><li id="8d7b" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae ko" href="#60b7" rel="noopener ugc nofollow"> <strong class="js iu">用法</strong> </a></li><li id="a619" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae ko" href="#2459" rel="noopener ugc nofollow"> <strong class="js iu">实现</strong> </a></li><li id="9df9" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae ko" href="#aab1" rel="noopener ugc nofollow"> <strong class="js iu">讨论与结论</strong> </a></li></ul><h1 id="861d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">概观</h1><p id="b143" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">以下是k1s的大致外观:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mz"><img src="../Images/4412b7da61a2384ccd813b8077267c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bJTmV6iOieSCusIUJYvTSw.gif"/></div></div></figure><p id="8b88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仪表板可以显示任何名称空间(或跨所有名称空间)中任何资源类型的实时视图。对于某些资源类型，会显示附加信息，例如pod的当前状态，以及部署所需的和实际的副本数量。</p><p id="38dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以并排运行仪表板的多个实例，这允许您同时观察多个资源类型的更新。</p><p id="641d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个有三个仪表板实例的例子，一个用于<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#deployment-v1-apps" rel="noopener ugc nofollow" target="_blank">部署</a>，一个用于<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#replicaset-v1-apps" rel="noopener ugc nofollow" target="_blank">复制集</a>，一个用于<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#pod-v1-core" rel="noopener ugc nofollow" target="_blank">面板</a>(在<a class="ae ko" href="https://en.wikipedia.org/wiki/Tmux" rel="noopener ugc nofollow" target="_blank"> tmux </a>中运行)。然后在部署上执行一些扩展操作和滚动更新:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi na"><img src="../Images/317acfcf82675da022adcf54fe913813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aWHURvaW8lHn5yhp7SfxTA.gif"/></div></div></figure><p id="5086" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意如何实时观察部署、其管理的副本集和pod之间的交互。这可以让我们深入了解部署是如何工作的。同样，仪表板可以应用于其他资源组合。</p><h1 id="00a0" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">装置</h1><p id="6e1a" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">k1s是一个简单的Bash脚本，安装它所需要做的就是将它复制到本地机器上。如果您在macOS上使用自制软件，您可以使用:</p><pre class="kq kr ks kt gt nb nc nd ne aw nf bi"><span id="3a86" class="ng lj it nc b gy nh ni l nj nk"><strong class="nc iu">$ brew install weibeld/core/k1s</strong></span></pre><p id="7af6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在所有其他情况下，您可以按如下方式安装k1s:</p><pre class="kq kr ks kt gt nb nc nd ne aw nf bi"><span id="d1d6" class="ng lj it nc b gy nh ni l nj nk"><strong class="nc iu">{<br/>  wget </strong><a class="ae ko" href="https://raw.githubusercontent.com/weibeld/k1s/master/k1s" rel="noopener ugc nofollow" target="_blank"><strong class="nc iu">https://raw.githubusercontent.com/weibeld/k1s/master/k1s</strong></a><strong class="nc iu"><br/>  chmod +x k1s<br/>  mv k1s /usr/local/bin<br/>}</strong></span></pre><p id="9c8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">k1s还依赖于您的计算机上安装的以下工具:</p><ul class=""><li id="55ef" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><code class="fe no np nq nc b"><a class="ae ko" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">jq</strong></a></code></li><li id="87d7" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe no np nq nc b"><a class="ae ko" href="https://linux.die.net/man/1/watch" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">watch</strong></a></code></li><li id="cb09" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe no np nq nc b"><a class="ae ko" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">curl</strong></a></code></li><li id="c68b" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe no np nq nc b"><a class="ae ko" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">kubectl</strong></a></code></li></ul><p id="6e71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能已经拥有了这些工具中的大部分。如果没有，你可以在<a class="ae ko" href="https://github.com/weibeld/k1s#dependencies" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到它们的安装说明。</p><h1 id="60b7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用</h1><p id="2010" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">k1s是一个名为<code class="fe no np nq nc b">k1s</code>的Bash脚本，它直接运行在您的本地机器上。它具有以下命令行界面:</p><pre class="kq kr ks kt gt nb nc nd ne aw nf bi"><span id="2c97" class="ng lj it nc b gy nh ni l nj nk"><strong class="nc iu">$ k1s [namespace] [resource-type]</strong></span></pre><p id="6578" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">两个可选的命令行参数是:</p><ul class=""><li id="421a" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><code class="fe no np nq nc b"><strong class="js iu">namespace</strong></code> <strong class="js iu"> : </strong>指定要在其中观察资源的Kubernetes名称空间(默认为<code class="fe no np nq nc b">default</code>)</li><li id="5d14" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe no np nq nc b"><strong class="js iu">resource-type</strong></code> <strong class="js iu"> : </strong>指定您想要观察的Kubernetes资源类型(默认为<code class="fe no np nq nc b">pods</code>)</li></ul><p id="fe05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了观察所有名称空间中的资源类型，可以使用破折号(<code class="fe no np nq nc b">-</code>)作为<code class="fe no np nq nc b">namespace</code>参数。</p><p id="8620" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于给定的资源类型，<code class="fe no np nq nc b">resource-type</code>参数的值可以是Kubernetes接受的任何名称变量。这包括复数形式、单数形式和简称(如果有的话)。例如，以下都是有效值:</p><ul class=""><li id="734f" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><code class="fe no np nq nc b">deployments</code>、<code class="fe no np nq nc b">deployment</code>、<code class="fe no np nq nc b">deploy</code></li><li id="75a0" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe no np nq nc b">replicasets</code>、<code class="fe no np nq nc b">replicaset</code>、<code class="fe no np nq nc b">rs</code></li><li id="119d" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe no np nq nc b">services</code>、<code class="fe no np nq nc b">service</code>、<code class="fe no np nq nc b">svc</code></li></ul><blockquote class="lb lc ld"><p id="4106" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">你可以通过<code class="fe no np nq nc b">kubectl api-resources</code>找到所有资源类型的简称。</p></blockquote><p id="149f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">k1s由本地机器上的<a class="ae ko" href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/" rel="noopener ugc nofollow" target="_blank"> kubeconfig </a>配置系统支持。这意味着，k1s总是适用于在kubeconfig文件的当前上下文中指定的集群。换句话说，k1s适用于kubectl默认使用的集群。</p><p id="8d3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要退出仪表板，请键入<em class="le"> Ctrl-C </em></p><h1 id="2459" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">履行</h1><p id="45f1" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">现在，让我们转向实现。如前所述，k1s是一个Bash脚本，下面是<a class="ae ko" href="https://github.com/weibeld/k1s/releases/tag/0.1.2" rel="noopener ugc nofollow" target="_blank"> k1s版本0.1.2 </a>的完整代码:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7394" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将一步一步地浏览上面的代码，但首先，让我们讨论一下k1s所基于的一般思想。</p><h2 id="1775" class="ng lj it bd lk nt nu dn lo nv nw dp ls kb nx ny lw kf nz oa ma kj ob oc me od bi translated">基本机制</h2><p id="32f6" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">以下是使k1s发挥作用的主要因素:</p><ol class=""><li id="f75c" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn oe mo mp mq bi translated">使用<code class="fe no np nq nc b"><a class="ae ko" href="https://kubernetes.io/docs/tasks/extend-kubernetes/http-proxy-access-api/" rel="noopener ugc nofollow" target="_blank">kubectl proxy</a></code>允许轻松访问Kubernetes API服务器(<strong class="js iu">第20行</strong>)。</li><li id="98c3" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn oe mo mp mq bi translated">使用<code class="fe no np nq nc b"><a class="ae ko" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank">curl</a></code>对给定资源类型的Kubernetes API执行<em class="le"> watch </em>请求(<strong class="js iu">第32行</strong>)。这创建了一个到API服务器的持久连接，它返回一个JSON资源事件流，这些事件属于<code class="fe no np nq nc b">ADDED</code>、<code class="fe no np nq nc b">MODIFIED</code>或<code class="fe no np nq nc b">DELETED</code>类型。</li><li id="096f" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn oe mo mp mq bi translated">使用<code class="fe no np nq nc b"><a class="ae ko" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank">jq</a></code>解析每个事件并从中提取某些信息，比如事件所涉及的资源的名称。将该信息作为附加行写入文件系统的一个文件中(称为<em class="le">状态文件</em>)。如果资源已经存在于文件中，更新它，如果资源被删除，从文件中删除它的行(<strong class="js iu">第48–50行</strong>)。</li><li id="6bd4" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn oe mo mp mq bi translated">使用<code class="fe no np nq nc b"><a class="ae ko" href="https://linux.die.net/man/1/watch" rel="noopener ugc nofollow" target="_blank">watch</a></code>显示状态文件并定期更新(<strong class="js iu">行54 </strong>)。这给人一种动态更新的全屏终端app的感觉。</li></ol><p id="c48d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，简而言之，k1s不断地将给定资源类型的状态合并到一个文件中，并用<code class="fe no np nq nc b">watch</code>显示这个文件，以便您可以实时观察任何更新。</p><p id="a36f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们转向实际的代码。</p><h2 id="7297" class="ng lj it bd lk nt nu dn lo nv nw dp ls kb nx ny lw kf nz oa ma kj ob oc me od bi translated">具体实施</h2><p id="ae3c" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated"><code class="fe no np nq nc b">k1s</code>脚本从以下代码行开始:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi of"><img src="../Images/5e5b99a8e9a889026ccc5228d5c1a5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e200LjeU3msikvmq55k7zw.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">k1s v0.1.2的第3–5行</figcaption></figure><p id="7786" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这执行一些基本的检查和初始化:</p><ul class=""><li id="e034" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><strong class="js iu">第3行</strong>实现打印k1s版本的<code class="fe no np nq nc b">-v</code> / <code class="fe no np nq nc b">--version</code>选项。</li><li id="930b" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第4行</strong>检查本地机器上是否安装了所有的依赖项，如果没有安装，则中止并显示一条错误消息。</li><li id="12d7" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第5行</strong>读取<code class="fe no np nq nc b">namespace</code>和<code class="fe no np nq nc b">resource-type</code>命令行参数的值，如果用户没有指定值，则使用默认值。</li></ul><p id="2c8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来的两行代码如下:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi of"><img src="../Images/966f6a7c22af0b3d59be270687eec1eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZsO8JVrWX4huLjaBz3big.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">k1s v0.1.2的第7–8行。</figcaption></figure><p id="1ba5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这定义了两个Bash函数，用于输出以特定颜色打印文本的<a class="ae ko" href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors" rel="noopener ugc nofollow" target="_blank"> ANSI转义序列</a>。这些函数将在以后用于k1s输出的着色部分。</p><blockquote class="lb lc ld"><p id="fbdc" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated"><a class="ae ko" href="https://en.wikipedia.org/wiki/ANSI_escape_code" rel="noopener ugc nofollow" target="_blank"> ANSI转义序列</a>是由<a class="ae ko" href="https://en.wikipedia.org/wiki/Terminal_emulator" rel="noopener ugc nofollow" target="_blank">终端仿真器</a>解释的一组标准化代码(例如<a class="ae ko" href="https://invisible-island.net/xterm/" rel="noopener ugc nofollow" target="_blank"> xterm </a>，<a class="ae ko" href="https://www.iterm2.com/" rel="noopener ugc nofollow" target="_blank"> iTerm2 </a>)。这些代码定义了如何在终端上显示内容的各个方面。它们起源于“哑巴”<a class="ae ko" href="https://en.wikipedia.org/wiki/Computer_terminal" rel="noopener ugc nofollow" target="_blank">视频终端</a>连接到大型共享计算机的时代。运行在计算机上的程序可以向终端发送ANSI转义序列，用于定义光标位置和输出文本颜色等内容。</p></blockquote><p id="5d85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是下面一行:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi of"><img src="../Images/40158130909eb285a7064ca5a587a188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wv1JgpbQWn-Qh2v6eIfeJg.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">k1s v0.1.2第10行。</figcaption></figure><p id="3ad2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将打印在启动k1s后立即出现的加载指示器。该任务作为后台进程启动，由一个以0.1秒间隔打印点的无限循环组成。当k1s的初始化过程完成时，该过程将按需终止。</p><p id="f1e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是下一段代码:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ok"><img src="../Images/88f36f9a9f2444e3114faa9c6f87b6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wO_q2S2HwPjts9QWm6pCZg.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">k1s v0.1.2的第12–18行</figcaption></figure><blockquote class="lb lc ld"><p id="fbe8" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">对于被截断的行，请参考<a class="ae ko" href="https://github.com/weibeld/k1s/blob/0.1.2/k1s" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中的代码。</p></blockquote><p id="1dde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码实现了k1s的主要初始化步骤。它为用户请求的资源类型和名称空间确定Kubernetes API路径:</p><ul class=""><li id="edb1" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><strong class="js iu">第12行</strong>启用<code class="fe no np nq nc b">pipefail</code> <a class="ae ko" href="http://th" rel="noopener ugc nofollow" target="_blank"> Bash选项</a>，如果其包含的任何命令返回非零退出代码，该选项将导致管道语句作为一个整体返回非零退出代码。这是以下命令正常工作所必需的。</li><li id="c5e2" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第13行</strong>对所请求的资源类型和名称空间发出一个<code class="fe no np nq nc b">kubectl get</code>请求，并从<code class="fe no np nq nc b">kubectl</code>的输出中提取该操作的正确Kubernetes API路径。这里的技巧是增加<code class="fe no np nq nc b">kubectl</code>(用<code class="fe no np nq nc b">-v 6</code>)的详细程度会导致<code class="fe no np nq nc b">kubectl</code>输出它在幕后发出的HTTP GET请求的确切URL。从这个URL中，通过一些<code class="fe no np nq nc b">grep</code>和<code class="fe no np nq nc b">sed</code>操作提取API路径。</li><li id="cd9d" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第14行</strong>记录了第13行发出的<code class="fe no np nq nc b">kubectl get</code>命令的退出代码。如果请求成功，这个退出代码为零，否则为非零。非零退出代码最可能(也是假定的)的原因是用户提供了无效的资源类型规范(例如，<code class="fe no np nq nc b">dep</code>而不是<code class="fe no np nq nc b">deployments</code>或<code class="fe no np nq nc b">deployment</code>或<code class="fe no np nq nc b">deploy</code>)。</li></ul><blockquote class="lb lc ld"><p id="00d3" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">使用<code class="fe no np nq nc b">kubectl get</code>来确定正确的API路径是k1s接受所有资源类型名称变量的原因，这些变量也被<code class="fe no np nq nc b">kubectl</code>接受。实际上，k1s将这些名称变体的处理和正确API路径的确定外包给了<code class="fe no np nq nc b">kubectl</code>，这极大地简化了k1s的实现。</p></blockquote><ul class=""><li id="13f8" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><strong class="js iu">第15行</strong>终止从第10行开始的加载指示器后台进程。请注意，加载指示器进程的进程ID (PID)保存在变量<code class="fe no np nq nc b">$!</code>中。在Bash中，<code class="fe no np nq nc b">$!</code>是一个内部变量，保存在后台启动的最后一个进程的PID。由于该脚本从第10行开始就没有启动其他后台进程，所以这肯定是加载指示器进程。</li><li id="4ede" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第16行</strong>检查第13行<code class="fe no np nq nc b">kubectl get</code>请求的退出代码。如果退出代码为非零值，则假定原因是用户提供了无效的资源类型规范，脚本中止并显示相应的错误消息。</li></ul><p id="0c52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来的两行只是装饰性的:</p><ul class=""><li id="d5d2" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><strong class="js iu">第17行</strong>检查提取的<a class="ae ko" href="https://kubernetes.io/docs/reference/using-api/api-concepts/" rel="noopener ugc nofollow" target="_blank"> API路径</a>是否包含名称空间段。如果不是这种情况，则意味着用户请求了跨所有命名空间的命名空间资源类型或者非命名空间资源类型。在这种情况下，将在仪表板中显示的名称空间指示被设置为<code class="fe no np nq nc b">-</code>。这修复了用户请求非命名空间资源类型但仍然指定命名空间的情况。</li><li id="2b9e" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第18行</strong>将用户提供的资源类型规范设置为它的规范复数形式，它是从API路径中提取的。该值也将显示在仪表板标题中。这意味着，如果用户指定<code class="fe no np nq nc b">deploy</code>或<code class="fe no np nq nc b">deployment</code>来观看部署，仪表板将在标题横幅中统一打印<code class="fe no np nq nc b">deployments</code>。</li></ul><p id="b820" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们继续下面两行代码:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ol"><img src="../Images/be7f07344f6c4bc59c1b751648e753a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWjZ9nbu4q-grVn1CLx19g.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">k1s v0.1.2的第20–21行</figcaption></figure><p id="0724" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两行设置了<code class="fe no np nq nc b"><a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#proxy" rel="noopener ugc nofollow" target="_blank">kubectl proxy</a></code>，脚本稍后将通过它连接到Kubernetes API服务器:</p><ul class=""><li id="3641" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><strong class="js iu">第20行</strong>执行<code class="fe no np nq nc b">kubectl proxy</code>作为后台进程。<code class="fe no np nq nc b">kubectl proxy</code>命令为Kubernetes API服务器创建一个本地代理，监听本地机器上的一个随机端口(由<code class="fe no np nq nc b">-p 0</code>指定)。后台进程的输出在一个新的文件描述符<code class="fe no np nq nc b">3</code>中被捕获。</li><li id="6984" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第21行</strong>从前一行创建的文件描述符<code class="fe no np nq nc b">3</code>(即<code class="fe no np nq nc b">kubectl proxy</code>的输出)中提取<code class="fe no np nq nc b">kubectl proxy</code>选择的随机端口。知道这个端口对于在代码后面构造Kubernetes watch请求的URL是必要的。</li></ul><blockquote class="lb lc ld"><p id="b79f" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">在<a class="ae ko" href="https://stackoverflow.com/a/20018118/4747193" rel="noopener ugc nofollow" target="_blank">这个StackOverflow回答</a>中描述了上述捕获后台进程输出的技术。</p></blockquote><p id="5601" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是下面这段代码:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi om"><img src="../Images/975beeb3914a132bde441e02c8901e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5eeyq6EzRGgB_D5_jd7HEg.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">k1s v0.1.2的第23–30行</figcaption></figure><p id="9547" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该代码创建并初始化状态文件，该文件稍后将通过<code class="fe no np nq nc b">watch</code>命令显示:</p><ul class=""><li id="e4dd" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated">第23行创建状态文件。</li><li id="507b" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第24–30行</strong>将标题横幅写入状态文件。标题横幅由(彩色)k1s徽标和一些其他信息组成，包括正在查看的命名空间和资源类型。</li></ul><p id="b3d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一段代码如下:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi on"><img src="../Images/bc7df3e13fafffdfed5acc375a280fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vdT7WFUuYBX2yeFvUFT74A.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">k1s v0.1.2的第32–52行</figcaption></figure><blockquote class="lb lc ld"><p id="e181" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">对于被截断的行，请参考<a class="ae ko" href="https://github.com/weibeld/k1s/blob/0.1.1/k1s" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中的代码。</p></blockquote><p id="3008" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码让实际的<em class="le">观察</em>请求，并处理来自Kubernetes API服务器的事件响应流。上面的代码实际上是一个Bash语句，由一个<code class="fe no np nq nc b">curl</code>命令组成，该命令通过管道传递给一个<code class="fe no np nq nc b">while</code>循环，该循环一直读取<code class="fe no np nq nc b">curl</code>命令的输出行:</p><ul class=""><li id="ade3" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><strong class="js iu">线32 </strong>用<code class="fe no np nq nc b">curl</code>使<em class="le">手表</em>请求。这个URL是从Kubernetes API路径和前面确定的<code class="fe no np nq nc b">kubectl proxy</code>端口构建的。由<em class="le"> watch </em>请求返回的每个响应都是对应于一个资源事件的一行JSON。<code class="fe no np nq nc b">curl</code>的<code class="fe no np nq nc b">-N</code>选项禁用输出缓冲，以便这些行中的每一行一被接收就被输出。</li><li id="b5de" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">行33 </strong>开始一个<code class="fe no np nq nc b"><a class="ae ko" href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html" rel="noopener ugc nofollow" target="_blank">while</a></code>循环，处理<code class="fe no np nq nc b">curl</code>的每一个输出行(保存在一个名为<code class="fe no np nq nc b">event</code>的变量中)。该循环无限期运行，只有当用户点击仪表板上的<em class="le"> Ctrl-C </em>时才会终止。</li></ul><p id="c5ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">循环体的范围从第34行到第51行。开头的几行从传递到循环体的JSON事件对象中提取一些数据:</p><ul class=""><li id="97eb" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><strong class="js iu">第34行</strong>提取事件所涉及的资源名称(即被创建、修改或删除的资源)。使用<code class="fe no np nq nc b">jq</code>工具完成提取。</li><li id="27cf" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第35行</strong>开始一个<code class="fe no np nq nc b"><a class="ae ko" href="http://a" rel="noopener ugc nofollow" target="_blank">case</a></code>语句，该语句将根据资源类型采取不同的动作。这样做的目的是特别对待某些资源类型，并为它们确定和提取附加信息。</li></ul><p id="49f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第36–41行以特殊方式处理<strong class="js iu">吊舱</strong>:</p><ul class=""><li id="febc" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><strong class="js iu">第37行</strong>提取Pod当前所处的<a class="ae ko" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase" rel="noopener ugc nofollow" target="_blank">阶段</a>。相位是Pod状态的高级指示，如<code class="fe no np nq nc b">Running</code>或<code class="fe no np nq nc b">Pending</code>。</li><li id="9ed2" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第38行</strong>确定Pod的<code class="fe no np nq nc b">Ready</code> <a class="ae ko" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions" rel="noopener ugc nofollow" target="_blank">条件</a>是否设置为<code class="fe no np nq nc b">True</code>。如果是这种情况，那么Pod中的所有容器都通过了它们的<a class="ae ko" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes" rel="noopener ugc nofollow" target="_blank">准备就绪探测器</a>，并且Pod能够服务于用户请求。</li><li id="c15a" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第39行</strong>确定Pod的<code class="fe no np nq nc b">PodScheduled</code>状态是否设置为<code class="fe no np nq nc b">True</code>。如果是这种情况，那么Kubernetes调度程序已经为Pod分配了一个节点。</li><li id="663b" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第40行</strong>决定k1s将显示的Pod的状态。默认情况下，k1s显示Pod的阶段。然而，在下面的情况下，行为是不同的:如果Pod已经被调度但是当前没有准备好，那么k1s显示<code class="fe no np nq nc b">NonReady</code>而不是阶段，在这些情况下是<code class="fe no np nq nc b">Pending</code>。这使得区分还没有被调度的单元和仅仅是暂时暂停或终止的单元变得更加容易。</li><li id="a779" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第41行</strong>为更好的视觉效果对Pod的状态指示器进行着色:如果状态为<code class="fe no np nq nc b">Running</code>则为绿色，其他情况下为黄色。</li></ul><p id="2ec8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第42–45行以特殊的方式处理部署、复制集和状态集(都是Pod控制器):</p><ul class=""><li id="0401" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><strong class="js iu">第43行</strong>决定了Pod控制器副本的指定(所需)数量。</li><li id="ca77" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第44行</strong>确定Pod控制器当前可用(就绪)的副本数量。</li><li id="522e" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">第45行对副本指示器进行格式化和着色:如果副本的可用数量与所需数量相匹配，则为绿色，否则为黄色。</li></ul><p id="a224" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，第47–51行根据事件类型和上面确定的信息更新状态文件。这是这几行:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi on"><img src="../Images/02e620c5d27b29ed5c83da639052aa43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-rv55oBFDVkTcSX0wexxgA.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">k1s v0.1.2的第47–51行(重复)。</figcaption></figure><ul class=""><li id="ebab" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated"><strong class="js iu">第47行</strong>开始一个<code class="fe no np nq nc b">case</code>语句，该语句将根据当前事件的类型采取不同的动作。类型可以是<code class="fe no np nq nc b">ADDED</code>、<code class="fe no np nq nc b">MODIFIED</code>和<code class="fe no np nq nc b">DELETED</code>中的一种。</li><li id="8e54" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第48行</strong>处理<code class="fe no np nq nc b">ADDED</code>事件:如果添加了一个资源，它的名称(以及任何先前确定的附加资源类型特定信息)将作为新的一行添加到状态文件中。</li><li id="39de" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第49行</strong>处理<code class="fe no np nq nc b">MODIFIED</code>事件:如果一个资源被修改(例如当一个Pod的阶段改变时)，状态文件中该资源的现有行被替换为包含新信息的新行。</li><li id="595e" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">第50行</strong>处理<code class="fe no np nq nc b">DELETED</code>事件:如果一个资源被删除，它在状态文件中对应的行也被删除。</li></ul><p id="51de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">k1s的代码中只剩下一行:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oo"><img src="../Images/6ca4e4dfcfe74570d74e3144ac3e918d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URmj9IROGrrnN0xqeC0QVg.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">k1s v0.1.2第54行。</figcaption></figure><p id="40ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一行执行<code class="fe no np nq nc b">watch</code>命令，在你的终端窗口显示状态文件并定期更新。更新间隔设置为0.1秒，这足够小，在人眼看来就像“实时”一样。</p><p id="5eff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">就这样！</strong></p><p id="90df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那是k1s的完整代码！</p><h1 id="aab1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">讨论和结论</h1><p id="581a" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">正如它的口号所暗示的，k1s的重点是简单和简洁。这带来了一些限制，需要指出的是:</p><ul class=""><li id="6786" class="mg mh it js b jt ju jx jy kb nl kf nm kj nn kn mn mo mp mq bi translated">目前最大的限制可能是，当仪表板中的项目列表超过终端窗口的高度时，超出窗口底部的所有输出都会被截断，并且没有办法滚动到它。这是因为<code class="fe no np nq nc b">watch</code>不允许滚动超过终端高度的文件。如果你知道解决这个问题的简单方法，请在评论中告诉我。</li><li id="bf5a" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">显示包括其他资源类型(如服务和端点)在内的更多附加信息会很有意思。然而，这可能是一个无底洞，因为总有更多的东西可以展示，不同的人对不同的东西感兴趣。然而，由于当前的代码如此简短，应该很容易为特定的用例或调查按需定制它。</li><li id="46d7" class="mg mh it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">该工具取决于其他工具的输出格式，尤其是<code class="fe no np nq nc b">kubectl</code>。这意味着，如果这些工具的输出格式发生变化，那么k1s也需要进行调整。但是，鉴于k1s代码的简洁性，这应该是一个相对快速的任务。</li></ul><p id="4194" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，这些限制中的大部分可以通过用真正的编程语言(比如Go)实现k1s来解决，就像所有成熟的Kubernetes仪表板一样。然而，k1s也是作为一种实验开始的，它是关于用尽可能简单的方法(和尽可能少的代码行)实现有用的东西能走多远。它实际上是作为一个Bash单行程序开始的，用于在默认名称空间中显示当前的pod集。</p><p id="1d03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑到这一点，这个工具仍然非常有用(至少对于实验性或教育性的用例来说)，它可以作为围绕Kubernetes的高级脚本的基础。</p><p id="4712" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本着这种精神，随意使用<a class="ae ko" href="https://github.com/weibeld/k1s" rel="noopener ugc nofollow" target="_blank"> k1s </a>和文件<a class="ae ko" href="https://github.com/weibeld/k1s/issues" rel="noopener ugc nofollow" target="_blank">问题</a>和<a class="ae ko" href="https://github.com/weibeld/k1s/pulls" rel="noopener ugc nofollow" target="_blank">拉动请求</a>！</p></div></div>    
</body>
</html>