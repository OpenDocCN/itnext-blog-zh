<html>
<head>
<title>Securing Node services with Client Authenticated TLS using CATKeys</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CATKeys通过客户端认证的TLS保护节点服务</h1>
<blockquote>原文：<a href="https://itnext.io/securing-node-services-using-client-authenticated-tls-with-catkeys-938709726fbc?source=collection_archive---------2-----------------------#2021-02-26">https://itnext.io/securing-node-services-using-client-authenticated-tls-with-catkeys-938709726fbc?source=collection_archive---------2-----------------------#2021-02-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ca1afaaf5b83a67dc56a4ceb4f18f894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBZcQZjP2cRacu0eRqhepw.png"/></div></div></figure><p id="3d8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有些服务是公开的，每个人都应该可以使用。有些服务是私有的，应该只允许一组特定的客户端访问。</p><p id="b8f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本指南介绍了使用CATKeys通过客户端认证TLS来保护基于节点的web服务的步骤，以便只有经过授权的客户端才能访问私有web服务。</p><h1 id="8f23" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">客户端验证的TLS</h1><p id="efa5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake" rel="noopener ugc nofollow" target="_blank">客户端认证TLS </a>是TLS握手的一个版本，它使用客户端证书在客户端和服务器之间提供<a class="ae lz" href="https://en.wikipedia.org/wiki/Mutual_authentication" rel="noopener ugc nofollow" target="_blank">相互认证</a>(也称为双向认证)。</p><p id="df28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相互身份验证意味着客户端将只连接到有效的服务器(普通TLS就是这种情况)，而且服务器将只允许有效的客户端连接。</p><p id="e6f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得它在只有特权客户端能够访问web服务或RPC端点的情况下非常有用。例如，您可能有一个使用私有web服务的公共web服务。</p><p id="f72b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用一个名为CATKeys的库(我是该库的作者)演示一种简单的方法来保护带有客户端认证TLS的节点服务器。</p><h1 id="06ca" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">猫钥匙</h1><p id="d234" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://github.com/93million/catkeys" rel="noopener ugc nofollow" target="_blank"> CATKeys </a>是在阅读了Anders Brownworth 的<a class="ae lz" href="https://engineering.circle.com/https-authorized-certs-with-node-js-315e548354a2" rel="noopener ugc nofollow" target="_blank">帖子后创建的，该帖子描述了如何使用OpenSSL来生成使用客户端证书保护HTTPS所需的ca、证书和密钥。这是一篇写得很好，内容广泛的帖子，如果你想了解幕后发生的事情，值得一读。</a></p><p id="3080" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CATKeys是一个简单的库，只需很少的努力就能提供相互认证。它支持HTTPS以及TLS通信。使用简单的命令生成密钥，然后在您使用<code class="fe ma mb mc md b">https.createServer()</code>、<code class="fe ma mb mc md b">https.request()</code>、<code class="fe ma mb mc md b">tls.createServer()</code>或<code class="fe ma mb mc md b">tls.connect()</code>的任何地方使用CATKeys作为替换。</p><p id="6986" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本指南中，我们将创建一个简单的web服务，它将使用包含用于连接的客户端密钥名称的JSON对象进行响应。</p><h2 id="1117" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">创建简单节点HTTP服务器</h2><p id="2a7e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们从一个简单的http服务器开始，我们将把它迁移到CATKeys。它将返回一个JSON对象，描述服务器是否安全。</p><p id="3664" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个服务器并另存为<code class="fe ma mb mc md b">serve.js</code>:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="41ed" class="me kx iq md b gy my mz l na nb">const http = require('http')<br/>const serve = () =&gt; {<br/>  http.createServer(<br/>    (req, res) =&gt; {<br/>      res.writeHead(200)<br/>      res.write(JSON.stringify({<br/>        isSecure: <!-- -->req.socket.authorized === true<br/>      }))<br/>      res.end()<br/>    }<br/>  ).listen(8080)<br/>}<br/>serve()</span></pre><p id="f9e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建一个客户端并将其保存为<code class="fe ma mb mc md b">request.js</code>:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="9ba1" class="me kx iq md b gy my mz l na nb">const http = require('http')<br/>const request = () =&gt; {<br/>  const req = http.request(<br/>    'http://localhost:8080',<br/>    (res) =&gt; {<br/>      const data = []<br/>      res.on('data', (chunk) =&gt; { data.push(chunk) })<br/>      res.on('end', () =&gt; { console.log(data.join('')) })<br/>      res.on('error', console.error)<br/>    }<br/>  )<br/>  req.end()<br/>}<br/>request()</span></pre><p id="3299" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试文件是否有效。在一个终端中启动服务器:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="5901" class="me kx iq md b gy my mz l na nb">node serve.js</span></pre><p id="46f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一个示例中，运行请求:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="2e07" class="me kx iq md b gy my mz l na nb">node request.js</span></pre><p id="1eb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该会在终端上看到服务器的响应输出:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="155a" class="me kx iq md b gy my mz l na nb">$ node request.js<br/>{"isSecure":false}</span></pre><h2 id="ef97" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">迁移到猫键</h2><p id="3230" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">以下命令需要从项目根目录运行。</p><p id="1773" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装来自NPM的CATKeys:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="6b3f" class="me kx iq md b gy my mz l na nb">npm i --save catkeys</span></pre><p id="5087" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生成服务器和客户端密钥:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="1f0d" class="me kx iq md b gy my mz l na nb">npx catkeys create-key --keydir catkeys --server<br/>npx catkeys create-key --keydir catkeys</span></pre><p id="239d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">--keydir</code> arg指定存储密钥的目录的位置。<code class="fe ma mb mc md b">--server</code> arg创建一个服务器密钥。服务器密钥总是需要首先创建，因为客户端密钥是从服务器密钥创建的。</p><p id="9aa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">名为<code class="fe ma mb mc md b">catkeys</code>的目录现在存在于您的项目根目录中，它包含两个键:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="80e2" class="me kx iq md b gy my mz l na nb">$ ls -l catkeys<br/>total 32<br/>-rw-r--r--  1 pommy  staff  5372  4 Sep 21:10 client.catkey<br/>-rw-r--r--  1 pommy  staff  7857  4 Sep 21:09 server.catkey</span></pre><p id="8663" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CATKeys是用于创建服务器和发出请求的<code class="fe ma mb mc md b">https</code>和<code class="fe ma mb mc md b">tls</code>方法的包装器。CATKeys方法的签名与Node提供的签名相同。唯一的区别是CATKeys方法是异步的。这意味着需要进行以下更改:</p><ul class=""><li id="2ead" class="nc nd iq ka b kb kc kf kg kj ne kn nf kr ng kv nh ni nj nk bi translated"><code class="fe ma mb mc md b">https</code>应该从<code class="fe ma mb mc md b">catkeys</code>库中导入</li><li id="c184" class="nc nd iq ka b kb nl kf nm kj nn kn no kr np kv nh ni nj nk bi translated"><code class="fe ma mb mc md b">await</code>应与CATKeys方法一起使用</li><li id="d5c6" class="nc nd iq ka b kb nl kf nm kj nn kn no kr np kv nh ni nj nk bi translated">封闭函数应该使用<code class="fe ma mb mc md b">async</code></li></ul><p id="7900" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">做出这些更改后，<code class="fe ma mb mc md b">serve.js</code>现在看起来像这样:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="9a47" class="me kx iq md b gy my mz l na nb">const { https } = require('catkeys')<br/>const serve = async () =&gt; {<br/>  (await https.createServer(<br/>    (req, res) =&gt; {<br/>      res.writeHead(200)<br/>      res.write(JSON.stringify({<br/>        isSecure: <!-- -->req.socket.authorized === true<br/>      <!-- -->}))<br/>      res.end()<br/>    }<br/>  )).listen(8080)<br/>}</span><span id="ec41" class="me kx iq md b gy nq mz l na nb">serve()</span></pre><p id="f39b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ma mb mc md b">request.js</code>中，URL方案也需要从<code class="fe ma mb mc md b">http</code>变为<code class="fe ma mb mc md b">https</code>。</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="4375" class="me kx iq md b gy my mz l na nb">const { https } = require('catkeys')<br/>const request = async () =&gt; {<br/>  const req = await https.request(<br/>    'https://localhost:8080',<br/>    (res) =&gt; {<br/>      const data = []<br/>      res.on('data', (chunk) =&gt; { data.push(chunk) })<br/>      res.on('end', () =&gt; { console.log(data.join('')) })<br/>      res.on('error', console.error)<br/>    }<br/>  )<br/>  req.end()<br/>}<br/>request()</span></pre><p id="0cf4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们重新启动服务器，再次运行客户机请求:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="6ef5" class="me kx iq md b gy my mz l na nb">$ node request.js<br/>{"isSecure":true}</span></pre><p id="3431" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当服务器运行时，我们可以使用<code class="fe ma mb mc md b">curl</code>验证服务器是否需要客户端证书:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="d1fd" class="me kx iq md b gy my mz l na nb">$ curl --insecure <a class="ae lz" href="https://localhost:8080/" rel="noopener ugc nofollow" target="_blank">https://localhost:8080/</a><br/>curl: (56) OpenSSL SSL_read: error:1409445C:SSL routines:ssl3_read_bytes:tlsv13 alert <strong class="md ir">certificate required</strong>, errno 0</span></pre><p id="0581" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前客户端能够连接到服务器，因为<code class="fe ma mb mc md b">server.js</code>和<code class="fe ma mb mc md b">request.js</code>共享项目根目录中的同一个<code class="fe ma mb mc md b">catkeys</code>目录。如果它们运行在不同的服务器上，您需要在客户端的项目根目录中创建一个<code class="fe ma mb mc md b">catkeys</code>目录，并将<code class="fe ma mb mc md b">catkeys/client.catkey</code>文件从服务器复制到其中。</p><h2 id="f3a8" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">服务器主机名</h2><p id="98c0" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">TLS证书通常包含主机名。当客户端连接到服务器时，会将服务器的主机名与其证书中的common和alt名称进行比较，如果它们不匹配，则会引发错误。</p><p id="2f0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CATKeys使用稍微不同的方法。CATKeys希望服务器证书包含一个为服务器密钥保留的特殊通用主机名。这意味着服务器的主机名可以更改，并且不会影响证书的有效性。使用存储在客户端密钥中的CA安全地验证服务器的身份。</p><p id="df8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要看到这种效果，尝试将<code class="fe ma mb mc md b">request.js</code>中的主机名从<code class="fe ma mb mc md b">localhost</code>更改为<code class="fe ma mb mc md b">127.0.0.1</code>，并重复请求。</p><p id="8e37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您希望将密钥限制在特定的主机名上使用，您可以通过使用带有<code class="fe ma mb mc md b">create-keys</code>命令的arg <code class="fe ma mb mc md b">--name</code>来生成带有主机名的服务器密钥:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="c7ab" class="me kx iq md b gy my mz l na nb">npx catkeys create-key -k catkeys -s --update --name example.com</span></pre><p id="3767" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你只能在<code class="fe ma mb mc md b">example.com</code>上主持这个键了。以任何其他名称托管服务器将导致客户端在连接时抛出错误。如果您重启服务器并运行客户机请求，您将得到一个类型为<code class="fe ma mb mc md b">ERR_TLS_CERT_ALTNAME_INVALID</code>的错误。</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="5e9d" class="me kx iq md b gy my mz l na nb">$ node request.js<br/>events.js:288<br/>      throw er; // Unhandled 'error' event<br/>      ^<br/>Error [ERR_TLS_CERT_ALTNAME_INVALID]: Hostname/IP does not match certificate's altnames: IP: 127.0.0.1 is not in the cert's list:</span></pre><p id="3a2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要从服务器密钥的主机名中删除<code class="fe ma mb mc md b">example.com</code>，请再次更新密钥并删除<code class="fe ma mb mc md b">--name</code>参数:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="d948" class="me kx iq md b gy my mz l na nb">npx catkeys create-key -k catkeys -s --update</span></pre><p id="6a8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想要告诉客户端拒绝通常出现在服务器密钥中的特殊的、通用的主机名，并且只连接到具有与其主机名匹配的证书的服务器，您可以提供选项<code class="fe ma mb mc md b">catRejectMismatchedHostname: true</code>:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="c11a" class="me kx iq md b gy my mz l na nb">const req = await https.request(<br/>  'https://localhost:8080',<br/>  { catRejectMismatchedHostname: true },<br/>  (res) =&gt; { ... }<br/>)</span></pre><h2 id="54f8" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">客户名称</h2><p id="aff9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">默认情况下，客户端密钥被命名为<code class="fe ma mb mc md b">client</code>。如果愿意，您可以在多个客户端之间共享一个客户端密钥。或者您可以创建几个密钥来区分不同的客户端。</p><p id="7f80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建具有特定名称的客户端密钥，请将<code class="fe ma mb mc md b">--name</code>传递给<code class="fe ma mb mc md b">create-key</code>命令:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="8ab7" class="me kx iq md b gy my mz l na nb">npx catkeys create-key --keydir catkeys --name client-key-2</span></pre><p id="143e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果只有一个客户端密钥，则CATKeys将始终使用该密钥进行连接。如果超过1个，您将需要定义连接时使用哪个密钥:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="6583" class="me kx iq md b gy my mz l na nb">const req1 = await https.request(<br/>  'https://host1.example.com/',<br/>  { <strong class="md ir">catKey: 'client'</strong> }<br/>  (res) =&gt; { ... }<br/>)<br/>const req2 = await https.request(<br/>  'https://host2.example.com/',<br/>  { <strong class="md ir">catKey: 'client-key-2'</strong> }<br/>  (res) =&gt; { ... }<br/>)</span></pre><h2 id="1994" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">访问客户端名称</h2><p id="e084" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设您想基于客户机的名称实现某种访问控制，或者您可能只想记录连接到服务器的客户机的名称。您可以通过在服务器上的请求处理器中使用<code class="fe ma mb mc md b">req.connection.getPeerCertificate()</code>访问证书来获得客户端的名称:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="224c" class="me kx iq md b gy my mz l na nb">(await https.createServer(<br/>  (req, res) =&gt; {<br/>    const clientCert = req.connection.getPeerCertificate()<br/>    console.log('Connection from client: ' + clientCert.subject.CN)<br/>    ...<br/>  }<br/>)).listen(8080)</span></pre><h2 id="092b" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">撤销客户端的访问权限</h2><p id="0fa1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">有两种方法可以取消对客户端的访问。</p><p id="ed3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果在您的<code class="fe ma mb mc md b">catkeys</code>目录中仍然可以访问您想要撤销的客户端密钥，您可以使用<code class="fe ma mb mc md b">revoke-key</code> cli命令撤销该密钥。</p><p id="6921" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果您创建了一个名为<code class="fe ma mb mc md b">client-to-revoke</code>的键，如下所示:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="4918" class="me kx iq md b gy my mz l na nb">npx catkeys create-key --keydir catkeys --name client-to-revoke</span></pre><p id="af76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么你可以像这样撤销它:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="aa67" class="me kx iq md b gy my mz l na nb">npx catkeys revoke-key --keydir catkeys --name client-to-revoke</span></pre><p id="1864" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有当您有权访问客户端密钥时，才能使用<code class="fe ma mb mc md b">revoke-key</code> cli命令。如果您不再拥有对客户端密钥的访问权，那么您可以通过在调用<code class="fe ma mb mc md b">createServer()</code>时传递选项<code class="fe ma mb mc md b">catCheckKeyExists: true</code>来限制对存在于<code class="fe ma mb mc md b">catkeys</code>目录中的密钥的访问，从而有效地撤销它:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="0e66" class="me kx iq md b gy my mz l na nb">(await https.createServer(<br/>  { catCheckKeyExists: true },<br/>  (req, res) =&gt; {<br/>    ...<br/>  }<br/>)).listen(8080)</span></pre><p id="e39b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CATKeys将检查Keys目录以查看客户端密钥是否存在。删除客户端密钥将撤销访问权限。如果密钥不在磁盘上，那么连接将被关闭，请求处理程序将不会被调用。</p><h2 id="0d04" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">对节点以外的服务器使用密钥</h2><p id="19b5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">CATKeys可以用于节点以外的服务器。密钥只是TAR存档，可以扩展。可以提取由ca、证书和密钥组成的，用于许多支持TLS/SSL的服务器。</p><p id="7ada" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提取我们之前创建的服务器密钥:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="b618" class="me kx iq md b gy my mz l na nb">npx catkeys extract-key catkeys/server.catkey</span></pre><p id="a2d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务器密钥已经被提取到当前目录中名为<code class="fe ma mb mc md b">server</code>的目录中。</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="e023" class="me kx iq md b gy my mz l na nb">$ ls -l server<br/>total 32<br/>-rw-r--r-- 1 pommy staff 2053 24 Feb 19:44 ca-crt.pem<br/>-rw-r--r-- 1 pommy staff 2009 24 Feb 19:44 crt.pem<br/>-rw-r--r-- 1 pommy staff 3243 24 Feb 19:44 key.pem</span></pre><p id="3c77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些文件可以在任何支持pem格式的web服务器上使用。</p><p id="416f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，Nginx可以配置为在端口8080上请求客户端证书，并代理到端口8081上的HTTP上游服务器，如下所示:</p><pre class="mq mr ms mt gt mu md mv mw aw mx bi"><span id="41f4" class="me kx iq md b gy my mz l na nb">server {<br/>  listen 8080 ssl;<br/>  ssl_certificate /path/to/server/crt.pem;<br/>  ssl_certificate_key /path/to/server/key.pem;<br/>  ssl_client_certificate /path/to/server/ca-crt.pem;<br/>  ssl_verify_client on;<br/>  location / {<br/>    proxy_pass <a class="ae lz" href="http://localhost:8081;" rel="noopener ugc nofollow" target="_blank">http://localhost:8081;</a><br/>  }<br/>}</span></pre><blockquote class="nr ns nt"><p id="60c4" class="jy jz nu ka b kb kc kd ke kf kg kh ki nv kk kl km nw ko kp kq nx ks kt ku kv ij bi translated"><em class="iq"> ⚠️这个</em> <code class="fe ma mb mc md b"><em class="iq">ssl_verify_client on;</em></code> <em class="iq">很重要。它使用</em> <code class="fe ma mb mc md b"><em class="iq">ssl_client_certificate</em></code> <em class="iq">中指定的证书验证客户端，并拒绝验证失败的客户端。</em></p></blockquote><p id="26fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为TLS连接是在服务器端终止的，所以您不能使用选项<code class="fe ma mb mc md b">catCheckKeyExists: true</code>来拒绝磁盘上没有密钥的客户端。</p><h2 id="ba42" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">坦克激光瞄准镜（Tank Laser-Sight的缩写）</h2><p id="055e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们只介绍了HTTPS，但是CATKeys也可以支持通过TLS升级的套接字进行通信。这对于实时通信很有用。</p><p id="7df5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用<code class="fe ma mb mc md b">const { tls } = require('catkeys')</code>导入<code class="fe ma mb mc md b">tls</code>模块。我不打算深入研究如何使用<code class="fe ma mb mc md b">tls.createServer()</code>和<code class="fe ma mb mc md b">tls.connect()</code>，因为它们与Node的<code class="fe ma mb mc md b">tls</code>模块中的<code class="fe ma mb mc md b">tls.createServer()</code>和<code class="fe ma mb mc md b">tls.connect()</code>具有相同的签名(区别也在于它们是<code class="fe ma mb mc md b">async</code>方法),并且可以使用我们在<code class="fe ma mb mc md b">https.createServer()</code>和<code class="fe ma mb mc md b">https.request()</code>中看到的相同的<code class="fe ma mb mc md b">cat*</code>选项。</p><p id="b410" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CATKeys文档包括创建<a class="ae lz" href="https://github.com/93million/catkeys/tree/master/examples/tls" rel="noopener ugc nofollow" target="_blank">普通TLS服务器和客户端</a>的示例，以及与JsonSocket 一起使用的<a class="ae lz" href="https://github.com/93million/catkeys/tree/master/examples/json-socket" rel="noopener ugc nofollow" target="_blank">——允许使用JSON通过TLS连接发送结构化数据。</a></p><h2 id="7f3d" class="me kx iq bd ky mf mg dn lc mh mi dp lg kj mj mk lk kn ml mm lo kr mn mo ls mp bi translated">为什么是另一个安全库？</h2><p id="f05c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">对于那些想知道新东西有什么意义的人来说，CATKeys并没有真正发明任何新东西。Node长期以来一直支持客户端认证的TLS，并且许多可以用作反向代理的web服务器(Nginx、HAProxy、Apache)都支持它。安全性由TLS协议处理——cat keys只是作为一个实用程序来创建和打包密钥以便于分发，此外它还包括一组用于加载这些密钥的包装方法。</p><h1 id="dad2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">有什么问题吗？</h1><p id="c1a7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">希望这能让您了解如何使用CATKeys实现客户端认证的TLS。我错过了什么或者让你困惑了吗？不要犹豫，在评论中提出问题和建议。</p></div></div>    
</body>
</html>