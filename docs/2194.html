<html>
<head>
<title>Microservice — How &amp; Why</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务—方式和原因</h1>
<blockquote>原文：<a href="https://itnext.io/microservice-how-why-cc40ca95d9f0?source=collection_archive---------3-----------------------#2019-04-14">https://itnext.io/microservice-how-why-cc40ca95d9f0?source=collection_archive---------3-----------------------#2019-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="db21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">微服务是当今行业的热词。几乎每个人都想将他们的系统迁移到基于微服务的架构，这样他们就可以用它创造奇迹。但是，在我们开始之前，我们应该停下来想一想。我们只是在随大流吗？这对我的产品有帮助吗？最重要的是，我们真的要转向微服务了吗——还是只是把一个正常工作的企业搞乱了？</p><p id="4af0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">微服务背后的所有炒作都是有充分理由的。但是，只有当我们能够真正理解本质并将其应用到我们的架构中时，它才有意义——而不仅仅是语法。在云上部署、分成小部分或者仅仅使用Spring Boot和Dockers都不能构成微服务架构。</p><p id="c756" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，什么才是好的微服务架构呢？要理解这一点，必须理解微服务架构的核心原则。我们必须了解为什么要引入微服务，以及我们试图用微服务解决什么问题。然后我们可以自省，了解我们的架构是否真的解决了这些问题。</p><p id="65be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个博客可以给你一个微服务背后的几个关键原则的简要概述。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/40c2d70982fae485388f7b60cc633bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zl__wc7P74yl6E-x_ZtU2Q.jpeg"/></div></div></figure><h1 id="b5a9" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">微服务</h1><p id="9fa7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">引入微服务是为了实现快速灵活的变化。在真正基于微服务的架构中，我们应该能够用增强版本更新和替换任何服务，而不会影响其他服务；任何用户故事的改变应该只影响一个微服务。我们到了吗？</p><p id="914a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了实现这一点，该体系结构应遵循以下原则:</p><h2 id="9662" class="md lb it bd lc me mf dn lg mg mh dp lk kb mi mj lo kf mk ml ls kj mm mn lw mo bi translated">1.单一业务功能</h2><p id="a98a" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">微服务应该实现单一的业务功能。现在，“单一业务功能”是一个模糊的短语。对于一个局外人来说，制作一部电影是一个单一的商业职能。对于一个内部人员来说，这是一项涉及各种不同任务的巨大努力。</p><p id="83e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">任何业务功能都是相当相似的。那么，我们如何决定“单一业务功能”对单一专用微服务的需求是否正确呢？当我们在企业应用程序上工作时，这是一个常见的设计问题——我们有各种各样的功能。任何函数都希望其他函数在黑盒中出现。但是，它们都太大，无法集成到单个微服务中。</p><p id="cfce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种问题的典型解决方案是一个树形结构——其中一个微服务作为一个微服务块的网关，微服务块可以进一步分裂。这种模块化应该继续分裂，直到一行代码。在一个设计良好的代码中，任何一行代码都应该包含该功能的一个独特方面。</p><p id="d6b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们有另一个问题！当然，我们不能继续将我们的微服务分割到那种程度。我们什么时候停止拆分微服务？<br/>理想情况下，微服务应该定义一个可以独立于其他服务而改变的功能。如果我们注意到几个微服务总是一起变化，我们应该知道我们搞砸了。</p><p id="d23d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们注意到几乎每个变化都有微服务变化；它只通过改变一小部分代码来改变——我们又搞砸了。</p><h2 id="c725" class="md lb it bd lc me mf dn lg mg mh dp lk kb mi mj lo kf mk ml ls kj mm mn lw mo bi translated">2.快速故障和安全故障</h2><p id="3f1b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如果微服务遇到问题，它应该很快意识到这一点，并且应该优雅地失败——而不会使系统崩溃。如果我们的问题沿着几个微服务级联，这意味着我们的设计有问题。</p><p id="d14c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理想情况下，我们的微服务应该以这样一种方式进行布局，即一个服务可以包含一个问题。但这并不意味着微服务试图掩盖其问题。如果它不能完成自己的工作，它就失败了。它很快就失效了。它作为服务是失败的。并且，系统的其余部分应该能够考虑这个问题。</p><p id="802b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，问题不是异常，它只是我们的代码设计处理的另一种情况。现在，如果微服务处理大量功能，它将有许多失败的原因。失败会影响许多不应该影响的功能。</p><p id="e464" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，如果微服务太薄，我们将有许多微服务因为一个问题而失败。无论哪种情况，我们都搞砸了。</p><h2 id="7f53" class="md lb it bd lc me mf dn lg mg mh dp lk kb mi mj lo kf mk ml ls kj mm mn lw mo bi translated">3.松散耦合</h2><p id="6b35" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">像大多数设计概念一样，这也是一个模糊的短语。“松”有多松？我们怎么知道自己够宽松？在真正意义上，松散耦合的服务应该在发现时进行通信，而不是在调用时进行通信。理想情况下，一对松散耦合的微服务不应该共享一行代码。</p><p id="bb14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这在现实生活中不会发生。如果在Spring Boot开发两个微服务，它们自然会共享弹簧罐。这很好，因为两个微服务都不希望对方使用它。按照设计，每个微服务在代码上应该是独立的。</p><p id="dc57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不共享代码并不意味着微服务之间的代码重复。重点是，两个微服务不应该需要相同的代码。如果我们注意到代码的重复，我们应该知道我们的设计是错误的。从真正的意义上来说，松耦合意味着基于功能和标准的耦合，而不是相互认可的接口。因此，我们可以看到典型的微服务使用REST API进行通信。它们使用基于功能的发现进行通信，而不是直接调用。</p><p id="535c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种“松散”耦合是有代价的——将特定于实现的数据结构转换成标准外部API的代价。微服务太多，不可能有这么松的耦合。即使我们能做到，那也会使我们的许多代码忙于这种翻译，而不是致力于真正的功能。</p><p id="a2d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，如果我们只有很少的几块，我们就会有一堆乱七八糟的巨石——这违背了我们的目的。因此，确定一组能够独立协作的最佳微服务非常重要。</p><h2 id="abf7" class="md lb it bd lc me mf dn lg mg mh dp lk kb mi mj lo kf mk ml ls kj mm mn lw mo bi translated">4.抽象和独立</h2><p id="0c56" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这不仅限于微服务。抽象可能是任何设计中最重要的方面。无论我们使用什么样的架构模式，抽象在一个好的设计中是必不可少的。</p><p id="8da5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">抽象到底是什么？按照抽象原则，任何代码单元都应该完成自己的工作，而不需要依赖于它是如何完成工作的。<br/>这是什么意思？考虑简单的System.out.println()。我们需要研究它是如何工作的吗？我们知道它是什么，但不知道它是如何做到的。任何设计良好的代码块都应该输出“什么”而不是“如何”。</p><p id="c025" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们需要研究功能是如何实现的，这意味着功能没有很好地实现。随着模块规模的增加，这变得越来越重要。随着模块规模的增加,“做什么”和“如何做”之间的差距也在增加。</p><p id="d020" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用户验证服务应该验证用户并返回是或否。其他人不应该关心它是如何做到这一点的。它可能使用关系数据库或基于文档的数据库，或者只是一个平面文件。它可能使用Java或Python或JavaScript——或者只是汇编代码！系统的其余部分不应该依赖于这些方面中的任何一个。它应该只是遵循定义的接口。</p><p id="bc9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有发生这种情况，如果一个微服务依赖于另一个微服务如何完成它的工作，这意味着该微服务没有抽象功能。这意味着它们不是独立的，设计是混乱的。</p><h2 id="5115" class="md lb it bd lc me mf dn lg mg mh dp lk kb mi mj lo kf mk ml ls kj mm mn lw mo bi translated">5.独立的CI/CD和集群</h2><p id="cd17" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在大型企业中，每项服务都以不同的速度发展。如果系统设计得很好，大多数的改变都局限于很少的服务。正因为如此，一项服务的改变不应该要求我们去接触其他服务。只有当我们为每个微服务提供独立的CI/CD时，这才有可能实现。</p><p id="0859" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，每个微服务都有自己的负载模式。随着企业的扩展，一些服务保持相同的负载，而另一些服务增长非常快。如果我们把它们放在一起，就会导致某些服务的能力过剩，或者其他服务的匮乏。</p></div></div>    
</body>
</html>