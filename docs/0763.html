<html>
<head>
<title>How to stub requests to remote hosts with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Go向远程主机发送存根请求</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-stub-requests-to-remote-hosts-with-go-6c2c1db32bf2?source=collection_archive---------1-----------------------#2018-05-23">https://itnext.io/how-to-stub-requests-to-remote-hosts-with-go-6c2c1db32bf2?source=collection_archive---------1-----------------------#2018-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a1637d1dcffbdcf46b8c279edaf8c696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKQYXpCYnBC1PtV7dJUegA.png"/></div></div></figure><p id="8d79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用客户端为某个API创建一个包时，用测试覆盖它是很关键的，特别是如果你想把这个包放到<em class="kw"> GitHub </em>上供公众使用，因为新版本中的bug会给在生产环境中使用它的项目带来可悲的后果。在公开软件包之后，你的工作是跟踪它的可靠性和兼容性，使它可供其他人使用。</p><p id="505f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试有助于代码<strong class="ka ir">的可维护性</strong>，所以当其他用户用他们所做的更改创建拉请求时，你总是会看到是否有什么地方出错了，并确保代码仍然<strong class="ka ir">可靠</strong>，尤其是当你使用一些集成了<em class="kw"> GitHub </em>的CI工具时，比如<em class="kw">特拉维斯</em>、<em class="kw">信号量</em>或<em class="kw">詹金斯</em>。</p><p id="255e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我浏览了各种实现API客户端的包，注意到它们缺少测试，尽管这些代码很容易通过<em class="kw">向远程主机发送</em>请求来测试。所以我决定分享我如何测试我的客户。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="e532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码定义了一个客户端，它能够从远程服务器接收用户列表，请求通过<code class="fe ld le lf lg b">http.Client</code>发生，通过用自定义<code class="fe ld le lf lg b">http.Transport</code>重新定义它的<code class="fe ld le lf lg b">Transport</code>属性，我们可以将客户端发出的所有请求重定向到另一个假服务器，我们可以使用<code class="fe ld le lf lg b">httptest.NewServer</code>工厂创建这个假服务器，并返回我们需要的响应。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="a570" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的函数接收<code class="fe ld le lf lg b">http.Handler</code>接口作为参数，在其中我们可以写响应体，设置状态码，或者我们从远程主机期待的任何东西——我们甚至可以检查我们发送的<em class="kw">请求。最后，该函数返回带有重新定义的<code class="fe ld le lf lg b">Transport</code>的<code class="fe ld le lf lg b">http.Client</code>，以及一个teardown函数，该函数将停止之前启动的假服务器。因此，我们有能力用<em class="kw">存根</em>请求编写一些测试。</em></p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="3f34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们的库将在其他包中使用，所以让其他包能够更改<code class="fe ld le lf lg b">httpClient</code>属性也是很好的，因为它可能会在集成测试中使用，例如，如果我们的客户端将作为依赖项被注入。你可以简单地通过将<code class="fe ld le lf lg b">httpClient *http.Client</code>属性重命名为<code class="fe ld le lf lg b">HTTPClient *http.Client</code>来公开它，或者通过为客户端添加<code class="fe ld le lf lg b">func(cli *Client) SetHTTPClient(httpClient *http.Client)</code>方法来实现，但就个人而言，我更喜欢使用<a class="ae lh" href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" rel="noopener ugc nofollow" target="_blank">功能选项</a>，因为它是一个非常强大的工具。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="6896" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的例子可以在<a class="ae lh" href="https://github.com/romanyx/api_client_testing" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>