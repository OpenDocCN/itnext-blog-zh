<html>
<head>
<title>How to use Terraform to create a small-scale Cloud Infrastructure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Terraform创建小规模云基础架构</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-terraform-to-create-a-small-scale-cloud-infrastructure-abf54fabc9dd?source=collection_archive---------0-----------------------#2021-04-16">https://itnext.io/how-to-use-terraform-to-create-a-small-scale-cloud-infrastructure-abf54fabc9dd?source=collection_archive---------0-----------------------#2021-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/00eed845b8da0ee6fb046f65d9ad7b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*rmwpOy4OtvgVz3yJvBetuQ.png"/></div></figure><h1 id="41cb" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">介绍</h1><p id="237f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">本教程给出并描述了如何使用软件Terraform创建各种类型的云基础设施的说明，即基础设施即服务(IaaS)、平台即服务(PaaS)和软件即服务(SaaS)，并使用这些方法来帮助读者了解更多关于Terraform和云技术的使用。</p><p id="b069" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本教程文档将为任何不了解Terraform和一些云技术，但有兴趣在小规模测试环境中学习更多相关知识的人提供一步一步的指导。</p><p id="c02d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本教程主要面向IT学生，将只提供安装、配置和使用Terraform所需的最相关的知识，以及侧重于实际解决方案和基准测试的用例。所有这些都要记住，它应该保持对读者的可访问性，以及在学习Terraform时要遵循的直观步骤。</p><p id="5b8f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">如前所述，本指南将涵盖三种类型的云。这将通过使用虚拟机管理程序和服务提供商来实现。本指南将使用以下三个应用程序编程接口:</p><p id="94db" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.面向IaaS的基于内核的虚拟机(KVM)管理程序</p><p id="8a35" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.面向PaaS的Docker容器平台</p><p id="97fe" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.SaaS的Azure云服务提供商</p><p id="29e6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">目录</strong></p><p id="4e33" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.<a class="ae lv" href="#41cb" rel="noopener ugc nofollow">简介</a></p><p id="95a1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.<a class="ae lv" href="#1795" rel="noopener ugc nofollow">语境</a></p><p id="8563" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第2章将提供所有使用的软件的背景。这将描述一些关于Terraform和服务提供商的信息，这些信息将用于创建小规模的云基础架构。此外，关于云技术和编排软件的解释将在这里找到。</p><p id="c6d6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.<a class="ae lv" href="#7292" rel="noopener ugc nofollow">先决条件</a></p><p id="ba77" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">将描述一些硬件要求，其中一些是复制指令的先决条件，一些是使某些任务更容易完成的建议。</p><p id="59c8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.<a class="ae lv" href="#d791" rel="noopener ugc nofollow">下载并安装Terraform </a></p><p id="c420" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">给出了在您的系统上安装Terraform的必要说明。在我们的例子中，我们使用的是Ubuntu 18.04。</p><p id="dd08" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.<a class="ae lv" href="#ab32" rel="noopener ugc nofollow">创建您的第一个Terraform项目</a></p><p id="0f54" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本章是一个简单的配置示例，打印“hello world”来验证安装。此外，这里将讨论更多关于Terraform语法的用法和资源生命周期管理的功能。</p><p id="ec24" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.<a class="ae lv" href="#407c" rel="noopener ugc nofollow">为libvirt安装KVM和terra form provider</a></p><p id="5fce" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">7.<a class="ae lv" href="#e6ed" rel="noopener ugc nofollow">使用Terraform和KVM创建虚拟机</a></p><p id="3453" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">8.<a class="ae lv" href="#73cd" rel="noopener ugc nofollow">供应和编排</a></p><p id="934e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第6章到第8章介绍了通过Terraform libvirt provider使用Linux KVM hypervisor部署一个示例SaaS项目“PiCalc”。此示例还演示了使用多个虚拟机实现负载平衡的方法。</p><p id="9639" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">9.<a class="ae lv" href="#debd" rel="noopener ugc nofollow">为docker安装Docker和Terraform provider】</a></p><p id="7d84" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第9章将介绍docker provider插件的安装，该插件是使用Go从源代码中构建的。</p><p id="1626" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">10.<a class="ae lv" href="#6a3a" rel="noopener ugc nofollow">使用Terraform部署Docker示例</a></p><p id="577a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第10章演示了通过Docker provider提供的容器中示例项目的部署。</p><p id="c24d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">11.<a class="ae lv" href="#8c22" rel="noopener ugc nofollow">为Windows安装Azure CLI和Terraform】</a></p><p id="7f8f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">12.<a class="ae lv" href="#9c85" rel="noopener ugc nofollow">使用Terraform在Microsoft Azure上提供功能应用</a></p><p id="4c5f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第11到12章将介绍官方平台Azure提供者的安装和使用。本章旨在展示Terraform提供的远程配置功能，其中相同的典型项目将作为功能应用程序进行部署。</p><p id="bd01" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">13.<a class="ae lv" href="#bf8f" rel="noopener ugc nofollow">故障排除</a></p><p id="0363" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">14.<a class="ae lv" href="#646c" rel="noopener ugc nofollow">参考书目</a></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1795" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">语境</h1><p id="e079" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><p id="8aec" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本章将介绍本指南中使用的软件。本章的目标是提供关于软件的基本信息以及云技术的一般含义。所描述的软件主要用于创建和供应虚拟机和容器。在本指南中，它们将用于演示Terraform的一些功能和能力。</p><p id="2624" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">云技术<br/></strong></p><p id="afeb" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">如<em class="mi">中所述。T21格兰斯。t，云计算的NIST定义p2–3”，2011a) </em>云计算的定义是:</p><p id="ce32" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><em class="mi">云计算是一种支持对可配置计算资源(例如，网络、服务器、存储、应用程序和服务)的共享池进行无处不在、方便、按需的网络访问的模型，可配置计算资源可通过最少的管理工作或服务提供商交互来快速供应和发布。这个云模型由五个基本特征、三个服务模型和四个部署模型组成。</em></p><p id="bbbf" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">这需要从存储和计算服务到数据库、网络、软件和分析服务<em class="mi">(“微软——什么是云计算”，2019a) </em>。<br/>这些技术可以通过灵活的按需服务流提供给用户/客户。<br/>像这样的技术需要技术配置才能实现功能，并且可以根据特定需求进行精确设置。组合和配置云技术将产生一个功能齐全的云基础设施，最终服务于客户/用户。</p><p id="4805" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">作为未来的系统工程师，您将在通过配置实现云基础设施的过程中扮演重要角色。</p><p id="7653" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir"> Terraform <br/> </strong> Terraform是一款软件，可以帮助用户使用代码<em class="mi">(“hashi corp，Introduction — Terraform”，2019a) </em>。这可以在许多流行的云服务上完成，如亚马逊Web服务或微软Azure服务。然后，可以在选择的服务上构建和管理不同类型的云基础架构。</p><p id="1f9c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">Terraform可以使用所谓的“<em class="mi"> Provider </em>”插件与各种API进行交互。这些提供者是Terraform和上述API之间的中间人。Terraform可用于管理所述API的各种创建的'<em class="mi">资源'</em>'的生命周期。资源可以是所有类型的虚拟设备，但也可以是简单的文件或目录。在下图(图1)中，可以找到Terraform软件的插图，其目的是显示提供商与其资源之间的关系，以及Terraform如何管理生命周期以及这些资源的创建和销毁。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/69f4c0296c5ed5df716f18242cb59600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/0*Ws98EnopXc101FQK"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><em class="ms">图1 — Terraform软件基于:(“HashiCorp，带Armon Dadgar的HashiCorp Terraform简介”，2018a) </em></figcaption></figure><p id="2ed2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">为了运行Terraform软件，执行命令<strong class="ku ir"> <em class="mi"> terraform init </em> </strong>。该命令将在当前目录中搜索Terraform配置文件并读取它们。这些文件的扩展名是。tf。根据配置，它将搜索所使用的提供者。如前所述，Terraform可用于管理资源。Terraform可以通过创建一个资源树来实现这一点，该树描述了它们所依赖的资源。该树是在调用命令<strong class="ku ir"> <em class="mi">地形图</em> </strong>时创建的。该命令的结果是对基础设施中将改变(创建或破坏)什么地形的描述。这棵树保存在目录<strong class="ku ir">中<em class="mi"> terraform init </em>中</strong>是调用自，否则表示当前目录。要应用更改，使用命令<strong class="ku ir"> <em class="mi">地形应用</em> </strong>。这将把配置发送给相应的提供者，以创建代码中定义的资源。然后，用户可以决定他想要在基础设施中改变什么，主要是通过添加代码，并再次运行<em class="mi"> terraform apply </em>命令。移除一个基础设施<strong class="ku ir"> <em class="mi">可以称为摧毁</em> </strong>。当某个资源要从基础结构中完全删除，或者需要进行重大更改时，这是一个要求。</p><p id="c4ff" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">用户可以对Terraform必须构建和管理的基础设施进行编程。这些配置可以用两种格式编写:HashiCorp配置语言(HCL)或JavaScript对象符号(JSON)。HCL是HashiCorp创建的语言，它对机器友好，但易于人类阅读，并将在本文档中使用。它深受nginx类型配置<em class="mi">(“HashiCorp，README.md — HCL是hashi corp配置语言”，2019b) </em>。</p><p id="8087" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">Terraform主要从命令行使用，也有可能从GUI运行Terraform。但是这些仍处于早期阶段，还不是很容易获得。Terraform的一个示例GUI工具是Terraform UI<em class="mi">(“glitter labs，terra form UI”，2019a) </em>。</p><p id="50af" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">基于内核的虚拟机(KVM)，QEMU和Libvirt <br/> </strong> KVM是一个面向Linux系统的开源虚拟化系统<em class="mi">(“red hat，KVM是什么？”，2019a) </em>。它是一个虚拟机管理程序，可用于创建虚拟化的硬件加速虚拟机。它可以使用内置的QEMU硬件仿真器来仿真处理器，从而实现这一点。QEMU和KVM都使用配置语言XML进行配置，<em class="mi">(“lib virt，KVM/QEMU hypervisor driver”，2019a) </em>当必须配置许多虚拟设备时，这可能会成为一项繁琐的任务。通常，KVM/QEMU与一个名为libvirt的虚拟化库一起使用。Libvirt是一个应用程序用户界面，可用于管理KVM，并可从所有类型的编程语言(如Python、C#、Go和许多其他语言)访问。它的一个非常有用的工具是命令行界面，称为“virsh”<em class="mi">(“lib virt，虚拟化API”，2019b) </em>。该工具用于从命令行调用libvirt API。</p><p id="0cb9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">Terraform-provider-lib virt<br/>terra form-provider-lib virt是terra form的提供者，用于为虚拟机创建资源。提供者由Duncan Mac-Vicar P开发，该软件可在Github<em class="mi">(“Duncan Mac-Vicar p .，dmacvicar/terraform-provider-lib virt”，2019a) </em>。使用terraform-provider-libvirt插件，可以从terraform代码中访问libvirt库，并用于创建和管理各种虚拟机及其计算资源。</p><p id="44b1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir"> Docker <br/> </strong> Docker是一款在操作系统级虚拟化上提供平台即服务软件的软件。可视化实例被称为容器，基本上是多个软件库和依赖项的包，以便应用程序可以在不同的环境中可靠地运行<em class="mi">(“Docker，什么是容器？”，2019a) </em>。许多流行的组织利用容器来完成不同类型的任务。这主要是因为docker容器非常轻量级，将减少基础设施所需的管理和开发量<em class="mi">(“Docker，为什么是Docker？”，2019b)。</em>一个例子是PayPal使用容器管理每秒需要处理的200笔交易<em class="mi">(“Docker，PayPal与Docker Enterprise的用例”，2019c) </em>。</p><p id="b9c9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">Terraform-Provider-docker<br/></strong>面向docker的terra form提供商使用Docker API来管理容器的图像、网络和生命周期<em class="mi">(“哈希公司，Docker提供商”，2019c) </em>。此外，可以在代码中使用docker编排平台docker swarm来创建docker服务和多个容器池。这些服务可用于部署易于扩展、更新或替换的应用服务。可以在GitHub中找到这个提供者，它是由Terraform社区开发的。</p><p id="7b27" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir"> Azure <br/> </strong>微软Azure是众所周知的云计算服务。它提供不同云服务的使用，包括那些用于计算、分析、存储和网络的服务<em class="mi">(“微软，什么是Azure”，2019b) </em>。我们主要通过Azure来使用它，因为可以创建一个学生帐户。学生可以使用“Azure for Students”，他们将获得€100，000信用点来购买Azure资源。</p><p id="92a9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">terra form-Provider-Azure m<br/></strong>terra form微软Azure provider使得在你的订阅内部署和更改资源成为可能<em class="mi">(“HaschiCorp，Azure Provider”，2019d) </em>。运行Terraform时，将自动下载该提供程序。它不是像libvirt那样的第三方提供程序，提供程序必须单独下载。提供者可以通过使用名为Azure CLI的工具进行身份验证来访问Azure用户<em class="mi">(“HaschiCorp，Azure Provider:Authenticating using the Azure CLI”，2019e) </em>。</p><p id="d285" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">示例架构<br/> </strong>为了说明我们将在本教程中使用的所有提供者的有用比较和概述，本教程中显示了各种架构图，以给出理论示例。此外，虚拟化和地形的基础知识也将得到阐述。</p><p id="9078" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">这些图是通过由开放组架构框架<em class="mi">(“开放组，欢迎使用ArchiMate 3.0.1规范，一个开放组标准”，2019a) </em>提供的Archimate建模语言创建的。这是一种开源建模语言，被世界各地的行业和大学所使用，以其通用性和易用性而闻名<em class="mi">(“开放集团，Archi开源ArchiMate建模”，2019b) </em>。</p><p id="1e54" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在第一个图(图2)中，显示了一个基本设置，其中从主机操作系统环境使用Libvirt虚拟化，从而提供KVM功能，提供更快和优化的PC硬件寻址。</p><p id="409a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">留意下面的建筑。这是一个示例架构(图2 ),说明了在主机上运行的KVM虚拟化；在本指南的上下文中，您自己的笔记本电脑或台式机。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mt"><img src="../Images/4537b3a5fb3af1cee3f195f3386b242a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*02rMYdHv1EBNjFSL"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><em class="ms">图2 —在PC上运行的基本架构KVM(由Archi制造)</em></figcaption></figure><p id="cee2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">用户(学生)使用Terraform代码在主机内创建基础设施。此代码包含创建和配置新虚拟机所需的数据。在提供者的帮助下，Terraform可以用来调用libvirt虚拟化API，Terraform可以在前面提到的terraform-provider-libvirt插件的帮助下做到这一点。然后，libvirt API将对KVM hypervisor进行函数调用，KVM hypervisor可以分配所需的资源来支持新机器。它提供了一个抽象层，机器可以在这个抽象层上运行不同种类的操作系统。虚拟系统的硬件指令通过QEMU硬件仿真器翻译。它通过转换指令来实现这一点，以便可以在不同的处理器上运行。QEMU还可以模拟各种设备，比如网络和USB。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="7292" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">3.先决条件</h1><p id="6f2a" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><p id="6ba3" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">为了能够准确地遵循本文档中描述的说明，满足本章中描述的要求非常重要。可以从下面描述的要求中推导出来，但是在本文档中找不到所用软件的其他发行版和/或版本的说明。</p><p id="16e3" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">希望读者对GNU/Linux CLI有一个基本的了解。</p><p id="1f67" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本文档中描述的指令都是在使用VMware Workstation Player 15 创建的虚拟机上进行的<strong class="ku ir">测试。在本文中，包含Terraform的虚拟机(VM)将被称为“<em class="mi">主机</em>”。在VirtualBox主机上，甚至直接在物理“裸机”主机上也应该可以遵循这些说明，但我们没有对此进行测试。在这两种情况下，无论是在物理机上运行还是在虚拟机上运行，它都将被称为"<em class="mi">主机"</em>，因为这是Terraform将在其上运行的机器。这主要是为了防止文档后面出现混乱。为了清楚起见，请注意下图(图3)。假设您的“您的电脑”是运行VMware的Linux或Windows操作系统。在VMware上，我们创建了称为“主机”的机器。我们这样命名是因为我们将使用Terraform来创建各种虚拟机或其他虚拟设备，我们将称之为“来宾机”。</strong></p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/e44f1ba1db47acdb7a06c5ff0a6b812e.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/0*NSy8wrcEea1ZhbGA"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><em class="ms">图3 —嵌套虚拟机(使用draw.io创建)</em></figcaption></figure><p id="0f39" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">主机使用的OS是<strong class="ku ir"> Ubuntu 18.04.3仿生64位</strong>。选择这个版本是因为它是Ubuntu的长期支持(LTS)发行版，并且将主要在Terraform将被长期使用时使用。另一个原因是本文中使用的许多软件包都有稳定的ubuntu版本。</p><p id="00f1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">系统规格<br/> </strong>这些是<strong class="ku ir">您的电脑的最低规格</strong>:</p><blockquote class="mz na nb"><p id="0e0f" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated">8 GB RAM <br/> 64位处理器，带4个vcore<br/>200 GB存储</p></blockquote><p id="303c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">这些是我们用于<strong class="ku ir">主机</strong>的推荐规格:</p><blockquote class="mz na nb"><p id="b6bd" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated">4 GB RAM <br/> 64位处理器，带4个vcore<br/>60gb存储</p></blockquote><p id="ba86" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">如果可能，具有更多vCores的更快CPU将显著加快Terraform工作流的速度。强制性要求是支持硬件/嵌套加速虚拟化的<strong class="ku ir">CPU</strong>(需要英特尔VT-x或AMD-V)。这需要能够在我们的主机中高效地创建新的虚拟机。<strong class="ku ir">如果指南在虚拟机内完成，则需要嵌套虚拟化</strong>。可以在裸机Ubuntu机器上测试对适当CPU指令的支持，如下所示:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="45f8" class="nk jv iq ng b gy nl nm l nn no">$ lscpu | grep Virtualization</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/37bcd14f877f397ecca1a5c30e53b476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*1zEbndIY48pwtaDa"/></div></figure><p id="5d11" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">我们的物理机(<strong class="ku ir">您的PC </strong>)基于英特尔，我们完全支持硬件加速虚拟化。AMD机器将显示AMD-V。如果物理机器不支持加速和嵌套虚拟化，则输出为空白。</p><p id="c91c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">如果您的电脑使用64位Windows 8或10</strong>，VMWare Workstation中的嵌套虚拟化应该已经可以访问。</p><p id="40db" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">如果您的PC使用GNU/Linux机器</strong>，我们必须指示物理机器上的KVM(虚拟机管理程序)为我们启用嵌套虚拟化(仅适用于VT-x或AMD-V)。确保所有其他虚拟机都已关闭，然后启用并验证支持，如下所示:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="2c4c" class="nk jv iq ng b gy nl nm l nn no">$ sudo rmmod kvm-intel &amp;&amp; sudo modprobe kvm_intel nested=1</span><span id="c302" class="nk jv iq ng b gy nq nm l nn no">$ cat /sys.module/kvm_intel/parameters</span></pre><p id="28cb" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">如果物理机有AMD CPU，用kvm_amd替换kvm_intel。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6876b605bb6b9a0cb70ba8c6f93f261f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/0*Zo7OngL_UyLXYrr3"/></div></figure><p id="0655" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">如果输出显示“Y”或“1”，则可以安全地继续使用指南</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="d791" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">4.下载和安装Terraform</h1><p id="9822" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><p id="21ef" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本章描述了如何在Linux主机系统上下载和安装Terraform。该软件将从Terraform的官方网站下载:</p><blockquote class="mz na nb"><p id="852d" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><a class="ae lv" href="http://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"><em class="iq">www.terraform.io/</em></strong></a></p></blockquote><p id="98ce" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">下载的文件是一个zip文件。要解压缩该文件，需要一个名为unzip的程序。生成的文件是一个独立的可执行文件。然后这个文件将被移动到<em class="mi"> '/usr/local/bin' </em>目录，这样程序就可以在整个系统中被广泛调用。</p><p id="fc75" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">我们还制作了第一个提供商KVM的视频。在每一章你都会找到一段视频，视频中有该章的确切链接。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2086" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.转到<a class="ae lv" href="http://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"><em class="mi">www.terraform.io/</em></strong></a>并点击下载CLI，下载用于Linux 64位的Terraform。</p><p id="4747" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.按下下载按钮后，会出现一个标签。点击保存文件。默认情况下，该文件将保存在'<em class="mi"> ~/Downloads/' </em>目录下。</p><p id="c8df" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">解压下载安装Terraform <br/> </strong>文件需要解压后才能使用。这将使用不会自动安装的unzip程序来完成。</p><p id="8a72" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.启动控制台</p><p id="e5c0" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.使用以下命令安装unzip</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4692" class="nk jv iq ng b gy nl nm l nn no">$ sudo apt install unzip</span></pre><p id="35f8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.进入下载文件夹，使用下面的命令提取下载的文件。这将在下载目录中提取一个名为terraform的可执行文件。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f20b" class="nk jv iq ng b gy nl nm l nn no">$ cd ~/Downloads/</span><span id="797e" class="nk jv iq ng b gy nq nm l nn no">$ unzip terraform_0.12.12_linux_amd64.zip</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/d415e9f32117f7dc41a09ceabf9e02a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/0*WxnboP7mkA6KOBDB"/></div></figure><p id="3adc" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">测试安装<br/> </strong>将“<em class="mi">terra form”</em>移动到一个名为<em class="mi">“/usr/local/bin”</em>的用户程序目录下。此目录是为用户安装的软件保留的。此操作将使您可以从系统中的任何目录运行Terraform。</p><p id="ff8f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.将未归档的可执行文件移动到<em class="mi"> '/usr/local/bin' </em>。这个目录是普通用户运行terraform的地方。放置<em class="mi">‘terra form’</em>可执行文件将使得从系统的任何地方调用它成为可能。这是可能的，因为目录自动具有路径导出。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4862" class="nk jv iq ng b gy nl nm l nn no">$ sudo mv terraform /usr/local/bin/terraform</span></pre><p id="7eb9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.通过运行以下命令测试terraform是否安装正确。如果输出了terraform的版本，那么这意味着可执行文件被正确链接并且可以被找到。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="8768" class="nk jv iq ng b gy nl nm l nn no">$ terraform -v</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/859e8758bba370d094573bfb81a8182c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/0*HsEqzChqmwAjRN_x"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="ab32" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">5.创建您的第一个Terraform项目</h1><p id="2798" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><p id="2f89" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本章描述了如何建立一个简单的Terraform项目，其中一个小的测试代码将用于测试Terraforms的功能。该测试配置将打印<em class="mi">‘hello world’</em>。之后，我们将通过一个管理文件的简单示例来讨论如何使用Terraform来管理基础设施。本章的目的是安装和测试Terraform，以显示它的一些代码语法和用法。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="70f2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本章描述了如何建立一个简单的Terraform项目，其中一个小的测试代码将用于测试Terraforms的功能。该测试配置将打印<em class="mi">‘hello world’</em>。之后，我们将通过一个管理文件的简单示例来讨论如何使用Terraform来管理基础设施。本章的目的是安装和测试Terraform，以显示它的一些代码语法和用法。</p><p id="240f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.创建一个新目录并进入该目录。这个目录是我们放置创建新基础设施所需的配置文件的地方。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f3eb" class="nk jv iq ng b gy nl nm l nn no">$ mkdir ~/terraform_project/</span><span id="cfcf" class="nk jv iq ng b gy nq nm l nn no">$ cd ~/terraform_project/</span></pre><p id="4784" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.使用下面的命令初始化Terraform项目。这将使terraform搜索扩展名为'<strong class="ku ir">'的配置文件。在它被调用的目录中。在这种情况下，目录为<em class="mi"> '~/terraform_project/' </em>。此外，这将在我们的工作空间中生成一些隐藏文件，Terraform将使用这些文件来保存和更改基础架构。</strong></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="c756" class="nk jv iq ng b gy nl nm l nn no">$ terraform init</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ba2967655024500ae250ed8ae44ba057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/0*dI3zpilvbc1erF7c"/></div></figure><p id="dff0" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">创建新的Terraform配置<br/>T3】本节介绍Hashicorp脚本语言的部分语法，该语言用于创建Terraform代码。将创建一个terraform配置文件，并使用该文件打印“<em class="mi"> hello world </em>”。之后，您将学习如何读取文件。这对以后加载配置文件很有用。</strong></p><p id="63e9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.进入项目，使用您最喜欢的编辑器创建一个新文件。为了让terraform识别新的配置文件，该文件必须有一个'<strong class="ku ir">。tf </strong>扩展名。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="da4e" class="nk jv iq ng b gy nl nm l nn no">$ nano test.tf</span></pre><p id="503f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.将下面的代码复制粘贴到打开的文件中并保存。请注意，该语法需要如下所示放置的花括号。这也称为范围。代码将以字符串的形式输出“文本”的值。输出后面的引号表示<em class="mi">“text”</em>可以根据用户的喜好进行修改，如果在代码中没有提前定义的话。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="3b5e" class="nk jv iq ng b gy nl nm l nn no">output “text” {<br/> value = “hello world”<br/>}</span></pre><p id="a4ab" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.初始化项目后，使用新配置运行terraform。输出应该与下面的输出相同。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="a24f" class="nk jv iq ng b gy nl nm l nn no">$ terraform apply</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/a0ff0b1c60dd5f4bf685b26495cb8503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/0*3wpcb1IMdqR_x8Nn"/></div></figure><p id="dae0" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.也可以读取文件。通过编辑<strong class="ku ir"> test.tf </strong>文件并添加下面的代码来实现。这段代码将从给定的路径中读取一个文件，并将其内容作为字符串输出。使用花括号中的<code class="fe nx ny nz ng b"><strong class="ku ir"><em class="mi">file(“/example_path/”)</em></strong> </code>函数读取内容。该函数需要路径。正如您在下面看到的，它期望我们的项目工作区中有一个文件。注意<strong class="ku ir"> <em class="mi"> ${} </em> </strong>用于调用字符串内的函数。在这种情况下，它是一个返回路径到<strong class="ku ir"> test.tf </strong>文件目录的函数。除了这些功能，请注意标签(<strong class="ku ir"> # </strong>)。这用于在代码中编写注释，在运行代码时会被否定。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="9e1b" class="nk jv iq ng b gy nl nm l nn no"># test.tf<br/>output “text” {<br/> value = file(“${path.module}/text.txt”)<br/>}</span></pre><p id="9fbd" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.保存<strong class="ku ir"> <em class="mi"> test.tf </em> </strong>文件，并创建需要读取的<strong class="ku ir"> <em class="mi"> text.txt </em> </strong>文件。确保添加文本并保存该文件。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="6709" class="nk jv iq ng b gy nl nm l nn no">$ nano ~/terraform_project/text.txt</span><span id="d9f6" class="nk jv iq ng b gy nq nm l nn no">Output: Hello world from text</span></pre><p id="a42f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.再次运行以下命令查看输出。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f6d2" class="nk jv iq ng b gy nl nm l nn no">$ terraform apply</span></pre><p id="d053" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">使用Terraform管理资源<br/> </strong>如本文所述，Terraform用于管理云基础设施的各种资源的生命周期。资源是节点，可以是存储磁盘、虚拟机、网络接口等等。在本节中，我们将假设文件是我们想要管理的资源。通过使用Terraform创建和销毁文件，我们可以了解更多关于Terraform的使用。</p><p id="2aa9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">Terraform代码中的资源编写如下:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="a4ef" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“&lt;resource_type&gt;” “&lt;resource_name&gt;”</strong> {<br/>}</span></pre><p id="b010" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><code class="fe nx ny nz ng b">“&lt;<em class="mi">resource_type&gt;” </em></code>对应于必须由某种提供者提供的资源类型。因为我们还没有提供者，所以我们将使用类型为<code class="fe nx ny nz ng b"><em class="mi">“null_resource”</em></code>的资源。此资源类型对应于“空”提供程序，并且是自动安装的。这使得Terraform能够跟踪未知对象的生命周期(“HashiCorp，Null Resource”，2019f)。“&lt; <em class="mi">资源名称</em> &gt;”是用户自定义的名称。该名称在代码范围内必须是唯一的。假设它被称为<code class="fe nx ny nz ng b">“<em class="mi">node1</em>”</code>，那么这将意味着不存在其他类型为<code class="fe nx ny nz ng b">“<em class="mi">null_resource</em>”</code>且名称为<code class="fe nx ny nz ng b"> “<em class="mi">node1</em>”</code>的资源。</p><p id="5528" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">我们将使用上面的描述来创建一个简单的示例资源，该资源使用本地供应器来创建文件。这些功能使我们能够从代码中调用主机中的命令。</p><p id="09ef" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.进入项目</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="95a2" class="nk jv iq ng b gy nl nm l nn no">$ cd ~/terraform_project/</span></pre><p id="b818" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.编辑<em class="mi"> test.tf </em>文件。在这个文件中，我们将定义一个新的资源。</p><p id="7899" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.移除文件中的任何其他现有代码。将下面的代码添加到文件中。这将使创建资源成为可能。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="022e" class="nk jv iq ng b gy nl nm l nn no"># test.tf<br/>resource <strong class="ng ir">“null_resource” “node1”</strong> {<br/> # add provisioners here<br/>}</span></pre><p id="b4c9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.现在已经可以运行Terraform了，但是这当然除了管理一个<code class="fe nx ny nz ng b">“<em class="mi">null_resource</em>”</code>之外什么也不会做。为了使其有用，我们将添加置备程序。在“<strong class="ku ir"># add provisioners here”</strong>下添加以下代码，使其在<code class="fe nx ny nz ng b">“<em class="mi">node1</em>”</code>的范围内。进行下一步解释。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="cdfa" class="nk jv iq ng b gy nl nm l nn no"># add provisioners here<br/> provisioner <strong class="ng ir">“local-exec”</strong>{<br/> command = “echo &gt;&gt; ${path.module}/node1.txt”<br/> }</span><span id="a79e" class="nk jv iq ng b gy nq nm l nn no">provisioner <strong class="ng ir">“local-exec”</strong>{<br/> command = “rm ${path.module}/node1.txt”<br/> when = destroy<br/> }</span></pre><p id="4b45" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.现在添加了两个本地置备程序。如前所述，这些函数用于在主机上执行命令。这里使用的<code class="fe nx ny nz ng b">‘provisioner’ </code>函数属于<code class="fe nx ny nz ng b">“local-exec”</code> <strong class="ku ir">类型。</strong>它期待一个将在解释器上运行的命令，在ubuntu OS上默认为<code class="fe nx ny nz ng b"><strong class="ku ir">‘/bin/sh’</strong></code>。在本例中，第一个函数运行一个命令，在我们的'<em class="mi"> test.tf' </em>文件的目录中创建一个名为'<em class="mi"> node1.txt </em>的新文本文件，第二个函数运行一个命令，从调用它的目录中删除一个名为'<em class="mi"> node1.txt </em>的文件。请注意，只有在调用Terraform destroy时，才会调用第二个函数。这是用<code class="fe nx ny nz ng b">‘when = destroy’</code>配置的</p><p id="4c4f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.保存文件并运行<code class="fe nx ny nz ng b">“<em class="mi">terraform init</em>”</code>。您将在输出中看到，Terraform将搜索提供者“<em class="mi"> null </em>”来创建类型“<em class="mi"> null_resource </em>”，因为我们之前没有在项目中安装它。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4b8e" class="nk jv iq ng b gy nl nm l nn no">$ terraform init</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/8c95027e81674d183ec2a11d19cdd53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/0*KmkTHe3HIw0vp0FV"/></div></figure><p id="0d4c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">7.用<code class="fe nx ny nz ng b">“<em class="mi">terraform apply</em>”</code>应用地形配置。您将看到一个新的资源将被添加。键入'<em class="mi"> yes' </em>确认这一点。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="1598" class="nk jv iq ng b gy nl nm l nn no">$ terraform apply</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/1c0c960ce80d94ce2028a83fff5530bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/0*Y5vnpk9aRAbCCSzg"/></div></figure><p id="3291" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">8.现在，使用下面的命令在项目目录中搜索创建的文件“<em class="mi"> node1.txt </em>”，以验证文件的创建是否成功。该命令还会列出一些其他文件和一个隐藏目录。这些项目<code class="fe nx ny nz ng b">(<strong class="ku ir">.terraform/, terraform.tfstate and terraform.tfstate.backup</strong>) </code>被Terraform用来管理资源的生命周期。删除这些将导致Terraform不知道创建了哪些资源，这意味着如果需要，您必须手动删除所有资源。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="957b" class="nk jv iq ng b gy nl nm l nn no">$ ls -al ~/terraform_project/</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8e1e644742a99e983a98c9836d06333c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/0*yk56SV5gzOgLxmEl"/></div></figure><p id="674f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">9.最后，使用<code class="fe nx ny nz ng b">‘<em class="mi">terraform destroy’</em></code>摧毁资源。您会看到有一个资源被标记为销毁。键入<em class="mi">‘yes’</em>确认销毁。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="11d9" class="nk jv iq ng b gy nl nm l nn no">$ terraform destroy</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/8fc677b476331ee58c409d6bdd657b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/0*4ADk3xaFnpubngXB"/></div></figure><p id="24d9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在本章中，您学习了如何使用Terraform来管理单个资源。当需要配置的多个资源开始发挥作用时，Terraform代码最有用。此外，本章没有使用实际的资源提供者。在从现在开始的章节中，用Terraform创建和破坏基础设施的概念会被大量使用。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="407c" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">6.正在为libvirt安装KVM和Terraform提供程序</h1><p id="8709" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a69f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">现在已经安装了Terraform，并且已经完成了一些测试。可以采取进一步的步骤来调配虚拟机。为此，将使用KVM虚拟机管理程序。此外，与用于管理KVM的虚拟化库(libvirt)的交互需要作为提供者添加到Terraform中。</p><p id="be33" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">下载/安装KVM并启用libvirt-service <br/> </strong> KVM是ubuntu 18.04的标准下载包。KVM依赖于几个包。主包是qemu-kvm和libvirt-bin。这些包是虚拟化所必需的。本章将指导您完成KVM及其依赖项的安装。</p><p id="cc4d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.启动控制台并更新您的系统以获取新的软件包源。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="faf8" class="nk jv iq ng b gy nl nm l nn no">$ sudo apt update</span></pre><p id="8084" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.使用以下命令下载/安装KVM和所需的软件包。这将安装许多软件包，可能需要相当长的时间。除了KVM软件包之外，还将安装一些其他有用的工具。<em class="mi"> Bridge-utils </em>用于调试网络中的问题，主要是桥接网络。Virtinst是一个可以用来创建虚拟机的工具。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="bd61" class="nk jv iq ng b gy nl nm l nn no">$ sudo apt -y install qemu-kvm libvirt-bin virt-top libguestfs-tools virtinst bridge-utils</span></pre><p id="8df5" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.启用<code class="fe nx ny nz ng b">“<em class="mi">vhost_net</em>”</code>内核模块。这个模块允许libvirt直接调用子系统，而不是使用来自用户空间的调用。这将主要提高虚拟机的性能，而不是使用libvirt服务的先决条件。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="b678" class="nk jv iq ng b gy nl nm l nn no">$ sudo modprobe vhost_net</span></pre><p id="31ff" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.使用<code class="fe nx ny nz ng b"><strong class="ku ir">‘</strong>lsmod<strong class="ku ir">’</strong></code>验证是否加载了“<em class="mi"> vhost_net </em>”模块，这将列出当前加载的模块，并使用<code class="fe nx ny nz ng b">‘grep’</code>(‘全局正则表达式’)在模块列表中查找“<em class="mi"> vhost_net </em>”模块。运行以下命令并比较输出，验证模块是否已激活。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="e5cf" class="nk jv iq ng b gy nl nm l nn no">$ sudo lsmod | grep vhost</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/434101d9b80fe8a2f9e1472fb2364049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/0*1I4Q9J9tsiEt6lWY"/></div></figure><p id="941d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.使用以下命令启动libvirt服务，并在下次启动时启用自动启动。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="5b94" class="nk jv iq ng b gy nl nm l nn no">$ sudo systemctl enable — now libvirtd</span></pre><p id="9cfe" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.通过运行以下命令并搜索<strong class="ku ir"> active (running) </strong>来验证libvirt状态。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="7c8a" class="nk jv iq ng b gy nl nm l nn no">$ sudo systemctl status libvirtd</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ob"><img src="../Images/d6dd6f281c4dd781cd44f4d8fd63219c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/0*TPDQ6xBGFFaFWhDU"/></div></div></figure><p id="3381" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">7.用下面的命令安装<strong class="ku ir">虚拟管理器</strong>。这是一个GUI程序，可以用来管理用libvirt创建的各种虚拟机。如果仅从控制台运行，则不需要安装此程序。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="3001" class="nk jv iq ng b gy nl nm l nn no">$ sudo apt -y install virt-manager</span></pre><p id="4e8c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">8.重启你的主机。</p><p id="9e6e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">安装GOlang和Git <br/> </strong> Golang是Google<em class="mi">【Google，The Go Programming Language】，2019</em>制作的开源编程语言。它以方便著称，因为它提供了跨平台支持。对于这些指令，它将用于从GitHub构建各种terraform提供者。我们只使用GO编译器来构建和安装插件。</p><p id="3996" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.运行以下命令来安装GOlang和Git。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="c956" class="nk jv iq ng b gy nl nm l nn no">$ sudo apt -y install golang git</span></pre><p id="9011" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">安装Terraform lib virt provider<br/></strong>要使用terra form与KVM交互，需要提供程序。该提供者将处理我们的terraform配置，并调用libvirt库所需的函数，然后lib virt库将告诉KVM执行某些任务。该提供程序将像其他提供程序一样从Github安装。安装也与其他提供商非常相似。在此之前，需要安装一些特定于terraform-provider-libvirt的包。</p><p id="633b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.使用go安装terraform-provider-libvirt需要安装libvirt-dev依赖项。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="8736" class="nk jv iq ng b gy nl nm l nn no">$ sudo apt -y install libvirt-dev</span></pre><p id="fc68" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.使用以下命令导出GO路径。这些是提供者将搜索的目录，以便可以构建它。函数<em class="mi">‘export’</em>是一个可以用来导出当前shell的某些路径的函数。从<code class="fe nx ny nz ng b"><em class="mi">~/.bashsrc</em>.</code>启动时已经自动添加了许多路径</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="0d10" class="nk jv iq ng b gy nl nm l nn no">$ export PATH=$PATH:/usr/lib/go/bin</span><span id="b0ee" class="nk jv iq ng b gy nq nm l nn no">$ export GOPATH=/usr/lib/go/</span></pre><p id="52f4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.使用下面的命令在GOPATH的目录中创建并进入一个新目录。以下代码中描述的格式似乎是安装terraform提供程序的标准，因为提供程序将在下面显示的目录中搜索构建文件。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="d2b2" class="nk jv iq ng b gy nl nm l nn no">$ sudo mkdir -p $GOPATH/src/github.com/dmacvicar/</span><span id="77e3" class="nk jv iq ng b gy nq nm l nn no">$ cd $GOPATH/src/github.com/dmacvicar/</span></pre><p id="89da" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.克隆官方git存储库。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="fd8a" class="nk jv iq ng b gy nl nm l nn no">$ sudo git clone <a class="ae lv" href="https://github.com/dmacvicar/terraform-provider-libvirt.git" rel="noopener ugc nofollow" target="_blank">https://github.com/dmacvicar/terraform-provider-libvirt.git</a></span></pre><p id="aced" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.进入提供者的目录，用下面的命令构建它。“make”命令将编译提供程序,“make install”将把它安装在我们的GOPATH中。这最多需要30秒。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="39e0" class="nk jv iq ng b gy nl nm l nn no">$ cd terraform-provider-libvirt</span><span id="fa93" class="nk jv iq ng b gy nq nm l nn no">$ sudo make install</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/5afe0134fc64b9e0308b3629f7fcbf7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/0*b6aQKGSQ63kCIN43"/></div></figure><p id="b1c2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.构建的结果是一个保存在＄GOPATH/bin中的可执行文件。进入这个目录，用下面的命令检查版本。输出应该类似于下图。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="7a6c" class="nk jv iq ng b gy nl nm l nn no">$ cd $GOPATH/bin/</span><span id="fdc5" class="nk jv iq ng b gy nq nm l nn no">$ ./terraform-provider-libvirt -version</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/7022297e1c7c17d522dc2e3b791ba07d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/0*UAAJFv9Z-09ia9L1"/></div></figure><p id="9154" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">添加提供者作为插件<br/> </strong>我们想使用libvirt作为我们的Terraform提供者。插件需要专门添加到<em class="mi">' ~/. terra form . d/plugins '</em>目录中。这是terraform初始化时搜索第三方插件的目录。</p><p id="6c35" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.在<code class="fe nx ny nz ng b">‘<em class="mi">~/terraform.d</em>’</code>中新建一个名为“<em class="mi">插件</em>的目录，链接<code class="fe nx ny nz ng b">‘<em class="mi">/usr/lib/go/bin/’</em></code> <em class="mi">中的<code class="fe nx ny nz ng b">‘<em class="mi">terraform-provider-libvirt’ </em></code>可执行文件。</em>同样，命令<code class="fe nx ny nz ng b"><em class="mi">‘ln’</em></code> <em class="mi"> </em>用于防止系统中出现重复的可执行文件。此外，当'<code class="fe nx ny nz ng b">/<em class="mi">$GOPATH/bin/’ </em></code>中的实际文件发生变化时，无需采取进一步的步骤。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="568a" class="nk jv iq ng b gy nl nm l nn no">$ mkdir ~/.terraform.d/plugins</span><span id="c8e2" class="nk jv iq ng b gy nq nm l nn no">$ sudo ln -s /usr/lib/go/bin/terraform-provider-libvirt ~/.terraform.d/plugins/</span><span id="33f0" class="nk jv iq ng b gy nq nm l nn no">$ ls -l ~/.terraform.d/plugins/</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/8be0f30dddabf8781542dd0b5622a34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*HztNqJnTiGJrECEF"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="e6ed" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">7.使用Terraform和KVM创建虚拟机</h1><p id="36f8" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f544" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本章将介绍如何创建新的虚拟机、分配计算资源以支持虚拟机，以及最终使用terraform的terraform-libvirt-provider插件配置虚拟机。</p><p id="31b1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">配置主要是我们想要放入机器的资源，例如内核数量和内存大小。除此之外，机器中的用户必须进行配置，以便我们在创建后登录。为此，我们将使用SSH密钥。创建机器并登录后，将在创建的虚拟机上运行一个可以计算给定精度的Pi的测试服务器，以展示其功能。</p><p id="05ad" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">设置权限<br/> </strong>首先，我们需要确保libvirt服务有权创建、读取和写入用户文件，以便为虚拟机分配空间。</p><p id="dbfd" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.Libvirt需要主机的用户权限才能分配计算资源。运行以下命令将您的用户添加到libvirt和KVM组。将<em class="mi">‘Ubuntu’</em>改为你主机的用户。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="9b52" class="nk jv iq ng b gy nl nm l nn no">$ sudo usermod -aG libvirt,kvm ubuntu</span></pre><p id="e123" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.我们当前的部分尚未启用这些组。使用<code class="fe nx ny nz ng b">‘su — ${user}‘</code> <strong class="ku ir"> <em class="mi"> </em> </strong>命令<em class="mi">重新登录到您的用户。</em>之后，使用<strong class="ku ir"> id </strong>命令列出用户所属的组。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="0fa1" class="nk jv iq ng b gy nl nm l nn no">$ su — ubuntu</span><span id="9207" class="nk jv iq ng b gy nq nm l nn no">$ id -nG</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/8c907168bdf838d97dcbfc13802a4b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*_goSfcuLtAYc9RT6"/></div></figure><p id="e01d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.通过编辑一个可以在<code class="fe nx ny nz ng b"><em class="mi">‘/etc/libvirt/qemu.conf</em>’</code>找到的文件，关闭libvirt的SElinux安全驱动程序。需要关闭安全驱动程序，因为它会阻止libvirt创建libvirt-domain。打开文件。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="ecf5" class="nk jv iq ng b gy nl nm l nn no">$ sudo nano /etc/libvirt/qemu.conf</span></pre><p id="b6c7" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.用<strong class="ku ir"> CTRL+W </strong>搜索，将<code class="fe nx ny nz ng b">‘security_driver=”selinux”’</code>改为<code class="fe nx ny nz ng b">‘security_driver = “none”’</code>。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/32ddd2286cbaf3c84c62a5fc1ed5abbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/0*CN1etKldJA-VUV22"/></div></figure><p id="b0b7" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.用<strong class="ku ir"> CTRL+X </strong>退出并保存，按<strong class="ku ir"> Y </strong>然后<strong class="ku ir">进入</strong></p><p id="395e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.最后，重新启动libvirt服务以使更改生效</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f046" class="nk jv iq ng b gy nl nm l nn no">$ sudo systemctl restart libvirtd</span></pre><p id="8684" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">设置项目工作区<br/> </strong>该项目是一个位于<code class="fe nx ny nz ng b">‘<em class="mi">~/kvm_project/</em>’</code>的目录。将要添加的目录是<em class="mi">图像</em>和<em class="mi">下载</em>。稍后将需要这些目录。映像目录是保存新虚拟机的位置。下载目录是克隆图像的地方。</p><p id="24e7" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.进入项目目录，使用以下命令创建两个名为<code class="fe nx ny nz ng b">‘<em class="mi">downloads/</em>’</code>的新目录。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="5e4a" class="nk jv iq ng b gy nl nm l nn no">$ mkdir ~/kvm_project/</span><span id="003a" class="nk jv iq ng b gy nq nm l nn no">$ cd ~/kvm_project/</span><span id="d117" class="nk jv iq ng b gy nq nm l nn no">$ mkdir downloads</span></pre><p id="62d7" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.创建一个新目录来保存图像。这是虚拟机磁盘的位置。因此，需要将它放在不易接近的地方。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="ccf1" class="nk jv iq ng b gy nl nm l nn no">$ sudo mkdir -p /libvirt_images/</span></pre><p id="195e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">下载映像<br/> </strong>需要一个您希望在客户机上运行的操作系统映像。任何操作系统都可以使用。对于本指南，我们将使用ubuntu 18.04云图像。我们建议使用云类型的图像，因为这可以大大减少下载和克隆的时间。</p><p id="7af9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.使用以下命令将图像下载到项目中的下载目录。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4701" class="nk jv iq ng b gy nl nm l nn no">$ cd ~/kvm_project/downloads</span><span id="b37e" class="nk jv iq ng b gy nq nm l nn no">$ wget <a class="ae lv" href="https://cloud-images.ubuntu.com/bionic/current/bionic-server-cloudimg-amd64.img" rel="noopener ugc nofollow" target="_blank">https://cloud-images.ubuntu.com/bionic/current/bionic-server-cloudimg-amd64.img</a></span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ef2756e4c955aa5bcbba534a7a989699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/0*xCqoRFQUVX80iv-V"/></div></figure><p id="9da5" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">下载网址</strong>:<a class="ae lv" href="https://cloud-images.ubuntu.com/bionic/current/" rel="noopener ugc nofollow" target="_blank">https://cloud-images.ubuntu.com/bionic/current/</a></p><p id="9c1a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.下载需要一段时间。您只需启动一个新的控制台，就可以继续其他步骤。</p><p id="ba57" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">生成SSH密钥<br/> </strong>登录客户虚拟机需要SSH密钥。SSH密钥成对出现。一个公钥和一个私钥。私钥从不共享，并保存在<code class="fe nx ny nz ng b">~/.ssh</code>目录下。公钥也保存在目录<code class="fe nx ny nz ng b">~/.ssh</code>中。与私钥不同，公钥应该是可共享的。当用户想要使用SSH登录到一个来宾虚拟机时，该虚拟机必须拥有经过授权的公钥。这时公钥被添加到客户机的<code class="fe nx ny nz ng b"><em class="mi">‘~/.ssh/authorized_keys’</em></code>文件中的公钥列表中。要创建密钥，可使用名为<code class="fe nx ny nz ng b">‘<em class="mi">ssh-keygen’ </em></code>的程序。</p><p id="8b9b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.运行以下命令来生成SSH密钥。当要求输入密码时，按两次enter。不需要密码，只需按回车键。没有指定选项，因为所需的文件和密钥将放在<code class="fe nx ny nz ng b">~/.ssh/</code>中。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="d857" class="nk jv iq ng b gy nl nm l nn no">$ ssh-keygen</span></pre><p id="f5f8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.通过运行以下命令并比较输出，查看所创建密钥的权限，以验证权限是否正确更改。你会看到两把钥匙。其中一个密钥是公钥和私钥。区别可见于<strong class="ku ir"> <em class="mi">。pub </em> </strong>扩展公钥。因为这是我们要共享的，所以也需要读写。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="deff" class="nk jv iq ng b gy nl nm l nn no">$ ls -al ~/.ssh/</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b77ed12dc3b23229bba041d5b53868b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/0*mRqKHmhEY7WYq8G9"/></div></figure><p id="54c5" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">按照第5章<strong class="ku ir">中的讨论，设置一个平台配置来配置一个客户虚拟机<br/> </strong>。tf </strong>文件用于在Terraform中配置基础设施。在本节中，将创建一个新的terraform配置文件。代码的目标是创建一个新的虚拟机，并分配支持虚拟机所需的资源。要创建虚拟机，需要一个映像。这是在本章第一节下载的图像。此外，还需要配置要创建的虚拟机中的用户。这将在下一节中完成，但是对用户配置文件的调用将在本节中完成。</p><p id="0b4c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.进入项目目录。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="0b1d" class="nk jv iq ng b gy nl nm l nn no">$ cd ~/kvm_project/</span></pre><p id="e601" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.使用您喜欢的编辑器创建一个新的terraform配置文件。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4522" class="nk jv iq ng b gy nl nm l nn no">$ nano libvirt.tf</span></pre><p id="4c40" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.首先需要的是提供者'<em class="mi">terra form-lib virt-provider</em>'。要在代码中实现这一点，需要添加一个调用。这是通过添加下面的代码行来完成的。这段代码将连接到QEMU Hypervisor。添加这些行后不要关闭编辑器，后面会有更多的说明。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="8ef2" class="nk jv iq ng b gy nl nm l nn no"># libvirt.tf<br/># add the provider<br/>provider <strong class="ng ir">“libvirt”</strong> {<br/> uri = “qemu:///system”<br/>}</span></pre><p id="5f0e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.创建一个libvirt池。这是为虚拟机映像留出的存储量。<em class="mi">名称</em>参数用于标识一个池。池类型“dir”提供了管理目录中文件的方法。这些文件可以是特殊的磁盘格式，如<strong class="ku ir"> ' <em class="mi"> qcow' </em> </strong>或<strong class="ku ir"> ' <em class="mi"> vmdk' </em> </strong>。最后，path参数是存储的位置以及机器图像的保存位置。我们选择<code class="fe nx ny nz ng b"><em class="mi">‘/libvirt_images/ubuntu-pool/’</em></code> <em class="mi">作为路径。</em>运行代码时，如果目录不存在，将创建一个新目录。(默认的池目录是<code class="fe nx ny nz ng b">“<em class="mi">/var/lib/libvirt/images</em>”</code>。在指南中，将使用目录“<em class="mi"> /libvirt_images/ </em>”</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="08b6" class="nk jv iq ng b gy nl nm l nn no"># create pool<br/>resource <strong class="ng ir">“libvirt_pool” “ubuntu”</strong> {<br/> name = “ubuntu-pool”<br/> type = “dir”<br/> path = “/libvirt_images/ubuntu-pool/”<br/>}</span></pre><p id="cd47" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.为虚拟机映像磁盘创建新资源。添加以下几行来创建新的图像资源。这将创建一个新的映像，方法是从给定的源克隆它，并将其保存在上一步中创建的池的路径中。来源可以是一个目录，甚至是实际下载的HTTP URL。请注意，给定的格式应该与池类型相匹配。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="1b64" class="nk jv iq ng b gy nl nm l nn no"># create image<br/>resource <strong class="ng ir">“libvirt_volume” “image-qcow2”</strong> {<br/> name = “ubuntu-amd64.qcow2”<br/> pool = libvirt_pool.ubuntu.name<br/> source =”${path.module}/downloads/bionic-server-cloudimg-amd64.img”<br/> format = “qcow2”<br/>}</span></pre><p id="dd72" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.创建云初始化磁盘并加载云初始化配置。该磁盘将用于与来宾虚拟机共享在<code class="fe nx ny nz ng b">‘<em class="mi">cloud_init.cfg’ </em></code>文件中找到的用户数据。将创建一个映像，并将其保存在我们将要创建的虚拟机所在的存储池中。关于云初始化文件的更多解释将出现在下一节，在这里将创建<em class="mi">云初始化. cfg </em>文件。添加以下几行。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="d5f8" class="nk jv iq ng b gy nl nm l nn no"># add cloudinit disk to pool<br/>resource “libvirt_cloudinit_disk” “commoninit” {<br/> name = “commoninit.iso”<br/> pool = libvirt_pool.ubuntu.name<br/> user_data = data.template_file.user_data.rendered<br/>}</span><span id="e635" class="nk jv iq ng b gy nq nm l nn no"># read the configuration<br/>data “template_file” “user_data” {<br/> template = file(“${path.module}/cloud_init.cfg”)<br/>}</span></pre><p id="d717" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">7.创建新的libvirt域。这是添加支持客户机的资源的地方。这基本上是创建虚拟机的地方，它将决定所创建的机器的性能以及网络功能。根据可用的资源，您可以更改内存和vcpu的名称。使用的网络是libvirt创建的<em class="mi">‘default’</em>网络，它已经具有DHCP功能。建议保持控制台设置不变。这方面的更多内容将在下一章介绍。将下列行追加到您的配置文件中。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="19e1" class="nk jv iq ng b gy nl nm l nn no"># Define KVM domain to create<br/>resource <strong class="ng ir">“libvirt_domain” “test-domain”</strong> {<br/> <br/> # name should be unique!<br/>   name = “test-vm-ubuntu”<br/>   memory = “1024”<br/>   vcpu = 1<br/> # add the cloud init disk to share user data<br/>   cloudinit = libvirt_cloudinit_disk.commoninit.id</span><span id="3336" class="nk jv iq ng b gy nq nm l nn no"># set to default libvirt network<br/>   network_interface {<br/>   network_name = “default”<br/> }</span><span id="85f8" class="nk jv iq ng b gy nq nm l nn no">console {<br/>   type = “pty”<br/>   target_type = “serial”<br/>   target_port = “0”<br/> }</span><span id="1611" class="nk jv iq ng b gy nq nm l nn no">disk {<br/>   volume_id = libvirt_volume.image-qcow2.id<br/> }</span><span id="2749" class="nk jv iq ng b gy nq nm l nn no">graphics {<br/>   type = “spice”<br/>   listen_type = “address”<br/>   autoport = true<br/> }<br/>}</span></pre><p id="4e47" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">8.这个脚本现在可以用来创建一个新的虚拟机。保存它，并继续使用'<strong class="ku ir">'设置cloud-init。</strong>.”部分，以便在创建时使用云初始化配置登录虚拟机。</p><p id="1f78" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">设置cloud-init用于在创建时配置客户虚拟机系统<br/> </strong>在本节中，cloud init将用于在客户虚拟机上配置用户。对什么是云初始化的简短描述:</p><p id="67b9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><em class="mi">“Cloud-init是跨平台云实例初始化的行业标准多分发方法。它受到所有主要公共云提供商、私有云基础架构的配置系统和裸机安装的支持。”</em></p><p id="27c6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><em class="mi">(“云初始化，云初始化19.2文档”2019a) </em></p><p id="3b6e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">首先，我们将创建一个名为“<em class="mi">cloud _ init . CFG”</em>的文件。Terraform不会自动加载该文件。要加载数据，需要从'<strong class="ku ir">'进行调用。tf </strong>配置文件。在最后一节，第7.5章第六步，可以找到对'<em class="mi"> cloud_init.cfg '的调用。</em>cloud init的语法是'<strong class="ku ir"> <em class="mi"> yaml '。</em> </strong>语法不能处理制表符。因此，仅使用空格在代码中创建结构。建议使用两个空格代替制表符。这一点很重要，因为Terraform不会处理云初始化配置的配置错误。</p><p id="aa06" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.进入项目目录，创建一个名为'<em class="mi"> cloud_init.cfg '的新文件。</em></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="6ebd" class="nk jv iq ng b gy nl nm l nn no">cd ~/kvm_project/</span><span id="a151" class="nk jv iq ng b gy nq nm l nn no">nano cloud_init.cfg</span></pre><p id="334b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.添加下面的代码并注意下面的解释。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="a09d" class="nk jv iq ng b gy nl nm l nn no">#cloud-config<br/>users:<br/> — name: <strong class="ng ir">terraform_guest</strong><br/> sudo: ALL=(ALL) NOPASSWD:ALL<br/> groups: users, admin<br/> home: /home/<strong class="ng ir">terraform_guest</strong><br/> shell: /bin/bash<br/> ssh_authorized_keys:<br/> — <strong class="ng ir">ssh-rsa XXXX</strong></span></pre><p id="eb7b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.这段代码用于设置我们将要创建的虚拟机的用户。确保更改所有粗体标记的零件。</p><p id="5af9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><em class="mi"> name </em>参数是将要添加的用户名。添加更多的名称参数将导致多个用户。在<em class="mi">名称</em>参数下，设置用户数据。最重要的是'<em class="mi"> ssh_authrozed_keys' </em>参数。该参数需要一个公钥列表，这些公钥将被添加到目录'<em class="mi"> ~/中的'<em class="mi"> authorized_keys' </em>下。客户机的ssh/authorized_keys' </em>。这样，我们将能够在同一个目录中使用我们的私钥登录到用户。</p><p id="4114" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">要得到大众只需运行:<strong class="ku ir"> <em class="mi">猫~/。主机上的ssh/id_rsa.pub </em> </strong>。</p><p id="42ce" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.最后，当创建虚拟机时，我们将让云init为我们下载一些包。注意下面的配置。这将下载包和<em class="mi"> python </em>和<em class="mi"> git </em>。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="5d5c" class="nk jv iq ng b gy nl nm l nn no"># install packages<br/>packages:<br/> — qemu-guest-agent<br/> — git</span></pre><p id="e9b9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">配置来宾虚拟机<br/> </strong>现在项目已经设置好，可以使用Terraform创建一个新的虚拟机。本节将向您介绍启动和运行机器的命令。</p><p id="d349" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.初始化项目工作环境。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="3513" class="nk jv iq ng b gy nl nm l nn no">$ terraform init</span></pre><p id="2b01" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.使用以下命令应用更改。确保键入'<em class="mi"> yes' </em>以确认更改。如您所见，将添加四种资源。它们是libvirt池、libvirt磁盘、云初始化磁盘和libvirt卷。应用Terraform后，将保存这些资源并记住它们，以便管理这些对象的生命周期。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f842" class="nk jv iq ng b gy nl nm l nn no">$ terraform apply</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/62d627cc0eb6609e26f788e2f70e9ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/0*8Ov688XUfvxwXIGa"/></div></figure><p id="a319" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.在机器制造完成之后。从输出中可以看出，机器由四个资源组成。我们希望验证我们的所有资源是否都是正确创建的。我们将通过一组<em class="mi">【virsh】</em>命令。这是一个从命令行创建和管理libvirt资源的工具。首先运行以下命令，列出用libvirt创建的所有虚拟机(域)。属性域列表中的一个条目与使用Terraform代码创建的条目同名。在这种情况下<em class="mi">‘test-VM-Ubuntu’</em></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f6af" class="nk jv iq ng b gy nl nm l nn no">$ virsh list — all</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/2b0cfa3c3ee661e35e9d48cf7dc92273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/0*afeDjuO0dcByL-t7"/></div></figure><p id="b62e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.我们为该域的存在创建了一些其他资源。它们是libvirt池、libvirt卷和云初始化磁盘。正如7.5章所讨论的，机器的磁盘(libvirt卷)和云初始化磁盘需要在同一个池中共享云初始化配置。为此，我们创建了一个名为<em class="mi">‘Ubuntu-pool’的池。</em>运行以下命令列出现有池。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="e721" class="nk jv iq ng b gy nl nm l nn no">$ virsh pool-list — all</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/b56dafdfdd465b596695913f233fb6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/0*RkuWyfUBlqKd9IWt"/></div></figure><p id="7d17" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.要列出在特定池中运行的现有卷，请运行以下命令。如你所见，这些是我们在第7.5章代码中定义的'<em class="mi"> libvirt_volume' </em>和'<em class="mi">lib virt _ cloud _ init _ disk '</em>。它们也在我们希望它们在的目录中。该目录是<code class="fe nx ny nz ng b">‘<em class="mi">/libvirt_images/ubuntu-pool/’.</em></code></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="3890" class="nk jv iq ng b gy nl nm l nn no">$ virsh vol-list <strong class="ng ir">ubuntu-pool</strong></span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/b00379ae6b4e01793b6eabb758c76525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/0*Mz16d3Psl2338ORX"/></div></figure><p id="c0e2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.列出目录<code class="fe nx ny nz ng b"><em class="mi">‘/libvirt_images/ubuntu-pool’</em></code>中的卷文件。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="e46e" class="nk jv iq ng b gy nl nm l nn no">$ sudo ls /libvirt_images/ubuntu-pool/</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/c1021a0d51a2f0bf5a2aebedd51515f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/0*mLecPNiNcKPoagpe"/></div></figure><p id="9267" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">7.现在，我们确信代码正在按预期工作，我们可以继续尝试登录。登录到我们创建的机器的唯一方法是使用SSH。为此，我们需要知道机器在哪个网络中，它有什么IP地址。使用下面的命令列出所有libvirt网络。这将列出libvirt提供的<em class="mi">‘默认’</em>网络。我们在域的网络接口下配置我们的虚拟机连接到第7.5章中的默认网络。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="d9d9" class="nk jv iq ng b gy nl nm l nn no">$ virsh net-list –-all</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/f9caf6851deed50f9380b7f3c108a915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/0*lWkTewzdaRjUG_p5"/></div></figure><p id="fffe" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">8.最后，尝试pinging客户机。首先找到DHCP租给它的IP地址。这不会总是立即发生，因为机器可能仍在启动。使用以下命令，它需要网络名称。我们在第7.5章中将其设置为'<em class="mi">默认'</em>。当然，也可以使用上一步获得的名称找到网络。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="312b" class="nk jv iq ng b gy nl nm l nn no">$ virsh net-dhcp-leases <strong class="ng ir">default</strong></span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/47d306f31509836b1f6f41838ef915d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/0*EtFefrcqyr11XZ4B"/></div></figure><p id="cf37" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">9.Ping上一步中找到的'<em class="mi"> IP地址'</em>。如果客人能找到主人，我们将使用这个来使用户。记下此IP地址，因为它将在下一部分中使用。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4abe" class="nk jv iq ng b gy nl nm l nn no">$ ping <strong class="ng ir">192.168.122.79</strong></span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/b049d6e0c8dfef6197d53d157e4e0d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/0*T3kaw6RpRSdjnzRp"/></div></figure><p id="8d85" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">在来宾虚拟机上运行测试服务器<br/> </strong>在最后一部分，创建了一个虚拟机。我们配置了两种登录方式。一种方法是只使用用户名和密码，另一种方法是使用在本章的云初始化部分配置的SSH密钥。我们将使用后一种方法登录到机器上，下载、安装并运行一个名为PiCalc的测试程序。</p><p id="cd49" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">PiCalc是一个HTTP服务器，用它可以计算出给定精度的圆周率。这将通过使用名为mpmath的Python数学库和web框架Bottle来实现。这是一个没有依赖关系的轻量级python with框架。该程序将从Github下载:</p><blockquote class="mz na nb"><p id="277c" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><a class="ae lv" href="https://github.com/krebsalad/PiCalcPy.git" rel="noopener ugc nofollow" target="_blank">【https://github.com/krebsalad/PiCalcPy.git】T4</a></p></blockquote><p id="9040" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.启动终端模拟器。</p><p id="fba7" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.首先，虚拟机的<em class="mi"> IP地址</em>需要使用SSH登录。在主机上运行以下命令，查看租用的IP地址。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="bf87" class="nk jv iq ng b gy nl nm l nn no">$ virsh net-dhcp-leases default</span></pre><p id="2d33" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.使用在云初始化中配置的来宾用户名和从上一步获得的<em class="mi"> IP地址</em>登录到来宾虚拟机。确保<strong class="ku ir"><em class="mi">terra form _ guest</em></strong>与本章“云初始化”一节中创建的用户相匹配。另外，<strong class="ku ir">&lt;192 . 168 . 122 . 79&gt;</strong>应该是客户机器的IP地址。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="10e4" class="nk jv iq ng b gy nl nm l nn no">$ ssh <strong class="ng ir">terraform_guest</strong>@<strong class="ng ir">192.168.122.79</strong></span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/a88223c9d464aaa20c90a1d2e0458901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/0*QlhiKVoCYcZGnjlY"/></div></figure><p id="2d31" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.检查是否按照我们在cloud_init文件中指定的方式安装了git，如果尚未安装python，则检查是否在客户机中安装了python。这些将用于创建python服务器。您会注意到已经安装了git。这要感谢我们在云初始化部分添加的云初始化包更新参数。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="e0c3" class="nk jv iq ng b gy nl nm l nn no">$ dpkg -s git | grep Status</span><span id="cc7d" class="nk jv iq ng b gy nq nm l nn no">$ dpkg -s python | grep Status</span></pre><p id="dfe6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.从Github克隆PiCalc服务器。这有一个python项目，将用于安装和运行PiCalc服务器。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="2409" class="nk jv iq ng b gy nl nm l nn no">$ git clone <a class="ae lv" href="https://github.com/krebsalad/PiCalcPy.git" rel="noopener ugc nofollow" target="_blank">https://github.com/krebsalad/PiCalcPy.git</a></span></pre><p id="9897" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.进入'<em class="mi">pic acpy/'</em>,运行下面的命令，安装服务器的依赖项。这将安装mpmath，一个数学库和瓶子。如前所述，Bottle是非常轻量级的，因为它不需要python已经拥有的其他依赖项。这可以从它只需要运行一个python文件的事实中看出。需要安装Mpmath，这需要<em class="mi"> sudo </em>权限。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="9b8b" class="nk jv iq ng b gy nl nm l nn no">$ cd PiCalcPy/</span><span id="48e1" class="nk jv iq ng b gy nq nm l nn no">$ sudo python install_picalc.py</span><span id="a83f" class="nk jv iq ng b gy nq nm l nn no">$ ls -a</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/ea2bb777813fc13ed84d3c24aa85413e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/0*xuU3rNMDFFhrt0un"/></div></figure><p id="e53c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">7.打开名为<em class="mi"> 'picalc_server.py' </em>的文件。该文件包含运行服务的代码。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="2324" class="nk jv iq ng b gy nl nm l nn no">$ nano picalc_server.py</span></pre><p id="c21f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">8.注意'<em class="mi"> picalc_server.py' </em>的内容。内容也可以在下面找到。这个脚本将等待一个对路由<strong class="ku ir"> http:// &lt; IP &gt; : &lt;端口&gt; /PiCalc/ &lt; p &gt;的HTTP请求。</strong>在最后一行'<em class="mi"> run(host=ip_addr，port=8080)' </em>中设置<strong class="ku ir"> IP </strong>。<strong class="ku ir"> <em class="mi"> p </em> </strong>代表<strong class="ku ir">精度</strong>，用于确定我们想要的圆周率的小数位数。该脚本将使用一个名为'<em class="mi"> socket' </em>'的python标准库自动获取您当前的IP。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="33f4" class="nk jv iq ng b gy nl nm l nn no"><strong class="ng ir"># picalc server.py</strong></span><span id="64dc" class="nk jv iq ng b gy nq nm l nn no">from bottle import route, run, template<br/>from mpmath import mp<br/>import socket<br/>import time</span><span id="23f1" class="nk jv iq ng b gy nq nm l nn no">hostname = socket.gethostname()<br/>ip_addr = socket.gethostbyname(hostname)</span><span id="48c3" class="nk jv iq ng b gy nq nm l nn no">@route(‘/PiCalc/&lt;p&gt;’)<br/>def index(p):<br/> # set time<br/> start_time = time.time()</span><span id="ebac" class="nk jv iq ng b gy nq nm l nn no"># read precision value<br/> precision = int(p)</span><span id="b971" class="nk jv iq ng b gy nq nm l nn no"># handle non ints<br/> if(str(type(precision)) != “&lt;type ‘int’&gt;”):<br/> print(str(type(precision)))<br/> return str(“error, precision was not an int”)</span><span id="3adf" class="nk jv iq ng b gy nq nm l nn no"># set precision val and calculate pi<br/> mp.dps = precision<br/> pi = mp.pi</span><span id="5f6c" class="nk jv iq ng b gy nq nm l nn no"># end time<br/> processing_time = time.time() — start_time</span><span id="7865" class="nk jv iq ng b gy nq nm l nn no"># return txt<br/> return str(“Server ip: “+ip_addr+ “\nTime took: “+ str(processing_time) + “ seconds\nPI = “ + str(pi) + “\n”)</span><span id="cb4e" class="nk jv iq ng b gy nq nm l nn no"># function to run picalc on port 8080 by default<br/>def run_server(port_num=8080):<br/> run(host=ip_addr, port=port_num)</span></pre><p id="7fc8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">9.退出编辑器，用下面的命令运行测试程序。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="e07b" class="nk jv iq ng b gy nl nm l nn no">$ sudo python run.py mode=server</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/84decca2b580c5029aeb6fbe5f63f430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/0*Z7WYyhc1jU7y_iIR"/></div></figure><p id="e3dd" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">10.通过启动新的终端并输入以下命令，从您的主机向服务器发送请求。(如果您的主机上有GUI，您也可以通过浏览器发送请求。只需在浏览器中键入以下命令，无需'<em class="mi"> curl </em>')</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4eeb" class="nk jv iq ng b gy nl nm l nn no">$ curl <strong class="ng ir">192.168.122.79</strong>:8080/PiCalc/100</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi or"><img src="../Images/581eb2d01f7b95938934f29f647815dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*itBoXZftX4rsd_3d"/></div></div></figure><p id="7b8a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">11.现在我们了解了如何调配虚拟机，我们可以更深入地了解如何调配多个虚拟机。现在，通过键入<em class="mi">‘exit’</em>退出客户机上的SSH会话。</p><p id="15cd" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">12.最后，在主机上使用以下命令销毁域及其资源。要正确做到这一点，它需要位于初始化terraform的目录中。在我们的例子中<em class="mi"> '~/kvm_project/' </em>。当要求删除所有内容时，键入<em class="mi">‘yes’</em>。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="11e7" class="nk jv iq ng b gy nl nm l nn no">$ terraform destroy</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="73cd" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">8.供应和流程编排</h1><p id="9489" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="bccb" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本章将涵盖云技术的不同方面，例如服务器的自动创建(也称为配置)，以及组合不同的虚拟机来创建单个服务(一种编排形式)。这将通过一个示例来完成，在该示例中，总共将创建三台虚拟机。两台机器将提供一个web服务，而一台机器将对此服务的请求进行负载平衡。这意味着所有请求都将通过带有负载均衡器的机器，然后负载均衡器将决定以循环方式处理请求的机器。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi os"><img src="../Images/3efb3f9f3cece169a5cee0e75e9d4877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qADuj21Ohjw9QvZb"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><em class="ms">图4 —配置多个虚拟机的架构(使用Archi制作)</em></figcaption></figure><p id="13d6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">见上图架构。这是第2章中使用的架构的变体，但显示了更多关于我们当前情况的信息。可以看出，目标是用户(学生)或任何其他人都可以向客户机发送HTTP请求。该请求将首先在您机器的网络接口卡上可用。然后，网卡将根据数据包必须发送到的请求目的地进行搜索。在虚拟机管理程序的帮助下，硬件应该已经知道目标网络，因为它在主机的NIC和虚拟机管理程序的虚拟网络接口之间创建了所谓的“桥”。在此网桥上，将启用地址转换(NAT ),以便可以从主机网络访问虚拟机。此外，网桥将充当域名解析(DNS)的中间媒介，并使用动态主机配置协议(DHCP)为虚拟机提供ip地址。在本章中，我们将尝试通过Terraform代码提供所有这些来实现这一点。这将展示一个很好的例子，说明如何用一个简单的负载平衡例子来使用Terraform创建这样的云基础设施。</p><p id="5db0" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本章的第一节将介绍如何配置在引导时运行服务器的虚拟机。相同的典型程序将用于测试虚拟机。之后，在第二部分中，将讨论更多关于libvirt提供的虚拟网络，其中将创建自定义桥接网络。第三、第四和第五节将讲授如何使用可以从一个集中位置重用的模块，目的是使配置更易于管理。最后，第六部分将结合所有信息来创建多个虚拟机，这些虚拟机对典型服务进行负载平衡。</p><p id="f744" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">要遵循本章中的说明，先决条件是成功完成第7章，因为在本章中，我们将在该章中创建的代码的基础上进一步构建。我们将在这些文件中添加一些代码或移动上述文件。</p><p id="01ab" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">为服务器配置虚拟机<br/> </strong>为了能够创建本章的最终目标，即负载平衡的典型服务，如果机器中的典型服务器被自动创建并运行，将会非常有用。这样，我们就不必登录虚拟机来启动服务器。为了实现这一点，必须在<em class="mi"> cloud_init.cfg </em>文件中进行一些编辑。我们将添加一些软件包，这些软件包是典型服务器安装和运行所需要的，但我们也将在安装后添加配置来运行服务器。</p><p id="cd8b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.编辑<em class="mi"> cloud_init.cfg </em>和下面的<strong class="ku ir"> yaml </strong>配置。这将尝试在计算机创建后安装软件包。这个功能之前在第7.8章展示过，git安装在虚拟机上。注意，我们添加了python wget，这两个程序用于安装PiCalc服务。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f7e0" class="nk jv iq ng b gy nl nm l nn no"># cloud-init configuration<br/># install packages<br/>packages:<br/> — qemu-guest-agent<br/> — git<br/> — python<br/> — wget</span></pre><p id="3981" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.为了在安装后启动服务器，我们必须运行一些<em class="mi"> bash </em>命令。幸运的是，<em class="mi"> cloud init </em>也能做到这一点。也添加下面的配置。如你所见，这将运行我们在第7.8章中使用的相同命令来创建PiCalc服务器。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="b45f" class="nk jv iq ng b gy nl nm l nn no"># cloud-init configuration<br/># run command after boot<br/>runcmd:<br/> — [“cd”, “/home/terraform_guest”]<br/> — [“git”, “clone”, “https://github.com/krebsalad/PiCalcPy.git"]<br/> — [“cd”, “PiCalcPy”]<br/> — [“python”, “install_picalc.py”]<br/> — [“python”, “run.py”, “mode=server”,”&amp;”]</span></pre><p id="e1fa" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">这些附加功能应该足以在服务器启动时自动运行它。通过在项目中初始化Terraform并应用配置来测试这一点。当创建的机器启动时，步骤I中的包将被安装。完成后，服务器的安装应该会自动开始，之后它将会运行。如果您想在启动之前看到所有安装的输出，您可以使用下面的命令进入虚拟机的控制台。(建议为此启动新的终端)。如前所示，第一个命令将列出您系统上的机器。记下您要登录的机器的id，并用机器的id替换“<em class="mi">虚拟控制台”</em>后面的数字。现在您将能够看到安装的输出。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="d3be" class="nk jv iq ng b gy nl nm l nn no">$ virsh list — all</span><span id="5ee1" class="nk jv iq ng b gy nq nm l nn no">$ virsh console <strong class="ng ir">2</strong></span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/3c01fb1d9720f065df2a0cb9f5ab3ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/0*RlTT3P5HBdOAz6eH"/></div></figure><p id="bb56" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">安装完成后，通过从CLI或主机浏览器向IP地址发送HTTP请求来测试服务器。您可以使用'<strong class="ku ir"><em class="mi">virsh net-DHCP-leases default</em></strong>'命令找到您可以找到的ip。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="eef7" class="nk jv iq ng b gy nl nm l nn no">$ curl VM_Guest_ip:8080/PiCalc/100</span></pre><p id="3910" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">完成服务器测试后，请确保在继续下一步操作之前销毁已创建的基础架构，因为我们将构建更改更多的配置。</p><p id="014b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">创建libvirt桥接网络<br/> </strong>在本节中，将使用libvirt和Terraform创建一个虚拟桥接网络。网桥是一种网络设备，能够将多个通信网络组合成一个网络。网络设备将用于为我们将要创建的虚拟机提供IP地址。这将使用DHCP来完成。注意下面的草图，在这里可以找到本节将要创建的场景。这里可以看到有一个虚拟网络和一个连接到该网络的客户机。网桥将在给定的范围内提供一个IP地址给toe机。网桥可以通过主机与外部网络通信。使用NAT可以做到这一点。外部的所有通信都将虚拟网络视为主机。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ou"><img src="../Images/caf39fab103fb3fc405275ff642ddbf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/0*glY47edAUGLeBlI8"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><em class="ms">图5 —用图纸io制作的桥接网络</em></figcaption></figure><p id="f55d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">到目前为止，我们一直使用libvirt提供的<em class="mi">‘默认’</em>网络。该网络也是一个基于NAT的带DHCP的桥接网络。我们将基于<em class="mi">【默认】</em>网络进行配置，目的是在下一节深入探讨之前，了解更多相关信息。</p><p id="6716" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">libvirt网络是使用XML文件定义的。XML的语法要求你按照下面的<strong class="ku ir"> &lt; /section &gt;来定义节。</strong>注意，开头的/是用来结束标签的。如果不存在，下面的所有部分将成为该部分的成员。要结束这种行为，重复该部分并关闭它也是可行的。例如:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="df95" class="nk jv iq ng b gy nl nm l nn no">&lt;<strong class="ng ir">section</strong>&gt; arguments &lt;<strong class="ng ir">/section</strong>&gt;</span></pre><p id="f017" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">幸运的是，libvirt会在我们的语法中寻找错误，这将有助于调试我们配置中的错误。通过运行以下命令查看默认网络的配置。这将打印网络的配置。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f0f8" class="nk jv iq ng b gy nl nm l nn no">$ virsh net-dumpxml default</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/c3406fa78328e16abf4641b01c0ab41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/0*3nP87S3WQX1QEXd3"/></div></figure><p id="f840" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">该配置采用XML格式。复制输出，因为我们将使用此配置来创建我们自己的网络。在项目目录中创建一个名为'<em class="mi">lib virt _ network _ config . XML '</em>的新文件，并粘贴从上一步复制的<em class="mi"> 'default' </em>网络的配置。该文件将用于定义新网络。我们将不得不编辑一些值，以便它适用于我们的新网络。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="b741" class="nk jv iq ng b gy nl nm l nn no">$ nano ~/kvm_project/libvirt_network_config.xml</span></pre><p id="773b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">我们必须改变的第一个XML标记是网络的名称。这是由标记'<em class="mi"> &lt;名&gt;和'&lt;名/ &gt;'之间的。</em>将名称<em class="mi">‘默认’</em>改为<em class="mi">‘典型_网络’。</em>该行应如下所示</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="9a7c" class="nk jv iq ng b gy nl nm l nn no">&lt;name&gt;picalc_net&lt;/name&gt;</span></pre><p id="fef5" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">现在完全移除<uuid>标签。这个标签由libvirt在创建网络时生成。</uuid></p><p id="6b1c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><em class="mi"> &lt;转发模式= 'nat' &gt; </em>标签不需要更改。这将为我们的网络提供网络地址转换(NAT)。这是与我们主机中的其他虚拟网络通信所必需的，因此也需要能够与互联网通信。</p><p id="036b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><em class="mi"> &lt;桥名..&gt; </em>必须改。网桥是网络接口，所有进出网络的数据包都要经过它。需要更改的选项是<em class="mi"> 'name=' </em>选项，因为它用于识别桥梁，在您的机器中应该是唯一的。这将不得不从<em class="mi">【virbr 0】</em>改变，例如<em class="mi">【virbr 1】</em>。除了这个选项之外，还有“标签上的<em class="mi">‘STP =’。确保此选项打开，因为它有助于防止网络中的任何环路，而且还会让数据包选择最可靠的路径到达其目的地。我们不需要改变这个选项。</em></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="bb24" class="nk jv iq ng b gy nl nm l nn no">&lt;bridge name=’virbr1' stp=’on’ delay=’0'&gt;</span></pre><p id="453b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><em class="mi"> &lt; mac地址… &gt; </em>标签用于在机器级别识别虚拟网络接口。地址本身必须是唯一的。这意味着我们从默认地址复制的mac地址也必须改变。将mac地址更改为有效的mac地址。注意下面的例子。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="7d4b" class="nk jv iq ng b gy nl nm l nn no">&lt;mac address=’52:54:00:6c:3c:01'/&gt;</span></pre><p id="7575" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><em class="mi"> &lt; ip地址… &gt; </em>标签用于设置网络接口的ip地址。这个IP应该是网络中机器的网关地址。此外，网络掩码必须是有效的掩码。在我们的例子中，我们将使用与默认网络相同的网络掩码，即<em class="mi"> /24，</em>，但是我们将把网络的子网改为网络<em class="mi"> 192.168.180.0 </em>。按如下方式更改标签。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="8e39" class="nk jv iq ng b gy nl nm l nn no">&lt;ip address= ‘192.168.180.1’ netmask=’255.255.255.0'&gt;</span></pre><p id="25e2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">如您所见，在IP地址标记中还有子成员标记<em class="mi"> &lt; dhcp &gt; </em>。这个标签将为我们定义的网络中的所有客户端提供一个IP地址。重要的是，该标签中的范围是我们定义的子网内的有效地址。在我们的例子中，这将如下所示。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="bf96" class="nk jv iq ng b gy nl nm l nn no">&lt;dhcp&gt;<br/>   &lt;range start=’192.168.180.2' end=’192.168.180.254'/&gt;<br/>&lt;/dhcp&gt;</span></pre><p id="1f95" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">最后，我们将配置一个<em class="mi"> </em> DNS服务器。这是必需的，因为我们主机中的虚拟网络将无法解析域地址，因为它隐藏在网桥接口之后。幸运的是，接口本身就在我们的主机中，可以找到DNS服务器。这意味着我们网络中的客户端将能够通过简单地使用网络接口来解析域名。我们唯一需要配置的是来自虚拟网络中客户端的解析请求通过接口传递。这是通过将我们的网络接口IP定义为DNS服务器来实现的。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="c7bd" class="nk jv iq ng b gy nl nm l nn no">&lt;dns enable=’yes’/&gt;</span></pre><p id="5083" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">现在配置已经完成。使用以下命令保存文件、定义并启动网络。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="8110" class="nk jv iq ng b gy nl nm l nn no">$ virsh net-define ~/kvm_project/libvirt_network_config.xml</span><span id="7719" class="nk jv iq ng b gy nq nm l nn no">$ virsh net-start picalc_net</span><span id="32eb" class="nk jv iq ng b gy nq nm l nn no">$ virsh net-list — all</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/1f006b9160f6d3b3ce48cab04b25d97b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*uQcSsTQO2l9euW0l"/></div></figure><p id="6584" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">为了测试网络，您可以使用项目'<em class="mi"> ~/kvm_project' </em>创建一个虚拟机。但是在初始化之前，必须在Terraform配置中进行一些更改，以便客户机的网络接口连接到我们称为“picalc_net”的虚拟网络。这在第7章步骤VII中有简要讨论。要更改配置中的网络，请编辑<em class="mi"> 'libvirt.tf' </em>文件，并将<em class="mi"> 'libvirt_domain' </em>资源中<em class="mi"> 'network_interface' </em>下的<em class="mi">' network _ name = " default " '</em>更改为'<em class="mi">network _ name = " picalc _ net "</em>'。</p><p id="5a56" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">最后，初始化并应用Terraform配置。创建客户机时。运行下面的命令来获取DHCP租用的IP。租用的IP应该在之前定义的范围内，即<strong class="ku ir"> 192.168.180.2/24 </strong>到<strong class="ku ir"> 192.168.180.254/24。</strong></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="8eb1" class="nk jv iq ng b gy nl nm l nn no">$ virsh net-dhcp-leases picalc_net</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/d80c2a359629e575b547cf696f2e6601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/0*Mk8tVRxIfeguFlxk"/></div></figure><p id="2249" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">完成测试后，确保用Terraform毁坏机器。不要删除网络配置文件，因为这将在下一节及以后的内容中用到。</p><p id="e7e9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">要停止正在运行的libvirt网络，请运行以下命令。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="2b5d" class="nk jv iq ng b gy nl nm l nn no">$ virsh net-destroy picalc_net</span></pre><p id="1177" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">要删除非活动的现有网络，请运行以下命令。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="11ff" class="nk jv iq ng b gy nl nm l nn no">$ virsh net-undefine picalc_net</span></pre><p id="9e55" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">要搜索现有的活动或非活动网络，请运行以下命令。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="e81a" class="nk jv iq ng b gy nl nm l nn no">$ virsh net-list — all</span></pre><p id="8519" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">为libvirt网络<br/> </strong>创建定制的Terraform模块在本章中，Terraform将在最后一章中用于创建相同的网络。这样可以使用Terraform管理网络的生命周期。terraform-provider-libvirt确实提供了libvirt网络资源，但自2019年10月起，它不支持将静态主机用于DHCP，我们将需要提供负载平衡的PiCalc服务。</p><p id="d767" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">为了能够从文件创建网络并管理其生命周期，我们必须创建一个模块。模块是放置Terraform配置文件的目录。一个模块需要至少一个带有<strong class="ku ir">的文件。tf' </strong>扩展。然后，通过调用目录，可以从另一个Terraform配置文件中调用该模块。</p><p id="edc9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在您的项目中创建一个目录“/<em class="mi">modules/’</em>，然后在modules目录中创建一个名为“<em class="mi"> /libvirt_picalc_network/ </em>”的新模块目录。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="0045" class="nk jv iq ng b gy nl nm l nn no">$ mkdir -p ~/kvm_project/modules/libvirt_picalc_network/</span></pre><p id="b69a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">将我们在上一章(8.2)中创建的网络配置XML文件移动到这个新目录中。我们将使用这个网络配置文件从Terraform代码创建相同的网络。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="95d1" class="nk jv iq ng b gy nl nm l nn no">$ mv ~/kvm_project/libvirt_network_config.xml ~/kvm_project/modules/libvirt_picalc_network/libvirt_network_config.xml</span></pre><p id="c88e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在“<em class="mi">/lib virt _ pi calc _ network/</em>”目录下添加并编辑一个名为“<em class="mi">pi calc _ net . TF”</em>的新文件。该文件将包含定义和运行网络所需的配置，但也会在收到指示时销毁和取消定义网络。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="fa85" class="nk jv iq ng b gy nl nm l nn no">$ nano ~/kvm_project/modules/libvirt_picalc_network/picalc_net.tf</span></pre><p id="ee65" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">添加下面的代码。这是为了确保在创建网络之前libvirt正在运行。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="c507" class="nk jv iq ng b gy nl nm l nn no"># make sure qemu is running<br/>provider <strong class="ng ir">“libvirt”</strong> {<br/> uri = “qemu:///system”<br/>}</span></pre><p id="457e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">为了让terraform在调用<em class="mi">‘apply’</em>或<em class="mi">‘destroy’</em>时执行所需的调用，我们必须创建一个资源。为此，Terraform提供了一个名为<em class="mi">‘null _ resource’</em>的资源，该资源有一个Terraform将管理的唯一ID。在资源中添加了一个<em class="mi">【本地执行】</em>类型的<em class="mi">【供应】</em>。这是一个有用的函数，可以用来在本地执行命令。还有选择使用哪个解释器的选项。我们将使用标准的<em class="mi"> '/bin/bash' </em>来调用一些virsh命令。请注意，有两个置备程序。其中一个供应器将在<em class="mi">‘地形应用’</em>运行时运行，第二个供应器将在<em class="mi">‘地形破坏’</em>运行时运行。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="b3b9" class="nk jv iq ng b gy nl nm l nn no"># let terraform manage the lifecycle of the network<br/>resource <strong class="ng ir">“null_resource” “picalc_network”</strong> {<br/> <br/> # when terraform apply<br/> provisioner <strong class="ng ir">“local-exec”</strong> {<br/> command = “”<br/> interpreter = [“/bin/bash”, “-c”]<br/> }</span><span id="0472" class="nk jv iq ng b gy nq nm l nn no"># when terraform destroy<br/> provisioner <strong class="ng ir">“local-exec”</strong> {<br/> when = “destroy”<br/> command = “”<br/> }<br/>}</span></pre><p id="1e07" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在应用terraform配置时使用的置备程序中添加以下命令。这是一个单行命令，它结合了用于定义和启动libvirt网络的多个命令。<em class="mi">'</em><strong class="ku ir"><em class="mi">&amp;&amp;'</em></strong>表示后面的命令只有在前面的命令成功时才会执行。使用的命令在第8.2章中讨论。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="9f26" class="nk jv iq ng b gy nl nm l nn no">command = “virsh net-define ${path.module}/libvirt_network_config.xml &amp;&amp; virsh net-autostart picalc_net &amp;&amp; virsh net-start picalc_net”</span></pre><p id="b219" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">现在添加一些命令来破坏网络。同样，这些是在第8.2章中使用的命令，用于取消现有网络的定义，但现在在一行中。使用下面的代码就可以做到这一点。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="ed99" class="nk jv iq ng b gy nl nm l nn no">command = “virsh net-undefine picalc_net &amp;&amp; virsh net-destroy picalc_net”</span></pre><p id="33a6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">保存配置文件。项目的最终结构应该如下所示</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/b0d391cddbcb2ce976bc23af7794d7ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/0*jJW7UGDT-Q9CDVN8"/></div></figure><p id="9dfc" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">为了测试模块，我们可以简单地在模块的目录中初始化并应用terraform。这不会对项目的配置产生任何影响。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="18dd" class="nk jv iq ng b gy nl nm l nn no">$ cd ~/kvm_project/modules/libvirt_picalc_network</span><span id="b0e4" class="nk jv iq ng b gy nq nm l nn no">$ terraform init</span><span id="3732" class="nk jv iq ng b gy nq nm l nn no">$ terraform apply</span></pre><p id="f527" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">验证网络是否是使用以下命令创建的</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="751e" class="nk jv iq ng b gy nl nm l nn no">$ virsh net-list -–all</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/0dd42129d127bac9a3627f82fe488994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/0*BP2G4Qup3c4YBzp7"/></div></figure><p id="77f8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">如果您想在这个网络上测试虚拟机，请进入项目目录init并应用更改。注意虚拟机的网络接口的网络名应该是<strong class="ku ir"> <em class="mi"> picalc_net </em>。</strong>这也在上一章讨论过，应该已经配置好了。</p><p id="3557" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">要破坏网络，调用目录'<em class="mi">lib virt _ pical c _ network '</em>中的'<em class="mi"> terraform destroy' </em>。在本章中，我们只从它的目录中创建了模块。但是也可以从不同的文件中调用它。这种方法将在后面讨论。</p><p id="4d3a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">使用静态IP配置客户机<br/> </strong>最终目标是创建一个多虚拟机服务，其中一个虚拟机对发送给其他虚拟机的请求进行负载平衡。为此，负载平衡机器需要知道所述机器的IP地址。您可能已经注意到，IP地址是由DHCP服务器在给定的范围内随机给出的。这意味着，即使我们为一台机器提供负载平衡服务，它也不会立即知道它应该为哪个IP地址提供负载平衡器，因此我们必须手动搜索IP地址并将其连接到负载平衡器。</p><p id="4894" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">幸运的是，DHCP可以根据MAC地址为主机分配固定的IP地址。在本章中，我们将使用这种行为来静态设置我们要配置的虚拟机的IP地址，方法是在创建虚拟机之前分配MAC地址。下面的草图显示了我们想要配置的情况。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ou"><img src="../Images/872617c6c469f220adc60b0fc00e33e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/0*4cFVS0OTfYtmmcwr"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><em class="ms">图6 —基于使用draw.io制作的MAC地址的DHCP静态主机</em></figcaption></figure><p id="6c8d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">使用DHCP中的主机功能，我们可以让具有固定MAC地址的客户端获得一个预定义的IP。在资源调配的情况下，这意味着如果我们总是希望虚拟机获得相同的IP地址，则应该在创建虚拟机时静态设置MAC地址。本章将通过在Terraform代码中配置MAC地址来解决这个问题。</p><p id="3d4e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">要正确完成这一部分，需要了解如何创建libvirt网络。注意第8.2和8.3章中的这些主题。假设使用第8.3章中创建的相同配置。</p><p id="581d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.编辑'<em class="mi">lib virt _ network _ config . XML '</em>文件。</p><p id="827d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.在DHCP标记中添加下面的粗体行。这将确保IP地址<em class="mi"> 192.168.180.102，</em>只租给与给定MAC地址匹配的机器，在本例中是<strong class="ku ir"><em class="mi">52:54:00:6c:3c:02</em></strong>。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f7a8" class="nk jv iq ng b gy nl nm l nn no">&lt;<strong class="ng ir">dhcp</strong>&gt;<br/>   &lt;<strong class="ng ir">range</strong> start=’192.168.180.2' end=’192.168.180.254'/&gt;<br/>   &lt;<strong class="ng ir">host</strong> mac=’52:54:00:6c:3c:02' ip=’192.168.180.102'/&gt;<br/>&lt;/<strong class="ng ir">dhcp</strong>&gt;</span></pre><p id="8b6f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.虚拟机也需要设置为上面的MAC地址。这可以在用于创建虚拟机的terraform配置文件中完成。在这个文档中，直到现在，它都被称为<strong class="ku ir"> libvirt.tf </strong>。编辑该文件，并将下面的粗体行添加到'<em class="mi"> libvirt_domain' </em>模块中的'<em class="mi"> network_interface' </em>下。此处添加的mac地址应该与上一步添加的主机MAC地址相匹配。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="c79c" class="nk jv iq ng b gy nl nm l nn no">network_interface {<br/>network_name = “picalc_net”<br/>mac = “52:54:00:6c:3c:02”<br/>}</span></pre><p id="57ca" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.现在测试项目。确保我们在上一章创建的<em class="mi"/><strong class="ku ir"><em class="mi"/></strong>正在运行。之后，通过在主项目工作区中进行初始化和规划，使用虚拟机测试该配置。</p><p id="93ca" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.使用以下命令验证IP是否按预期租用。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="8347" class="nk jv iq ng b gy nl nm l nn no">$ virsh net-dhcp-leases picalc_net</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi oy"><img src="../Images/96116bd952f206490b25bec146b03a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8Ka8DJeHmwI0DT8z"/></div></div></figure><p id="f0c6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">使用模块和变量<br/> </strong>本章将描述如何创建一个用于供应虚拟机的Terraform模块。目标是创建一个模板，通过简单地改变值就可以创建不同的ubuntu机器。通过使用变量，可以重复使用模块，并从一个集中的位置设置它们。</p><p id="f4f2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在本章中，我们将使用前面章节中使用的'<strong class="ku ir"> libvirt.tf </strong>'文件来创建虚拟机。我们将把这个文件做成一个可重复使用的模块。因此，在进行本部分之前，必须完成本章中的所有说明，以便能够准确地遵循指南。</p><p id="4d36" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">创建一个名为'<em class="mi"> ubuntu-module' </em>的新模块目录。该目录将包含创建虚拟机所需的文件。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="5dd7" class="nk jv iq ng b gy nl nm l nn no">$ mkdir -p ~/kvm_project/modules/ubuntu-module/</span></pre><p id="5350" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">将文件'<em class="mi"> libvirt.tf' </em>移动到模块目录。我们将改变<em class="mi">‘lib virt . TF’</em>文件，使其可重复使用。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="fce1" class="nk jv iq ng b gy nl nm l nn no">$ mv ~/kvm_project/libvirt.tf ~/kvm_project/modules/ubuntu-module</span></pre><p id="b7b0" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">kvm_project的树形结构应该如下所示:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/9b40cdb6bd7ccda47d73b4fd64e3bddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/0*Idc4-_rKbnmL-gHi"/></div></figure><p id="40b0" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">用你最喜欢的编辑器编辑<em class="mi"> 'libvirt.tf' </em>文件。我们将从添加变量开始。变量用于设置值。除了文件本身之外，这些变量可以从其他Terraform模块中设置。也可以从其他<em class="mi"> ' </em> <strong class="ku ir"> <em class="mi">来做。tf </em> </strong> <em class="mi"> ' </em>文件。注意下面的代码。这段代码定义了一个名为<em class="mi">‘机器名’</em>的变量。我们定义的变量属于字符串类型。这可以使用'<em class="mi">类型'</em>参数来定义。当需要许多变量时，description参数非常有用。它应该描述变量的用途。将下面的变量定义添加到'<em class="mi"> libvirt.tf' </em>的顶部。该变量将用于设置文件的各种值。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="0e29" class="nk jv iq ng b gy nl nm l nn no">#libvirt.tf<br/>variable <strong class="ng ir">“machine_name”</strong> {<br/>}</span></pre><p id="13f4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">当重用一个模块时，变量是有用的，因为有些值需要是唯一的，这样模块才能被重用。在<em class="mi"> 'libvirt.tf' </em>文件中，许多值必须使用变量进行更改。我们将在下面介绍所有这些在文件中必须是唯一的值。</p><p id="f7ef" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">首先，从<em class="mi">‘lib virt _ pool’</em>开始。创建多台计算机时，池的名称必须是唯一的。此外，池保存其图像的目录必须是唯一的。要使用一个变量<em class="mi">‘var’</em>自变量被使用。这提供了对当前模块中所有变量的访问。使用它，我们可以从不同的文件中设置值。以下面的例子为例。如果变量<em class="mi">‘machine _ name’</em>在初始化时被设置为’<em class="mi">Ubuntu _ 1’</em>，那么池的名称将是’<em class="mi">Ubuntu _ 1 _ pool’</em>，路径将是’<em class="mi">/lib virt _ images/Ubuntu _ 1 _ pool’</em>。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="35f0" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“libvirt_pool” “ubuntu”</strong> {<br/> name = “${var.machine_name}_pool”<br/> type = “dir”<br/> path = “/libvirt_images/${var.machine_name}_pool/”<br/>}</span></pre><p id="cbb5" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在<em class="mi">‘lib virt . TF’</em>文件中必须更改的第二个资源是<em class="mi">‘lib virt _ volume’</em>。注意下面的例子。唯一需要动态的值是<em class="mi">名称</em>值，因为它用于管理机器的生命周期，并且是图像文件的名称。根据变量进行更改将有助于防止名称冲突。我们还将更改路径值。这是因为我们移动了模块的目录。正因为如此，<em class="mi"> path.module </em>函数不会返回我们下载的路径。如下所示更改这些值</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="199e" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“libvirt_volume” “image-qcow2”</strong>{<br/> name = “${var.machine_name}_image.qcow2”<br/> pool = libvirt_pool.ubuntu.name<br/> source = “${path.module}/../../downloads/bionic-server-cloudimg-amd64.img” <br/> format = “qcow2”<br/>}</span></pre><p id="7912" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第三个必须更改的资源是<em class="mi">‘lib virt _ domain’</em>。注意下面的例子。该名称应再次更改，因为它必须是唯一的。可以为此资源创建新变量。例如，创建用于设置内存的变量。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="27ee" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“libvirt_domain” “test-domain”</strong> {<br/>   name = “${var.machine_name}_domain”<br/>   memory = “1024”<br/>   vcpu = 1<br/>   …</span></pre><p id="6f1b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在编辑更多组件之前，我们将创建三个新变量，用于设置<em class="mi">‘lib virt _ domain’</em>的网络接口和机器的用户配置。如上一章所述，我们可以设置网络接口的MAC地址，以便我们的机器获得一个固定的IP地址。为了使多台机器都可以这样做，有一个变量来设置MAC地址和网络是很有用的。除了网络接口的变量之外，能够为虚拟机设置不同的用户配置也很重要。为此，我们将使用变量<em class="mi">‘用户数据路径’。</em>添加以下变量。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="2cb1" class="nk jv iq ng b gy nl nm l nn no">variable <strong class="ng ir">“network_name”</strong> {<br/>}</span><span id="748d" class="nk jv iq ng b gy nq nm l nn no">variable <strong class="ng ir">“mac_address”</strong> {<br/>}</span><span id="8eaa" class="nk jv iq ng b gy nq nm l nn no">variable <strong class="ng ir">“user_data_path”</strong>{<br/>}</span></pre><p id="af1b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">现在使用两个新添加的变量来设置<em class="mi">【网络接口】</em>的<em class="mi">【网络名称】</em>和<em class="mi">【MAC】</em>，这两个变量可以在<em class="mi">【lib virt _ domain】</em>下找到。注意下面的例子</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="ea6d" class="nk jv iq ng b gy nl nm l nn no">network_interface {<br/>   network_name = “${var.network_name}”<br/>   mac = “${var.mac_address}”<br/>}</span></pre><p id="efb3" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><em class="mi">‘用户数据路径’</em>变量必须指向<em class="mi">‘cloud _ init . CFG’</em>文件。为此，我们必须更改用户数据文件的加载位置，以便可以从可变路径加载它。注意下面的例子</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="c465" class="nk jv iq ng b gy nl nm l nn no">data <strong class="ng ir">“template_file” “user_data”</strong> {<br/>   template = file(“<strong class="ng ir">${var.user_data_path}</strong>”)<br/>}</span></pre><p id="048a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">最后，保存<em class="mi"> 'libvirt.tf' </em>文件并关闭。该模块可以重复使用而不会产生名称冲突。为了使用该模块，将在项目的主目录中创建一个新文件。该文件将用于调用多个模块，因此将被命名为<em class="mi"> main.tf </em>。进入目录并创建文件。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="6b47" class="nk jv iq ng b gy nl nm l nn no">$ cd ~/kvm_project/</span><span id="4fb7" class="nk jv iq ng b gy nq nm l nn no">$ nano main.tf</span></pre><p id="efd9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在这个文件中，我们将调用模块并设置我们之前添加的变量。注意下面的例子。我们在前面章节中用来设置mac地址和网络的相同值在这里被重复使用。我们还将机器名设置为“<em class="mi"> ubuntu_1”。</em>云初始化的路径在这个文件的目录中。这意味着我们可以使用'<em class="mi"> path.module' </em>函数来获取我们当前的目录。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f790" class="nk jv iq ng b gy nl nm l nn no">module <strong class="ng ir">“ubuntu-module-1”</strong> {<br/>   # load the module<br/>   source = “./modules/ubuntu-module/”<br/>   # set the variables<br/>   machine_name = “ubuntu_1”<br/>   network_name = “picalc_net”<br/>   mac_address = “52:54:00:6c:3c:02”<br/>   user_data_path = “${path.module}/cloud_init.cfg”<br/>}</span></pre><p id="2c44" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">确保添加后保存文件。项目的最终结构应该如下所示。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/5d032c86b87edb5a58ed3ad9ab5fc345.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/0*2WfhksS5xY-IraPg"/></div></figure><p id="3ec5" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在'<strong class="ku ir"> main.tf' </strong>文件所在的项目工作区中，通过运行'<em class="mi"> terraform init' </em>和<em class="mi"> 'terraform apply' </em>来测试代码。这应该会创建一个新的虚拟机。结果应该类似于上一章，其中创建的机器根据给定的MAC地址获得一个租用的IP。这当然只有在网络已经运行的情况下才有效。完成测试后，确保摧毁基础设施。此外，销毁并取消定义libvirt网络，因为从现在开始我们也应该能够从'<em class="mi"> main.tf' </em>文件创建网络。</p><p id="dd42" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">编排示例:负载平衡<br/> </strong>在本章中，在第8.3章中创建的名为<em class="mi"> 'libvirt_picalc_network' </em>的模块和在第8.5章中创建的名为<em class="mi"> 'ubuntu_module' </em>的模块将被合并，以创建一个单独的picalc服务。ubuntu模块将用于创建三个独立的虚拟机，它们将被放置在同一个网络中。其中一个虚拟机将作为其他两个机器的负载平衡器，它将接收针对典型服务器的HTTP请求，然后决定哪个服务器将以循环方式处理该请求。注意下面的草图和解释。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/6693a56ddbfa25082e7f9fcc1e8a2221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/0*OlCNha0TdbsdUEew"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><em class="ms">图7 —负载平衡器网络接口配置(使用draw.io制作)</em></figcaption></figure><p id="a593" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">为了能够为运行PiCalc服务器的虚拟机提供负载平衡服务，使用静态IP地址将非常有用。第8.4章讨论了使用DHCP协议实现这一点的方法。在这里，主机在创建之前被设置为MAC地址，以便它在网络上可用时获得固定的IP地址。这也可以在上面的草图中看到，并将在所有机器上完成。</p><p id="34c0" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">负载平衡服务将从名为<em class="mi">‘main . TF’</em>的单一Terraform配置文件中运行。这个文件是在上一章中创建的。在开始操作前清除其内容。新增加的内容将是对<em class="mi">‘lib virt _ picalc _ network’</em>的一次调用以创建网络，对<em class="mi">‘Ubuntu-module’</em>的三次调用以创建三个虚拟机。除了主文件中的这些附加内容，我们将创建一个特定于负载平衡器的新用户配置文件，以便在创建时启动其服务。这将在一个名为<em class="mi">‘cloud _ init _ lb . CFG’</em>的新文件中完成。</p><p id="e28b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.编辑<em class="mi"> 'main.tf' </em>并清除其内容。</p><p id="fe11" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.添加网络模块定义，以便在同一个'<em class="mi"> main.tf' </em>文件中创建和管理网络。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="3b29" class="nk jv iq ng b gy nl nm l nn no"># run the network<br/>module <strong class="ng ir">“picalc-network-module”</strong> {<br/>   source = “./modules/libvirt_picalc_network/”<br/>}</span></pre><p id="8892" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.使用下面的示例代码添加这三个模块。它们将用于创建虚拟机。第一个模块将创建一个虚拟机，我们在其中运行一个脚本来实现负载平衡。这将在下面的步骤中讨论。第二个和第三个模块将创建一个典型的服务器。这是可能的，因为我们当前的用户数据配置，<em class="mi"> cloud_init.cfg，</em>被配置为在启动时设置一个典型服务器，如第8.1章中所创建的。这也是负载平衡器的配置文件不同的原因，因为它不需要在启动时运行典型服务器。除了用户配置文件，请注意添加到每台机器的mac地址。这些地址当然可以是任何其他有效的mac地址。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="60f2" class="nk jv iq ng b gy nl nm l nn no"># load balancer<br/>module <strong class="ng ir">“picalc-lb”</strong> {<br/>   # load the module<br/>   source = “./modules/ubuntu-module/”<br/>   # set the variables<br/>   machine_name = “loadbalancer”<br/>   network_name = “picalc_net”<br/>   mac_address = “52:54:00:6c:3c:02”<br/>   user_data_path = “${path.module}/cloud_init_lb.cfg”<br/>}</span><span id="106a" class="nk jv iq ng b gy nq nm l nn no"># picalc server 1<br/>module <strong class="ng ir">“picalc-server-1”</strong> {<br/>   # load the module<br/>   source = “./modules/ubuntu-module/”<br/>   # set the variables<br/>   machine_name = “server_1”<br/>   network_name = “picalc_net”<br/>   mac_address = “52:54:00:6c:3c:03”<br/>   user_data_path = “${path.module}/cloud_init.cfg”<br/>}</span><span id="4e53" class="nk jv iq ng b gy nq nm l nn no"># picalc server 2<br/>module “picalc-server-2” {<br/>   # load the module<br/>   source = “./modules/ubuntu-module/”<br/>   # set the variables<br/>   machine_name = “server_2”<br/>   network_name = “picalc_net”<br/>   mac_address = “52:54:00:6c:3c:04”<br/>   user_data_path = “${path.module}/cloud_init.cfg”<br/>}</span></pre><p id="3ac1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.负载均衡器的虚拟机已经可以用上面的例子创建了。我们只需要创建一个新的<em class="mi"> cloud_init.cfg </em>，它是特定于负载均衡器的，因为我们不希望在机器上运行相同的典型服务器。通过将<em class="mi">‘cloud _ init . CFG’</em>文件复制并粘贴到与<em class="mi">‘cloud _ init _ lb . CFG’</em>相同的目录中来实现。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="b2be" class="nk jv iq ng b gy nl nm l nn no">$ cp ~/kvm_project/cloud_init.cfg ~/kvm_project/cloud_init_lb.cfg</span></pre><p id="8512" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.打开并编辑<em class="mi"> 'cloud_init_lb.cfg' </em>文件。</p><p id="f8b8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.更改<em class="mi"> 'runcmd:' </em>下的部分，以便在启动时创建负载平衡器。使用下面的代码示例来实现这一点。可以看出，与前面的指令使用了相同的PiCalc git存储库。程序的使用方式略有不同。要安装负载平衡器，需要一个额外的'<em class="mi"> lb' </em>选项。此外，要运行服务器，我们必须将模式设置为<strong class="ku ir"> lb </strong>，并使用<strong class="ku ir"> lb_config </strong>选项添加一些配置。下一步中关于<strong class="ku ir"> lb_config </strong>选项的更多信息。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="5c29" class="nk jv iq ng b gy nl nm l nn no"># run command at boot<br/>runcmd:<br/>   - [“cd”, “/home/terraform_guest”]<br/>   - [“git”, “clone”, “https://github.com/krebsalad/PiCalcPy.git"]<br/>   - [“cd”, “PiCalcPy”]<br/>   - [“python”, “install_picalc.py”, “lb”]<br/>   - [“python”, “run.py”, “mode=lb”, “lb_config=      [options]\nbuffer_size=4096\n\n[mappings]\n<strong class="ng ir">80=192.168.180.103:8080,192.168.180.104:8080”, </strong>“&amp;”]</span></pre><p id="b56f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">7.负载平衡器非常容易配置。所使用的负载平衡器称为pumpkin lb<em class="mi">(“Savannah t .，PumpkinLB A simple，fast，pure-python load balancer”，(2019a) </em>，可以使用从github克隆的典型示例进行安装。负载平衡器的工作方式如下。首先可以在<strong class="ku ir">【选项】</strong>标签后面给出一些选项。我们以字节<strong class="ku ir">将缓冲区大小设置为<strong class="ku ir"> 4096 </strong>。</strong>选项后跟随着<strong class="ku ir">【映射】</strong>标签。这需要为传入消息公开一个端口，以及一个或多个IP地址，包括要监听的端口。在我们的例子中，我们需要改变这些来匹配在网络定义中静态配置的IP地址。请按照以下步骤进行。</p><p id="7bb6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">8.打开网络配置，根据步骤III中定义的MAC地址和上一步中的负载平衡器配置添加两台新的静态主机。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="e084" class="nk jv iq ng b gy nl nm l nn no">$ nano ~/kvm_project/modules/libvirt_picalc_network/libvirt_network_config.xml</span></pre><p id="31b2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">9.将下面的粗体标记行添加到您的配置中，以便新添加的主机也能获得DHCP租用的固定IP地址。请注意，添加的IP地址是服务器的IP地址。我们之前已经添加了负载平衡器虚拟机的地址。在任何情况下，请确保主机的MAC地址与步骤III中给出的相应地址匹配，并且主机的IP地址与步骤VII中设置的地址匹配。请注意示意图7中完整的主机表和相应的主机。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="da46" class="nk jv iq ng b gy nl nm l nn no">&lt;dhcp&gt;<br/>   &lt;range start=’192.168.180.2' end=’192.168.180.254'/&gt;<br/>   &lt;host mac=’52:54:00:6c:3c:02' ip=’192.168.180.102'/&gt;<br/>   <strong class="ng ir">&lt;host mac=’52:54:00:6c:3c:03' ip=’192.168.180.103'/&gt;<br/>   &lt;host mac=’52:54:00:6c:3c:04' ip=’192.168.180.104'/&gt;<br/></strong>&lt;/dhcp&gt;</span></pre><p id="7667" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">10.现在，保存文件并退出。</p><p id="f53d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">11.Terraform配置应该可以运行了。但是在运行'<em class="mi"> main.tf </em>'文件之前，确保不存在与我们要创建的域名、网络或池同名的域名、网络或池是非常有用的。通过使用本文档中学习到的各种调试命令来实现这一点。关于这些命令的更多信息也可以在第13章<strong class="ku ir">中找到。故障排除</strong>。此外，如果您的主机有所有可用的资源，因为三台客户机将同时运行，这将非常有用。这应该适用于少于4个内核的情况，但是一些进程交换会发生很多，使它非常慢。在主机是虚拟机的情况下，当有太多的进程交换时，它可能会崩溃。</p><p id="b7c4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">12.进入主工作区<em class="mi"> '~/kvm_project' </em>，运行'<em class="mi"> terraform init </em>，然后运行<em class="mi"> 'terraform plan' </em>，规划配置。您将看到总共创建了13个资源，其中4个用于第一个PiCalc服务器，另外4个用于第二个PiCalc服务器，另外4个用于负载平衡器，最后一个用于libvirt网络。如果你不记得这些资源是什么，请注意第7章。</p><p id="5b27" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">13.通过在主工作区运行<em class="mi">‘terra form apply’</em>来运行配置。当您键入<em class="mi">‘yes’</em>时，基础架构将被创建。</p><p id="9eaa" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">14.在机器被创建并且地形被完成之后继续这里。使用<em class="mi">‘虚拟控制台&lt;n&gt;’</em>启动三个新的终端来监控虚拟机的启动。使用<em class="mi">“虚拟列表—全部”</em>命令，根据控制台的编号更改<em class="mi"> &lt; n &gt; </em>。为创建的每个虚拟机打开多个控制台。在这里，你必须等到机器完全启动。完成后不要按回车键，因为当cloud init安装完成时，您可以看到服务器是否正在运行。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/de6815bba5ecfaadbcd9fd1e36940108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/0*1bTcA4hYIEbLyX9i"/></div></figure><p id="f759" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">15.使用<em class="mi">‘virsh net-DHCP-leases picalc _ net’</em>确保所有机器都获得了ip租约</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi or"><img src="../Images/a66f5ba5d3f595bc0e8c9f96c26eb481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k2-g51e0KPzEJiYn"/></div></div></figure><p id="595e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">16.最后，通过向'<em class="mi">192 . 168 . 180 . 102:80/PiCalc/100</em>'发送HTTP请求来测试PiCalc负载平衡服务。这是我们为负载平衡器设置的iP地址。这样做多次，你会注意到连续请求后返回的IP地址不同。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi or"><img src="../Images/4b9cc29a008cf3e3ca1632a1b6e5af91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lcjOq_hg1WGgiEb-"/></div></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="debd" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">9.正在为docker安装Docker和Terraform提供程序</h1><p id="4f09" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><p id="67ef" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本章解释了Docker provider插件在Terraform中的用法。Docker主要用于互联网上的云服务中，以封装各种应用程序。这使得它成为使用Terraform实现自动化的完美候选，因为docker API很容易获得，并且可以与Docker Swarm和Docker Compose一起使用。(官方)Docker提供者插件使得通过Terraform与Docker引擎交互成为可能。</p><p id="3c4a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">我们将在本章中继续使用相同的主机环境(Ubuntu 18.04)，并假设Go和Git已安装(如前面6.3章所述)。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi pd"><img src="../Images/5299079df3ab4c22b9c914cf75fc44ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MsU59a7-mwucjrQj"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><em class="ms">图8 —静态主机(使用Archi制作)</em></figcaption></figure><p id="306f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">见上图。在本章中，我们将使用Docker provider插件创建3个复制容器。这些容器将由Terraform创建，作为Docker服务运行</p><p id="4461" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">覆盖网络。目标是部署一个docker映像并对其进行水平缩放。容器复制通常用于保持尽可能高的正常运行时间。必须事先创建图像，因为Terraform不提供基于docker文件的图像自动生成。构建我们的架构的过程将包括生成包含一个示例应用程序(例如，PiCalc)的docker映像。接下来，我们将配置和规划我们的Terraform服务来使用这个映像并复制它，并创建一个Docker网络。</p><p id="9204" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">安装docker引擎<br/>我们需要手动添加库，因为Ubuntu的库中没有Docker。</strong></p><p id="bb72" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.打开一个终端模拟器，将官方Docker存储库添加到APT(为此，我们下载Docker公钥，将其添加到APT，然后安装' docker-ce '</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="c4ca" class="nk jv iq ng b gy nl nm l nn no">$ curl -fsSL <a class="ae lv" href="https://download.docker.com/linux/ubuntu/gpg" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/ubuntu/gpg</a> \ | sudo apt-key add -</span><span id="e963" class="nk jv iq ng b gy nq nm l nn no">$ sudo add-apt-repository \</span><span id="15e7" class="nk jv iq ng b gy nq nm l nn no">“deb [arch=amd64] <a class="ae lv" href="https://download.docker.com/linux/ubuntu" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/ubuntu</a> bionic stable”</span><span id="506f" class="nk jv iq ng b gy nq nm l nn no">$ sudo apt update</span><span id="5a24" class="nk jv iq ng b gy nq nm l nn no">$ sudo apt install -y docker-ce</span></pre><p id="6a58" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.启用并启动Docker引擎服务:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="07c6" class="nk jv iq ng b gy nl nm l nn no">$ sudo systemctl enable — now docker</span></pre><p id="8ff8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.验证Docker服务已启动并正在运行</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4a5d" class="nk jv iq ng b gy nl nm l nn no">$ sudo systemctl status docker</span></pre><p id="4401" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">Systemd应该给出关于容器引擎运行的结果:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi pe"><img src="../Images/16805afeec24c42a4eb09ef2118def69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5-3NUhucfwZva7OH"/></div></div></figure><p id="8b47" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.从这里开始，可以启动新的容器，但是在此之前，我们必须配置我们的Terraform用户，使其拥有使用Docker服务的权限。为此，我们必须将我们的用户添加到docker组。</p><p id="b1ba" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.将我们的Terraform用户添加到docker组，让Terraform在没有root用户的情况下使用Docker。将<em class="mi">‘Ubuntu’</em>改为运行Terraform的主机用户。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="0ad1" class="nk jv iq ng b gy nl nm l nn no">$ sudo groupadd docker #in case its not created by default</span><span id="caab" class="nk jv iq ng b gy nq nm l nn no">$ sudo usermod -aG docker ubuntu</span></pre><p id="1191" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.强烈建议注销并重新登录系统(或从当前会话启动新会话)，然后通过检查组的输出来验证用户是否已添加到组中。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="90f1" class="nk jv iq ng b gy nl nm l nn no">$ su — ubuntu</span><span id="ee78" class="nk jv iq ng b gy nq nm l nn no">$ groups</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi pf"><img src="../Images/4d6738c8b4bfe9760ed15758d147e6d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G74LrjUTQ22Puuit"/></div></div></figure><p id="9b48" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">7.验证用户是否被允许运行Docker。为此，将执行一个小的“hello world”测试。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f7bd" class="nk jv iq ng b gy nl nm l nn no">$ docker run hello-world</span></pre><p id="a64f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">这应该输出典型的Docker 'Hello from Docker '文本。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi pe"><img src="../Images/25138be8309f56a52d049b3708504487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fdXYi5JqnVj9D6w9"/></div></div></figure><p id="adeb" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">编译和安装Docker提供程序</strong></p><p id="30de" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.导出我们的路径变量，以防以前没有这样做过。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="75b8" class="nk jv iq ng b gy nl nm l nn no">$ export PATH=$PATH:/usr/lib/go/bin</span><span id="e472" class="nk jv iq ng b gy nq nm l nn no">$ export GOPATH=/usr/lib/go</span></pre><p id="a06f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.根据我们的路径创建源目录。我们将在这些目录中克隆源代码，类似于第6.4章。(如果本章已经完成，目录“terraform-providers”应该已经存在)。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="cd93" class="nk jv iq ng b gy nl nm l nn no">$ sudo mkdir -p $GOPATH/src/github.com/terraform-providers</span><span id="0c0b" class="nk jv iq ng b gy nq nm l nn no">$ cd $GOPATH/src/github.com/terraform-providers</span></pre><p id="76c2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.克隆官方git存储库。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4889" class="nk jv iq ng b gy nl nm l nn no">$ sudo git clone github.com/terraform-providers/terraform-provider-docker.git</span></pre><p id="dedb" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.进入提供者的目录，用下面的命令构建它。在这个makefile中,“make”默认目标安装提供程序。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="2475" class="nk jv iq ng b gy nl nm l nn no">$ cd terraform-provider-docker</span><span id="5b02" class="nk jv iq ng b gy nq nm l nn no">$ sudo make</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi pe"><img src="../Images/3f3d73e0b628df775fb2e3c4a5c7b95c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*me4OnESKB6TJgiZt"/></div></div></figure><p id="33a1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.通过运行验证插件是否已安装。GO可执行路径已经在我们的路径环境中，所以它可以从任何目录直接运行。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="1ac7" class="nk jv iq ng b gy nl nm l nn no">$ terraform-provider-docker -version</span></pre><p id="99e0" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">该命令应该输出一条关于其用法的警告消息:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi pg"><img src="../Images/45b2c35111c846b792cf276deacc4dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tcjm4Y2dyLAszxIh"/></div></div></figure><p id="5ca5" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.将插件符号链接到Terraform插件目录，以便Terraform使用它。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4f7b" class="nk jv iq ng b gy nl nm l nn no">sudo ln -s /usr/lib/go/bin/terraform-provider-docker ~/.terraform.d/plugins/</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="6a3a" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">10.使用Terraform部署Docker示例</h1><p id="59c3" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><p id="3a87" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本章将通过指导用户完成步骤和配置文件，演示Terraform必须通过Docker provider插件提供的一些基本功能。</p><p id="703c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">通过Terraform与Docker进行交互与Terraform的传统用法不同，因为它不再是基础设施即服务，而是直接在运行Terraform的同一台主机上部署容器化的应用程序。如果人们寻求将松散应用程序的部署与分布在多个Terraform模块上的基础设施的其余部分统一起来，或者如果其他Terraform模块依赖于在早期部署或后期部署期间碰巧在Docker容器中的某个应用程序，这是有意义的。</p><p id="619c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">随着Docker在我们的Ubuntu 18.04主机上的安装如第9章所述完成，我们将继续两个例子:</p><ul class=""><li id="74f0" class="ph pi iq ku b kv lq kz lr ld pj lh pk ll pl lp pm pn po pp bi translated">带有默认测试页面的简单容器化Apache web服务器。</li><li id="8392" class="ph pi iq ku b kv pq kz pr ld ps lh pt ll pu lp pm pn po pp bi translated">我们自己生成的映像，它将被初始化为带有副本的Docker服务(因此是自动负载平衡的)。在我们的示例中，一个名为“PiCalc”的NodeJS应用程序将用于分发请求。</li></ul><p id="ee8f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">必须指出的是，在本文档制作时，Terraform没有提供与Docker合成和Docker文件使用的集成。这意味着我们不能基于配置来构建我们的映像。因此，第二个示例我们将直接使用Docker通过Docker Compose构建我们的映像，并使用Terraform运行它。或者，这可以通过使用远程执行或本地执行置备程序来实现，如前面第5.3章所述。我们不会使用它，而是直接使用Docker。</p><p id="af7e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">使用Docker Hub <br/> </strong>构建一个简单的web服务器示例第一个示例演示了实际上只需要很少的配置就可以启动并运行Docker容器，并且所使用的Docker映像可以根据用例用许多其他映像替换。将创建一个类似于第5.3章的资源。</p><p id="3235" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.在Terraform工作目录下创建一个新文件夹，我们称之为‘docker _ web’</p><p id="bdbe" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.进入项目目录，创建一个名为'<em class="mi"> cloud_init.cfg '的新文件。</em></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="c341" class="nk jv iq ng b gy nl nm l nn no">$ cd ~/docker_web/</span><span id="8d39" class="nk jv iq ng b gy nq nm l nn no">$ terraform init</span></pre><p id="9919" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">最后一个命令的输出将通知用户Terraform在当前的空目录中初始化成功，我们准备继续。</p><p id="a7d2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.用你喜欢的编辑器创建一个新的terraform模块，我们称它为‘main . TF ’,因为我们遵循Terraform为最小模块推荐的文件名。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="297b" class="nk jv iq ng b gy nl nm l nn no">$ nano main.tf</span></pre><p id="30d2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.在我们解释时，将下面的代码片段附加到文件中。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="1609" class="nk jv iq ng b gy nl nm l nn no"><strong class="ng ir">#main.tf<br/></strong>provider <strong class="ng ir">“docker”</strong> {<br/>   host = <strong class="ng ir">“unix:///var/run/docker.sock”</strong><br/>}<br/>#…</span></pre><p id="16de" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.首先，我们将提供者设置为运行Docker守护进程的主机。理论上可以使用任何外部docker主机(如Azure、AWS或libvirt虚拟机)，但为了简单起见，我们直接连接到我们的本地Docker守护进程，如第9章所配置的。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="7697" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“docker_image” “httpd”</strong> {<br/>   name = <strong class="ng ir">“httpd:2.4”</strong><br/>}</span><span id="c824" class="nk jv iq ng b gy nq nm l nn no">#prints the used contained ID for demonstration, optional<br/>output <strong class="ng ir">“Docker Image”</strong> {<br/>   value = <strong class="ng ir">“Using ${docker_image.httpd.latest}”</strong><br/>}<br/>#…</span></pre><p id="3cba" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.接下来，我们为包含我们想要使用的应用程序的docker映像定义一个Terraform资源。这里接受的参数与docker run相同。这意味着，如果指定的映像不是本地安装的，它将自动从Docker Hub获取它。对于这个例子，我们使用的是官方的Apache镜像版本2.4。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="5267" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“docker_container” “webserver”</strong> {<br/>   name = <strong class="ng ir">“webserver”</strong><br/>   image = “${docker_image.httpd.latest}”<br/>   count = 1 #we come back to this optional variable later!<br/>   ports {<br/>      internal = <strong class="ng ir">80</strong><br/>      external = <strong class="ng ir">80</strong><br/>   }<br/>}</span></pre><p id="cfbe" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">7.最后，我们使用docker_image资源创建资源来制作Docker容器。我们的docker_image.httpd资源对象的属性latest包含一个带有SHA256 ID的字符串，它表示在命令' $docker images '的输出中看到的图像的名称。Terraform只接受此格式作为“image =”属性的有效输入。在添加您自己的本地图像时，注意不要创建不明确的图像名称，还要确保Terraform不会删除任何图像(在第二个示例中有更多相关内容)</p><p id="54aa" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">8.“端口”块指定Docker将从容器向外界转发哪些端口。在当前版本的提供程序插件中只能使用一个端口块。</p><p id="5726" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">9.为了便于参考和更好地理解，完整的上述脚本将实现完全等同于:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="5208" class="nk jv iq ng b gy nl nm l nn no">#docker run — name webserver -p 80:80 apache:2.4</span></pre><p id="6e27" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">10.通过运行以下命令应用Terraform配置:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="6c3e" class="nk jv iq ng b gy nl nm l nn no">$ terraform apply</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi pv"><img src="../Images/28a16063ba08846ab10d90fbe0296fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dleO0c2O9pfxZfP0"/></div></div></figure><p id="5431" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">11.出现提示时输入“yes”后，Terraform现在将创建容器并打印其完整的SHA256 ID。这可以在检查例如' $ docker ps '以及' $ docker stats '的输出时使用，以了解容器已启动并正在运行。</p><p id="818a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">12.浏览器连接到IP terra form的结果应该如下。请注意，要输入的IP可能会因您的主机网络配置而异。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi pw"><img src="../Images/67989b9fa238c52f3319eef5ec8923d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oMk1smbt1I4J8_Pp"/></div></div></figure><p id="2fa3" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">13.在继续下一个示例之前，在我们的项目文件夹中使用以下命令删除基础结构:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="aad2" class="nk jv iq ng b gy nl nm l nn no">$ terraform destroy</span></pre><p id="540d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">14.这将停止并清理任何Docker容器。请注意，它还会清除之前本地或通过Docker Hub远程提取的图像。</p><p id="e599" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">使用定制容器和负载平衡构建可伸缩的Docker服务。<br/> </strong>我们已经在第一个例子中看到了如何基于Docker Hub的可下载容器轻松创建容器。然而，它提供了较低的灵活性和定制性。</p><p id="6cd9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">虽然可以使用“count =”属性创建多个容器，但在我们的情况下这不是很有用，可能会导致端口冲突，并且不提供负载平衡。</p><p id="aad3" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">为了解决这个问题，将使用第二个示例，我们创建自己的本地Docker映像，运行前面提到的PiCalc NodeJs示例应用程序。它还将展示Docker Compose中常用的更高级、更有用的代码块。结果将是4个Docker容器一起工作，每个容器都有25%的最大CPU负载和100MB分配的RAM来同时计算典型的请求。这通过减少队列时间提高了性能，并通过冗余实现了增强的可用性。</p><p id="6d0c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">因为Terraform完全是脚本驱动的，所以基于脚本(换句话说，Docker文件)构建我们自己的Docker应用程序是有意义的。然而，目前还不可能自动完成映像构建过程，因此我们将手动运行$ docker image create。</p><p id="b0c3" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">该示例将由以下步骤组成:</p><p id="b0e0" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.基于示例Docker文件生成我们的Docker图像</p><p id="c47a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.创建并规划(但尚未应用)我们的Terraform配置文件。</p><p id="364e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.将主机添加到Docker群组。</p><p id="6cc2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.应用(运行)Terraform模块，并在浏览器中验证结果。</p><p id="ace8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.为我们的示例创建一个新的项目文件夹:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="ac0d" class="nk jv iq ng b gy nl nm l nn no">$ mkdir terraform-docker-picalc</span><span id="e6c5" class="nk jv iq ng b gy nq nm l nn no">$ cd terraform-docker-picalc</span></pre><p id="b6a2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.为了创建我们自己的图像，我们必须基于order文件生成一个图像。这是一个文本文档，包含了组装图像所需的所有shell命令。它还包含从现有图像派生图像的特殊字段，以及执行我们任务的命令。</p><p id="19ca" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.用您喜欢的名为Dockerfile的编辑器创建一个新文件，并将以下内容添加到该文件中:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="8ad3" class="nk jv iq ng b gy nl nm l nn no"><strong class="ng ir">#Dockerfile<br/></strong>FROM node:10<br/>MAINTAINER terraform_user<br/>WORKDIR /app<br/>RUN git clone <a class="ae lv" href="https://github.com/pb12/PiCalc" rel="noopener ugc nofollow" target="_blank">https://github.com/pb12/PiCalc</a> .<br/>RUN npm install<br/>CMD [ “node”, “server.js” ]</span></pre><p id="9552" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.简而言之，这个Docker文件将从Docker Hub中提取一个现有的(基于Ubuntu Linux的)映像，并将官方Git库克隆到一个文件夹/应用程序中。因为已经使用了为使用NodeJS而设计的基础映像，所以不需要额外的步骤，NodeJS应用程序可以立即用CMD语句执行。</p><p id="6785" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.构建并安装供本地使用的映像。我们将这个图像命名为“picalc ”,并为它分配一个标签“git”。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="5075" class="nk jv iq ng b gy nl nm l nn no">$ docker image build -t picalc:git .</span></pre><p id="d6a9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">6.输出应该以“成功构建了a46004371aeb”和“成功标记了picalc:git”结束。因为docker容器的惟一SHA256 ID在每次构建映像时都会发生变化，所以输出也会发生变化。Terraform将使用该ID，如第10.1章步骤IV所示。</p><p id="6864" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">7.现在我们已经手动构建了我们的映像，因为在编写本指南时，提供者插件没有提供这样的功能。但是，我们也可以指示Terraform在将来使用“null_resource”为我们运行该命令，如第5.3章所示:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="da8f" class="nk jv iq ng b gy nl nm l nn no"><strong class="ng ir">#optional code snippet, not required for the next step<br/></strong>resource “null_resource” “create_local_image” {<br/>   provisioner “local-exec” {<br/>      command = “docker image build -t picalc:git .”<br/>   }<br/>}</span></pre><p id="f643" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">8.每当Terraform创建我们的Docker基础设施时，这将创建我们的形象。但是因为图像创建过程并不总是保证总是成功的，所以它可能会在将来突然使Terraform应用过程失败，因此我们不推荐这种解决方法。</p><p id="d05c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">9.使用您喜欢的编辑器创建一个名为“main.tf”的新文件，将下面的代码片段添加到该文件中，我们将详细解释它们。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="f9fd" class="nk jv iq ng b gy nl nm l nn no">$ nano main.tf</span></pre><p id="6d5f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第一段:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="3cc2" class="nk jv iq ng b gy nl nm l nn no"><strong class="ng ir">#main.tf</strong></span><span id="ed92" class="nk jv iq ng b gy nq nm l nn no">resource “docker_image” “picalc_image” {<br/>   name = “picalc:git”<br/>   keep_locally = true #We don’t want Terraform to remove our local           image<br/>   #depends_on = [null_resource.image_create_local] #if the NR is   used<br/>}<br/>#…</span></pre><p id="4258" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第一个资源类似于第10.1章中的前一个例子。然而这一次，一个不同的图像将被用于容器，也就是我们刚刚构建的那个。与Docker CLI类似，它将首先在本地搜索容器，如果映像在本地不存在，它将搜索Docker Hub。</p><p id="ba04" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">每当本地图像与Terraform一起使用时，属性keep_locally必须设置为true(默认为false)。如果使用默认值，在Terraform破坏基础设施后，本地保存的Docker映像版本(下载的或构建的)将被删除。</p><p id="bd75" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">第二个也是最后一个片段:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="9b7d" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“docker_service” “app-server”</strong> {<br/>   name = <strong class="ng ir">“picalc-service”</strong></span><span id="7840" class="nk jv iq ng b gy nq nm l nn no">task_spec {<br/>   restart_policy = {<br/>      condition = <strong class="ng ir">“on-failure”</strong> #if it crashes, container will respawn<br/>  }<br/>   container_spec {<br/>      image = <strong class="ng ir">“${docker_image.picalc_image.latest}”</strong><br/>}<br/>   resources {<br/>      limits {<br/>         nano_cpus = <strong class="ng ir">250000000 </strong>#~25% load, 1*10^-9 CPU shares in ns<br/>         memory_bytes = <strong class="ng ir">100000000 </strong>#100MB, same as 100*10⁵ bytes<br/>    }<br/>  }<br/>}</span><span id="5e34" class="nk jv iq ng b gy nq nm l nn no">mode {<br/>   replicated {<br/>    replicas = <strong class="ng ir">4</strong><br/>  }<br/>}<br/>  endpoint_spec {<br/>    ports {<br/>      target_port = “<strong class="ng ir">80</strong>”<br/>      published_port = “<strong class="ng ir">80</strong>”<br/>    }<br/>  }<br/>}</span></pre><p id="c4a6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">最后一个资源实际上定义了我们的Docker服务。它由几个必需和可选的块组成。必须注意，这些块<strong class="ku ir">必须具有这些确切的名称</strong>，并且包含最少的必需属性。最小docker服务由至少一个任务规范(task_spec)和一个端点规范(endpoint_spec)块组成。</p><p id="a185" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">10.在task_spec中，我们为Docker设置了重启策略，并为服务中的容器指定了使用的映像。我们还使用块资源来防止容器占用所有的CPU执行时间。这是PiCalc在尽可能利用CPU的情况下同时处理4个请求所必需的。</p><p id="dd41" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">模式块指定制作容器的4个副本，以便在我们的服务中使用。它不同于上一个示例中使用的count =,因为这次它将在aa服务中创建，而不是单独创建。副本在虚拟负载均衡器后面一起工作(感谢Docker Swarm在后台为我们工作)。最后，我们在ports块中定义了要转发的端口，类似于前面的示例。</p><p id="626a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">11.作为参考，Terraform配置现在实现了相同的直接Docker命令:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="11ae" class="nk jv iq ng b gy nl nm l nn no"># docker service create — publish 8080 \<br/> — name picalc-service \<br/> — cpus 0.25 \<br/> — memory 100M \<br/> — restart-condition=”on-faillure” \<br/> — mode replicated \<br/> — replicas=4 \<br/>picalc:git</span></pre><p id="4af7" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">或者，它将完全替换此Docker合成文件，如果它将被使用:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="5525" class="nk jv iq ng b gy nl nm l nn no"><strong class="ng ir">#docker-compose.yml, for reference only<br/></strong>version: “3”<br/>services:<br/>   myservice:<br/>      image: picalc:git<br/>      deploy:<br/>      replicas: 4<br/>      resources:<br/>      limits:<br/>         cpus: “0.25”<br/>         memory: 100M<br/>      restart_policy:<br/>      condition: on-failure<br/>      ports:<br/>      - “80:80”<br/>      networks:<br/>      - net1<br/>networks:<br/>   net1:version: “3”<br/>services:<br/>   myservice:<br/>   image: picalc:git<br/>   deploy:<br/>   replicas: 4<br/>   resources:<br/>   limits:<br/>      cpus: “0.25”<br/>      memory: 100M<br/>   restart_policy:<br/>   condition: on-failure<br/>   ports:<br/>   - “80:80”</span></pre><p id="e184" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">12.启动我们的基础设施。为此，我们需要在项目文件夹中初始化Terraform。这可能是一些缺失的插件。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="21e1" class="nk jv iq ng b gy nl nm l nn no">$ terraform apply</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi px"><img src="../Images/22482f55b3b1678d11bf59dd7816ddb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TgpfK19s6Uy6KEa4"/></div></div></figure><p id="1a54" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">使我们的主机成为Docker群管理器，这必须手动完成，因为提供商不能</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="218e" class="nk jv iq ng b gy nl nm l nn no">$ docker swarm init</span></pre><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi py"><img src="../Images/e5753ab47e66b7857f948640e43900d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ef1bCYdOWZ12yqkN"/></div></div></figure><p id="5b64" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">现在应用配置，这可能需要一些时间。出现提示时，输入“是”。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="8379" class="nk jv iq ng b gy nl nm l nn no">$ terraform apply</span></pre><p id="08fe" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">13.现在是时候在浏览器中检查最终结果了。我们将发送一个请求来计算圆周率的前5000位小数，作为我们服务的演示工作负载。执行请求时，检查以下各项的输出:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="1eb6" class="nk jv iq ng b gy nl nm l nn no">$ docker stats</span></pre><p id="4e42" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">14.这个命令监控容器的资源利用情况。</p><p id="0247" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">15.现在发送请求，输入您的主机IP地址，后跟/？n =小数。其中decimals是要计算的π的小数位数。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi pz"><img src="../Images/e556475e4fdf042bb745e349c5ed5a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HModBayI09wgCAV5"/></div></div></figure><p id="f8f5" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">其中一个容器现在正在处理请求，CPU上限在我们的Terraform配置中配置。可以打开多个浏览器选项卡并发送更多请求来查看工作负载的分布情况。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="8c22" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">11.正在为Windows安装Azure CLI和Terraform</h1><p id="eb8d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><p id="78cc" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在本章中，我们将安装使用Terraform在Azure provider中部署资源所需的工具。所需的工具是Azure CLI。这将用于通过Azure provider来验证我们自己，该提供程序可用于Terraform。我们将在下一章深入讨论之前安装这些工具。此外，本章中还有在Windows 10上安装Terraform的说明。在整个指南中使用的同一台机器上，仍然可以遵循这些说明。</p><p id="531b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">安装Terraform (Windows 10) <br/> </strong>在本节中，我们将为Windows 10安装Terraform。当使用Azure时，在Windows上使用Terraform提供了更简单的工作流程。我们从官方网站安装Terraform，然后我们必须将其设置为全局路径。</p><p id="5079" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.为Windows 10下载<a class="ae lv" href="https://www.terraform.io/downloads.html" rel="noopener ugc nofollow" target="_blank"> Terraform </a></p><p id="a5c6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">下载包含一个可执行文件。把它放在任何你喜欢的文件夹里，并记下路径。</p><p id="226b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.转到控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;环境变量。</p><p id="ca03" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.搜索变量“Path”并双击它。</p><p id="264b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.单击新建并添加Terraform的路径(不带。exe文件)后添加分号(；)在最后一个条目上。</p><p id="dd06" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">例如:<code class="fe nx ny nz ng b">C:\Users\&lt;user-name&gt;\Terraform\</code></p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/464bb6adba3db291c1af186cd7c11762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/0*ITPv-EyjhExvQ5Kl"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><em class="ms">图9 —配置环境变量(截图)</em></figcaption></figure><p id="3cf4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.现在可以去Powershell用Terraform了。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/8c13f83ca639c5c487892d9b211abde2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/0*sMP02Kt--nv9B7A3"/></div></figure><p id="49a6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">注意:</strong>如果您收到未安装Terraform的错误信息。PATH环境变量设置不正确。</p><p id="0dcc" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">安装Terraform (Windows 10) <br/> </strong>我们将需要为Terraform使用Azure CLI来初始化您的帐户。有了它，你就可以直接在Terraform上使用你的账户，而不用去Azure门户网站。</p><p id="d9de" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.下载<a class="ae lv" href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?view=azure-cli-latest" rel="noopener ugc nofollow" target="_blank"> Azure CLI </a>并安装。</p><p id="af91" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.重新启动Powershell。仅重启Powershell并不总是有效，建议同时重启您的计算机或虚拟机。</p><p id="333a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.运行登录命令:<code class="fe nx ny nz ng b">az login</code></p><p id="a67b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">默认浏览器将会打开，在那里你可以使用你的Azure凭据登录。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/faeceeeee05df94afda615d125896615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/0*alKz-Lu85c6irTIr"/></div></figure><h1 id="9c85" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">12.使用Terraform在Microsoft Azure上调配功能应用程序</h1><p id="d197" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><p id="4eea" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在本章中，我们将在Windows上的Microsoft Azure中创建一个典型的应用程序。这次我们选择了Windows，因为我们已经在Linux中做了所有的事情。所以我们想证明这在Windows中也是可能的。当然你也可以在Linux上这样做，但是你必须自己做。</p><p id="12f4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">微软Azure是众所周知的云计算服务。它提供不同云服务的使用，包括计算、分析、存储和网络服务。我们主要通过Azure来使用它，因为可以创建一个学生帐户。学生可以使用学生Azure，他们将获得€100，000信用点来购买Azure资源。这当然是指南这一部分的先决条件。</p><p id="abe2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">使用Azure将帮助您了解更多有关使用Terraform进行远程供应的信息。</p><p id="1c93" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">为Azure创建Terraform配置<br/> </strong>如前所述，为Terraform进行的配置是在扩展名为. tf的配置文件中完成的，这些配置可以用两种格式编写:HashiCorp配置语言(HCL)，或JavaScript对象符号(JSON)。HCL是HashiCorp创造的一种语言，它对机器友好，但对人类来说容易阅读。JSON是一种众所周知的语言，具有与HCL相同的方面，但有时当配置由机器生成时更好。你可以选择你想用哪一个，但是在这一章我们将继续使用HCL。</p><p id="006a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">我们将制作一个基本的Azure provider块。</p><ol class=""><li id="8b28" class="ph pi iq ku b kv lq kz lr ld pj lh pk ll pl lp qc pn po pp bi translated">创建一个名为<code class="fe nx ny nz ng b">kvm_project/</code>的新项目工作区</li></ol><p id="8823" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.在项目目录中创建一个名为<code class="fe nx ny nz ng b">main.tf</code>的空文件</p><p id="78a8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.下面的代码将告诉我们将使用哪个提供者</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="1676" class="nk jv iq ng b gy nl nm l nn no">provider <strong class="ng ir">“azurerm”</strong> {<br/>   version = “=1.34.0”<br/>}</span></pre><p id="1dfe" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">version参数是可选的，用于将提供程序约束到特定版本甚至某个范围。这将阻止提供程序下载新的提供程序，这可能会破坏更改。</p><p id="a033" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.在下一节中，我们将创建一个资源块。资源块有两个字符串参数，如下所示。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4687" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“&lt;resource_type&gt;” “&lt;resource_name&gt;”</strong> {<br/>   name = “HelloWorld”<br/>   location = “westeurope”<br/>}</span></pre><p id="3d48" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.将步骤2和3中的代码复制粘贴到我们在步骤1 <code class="fe nx ny nz ng b">main.tf</code>中创建的文件中。</p><p id="dab2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">不要忘记更改资源类型和资源名称。将<strong class="ku ir"> azurerm_resource_group </strong>中的<code class="fe nx ny nz ng b">&lt;resource_type&gt;</code>和<code class="fe nx ny nz ng b"> &lt;resource_name&gt;</code>更改为您想要的任何名称。我们就称之为<code class="fe nx ny nz ng b">rg</code>。</p><p id="56a6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">使用Terraform提供Azure资源<br/></strong>terra form的三个重要命令是:terraform init、terraform plan和terraform apply。第一个命令用于新配置，初始化本地设置和数据。</p><p id="3e9c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">使用第二个命令，可以看到您将要进行的所有更改。Terraform apply将执行配置文件中描述的所有更改。</p><p id="806c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">1.转到您创建配置文件的项目文件夹</p><p id="972e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">2.使用命令:<code class="fe nx ny nz ng b">terraform init</code> Terraform将下载提供者插件。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/fc6447db76235bd1cd5480b95351ddce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/0*uJ_7-4FUnstVKDSV"/></div></figure><p id="bfe4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">3.现在使用<code class="fe nx ny nz ng b">terraform apply</code>，我们不必运行<code class="fe nx ny nz ng b">terraform plan,</code>，因为我们没有改变基础设施。确保您已经使用<code class="fe nx ny nz ng b">az login</code>登录，否则命令将会失败。</p><p id="e64e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">4.转到<em class="mi">portal.azure.com</em>并点击左侧的<em class="mi">资源组</em>面板。您将在这里找到您在上一章中定义的资源组。在我们的例子中，我们将其命名为<code class="fe nx ny nz ng b">HelloWorld.</code></p><p id="1581" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">5.摧毁用<code class="fe nx ny nz ng b">terraform destroy</code>创建的资源组。这应该会开始破坏资源。过一会儿，资源组也将在Azure portal中消失。</p><p id="a946" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">使用Terraform <br/> </strong>创建一个作为Azure函数应用的PiCalc服务器。在本节中，我们将创建一个Azure函数应用，并在其上运行PiCalc服务器。在这一章中，我们将使用我们创建的两个不同的docker映像，它们都有彼此不同的实现。其中一个基于NODE|10 Docker映像，另一个基于最新发布的Python Docker映像。这些映像被配置为在启动时启动一个典型的服务器，并将成为Azure Function应用程序的配置，该应用程序使用Linux容器作为站点配置。</p><p id="88a3" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">两个映像中服务器的实现是不同的，基于python的Docker映像将运行我们在本文中使用的相同的典型Python服务器。在NODE variant上将运行我的老师Pieter Burghouwt爵士创建的PiCalc应用程序，我们必须感谢他创建了这个应用程序。下面我们将展示用于创建这些映像的docker文件，这些映像可以在启动时运行典型的服务器，当然还有用于创建基于这些映像的Azure Function应用程序的Terraform代码。</p><p id="a095" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir"> Dockerfiles <br/> </strong>首先，我们将研究用于创建图像的两个Dockerfiles。Dockerfile文件的使用已经在第10章解释过了。注意下面的docker文件和它们后面的解释。</p><p id="9113" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir"> Nodejs </strong></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="70d9" class="nk jv iq ng b gy nl nm l nn no"><strong class="ng ir">FROM</strong> node:<strong class="ng ir">10</strong><br/><strong class="ng ir">MAINTAINER</strong> Nitesh<br/><strong class="ng ir">EXPOSE</strong> <strong class="ng ir">8080</strong><br/><strong class="ng ir">COPY</strong> /PiCalc ./PiCalc<br/>WORKDIR /PiCalc<br/>RUN npm install<br/>CMD [ <strong class="ng ir">“node”</strong>, <strong class="ng ir">“server.js”</strong> ]</span></pre><p id="d65f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">首先，我们下载一个名为node:10的图像。然后，我们将app文件复制到容器中，并将shell实例的目录更改为PiCalc app目录。运行命令总体上用于安装应用程序或软件包。CMD命令允许您设置一个默认命令，该命令只有在您运行container而没有指定命令时才会执行。</p><p id="39ab" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir"> Python </strong></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="d357" class="nk jv iq ng b gy nl nm l nn no"><strong class="ng ir">FROM</strong> python<br/><strong class="ng ir">MAINTAINER</strong> Nitesh<br/><strong class="ng ir">EXPOSE</strong> <strong class="ng ir">8080</strong><br/><strong class="ng ir">COPY</strong> /PiCalcPy ./PiCalcPy<br/>WORKDIR /PiCalcPy<br/>RUN python install_picalc.py<br/>CMD [ <strong class="ng ir">“python”</strong>, <strong class="ng ir">“run.py”</strong>, <strong class="ng ir">“mode=server”</strong> ]</span></pre><p id="aa4f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">基本上我们在这里做的和上面差不多。这种流程安装也非常类似于我们在第8章“云初始化配置”中配置虚拟机运行的方式。这里我们还调用了相同的命令来运行PiCalc服务器。</p><p id="73f9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">执行这两个After文件后，我们为它们创建了两个新的映像。你可以在DockerHub的<a class="ae lv" href="https://hub.docker.com/r/ineshi/picalcpy" rel="noopener ugc nofollow" target="_blank">和</a><a class="ae lv" href="https://hub.docker.com/r/ineshi/picalc19" rel="noopener ugc nofollow" target="_blank">找到它们。在下一节中，这些将用于创建一个Azure函数应用程序。</a></p><p id="8525" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在GitHub上可以找到PiCalc代码:<a class="ae lv" href="https://github.com/krebsalad/PiCalcPy" rel="noopener ugc nofollow" target="_blank"> PiCalcPy </a>和<a class="ae lv" href="https://github.com/pb12/PiCalc" rel="noopener ugc nofollow" target="_blank"> PiCalc19 </a>。</p><p id="8411" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">我们不打算解释代码，它非常简单，基本的Python和JavaScript。第七章已经解释了一个重要的部分。另外，请留意上述存储库中的README.md文件以获取更多信息。</p><p id="5769" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">配置Terraform模块部署典型功能App <br/> </strong>在本节中，我们将创建一个新的配置。该配置将是一个包含. tf文件的Terraform模块，该文件将包含部署Azure功能应用程序的代码。模块目录将被称为modules/azure_picalc_function/</p><p id="ed5e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">创建上述文件和目录。编辑<code class="fe nx ny nz ng b">modules/azure_picalc_function/deploy.tf</code>文件。在这个文件中，我们将添加代码。</p><p id="c194" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">首先创建一个Azure资源组。这个资源组将包含我们的服务将在哪里托管的信息。在我们的例子中，我们将把＄{ var . location }设置为“westeurope”。资源组不会增加你在Azure中的成本。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="9f11" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“azurerm_resource_group” “main”</strong> {<br/>   name = “${var.prefix}-resource”<br/>   location = “${var.location}”<br/>}</span></pre><p id="98eb" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">添加Azure存储帐户。</p><p id="e5e4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><em class="mi">“存储帐户为您的Azure存储数据提供了一个唯一的命名空间，您可以通过HTTP或HTTPS从世界任何地方访问该命名空间</em>”。<em class="mi">(《微软，Azure存储帐户概述》，2019c) </em></p><p id="90d1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">这是将部署function App的位置。请注意，resource_group_name应该与资源的名称匹配。在下面的代码中，这是通过使用名称变量<code class="fe nx ny nz ng b">azurerm_resource_group</code>来确保的。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="5451" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“azurerm_storage_account” “main”</strong> {<br/>   name = “${var.prefix}sa”<br/>   resource_group_name = “${azurerm_resource_group.main.name}”<br/>   location = “${azurerm_resource_group.main.location}”<br/>   account_tier = “Standard”<br/>   account_replication_type = “LRS”<br/>}</span></pre><p id="1647" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在资源组中添加Azure应用服务计划。这将决定你在Azure上的消费计划，并将极大地定义将要创建的服务的性能，但同样也会极大地增加成本。请注意，下面的类型是“FunctionApp ”,这意味着我们将要运行的映像必须是Linux发行版的变体。其他选项有FunctionApp、Linux和elastic或Windows。当种类设置为Linux时，reserved必须设置为true</p><p id="c908" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">此外，有可能改变层和大小，这当然会改变你目前支付的价格。请参见下图了解不同的选项:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi py"><img src="../Images/f4a26c14df65c0a3f4b9a94b4194ac45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HOtUM-UWjmhLsV7-"/></div></div></figure><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi py"><img src="../Images/8bd5129068eb1471cb2cf988ef772dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GuEe_i1VrH0wuhHq"/></div></div></figure><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="eb42" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“azurerm_app_service_plan” “main”</strong> {<br/>   name = “${var.prefix}-asp”<br/>   location = “${azurerm_resource_group.main.location}”<br/>   resource_group_name = “${azurerm_resource_group.main.name}”<br/>   kind = “FunctionApp”<br/>   reserved = “true”</span><span id="4025" class="nk jv iq ng b gy nq nm l nn no">sku {<br/>    tier = “Standard”<br/>    size = “S1”<br/> }<br/>}</span></pre><p id="1290" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">添加一个功能app。这将部署典型服务。在下面的代码中，在site_config下可以看到设置了一个linux_fx_version值。这将拉一个Docker图像，并将其作为功能应用程序运行。本例中安装的docker映像是节点变体。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="1af7" class="nk jv iq ng b gy nl nm l nn no">resource <strong class="ng ir">“azurerm_function_app” “main”</strong> {<br/>   name = “${var.prefix}-function”<br/>   location = “${azurerm_resource_group.main.location}”<br/>   resource_group_name = “${azurerm_resource_group.main.name}”<br/>   app_service_plan_id = “${azurerm_app_service_plan.main.id}”<br/>   storage_connection_string = “${azurerm_storage_account.main.primary_connection_string}”</span><span id="fd82" class="nk jv iq ng b gy nq nm l nn no"># set picalcpy image as server example<br/>   site_config {<br/>   linux_fx_version = “DOCKER|ineshi/picalcpy:latest”<br/>   #linux_fx_version = “DOCKER|ineshi/picalc19:latest”<br/> }</span><span id="0025" class="nk jv iq ng b gy nq nm l nn no">app_settings = {<br/>   “WEBSITES_ENABLE_APP_SERVICE_STORAGE” = “false”<br/>   “DOCKER_REGISTRY_SERVER_URL” = “https://index.docker.io"<br/>  }<br/>}</span></pre><p id="f5c7" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">如第8章所述，可以使用模块，以便可以从集中位置设置地形配置的变量。在上面的代码中，我们添加了几个变量，但从未定义它们。在本章中，我们将使用不同的方法创建一个单独的。包含变量和值的模块目录中的“tf”文件。例如，我们可以将这个新文件模块命名为/azure _ pi calc _ function/variables . TF</p><p id="483b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">创建上面提到的文件，将下面可以找到的代码粘贴到variables.tf中，变量的语法是一样的。请注意，我们为所有变量设置了默认值。这将确保即使没有从调用模块的地方设置变量，代码也可以运行。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="8961" class="nk jv iq ng b gy nl nm l nn no">variable <strong class="ng ir">“prefix”</strong> {<br/>   description = “The prefix used for all resources in this example”<br/>   default = “picalc” <br/>}</span><span id="bd74" class="nk jv iq ng b gy nq nm l nn no">variable “<strong class="ng ir">location</strong>” {<br/>   description = “The Azure location where all resources in this example should be created”<br/>   default = “westeurope” <br/>}</span></pre><p id="0c32" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">要运行配置，您必须调用模块。编辑main.tf并添加以下代码来启动该模块。</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="80ab" class="nk jv iq ng b gy nl nm l nn no">module<strong class="ng ir"> “function_app_test</strong>” {<br/>   source = “./modules/azure_picalc_function/”<br/>}</span></pre><p id="2776" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">最后用<code class="fe nx ny nz ng b"> ‘<em class="mi">terraform init’</em></code> <em class="mi"> </em>和<code class="fe nx ny nz ng b"><em class="mi">‘terraform apply’</em></code>运行配置。转到Azure portal，然后点击<em class="mi">‘资源组’</em>，点击名为<em class="mi">‘典型资源’</em>的资源组。您将看到以下内容:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi qe"><img src="../Images/f45fcf67430adca226be510dad7acc78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AgbqMlB3KqrVIR8F"/></div></div></figure><p id="9e3d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">通过启动浏览器并根据您使用的PiCalc图像搜索以下URL之一来测试PiCalc。加载要花很长时间，因为功能App要初始化各种东西。</p><p id="a95e" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">(在本章给出的示例代码中，我们使用了<code class="fe nx ny nz ng b">“DOCKER|ineshi/picalcpy:latest”</code>，但是您也可以使用<code class="fe nx ny nz ng b">“DOCKER|ineshi/picalc19:latest”</code>作为站点配置。)</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="257e" class="nk jv iq ng b gy nl nm l nn no"># PiCalcPy<br/><a class="ae lv" href="https://picalc-function.azurewebsites.net/PiCalc/100" rel="noopener ugc nofollow" target="_blank">https://picalc-function.azurewebsites.net/PiCalc/100</a></span><span id="3ea5" class="nk jv iq ng b gy nq nm l nn no">PiCalc19<br/><a class="ae lv" href="https://picalc-function.azurewebsites.net/?n=100" rel="noopener ugc nofollow" target="_blank">https://picalc-function.azurewebsites.net/?n=100</a></span></pre><p id="b9be" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">上述URL的输出应该类似于以下输出(忽略下图中的IP):</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi qf"><img src="../Images/62bda7e2e0e95a2be69da08ffbc6ebd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iGekk6hMk13tjh0C"/></div></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="bf8f" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">13.解决纷争</h1><p id="40d7" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><a class="ae lv" href="#29e6" rel="noopener ugc nofollow">返回目录</a></p><p id="602c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">本章将介绍使用Terraform和本指南中提到的提供商时可能出现的常见问题。这将在三个部分中完成，在这三个部分中可以找到使用提供程序时可能发生的问题的解决方案。在这些部分中，还将讨论一些可用于调试这些问题的工具。</p><p id="9474" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">调试terra form provider libvirt<br/></strong>使用libvirt provider时出现的大多数错误都与lib virt资源的创建有关。创建资源时，提供程序可能会因为各种问题而失败。因此，了解一些有助于调试这些问题的命令是很有用的。注意下面的命令及其描述。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/9f1ef8728d4fbecffca310ede86cda3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*aH2zX5wNebbhOZvEkLymJg.png"/></div></figure><p id="0991" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">常见问题和可能的解决方案</strong></p><blockquote class="mz na nb"><p id="5f32" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">问题1 </strong></p><p id="09b9" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir"> Error: virError(Code=38，Domain=7，Message= '无法将套接字连接到'/var/run/libvirt/libvirt-sock ':没有这样的文件或目录')，位于libvirt.tf的第1行，在提供程序“libvirt”中:1:提供程序“lib virt”{</strong></p></blockquote><p id="f41f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">当libvirt未启动时，可能会发生此问题。使用以下命令验证libvirt是否已启动:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="5362" class="nk jv iq ng b gy nl nm l nn no">$ sudo systemctl status libvirtd</span></pre><p id="ec39" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">如果它没有运行，请确保启动它。使用systemctl启动命令。</p><blockquote class="mz na nb"><p id="a0c9" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">问题二</strong></p><p id="f823" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">错误:virError(Code=38，Domain=7，Message= '无法将套接字连接到'/var/run/libvirt/libvirt-sock ':权限被拒绝')</strong></p></blockquote><ul class=""><li id="d7ae" class="ph pi iq ku b kv lq kz lr ld pj lh pk ll pl lp pm pn po pp bi translated">libvirt在运行吗？</li><li id="7c8c" class="ph pi iq ku b kv pq kz pr ld ps lh pt ll pu lp pm pn po pp bi translated">您的用户在libvirt组中吗？如果没有重做第7.1章设置权限</li><li id="e738" class="ph pi iq ku b kv pq kz pr ld ps lh pt ll pu lp pm pn po pp bi translated">如果在虚拟机上，并且您刚刚第一次安装了libvirt，请确保重新启动机器并重试。</li></ul><p id="535f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">第7章的一个常见问题<br/> </strong>如第7章所述，通过libvirt和Terraform部署KVM时，即使只出现了一个错误，也会出现某些问题，并且这些问题会相互影响。这里描述了已知的解决方案。问题3到7都是相关的，确保如果出现一个问题，在再次使用Terraform Apply之前，首先使用每个问题的所有已知解决方案。</p><blockquote class="mz na nb"><p id="7dfb" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">问题3 </strong></p><p id="b621" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">错误:创建libvirt域时出错:…。无法打开“/tmp/terra form _ lib virt _ provider _ images/image . qcow 2”:权限被拒绝)</strong></p></blockquote><p id="8991" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在Libvirt提供程序上应用Terraform计划时，可能会出现此问题。</p><ul class=""><li id="d766" class="ph pi iq ku b kv lq kz lr ld pj lh pk ll pl lp pm pn po pp bi translated">这意味着无法访问该文件。确保被拒绝的文件的目录具有用户权限。该目录是否存在？因为terraform不能创建文件，除非它在/tmp/中。</li></ul><p id="ac81" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">您可以使用chmod命令更改images文件夹的权限。</p><ul class=""><li id="19cf" class="ph pi iq ku b kv lq kz lr ld pj lh pk ll pl lp pm pn po pp bi translated">确保/etc/libvirt/qemu.conf中的security_driver设置为“none ”,而不是“selinux”</li></ul><p id="aa71" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">如果进行了更改，不要忘记重新启动libvirt服务:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="8290" class="nk jv iq ng b gy nl nm l nn no">$ sudo systemctl restart libvirtd</span></pre><blockquote class="mz na nb"><p id="15c3" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">问题4 </strong></p><p id="60f8" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">错误:定义libvirt域时出错:virError(Code=9，Domain=20，Message= '操作失败:域“ubuntu-domain”已经存在，uuid为56 A0 FCC 3-E8 a2–4 EAE-a9e 0-b 94 b 9 fc 2e 284 ')</strong></p></blockquote><p id="d450" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在Libvirt提供程序上应用Terraform计划时，可能会出现此问题。经常发生在第七章。</p><ul class=""><li id="d838" class="ph pi iq ku b kv lq kz lr ld pj lh pk ll pl lp pm pn po pp bi translated">这意味着您试图创建的资源已经存在。确保使用virsh undefine命令之一销毁所述资源。例如，当一个域已经存在时，如上例所示，运行以下命令。</li></ul><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="e0b0" class="nk jv iq ng b gy nl nm l nn no">$ virsh destroy ubuntu-domain</span></pre><blockquote class="mz na nb"><p id="8b3c" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">问题5 </strong></p><p id="0b08" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">错误:创建libvirt卷时出错:virError(Code=90，Domain=18，Message = ' storage volume ' Ubuntu-amd64 . qcow 2 ' exists has ')</strong></p></blockquote><p id="5a23" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">和</p><blockquote class="mz na nb"><p id="2d88" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated">e<strong class="ku ir">Error:为cloudinit设备commoninit.iso创建libvirt卷时出错:virError(Code=90，Domain=18，Message = ' storage volume ' common init . iso '已存在')</strong></p></blockquote><p id="528b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">当试图删除错误的地形图时，可能会出现此错误。经常发生在第七章。</p><ul class=""><li id="cf36" class="ph pi iq ku b kv lq kz lr ld pj lh pk ll pl lp pm pn po pp bi translated">由Libvirt创建的卷仍然附加到映像，并防止使用相同的卷名应用新的Terraform。因此，需要移除这些:</li></ul><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="1b57" class="nk jv iq ng b gy nl nm l nn no">$ virsh vol-delete commoninit.iso — pool ubuntu-pool &amp;&amp; virsh vol-delete ubuntu-amd64.qcow2 — pool ubuntu-pool</span></pre><blockquote class="mz na nb"><p id="448b" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">问题6 </strong></p><p id="f33f" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">错误:错误存储池“ubuntu-pool”已经存在</strong></p></blockquote><p id="9929" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">确保您也删除了创建的池，首先暂停它，然后删除它。经常发生在第七章。</p><ul class=""><li id="f6cf" class="ph pi iq ku b kv lq kz lr ld pj lh pk ll pl lp pm pn po pp bi translated">删除在Terraform过程中创建的libvirt池:</li></ul><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="9f51" class="nk jv iq ng b gy nl nm l nn no">$ virsh pool-destroy ubuntu-pool &amp;&amp; virsh pool-undefine ubuntu-pool</span><span id="3b9b" class="nk jv iq ng b gy nq nm l nn no">Pool ubuntu-pool destroyed</span></pre><blockquote class="mz na nb"><p id="ae26" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">问题7 </strong></p><p id="81f1" class="ks kt mi ku b kv lq kx ky kz lr lb lc nc ls lf lg nd lt lj lk ne lu ln lo lp ij bi translated"><strong class="ku ir">错误:错误您的虚拟机名称已经存在</strong></p></blockquote><ul class=""><li id="687c" class="ph pi iq ku b kv lq kz lr ld pj lh pk ll pl lp pm pn po pp bi translated">删除正在运行的虚拟机</li></ul><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="553d" class="nk jv iq ng b gy nl nm l nn no">$ virsh undefine your_vm_name</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="646c" class="ju jv iq bd jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr bi translated">文献学</h1><p id="06af" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">“云初始化，云初始化19.2文档”，(2019a)。检索于2019年10月15日，来自<a class="ae lv" href="https://cloudinit.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://cloudinit.readthedocs.io/en/latest/</a></p><p id="e2c4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“码头工人，什么是集装箱？”，(2019a)。检索于2019年10月10日，来自<a class="ae lv" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/resources/what-container</a></p><p id="1487" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“Docker，为什么是Docker？”，(2019b)。检索于2019年10月10日，来自<a class="ae lv" href="https://www.docker.com/why-docker" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/why-docker</a></p><p id="eb50" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“Docker，PayPal与Docker Enterprise的使用案例”，(2019c)。检索于2019年10月10日，来自<a class="ae lv" href="https://www.docker.com/customers/paypal" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/customers/paypal</a></p><p id="2faf" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“Duncan Mac-Vicar P .，dmacvicar/terra form-provider-lib virt”，(2019a)。检索于2019年9月30日，来自<a class="ae lv" href="https://github.com/dmacvicar/terraform-provider-libvirt" rel="noopener ugc nofollow" target="_blank">https://github.com/dmacvicar/terraform-provider-libvirt</a></p><p id="10f9" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“glitterlabs，Terraform UI”，(2019a)。检索于2019年10月20日，来自<a class="ae lv" href="http://www.glitterlabs.com/terraform_ui/index.html" rel="noopener ugc nofollow" target="_blank">http://www.glitterlabs.com/terraform_ui/index.html</a></p><p id="c1ca" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“谷歌，Go编程语言”，(2019)。检索于2019年10月10日，来自https://golang.org/<a class="ae lv" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"/></p><p id="8cdb" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“哈希公司，简介—地形”，(2019年a)。检索于2019年9月30日，来自https://www.terraform.io/intro/index.html<a class="ae lv" href="https://www.terraform.io/intro/index.html" rel="noopener ugc nofollow" target="_blank"/></p><p id="8874" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“HashiCorp，带Armon Dadgar的HashiCorp Terraform简介”，(2018b)。检索于2019年10月11日，发自<a class="ae lv" href="https://www.youtube.com/watch?v=h970ZBgKINg&amp;t=148s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=h970ZBgKINg&amp;t = 148s</a></p><p id="0d48" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“HashiCorp，README.md — HCL是HashiCorp配置语言”，(2019b)。检索于2019年10月11日，来自<a class="ae lv" href="https://github.com/hashicorp/hcl" rel="noopener ugc nofollow" target="_blank">https://github.com/hashicorp/hcl</a></p><p id="a053" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“码头供应商hashi corp”(2019 c)。检索到2019年10月10日，<a class="ae lv" href="https://www.terraform.io/docs/providers/docker/index.html" rel="noopener ugc nofollow" target="_blank">https://www.terraform.io/docs/providers/docker/index.html</a></p><p id="66f8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“HaschiCorp，Azure提供商”，(2019d)。检索于2019年10月20日，<a class="ae lv" href="https://www.terraform.io/docs/providers/azurerm/index.html" rel="noopener ugc nofollow" target="_blank">https://www.terraform.io/docs/providers/azurerm/index.html</a></p><p id="5f4d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“HaschiCorp，Azure提供程序:使用Azure CLI进行身份验证”，(2019e)。检索于2019年10月20日，<a class="ae lv" href="https://www.terraform.io/docs/providers/azurerm/auth/azure_cli.html" rel="noopener ugc nofollow" target="_blank">https://www . terraform . io/docs/providers/azure RM/auth/azure _ CLI . html</a></p><p id="b035" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“HashiCorp，空资源”，(2019f)。检索到2019年10月10日，<a class="ae lv" href="https://www.terraform.io/docs/providers/null/resource.html" rel="noopener ugc nofollow" target="_blank">https://www.terraform.io/docs/providers/null/resource.html</a></p><p id="514f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“libvirt，KVM/QEMU虚拟机管理程序驱动程序”，(2019a)。检索于2019年10月15日，来自<a class="ae lv" href="https://libvirt.org/drvqemu.html" rel="noopener ugc nofollow" target="_blank">https://libvirt.org/drvqemu.html</a></p><p id="6bc8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“libvirt，虚拟化API”，(2019b)。检索于2019年9月30日，来自<a class="ae lv" href="https://libvirt.org/" rel="noopener ugc nofollow" target="_blank">https://libvirt.org/</a></p><p id="3fe8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“微软，什么是云计算”，(2019a)。检索于2019年9月30日，来自<a class="ae lv" href="https://azure.microsoft.com/nl-nl/overview/what-is-cloud-computing/" rel="noopener ugc nofollow" target="_blank">https://azure . Microsoft . com/nl-nl/overview/what-is-cloud-computing/</a></p><p id="61c1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">《微软，什么是Azure》，(2019b)。检索到2019年10月20日，<a class="ae lv" href="https://azure.microsoft.com/en-us/overview/what-is-azure/" rel="noopener ugc nofollow" target="_blank">https://azure.microsoft.com/en-us/overview/what-is-azure/</a></p><p id="fc84" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">《微软Azure存储账户概述》(2019c)，2019年10月23日检索，来自<a class="ae lv" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/Azure/storage/common/storage-account-overview</a></p><p id="5368" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“梅尔。宝洁公司。t，云计算p2–3的NIST定义，(2011a)。检索于2019年9月30日，来自<a class="ae lv" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-145.pdf" rel="noopener ugc nofollow" target="_blank">https://nvl pubs . NIST . gov/NIST pubs/Legacy/SP/nistspecialpublication 800-145 . pdf</a></p><p id="9d0b" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“Redhat，KVM是什么？”，(2019a)。检索于2019年9月30日，来自<a class="ae lv" href="https://www.redhat.com/en/topics/virtualization/what-is-KVM" rel="noopener ugc nofollow" target="_blank">https://www.redhat.com/en/topics/virtualization/what-is-KVM</a></p><p id="48b3" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“Savannah T .，PumpkinLB一个简单、快速、纯python的负载平衡器”，(2019 A)2019年10月20日检索，<a class="ae lv" href="https://github.com/kata198/PumpkinLB" rel="noopener ugc nofollow" target="_blank">https://github.com/kata198/PumpkinLB</a></p><p id="c6c5" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“开放组，欢迎使用ArchiMate 3.0.1规范，一个开放组标准”，(2019a)。检索于2019年10月11日，来自<a class="ae lv" href="https://pubs.opengroup.org/architecture/archimate3-doc/" rel="noopener ugc nofollow" target="_blank">https://pubs.opengroup.org/architecture/archimate3-doc/</a></p><p id="7c55" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">“开放组，Archi开源ArchiMate建模”，(2019b)。检索于2019年10月11日，来自<a class="ae lv" href="https://www.archimatetool.com/" rel="noopener ugc nofollow" target="_blank">https://www.archimatetool.com/</a></p></div></div>    
</body>
</html>