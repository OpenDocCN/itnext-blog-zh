<html>
<head>
<title>Powering up your OutSystems Applications — Part 2— Performance tracking with Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">启动您的外部系统应用程序—第2部分—用Javascript进行性能跟踪</h1>
<blockquote>原文：<a href="https://itnext.io/powering-up-your-outsystems-applications-part-2-performance-tracking-with-javascript-92fd5814aa42?source=collection_archive---------6-----------------------#2020-01-15">https://itnext.io/powering-up-your-outsystems-applications-part-2-performance-tracking-with-javascript-92fd5814aa42?source=collection_archive---------6-----------------------#2020-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8d0ba612ed44ed63fcb030c08f64d710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6HLG4i8S9CVFgyIr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">性能不仅仅是指速度快，还包括使用对你有利的能力。</figcaption></figure><p id="e0ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">前一段时间，我在考虑如何在客户端测量页面负载的真实性能。</p><p id="6df0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我可以通过创建自己的逻辑来轻松地测量它，从而根据我想要测量的操作的开始和结束来获得指标。但是这种方法仍然依赖于浏览器、服务器和外部系统平台之间运行的一切。这样，我就没有在我的外部系统应用程序的服务器端测量它的延迟。</p><p id="b0d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">经过一番调查，我从Web API(我在<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/powering-up-your-outsystems-applications-part-1-integrating-web-apis-to-outsystems-c4c41125e7a?source=friends_link&amp;sk=82733b2c30922282a9cdddca1cf76f89">上一篇文章</a>中已经解释过什么是Web API)中了解到了导航定时API。</p><p id="4683" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个API为我们提供了一种检测浏览器交互的本地javascript方式，以及测量这些交互的能力。</p><p id="eb79" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，使用该API，我们可以检测三种类型的交互:</p><ul class=""><li id="37f4" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated">航行</li><li id="1551" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">再装</li><li id="4759" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">后退_前进</li></ul><p id="c60c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming/type" rel="noopener ugc nofollow" target="_blank"> Mozilla文档</a>中找到更多相关信息。</p><p id="3e18" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们从一个简单的例子开始，我们将测量一个简单的屏幕加载所需的时间。</p><p id="cab4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我在OutSystems平台中创建了一个简单的测试应用程序，还创建了一个空白屏幕，在该屏幕中，我添加了以下Javascript代码:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/62cbadde0cc071d6225c611e592d3bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bc027BPaZ39fCR1pekBVjg.png"/></div></div></figure><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="ecea" class="lz ma iq lv b gy mb mc l md me">window.addEventListener('load',function(){<br/> let now = new Date().getTime();<br/> let loadingTime = now — performance.timing.navigationStart;</span><span id="be5e" class="lz ma iq lv b gy mf mc l md me">console.log(loadingTime + ' ms');<br/>},false);</span></pre><p id="19e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">发布模块并运行应用程序后，我们会看到:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/1223644e8155319bf12474f64d37a56f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8C4cOfhZpwIlEekt8Eq_Q.png"/></div></div></figure><p id="b8ff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这意味着我们的简单屏幕花了1537毫秒加载。现在，我们将使我们的Javascript代码变得更好、更复杂，让我们跟踪导航计时API提供给我们的所有事件:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/d9e6dcfa95525de0a918fe4ece48bc79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lnX4BR-PnLom3U2k0dmVFg.png"/></div></div></figure><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="d323" class="lz ma iq lv b gy mb mc l md me">window.addEventListener('load', function() {<br/>  let now = new Date().getTime();<br/>  let loadingTime = now - performance.timing.navigationStart; <br/>  let result = "";<br/>  switch(performance.navigation.type) {<br/>      case PerformanceNavigation.TYPE_NAVIGATE:<br/>        result += "Navigation";<br/>      break;<br/>    case PerformanceNavigation.TYPE_RELOAD:<br/>        result += "Reload";<br/>      break;<br/>    case PerformanceNavigation.TYPE_BACK_FORWARD:<br/>        result += "History";<br/>      break;<br/>    default:<br/>        result += "Unknown";<br/>      break;<br/>  }<br/><br/>  result += " " + loadingTime + " ms";<br/>      <br/>  console.log(result);<br/>  <br/>}, false);</span></pre><p id="5a7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们的代码已经准备好跟踪3种不同类型的事件，结果将显示在控制台中。</p><p id="7a79" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我还复制了屏幕，并在第一个屏幕上放了一个链接到第二个。这样，我们将能够测试BACK_FORWARD事件。</p><p id="483a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们开始测试应用程序，看看它是什么样子的。</p><p id="914c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第一个测试是打开应用程序:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/2ef5aeb547eedec36bd9b101c71ed41e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IFh92CtunB-GcUFhDCYveQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">加载时间为1167毫秒</figcaption></figure><p id="7c96" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于第二个测试，我们将通过我们创建的链接导航到第二页，然后单击浏览器的后退按钮:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/14b499b782dd284a88c346b12c96446f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhUL3gx-TQpZuAZaOhSAjA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">花了438毫秒回去</figcaption></figure><p id="bfda" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以测试的第三个事件是通过单击浏览器的“reload”按钮来重新加载页面:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/b46f395f87022f81953d7ef086b33f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kVjv-0cAb2g3sZdk8hxDjA.png"/></div></div></figure><p id="e8d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以看到，事件的持续时间彼此之间有很大的不同。</p><p id="2d55" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是因为浏览器呈现页面的方式。在第一次导航到页面时，浏览器加载所有内容，而在重新加载期间，由于缓存机制，它将花费更少的时间。返回浏览器的back按钮将加载离开页面时保存的ViewState内容。这就是为什么BACK_FORWARD事件比其他事件花费的时间少。</p><p id="74a0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以，最后，我们的代码看起来像这样:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="67b0" class="lz ma iq lv b gy mb mc l md me">window.addEventListener('load', function() {<br/>  let now = new Date().getTime();<br/>  let loadingTime = now - performance.timing.navigationStart; <br/>  let result = "";<br/>  switch(performance.navigation.type) {<br/>      case PerformanceNavigation.TYPE_NAVIGATE:<br/>        result += "Navigation";<br/>      break;<br/>    case PerformanceNavigation.TYPE_RELOAD:<br/>        result += "Reload";<br/>      break;<br/>    case PerformanceNavigation.TYPE_BACK_FORWARD:<br/>        result += "History";<br/>      break;<br/>    default:<br/>        result += "Unknown";<br/>      break;<br/>  }<br/><br/>  result += " " + loadingTime + " ms";<br/>      <br/>  console.log(result);<br/>  <br/>}, false);</span></pre><p id="2d38" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从现在起，您可以将这些指标发送到服务器，并对它做任何您想做的事情；存储在您数据库中，发送到您的BI应用程序，创建报告或使用这些指标执行任何其他程序。</p><p id="7646" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个容易、简单且非常有用的Web API，任何人都可以使用。因此，请利用它，并改善故障诊断和记录您的应用程序。</p></div></div>    
</body>
</html>