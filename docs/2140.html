<html>
<head>
<title>A simple MVVM implementation in client side Blazor.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">客户端Blazor中一个简单的MVVM实现。</h1>
<blockquote>原文：<a href="https://itnext.io/a-simple-mvvm-implementation-in-client-side-blazor-8c875c365435?source=collection_archive---------0-----------------------#2019-04-06">https://itnext.io/a-simple-mvvm-implementation-in-client-side-blazor-8c875c365435?source=collection_archive---------0-----------------------#2019-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8686cfd665f32462b6a7ba17426b12e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-wx9Fsh2nXJ6qAiXqz3KA.png"/></div></div></figure><p id="3519" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是系列文章的第一篇，我将介绍我目前计划如何创建一个Blazor客户端应用程序来替换我的生产Silverlight应用程序。本系列的重点是将模型-视图-视图模型模式应用于客户端Blazor。</p><p id="ce2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上一篇文章中，我讨论了如何将我的生产Silverlight应用程序迁移到一个新的平台。我目前的希望是，我将能够使用Blazor作为平台。我谈到了将我的应用程序改为使用Web API REST调用，而不是WCF服务。如果您对在Silverlight中使用Web API感兴趣，您可以在这里阅读该文章:</p><div class="kw kx gp gr ky kz"><a href="https://medium.com/@haywireiv/getting-ready-to-say-goodbye-to-silverlight-and-hello-to-blazor-477d5ca88a32" rel="noopener follow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">准备向Silverlight告别，向Blazor问好</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">我当时不知道的是，2011年12月9日发布的Silverlight 5将是……</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">medium.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><p id="e048" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经将按照本文中的步骤创建的完整解决方案上传到GitHub。本文的代码可以从ArticleOne分支或V4.1版本中检索。该存储库位于:</p><div class="kw kx gp gr ky kz"><a href="https://github.com/lchendricks/BlazorMVVM" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">lchendrick s/blazormvm</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">一个客户端Blazor MVVM实现。通过在…上创建帐户，为lchendricks/BlazorMVVM的开发做出贡献</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">github.com</p></div></div><div class="li l"><div class="lo l lk ll lm li ln jw kz"/></div></div></a></div><p id="717f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我当前的应用程序是使用视图优先实现构建的Silverlight MVVM应用程序。导航到一个页面会打开Silverlight XAML页面，该页面实例化它自己的ViewModel，然后实例化一个视图。Blazor也可以很容易地做到这一点，使用内置的依赖注入，它甚至比我的Silverlight应用程序做得更干净。在Blazor中实现的关系如下所示:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/bf140b64dbac394b39cfe50a2da18f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*re181uJUAJMB6--rqz8JQg.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">MVVM·布拉佐</figcaption></figure><p id="6703" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文已更新，可与Visual Studio 2019预览版一起使用。Net Core 3 preview 4和4/18版的客户端Blazor。我只关注MVVM的一个例子，没有关注任何其他相关的应用程序，比如身份验证或数据访问。我将使用包含的样本模板；如果你已经在你的系统上安装了所有的东西，你可以启动一个新的Blazor(ASP.Net核心托管)应用程序，并遵循以下步骤。</p><h1 id="078f" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">项目结构</h1><p id="bc88" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">为了开始并保持我们的项目整洁，我们将在。视图、视图模型和模型的客户端项目:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1bfb83db00739cbf7ba416cec471811d.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*QiD29gUGY3cMUffcWGgpfQ.png"/></div></figure><p id="19ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使我们的视图看起来和工作起来与现有的示例页面一样，我们将same _Imports.razor添加到pages文件夹中的Views文件夹中。对于此示例，我们将从示例中重新创建FetchData页面，因此添加以下三个文件:</p><ul class=""><li id="c5fa" class="nc nd iq ka b kb kc kf kg kj ne kn nf kr ng kv nh ni nj nk bi translated">在视图文件夹中提取数据视图作为新的Razor视图</li><li id="1d21" class="nc nd iq ka b kb nl kf nm kj nn kn no kr np kv nh ni nj nk bi translated">将FetchDataViewModel作为ViewModels文件夹中的新C#类</li><li id="e2d6" class="nc nd iq ka b kb nl kf nm kj nn kn no kr np kv nh ni nj nk bi translated">将FetchDataModel作为Models文件夹中的新C#类</li></ul><p id="f1d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的解决方案现在看起来像这样:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/af986531a23922659418ea85be4ef467.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*RF0v5-MrC9OThG2RM5Qvzw.png"/></div></figure><p id="8f0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了能够在我们开始测试时获得新的视图，进入共享文件夹中的NavMenu.razor并修改包含NavMenu的div。只需复制列表项块并将其粘贴为第四项，然后将href修改为“fetchdatamvvm”，将span文本修改为“Fetch data MVVM”。更新后的导航菜单将类似于下面的代码。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="d830" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">视图和视图模型</h1><p id="f7ae" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">首先，向FetchDataView.razor添加最少的内容。</p><pre class="lq lr ls lt gt nt nu nv nw aw nx bi"><span id="2d4f" class="ny lz iq nu b gy nz oa l ob oc">@page "/fetchdatamvvm"</span><span id="15ee" class="ny lz iq nu b gy od oa l ob oc">&lt;h1&gt;Weather forecast&lt;/h1&gt;</span><span id="191e" class="ny lz iq nu b gy od oa l ob oc">&lt;p&gt;This component demonstrates fetching data from the server.&lt;/p&gt;</span></pre><p id="3cf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们可以在debug中启动应用程序，看到视图是可访问的，并返回我们添加的静态HTML:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/050ee4dfb6df43d8f0cf2d545d29aa92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tK89ZdXeUr37l3Tt6zswnQ.png"/></div></div></figure><p id="3977" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的视图已经存在，它需要一个ViewModel来绑定。如果我们从示例应用程序返回到FetchData页面，我们会看到有一个WeatherForecast数组和一个填充该数组的异步方法。转到FetchDataViewModel.cs，用以下代码更新它:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5071" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们用类中的公共属性创建了一个私有数组来保存和公开我们的WeatherForecast[]。我们还增加了一个控制台。Writeline()到我们的构造函数中，这样我们就可以在浏览器调试工具中看到我们的对象正在被实例化。不幸的是，我们现在还不能在客户端C#上的Visual Studio中为Blazor设置断点，所以这是我们可以使用的选项之一。我们还为我们的类声明了一个公共接口。本着松耦合和可测试性的精神，我们将对所有引用使用接口。</p><p id="c34e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了一个视图模型，我们要让它对我们的视图可用。我们将使用。Net核心内置依赖注入。转到我们的客户端项目中的Startup.cs，将这行代码添加到ConfigureServices方法中(以及必要的using语句):</p><pre class="lq lr ls lt gt nt nu nv nw aw nx bi"><span id="a848" class="ny lz iq nu b gy nz oa l ob oc">services.AddTransient&lt;IFetchDataViewModel, FetchDataViewModel&gt;();</span></pre><p id="469a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是一篇关于依赖注入的文章，但是这条语句将为任何请求IFetchDataViewModel的类提供一个新的FetchDataViewModel实例。AddTransient方法是接收新实例的原因；还有AddSingleton和AddScoped，我们今天不会用到它们。</p><p id="5cd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们的视图模型已经可以使用了，我们可以更新我们的视图来使用它。返回FetchDataView，在page指令下添加这两行代码:</p><pre class="lq lr ls lt gt nt nu nv nw aw nx bi"><span id="929a" class="ny lz iq nu b gy nz oa l ob oc">@using  BlazorMVVM.Client.ViewModels</span><span id="be54" class="ny lz iq nu b gy od oa l ob oc">@inject IFetchDataViewModel fetchDataViewModel</span></pre><p id="3602" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将这段代码添加到静态html的下面:</p><pre class="lq lr ls lt gt nt nu nv nw aw nx bi"><span id="908d" class="ny lz iq nu b gy nz oa l ob oc">@if (fetchDataViewModel.WeatherForecasts == null)<br/>{<br/>   &lt;p&gt;&lt;em&gt;Loading...&lt;/em&gt;&lt;/p&gt;<br/>}<br/>else<br/>{}</span></pre><p id="551a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">@using语句就像C#类中的语句一样；它使名称空间对我们的视图可用。@inject语句告诉我们的依赖注入容器给我们一个IFetchDataViewModel的新实例。由于我们在Startup.cs中添加的语句，这将导致ViewModel接收FetchDataViewModel的新实例。视图现在看起来像这样:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e8bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的视图现在连接到我们的视图模型。我们可以通过启动应用程序、打开浏览器控制台并导航到视图来证明这一点。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/67505977edb70ebddc51fb240235d471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEEMzvrLvcJYc57O_ikxuQ.png"/></div></div></figure><p id="ad8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到，由于fetchDataViewModel，我们在视图上收到了加载文本。WeatherForecasts为null，符合条件，控制台输出显示了我们添加到调试器中的语句。现在我们有了一个工作视图模型和视图，我们可以实现和连接我们的模型。</p><h1 id="5ff1" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">添加模型</h1><p id="c644" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">在本文中，我们将构建一个简单的传递模型，而不是讨论在模型中存储数据并让ViewModel转换它。我们将在下一篇文章中真正做到这一点。返回到FetchDataModel并输入以下代码:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1ba9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经创建了一个公共方法，并在IFetchDataModel接口中公开了它。我们还声明了一个私有变量来保存HttpClient实例。请注意，在我们编写的代码中，没有其他地方引用HttpClient。我们使用构造器依赖注入(与我们在视图中使用的@inject语句相反)让框架为我们提供一个HttpClient。这段代码为我们提供了一个HttpClient，它已经配置好并准备好回调服务器，它与默认模板中的FetchData页面中使用的是同一个客户端。“RetrieveForecastsAsync()”方法只是向服务器发出GET请求，以获取我们的WeatherForecast[]。</p><p id="9820" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，模型已经具备了我们需要的基本功能，我们可以转到Startup.cs，并使用这行代码(以及所需的using语句)将其添加到ConfigureServices中:</p><pre class="lq lr ls lt gt nt nu nv nw aw nx bi"><span id="95b4" class="ny lz iq nu b gy nz oa l ob oc">services.AddTransient&lt;IFetchDataModel, FetchDataModel&gt;();</span></pre><p id="4a14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以更新FetchDataViewModel来实例化模型。我们要做的第一件事是更新我们的构造函数，从依赖注入中获取模型的一个实例。向ViewModel添加另一个私有成员以及所需的using语句:</p><pre class="lq lr ls lt gt nt nu nv nw aw nx bi"><span id="6b7a" class="ny lz iq nu b gy nz oa l ob oc">private IFetchDataModel _fetchDataModel;</span></pre><p id="ff37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后更新ViewModel构造函数，用一个实现填充它:</p><pre class="lq lr ls lt gt nt nu nv nw aw nx bi"><span id="ae88" class="ny lz iq nu b gy nz oa l ob oc">public FetchDataViewModel(IFetchDataModel fetchDataModel)<br/>{<br/>   Console.WriteLine("FetchDataViewModel Constructor Executing");<br/>   _fetchDataModel = fetchDataModel;<br/>}</span></pre><p id="c01b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然模型已经实现并可访问，我们将添加一个方法，向模型请求天气预报[]。将以下方法添加到ViewModel中:</p><pre class="lq lr ls lt gt nt nu nv nw aw nx bi"><span id="b1a3" class="ny lz iq nu b gy nz oa l ob oc">public async Task RetrieveForecastsAsync()<br/>{<br/> _weatherForecasts = await _fetchDataModel.RetrieveForecastsAsync();<br/> Console.WriteLine("FetchDataViewModel Forecasts Retrieved");<br/>}</span></pre><p id="bd0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还将这一行添加到接口中，以公开新方法:</p><pre class="lq lr ls lt gt nt nu nv nw aw nx bi"><span id="044c" class="ny lz iq nu b gy nz oa l ob oc">Task RetrieveForecastsAsync();</span></pre><p id="04c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">FetchDataViewModel现在看起来像这样:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3133" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们的模型和视图模型连接在一起，我们将让视图向视图模型请求数据。我们将挂钩到Blazor视图的生命周期中，所以现在我将它直接包含在视图中。当您需要大量特定于视图的代码时，另一个可能更好的选择是在类后创建代码。为此，声明一个从“ComponentBase”继承的C#类，然后让视图使用“@inherits”使该类成为视图的代码。然后，您可以重写该代码中的任何生命周期方法。现在，我们将把这段代码添加到FetchDataView的底部:</p><pre class="lq lr ls lt gt nt nu nv nw aw nx bi"><span id="ddb2" class="ny lz iq nu b gy nz oa l ob oc">@functions {<br/>   protected override async Task OnInitAsync()<br/>   {<br/>      await fetchDataViewModel.RetrieveForecastsAsync();<br/>   }<br/>}</span></pre><p id="0125" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将调用服务器在视图初始化时填充WeatherForecasts[]。此时，我们可以再次启动应用程序，我们将看到加载消息短暂出现，然后在模型收到WeatherForecast[]并将其传递给ViewModel后消失。</p><h1 id="9222" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">将这一切结合在一起</h1><p id="29a0" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">最后一步是更新视图以匹配原始的FetchData页面。用以下代码替换视图中的空else{}块:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bc16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这与原始页面中的代码完全相同，只是它现在引用的是ViewModel，而不是函数块中的页面局部变量。如果我们现在运行应用程序并导航到FetchDataMVVM选项卡，我们将看到我们的预测:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/48aff7f2752e71f1055dca37f2b0c031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbAwZi3lD4SVvaUaPwei1A.png"/></div></div></figure><p id="e306" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个小的示例应用程序中，这可能有点矫枉过正，但是一旦应用程序变得更大、更复杂，维护起来就容易多了。将所有的视图模型和模型作为没有具体依赖关系的纯C#类也将使执行单元测试或根据需要替换依赖关系变得更加容易。随着新的Blazor预览版的发布，我会尽量保持更新。</p><p id="6ea4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文的后续部分现在可以在本文中构建的项目的基础上获得:</p><div class="kw kx gp gr ky kz"><a href="https://medium.com/@haywireiv/building-on-the-simple-mvvm-implemention-in-client-side-blazor-c2e75c703fae" rel="noopener follow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">在客户端Blazor中构建简单的MVVM实现</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">在位于此处的第一篇文章中，我们采用了Blazor预览版0.9.0附带的默认托管Blazor应用程序模板…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">medium.com</p></div></div><div class="li l"><div class="oh l lk ll lm li ln jw kz"/></div></div></a></div></div></div>    
</body>
</html>