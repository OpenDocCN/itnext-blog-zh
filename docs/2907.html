<html>
<head>
<title>Laravel: The Fantastic 4 Interfaces — Htmlable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel:奇妙的4个界面— Htmlable</h1>
<blockquote>原文：<a href="https://itnext.io/laravel-the-fantastic-4-interfaces-renderable-6dbdd3c5e539?source=collection_archive---------4-----------------------#2019-08-26">https://itnext.io/laravel-the-fantastic-4-interfaces-renderable-6dbdd3c5e539?source=collection_archive---------4-----------------------#2019-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1587" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习响应代码，一次一个实现。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ae6eda4c67954cc3e512fb77187bac35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ea8OJpZ9mPCPEVOL"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0a3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该归功于谁。去年我偶然发现了Josip Crnkovi的一篇文章，他在文章中介绍了这个框架的一些有用的接口。在其中，他<em class="ls">发现了</em>一些用于向浏览器发送响应的消息。</p><p id="1916" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在尝试之后，我不得不说这些减轻了很多枯燥的问题，并且将多行代码精简为几行。在这一系列文章中，我将检查它们，因为它们可以帮助您更容易地编写应用程序。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="9026" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">html表格</h1><p id="db95" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">庆幸吧，这是最有用的！推动这个接口的方法叫做<code class="fe mx my mz na b">toHtml()</code>，它负责将类表示为一个HTML字符串。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7a28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当刀片模板引擎检测到双花括号内的Htmlable实例时，就会调用这个方法——你知道，就是那个<code class="fe mx my mz na b">{{ }}</code>的东西。当找到它时，它将继续使用<code class="fe mx my mz na b">toHtml()</code>方法，而不是试图将它转换为字符串。</p><p id="314d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于可以用几行代码呈现为HTML的类很有用。例如，<a class="ae kv" href="https://github.com/DarkGhostHunter/Laralerts/blob/master/src/AlertsHtml.php#L37-L53" rel="noopener ugc nofollow" target="_blank">我的Laralerts包使用Htmlable接口</a>将每个警报呈现为带有警报消息的HTML字符串，将逻辑放在一个地方，而不是在每个警报中调用视图工厂。</p><p id="ff0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对分页链接也很有用:当你使用类似于<code class="fe mx my mz na b">$pagination-&gt;links()</code>的东西时，它会返回一个<code class="fe mx my mz na b">AbstractPaginator</code>的实例，而<a class="ae kv" href="https://github.com/laravel/framework/blob/5.8/src/Illuminate/Pagination/AbstractPaginator.php#L628-L636" rel="noopener ugc nofollow" target="_blank">会将这个实例转换成一个HTML字符串</a>。</p><h1 id="907e" class="ma mb iq bd mc md nd mf mg mh ne mj mk jw nf jx mm jz ng ka mo kc nh kd mq mr bi translated">示例:渲染参与者</h1><p id="44fc" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">假设我们需要将参与者模型的每个实例转换为HTML，这些实例是播客中出现的人的个人资料。我们可以很容易地返回一个简单的字符串，或者更好地呈现一个视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d56c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们把它调用到我们的视图中，一旦它被渲染，我们就看着它变魔术。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b4e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这与可渲染不同。如果你单独推一个类，将会抛出一个错误，除非这个类作为最后一个资源有一个<code class="fe mx my mz na b">_toString()</code>方法，它应该镜像<code class="fe mx my mz na b">toHtml()</code>方法。</p></div></div>    
</body>
</html>