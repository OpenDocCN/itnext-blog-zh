<html>
<head>
<title>Forcefully Closing TCP Connections in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强制关闭Golang中的TCP连接</h1>
<blockquote>原文：<a href="https://itnext.io/forcefully-close-tcp-connections-in-golang-e5f5b1b14ce6?source=collection_archive---------0-----------------------#2021-09-07">https://itnext.io/forcefully-close-tcp-connections-in-golang-e5f5b1b14ce6?source=collection_archive---------0-----------------------#2021-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ba612d4247a57469dd0236e97fc9c42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-8aJ51LfCfTm6yZEvNeoA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">何塞·安东尼奥·加列戈·巴斯克斯在<a class="ae kf" href="https://unsplash.com/s/photos/reset?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="60b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用TCP服务器是熟悉底层网络通信的好方法。当编写直接通过TCP套接字通信的应用程序时，需要大量的套接字管理步骤。对于典型的基于HTTP的应用程序，您通常不必采取这些操作。</p><p id="dd63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时，这些额外的管理步骤包括必须强制关闭TCP会话。</p><p id="1adf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天的文章将讨论两种关闭TCP会话的方法；传统的默认关闭和使用<code class="fe le lf lg lh b">SetLinger()</code>方法的强制关闭。本文还将解释为什么这些方法不同，以及何时应该使用每种方法。</p><h2 id="e500" class="li lj it bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated">Go中的基本TCP服务器</h2><p id="f204" class="pw-post-body-paragraph kg kh it ki b kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">我们将在本文中使用的编程语言是Golang，但是讨论的概念是通用的，适用于整个网络。</p><p id="5525" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是Go中一个基本的TCP服务器。该服务器监听单个端口，回显发送给它的任何数据，当然，为了更好地显示关闭的连接，它将在一段时间后关闭连接。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d453" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将上面的代码分成四个主要部分。</p><p id="af78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个通过开始监听端口<code class="fe le lf lg lh b">9000</code>上的TCP连接来创建<code class="fe le lf lg lh b">net.Listener</code>。在内部，Go告诉系统内核在所有可用的接口上绑定端口<code class="fe le lf lg lh b">9000</code>。</p><p id="b3cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果成功，代码转到第二部分，程序通过调用<code class="fe le lf lg lh b">net.Listener.Accept()</code>方法等待新的TCP连接。<code class="fe le lf lg lh b">Accept()</code>方法将等待新的连接到达，并将该连接作为<code class="fe le lf lg lh b">net.Conn</code>返回。从这里，我们的节目开始第三和第四部分。</p><p id="27c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第三部分，我们的代码开始一个新的goroutine这个goroutine采用被称为<code class="fe le lf lg lh b">c</code>的<code class="fe le lf lg lh b">net.Conn</code>，并开始读取和写入连接。对于写入这个TCP连接的所有内容，这个goroutine将写回同一个连接。</p><p id="414b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第四部分是本文的重点。这里，我们的程序创建了另一个goroutine，但是这个goroutine使用了<code class="fe le lf lg lh b">time.After</code>来等待15秒。一旦这15秒结束，我们的goroutine将通过<code class="fe le lf lg lh b">defer</code>函数调用<code class="fe le lf lg lh b">net.Conn.Close()</code>。实际上，从服务器端关闭我们的TCP会话。</p><h2 id="d276" class="li lj it bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated">Go中的一个基本TCP客户端</h2><p id="930c" class="pw-post-body-paragraph kg kh it ki b kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">为了连接到我们的TCP服务器，我们将使用下面的客户端代码，也是用Go编写的。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="4a7a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的客户可以分为三个不同的部分。</p><p id="cdbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们使用<code class="fe le lf lg lh b">net.Dial()</code>方法打开一个TCP连接到我们的TCP服务器正在监听的同一个<code class="fe le lf lg lh b">localhost:9000</code>地址。</p><p id="1d89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">利用返回的<code class="fe le lf lg lh b">net.Conn</code>，第二部分使用<code class="fe le lf lg lh b">net.Conn.Write()</code>方法编写我们的示例消息。</p><p id="2878" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，第三部分只是简单地循环一个<code class="fe le lf lg lh b">net.Conn.Read()</code>方法来连续读取从TCP服务器发送的数据。</p><h2 id="6f4d" class="li lj it bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated">运行我们的客户端和服务器</h2><p id="1170" class="pw-post-body-paragraph kg kh it ki b kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">我们的客户机和服务器已经准备好了，让我们看看运行它们时会发生什么。</p><p id="2b69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的输出来自我们的TCP服务器。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="27e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面我们可以看到，我们的服务器看到了一个打开的TCP会话，过了一会儿，输出一个错误，指出我们的服务器试图从一个关闭的网络连接中读取。</p><p id="743f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑到我们有一个从TCP连接读取的goroutine，而在另一个goroutine中，我们关闭了那个连接，这种行为是可以预料的。</p><p id="3c92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，对于本练习，该错误表明我们成功关闭了服务器端的会话。</p><p id="6c3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们来看看TCP客户端的输出。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="66e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这个输出中，我们可以看到我们的TCP会话被打开了，不久之后(与来自TCP服务器的时间戳相匹配)，我们从连接中收到了一个<strong class="ki iu"> EOF </strong>错误。同样，这也是我们所期望的。当远程端很好地关闭了我们的TCP会话时，我们的客户端收到了一个错误类型(<code class="fe le lf lg lh b">io.EOF</code>)。</p><h2 id="d899" class="li lj it bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated">学习<code class="fe le lf lg lh b">net.Conn.Close()</code>如何工作</h2><p id="59f6" class="pw-post-body-paragraph kg kh it ki b kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">根据Go文档，默认情况下，在执行<code class="fe le lf lg lh b">net.Conn.Close()</code>方法后；在后台，操作系统将完成所有数据的发送，然后关闭TCP会话。</p><p id="004c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着，当我们执行我们的<code class="fe le lf lg lh b">net.Conn.Close()</code>方法时，我们对其执行的TCP会话将启动一个连接终止序列，其中包括处理(丢弃)任何未完成的数据。也就是说，直到我们接收到最后的<code class="fe le lf lg lh b">FIN-ACK</code>包。</p><p id="f4c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了更好地了解这种行为，让我们来看一个使用<code class="fe le lf lg lh b">tcpdump</code>命令的TCP客户端和服务器通信的网络捕获。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="4870" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在研究网络通信时,<code class="fe le lf lg lh b">tcpdump</code>命令是一个方便的工具。它允许我们捕获和查看网络数据包。</p><p id="c7df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我使用了<code class="fe le lf lg lh b">-i</code>标志将我的网络接口指定为<code class="fe le lf lg lh b">lo0</code>我的环回接口。我使用<code class="fe le lf lg lh b">port 9000</code>过滤网络捕获，只捕获与端口<code class="fe le lf lg lh b">9000</code>通信或来自端口<code class="fe le lf lg lh b">9000</code>的流量。</p><p id="42d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第<code class="fe le lf lg lh b">3</code>行，我们可以看到客户端(源端口<code class="fe le lf lg lh b">50796</code>)向端口<code class="fe le lf lg lh b">9000</code>(TCP服务器)发送了一个<code class="fe le lf lg lh b">SYN</code>数据包(显示为<code class="fe le lf lg lh b">Flags [S]</code>)。在接下来的几行中，我们可以看到服务器发回一个<code class="fe le lf lg lh b">SYN-ACK</code>(显示为<code class="fe le lf lg lh b">Flags [S.]</code>)，客户端发送一个<code class="fe le lf lg lh b">ACK</code>(显示为<code class="fe le lf lg lh b">Flags [.]</code>)来确认<code class="fe le lf lg lh b">SYN-ACK</code>数据包。然后完成3次TCP握手。</p><p id="a9bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这里开始，我们的客户机和服务器来回发送数据，直到第<code class="fe le lf lg lh b">11</code>行，在这里我们的TCP服务器向TCP客户机发送一个<code class="fe le lf lg lh b">FIN</code>包。</p><p id="0882" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在接下来的两行中，我们可以看到TCP客户端发送了另一个<code class="fe le lf lg lh b">ACK</code>，后跟一个<code class="fe le lf lg lh b">FIN-ACK</code>。TCP服务器用确认<code class="fe le lf lg lh b">FIN-ACK</code>的<code class="fe le lf lg lh b">ACK</code>来回复。</p><p id="27ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从网络捕获中，我们可以看到一个标准的TCP闭包是如何工作的。我们可以看到，即使我们的程序可能已经执行了<code class="fe le lf lg lh b">net.Conn.Close()</code>方法，在操作系统的后台，连接仍然是活动的，直到我们接收到最后的<code class="fe le lf lg lh b">FIN-ACK</code>包。</p><h2 id="8b6f" class="li lj it bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated">强制关闭TCP会话</h2><p id="7cc9" class="pw-post-body-paragraph kg kh it ki b kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">虽然上面的例子已经展示了默认行为，但是执行更“强有力”的套接字关闭是可能的。在Go中，我们可以使用<code class="fe le lf lg lh b">net.TCPConn.SetLinger()</code>方法来控制这种行为。</p><p id="6176" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该方法通过对操作系统的系统调用来改变<code class="fe le lf lg lh b">SO_LINGER</code>套接字选项值。</p><p id="550d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了展示这一切是如何工作的，让我们对我们最初的TCP服务器做一些简单的修改。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="4e4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在很大程度上，这个版本的TCP服务器与以前的相同，只有一个关键的区别。在第<code class="fe le lf lg lh b">59</code>行运行<code class="fe le lf lg lh b">net.Conn.Close()</code>之前，我们的应用程序正在执行<code class="fe le lf lg lh b">net.TCPConn.SetLinger()</code>，将值<code class="fe le lf lg lh b">0</code>传递给方法。</p><p id="6603" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过向<code class="fe le lf lg lh b">net.TCPConn.SetLinger()</code>方法传递一个值来定义操作系统在关闭TCP连接时的行为。</p><p id="498b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">传递的值可以被认为是以秒为单位的计时器值。</p><p id="dbc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某些操作系统中，当传递大于<code class="fe le lf lg lh b">0</code>的任何内容时，这将导致连接以与默认行为相同的方式运行，只是在定义的秒数后，任何未完成的流量都会被拒绝。</p><p id="af91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当精确设置为<code class="fe le lf lg lh b">0</code>时，操作系统将立即关闭连接并丢弃任何未完成的数据包。为了更好地理解发生了什么，让我们使用仍在运行的<code class="fe le lf lg lh b">tcpdump</code>命令来看看这个例子。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="7b24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过上面的输出，我们可以再次看到通过<code class="fe le lf lg lh b">SYN</code>、<code class="fe le lf lg lh b">SYN-ACK</code>和<code class="fe le lf lg lh b">ACK</code>三次握手建立了一个TCP会话。我们也可以在这个截图中看到闭包，但是这一次，闭包过程看起来有点不同。</p><p id="8e54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TCP服务器没有发送<code class="fe le lf lg lh b">FIN</code>数据包，而是向TCP客户端发送了<code class="fe le lf lg lh b">RST</code>(显示为<code class="fe le lf lg lh b">Flags [R.]</code>)数据包。</p><p id="f8b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是对话中的最后一个数据包；此流中没有确认。这是故意的。</p><p id="a1dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">RST</code>数据包是一种特殊类型的数据包，用于“重置”TCP连接。这是发送方告诉远程方它不会接受或接收该连接的新数据的一种方式。TCP客户端不需要确认这个关闭，因为TCP服务器将拒绝所有接收到的数据。</p><h2 id="83ac" class="li lj it bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated">摘要</h2><p id="858c" class="pw-post-body-paragraph kg kh it ki b kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">至此，我们已经探索了关闭TCP会话的默认过程，并展示了强制关闭TCP会话的过程。</p><p id="2f01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还深入研究了操作系统中的底层过程，以及这两种方法在网络级别上的不同之处。</p><p id="7585" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们还没有探究为什么我们应该知道这种区别，以及何时应该使用每个过程。</p><p id="27e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般来说，作为一个TCP服务器，关闭一个TCP会话时，最好使用默认的<code class="fe le lf lg lh b">net.Conn.Close()</code>进程，不改变任何<code class="fe le lf lg lh b">SO_LINGER</code>选项。这适用于大多数用例，如超时、响应最终消息或任何其他典型行为。</p><p id="d554" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">A <code class="fe le lf lg lh b">RST</code>应该被保留用于当客户端行为是非典型的或者当所有通信必须完成时。一个例子可能是一个应用程序有许多，许多短期连接。</p><p id="0ace" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用默认方式关闭时，每个连接都会经历一系列连接状态，如<code class="fe le lf lg lh b">FIN_WAIT_1</code>、<code class="fe le lf lg lh b">FIN_WAIT_2</code>、<code class="fe le lf lg lh b">TIME_WAIT</code>等。，使连接在系统上停留一段时间。夺取资源。使用强制关闭会立即关闭这些连接，释放资源，如打开的文件等。</p><p id="86bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个例子是当一个连接对一个保留的或特殊的端口打开时。在这些情况下，通常使用<code class="fe le lf lg lh b">RST</code>数据包来表示不希望的行为。</p><p id="66c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于大多数应用程序和关闭场景，TCP客户端应该启动连接关闭。因此，TCP服务器通常会将<code class="fe le lf lg lh b">RST</code>数据包用于需要服务器启动连接关闭的特殊情况。</p></div></div>    
</body>
</html>