<html>
<head>
<title>ES6 Destructuring and Variable Renaming Explained!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6析构和变量重命名解释！</h1>
<blockquote>原文：<a href="https://itnext.io/es6-destructuring-and-variable-renaming-explained-618fac4207e7?source=collection_archive---------4-----------------------#2018-09-24">https://itnext.io/es6-destructuring-and-variable-renaming-explained-618fac4207e7?source=collection_archive---------4-----------------------#2018-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ac9dbdd8b495174b6069d837538d270a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0tbY-HJLXDU2gvd5J6j8Q.png"/></div></div></figure><p id="8936" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">析构对象和数组可能是ES6中最常用的特性，这是有道理的。这种简单的技术对于编写更简洁、可读性更强的JavaScript代码来说是惊人的。ES6附带的另一个很酷的特性是变量重命名。唯一的问题是，这可能会给仍在努力掌握现代JavaScript所能提供的一切的编码人员带来一些困惑。让我们在实践中看看这两个概念，并向您展示陷阱通常出现在哪里。</p><h1 id="92ec" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">实践中的基本解构</h1><p id="0187" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设我们有一个<code class="fe lz ma mb mc b">person</code>对象，它的键<code class="fe lz ma mb mc b">name</code>和<code class="fe lz ma mb mc b">surname</code>声明如下:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="0726" class="ml kx iq mc b gy mm mn l mo mp">const person = {<br/>  name: 'Barry',<br/>  surname: 'Doyle',<br/>};</span></pre><p id="75bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想以传统方式将<code class="fe lz ma mb mc b">person</code>的<code class="fe lz ma mb mc b">name</code>和<code class="fe lz ma mb mc b">surname</code>记录到控制台，你可以这样做:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="80ac" class="ml kx iq mc b gy mm mn l mo mp">console.log(person.name, person.surname); // Barry Doyle</span></pre><p id="da6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是因为我们都是DRY的忠实粉丝(不要重复自己的话)，我们可以使用ES6来破坏像这样的人的<code class="fe lz ma mb mc b">name</code>和<code class="fe lz ma mb mc b">surname</code>:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="f20b" class="ml kx iq mc b gy mm mn l mo mp">const { name, surname } = person;</span><span id="c321" class="ml kx iq mc b gy mq mn l mo mp">console.log(name, surname); // Barry Doyle</span></pre><p id="25e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这显然需要写更多的行，所以现在可能不太理想。但是当你开始处理更大的对象时，它会有很大的帮助。作为一般的经验法则，如果析构阻止你重复你自己，那么就使用它！否则就别烦了，不值得。例如，如果我们只想将<code class="fe lz ma mb mc b">name</code>记录到控制台，那么我会强烈反对只对一个变量使用析构。</p><h1 id="6786" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">更深的嵌套析构</h1><p id="f26f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">上面我给了你一个简单的例子。让我们来看看更复杂的东西。如果我们有一个客体的客体呢？想象一下，我扩展了我的<code class="fe lz ma mb mc b">person</code>对象来包含一个名为<code class="fe lz ma mb mc b">skills</code>的键，它是一个代表我的一些技能的键的对象。出于这个例子的目的，我将给我的<code class="fe lz ma mb mc b">skills</code>对象两个键:<code class="fe lz ma mb mc b">JavaScript</code>和<code class="fe lz ma mb mc b">React</code>。这些键中的每一个都有一个里面有一个键的对象的值。我的每个对象的键都是<code class="fe lz ma mb mc b">years</code>,它代表我在对象键中的经验年限。下面是我们新的扩展<code class="fe lz ma mb mc b">person</code>对象的声明:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="cee7" class="ml kx iq mc b gy mm mn l mo mp">const person {<br/>  name: 'Barry',<br/>  surname: 'Doyle',<br/>  skills: {<br/>    JavaScript: {<br/>      years: 7,<br/>    },<br/>    React: {<br/>      years: 4,<br/>    },<br/>  },<br/>};</span></pre><p id="1856" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，分别为<code class="fe lz ma mb mc b">JavaScript</code>和<code class="fe lz ma mb mc b">React</code>注销我的<code class="fe lz ma mb mc b">name</code>、<code class="fe lz ma mb mc b">surname</code>和多年经验的老式方法是做以下事情:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="e8e7" class="ml kx iq mc b gy mm mn l mo mp">console.log(<br/>  person.name,<br/>  person.surname,<br/>  person.skills.JavaScript.years,<br/>  person.skills.React.years<br/>); // Barry Doyle 7 4</span></pre><p id="d85c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，使用我们出色的ES6析构技术，我们可以简化控制台日志，如下所示:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="b620" class="ml kx iq mc b gy mm mn l mo mp">const { name, surname, skills: { JavaScript, React } } = person;</span><span id="3fe6" class="ml kx iq mc b gy mq mn l mo mp">console.log(name, surname, JavaScript.years, React.years)<br/>// Barry Doyle 7 4</span></pre><p id="e15e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个奇怪的不寻常的例子，但我希望你明白这一点。我们可以更进一步，从<code class="fe lz ma mb mc b">JavaScript</code>或<code class="fe lz ma mb mc b">React</code>对象中析构<code class="fe lz ma mb mc b">years</code>。然而，我们不能同时从两个变量中得到它，因为那样我们会有一个变量名指向两个不同的值，这是行不通的。一个解决方法是在我们析构变量时重命名<code class="fe lz ma mb mc b">year</code>变量。</p><h1 id="923c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">析构时重命名变量</h1><p id="6b87" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们以上面的例子为例，将名称<code class="fe lz ma mb mc b">javaScriptYears</code>和<code class="fe lz ma mb mc b">reactYears</code>分别分配给分配给<code class="fe lz ma mb mc b">JavaScript</code>和<code class="fe lz ma mb mc b">React</code>对象的<code class="fe lz ma mb mc b">years</code>键。为了保持代码的整洁，我将对析构语句进行多行处理。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="bc5f" class="ml kx iq mc b gy mm mn l mo mp">const {<br/>  name,<br/>  surname,<br/>  skills: {<br/>    JavaScript: { years: javaScriptYears },<br/>    React: { years: reactYears },<br/>  },<br/>} = person;</span><span id="53a1" class="ml kx iq mc b gy mq mn l mo mp">console.log(name, surname, javaScriptYears, reactYears);<br/>// Barry Doyle 7 4</span></pre><p id="9847" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这种技术，我们避免了通过从我们的<code class="fe lz ma mb mc b">person</code>对象中析构两个不同的<code class="fe lz ma mb mc b">years</code>值而产生的重复变量名问题。以便在析构变量时重命名变量。您需要在您正在析构的变量后添加一个<code class="fe lz ma mb mc b">:</code>,后跟您想要将析构变量重命名为的变量名。</p><p id="6e22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意我们怎么说<code class="fe lz ma mb mc b">years: javaScriptYears</code>而不是<code class="fe lz ma mb mc b">years: { javaScriptYears }</code>。做前者会将<code class="fe lz ma mb mc b">years</code>重命名为<code class="fe lz ma mb mc b">javaScriptYears</code>，而做后者意味着<code class="fe lz ma mb mc b">years</code>是一个带有键<code class="fe lz ma mb mc b">javaScriptYears</code>的对象，而你正试图从<code class="fe lz ma mb mc b">years</code>中析构它。</p><h1 id="c154" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">析构可以在方法内部完成</h1><p id="4de3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">关于析构最好的部分是，它可以很容易地在运行中完成。假设我们有一个名为<code class="fe lz ma mb mc b">people</code>的对象数组，实现如下:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="7635" class="ml kx iq mc b gy mm mn l mo mp">const people = [<br/>  { name: 'Barry' },<br/>  { name: 'Michael },<br/>  { name: 'Doyle' },<br/>];</span></pre><p id="4378" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们通过<code class="fe lz ma mb mc b">people</code>绘制地图，并以传统方式将每个<code class="fe lz ma mb mc b">name</code>登录到控制台:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="7446" class="ml kx iq mc b gy mm mn l mo mp">people.map(person =&gt; console.log(person.name));<br/>// Barry<br/>// Michael<br/>// Doyle</span></pre><p id="c096" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是你如何用ES6的奇特方式做到的:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="4efe" class="ml kx iq mc b gy mm mn l mo mp">people.map(({ name }) =&gt; console.log(name));<br/>// Barry<br/>// Michael<br/>// Doyle</span></pre><p id="eb70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在看起来可能没那么神奇。但是相信我，在处理更复杂的数据结构时，这些技术确实节省了大量时间，并使所有内容更容易阅读。</p><h1 id="c363" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">一个常见的陷阱和这篇文章的灵感</h1><p id="950b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">作为一名全职React开发人员，我经常看到同事们因为对变量的析构和重命名有点混淆而放弃在事件处理程序中析构。</p><p id="d798" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看这个基本的React组件:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="3841" class="ml kx iq mc b gy mm mn l mo mp">import React, { Component } from 'react';<br/>// ^^^ Look! we're even destructuring in our imports :D</span><span id="561a" class="ml kx iq mc b gy mq mn l mo mp">export default class SimpleInput extends Component {<br/>  state = {<br/>    inputText: '',<br/>  }</span><span id="bdd9" class="ml kx iq mc b gy mq mn l mo mp">  constructor(props) {<br/>    super(props);<br/>    this.handleInputChange = this.handleInputChange.bind(this);<br/>  }</span><span id="9e50" class="ml kx iq mc b gy mq mn l mo mp">  handleInputChange(event) {<br/>    this.setState({ inputText: event.target.value });<br/>  }<br/>  // ^^^ Our focus is going to be here</span><span id="d130" class="ml kx iq mc b gy mq mn l mo mp">  render() {<br/>    return (<br/>      &lt;input<br/>        onChange={this.handleInputChange}<br/>        value={this.state.inputText}<br/>      /&gt;<br/>    );<br/>    // ^^^ Notice how we don't bother destructuring inputText<br/>    // ^^^ from this.state because it doesn't prevent "DRY"<br/>  }<br/>}</span></pre><p id="e96e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个简单的React组件，实际上并没有做太多事情。但是嘿！它应该正常工作。我希望我们把注意力放在<code class="fe lz ma mb mc b">handleInputChange</code>事件处理程序上。</p><p id="2be1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">人们在试图析构变量时犯的一个常见错误是他们这样做:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="5261" class="ml kx iq mc b gy mm mn l mo mp">handleInputChange({ target: value }) {<br/>  this.setState({ inputText: value });<br/>}</span></pre><p id="fd11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们试图这样做的时候，你看，我们得到了疯狂的错误。然后我们开始不可避免地放弃，回到传统的方式去做事情，因为它从未让我们失望。</p><p id="3d5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个实现有什么问题？</p><p id="cf15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们想从<code class="fe lz ma mb mc b">target</code>对象中取出<code class="fe lz ma mb mc b">value</code>时，我们实际上是将<code class="fe lz ma mb mc b">target</code>对象重命名为<code class="fe lz ma mb mc b">value</code>。记住，我们需要做这个<code class="fe lz ma mb mc b">({ target: { value } })</code>而不是<code class="fe lz ma mb mc b">({ target: value })</code>。</p><p id="3dec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过将被析构的<code class="fe lz ma mb mc b">value</code>变量重命名为<code class="fe lz ma mb mc b">inputText</code>来进一步发展这种析构技术，并使用另一个方便的ES6特性，通过这样做使我们的代码可读性更好:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="3e11" class="ml kx iq mc b gy mm mn l mo mp">handleInputChange({ target: { value: inputText } }) {<br/>  this.setState({ inputText });<br/>}</span></pre><p id="ef89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还没有深入研究这个特性，但是这里有一个TL:dr；<br/> <code class="fe lz ma mb mc b">({ inputText })</code>与<code class="fe lz ma mb mc b">({ inputText: inputText })</code>相同。</p><h1 id="6ced" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="5d1f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我希望这篇文章教会了你一些新的东西，或者至少巩固了你对这些流行的ES6技术的理解。</p><p id="b651" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的灵感来自于<a class="ae mr" href="https://amzn.to/2DrCUiR" rel="noopener ugc nofollow" target="_blank">完整的软件开发人员职业指南:如何快速学习编程语言，如何在编程面试中胜出，如何获得你梦想中的软件开发人员工作</a>。这本书在提供的链接上非常便宜，而且价值远远超过你为它支付的费用。毫无疑问，它是迄今为止对我作为一名专业软件开发人员的成长影响最大的因素！</p><p id="de9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，请留下一些赞或掌声。另外，请务必在<a class="ae mr" href="https://www.facebook.com/barrymichaeldoyle" rel="noopener ugc nofollow" target="_blank">脸书</a>、<a class="ae mr" href="https://twitter.com/barrymdoyle" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae mr" href="https://medium.com/@barrymdoyle" rel="noopener">媒体</a>、<a class="ae mr" href="https://www.youtube.com/barrymichaeldoyle?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> YouTube </a>和<a class="ae mr" href="https://www.linkedin.com/in/barry-michael-doyle-11369683/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我，随时更新我制作的新内容。</p><p id="feb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在出去写史诗代码吧！</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="970b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mz">原载于2018年9月24日</em><a class="ae mr" href="https://www.barrymichaeldoyle.com/destructuring/" rel="noopener ugc nofollow" target="_blank"><em class="mz">【www.barrymichaeldoyle.com】</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>