<html>
<head>
<title>Kube-fledged: Cache Container Images in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kube-fledged:在Kubernetes中缓存容器图像</h1>
<blockquote>原文：<a href="https://itnext.io/kube-fledged-cache-container-images-in-kubernetes-7880a00bab91?source=collection_archive---------0-----------------------#2021-09-27">https://itnext.io/kube-fledged-cache-container-images-in-kubernetes-7880a00bab91?source=collection_archive---------0-----------------------#2021-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7dabbcfa9902639db586422cb170c00c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMiJdyzcPIUkGwPmGRs1tA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">游隼</figcaption></figure><div class=""/><p id="d6f1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">游隼以其速度著称，在其特有的高速俯冲过程中，其速度可达每小时200多英里，这使它成为世界上最快的鸟类，也是动物王国中速度最快的成员(来源:维基百科)</p><h1 id="018b" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">介绍</h1><p id="4758" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">当一个容器化的应用程序被部署到Kubernetes集群时，K8s控制平面将Pod调度到集群中的一个工作节点。运行在worker节点中的节点代理(Kubelet)与安装在节点中的容器运行时(例如containerd)相协调，并从映像注册表中提取必要的容器映像。根据图像的大小和可用的网络带宽，将所有图像提取到节点需要时间。因此，在任何容器化的应用程序中，我们都应该认识到从注册表中获取图像所带来的延迟。然而，作为进程运行的传统应用程序(例如由systemd管理的)不会遭受这种延迟，因为所有必需的文件都已经安装在机器中。</p><p id="b919" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设您的容器化应用程序经历了流量的突然激增，它需要立即<em class="la"/>横向扩展(即需要创建额外的实例)。如果您配置了水平Pod自动缩放器(HPA)，K8s控制平面会创建额外的Pod副本。然而，这些容器将无法用于处理增加的流量，<em class="la">直到</em>所需的图像被提取，容器启动并运行。或者假设您的应用程序需要处理高速实时数据。这种应用对启动和扩展的速度有严格的要求，这是因为它所实现的目的的本质。简而言之，在一些用例中，由于从注册表中提取图像而引入的延迟是不可接受的。此外，群集和映像注册表之间的网络连接可能会受到带宽不足的影响，或者连接可能会完全丢失。有些情况下，尤其是在边缘计算中，应用程序必须优雅地容忍间歇性的网络连接。</p><p id="3080" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些挑战可以通过不同的方式解决。在这些场景中，一个非常有用的解决方案是将容器图像直接缓存在集群工作节点上，这样Kubelet就不需要提取这些图像，而是立即使用已经缓存在节点中的图像。在这篇博客中，我将解释如何使用开源项目<a class="ae me" href="https://github.com/senthilrch/kube-fledged" rel="noopener ugc nofollow" target="_blank"><strong class="ke jg"/></a>在Kubernetes集群中构建和管理容器图像缓存。</p><h1 id="2c6f" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">现有解决方案</h1><p id="13f9" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在向您介绍kube-fledged之前，让我简要描述一下解决这个问题的现有解决方案。广泛使用的方法是让注册表镜像在集群内运行。两种广泛使用的解决方案是I)集群内自托管注册表ii)直通缓存。在前一个解决方案中，本地注册中心在k8s集群中运行，并在容器运行时被配置为镜像注册中心。任何映像拉取请求都被定向到集群内注册表。如果失败，请求将被定向到主注册表。在后一种解决方案中，本地注册表具有缓存功能。当第一次提取图像时，它被缓存在本地注册表中。对该映像的后续请求由本地注册表提供服务。</p><h2 id="179f" class="mf lc jf bd ld mg mh dn lh mi mj dp ll kn mk ml lp kr mm mn lt kv mo mp lx mq bi translated">现有解决方案的缺点</h2><ol class=""><li id="85d4" class="mr ms jf ke b kf lz kj ma kn mt kr mu kv mv kz mw mx my mz bi translated">设置和维护本地注册表镜像会消耗大量的计算和人力资源。</li><li id="4b92" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">对于跨越多个区域的大型集群，我们需要多个本地注册镜像。当应用程序实例跨越多个区域时，这会带来不必要的复杂性。您可能需要多个部署清单，每个清单都指向该区域的本地注册表镜像。</li><li id="efc8" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">这些方法不能完全解决实现Pod快速启动的要求，因为从本地镜像提取图像时仍有明显的延迟。有几个用例不能容忍这种延迟。</li><li id="1002" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">节点可能会失去与本地注册表镜像的网络连接，因此Pod将被卡住，直到连接恢复。</li></ol><h1 id="dc34" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">kube-成熟的概述</h1><figure class="ng nh ni nj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/1ea5c3faaaad23c1e98e9f103bea2bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvpphTdz8I2R-c-LGpJoaA.png"/></div></div></figure><p id="787a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">kube-friedged</strong>是一个kubernetes插件或操作器，用于直接在kubernetes集群的工作节点上创建和管理容器映像缓存。它允许用户定义图像列表以及那些图像应该被缓存(即，拉取)到哪个工作者节点上。因此，应用程序窗格几乎可以立即启动，因为不需要从注册表中提取图像。kube-friedged提供CRUD APIs来管理图像缓存的生命周期，并支持几个可配置的参数，以便根据个人需求定制功能。(网址:【https://github.com/senthilrch/kube-fledged T4】)</p><p id="0779" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">kube-fledged是作为一个通用的解决方案来设计和构建的，用于管理Kubernetes中的图像缓存。尽管主要用例是实现快速Pod启动和扩展，<em class="la">该解决方案支持多种用例</em>，如下所述</p><h2 id="0a3e" class="mf lc jf bd ld mg mh dn lh mi mj dp ll kn mk ml lp kr mm mn lt kv mo mp lx mq bi translated">用例</h2><ul class=""><li id="ecdd" class="mr ms jf ke b kf lz kj ma kn mt kr mu kv mv kz nk mx my mz bi translated">需要快速启动的应用。例如，由于数据量的激增，执行实时数据处理的应用程序需要快速扩展。</li><li id="5a39" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">因为它们需要对到来的事件立即做出反应。</li><li id="b64d" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">在边缘设备上运行的物联网应用程序，因为边缘设备和图像注册表之间的网络连接会是间歇性的。</li><li id="5e18" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">如果需要从私有注册表中提取映像，并且不能授予每个人从该注册表中提取映像的访问权限，那么可以在集群的节点上提供映像。</li><li id="e82d" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">如果集群管理员或操作员需要对应用程序进行升级，并希望提前验证新映像是否可以成功获取。</li></ul><h1 id="3022" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">kube-成熟的工作方式</h1><figure class="ng nh ni nj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/89f02991116cd05acc9614e50281cc7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54CuoD3l2NtXxg3uRbWlWw.png"/></div></div></figure><p id="4775" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Kubernetes允许开发者通过定制资源来扩展kubernetes api。kube-fledged定义了一个定制的"<strong class="ke jg"> ImageCache </strong>类资源，并实现了一个定制的控制器(名为kubefledged-controller)。kubefledged-controller负责管理图像缓存。用户可以使用kubectl命令创建和删除ImageCache资源。</p><p id="2fd0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">kubefledged-controller有一个内置的图像管理器例程，负责拖动和删除图像。使用kubernetes作业提取或删除图像。如果启用，刷新工作器会定期刷新图像缓存。kubefledged-controller在ImageCache资源的状态字段中更新图像提取、刷新和图像删除的状态。kubefledged-webhook-server负责验证ImageCache资源的字段。</p><p id="056e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您需要在集群中创建一个图像缓存，您只需要通过指定要拉取的图像列表以及一个<code class="fe nm nn no np b">nodeSelector</code>来创建一个<code class="fe nm nn no np b">ImageCache</code>清单。<code class="fe nm nn no np b">nodeSelector</code>用于指定图像应该缓存到的节点。如果您希望图像缓存在集群的所有节点中，那么省略<code class="fe nm nn no np b">nodeSelector</code>。当您向集群提交清单时，API服务器将向kubefledged-webhook-server发布一个验证webhook事件。webhook服务器验证清单的<code class="fe nm nn no np b">cacheSpec</code>。当收到来自webhook服务器的成功响应时，API服务器会将ImageCache资源保存在etcd中。这将向kubefledged-controller触发一个Informer通知，后者将请求排队。该请求由映像缓存工作线程获取，它创建多个映像拉取请求(每个节点每个映像一个请求)并将它们放入映像拉取/删除队列中。这些请求由图像管理器例程处理。对于每个请求，映像管理器都会创建一个k8s作业，负责将映像拉入缓存。映像管理器会跟踪它创建的作业，一旦作业完成，它会将响应放入一个单独的队列中。然后，image cache worker聚合来自image manager的所有结果，最后更新image cache资源的status部分。</p><p id="9e8e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">kube-fledged有一个刷新工作例程，它定期运行以保持图像缓存刷新。如果它发现缓存中缺少任何图像(可能被kubelet的图像垃圾收集删除了)，它会将图像重新拉入缓存。带有<code class="fe nm nn no np b">:latest</code>标签的图像在刷新周期中总是被重新提取。默认情况下，刷新周期每隔<code class="fe nm nn no np b">5m</code>触发一次。用户可以将其修改为不同的值，或者在部署kube-friedged时完全禁用自动刷新机制。还支持按需刷新机制，用户可以使用该机制请求kube-friedged立即刷新图像缓存。</p><h1 id="dc95" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">kube-friedged支持的图像缓存操作</h1><p id="b5b4" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">kube-fledged支持以下图像缓存操作。所有这些操作都可以使用kubectl或者通过直接向Kubernetes API服务器提交REST API请求来执行:</p><ul class=""><li id="9d21" class="mr ms jf ke b kf kg kj kk kn nq kr nr kv ns kz nk mx my mz bi translated">创建图像缓存</li><li id="4007" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">修改图像缓存</li><li id="5e51" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">刷新图像缓存</li><li id="3489" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">清除图像缓存</li><li id="a96e" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">删除图像缓存</li></ul><h1 id="240e" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">支持的容器运行时</h1><ul class=""><li id="5c92" class="mr ms jf ke b kf lz kj ma kn mt kr mu kv mv kz nk mx my mz bi translated">码头工人</li><li id="cf9e" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">集装箱d</li><li id="f448" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">中国国际广播电台</li></ul><h1 id="4aaf" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">支持的平台</h1><ul class=""><li id="1c82" class="mr ms jf ke b kf lz kj ma kn mt kr mu kv mv kz nk mx my mz bi translated">linux/amd64</li><li id="33ef" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">linux/arm</li><li id="154b" class="mr ms jf ke b kf na kj nb kn nc kr nd kv ne kz nk mx my mz bi translated">linux/arm64</li></ul><h1 id="fb83" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">试试kube-fledged</h1><p id="d09f" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">测试kube-fledged的最快方法是在项目的GitHub Repo(【https://github.com/senthilrch/kube-fledged】)中使用YAML清单来部署它。你也可以使用舵图表和舵操作员来部署它。在下面找到使用清单部署kube-fledged的步骤:</p><ul class=""><li id="a2e7" class="mr ms jf ke b kf kg kj kk kn nq kr nr kv ns kz nk mx my mz bi translated">克隆源代码库</li></ul><pre class="ng nh ni nj gt nt np nu nv aw nw bi"><span id="5bbd" class="mf lc jf np b gy nx ny l nz oa">$ mkdir -p $HOME/src/github.com/senthilrch</span><span id="7cbd" class="mf lc jf np b gy ob ny l nz oa">$ git clone https://github.com/senthilrch/kube-fledged.git $HOME/src/github.com/senthilrch/kube-fledged</span><span id="516b" class="mf lc jf np b gy ob ny l nz oa">$ cd $HOME/src/github.com/senthilrch/kube-fledged</span></pre><ul class=""><li id="fa52" class="mr ms jf ke b kf kg kj kk kn nq kr nr kv ns kz nk mx my mz bi translated">将<em class="la">部署到集群</em></li></ul><pre class="ng nh ni nj gt nt np nu nv aw nw bi"><span id="7961" class="mf lc jf np b gy nx ny l nz oa">$ make deploy-using-yaml</span></pre><ul class=""><li id="b12a" class="mr ms jf ke b kf kg kj kk kn nq kr nr kv ns kz nk mx my mz bi translated">验证<em class="la">kube-edged</em>是否部署成功</li></ul><pre class="ng nh ni nj gt nt np nu nv aw nw bi"><span id="b316" class="mf lc jf np b gy nx ny l nz oa">$ kubectl get pods -n kube-fledged -l app=kubefledged</span><span id="c87c" class="mf lc jf np b gy ob ny l nz oa">$ kubectl get imagecaches -n kube-fledged (Output should be: 'No resources found')</span></pre><h1 id="3040" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类似的解决方案</h1><p id="ebcb" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">下面是我注意到的类似开源解决方案的列表。这些解决方案试图使用替代方法来解决问题(如果你碰巧知道其他类似的解决方案，请在本博客中添加评论)。</p><p id="3412" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">Stargz snapshoter:</strong>带懒拉的快速容器图片分发插件(网址:<a class="ae me" href="https://github.com/containerd/stargz-snapshotter" rel="noopener ugc nofollow" target="_blank">https://github.com/containerd/stargz-snapshotter</a>)</p><p id="3e5f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">优步北海巨妖:</strong>北海巨妖是一个P2P Docker注册中心，能够在几秒钟内分发数TB的数据(网址:<a class="ae me" href="https://github.com/uber/kraken" rel="noopener ugc nofollow" target="_blank">https://github.com/uber/kraken</a></p><p id="ab54" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> Imagewolf: </strong> ImageWolf是一个PoC，它提供了一种非常快速的方式将Docker映像加载到您的集群中，从而允许更快地推送更新(URL:<a class="ae me" href="https://github.com/ContainerSolutions/ImageWolf" rel="noopener ugc nofollow" target="_blank">https://github.com/ContainerSolutions/ImageWolf</a>)</p><h1 id="b2c3" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="28b9" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">有些应用和用例需要快速启动和扩展。在这种情况下，从注册表中提取图像所带来的延迟可能是不可接受的。此外，注册表的网络连接可能不稳定/时断时续。并且可能存在不允许所有用户访问安全注册表的安全原因。kube-friedged是一个简单而有用的解决方案，可以直接在集群工作节点上构建和管理容器映像的缓存。</p><p id="88d2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">👉我定期在Kubernetes和云原生技术上发微博。 <em class="la">跟我上</em> <a class="ae me" href="https://twitter.com/senthilrch" rel="noopener ugc nofollow" target="_blank"> <em class="la">推特</em> </a> <em class="la">和</em> <a class="ae me" href="https://medium.com/@senthilrch" rel="noopener"> <em class="la">中</em> </a></p></div></div>    
</body>
</html>