<html>
<head>
<title>How to (unit) test in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中进行(单元)测试</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-unit-test-in-react-72e911e2b8d?source=collection_archive---------0-----------------------#2020-01-23">https://itnext.io/how-to-unit-test-in-react-72e911e2b8d?source=collection_archive---------0-----------------------#2020-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9107" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本指南解释了什么是单元测试，为什么需要单元测试，以及从小型到大型React应用程序的最佳实践。</p><h1 id="6842" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是单元测试</h1><p id="3214" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">单元测试是软件测试的一个层次<strong class="jp ir">测试</strong>，其中测试软件的单个单元/组件。在React世界中，这意味着测试一个单独的React组件或纯函数。</p><h1 id="8f05" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">我为什么要测试</h1><p id="815f" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">测试对于保证稳定的应用程序至关重要。尤其是单元测试可能是测试中最重要的部分。普遍的共识是，我们所有测试的70%应该是单元测试，而且理由非常充分。</p><ol class=""><li id="74c5" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">它们运行速度非常快，让我们能够很快了解我们的应用程序中是否有任何问题。</li><li id="7991" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">它们以最少的努力带来巨大的价值，因为与其他更复杂的测试相比，它们非常容易编写。</li><li id="6a7e" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">如果他们失败了，很容易知道错误在哪里，因为他们只关注代码的小单元。</li></ol><p id="9471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注:</strong> <em class="mc">功能</em>、<em class="mc">集成</em>或<em class="mc">端到端</em>测试用于一次测试多个单元/组件。他们通常很慢，也很难确定问题出在哪里。</p><h1 id="8745" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">React单元测试的先决条件</h1><p id="db92" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">为了进行单元测试，我们将使用两个非常流行的库，即<a class="ae md" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> jest </a>和<a class="ae md" href="http://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank"> enzyme </a>。Jest是一个由facebook编写的库，在过去几年中变得非常流行(你也可以使用其他库，如mocha或chai)。Jest将帮助我们做所有的断言，enzyme将帮助我们在测试模式下渲染React组件。在接下来的几节中，您将看到这两者的实际应用。</p><h1 id="1a30" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">我们的第一个测试</h1><p id="ea71" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们的第一个测试将非常简单。我们将测试一个组件，它的唯一目的是呈现一个包含一些文本的段落。</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="88d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们唯一想测试的是传递给这个组件的子组件被呈现在一个<p>标签中。让我们为此写一个测试。</p></p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f12e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是上面测试中发生的情况:</p><p id="3ded" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">a.首先，在第10行，我们根据文档为react 16配置酶。这是我们在每次使用酶的测试中必须做的事情，所以稍后我们将在辅助函数中添加它。</p><p id="96ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">b.我们使用enzyme的浅层渲染器来渲染段落组件。浅层渲染器非常适合单元测试，因为它不渲染任何子组件，从而允许我们将测试集中在一个组件上(这将在下面的测试中变得清楚)。那么我们的包装常量将包含这个组件的所有节点。</p><p id="44f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">c.使用enzyme的find函数，我们正在寻找一个<p>标签(第15行),然后我们断言只找到了一个标签(第16行),这是我们期望段落组件做的。</p></p><p id="7dee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">d.最后(第17行)，使用enzyme的text函数，它返回一个呈现文本的字符串，我们断言<p>标签内的文本与传递的子元素相同。</p></p><p id="aa39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，在短短几行代码中，我们测试了一个简单的组件，并使我们的代码更加健壮。</p><h1 id="2b14" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">测试稍微复杂一点的组件</h1><p id="8e3e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在我们的第二个测试中，我们将测试一个比上面的简单组件稍微复杂一点的组件。这次我们将测试一个列表组件。</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f4c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的列表组件接受一个项目数组并呈现它们。如果数组为空，则呈现一条空列表消息。组件的测试如下:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f30c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>我们已经在一个帮助函数中移动了酶设置，我们在任何测试之前导入并调用该函数。</p><p id="9b5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是上面测试中发生的情况:</p><p id="ddfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">a.在第一个测试中(第13行),我们用一个空的项目数组来呈现列表组件。然后，我们断言(第16行),在这种情况下，呈现的段落组件的子组件等于空列表消息。</p><p id="f598" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">b.在第二个测试中(第19行),我们用一个包含3个条目的数组来呈现列表组件。然后我们使用css选择器找到所有这些条目(第23行)。我们断言找到了3项(数组长度)(第24行)。最后，我们测试第一个项目的文本是“购物”,即项目的主体。</p><p id="bf67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的是，在上面的测试中，我们在两种不同的情况下测试了组件中呈现的文本(第16行和第25行)。在第一种情况下，我们使用<code class="fe ml mm mn mo b">.props().children</code>，在第二种情况下，我们使用<code class="fe ml mm mn mo b">.text()</code>。这是因为<code class="fe ml mm mn mo b">text</code>函数只能用于html元素(即<code class="fe ml mm mn mo b">div</code>、<code class="fe ml mm mn mo b">p</code>)，而不能用于React组件(如<code class="fe ml mm mn mo b">Paragraph</code>)。另外，请注意，因为我们使用的是shallow，所以渲染在段落组件处停止，并且不渲染段落的实现，也就是说，我们在树中永远看不到<code class="fe ml mm mn mo b">&lt;p&gt;</code>标签。我们只看到以下内容:</p><pre class="me mf mg mh gt mp mo mq mr aw ms bi"><span id="687d" class="mt km iq mo b gy mu mv l mw mx">&lt;Paragraph&gt;<br/>  This list is empty<br/>&lt;/Paragraph&gt;</span></pre><p id="b66e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Pro提示:</strong>上面的代码是运行<code class="fe ml mm mn mo b">console.log(wrapper.debug())</code>生成的</p><h1 id="9bce" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">测试涉及状态的组件</h1><p id="0206" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated"><strong class="jp ir">类组件</strong></p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">成分</figcaption></figure><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">试验</figcaption></figure><p id="c363" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，对于一个类组件，我们可以做两组测试。</p><ol class=""><li id="ff4d" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">行为。我们可以直接模拟点击按钮，看看按钮的文字有没有变化。我们正在模拟用户的行为，并测试预期的变化。</li><li id="ebe0" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">基于组件。直接测试组件的toggle方法，看看它是否如我们所期望的那样。当切换功能更复杂，并且我们想要测试不同的场景时，这是很有帮助的。</li></ol><p id="af57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两者的结合给了我们更高的信心。</p><p id="3dcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更新:</strong>上述行为测试(1)理论上是一个<strong class="jp ir">集成</strong>测试，因为它实际上间接测试了切换方法。</p><p id="72d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一个真正的和完整的<strong class="jp ir">单元</strong>测试，我们将模拟切换功能，只测试按钮调用该功能，而不关心接下来会发生什么。此外，我们会将组件设置为所需的状态，并对照该状态检查呈现方法。完整的单元测试应该是这样的:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">纯单元测试</figcaption></figure><p id="4400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果类方法的功能非常复杂(很多分支，if/else等等)，最好包含所有的单元测试。如果类方法的功能不是很复杂(就像上面的toggle ),上面的原始测试应该足够了。</p><p id="fe45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">带挂钩的组件</strong></p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">成分</figcaption></figure><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">试验</figcaption></figure><p id="a6ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遵循与上面的类组件的行为测试相同的模式，我们可以测试我们的钩子组件。</p><p id="66fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>可以将切换功能提取到它自己的钩子中，使其可重用。</p><h1 id="8d67" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">用高阶组件测试组件</h1><p id="ea86" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated"><strong class="jp ir">注射器(渲染道具)</strong></p><p id="4ddc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">酵素有一个功能可以帮助我们快速测试渲染道具。考虑以下组件。</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="c549" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，<code class="fe ml mm mn mo b">ModalHOC</code>给了孩子一个<code class="fe ml mm mn mo b">toggleModal</code>道具来触发切换模态。为了测试上面的组件，我们需要这样的东西:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="efee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我们是如何在第20行使用<code class="fe ml mm mn mo b">renderProp</code>来获得孩子的新包装的。这允许我们使用子包装器轻松地进行断言，子包装器拥有原始包装器的所有方法(通过使用<code class="fe ml mm mn mo b">shallow</code>生成)。</p><p id="fc85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要模仿<code class="fe ml mm mn mo b">toggleModal</code>将其作为参数传递给我们的<code class="fe ml mm mn mo b">children</code>道具。这里我们使用的是jest函数mock using <code class="fe ml mm mn mo b">jest.fn()</code>。</p><p id="151a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">增强剂</strong></p><p id="6454" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑一个带有react路由器<code class="fe ml mm mn mo b">withRouter</code>增强器HOC的例子。</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">成分</figcaption></figure><p id="9a91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将这样测试:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">试验</figcaption></figure><p id="8010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们不用担心第8行。我们可以有把握地假设<code class="fe ml mm mn mo b">withRouter</code>将完成它的工作，并将正确的道具传递给我们的<code class="fe ml mm mn mo b">UserLink</code>组件。</p><p id="da9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们直接测试<code class="fe ml mm mn mo b">UserLink</code>组件。这里我们模拟从<code class="fe ml mm mn mo b">withRouter</code> HOC传递来的<code class="fe ml mm mn mo b">history</code>属性，并测试当点击按钮时，使用参数<code class="fe ml mm mn mo b">/users</code>调用<code class="fe ml mm mn mo b">history.push</code>函数。</p><p id="1014" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">提示:</strong>我们可以在每次考试前调用<code class="fe ml mm mn mo b">jest.clearAllMocks()</code>。这在这个测试中不是很有用，因为我们只调用了一次<code class="fe ml mm mn mo b">history.push</code>。但是如果我们需要多次测试，那么在每次测试之前清除模拟是一个好的做法，这样我们就可以从一个干净的模拟开始。</p><h1 id="6ef2" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">学会不去担心系统的其他部分</strong></h1><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/2861ae7bc50d4d4b5b153d075039fcfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*28FF8hx21nF5mltH."/></div></div></figure><p id="f44c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在前面的测试中看到的(在<strong class="jp ir">增强子</strong>下)，我们不必担心两个组分或一个组分和一个增强子HOC的相互作用。这是集成测试的工作。这就是为什么我们使用酶的<code class="fe ml mm mn mo b">shallow</code>方法而不是<code class="fe ml mm mn mo b">mount</code>方法。</p><p id="e92b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单元测试应该只关注特定的一段代码。我们只是在测试，当传递某些输入时，我们得到了期望的输出。</p><h1 id="d6e3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">覆盖范围</strong></h1><p id="9ba8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">你应该知道你已经测试了多少文件/行/分支，jest通过用<code class="fe ml mm mn mo b">--coverage</code>标志运行你的测试使这变得容易。这将给你一个代码覆盖率的报告。理想情况下，您应该接近<strong class="jp ir"> 100% </strong>代码覆盖率。实际上，这个比例可能在80%-90%之间。根据我的经验，超过80%的代码覆盖率会给你很多信心，你的代码不会崩溃。尽管这些数字看起来很大，尤其是如果你目前没有很多单元测试，如果你养成了为所有新组件编写测试的习惯，你将能够逐渐接近这个级别的代码覆盖率。</p><p id="1ddb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>一个组件有100%的代码覆盖率并不意味着它是防弹的。你应该测试一系列不同的(奇怪的)输入来增加信心。此外，整个代码库中100%的代码覆盖率并不能保证没有错误的体验。正如本文开头所述，我们需要集成测试和e2e测试，以确保我们的单元在相互交互时按预期工作。</p><h1 id="545c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">关于测试驱动开发(TDD)的一句话</h1><p id="94d7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">TDD对于达到接近100%的代码覆盖率是必不可少的。TDD本质上是告诉我们为我们想要编写的每一段代码编写一个测试。很多文章都提到了这个过程:</p><p id="7136" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.添加测试</p><p id="be3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.运行所有测试，看看新的测试是否失败</p><p id="2d47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.编写代码(不必完美，只要能通过测试就行)</p><p id="f516" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.运行测试(确保是绿色)</p><p id="865d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.重构代码(使代码更加完美)</p><p id="3646" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人更喜欢先写组件，因为这样更有创造性，然后写测试，再重构。无论您采用哪种方法，重要的是尝试和测试某个组件的所有场景(包括边缘情况)。并且<strong class="jp ir">让测试失败</strong>至少一次，这样你才能确定你的测试是有意义的。</p><h1 id="64c3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">附加提示</strong></h1><ol class=""><li id="768b" class="lo lp iq jp b jq lj ju lk jy nj kc nk kg nl kk lt lu lv lw bi translated">有一个fixtures文件夹来保存来自api的数据会很有帮助。例如，你可以拥有一个拥有一定数量帖子的用户的<code class="fe ml mm mn mo b">userWithPosts</code>设备，以及一个没有任何帖子的用户的<code class="fe ml mm mn mo b">userWithoutPosts</code>设备。这将允许您快速回忆起这些常量，以便在测试中使用它们。此外，如果api响应的结构发生变化，您可以在一个地方更改fixture，并查看是否有任何测试失败。</li><li id="e3da" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">您应该编写自己的助手函数，当您编写的部分测试是可重复的时，这些函数会使测试更容易。例如，您可以编写一个名为<code class="fe ml mm mn mo b">testRenderComponent</code>的函数，它将一个<code class="fe ml mm mn mo b">wrapper</code>、一个元素(如<code class="fe ml mm mn mo b">button</code>)和一个数字(如<code class="fe ml mm mn mo b">2</code>)作为参数。这将测试在包装器中呈现了两个按钮。</li></ol><h1 id="75ae" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">我仍然不知道我应该测试什么</h1><p id="7855" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果你仍然不确定你应该测试什么，试试这个。</p><ul class=""><li id="215f" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk nm lu lv lw bi translated">测试您期望组件呈现的内容。</li><li id="e0b2" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk nm lu lv lw bi translated">测试该组件(分支)的所有不同状态。如果您希望根据所传递的道具呈现不同的内容，请使用不同的道具组来浅层呈现组件，并做出适当的断言。</li><li id="d18f" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk nm lu lv lw bi translated">测试操作。例如，如果您希望当您单击或悬停在按钮上时会发生一些事情，请测试。</li><li id="5714" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk nm lu lv lw bi translated">测试传递给子组件的道具。如果你正在渲染一个定制的<code class="fe ml mm mn mo b">Button</code>组件，并且你传递了一个值为<code class="fe ml mm mn mo b">red</code>的<code class="fe ml mm mn mo b">color</code>道具，你应该测试一下。这也将使您确信您的组件满足设计要求。</li></ul><blockquote class="nn no np"><p id="7177" class="jn jo mc jp b jq jr js jt ju jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj kk ij bi translated"><strong class="jp ir">底线:</strong>如果你或另一个开发者<strong class="jp ir">以某种方式改变组件</strong>的行为<strong class="jp ir">，那么至少有一个</strong> <strong class="jp ir">测试应该失败</strong>。</p></blockquote><h1 id="930c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="4d5c" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在每个项目中，为了增加对我们所写代码正确性的信心，编写单元测试是很重要的，单元测试是最简单的测试。我们应该以高百分比的代码覆盖率为目标，并让它成为我们编写单元测试的工作流程的一部分。</p><p id="99bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试愉快！</p></div></div>    
</body>
</html>