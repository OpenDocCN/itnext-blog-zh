<html>
<head>
<title>Test Driven Development (TDD) with React Testing Library &amp; Mock Service Worker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React测试库和模拟服务人员进行测试驱动开发(TDD)</h1>
<blockquote>原文：<a href="https://itnext.io/test-driven-development-tdd-with-react-testing-library-mock-service-worker-b23c9fedf6fa?source=collection_archive---------0-----------------------#2020-08-07">https://itnext.io/test-driven-development-tdd-with-react-testing-library-mock-service-worker-b23c9fedf6fa?source=collection_archive---------0-----------------------#2020-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2c36d9d8ed8d6a60aed868579476cc89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tvf7rMSGPQA7XnA38Gv9Iw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">Logos: React，测试库和模拟服务人员</figcaption></figure><div class=""/><p id="4170" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们用两个非常适合TDD方法的有用的库来加强我们的测试。</p><h1 id="8834" class="le lf ji bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">安装</h1><p id="08a5" class="pw-post-body-paragraph kf kg ji kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">每当我想尝试一些与React相关的东西时，我就使用库<a class="ae mh" href="https://create-react-app.dev/docs/getting-started/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>。它为您提供了一个无需配置即可使用的基本React应用程序。最近的版本也捆绑了react测试库，所以如果你使用最新的<em class="ld"> create-react-app </em>，你可以马上开始使用React测试库。如果没有，在现有的react应用程序中安装<a class="ae mh" href="https://www.npmjs.com/package/@testing-library/react" rel="noopener ugc nofollow" target="_blank"> @testing-library/react </a>和<a class="ae mh" href="https://www.npmjs.com/package/@testing-library/jest-dom" rel="noopener ugc nofollow" target="_blank">@ testing-library/jest-DOM</a>。</p><p id="de4f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我要实现以下功能:一个简单的搜索功能食谱列表。在移动浏览器中，用户会看到这样的内容:</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mi"><img src="../Images/299fad3113844f616222ce3e961250c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQ5oG2QrMA00Pa7K7RWyUw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图片来源:罗宾·斯蒂克尔<a class="ae mh" href="https://unsplash.com/@robinstickel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae mh" href="https://unsplash.com/s/photos/burger?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的汉堡照片，约瑟夫·冈萨雷斯<a class="ae mh" href="https://unsplash.com/@miracletwentyone?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae mh" href="https://unsplash.com/s/photos/food?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的法式吐司照片，凯西·李在<a class="ae mh" href="https://unsplash.com/s/photos/food?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的三文鱼照片</figcaption></figure><h1 id="ef3a" class="le lf ji bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从失败的测试开始</h1><p id="ab3d" class="pw-post-body-paragraph kf kg ji kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">我想使用TDD方法，所以让我们从一个失败的测试开始。在这一点上，还没有组件，所以当然无论我们写什么测试都会失败。但是让我们从小处着手；我想要一个名为'食谱'的组件，呈现预期的标题文本。以下是我对这种期望的测试:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2c19" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">React测试库导出一个<em class="ld"> render </em>方法，该方法将呈现一个组件及其所有子组件。它还导出了一个<em class="ld">屏幕</em>对象，其中保存了一些<a class="ae mh" href="https://testing-library.com/docs/dom-testing-library/api-queries" rel="noopener ugc nofollow" target="_blank">查询</a>，我们可以用它们来选择渲染组件中的不同元素(及其子组件)。<strong class="kh jj"> getByRole </strong>查询让我选择标题元素并对其文本内容做出断言。</p><p id="33fc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为什么选择标题元素是根据它的角色，而不是一个CSS类？React测试库的指导原则是<a class="ae mh" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank">“你的测试越像你的软件被使用的方式，它们就越能给你信心。”</a>因此，我们希望编写的测试尽可能接近最终测试人员——最终用户——使用应用程序的方式。用户看不到CSS类或数据属性；它们与文本、标签文本以及语义元素和角色进行交互。使用像<strong class="kh jj"> getByRole </strong>这样的查询也鼓励我们编写可访问的代码，因为每个人都可以使用这些选择器，包括屏幕阅读器的用户。</p><h1 id="b0b7" class="le lf ji bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">通过测试</h1><p id="ef78" class="pw-post-body-paragraph kf kg ji kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">我们的第一次测试不出所料地失败了。<strong class="kh jj">配方未定义。但是这是TDD的第一步——一个失败的测试。现在，让我们通过编写带有正确标题的最简单的&lt; Recipes / &gt;组件，然后将其导入到我们的测试文件中。现在，让我们重新运行测试。它过去了！</strong></p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="c638" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用进一步的查询，我们可以对输入元素和“Find”按钮做出类似的期望。按钮也有作用，但是对于输入字段，我将使用<strong class="kh jj"> getByPlaceholderText </strong>查询，因为这可能是最接近用户在页面上如何找到它的查询。</p><p id="ae83" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从失败的测试开始…</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9830" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">…并实施必要的更改以使其通过:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8972" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这样，我们知道我们期望从代码中得到什么，更重要的是，如果之前通过的测试突然失败，我们将知道我们是否破坏了任何功能。</p><p id="0e71" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">TDD中的一个重要步骤是<em class="ld">重构</em>步骤，在这个步骤中，我们改进了我们的代码，例如，使其更容易阅读，变得更有效，并消除任何重复。在我们重构之后，测试仍然应该通过。</p><h1 id="0580" class="le lf ji bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">设置我们的模拟场景</strong></h1><p id="6b89" class="pw-post-body-paragraph kf kg ji kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">当应用程序第一次呈现时，我想显示我所有食谱的列表，就像上面的视觉设计一样。这需要与API进行某种通信。我们将使用<a class="ae mh" href="https://mswjs.io/" rel="noopener ugc nofollow" target="_blank">模拟服务工作者</a>来模拟HTTP请求，这样我们就可以控制响应数据。使用npm安装模拟服务人员，如下所示:</p><pre class="mj mk ml mm gt mp mq mr ms aw mt bi"><span id="b305" class="mu lf ji mq b gy mv mw l mx my">npm install msw --save-dev</span></pre><p id="b113" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用Mock Service Worker，我们不是在模仿一个特定的模块(不像我们使用Jest.mock)，这意味着我是使用<em class="ld"> fetch </em>还是使用第三方库比如<em class="ld"> axios </em>来获取数据没有任何区别。这使得它非常灵活。让我们将以下导入添加到我们的测试文件中:</p><pre class="mj mk ml mm gt mp mq mr ms aw mt bi"><span id="2347" class="mu lf ji mq b gy mv mw l mx my">import { <strong class="mq jj"><em class="ld">rest </em></strong>} from 'msw';<br/>import { <strong class="mq jj"><em class="ld">setupServer </em></strong>} from 'msw/node';</span></pre><p id="4e46" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是我如何设置模拟对配方列表端点的调用:</p><pre class="mj mk ml mm gt mp mq mr ms aw mt bi"><span id="a8c7" class="mu lf ji mq b gy mv mw l mx my">GET /api/recipes</span></pre><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="f5e1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您使用过NodeJS和Express，语法看起来非常熟悉。对“/api/recipes”的GET请求将用包含allRecipes数组的JSON响应，就像真正的api一样。这两行确保服务器在测试运行之前开始监听(拦截),并在该文件中的测试运行完毕后关闭其连接:</p><pre class="mj mk ml mm gt mp mq mr ms aw mt bi"><span id="414a" class="mu lf ji mq b gy mv mw l mx my">beforeAll(() =&gt; server.listen());<br/>afterAll(() =&gt; server.close());</span></pre><h1 id="9339" class="le lf ji bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">测试异步代码</strong></h1><p id="576f" class="pw-post-body-paragraph kf kg ji kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">让我们编写一个新的测试，验证组件呈现时食谱列表是否显示。由于显示的配方是异步操作的结果，我们需要确保测试在断言它们的出现之前等待一段时间。React测试库为此提供了异步查询，即<strong class="kh jj"> findBy* </strong>查询。如果经过一定次数的重试后，查询的元素不存在，测试将超时并失败。在我们的测试中使用<em class="ld"> async await </em>，我们可以找到所有具有<em class="ld"> listitem </em>角色的元素(&lt; li &gt;元素)，一旦它们被获取和呈现:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">不要忘记进行异步测试！</figcaption></figure><p id="0988" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在可以在我们的<Recipes/>组件中写一些代码，让这个测试也通过。它可能看起来像这样:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">这只是实现获取和显示食谱列表的许多方法之一</figcaption></figure><h1 id="bb4d" class="le lf ji bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">模拟用户交互</strong></h1><p id="b814" class="pw-post-body-paragraph kf kg ji kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">React测试库为此公开了另一个方法— <strong class="kh jj"> fireEvent </strong>。同样，让我们从编写一个我们知道会失败的测试场景开始:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="50a7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">FireEvent从与<strong class="kh jj">渲染</strong>和<strong class="kh jj">屏幕</strong>相同的地方导入:</p><pre class="mj mk ml mm gt mp mq mr ms aw mt bi"><span id="1df3" class="mu lf ji mq b gy mv mw l mx my">import { <strong class="mq jj"><em class="ld">fireEvent</em></strong>, <strong class="mq jj">render</strong>, <strong class="mq jj"><em class="ld">screen </em></strong>} from '@testing-library/react';</span></pre><p id="99c4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用<strong class="kh jj"> fireEvent </strong>，我们可以模拟一个<em class="ld"> change </em>事件和一个<em class="ld"> click </em>事件，以使测试行为更接近用户输入和提交表单的方式。如果用户在输入字段中键入单词“fish”并单击“Find”按钮，我们期望看到消息“显示fish的结果:”并且只有一个&lt; li &gt;元素，其文本内容是“Salmon”。</p><p id="075c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是等等——我们的mock已经设置为当我们对‘API/recipes’端点进行GET调用时总是返回完整的食谱列表。我们必须能够处理请求查询字符串来模拟过滤后的响应。幸运的是，这很容易通过模拟服务人员来完成。</p><h1 id="766d" class="le lf ji bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用查询字符串模拟调用</h1><p id="440e" class="pw-post-body-paragraph kf kg ji kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">在我们的GET请求处理程序中，我们可以访问带有<strong class="kh jj"> req.url.searchParams. </strong>的请求的查询字符串，通过对请求处理程序做一个小的改变，我们可以确保当测试遇到一个请求时:</p><pre class="mj mk ml mm gt mp mq mr ms aw mt bi"><span id="9930" class="mu lf ji mq b gy mv mw l mx my">GET /api/recipes?ingredient=fish</span></pre><p id="1d1a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的模拟将返回过滤后的数据；只包含鲑鱼食谱的数组。</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="3d98" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们可以在<Recipes/>中实现必要的逻辑来通过测试了！在本文的最后，我已经添加了完整的实现，但是这里有一个片段显示了fetch调用:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">向下滚动到本文末尾，查看完整的示例</figcaption></figure><h1 id="3d69" class="le lf ji bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">模拟服务器端错误</h1><p id="bb43" class="pw-post-body-paragraph kf kg ji kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">我们可能还想在食谱应用程序中实现一些错误处理。像往常一样，让我们从一个失败的测试开始，概述我们的期望:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e57a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了让我们的模拟返回内部服务器错误，我们简单地创建一个状态为500和“内部服务器错误”消息的响应处理程序，类似于真实API的响应方式。但是，我们只希望mock在这个特定的测试用例中做出不同的响应——之前编写的测试仍然应该期待一个成功的mock API响应。模拟服务工作者让我们用<em class="ld">服务器覆盖前面的响应处理程序。在特定的测试中使用</em>:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="833d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">重要的是，当我们开始在测试套件中覆盖先前模拟的响应时，我们在测试上方添加以下行:</p><pre class="mj mk ml mm gt mp mq mr ms aw mt bi"><span id="92a8" class="mu lf ji mq b gy mv mw l mx my">afterEach(() =&gt; server.resetHandlers());</span></pre><p id="bb74" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这确保了在测试运行期间设置的任何处理程序，都不会“泄漏”到后续的测试中。</p><h1 id="d7f9" class="le lf ji bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包扎</h1><p id="278f" class="pw-post-body-paragraph kf kg ji kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">当然，我们可以用测试驱动的方法来实现更多的特性、错误处理和表单验证，但是希望现在您有一些灵感来开始自己的项目！</p><p id="1374" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我想强调的是，你如何实现你用React测试库和模拟服务工作者测试的代码并不重要。在我的例子中，我使用了一个带有<strong class="kh jj"> useState </strong>和<strong class="kh jj"> useEffect </strong>钩子的函数组件，并用<strong class="kh jj"> fetch </strong>来检索数据。然而，我可以将这个组件重构为一个类组件，甚至更小的子组件，只要逻辑不中断，测试仍然会通过。就像你的最终用户不关心有多少子组件被渲染或者你是否用<strong class="kh jj"> setState </strong>或<strong class="kh jj"> useState </strong>处理状态一样，React测试库也不关心。与其他测试工具相比，这是一个巨大的优势。每当我们对实现细节进行更改时，知道我们不必担心破坏测试是一种很好的感觉。这也非常符合TDD哲学，因为TDD过程中的一个重要步骤是重构。</p><p id="c221" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是一个完整的例子，由我们上面的测试案例驱动:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div></div>    
</body>
</html>