<html>
<head>
<title>Recognising Functional Patterns: functors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">识别功能模式:函子</h1>
<blockquote>原文：<a href="https://itnext.io/recognising-functional-patterns-functors-for-dummies-2a829c875767?source=collection_archive---------4-----------------------#2019-12-17">https://itnext.io/recognising-functional-patterns-functors-for-dummies-2a829c875767?source=collection_archive---------4-----------------------#2019-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fca0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函子是实现map()函数的结构。它被用作用户想要转换的特定数据/结构的上下文包装器。</p><p id="2798" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们传递给函子的结构可以是任何类型，但是在这篇文章中，我将演示一个获取数据列表的函子。(函子无处不在，这里可以找到几种函子类型<a class="ae kl" href="https://blog.ploeh.dk/2018/03/22/functors/" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="44a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将仿函数看作是一种结构，我们需要这种结构来将一个项目从一组值A传递到另一组值——比如说B(我们通过使用map()函数来实现这一点，该函数迭代给定的数据并将其转换为其他数据)。</p><p id="d427" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为仿函数返回上下文(在我的面向类的解决方案中它自己的一个新实例..)我们可以永远保持映射(或者直到我们得到想要的数据类型)</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="2130" class="kv kw iq kr b gy kx ky l kz la">someArray<br/>  .map(f1)<br/>  .map(f2)<br/>  .map(f3)</span></pre><h2 id="65bc" class="kv kw iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">识别模式的用例:</h2><p id="27f5" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我将软件<a class="ae kl" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">设计模式</strong> </a> <strong class="jp ir"> </strong>视为一套工具，根据需要完成的必要工作进行组合。</p><p id="4c00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当编写软件时，我们可以<strong class="jp ir">将</strong>代码中的某些部分识别为设计模式候选<strong class="jp ir"> </strong>，这可以使代码更加独立/分离、可重用和讲故事。</p><p id="5877" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在面向对象的概念中，这些是<strong class="jp ir">“GOF设计模式”</strong>，它们被分为<strong class="jp ir">创造型、结构型</strong>和<strong class="jp ir">行为型</strong>(并且要务实！在基于lang as JS的原型中，我们不需要全部甚至大部分。</p><p id="7247" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外，还有功能模式。</p><p id="b3a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想到一个对<strong class="jp ir">仿函数</strong>的OOP引用，我们可以想到<strong class="jp ir">访问者</strong>模式，这是一种将算法与其操作的对象结构分离的方式(我喜欢这个<a class="ae kl" href="https://github.com/thma/LtuPatternFactory#visitor--foldable" rel="noopener ugc nofollow" target="_blank">引用</a>)。</p><p id="a510" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在visitor实现中，我们提供了在给定结构上操作的visit()方法——如果该结构接受它(实现了一个调用visitor.visit()的函数),但访问包装不会返回新的结构，它将修改现有的结构(与仿函数不同)。</p><p id="947c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们以迭代的方式使用visitor时(这通常是用例，当在树上运行时是递归的，例如“标记”节点),它会提醒函子的map函数。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="7f7b" class="kv kw iq kr b gy kx ky l kz la"><strong class="kr ir">for</strong> (<strong class="kr ir">const</strong> <strong class="kr ir">orange</strong> <strong class="kr ir">of</strong> oranges) {<br/>        orange.accept(visitor);<br/>    }</span></pre><p id="988c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也想到了用户赋予地图的变换函数形式的<strong class="jp ir">策略</strong>模式，但我不想误导任何人，那只是一种看法。</p><h2 id="e300" class="kv kw iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">关于函数式编程的一句话:</h2><p id="f991" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">IMO函数式编程是关于-</p><ul class=""><li id="bf19" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">编写总是输出结果的纯函数，这样我们就可以编写声明性的(可组合的)代码。</li><li id="12d0" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">使用<a class="ae kl" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank">高阶函数</a> s(抽象)。</li><li id="d57b" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">保持函数没有副作用(并且在可能的情况下保持不变)。</li><li id="21a5" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">编写自己的组合/管道抽象实用程序等..</li><li id="6d0d" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">代数数据类型帮助我们涵盖所有可能的情况(对于和与积)。</li><li id="8d17" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">表达我们事业的类型/类型系统！通过定义函数的类型。</li></ul><p id="d3c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是还有更多的基于范畴论和抽象代数的概念。</p><p id="dbf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://bartoszmilewski.com/2015/11/17/its-all-about-morphisms/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">函子</strong> </a>就是其中之一，所以让我们尽量简化它，直到实现一个列表函子。</p><p id="6e9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函子的类型定义应该是通用的，而不是像我的例子中那样绑定到某个类型。</p><h2 id="5bf5" class="kv kw iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">函子定义</h2><p id="728b" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">根据Luis Atencio的书<a class="ae kl" href="https://www.amazon.com/Functional-Programming-JavaScript-Javascript-Techniques/dp/B07KFPZLQ6/ref=tmm_aud_title_sr?_encoding=UTF8&amp;qid=&amp;sr=" rel="noopener ugc nofollow" target="_blank">“JavaScript中的函数式编程—如何改进您的JavaScript程序”</a></p><blockquote class="ml"><p id="ba02" class="mm mn iq bd mo mp mq mr ms mt mu kk dk translated">“本质上，函子只不过是一种数据结构，您可以映射函数，目的是将值提升到包装器中，修改它们，然后<br/>将它们放回包装器中。这是一种设计模式，定义了fmap应该如何工作的语义。下面是fmap的一般定义:<br/> fmap :: (A - &gt; B) - &gt;包装器(A) - &gt;包装器(B)”</p></blockquote><p id="4387" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">下面的插图也取自这本书:</p><figure class="km kn ko kp gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi na"><img src="../Images/077eb2d9e230fcc059173545c15db232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OB0fwHigE3nCR5bE8c5KYg.png"/></div></div></figure><p id="5717" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数组</strong>数据结构包含map()，(和其他用于转换的高阶函数)，使用map函数我们修改给定的数据并返回一个新的数组引用和修改后的数据(另一个包装器)，我们可以这样做下去！</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="d00a" class="kv kw iq kr b gy kx ky l kz la"><strong class="kr ir">class </strong>MyFunctorContext&lt;T&gt; {<br/><br/>    <strong class="kr ir">items</strong>: T[];<br/><br/>    <strong class="kr ir">constructor </strong>(items: T[]) {<br/>        <strong class="kr ir">this</strong>.<strong class="kr ir">items </strong>= items<br/>    }<br/><br/>    map(transformFn: &lt;T, V&gt; (arg: T) =&gt; V ): MyFunctorContext&lt;T&gt; {<br/>        <strong class="kr ir">const </strong>newItems = [];<br/><br/>        <strong class="kr ir">for </strong>(<strong class="kr ir">const </strong>item <strong class="kr ir">of this</strong>.<strong class="kr ir">items</strong>) {<br/>            newItems.push(transformFn(item));<br/>        }<br/><br/>        <strong class="kr ir">return new </strong>MyFunctorContext(newItems);<br/>    }<br/>}</span></pre><p id="4565" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何使用:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="6bc4" class="kv kw iq kr b gy kx ky l kz la"><strong class="kr ir">const <em class="ni">bananas</em></strong>: <strong class="kr ir">any </strong>= [<br/>    {<strong class="kr ir">isYellow</strong>: <strong class="kr ir">true</strong>},<br/>    {<strong class="kr ir">isYellow</strong>: <strong class="kr ir">false</strong>},<br/>    {<strong class="kr ir">isYellow</strong>: <strong class="kr ir">true</strong>},<br/>    {<strong class="kr ir">isYellow</strong>: <strong class="kr ir">false</strong>}<br/>    ];<br/><br/><br/><strong class="kr ir">const <em class="ni">myTypedFunctor </em></strong>= <strong class="kr ir">new </strong>MyFunctorContext(<strong class="kr ir"><em class="ni">bananas</em></strong>);<br/><br/><strong class="kr ir">const <em class="ni">bestBananas </em></strong>= <strong class="kr ir"><em class="ni">myTypedFunctor<br/>    </em></strong>.map((banana: <strong class="kr ir">any</strong>) =&gt; {<br/>    <strong class="kr ir">if </strong>(banana.<strong class="kr ir">isYellow</strong>) {<br/>        banana.<strong class="kr ir">tasty </strong>= <strong class="kr ir">true</strong>;<br/>        <strong class="kr ir">return </strong>banana;<br/>    }<br/>    banana.<strong class="kr ir">tasty </strong>= <strong class="kr ir">false</strong>;<br/>    <strong class="kr ir">return </strong>banana;<br/>});</span></pre><p id="476d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以理论上这很棒，但是我实际上从来没有发现使用它的需要，数组<t>让我得到了掩护..</t></p><p id="538b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Haskell BTW中，map()表示为:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="ef19" class="kv kw iq kr b gy kx ky l kz la">(a -&gt; b) -&gt; [a] -&gt; [b]</span></pre><p id="16a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个参数:(a -&gt; b)表示一个采用类型“a ”(可以是任何类型)并返回类型“b”的函数</p><p id="3716" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个参数是“a”类型的列表</p><p id="787a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">返回值是“b”类型的列表</p><p id="fcc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个使用仿函数的例子可以在<strong class="jp ir"> D3 </strong>中找到，我用这个库做了很多工作，我似乎认识到了“<strong class="jp ir">选择</strong>API形式的仿函数模式，查看<a class="ae kl" href="http://www.dreadedsoftware.com/blog/2016/1/16/d3js-is-a-functor-over-the-dom" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。(选择总是返回选择的新引用)</p><p id="16ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是可运行的示例:</p><figure class="km kn ko kp gt nb"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="754a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你觉得那个帖子有意思，我推荐你看看我下面的帖子:</p><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/a-short-time-learning-haskell-can-shortly-improve-your-typescript-skills-523505900ac0"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">短时间学习Haskell可以很快提高您的打字技能！</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">键入任意函数！仿制药太牛逼了！😎 👏哈斯克尔为了更大的利益。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">itnext.i</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ng no"/></div></div></a></div><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/exploring-the-mixin-pattern-by-code-1dbe5e3124eb"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">探索Mixin模式→按代码</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">让我们混合一些类型脚本类</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">itnext.io</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc ng no"/></div></div></a></div><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/d3-selections-in-depth-40b8b36ef738"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">D3深度选择</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">输入→选择</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">itnext.io</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc ng no"/></div></div></a></div><p id="b9c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也欢迎你深入我的<a class="ae kl" href="https://github.com/LironHazan/advanced-patterns-in-typescript/blob/master/functional/algebric-data-types.ts" rel="noopener ugc nofollow" target="_blank">游乐场回购</a>来掌握一些更多的功能概念。</p><p id="5c6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">干杯，勒荣。</p></div></div>    
</body>
</html>