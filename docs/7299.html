<html>
<head>
<title>Kubernetes StatefulSets are Broken</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes StatefulSets坏了</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-statefulsets-are-broken-8cafde6544af?source=collection_archive---------1-----------------------#2022-08-15">https://itnext.io/kubernetes-statefulsets-are-broken-8cafde6544af?source=collection_archive---------1-----------------------#2022-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7d8614dd0da3014b0109edc4ea86c0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpsg4a3v6oaAK7EJU0tBiw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这实际上不是一个有状态的集合。Unsplash.com的克利姆·穆萨利莫夫的照片。</figcaption></figure><p id="0d4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> Kubernetes最初旨在充当无状态工作负载的容器编排平台，而不是有状态应用。</em></p><p id="1c54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要误会我；我们是Kubernetes的坚定支持者。这是<a class="ae kc" href="https://github.com/pluralsh/plural" rel="noopener ugc nofollow" target="_blank">我们项目</a> t的一个关键部分，正确使用的话会提供巨大的价值。但是，Kubernetes的初衷是作为无状态工作负载的容器编排平台，<strong class="kf ir">而不是有状态应用</strong>。</p><p id="0aa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去几年中，Kubernetes社区通过创建StatefulSets(这是Kubernetes对以存储为中心的工作负载的解决方案)在发展项目以支持有状态工作负载方面做了大量工作。</p><p id="b1b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">状态集涵盖了从数据库、队列和对象存储到出于某种原因需要修改本地文件系统的旧web应用程序。它们为开发人员提供了一套非常强大的保证:</p><ul class=""><li id="cc8b" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated"><strong class="kf ir">每个pod的一致网络身份:</strong>这允许您在应用中轻松配置pod的DNS地址。它对于数据库连接字符串或配置复杂的Kafka客户端非常有用。我们有时也用它来建立erlang的网状网络。</li><li id="3f13" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><strong class="kf ir">持久性卷自动化:</strong>每当pod重新启动时，即使它被重新安排到不同的节点上，持久性卷也会重新附加到它所在的节点上。这在某种程度上受到您所使用的CSI(容器存储接口)功能的限制。例如，在AWS上，这仅在同一区域AZ内有效，因为EBS卷是与AZ链接的。</li><li id="2298" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><strong class="kf ir">顺序滚动更新:</strong> StatefulSet更新被设计为滚动和一致的。它将总是以相同的顺序更新，这有助于保护具有微妙协调协议的系统。</li></ul><p id="4c32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些保证涵盖了运行有状态工作负载所需的大量操作。特别是，它几乎完全处理可用性部分。鉴于EBS的正常运行时间和冗余保证非常强大，StatefulSet的重新调度自动化几乎可以保证您获得高可用性服务。然而，一些警告确实适用(例如，您的集群中有空间，不要搞糟AZ设置。)</p><p id="e5b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kubernetes在这一领域大有可为，从理论上讲，它肯定会发展成为一个平台，可以轻松地运行大多数开发人员使用的有状态工作负载和无状态工作负载。</p><div class="lq lr gp gr ls lt"><a href="https://github.com/pluralsh/plural" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd ir gy z fp ly fr fs lz fu fw ip bi translated">GitHub - pluralsh/plural:以创纪录的时间在kubernetes上部署开源软件。🚀</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">Plural使您能够在Kubernetes上构建和维护云原生和生产就绪的开源基础设施…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">github.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh jw lt"/></div></div></a></div><h1 id="bcce" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">Kubernetes StatefulSet中缺少什么？</h1><p id="465f" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">那么，为什么我们认为状态集是坏的呢？嗯，如果您在头脑中思考有状态工作负载的操作需求，您可能会注意到缺少一个关键组件:</p><p id="158b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">当你需要调整底层磁盘大小时，你会怎么做？</em></p><p id="da45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据集是一种常见的数据库存储，通常以相当恒定的正速率增长。除非您支持水平扩展和分区，否则随着数据集的增长，您需要在磁盘中增加扩展空间。这就是Kubernetes的失败之处。</p><p id="f763" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，StatefulSet控制器<a class="ae kc" href="https://github.com/kubernetes/kubernetes/issues/68737" rel="noopener ugc nofollow" target="_blank">没有对音量大小调整</a>的内置支持。尽管事实上几乎所有的CSI实现都支持控制器可以挂接的卷大小调整。有一个解决办法，但它几乎是可笑的迂回:</p><ul class=""><li id="0502" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">在孤立pod时删除状态集以避免停机，方法是:kubectl <strong class="kf ir">删除</strong>STS&lt;T6】name&gt;—级联=孤立</li><li id="08c7" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">将每个pod的永久卷手动编辑为新的存储大小</li><li id="c527" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">使用新的存储大小手动编辑StatefulSet卷声明，并添加虚拟pod注释以强制滚动更新</li><li id="9716" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">使用新规范重新创建StatefulSet，这允许控制器收回对孤立单元的控制，并开始滚动更新，这将触发CSI应用卷大小调整</li></ul><blockquote class="nl nm nn"><p id="439b" class="kd ke lb kf b kg kh ki kj kk kl km kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">💡我们实际上将整个过程自动化为复数操作符的<a class="ae kc" href="https://github.com/pluralsh/plural-operator/blob/main/controllers/statefulsetresize_controller.go#L70" rel="noopener ugc nofollow" target="_blank">部分。我们知道，我们需要构建存储大小调整自动化，让非Kubernetes专家也能操作使用复数运行的有状态应用程序。这在现实中是一个不小的逻辑量，如果有人被要求在高压情况下做这件事，失败的可能性非常高。</a></p></blockquote><p id="8c63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，所以在Kubernetes的StatefulSets中有一个相当值得注意的缺陷，但是有<em class="lb">是</em>一个变通办法，即使它有点滑稽。</p><p id="dbfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那应该不会太糟，对吧？</p><h1 id="c50f" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">但情况变得更糟！</h1><p id="89c4" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">当您意识到这种限制的影响以及许多Kubernetes操作符是为管理有状态工作负载而构建的时，情况会变得非常糟糕。</p><p id="3780" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个很好的例子是<a class="ae kc" href="https://github.com/prometheus-operator/prometheus-operator" rel="noopener ugc nofollow" target="_blank"> Prometheus operator </a>，这是一个很棒的项目，既提供Prometheus数据库，又允许基于CRD的工作流配置指标、刮刀和警报。</p><p id="d3f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出现这个问题是因为操作符的内置控制器没有管理StatefulSet resize的逻辑，但是如果它发现触发其删除的事件，它有重新创建其基础StatefulSet的逻辑。这意味着您实际上没有办法使用上述解决方法，因为当您执行级联孤立删除时，操作符将根据旧规范重新创建StatefulSet，并阻止正确调整大小。唯一的解决方案是删除整个CRD或找到一个可以欺骗操作者不协调对象的调整(有时缩放到零会做到这一点)。</p><p id="3202" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论如何，作为这个缺陷的结果，实际上没有办法在不造成大量停机或数据丢失的情况下用操作者调整Prometheus实例的大小。考虑到StatefulSets中的自动化在所有其他情况下是多么健壮，这仍然是一种潜在的失败模式，这是非常令人震惊的。</p><p id="2a60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的社区负责人Abhi在开源Vitess操作符中实现StatefulSet volume resizes时，实际上已经解决了这个问题。</p><blockquote class="nl nm nn"><p id="6806" class="kd ke lb kf b kg kh ki kj kk kl km kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated"><em class="iq">“考虑到Vitess部署的自然复杂性，您可以推断磁盘大小调整也是成比例的复杂。</em> <a class="ae kc" href="https://vitess.io/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Vitess </em> </a> <em class="iq">是一个位于MySQL之上的数据库共享系统，这意味着卷大小调整必须是分区感知和分片感知的。我们不得不手动编写我们自己的分片安全的</em> <a class="ae kc" href="https://github.com/planetscale/vitess-operator/blob/eeff200e5acaf67db6f01f0f7f945ea7e89d4540/pkg/controller/vitessshard/reconcile_rollout.go#L18" rel="noopener ugc nofollow" target="_blank"> <em class="iq">滚动重启，创建一个</em> </a> <a class="ae kc" href="https://github.com/planetscale/vitess-operator/blob/eeff200e5acaf67db6f01f0f7f945ea7e89d4540/pkg/operator/rollout/rollout.go#L82" rel="noopener ugc nofollow" target="_blank"> <em class="iq">级联条件</em> </a> <em class="iq">以便与Vitess自定义资源的父子结构一起工作，并使用</em> <a class="ae kc" href="https://github.com/planetscale/vitess-operator/blob/eeff200e5acaf67db6f01f0f7f945ea7e89d4540/pkg/controller/vitessshard/reconcile_disk.go#L21" rel="noopener ugc nofollow" target="_blank"> <em class="iq">解决每一个可以想到的故障</em> </a> <em class="iq">条件以防止停机。感谢著名的Kubernetes撰稿人</em><a class="ae kc" href="https://mobile.twitter.com/enisoc" rel="noopener ugc nofollow" target="_blank"><em class="iq">enisoc</em></a><em class="iq">设计了这一功能。”</em></p></blockquote><p id="b33b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他广泛使用和著名的数据库操作符，如<a class="ae kc" href="https://github.com/zalando/postgres-operator" rel="noopener ugc nofollow" target="_blank"> Zalando的Postgres操作符</a>，在他们自己的代码库中有效地重新实现了我们在复数操作符中实现的相同过程。这导致在一个只需修复一次的问题上浪费了大量的开发周期。</p><h1 id="3068" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">Kubernetes的潜力</h1><p id="2237" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">总的来说，我们非常看好Kubernetes让几乎任何工作量的操作变得微不足道的潜力，我们在<a class="ae kc" href="https://github.com/pluralsh/plural/" rel="noopener ugc nofollow" target="_blank"> Plural </a>的任务的很大一部分就是让这成为可能。</p><p id="b2dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，我们还需要清楚地看到Kubernetes生态系统中仍然存在的差距，这样我们就可以解决它们，或者从上游弥补它们。我认为很明显这是一个重大的差距，如果优先考虑，这可以在Kubernetes的未来版本中很容易地修复<a class="ae kc" href="https://github.com/kubernetes/kubernetes/pull/110522" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="212f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你认为这很有趣，看看我们在Kubernetes <a class="ae kc" href="https://github.com/pluralsh/plural" rel="noopener ugc nofollow" target="_blank">这里</a>构建了什么。</p></div></div>    
</body>
</html>