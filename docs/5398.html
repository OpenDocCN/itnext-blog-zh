<html>
<head>
<title>Flutter app’s state in Isolate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">孤立状态下的颤振应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/flutter-apps-state-in-isolate-8fd9828fc1a3?source=collection_archive---------0-----------------------#2021-02-25">https://itnext.io/flutter-apps-state-in-isolate-8fd9828fc1a3?source=collection_archive---------0-----------------------#2021-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f973388a0f504b4d17acb821a40d4951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pS1tSlYxFirHPj9U0RFrkg.png"/></div></div></figure><p id="549c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Flutter中有许多管理状态的方法，但大多数都是在应用程序的主隔离中执行所有逻辑。执行网络请求、使用WebSocket、潜在的繁重同步操作(如本地搜索)，所有这些通常都在main isolate中实现。本文也将展示其他的门。</p><p id="eb31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我只看到了一个旨在将这些操作转移到外部隔离物的包，但最近出现了另一个包(由我编写)。建议你熟悉一下。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/4119fee9ecaa5f2553e0b162f82122f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*er5gBk6tr8FZh42rwqDQAA.png"/></div></div></figure><p id="33c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将使用两个主要术语— <strong class="ka ir">隔离</strong>和<strong class="ka ir">主线程</strong>。他们不同，使文本不是太同义反复，但本质上的主线也是一个孤立的。此外，在这里你会发现一些表达会伤害耳朵(<em class="lc">或眼睛</em>)特别敏感的人，所以我提前道歉——对不起。我会用斜体标出所有有疑问的单词(<em class="lc">不只是它们，现在试着弄清楚</em>)。此外，进一步调用同步操作—我会记住，您将在调用第三方方法的同一个函数中收到结果。异步函数是这样的函数，你不能在一个地方得到结果，而是在另一个地方得到。</p><h2 id="e3f5" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">介绍</h2><p id="a943" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">隔离旨在在Flutter应用程序的非主线程上运行代码。当主线程开始执行网络请求，执行计算，或者做除了它的主要用途——绘制界面之外的任何其他操作时，迟早你会面临这样一个事实，渲染一帧的宝贵时间会开始增加。基本上，您在主线程上执行任何操作的可用时间都被限制在大约16ms，这是以60FPS渲染2帧之间存在的窗口。然而，目前有许多手机具有更高的显示频率，因为我只有一个，所以比较一个应用程序使用不同方法执行相同操作的性能会更有趣。这种情况下，窗口已经~11.11ms，显示刷新率为90FPS。</p><h2 id="d279" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">输入条件</h2><p id="4131" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">假设您需要加载大量数据，您可以通过几种方式来完成:</p><ul class=""><li id="045a" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">只需在主线程上发出一个请求</li><li id="cb37" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">使用计算功能提出请求</li><li id="b48f" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">对请求显式使用隔离</li></ul><p id="74e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实验是在一台一加7 Pro上进行的，它配有骁龙855处理器，屏幕频率强制为90Hz。该应用程序由颤振运行剖面命令启动。执行了从服务器接收数据的模拟(连续10次5个同时请求)。</p><p id="c911" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个请求返回JSON——一个由<strong class="ka ir"> 2273 </strong>个元素组成的数组，其中一个元素显示在屏幕截图中。答案的大小是1.12Mb。因此，对于5个并发请求，我们需要解析5.6Mb的JSON(但应用程序列表中将有2273个条目)。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/8babb656174b71ebfe1e798a9bfdb1f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YKRPN4U5BD3oMjakLKJqQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">JSON的要素之一</figcaption></figure><p id="cd8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们根据这些参数来比较这三种方法——帧渲染时间、操作时间、组织/编写代码的复杂性。</p><h2 id="e6fd" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated"><strong class="ak">第一个例子:来自主线程的一组请求</strong></h2><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9ae0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该方法处于被动状态，在主应用隔离中执行。</p><p id="f2f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该方法位于在应用程序的主隔离中执行的反应状态中。当执行上面的代码时，我们得到以下值:</p><ul class=""><li id="e5a0" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">一帧的平均渲染时间(FrameRenderingTime)—14.036毫秒/ 71.25FPS</li><li id="8303" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">最大FRT—100.332毫秒/9.97帧/秒</li><li id="b1d2" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">执行5个并发请求的平均时间—226.894毫秒</li></ul><p id="6198" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看实际情况:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mw mv l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">在主线程中加载项目</figcaption></figure><h2 id="f39e" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">第二个示例:compute()</h2><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="20bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，相同的请求在两个版本中启动:每10个连续请求中有5个并发请求在各自的计算中启动:</p><ul class=""><li id="a404" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">平均FRT—11.254毫秒/88.86帧/秒</li><li id="d819" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">最大FRT—22.304毫秒/ 44.84FPS</li><li id="0c55" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">执行5个并发请求的平均时间—386.253毫秒</li></ul><p id="6e42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二种方式—在一次计算中启动5个并发请求的所有10个顺序请求:</p><ul class=""><li id="94e9" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">平均FRT—11.252毫秒/ 88.87FPS</li><li id="7f20" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">最大FRT—22.306毫秒/ 44.83FPS</li><li id="7171" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">5个并发请求的平均时间(计算方法是在计算中执行5个请求中的全部10个，除以10)—231.747毫秒</li></ul><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mw mv l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">正在compute()中加载项目</figcaption></figure><h2 id="1e83" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">第三个例子:隔离</h2><p id="28a2" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这里值得做一个题外话:在包术语中，一般状态(state)有两个部分:</p><ul class=""><li id="eb30" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">Frontend-state是一种任意反应状态，它向后端发送消息，处理它的响应，并且还存储数据，在更新之后，UI被更新，并且它还存储从UI调用的轻量方法。这种状态在应用程序的主线程中工作。</li><li id="c139" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">后端状态(Backend-state)是一种繁重的状态，它从前端接收消息，执行繁重的操作，向前端返回响应，并在单独的隔离中运行。这种状态也可以存储数据(任何你想要的地方)。</li></ul><p id="364f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于需要与隔离区通信，第三个选项的代码被分成几个方法。前端方法如下所示:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2163" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，您可以看到后端方法，以及我们需要的逻辑:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="917f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果:</p><ul class=""><li id="34d3" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">平均FRT—11.151毫秒/89.68帧/秒</li><li id="efe2" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">最大FRT—11.152毫秒/ 89.67FPS</li></ul><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mw mv l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">隔离加载项目</figcaption></figure><h2 id="f64c" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">小计</h2><p id="b71f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在应用程序中加载相同数据集进行了三次实验后，我们得到了以下结果:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/14b48c2e6a356a260a64a89ee47cbcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaaB00HhBozq_GkIGYCREA.png"/></div></div></figure><p id="2e24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据这些结果，可以得出以下结论:</p><ul class=""><li id="eb9e" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">颤振能够提供大约90帧/秒的稳定速度</li><li id="161f" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">在应用程序的主线程上发出大量繁重的网络请求会影响其性能——出现延迟</li><li id="fa2b" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">编写在主线程上运行的代码就像剥梨一样简单</li><li id="f729" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">Compute允许您减少滞后的可见性</li><li id="fd51" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">用Compute写代码有一些限制(纯函数，不能传递静态方法，没有闭包等。)</li><li id="1536" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">使用按操作时间计算时的开销约为150–160毫秒</li><li id="758c" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">隔离完全消除了滞后</li><li id="0873" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">使用隔离区编写代码更加困难，也有一些限制，这将在后面讨论</li></ul><p id="996c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们进行另一个实验，以确定哪种方法对于所有正在研究的参数是最佳的。</p><p id="95eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lc">一切似乎都很清楚</em></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/a15537fbb269f28e6b95bd727f78bdfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/1*6TYqMppsXPc0yo95nyisPA.gif"/></div></figure><h2 id="29f9" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">实验二:局部搜索</h2><p id="0bf4" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">假设现在我们需要通过输入到输入中的值在加载的数据中找到某些元素。该测试以如下方式实现:有一个输入，其中从项目列表中可用的子串数量中逐字符地输入3个3字符的子串。搜索数组中的元素数量增加了10倍，为<strong class="ka ir"> 22730 </strong>个。</p><p id="d76b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">搜索以两种模式进行——输入字符串在列表元素中的原始存在，以及使用字符串相似性<a class="ae kw" href="https://pub.dev/packages/string_similarity" rel="noopener ugc nofollow" target="_blank">算法</a>。</p><p id="b162" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，异步搜索选项——计算/隔离——在前一次搜索完成之前不会启动。它是这样工作的——通过在输入字段中输入第一个字符，我们开始搜索，直到搜索完成——数据不会返回到主线程，UI也不会重绘，第二个字符不会输入到输入字段中。当所有动作完成后，输入第二个字符，反之亦然。这类似于当我们“保存”用户输入的字符，然后只发送一个请求时的算法，而不是对输入的每个字符都发送一个请求，不管它们输入得有多快。</p><p id="486c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有在搜索中输入字符时才测量渲染时间，即数据准备操作和不影响收集数据的任何其他操作。</p><p id="54c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于初学者、助手函数、搜索函数和其他通用代码:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="6c93" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">在主线程中搜索</h2><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5c48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来是这样的:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mw mv l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">主线程中的简单搜索(隔离)</figcaption></figure><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mw mv l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">在主线索中搜索相似性</figcaption></figure><p id="587e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单搜索结果:</p><ul class=""><li id="4e91" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">平均FRT—21.588毫秒/46.32帧/秒</li><li id="d154" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">最大FRT — 668，986毫秒/1.50帧/秒</li></ul><p id="1a0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用相似性结果进行搜索:</p><ul class=""><li id="6c98" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">平均FRT — 43，123毫秒/23.19英尺/秒</li><li id="43ca" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">最大FRT — 2 440，910毫秒/ 0.41FPS</li></ul><h2 id="f7f1" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">使用计算机搜索()</h2><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="aa3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些YouTube:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mw mv l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">使用compute()进行简单搜索</figcaption></figure><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mw mv l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">在计算机中搜索相似性()</figcaption></figure><p id="354c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单搜索结果:</p><ul class=""><li id="a654" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">平均FRT—12.682毫秒/78.85帧/秒</li><li id="3b5f" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">最大FRT—111.544毫秒/ 8.97FPS</li></ul><p id="4768" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用相似性结果进行搜索:</p><ul class=""><li id="ab51" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">平均FRT—12.515毫秒/79.90帧/秒</li><li id="b354" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">最大FRT — 111，527毫秒/8.97帧/秒</li></ul><h2 id="d799" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">用隔离搜索</h2><p id="7cba" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">大量代码:前端</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c694" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些是在第三方隔离中运行的后端方法:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7a5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单搜索结果:</p><ul class=""><li id="4512" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">平均FRT—11.354毫秒/ 88.08FPS</li><li id="8c3f" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">最大FRT—33.455毫秒/29.89英尺/秒</li></ul><p id="796f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相似性搜索:</p><ul class=""><li id="856f" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">平均FRT—11.353毫秒/ 88.08FPS</li><li id="7d61" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">最大FRT—33.459毫秒/29.89英尺/秒</li></ul><p id="6c8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lc">是时候伸展一下手臂了</em></p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="c9ae" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">更多结论</h2><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/902d9ec07d861c647a64bd317753481f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OqU3gPE2j2q6ChVL5LafYA.png"/></div></div></figure><p id="7920" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从这个平板电脑和之前的研究可以得出:</p><ul class=""><li id="9ba9" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">主线程不应用于大于16ms的操作(以提供至少60FPS)</li><li id="113b" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">计算在技术上适用于频繁和繁重的操作，但同样会带来150毫秒的开销，并且与永久隔离相比，性能更不稳定(这可能是因为每次打开时，操作完成后，隔离会关闭，这也需要资源)</li><li id="03fa" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">隔离是颤振应用中最难实现最高性能的编码方式</li></ul><h1 id="620f" class="mz le iq bd lf na nb nc li nd ne nf ll ng nh ni lo nj nk nl lr nm nn no lu np bi translated">隔音装置</h1><p id="095e" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">好吧，看起来隔离是实现结果的理想方式，甚至谷歌建议在所有繁重的操作中使用它们(<em class="lc">这是为了口碑，我还没有找到任何证据</em>)。但是你要写很多代码。事实上，上面写的所有东西都是使用一开始提供的库得到的结果，没有它，你将不得不写更多的东西。此外，这种搜索算法可以优化—在过滤所有元素后，只将一小部分数据发送到前端—这将占用更少的资源，在其传输后，发送其他所有内容。或者按块发送数据。</p><p id="7007" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还试验了隔离物之间的通信信道的带宽。为了对其进行评估，使用了以下实体:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="54d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果是这样的——在同时传输5000个元素的情况下，复制数据所需的时间不会影响UI，也就是说，渲染频率不会降低。通过<em class="lc">未来&lt;虚空&gt;，这些元素中的100万被分批传输，每次5000个，在8毫秒的突发传输之间有一个强制暂停。延迟</em>，而帧率没有降到80FPS以下。不幸的是，我在写这篇文章之前很久就做了这个实验，而且没有干燥的数字(如果有请求，它们就会出现)。</p><p id="cc84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">许多人可能会发现很难或没有必要处理孤立，人们停止计算。在这里，这个包的另一个功能可以拯救我们，它将API等同于计算的简单性，因此，它提供了更多的可能性。</p><p id="c708" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个例子:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3619" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这种方法，您可以简单地通过这个函数对应的ID来调用后端函数。与方法匹配的ID在预定义的getters中指定:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="faf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们有两种互动方式:</p><ol class=""><li id="ba71" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv nq mh mi mj bi translated"><strong class="ka ir">通过显式消息传递进行异步通信</strong></li></ol><p id="6b16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前端使用<em class="lc"> send </em>方法向后端发送事件，在消息中传递事件ID和可选参数。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8292" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个消息被传递到后端并在那里被处理。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7802" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Backend把结果返回给Frontend，你就大功告成了！有两种方法可以返回结果——通过使用后端方法返回响应(<em class="lc"> return </em>)(然后响应将使用与接收时相同的消息ID发送)，第二种方法是显式调用send方法。在这种情况下，您可以使用指定的任何ID将任何消息发送到反应状态。主要是处理程序方法是由这些id设置的。</p><p id="02b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">示意性地，第一种方式如下:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/7b1e130ac302cbf5915b3c49c90f31df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wtw5fWtAbI3RTCIJoWnWBg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">应用程序中前端和后端之间的异步通信方案</figcaption></figure><p id="9134" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">黄色双向箭头—与外部的任何服务交互，例如，某个服务器。紫色从服务器到服务器，这些是来自同一个服务器的消息，例如WebSocket。</p><p id="fd31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.<strong class="ka ir"> <em class="lc">同步</em> </strong>通过其ID调用后台函数进行通信</p><p id="3f0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前端使用<em class="lc"> runBackendMethod </em>方法，指定一个ID来调用与之对应的后端方法，在那里得到响应。这样，你甚至不需要在你前面的任务列表中指定任何东西。同时，如下面的代码所示，您可以在前端覆盖onBackendResponse方法，每次前端状态从后端接收消息时都会调用该方法。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a67c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端方法处理传入的事件，并简单地返回结果。在这种情况下，有一个限制——“同步”调用的back方法不应该使用它们对应的相同ID调用send方法。在此示例中，_decrement方法不应调用send (Events.decrement)方法。同时，他可以发送任何其他消息。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7954" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Схема второго способа похожа на первый, за тем исключением, что во фронте вам не нужно писать обработчики событий, прилетающих с бэка.<em class="lc">(非常抱歉，我正在从RU翻译我的文章，看起来翻译器在最不合适的时候坏了</em>😣<em class="lc"> ) </em></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/3291aa0ab673a875087351b28e8e02cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SRGd5ouJddw6fflEluZaKA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">前端和后端应用内通信的同步方案</figcaption></figure><p id="2b98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lc">很快，在0.0.5版本中，这个功能将起作用并向后——你可以从它的后端以同步模式运行前端的任务。</em></p><h2 id="0c81" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">还有什么要补充的…</h2><p id="7334" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">要使用这样的包，您需要创建这些后端。为此，<em class="lc">前端&lt;事件类型&gt; </em>有一个后端创建机制——init back end方法。在这个方法中，您需要传递一个工厂函数来创建后端。它应该是一个纯粹的顶级函数(正如Flutter文档所说的顶级)，或者是一个静态类方法。创建一个隔离区的时间约为200毫秒。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2383" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端零件创建者功能的示例:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="8e21" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">限制</h2><ul class=""><li id="8860" class="mb mc iq ka b kb lw kf lx kj nt kn nu kr nv kv mg mh mi mj bi translated">一切都和常规的<a class="ae kw" href="https://api.flutter.dev/flutter/dart-isolate/Isolate-class.html" rel="noopener ugc nofollow" target="_blank">隔离</a>一样</li><li id="6a4d" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">对于每个正在创建的“后端”,它自己的隔离当前正在被创建，如果有太多的后端，它们的创建时间会变得很明显，特别是如果您初始化所有的后端，比如说，当应用程序被加载时。我试验了同时运行30个后端——上述手机在发布模式下的启动时间超过了6秒。</li><li id="f9a4" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">在处理隔离(后端)中出现的错误时存在一些困难。在这里，如果你对这个包感兴趣，你应该更详细地熟悉一下来自<em class="lc">Frontend&lt;event type&gt;</em>的initBackend方法。</li><li id="c7de" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">与仅在主线程中存储逻辑相比，编写代码的复杂性更高</li></ul><h2 id="3fa7" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">使用清单</h2><p id="5f98" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这里一切都很简单，你<strong class="ka ir">不需要</strong>使用隔离(单独或使用这个包)，如果:</p><ul class=""><li id="cca9" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">在各种操作下，应用程序的性能不会降低</li><li id="b3be" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">对于瓶颈，计算就足够了</li><li id="3aa0" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">你不想和隔离者打交道</li><li id="1d22" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">你的应用程序的生命周期如此之短，以至于优化它毫无意义</li></ul><p id="73f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">否则，您可以将注意力转向这种方法和一个<a class="ae kw" href="https://pub.dev/packages/isolator" rel="noopener ugc nofollow" target="_blank">封装</a>(称为<strong class="ka ir">隔离器</strong>)，它将简化您的隔离工作。</p><p id="847b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文中的所有例子都可以在<a class="ae kw" href="https://github.com/alphamikle/isolator/tree/master/example" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="731b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lc">让我们开始使用分离菌吧！</em></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/288d0ec5f5eefdfeefd9c904895f0a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*6Kaa7nN-dwK4F70EYuBInA.gif"/></div></figure></div></div>    
</body>
</html>