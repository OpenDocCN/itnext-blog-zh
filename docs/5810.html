<html>
<head>
<title>Perform Kubernetes Deployment Rolling Updates in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Java中执行Kubernetes部署滚动更新</h1>
<blockquote>原文：<a href="https://itnext.io/perform-kubernetes-deployment-rolling-updates-in-java-2a133dbe6e7e?source=collection_archive---------1-----------------------#2021-05-30">https://itnext.io/perform-kubernetes-deployment-rolling-updates-in-java-2a133dbe6e7e?source=collection_archive---------1-----------------------#2021-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6f8fc6c970d4c4727c35fbb5b811bc63.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*-58gIpXpeckgKtH8jJPUfA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://github.com/fabric8io/kubernetes-client" rel="noopener ugc nofollow" target="_blank"> Fabric8 Kubernetes客户端</a></figcaption></figure><p id="207e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我最近在StackOverflow上看到一个问题，是关于如何使用Fabric8 Kubernetes客户端在Java中以编程方式进行滚动更新/回滚:</p><div class="kx ky gp gr kz la"><a href="https://stackoverflow.com/questions/61929260/does-fabric8io-k8s-java-client-support-patch-or-rollingupdate-using-yaml-sni/67709155#67709155" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">Fabric8io K8s java客户端支持使用YAML片段的patch()或rollingupdate()吗？</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">我正试图通过将部署片段作为输入，对k8s应用程序的补丁/滚动升级进行编程。我使用patch()…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">stackoverflow.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo js la"/></div></div></a></div><p id="b6f0" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我在那里看到一个已经过时的答案。根据最新的API改进，我给出了一个新的<a class="ae jy" href="https://stackoverflow.com/a/67709155/2830116" rel="noopener ugc nofollow" target="_blank">答案</a>,但我认为把它转换成一篇博客文章会更好，因为它可能对正在寻找类似内容的人有所帮助。因此，今天我们将了解如何使用Fabric8 Kubernetes Client以Java编程方式对您的Kubernetes资源进行滚动更新(我们以<code class="fe lp lq lr ls b">Deployment</code>为例)。</p><h1 id="fcca" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">获取客户端:</h1><p id="b142" class="pw-post-body-paragraph jz ka iq kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ij bi translated">如果您没有将Fabric8 Kubernetes客户端添加到您的项目中，您可能希望将其作为依赖项添加到您的项目配置中。如果你正在使用maven，你可以从<a class="ae jy" href="https://maven-badges.herokuapp.com/maven-central/io.fabric8/kubernetes-client" rel="noopener ugc nofollow" target="_blank"> maven central </a>获得最新版本，你可以像这样把它下载到你的<code class="fe lp lq lr ls b">pom.xml</code>:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="bb83" class="ne lu iq ls b gy nf ng l nh ni"><strong class="ls ir">&lt;dependency&gt;<br/>  &lt;groupId&gt;</strong>io.fabric8<strong class="ls ir">&lt;/groupId&gt;<br/>  &lt;artifactId&gt;</strong>kubernetes-client<strong class="ls ir">&lt;/artifactId&gt;<br/>  &lt;version&gt;</strong>5.4.0<strong class="ls ir">&lt;/version&gt;<br/>&lt;/dependency&gt;</strong></span></pre><h1 id="5e75" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">设置Kubernetes环境:</h1><p id="2ed1" class="pw-post-body-paragraph jz ka iq kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ij bi translated">如果您已经可以访问Kubernetes集群，那么您需要登录到您的集群。我使用的是<a class="ae jy" href="https://github.com/kubernetes/minikube" rel="noopener ugc nofollow" target="_blank"> minikube </a>，它建立了一个本地Kubernetes集群，这是一个单节点集群。为了开始使用它，我只需运行这个简单的命令:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="e2ad" class="ne lu iq ls b gy nf ng l nh ni"><strong class="ls ir">~ : $</strong> minikube start<br/>  minikube v1.19.0 on Fedora 34 <br/>  minikube 1.20.0 is available! Download it: https://github.com/kubernetes/minikube/releases/tag/v1.20.0 <br/>  To disable this notice, run: 'minikube config set WantUpdateNotification false' <br/>✨  Using the kvm2 driver based on existing profile <br/>  Starting control plane node minikube in cluster minikube <br/>  Restarting existing kvm2 VM for "minikube" ... <br/>  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ... <br/>  Verifying Kubernetes components... <br/>    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5 <br/>  Enabled addons: storage-provisioner, default-storageclass <br/>  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</span></pre><h1 id="e73f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">创建示例部署+服务:</h1><p id="0d78" class="pw-post-body-paragraph jz ka iq kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ij bi translated">为了进行滚动更新，我们需要创建一个控制器资源，它可以是下列资源之一:</p><ul class=""><li id="6977" class="nj nk iq kb b kc kd kg kh kk nl ko nm ks nn kw no np nq nr bi translated">部署</li><li id="e2b0" class="nj nk iq kb b kc ns kg nt kk nu ko nv ks nw kw no np nq nr bi translated">状态集</li><li id="5328" class="nj nk iq kb b kc ns kg nt kk nu ko nv ks nw kw no np nq nr bi translated">达蒙塞特</li></ul><p id="51f5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们将选择<code class="fe lp lq lr ls b">Deployment</code>，因为它是被广泛使用的库伯内特资源。让我们创建一个简单的<code class="fe lp lq lr ls b">Deployment</code>和一个<code class="fe lp lq lr ls b">Service</code>来公开这个部署:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">使用Fabric8 Kubernetes客户端创建部署和服务</figcaption></figure><p id="ca39" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">请注意，在<code class="fe lp lq lr ls b">Deployment</code>生成器中，我已经将<code class="fe lp lq lr ls b">spec.strategy.type</code>设置为<code class="fe lp lq lr ls b">RollingUpdate</code>，并设置了以下字段:</p><ul class=""><li id="d4bc" class="nj nk iq kb b kc kd kg kh kk nl ko nm ks nn kw no np nq nr bi translated"><strong class="kb ir"> maxSurge: </strong>在更新过程中可以创建的超过所需数量的pod的数量</li><li id="ec85" class="nj nk iq kb b kc ns kg nt kk nu ko nv ks nw kw no np nq nr bi translated"><strong class="kb ir"> maxUnavailable: </strong>在更新过程中不可用的单元数量</li></ul><p id="717f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">通过IDE或构建工具(在我的例子中是maven)运行这段代码:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="605b" class="ne lu iq ls b gy nf ng l nh ni"><strong class="ls ir">~ : $</strong> mvn exec:java  -Dexec.mainClass="io.fabric8.DeploymentAndServiceCreate"</span></pre><p id="1cdd" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">运行此示例后，您将能够看到正在创建的窗格:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="3555" class="ne lu iq ls b gy nf ng l nh ni"><strong class="ls ir">~ : $</strong> kubectl get deploy <br/>NAME        READY   UP-TO-DATE   AVAILABLE   AGE <br/>hello-dep   2/2     2            2           7m34s <br/><strong class="ls ir">~ : $</strong> kubectl get pods <br/>NAME                         READY   STATUS    RESTARTS   AGE <br/>hello-dep-648c656c8c-kz9xn   1/1     Running   0          7m36s <br/>hello-dep-648c656c8c-nx5hk   1/1     Running   0          7m36s</span></pre><p id="9ab9" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">当您的pod处于<code class="fe lp lq lr ls b">Running</code>状态时，您应该能够使用创建的<code class="fe lp lq lr ls b">Service</code>来访问它:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="348d" class="ne lu iq ls b gy nf ng l nh ni"><strong class="ls ir">~ : $ </strong>MINIKUBE_IP=`minikube ip` <br/><strong class="ls ir">~ : $</strong> HELLO_DEP_PORT=`kubectl get svc hello-dep -ojsonpath='{.spec.ports[0].nodePort}'` </span><span id="ff44" class="ne lu iq ls b gy nz ng l nh ni"><strong class="ls ir">~ : $</strong> curl $MINIKUBE_IP:$HELLO_DEP_PORT/ <br/>Hello, world! <br/>Version: 1.0.0 <br/>Hostname: hello-dep-648c656c8c-nx5hk</span></pre><p id="1572" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">或者您可以在浏览器中打开此URL:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi gj"><img src="../Images/381634fa96b97597af014dc5d365c324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jq6BQ4qNPN4biDFpReGtYw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">在Chrome中打开的应用程序URL</figcaption></figure><p id="8fa9" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如您所见，我们的第一个应用程序版本已经部署完毕。现在，我们可以看到滚动更新的不同方式。</p><h1 id="c1be" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">使用补丁API和JSON补丁进行滚动更新:</h1><p id="ed8b" class="pw-post-body-paragraph jz ka iq kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ij bi translated">现在我想用一个新的镜像版本更新应用程序，假设新的镜像版本是<code class="fe lp lq lr ls b">gcr.io/google-samples/hello-app:2.0</code>。我可以使用<code class="fe lp lq lr ls b">patch()</code>方法用JSON或YAML代码片段修补<code class="fe lp lq lr ls b">Deployment</code>中的图像，就像这样:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">使用补丁调用滚动更新</figcaption></figure><p id="7850" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">该呼叫将创建两个额外的单元，当它们准备就绪时，另外两个单元将被终止:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="92a5" class="ne lu iq ls b gy nf ng l nh ni"><strong class="ls ir">~ : $</strong> kubectl get pods <br/>NAME                       READY   STATUS            RESTARTS    AGE <br/>hello-dep-648c656c8c-n874w 1/1     Running             0         52s <br/>hello-dep-648c656c8c-p2jsr 1/1     Running             0         52s <br/>hello-dep-7c4d8c96db-bzn4h 0/1     ContainerCreating   0          3s <br/>hello-dep-7c4d8c96db-q49jh 0/1     ContainerCreating   0          3s </span><span id="9c3f" class="ne lu iq ls b gy nz ng l nh ni"><strong class="ls ir">~ : $</strong> kubectl get pods  <br/>NAME                         READY   STATUS        RESTARTS   AGE <br/>hello-dep-648c656c8c-n874w   1/1     Running       0          55s <br/>hello-dep-648c656c8c-p2jsr   0/1     Terminating   0          55s <br/>hello-dep-7c4d8c96db-bzn4h   1/1     Running       0          6s <br/>hello-dep-7c4d8c96db-q49jh   1/1     Running       0          6s </span><span id="c5e8" class="ne lu iq ls b gy nz ng l nh ni"><strong class="ls ir">~ : $</strong> kubectl get pods  <br/>NAME                         READY   STATUS        RESTARTS   AGE <br/>hello-dep-648c656c8c-n874w   0/1     Terminating   0          56s <br/>hello-dep-648c656c8c-p2jsr   0/1     Terminating   0          56s <br/>hello-dep-7c4d8c96db-bzn4h   1/1     Running       0          7s <br/>hello-dep-7c4d8c96db-q49jh   1/1     Running       0          7s</span><span id="48cd" class="ne lu iq ls b gy nz ng l nh ni"><strong class="ls ir">~ : $</strong> kubectl get pods  <br/>NAME                         READY   STATUS    RESTARTS   AGE <br/>hello-dep-7c4d8c96db-bzn4h   1/1     Running   0          2m40s <br/>hello-dep-7c4d8c96db-q49jh   1/1     Running   0          2m40s</span></pre><p id="a911" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">您应该能够访问更新服务并更改应用程序的根端点响应:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f4688260119a1325b7030fa6ae77695b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*PiFMz7FCLTbh-0VmpiNYww.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">滚动更新后应用程序的响应</figcaption></figure><h1 id="4d73" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">使用<code class="fe lp lq lr ls b">rolling()</code> API更新图像的滚动更新:</h1><p id="8674" class="pw-post-body-paragraph jz ka iq kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ij bi translated">Fabric8 Kubernetes客户端也提供了类似于<code class="fe lp lq lr ls b">kubectl rollout</code>的<code class="fe lp lq lr ls b">rolling()</code> DSL方法。在我看来，与上面的补丁例子相比，它的语法要清晰得多。下面是上面使用<code class="fe lp lq lr ls b">rolling().updateImage()</code>调用更新图像操作的样子:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">使用“Rolling()滚动更新。updateImage()`方法</figcaption></figure><p id="2fcf" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">当您运行这段代码时，您会看到它会显示与我们的补丁调用类似的行为。正如你所看到的，与之前的选择相比，它更干净。如果您的部署碰巧有多个容器，并且您想要更新这些容器的映像；你可以用<code class="fe lp lq lr ls b">updateImage(Map&lt;String, String&gt;)</code>的方法:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">使用rolling()更新多个容器的图像。updateImage()</figcaption></figure><h1 id="2aca" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">使用Rolling()重新启动滚动更新。重新启动():</h1><p id="e8b1" class="pw-post-body-paragraph jz ka iq kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ij bi translated">如果你想简单地重启已部署的吊舱。您可以执行首次展示重启，这将为您的应用程序创建新的窗格:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Rollout使用rolling()重新启动部署。重新启动()</figcaption></figure><h1 id="1c2a" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">使用rolling()回滚部署。撤消():</h1><p id="b7f7" class="pw-post-body-paragraph jz ka iq kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ij bi translated">您还可以使用<code class="fe lp lq lr ls b">rolling().undo()</code>方法回滚到部署的前一个部署版本，就像您对<code class="fe lp lq lr ls b">kubectl rollout undo</code>所做的那样。比方说，你已经用v1部署了应用程序的第一个版本。您将它的图像更新到第二个版本，现在您会得到以下响应:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f4688260119a1325b7030fa6ae77695b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*PiFMz7FCLTbh-0VmpiNYww.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">应用程序已通过滚动更新重新部署</figcaption></figure><p id="ca27" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在，您希望回滚到此部署的先前版本。你可以这样用<code class="fe lp lq lr ls b">rolling().undo()</code>调用:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">使用Fabric8 Kubernetes客户端回滚</figcaption></figure><p id="6fd3" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">运行这段代码后，您应该能够看到正在部署的应用程序的第一个版本:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi gj"><img src="../Images/381634fa96b97597af014dc5d365c324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jq6BQ4qNPN4biDFpReGtYw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">使用Fabric8 Kubernetes客户端回滚部署</figcaption></figure><h1 id="ebe8" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">暂停和恢复滚动更新:</h1><p id="6261" class="pw-post-body-paragraph jz ka iq kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ij bi translated">您还可以使用<code class="fe lp lq lr ls b">rolling().pause()</code> / <code class="fe lp lq lr ls b">rolling().resume()</code>方法暂停/恢复正在进行的滚动更新。这里是它的用法的例子。我在一个窗口中开始部署，然后运行这个示例:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">部署滚动更新暂停/恢复</figcaption></figure><p id="78d0" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">当我运行这个程序时，有一分钟时间，所有使用rollout step创建的附加单元都与已经部署的单元一起存在。休眠1分钟后，程序以<code class="fe lp lq lr ls b">rollout().resume()</code>终止，之后吊舱开始终止，只有2个吊舱处于活动状态。</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="e616" class="ne lu iq ls b gy nf ng l nh ni"><strong class="ls ir">~ : $</strong> kubectl get pods <br/>NAME                         READY   STATUS    RESTARTS   AGE <br/>hello-dep-648c656c8c-kgqtv   1/1     Running   0          9m27s <br/>hello-dep-6f44dbbdd6-25zcj   1/1     Running   0          43s <br/>hello-dep-6f44dbbdd6-2qq7k   1/1     Running   0          37s <br/>hello-dep-6f44dbbdd6-4t9q6   1/1     Running   0          37s <br/>hello-dep-6f44dbbdd6-54cbp   1/1     Running   0          43s <br/>hello-dep-6f44dbbdd6-bts9r   1/1     Running   0          37s <br/><strong class="ls ir">~ : $</strong> kubectl get pods <br/>NAME                         READY   STATUS    RESTARTS   AGE <br/>hello-dep-648c656c8c-kgqtv   1/1     Running   0          9m44s <br/>hello-dep-6f44dbbdd6-25zcj   1/1     Running   0          60s <br/>hello-dep-6f44dbbdd6-2qq7k   1/1     Running   0          54s <br/>hello-dep-6f44dbbdd6-4t9q6   1/1     Running   0          54s <br/>hello-dep-6f44dbbdd6-54cbp   1/1     Running   0          60s <br/>hello-dep-6f44dbbdd6-bts9r   1/1     Running   0          54s <br/><strong class="ls ir">~ : $</strong> kubectl get pods <br/>NAME                         READY   STATUS        RESTARTS   AGE <br/>hello-dep-648c656c8c-kgqtv   0/1     Terminating   0          9m56s <br/>hello-dep-6f44dbbdd6-25zcj   1/1     Running       0          72s <br/>hello-dep-6f44dbbdd6-2qq7k   0/1     Terminating   0          66s <br/>hello-dep-6f44dbbdd6-4t9q6   0/1     Terminating   0          66s <br/>hello-dep-6f44dbbdd6-54cbp   1/1     Running       0          72s <br/>hello-dep-6f44dbbdd6-bts9r   0/1     Terminating   0          66s <br/>stackoverflow-code : $ kubectl get pods <br/>NAME                         READY   STATUS    RESTARTS   AGE <br/>hello-dep-6f44dbbdd6-25zcj   1/1     Running   0          3m37s <br/>hello-dep-6f44dbbdd6-54cbp   1/1     Running   0          3m37s</span></pre><h1 id="1e0c" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论:</h1><p id="86d6" class="pw-post-body-paragraph jz ka iq kb b kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw ij bi translated">在今天的博客中，您学习了如何使用Fabric8 Kubernetes客户端在Java中对控制器资源进行滚动更新。您可以在这个资源库中找到与本博客相关的所有代码:</p><div class="kx ky gp gr kz la"><a href="https://github.com/rohanKanojia/kubernetes-client-demo" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">rohanKanojia/kubernetes-客户端-演示</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">该项目包含Fabric8 Kubernetes客户端不同用法的各种示例。我通常在我的…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">github.com</p></div></div><div class="lj l"><div class="of l ll lm ln lj lo js la"/></div></div></a></div><p id="d2d4" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>