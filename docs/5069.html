<html>
<head>
<title>A deep dive into ConfigureAwait</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解配置等待</h1>
<blockquote>原文：<a href="https://itnext.io/a-deep-dive-into-configureawait-65f52b9605c2?source=collection_archive---------0-----------------------#2020-12-03">https://itnext.io/a-deep-dive-into-configureawait-65f52b9605c2?source=collection_archive---------0-----------------------#2020-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0d09d90f5868bba6371166b3d8600142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZZNrhftYlEAHdRK5gfrXEQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">里卡多四世塔马约在<a class="ae kf" href="https://unsplash.com/s/photos/airport-worker?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="556d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧好吧好吧！(是的，它是马修·麦康纳<a class="ae kf" href="https://www.youtube.com/watch?v=EuER2Puym4I" rel="noopener ugc nofollow" target="_blank">的参考文献</a>)</p><p id="a66a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能已经注意到了，我非常喜欢异步及其内在特性。我喜欢艰难的挑战，深刻理解异步是一个挑战。</p><p id="f66f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">异步的美妙之处在于它可以是甜蜜的，也可以是苦涩的，这取决于你如何实现它。但是，如果你理解它是如何在引擎盖下工作的，以及它的句法糖，你就能掌握它，并享受它的全部潜力。</p><p id="472f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的上一篇博文中，<a class="ae kf" href="https://medium.com/@nelsonparente/net-async-programming-in-a-nutshell-dc01c2e71a20" rel="noopener">。NET异步编程简而言之</a>，我们在。NET和实现最佳实践。当我们在。NET中有一个扩展方法几乎总是出现在讨论中，那就是<em class="le">configurewait(false)。</em></p><p id="7248" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你写<em class="le">。ConfigureAwait(false) </em>在每次<em class="le">等待</em>使用后？如果是，你能解释为什么吗？或者这是你机械地做的事情，因为它是“模式”？</p><p id="a65b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在更好地理解<em class="le">configurewait(false)</em>之前，我们必须后退几步，看看<em class="le"> SynchronizationContext </em>。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="7b66" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">同步上下文</h2><p id="f6f8" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">微软<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext?view=net-5.0" rel="noopener ugc nofollow" target="_blank">文档声明</a><em class="le">SynchronizationContext</em>类提供了在各种同步模型中传播同步上下文的基本功能。你从描述中了解它是做什么的吗？我没有，所以我必须深入调查。</p><p id="e5cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个正在运行的线程都有它的“当前”<em class="le">同步上下文</em> <strong class="ki iu"> </strong>并且在这个类中有一个特殊的方法，即<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext.post?view=net-5.0#System_Threading_SynchronizationContext_Post_System_Threading_SendOrPostCallback_System_Object_" rel="noopener ugc nofollow" target="_blank"> Post </a>:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="3b9b" class="lm ln it mp b gy mt mu l mv mw">public virtual void Post (System.Threading.SendOrPostCallback d, object? state)</span></pre><p id="2947" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<em class="le"> SynchronizationContext </em>默认实现中的这个方法接收一个委托并调用<em class="le">线程池。将被异步调用的QueueUserWorkItem </em> <strong class="ki iu"> </strong>。然后<em class="le">线程池</em>包含一个有工作要做的队列，将在任务执行完成时回调结果。</p><p id="8ba9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意到<em class="le">帖</em>是虚法？虚拟方法可以被不同地覆盖和实现，这就是一些框架实际做的，它们扩展<em class="le"> SynchronizationContext </em>并覆盖虚拟方法的实现。例如，。NET框架使用<a class="ae kf" href="https://referencesource.microsoft.com/#system.web/AspNetSynchronizationContext.cs" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">AspNetSynchronizationContext</strong></a><strong class="ki iu"/>，WPF使用<a class="ae kf" href="https://github.com/dotnet/wpf/blob/ac9d1b7a6b0ee7c44fd2875a1174b820b3940619/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherSynchronizationContext.cs" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">DispatcherSynchronizationContext</strong></a>，每个框架都以更适合自己的方式实现这个类。</p><p id="e421" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更简单地说，当我们在C#中<em class="le">等待</em>任何东西时，编译器会转换代码，向“可等待的”(<em class="le"> Task </em>)请求“等待者”(<em class="le"> TaskAwaiter &lt; T &gt; </em>)。然后awaiter负责抓取当前的<em class="le"> SynchronizationContext </em>，然后在等待的<em class="le">任务</em>完成时返回回调。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="847d" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">configurewait(false)</h2><p id="d61c" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">大概此时此刻，你正在疑惑<em class="le">configurewait</em>到底有什么特别之处。除了一个小细节外，<em class="le">配置并没有什么特别的。</em></p><p id="4b12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">configurewait(continueOnCapturedContext:false)</em>避免了回调在原来的<em class="le">SynchronizationContext</em><strong class="ki iu"/>中执行，这有很多好处。</p><p id="27cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个是性能，使用<em class="le">configurewait(false)</em>将不会有任何队列，或者等待原始上下文可用所涉及的额外工作，<em class="le">任务</em>将在可用的上下文中恢复。第二个好处是避免死锁，想象一下，由于某种原因，所需的<em class="le">SynchronizationContext</em><strong class="ki iu"/>无限期地处于阻塞状态，必须等待它被释放才能恢复执行，这将导致应用程序中的死锁。</p><p id="8f77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很少有使用<em class="le">configurewait(true)</em>的用例，它实际上没有什么意义。在99%的情况下，您应该使用<em class="le">configurewait(false)</em>。</p><p id="6f3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">英寸NET Framework默认情况下，<em class="le">任务</em>将在捕获的上下文上继续执行，这是<em class="le">configurewait(true)</em>。正如我们上面看到的，使用<em class="le">configurewait(false)</em>有几个好处。</p><p id="99ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当使用async/await时，这种默认行为导致<em class="le">configurewait(false)</em>遍布我们的代码库，并成为异步编程中的一种<a class="ae kf" href="https://exceptionnotfound.net/cargo-cult-programming-the-daily-software-anti-pattern/" rel="noopener ugc nofollow" target="_blank"> Cargo Cult反模式</a>。</p><blockquote class="mx my mz"><p id="b291" class="kg kh le ki b kj kk kl km kn ko kp kq na ks kt ku nb kw kx ky nc la lb lc ld im bi translated">当一个程序员向他的项目中添加代码时，尽管他并不完全理解这些代码是做什么的，但还是会出现Cargo-Cult编程。</p></blockquote><p id="cdb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们大多数人在使用<em class="le">configurewait(false)</em>时，从来没有问过自己它的真正目的是什么，以及这些东西在幕后是如何工作的。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="2f0c" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">。网络核心拯救世界</h2><p id="2251" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated"><em class="le">中的大新闻之一。NET Core </em>框架缺少任何一种<em class="le"> SynchronizationContext </em>，这是移除了旧<em class="le">中使用的<a class="ae kf" href="https://referencesource.microsoft.com/#system.web/AspNetSynchronizationContext.cs" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">AspNetSynchronizationContext</strong></a><strong class="ki iu"/>。NET框架</em>。</p><p id="a273" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以在这个<em class="le">的无语境方法中。NET Core，</em>默认的异步行为与我们使用<em class="le">configurewait(false)</em>时的行为相同，因此当<em class="le">异步</em>处理程序恢复执行时，一个线程从线程池中取出并开始工作。但是请注意，await关键字不能捕获上下文并不意味着您可以避免死锁，异步实现中的错误仍然会导致线程阻塞。</p><p id="6f91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这时，有人可能会想，在<em class="le">里。NET Core </em>你不需要将<em class="le">configurewait(false)</em>散布在你的代码中。差不多！</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f8dfb35af23b9ad45c844673cd455b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*TRhoD6ka7w7N3HtrpzIFjA.gif"/></div></figure><p id="49dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这几乎是真的，如果在遗留框架中使用库，仍然建议使用库的<em class="le">configurewait(false)</em>作为后备。但是大多数情况下是的，在<em class="le">中。NET Core </em>可以去掉<em class="le">configurewait(false)</em>用法。</p><p id="fa42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结束了！</p><p id="4a6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一名工程师，这些事情让我越来越想继续研究我日常使用的技术的核心，这引发了我的好奇心，并且理解所有这些复杂概念如何协同工作是非常有益的。</p><p id="b306" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇博文中，我们稍微深入了一下<em class="le">中异步编程的核心。NET </em>，<em class="le">SynchronizationContext</em><strong class="ki iu"><em class="le"/></strong>和，我们明白了<em class="le">configurewait(false)</em>传播的原因。我希望，看完这篇博客后，你不是这个货物邪教的成员之一，现在你知道为什么使用<em class="le"> ConfigureAwait(false) </em>以及它如何成为<a class="ae kf" href="https://exceptionnotfound.net/cargo-cult-programming-the-daily-software-anti-pattern/" rel="noopener ugc nofollow" target="_blank">货物邪教反模式</a>的最大例子之一。</p><p id="22d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尼尔森出局。</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><a href="https://www.buymeacoffee.com/nelsonparente"><div class="gh gi ne"><img src="../Images/69716627feab2505c60838bbd29241a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gS6Sh6i8g535gOafY4Wl1w.png"/></div></a></figure></div></div>    
</body>
</html>