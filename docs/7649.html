<html>
<head>
<title>K8s Tips: Accessing the API Server From a Pod</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s技巧:从Pod访问API服务器</h1>
<blockquote>原文：<a href="https://itnext.io/k8s-tips-accessing-the-api-server-from-a-pod-f6f72bc847de?source=collection_archive---------2-----------------------#2022-12-08">https://itnext.io/k8s-tips-accessing-the-api-server-from-a-pod-f6f72bc847de?source=collection_archive---------2-----------------------#2022-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ca5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">除非真的有必要，否则不要让这种情况发生</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bab0c3e104d4b758343dc5e2a75280fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PfZs34sgn-aMLmEsRWRM6Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dimhou?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Dim侯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/not-authorized?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="3053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，标识默认ServiceAccount的令牌安装在Pod的容器中。这个令牌允许容器与API服务器通信。应用程序能做的不多，但是能够针对API服务器进行身份验证已经太多了，尤其是在不需要这样做的情况下。只有需要对Kubernetes的资源执行操作的应用程序(例如:列出节点、创建服务、部署、配置映射等)才需要能够针对API服务器进行身份验证。</p><p id="169e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇短文中，我们将探索一个Pod在默认情况下与API服务器通信的方式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="391a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们使用下面的命令创建一个基于<strong class="lb iu">幽灵</strong>图像的Pod:</p><pre class="kj kk kl km gt mc md me bn mf mg bi"><span id="2768" class="mh mi it md b be mj mk l ml mm">$ cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: ghost<br/>spec:<br/>  containers:<br/>  - image: ghost:4<br/>    name: ghost<br/>EOF</span></pre><p id="6f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们检查群集中现在已知的Pod的完整规格:</p><pre class="kj kk kl km gt mc md me bn mf mg bi"><span id="8d24" class="mh mi it md b be mj mk l ml mm">$ kubectl get po ghost -o yaml<br/>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  annotations:<br/>    cni.projectcalico.org/containerID: c7b73bd3bbb97438285987733aece40a84b73c96d39babfce624df10303dea29<br/>    cni.projectcalico.org/podIP: 192.168.6.153/32<br/>    cni.projectcalico.org/podIPs: 192.168.6.153/32<br/>    kubectl.kubernetes.io/last-applied-configuration: |<br/>      {"apiVersion":"v1","kind":"Pod","metadata":{"annotations":{},"name":"ghost","namespace":"default"},"spec":{"containers":[{"image":"ghost:4","name":"ghost"}]}}<br/>    kubernetes.io/psp: privileged<br/>  creationTimestamp: "2022-12-08T15:12:19Z"<br/>  name: ghost<br/>  namespace: default<br/>  resourceVersion: "3858826580"<br/>  uid: 61b901a1-cd5b-41a1-9cc6-3f703cc555c1<br/>spec:<br/>  containers:<br/>  - image: ghost:4<br/>    imagePullPolicy: IfNotPresent<br/>    name: ghost<br/>    resources: {}<br/>    terminationMessagePath: /dev/termination-log<br/>    terminationMessagePolicy: File<br/>    volumeMounts:<br/>    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount<br/>      name: kube-api-access-fsjkt<br/>      readOnly: true<br/>  dnsPolicy: ClusterFirst<br/>  enableServiceLinks: true<br/>  nodeName: pool-9d740-qcgsu<br/>  preemptionPolicy: PreemptLowerPriority<br/>  priority: 0<br/>  restartPolicy: Always<br/>  schedulerName: default-scheduler<br/>  securityContext: {}<br/>  serviceAccount: default<br/>  serviceAccountName: default<br/>  terminationGracePeriodSeconds: 30<br/>  tolerations:<br/>  - effect: NoExecute<br/>    key: node.kubernetes.io/not-ready<br/>    operator: Exists<br/>    tolerationSeconds: 300<br/>  - effect: NoExecute<br/>    key: node.kubernetes.io/unreachable<br/>    operator: Exists<br/>    tolerationSeconds: 300<br/>  volumes:<br/>  - name: kube-api-access-fsjkt<br/>    projected:<br/>      defaultMode: 420<br/>      sources:<br/>      - serviceAccountToken:<br/>          expirationSeconds: 3607<br/>          path: token<br/>      - configMap:<br/>          items:<br/>          - key: ca.crt<br/>            path: ca.crt<br/>          name: kube-root-ca.crt<br/>      - downwardAPI:<br/>          items:<br/>          - fieldRef:<br/>              apiVersion: v1<br/>              fieldPath: metadata.namespace<br/>            path: namespace<br/>status:<br/>  conditions:<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2022-12-08T15:12:19Z"<br/>    status: "True"<br/>    type: Initialized<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2022-12-08T15:12:21Z"<br/>    status: "True"<br/>    type: Ready<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2022-12-08T15:12:21Z"<br/>    status: "True"<br/>    type: ContainersReady<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2022-12-08T15:12:19Z"<br/>    status: "True"<br/>    type: PodScheduled<br/>  containerStatuses:<br/>  - containerID: containerd://0d8abbb5d2ec63b5a7367b073a87557dc3d19daab6dc5fc45e7d361b9743c9bb<br/>    image: docker.io/library/ghost:4<br/>    imageID: docker.io/library/ghost@sha256:46e434734d979066bcea050dc0fb156b763283168ae080e00616543d62cc3706<br/>    lastState: {}<br/>    name: ghost<br/>    ready: true<br/>    restartCount: 0<br/>    started: true<br/>    state:<br/>      running:<br/>        startedAt: "2022-12-08T15:12:20Z"<br/>  hostIP: 194.182.168.142<br/>  phase: Running<br/>  podIP: 192.168.6.153<br/>  podIPs:<br/>  - ip: 192.168.6.153<br/>  qosClass: BestEffort<br/>  startTime: "2022-12-08T15:12:19Z"</span></pre><p id="f536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们在创建Pod时使用的属性相比，上面的规范中有更多的属性，例如:</p><ul class=""><li id="8eea" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">网络插件已经添加了注释</li><li id="857c" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">已创建内部标识符</li><li id="1d39" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">已经为我们在初始规范中没有指定的属性添加了默认值</li><li id="bf51" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">添加了<em class="nb">状态</em>属性，它给出了关于Pod和容器生命周期的信息</li><li id="152a" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">添加了Pod及其运行节点的IP地址</li></ul><p id="551b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将重点关注以下部分:</p><ul class=""><li id="2075" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated"><em class="nb">卷</em>属性下<em class="nb">。规格</em>:</li></ul><pre class="kj kk kl km gt mc md me bn mf mg bi"><span id="c6fd" class="mh mi it md b be mj mk l ml mm">volumes:<br/>  - name: kube-api-access-gh2kv<br/>    projected:<br/>      defaultMode: 420<br/>      sources:<br/>      - serviceAccountToken:<br/>          expirationSeconds: 3607<br/>          path: token<br/>      - configMap:<br/>          items:<br/>          - key: ca.crt<br/>            path: ca.crt<br/>          name: kube-root-ca.crt<br/>      - downwardAPI:<br/>          items:<br/>          - fieldRef:<br/>              apiVersion: v1<br/>              fieldPath: metadata.namespace<br/>            path: namespace</span></pre><ul class=""><li id="49e9" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated"><em class="nb">volume mounts<em class="nb">下的</em>属性. spec.containers </em></li></ul><pre class="kj kk kl km gt mc md me bn mf mg bi"><span id="3c2f" class="mh mi it md b be mj mk l ml mm">volumeMounts:<br/>  - mountPath: /var/run/secrets/kubernetes.io/serviceaccount<br/>    name: kube-api-access-gh2kv<br/>    readOnly: true</span></pre><p id="f071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那些<em class="nb">卷</em>和<em class="nb">卷装</em>是干什么用的？</p><p id="2d17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，<em class="nb">卷</em>属性定义了一个<em class="nb">投影</em>卷。这种卷允许将多个现有卷源放入同一目录。在当前示例中，预计体积使用:</p><ul class=""><li id="fa36" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">标识默认命名空间(在其中创建Pod的命名空间)的ServiceAccount的令牌</li><li id="ca8b" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">包含群集证书颁发机构的配置映射</li><li id="d57b" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">Pod所在的命名空间。这一个是使用DownwardAPI检索的，它允许从属于Pod规范的字段中获取值</li></ul><p id="e2a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这3个元素中的每一个都将在投影卷内的专用路径中可用:分别是<em class="nb">令牌</em>、<em class="nb"> ca.crt </em>和<em class="nb">命名空间</em></p><p id="74a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，<em class="nb"> volumesMounts </em>属性用于将投影卷的内容挂载到Pod的文件系统中的<em class="nb">/var/run/secrets/kubernetes . io/service account</em>文件夹中。</p><p id="8964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了验证这一点，我们可以在ghost容器中运行一个shell，并确保文件夹<em class="nb">/run/secrets/kubernetes . io/service account/</em>包含3个文件:</p><pre class="kj kk kl km gt mc md me bn mf mg bi"><span id="142a" class="mh mi it md b be mj mk l ml mm">$ ls /run/secrets/kubernetes.io/serviceaccount/<br/>ca.crt namespace  token</span></pre><p id="7f49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从容器中，我们尝试使用<em class="nb"> kubernetes </em>内部服务调用API服务器:</p><pre class="kj kk kl km gt mc md me bn mf mg bi"><span id="73a2" class="mh mi it md b be mj mk l ml mm">$ curl https://kubernetes/api/v1<br/>curl: (60) SSL certificate problem: unable to get local issuer certificate<br/>More details here: https://curl.se/docs/sslcerts.html<br/><br/>curl failed to verify the legitimacy of the server and therefore could not<br/>establish a secure connection to it. To learn more about this situation and<br/>how to fix it, please visit the web page mentioned above.</span></pre><p id="de9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<em class="nb">/run/secrets/kubernetes . io/service account/</em>中的证书来消除这个错误:</p><pre class="kj kk kl km gt mc md me bn mf mg bi"><span id="ad09" class="mh mi it md b be mj mk l ml mm">$ curl --cacert /run/secrets/kubernetes.io/serviceaccount/ca.crt https://kubernetes/api/v1<br/>{<br/>  "kind": "Status",<br/>  "apiVersion": "v1",<br/>  "metadata": {},<br/>  "status": "Failure",<br/>  "message": "forbidden: User \"system:anonymous\" cannot get path \"/api/v1\"",<br/>  "reason": "Forbidden",<br/>  "details": {},<br/>  "code": 403<br/>}</span></pre><p id="79c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到了一个禁止的/ 403错误，因为上面的命令没有使用任何认证。为了更进一步，我们可以使用在<em class="nb">/run/secrets/kubernetes . io/service account/token</em>中定义的令牌，如下所示:</p><pre class="kj kk kl km gt mc md me bn mf mg bi"><span id="628e" class="mh mi it md b be mj mk l ml mm">$ TOKEN=$(cat /run/secrets/kubernetes.io/serviceaccount/token) <br/><br/>$ curl -H "Authorization: Bearer $TOKEN" --cacert /run/secrets/kubernetes.io/serviceaccount/ca.crt https://kubernetes/api/v1/ <br/>{<br/>  "kind": "APIResourceList",<br/>  "groupVersion": "v1",<br/>  "resources": [<br/>    {<br/>      "name": "bindings",<br/>      "singularName": "",<br/>      "namespaced": true,<br/>      "kind": "Binding",<br/>      "verbs": [<br/>        "create"<br/>      ]<br/>    },<br/>    {<br/>      "name": "componentstatuses",<br/>      "singularName": "",<br/>      "namespaced": false,<br/>      "kind": "ComponentStatus",<br/>      "verbs": [<br/>        "get",<br/>        "list"<br/>      ],<br/>      "shortNames": [<br/>        "cs"<br/>      ]<br/>    },<br/>    {<br/>      "name": "configmaps",<br/>      "singularName": "",<br/>      "namespaced": true,<br/>      "kind": "ConfigMap",<br/>      "verbs": [<br/>        "create",<br/>        "delete",<br/>        "deletecollection",<br/>        "get",<br/>        "list",<br/>        "patch",<br/>        "update",<br/>        "watch"<br/>      ],<br/>      "shortNames": [<br/>        "cm"<br/>      ],<br/>      "storageVersionHash": "qFsyl6wFWjQ="<br/>    },<br/>    ...<br/>  ]<br/>}</span></pre><p id="86fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在能够获得集群中所有可用资源类型的列表。让我们尝试获取节点列表:</p><pre class="kj kk kl km gt mc md me bn mf mg bi"><span id="7154" class="mh mi it md b be mj mk l ml mm">$ curl -H "Authorization: Bearer $TOKEN" --cacert /run/secrets/kubernetes.io/serviceaccount/ca.crt https://kubernetes/api/v1/nodes<br/>{<br/>  "kind": "Status",<br/>  "apiVersion": "v1",<br/>  "metadata": {},<br/>  "status": "Failure",<br/>  "message": "nodes is forbidden: User \"system:serviceaccount:default:default\" cannot list resource \"nodes\" in API group \"\" at the cluster scope",<br/>  "reason": "Forbidden",<br/>  "details": {<br/>    "kind": "nodes"<br/>  },<br/>  "code": 403<br/>}</span></pre><p id="a2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们使用链接到默认ServiceAccount的授权令牌，因此我们被标识为<strong class="lb iu">system:service account:default:default</strong>。这个ServiceAccount没有允许它列出节点的关联角色，这是我们得到一个新的禁止/ 403错误的原因。</p><p id="4e2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们删除ghost Pod，并使用以下命令创建一个新的。Pod的规范将<em class="nb">. spec . automountserviceaccountoken</em>设置为<em class="nb"> false </em>以防止ServiceAccount令牌在容器的文件系统中可用。</p><pre class="kj kk kl km gt mc md me bn mf mg bi"><span id="83a5" class="mh mi it md b be mj mk l ml mm">$ kubectl delete po ghost<br/><br/>$ cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: ghost<br/>spec:<br/>  automountServiceAccountToken: false<br/>  containers:<br/>  - image: ghost:4<br/>    name: ghost<br/>EOF</span></pre><p id="8f60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们之前所做的那样，我们可以查看一下集群中现在已知的完整规范:</p><pre class="kj kk kl km gt mc md me bn mf mg bi"><span id="d341" class="mh mi it md b be mj mk l ml mm">$ kubectl get po ghost -o yaml<br/>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  annotations:<br/>    cni.projectcalico.org/containerID: ee795d6656add15dbbd6dce8c045a86b69c97d72333b1a930d73213b36d80e2d<br/>    cni.projectcalico.org/podIP: 192.168.6.157/32<br/>    cni.projectcalico.org/podIPs: 192.168.6.157/32<br/>    kubectl.kubernetes.io/last-applied-configuration: |<br/>      {"apiVersion":"v1","kind":"Pod","metadata":{"annotations":{},"name":"ghost","namespace":"default"},"spec":{"automountServiceAccountToken":false,"containers":[{"image":"ghost:4","name":"ghost"}]}}<br/>    kubernetes.io/psp: privileged<br/>  creationTimestamp: "2022-12-08T18:21:19Z"<br/>  name: ghost<br/>  namespace: default<br/>  resourceVersion: "3860621158"<br/>  uid: b51f5883-d8b9-4835-9436-db6cc845aac0<br/>spec:<br/>  automountServiceAccountToken: false<br/>  containers:<br/>  - image: ghost:4<br/>    imagePullPolicy: IfNotPresent<br/>    name: ghost<br/>    resources: {}<br/>    terminationMessagePath: /dev/termination-log<br/>    terminationMessagePolicy: File<br/>  dnsPolicy: ClusterFirst<br/>  enableServiceLinks: true<br/>  nodeName: pool-9d740-qcgsu<br/>  preemptionPolicy: PreemptLowerPriority<br/>  priority: 0<br/>  restartPolicy: Always<br/>  schedulerName: default-scheduler<br/>  securityContext: {}<br/>  serviceAccount: default<br/>  serviceAccountName: default<br/>  terminationGracePeriodSeconds: 30<br/>  tolerations:<br/>  - effect: NoExecute<br/>    key: node.kubernetes.io/not-ready<br/>    operator: Exists<br/>    tolerationSeconds: 300<br/>  - effect: NoExecute<br/>    key: node.kubernetes.io/unreachable<br/>    operator: Exists<br/>    tolerationSeconds: 300<br/>status:<br/>  conditions:<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2022-12-08T18:21:19Z"<br/>    status: "True"<br/>    type: Initialized<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2022-12-08T18:21:20Z"<br/>    status: "True"<br/>    type: Ready<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2022-12-08T18:21:20Z"<br/>    status: "True"<br/>    type: ContainersReady<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2022-12-08T18:21:19Z"<br/>    status: "True"<br/>    type: PodScheduled<br/>  containerStatuses:<br/>  - containerID: containerd://f7a5127800534ad87cdecf14275d679fedc956b97bd45aeec2b91d5e55529774<br/>    image: docker.io/library/ghost:4<br/>    imageID: docker.io/library/ghost@sha256:46e434734d979066bcea050dc0fb156b763283168ae080e00616543d62cc3706<br/>    lastState: {}<br/>    name: ghost<br/>    ready: true<br/>    restartCount: 0<br/>    started: true<br/>    state:<br/>      running:<br/>        startedAt: "2022-12-08T18:21:20Z"<br/>  hostIP: 194.182.168.142<br/>  phase: Running<br/>  podIP: 192.168.6.157<br/>  podIPs:<br/>  - ip: 192.168.6.157<br/>  qosClass: BestEffort<br/>  startTime: "2022-12-08T18:21:19Z"</span></pre><p id="26da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，在容器的文件系统中没有安装预计的卷，因此阻止了它向API服务器发送经过验证的查询(尽管受到限制)</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8c07" class="nc mi it bd nd ne nf dn ng nh ni dp nj li nk nl nm lm nn no np lq nq nr ns nt bi translated">关键要点</h2><p id="1e31" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">默认情况下，Pod可以与API服务器通信，因为默认的ServiceAccount令牌安装在它的容器中。如果应用程序不需要与API服务器通信，我们需要确保这个令牌在容器中不可用。这可以通过Pod规范中的automountServiceAccountToken属性来完成。</p></div></div>    
</body>
</html>