<html>
<head>
<title>Building RESTful Web APIs with Dart, Aqueduct, and PostgreSQL — Part 2: Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Dart、Aqueduct和PostgreSQL构建RESTful Web APIs第2部分:路由</h1>
<blockquote>原文：<a href="https://itnext.io/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-2-routing-with-crud-operations-629fe58114fa?source=collection_archive---------5-----------------------#2018-05-17">https://itnext.io/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-2-routing-with-crud-operations-629fe58114fa?source=collection_archive---------5-----------------------#2018-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/06e8bbde0c96f1f6bf784142ca15afc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZOMxFZ3wwPS9yd0OYUPHg.jpeg"/></div></div></figure><div class=""/></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="f08e" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh jc"> <em class="ld">请注意:从Dart 2开始，导水管的API发生了变化，导致了突破性的变化。本文基于Dart v1的Aqueduct 2.5.0。</em> </strong></p><p id="d5d9" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh jc"> <em class="ld">我把这个更新为新的视频系列:</em></strong><a class="ae le" href="http://bit.ly/aqueduct-tutorial" rel="noopener ugc nofollow" target="_blank"><strong class="kh jc"><em class="ld">http://bit.ly/aqueduct-tutorial</em></strong></a></p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="8e5b" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在第1部分中，我们简要概述了Aqueduct及其特性，并学习了如何使用其CLI工具设置示例项目。</p><p id="bbef" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">本文是系列文章的一部分，涵盖以下主题:</p><ul class=""><li id="97d3" class="lf lg jb kh b ki kj km kn kq lh ku li ky lj lc lk ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-3cc9b931f777"> <strong class="kh jc">第1部分:设置并运行示例</strong> </a></li><li id="0e57" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><strong class="kh jc">第2部分:用CRUD操作实现路由</strong> ( <em class="ld">我们到了</em>)</li><li id="1742" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><a class="ae le" href="https://medium.com/@98d967ac6f3a/90ff70742675" rel="noopener"> <strong class="kh jc">第3部分:将Web APIs连接到PostgreSQL数据库</strong> </a></li><li id="c038" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-4-testing-de3618515639"> <strong class="kh jc">第4部分:编写自动化测试</strong> </a></li><li id="a653" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-bonus-content-2fc086b7259a"><strong class="kh jc">*奖金内容* </strong> <em class="ld"> </em> DB迁移和模型关系</a></li></ul><p id="4869" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在这一部分中，我们将实现一个具有CRUD( <em class="ld">创建、读取、更新、删除)</em>功能的定制路由。</p><p id="a1a2" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在开始之前，我们需要理解路由器和HTTPControllers的概念。这将有助于我们了解前进的方向。在这一部分的最后，我们将有我们的端点，能够通过我们定义的CRUD操作来操作我们的数据源。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="54b4" class="lt lu jb bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">什么是路由器？</h1><p id="6485" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">路由器负责捕获请求路径，并确定基于该路径运行的逻辑。当在提供给我们的<code class="fe mw mx my mz b">Router</code>对象上调用<code class="fe mw mx my mz b">route</code>方法时，通过注册一个路由来定义请求路径。注册发生在我们的<strong class="kh jc"><em class="ld">favereadsink</em></strong>子类中的<code class="fe mw mx my mz b">setupRouter</code>方法被调用时:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="4f73" class="ni lu jb mz b gy nj nk l nl nm">// lib/fave_reads_sink.dart</span><span id="8014" class="ni lu jb mz b gy nn nk l nl nm">@override<br/>void setupRouter(Router router) {...}</span></pre><p id="5d84" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe mw mx my mz b">setupRouter</code>方法提供了一个路由器对象作为参数，然后我们用它来定义我们的每条路由:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="4cd6" class="ni lu jb mz b gy nj nk l nl nm">@override<br/>void setupRouter(<strong class="mz jc">Router router</strong>) {<br/>  <strong class="mz jc">router.route(’/path-1’)</strong>.listen(...);<br/>  <strong class="mz jc">router.route(’/path-2’)</strong>.listen(...);<br/>  <strong class="mz jc">router.route(’/path-3’)</strong>.listen(...); // and so on<br/>}</span></pre><p id="f784" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">调用route方法接受一个包含路径名的字符串，后跟一个<code class="fe mw mx my mz b">listen</code>方法，该方法允许我们定义向该路径发出请求时运行的逻辑。路由可以包含<em class="ld">路径变量</em>，这些变量是占位符标记，代表路径段中的任何值:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="2b46" class="ni lu jb mz b gy nj nk l nl nm">router.route('/items/<strong class="mz jc">:itemID</strong>');</span></pre><p id="4206" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">上面的例子声明了一个路径变量<code class="fe mw mx my mz b">itemID</code>，匹配“<strong class="kh jc"> /items/0”、“/items/1 </strong>”、“<strong class="kh jc"> /items/foo </strong>”等等。<code class="fe mw mx my mz b">itemID</code>的值将分别为“0”、“1”和“foo”。</p><p id="0ee8" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">路径变量也可以是可选的，因此我们可以这样设置它们:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="dff5" class="ni lu jb mz b gy nj nk l nl nm">router.route('/items/<strong class="mz jc">[</strong>:itemID<strong class="mz jc">]</strong>);</span></pre><p id="bce8" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这意味着路线匹配也将包括“<strong class="kh jc"> /items </strong>”作为路径名。</p><p id="5090" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><em class="ld">关于路由器的文档非常全面，我推荐</em> <a class="ae le" href="https://aqueduct.io/docs/http/routing" rel="noopener ugc nofollow" target="_blank"> <em class="ld">查看</em> </a> <em class="ld">。</em></p><h1 id="b4a4" class="lt lu jb bd lv lw no ly lz ma np mc md me nq mg mh mi nr mk ml mm ns mo mp mq bi translated">那么，我该如何应用呢？</h1><p id="3392" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">有了这些知识，让我们从项目中打开<code class="fe mw mx my mz b">lib/fave_reads_sink.dart</code>,修改<code class="fe mw mx my mz b">setupRouter</code>实现如下:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c41b" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">根路径(/)现在返回HTML内容。我们还定义了一个“<strong class="kh jc"> /books </strong>”路由，它接受一个名为<code class="fe mw mx my mz b">index</code>的可选路径变量。这将是我们CRUD操作的终点。</p><p id="5f56" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">调用route方法会返回一个<code class="fe mw mx my mz b">RouteController</code>，它公开了<code class="fe mw mx my mz b">listen</code>方法，让我们定义要运行的逻辑。还有两种方法我们可以用，分别是<code class="fe mw mx my mz b">pipe</code>和<code class="fe mw mx my mz b">generate</code>。后者允许我们创建一个新的HTTPController对象，该对象可以更好地处理我们的请求(稍后的<em class="ld">将详细介绍</em>)。</p><p id="200d" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe mw mx my mz b">listen</code>方法接受一个闭包，该闭包包含一个代表传入请求的<code class="fe mw mx my mz b">Request</code>对象。然后，我们可以从中提取我们需要的信息，执行转换，并返回响应。</p><p id="d167" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">不管请求动作如何，“<strong class="kh jc"> /books </strong>”的当前逻辑返回相同的响应。让我们修改它，为我们的每个操作返回不同的响应:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8845" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">代码质量很快变得相当糟糕。这是重复的，容易把事情弄得一团糟:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/100b5447686dc299e876da81234ca3b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/1*KyfycnaLaJdnxHsA5rvLyQ.gif"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">通过<a class="ae le" href="https://giphy.com/gifs/spaghetti-IVoBdwlksSq7m" rel="noopener ugc nofollow" target="_blank"> Giphy </a></figcaption></figure><p id="4667" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这可以用<code class="fe mw mx my mz b">HTTPController</code>清理！</p><h1 id="5007" class="lt lu jb bd lv lw no ly lz ma np mc md me nq mg mh mi nr mk ml mm ns mo mp mq bi translated">什么是HTTPController？</h1><p id="44e9" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">HTTPControllers通过将HTTP请求映射到特定的“处理程序方法”来生成响应，从而对HTTP请求做出响应。只要路径匹配，路由器就会向HTTPController发送请求。</p><p id="66c5" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">为了创建一个，我们将创建一个扩展<code class="fe mw mx my mz b">HTTPController</code>的<code class="fe mw mx my mz b">BooksController</code>，以便添加我们想要的行为。我们现在就开始吧。在<code class="fe mw mx my mz b">lib</code>目录下创建<code class="fe mw mx my mz b">controller/books_controller.dart</code>，内容如下:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="58d9" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这是正在发生的事情的总结:</p><ol class=""><li id="359d" class="lf lg jb kh b ki kj km kn kq lh ku li ky lj lc oa ll lm ln bi translated"><code class="fe mw mx my mz b">BooksController</code>子类包含5个handler方法，称为<em class="ld"> responder方法</em> <strong class="kh jc"> <em class="ld">。</em> </strong></li><li id="cb62" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc oa ll lm ln bi translated">每个responder方法都用一个常量来注释，该常量反映了适当的请求方法:<code class="fe mw mx my mz b">@httpGet</code>、<code class="fe mw mx my mz b">@httpPost</code>、<code class="fe mw mx my mz b">@httpPut</code>、<code class="fe mw mx my mz b">@httpDelete</code>。其他方法会用<code class="fe mw mx my mz b">HTTPMethod</code>，像<code class="fe mw mx my mz b">@HTTPMethod('PATCH')</code>。</li><li id="72f2" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc oa ll lm ln bi translated">每个responder方法返回一个类型为<code class="fe mw mx my mz b">Response</code>的<code class="fe mw mx my mz b">Future</code>。未来之于飞镖，犹如承诺之于JavaScript。</li><li id="3317" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc oa ll lm ln bi translated">responder方法可以将请求中的值绑定到它的参数。我们在<code class="fe mw mx my mz b">getBook()</code> responder方法参数中看到了这一点:<code class="fe mw mx my mz b">@HTTPPath("index") int idx</code>。它的path变量被转换成一个整数，并赋给一个名为<code class="fe mw mx my mz b">idx</code>的变量。</li></ol><p id="a474" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">如果没有响应方法与请求方法匹配(<em class="ld">，例如补丁</em>，则返回<code class="fe mw mx my mz b">405 Method Not Allowed</code>响应。</p><p id="5354" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">让我们转到<code class="fe mw mx my mz b">lib/fave_reads_sink.dart</code>并使用该控制器:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="9672" class="ni lu jb mz b gy nj nk l nl nm">import 'fave_reads.dart';<br/><strong class="mz jc">import 'controller/books_controller.dart';<br/></strong>...<br/>...<br/>@override<br/>void setupRouter((Router router) async {<br/>  router<br/>    .route(‘/books/[:index]’)<br/>    .<strong class="mz jc">generate(() =&gt; new BooksController())</strong>; // replaces `listen` method<br/>...</span></pre><p id="fd3d" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">并通过在终端中执行<code class="fe mw mx my mz b">aqueduct serve</code>或<code class="fe mw mx my mz b">dart bin/main.dart</code>来运行我们的项目。</p><p id="8993" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们可以使用<a class="ae le" href="https://www.getpostman.com/apps" rel="noopener ugc nofollow" target="_blank"> <em class="ld"> Postman </em> </a> <em class="ld">来测试我们的响应。</em></p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ob"><img src="../Images/45178fb7505e18351d01580de4162036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*02VNMsIjdYL8y8Fy68rOkQ.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">用邮递员测试POST请求</figcaption></figure><h1 id="b084" class="lt lu jb bd lv lw no ly lz ma np mc md me nq mg mh mi nr mk ml mm ns mo mp mq bi translated">嘲笑我们的数据源</h1><p id="6597" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">对于我们的数据源，让我们在<code class="fe mw mx my mz b">controller/books_controller.dart</code>中创建一个数组:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4976" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">然后，我们将在<code class="fe mw mx my mz b">BooksController</code>中更新我们的responder方法来操作这个数据集:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1954" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae le" href="https://api.dartlang.org/stable/1.24.3/dart-core/List-class.html" rel="noopener ugc nofollow" target="_blank"> <em class="ld">了解Dart的各种数组/列表方法</em> </a>。</p><p id="fc57" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">再次重启服务器并用<a class="ae le" href="https://www.getpostman.com/apps" rel="noopener ugc nofollow" target="_blank"> Postman </a>进行测试。</p><p id="2167" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh jc">请注意:这是在隔离中运行的，这意味着任何副作用只能在Postman的(<em class="ld">或任何工具)</em>会话中看到。打开一个单独的会话(<em class="ld">像浏览器</em>)不会显示这些变化。这是因为设计的隔离不共享状态。不过不要担心——这将在我们实现真正的数据库时得到解决。</strong></p><h1 id="aee3" class="lt lu jb bd lv lw no ly lz ma np mc md me nq mg mh mi nr mk ml mm ns mo mp mq bi translated">重构解决方案</h1><p id="768a" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">我应该已经完成了，但是这将在第3部分给我们带来更多的工作。我不希望这种情况发生，所以请在这最后一段时间里容忍我😊</p><p id="12b8" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">还记得我说过可以将请求中的值绑定到responder方法的参数吗？嗯，我们可以重构POST操作，通过<code class="fe mw mx my mz b">@HTTPBody()</code>元数据将其有效负载转换为地图:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="de2c" class="ni lu jb mz b gy nj nk l nl nm">@httpPost<br/>Future&lt;Response&gt; addSingle(<strong class="mz jc">@HTTPBody() Map book</strong>) async {<br/>  books.add(book);<br/>  return new Response.ok('Added new book.');<br/>}</span></pre><p id="3f4f" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这里，尝试将请求有效负载解析为一个<code class="fe mw mx my mz b">Map</code>类型。我们也可以指定一个自定义类型，而不仅仅是使用内置类型，只要自定义类型扩展了一个<code class="fe mw mx my mz b">HTTPSerializable</code>类型。让我们通过在<code class="fe mw mx my mz b">lib/model/book.dart</code>内部引入一个<code class="fe mw mx my mz b">Book</code>模型来做到这一点:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7170" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">下面是正在发生的事情的总结:</p><ol class=""><li id="9a58" class="lf lg jb kh b ki kj km kn kq lh ku li ky lj lc oa ll lm ln bi translated">我们的<code class="fe mw mx my mz b">Book</code>模型实现了<code class="fe mw mx my mz b">HTTPSerializable</code>，这是一个用于从HTTP请求中解析信息的实用程序</li><li id="79ef" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc oa ll lm ln bi translated">定义<code class="fe mw mx my mz b">asMap</code>和<code class="fe mw mx my mz b">readFromMap(Map requestBody)</code>方法。第一个将在JSON响应被发送回客户机时使用，而后者检索请求体并提取数据以填充模型的属性。</li></ol><p id="bc48" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">现在我们只需要使用这个模型:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6bb4" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">重启服务器，用Postman测试结果。</p><h1 id="b170" class="lt lu jb bd lv lw no ly lz ma np mc md me nq mg mh mi nr mk ml mm ns mo mp mq bi translated">结论</h1><p id="ec79" class="pw-post-body-paragraph kf kg jb kh b ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky mv la lb lc ij bi translated">通过充实web APIs的框架，我们已经取得了一些重大进展。我希望这次旅程到目前为止是一次有趣的挑战。我鼓励你浏览下面的进一步阅读材料，以掌握我们已经讨论过的概念。</p><p id="8754" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">一如既往<strong class="kh jc">我乐于接受反馈</strong>。让我知道你喜欢这个教程的什么，你不喜欢什么，你希望在未来看到什么。我真的很感激。</p><p id="26eb" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">本系列的第2部分到此结束。源代码<a class="ae le" href="https://github.com/graphicbeacon/favereads" rel="noopener ugc nofollow" target="_blank">在github </a>上可用，而<a class="ae le" href="https://medium.com/@98d967ac6f3a/90ff70742675" rel="noopener">第3部分</a>现在也可用。<strong class="kh jc">如果您喜欢这篇文章，请喜欢并关注我</strong>了解更多关于Dart的内容。</p><h1 id="259f" class="lt lu jb bd lv lw no ly lz ma np mc md me nq mg mh mi nr mk ml mm ns mo mp mq bi translated">进一步阅读</h1><ol class=""><li id="74d1" class="lf lg jb kh b ki mr km ms kq oc ku od ky oe lc oa ll lm ln bi translated"><a class="ae le" href="https://aqueduct.io/docs/http/routing/" rel="noopener ugc nofollow" target="_blank">路由和路径变量</a></li><li id="3807" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc oa ll lm ln bi translated"><a class="ae le" href="https://aqueduct.io/docs/http/http_controller/" rel="noopener ugc nofollow" target="_blank">处理请求:HTTPController </a></li></ol></div></div>    
</body>
</html>