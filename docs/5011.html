<html>
<head>
<title>Javascript sliders will kill your website performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript滑块会扼杀你的网站性能</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-sliders-will-kill-your-website-performance-5e4925570e2b?source=collection_archive---------0-----------------------#2020-11-16">https://itnext.io/javascript-sliders-will-kill-your-website-performance-5e4925570e2b?source=collection_archive---------0-----------------------#2020-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1e57f4a3f0cea8810a21b9f64dd3e9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zhNjsyY9Uo8Z88Ukw2p6Xg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由Vincentas Liskauskas拍摄</figcaption></figure><p id="aeec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">滑块(或旋转木马)是目前几乎所有网站中最常见的元素，不管你对它们的感觉如何，它们都可以提供一种便捷的方式来显示信息，尤其是在屏幕尺寸有限的情况下。</p><p id="c2d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在电子商务网站中，用例的范围从展示特色产品、横幅、促销、产品图库，应有尽有！这些坏男孩在野外并不缺乏，尽管他们的有效性有点争议，这是用户习惯看到的事情之一，所以它为大多数人提供了低摩擦的体验。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/c17ef3f935395553643925212767daf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Tcw9CRZwqd6KCKC7WpY5ng.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用滑块在asos.com<a class="ae la" href="https://www.asos.com/" rel="noopener ugc nofollow" target="_blank">和</a>输入样式</figcaption></figure><p id="8d71" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">幸运的是，对于我们这些前端开发人员来说，有数百个基于Javascript的滑块可供选择，不幸的是，它们中的大多数都有相同的缺点:<strong class="ke ir">它们的性能很差</strong>，请相信我，因为我已经使用了所有的滑块，每一个都是。</p><h1 id="2beb" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">他们不可能都那么坏！</h1><p id="f563" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">是时候运行一些测试了，让我们创建一个非常简单的slider实现来显示产品图片列表，几乎每个电子商务商店都有这样或那样的形式，所以尽管外观会有所不同，但作为一个例子来使用还是很常见的。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/faddf3870a8116c35c5b26e2578cc138.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*0zuoYecylTeM2OKZVoPKrw.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">超级简单的产品图库滑块</figcaption></figure><p id="83df" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如你所看到的，它非常简单，一次只有一张幻灯片，没有箭头，没有导航指示器或任何花哨的东西。我所做的只是显示下一张或上一张图片的一部分，向用户提供一些反馈，让他们知道他们可以左右滑动来查看更多内容。</p><h1 id="4e4c" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">顶级竞争者</h1><p id="71f1" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">我不想花时间测试每一个javascript滑块，所以我选择了这些年来最适合我的5个:</p><ol class=""><li id="e529" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz mp mq mr ms bi translated"><a class="ae la" href="https://kenwheeler.github.io/slick/" rel="noopener ugc nofollow" target="_blank">光滑的滑块</a></li><li id="fd7b" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz mp mq mr ms bi translated"><a class="ae la" href="https://owlcarousel2.github.io/OwlCarousel2/" rel="noopener ugc nofollow" target="_blank">猫头鹰旋转木马</a></li><li id="9c6c" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz mp mq mr ms bi translated"><a class="ae la" href="https://flickity.metafizzy.co/" rel="noopener ugc nofollow" target="_blank">轻飘飘</a></li><li id="196f" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz mp mq mr ms bi translated"><a class="ae la" href="https://keen-slider.io/" rel="noopener ugc nofollow" target="_blank"> Keen-slider </a></li><li id="afaa" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz mp mq mr ms bi translated"><a class="ae la" href="https://nickpiscitelli.github.io/Glider.js/" rel="noopener ugc nofollow" target="_blank"> Glider.js </a></li></ol><p id="5fbb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所有这些滑块都有一些重要的共同点，它们提供了最基本的CSS样式来使它们工作，除此之外的任何定制都取决于你。这对我来说是一个关键的特性，因为我倾向于大量定制滑块，所以我必须覆盖的越少越好，你也不希望在你的滑块需要的额外的JS之上包含一堆CSS。</p><p id="81e0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我不会深入讨论很多实现细节，但是如果你想了解更多，请随意查看每个库的文档，它们都很不错。</p><h1 id="2128" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">光滑的</h1><p id="5e1b" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">当谈到在web上实现功能丰富的滑块时，Slick是我的首选，它几乎拥有世界上的所有功能，一个非常简单的API和动画非常流畅，因为它支持开箱即用的CSS转换，所以让我们尝试一下。</p><p id="5fd3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要做的就是用一个<code class="fe mz na nb nc b">script</code>标签包含这个库，所需的CSS，并像这样初始化它:</p><pre class="lc ld le lf gt nd nc ne nf aw ng bi"><span id="e6a6" class="nh lh iq nc b gy ni nj l nk nl">$(function () {<br/>    $('.js-slider').slick({<br/>        centerMode: true,<br/>        centerPadding: '15px',<br/>        arrows: false,<br/>        infinite: false,<br/>    });<br/>})</span></pre><p id="bd03" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">再简单不过了，让我们看看我们的资源是什么样的:</p><ul class=""><li id="64bd" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz nm mq mr ms bi translated"><strong class="ke ir"> JS </strong> : 126 Kb</li><li id="0703" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir"> CSS </strong> : 4.9 Kb</li></ul><p id="0fc2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">马上我们可以看到一个最大的缺点，slick本身就很大(<strong class="ke ir"> 42.4 kb </strong> minified)，但我们还需要jQuery。除此之外，如果你已经在使用jQuery，这不是一个大问题，但库本身的大小是需要考虑的。</p><p id="08f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">核心网络重要指标呢？为此，我将在模拟的<strong class="ke ir">快速3G </strong>连接上进行测试，并使用<strong class="ke ir"> 4x CPU减速</strong>进行所有测试:</p><ul class=""><li id="e34a" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz nm mq mr ms bi translated"><strong class="ke ir">总阻塞时间(TBT)</strong>:0毫秒</li><li id="51dc" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">第一幅内容丰富的画(FCP) </strong> : 1989ms</li><li id="944d" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">最大含量油漆(LCP)</strong>:2789毫秒</li><li id="490c" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">内容布局偏移(CLS) </strong> : 0.1344</li><li id="6a82" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">互动时间(TTI)</strong>:2939毫秒</li></ul><p id="cbfc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们的测试中，我们可以立即看到所有这些JS的影响，在屏幕上看到任何有意义的东西几乎需要<strong class="ke ir"> 2秒</strong>和几乎<strong class="ke ir"> 3秒</strong>才能交互。滑块加载时，布局也会发生一些变化:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/19b756d383f9225935829549d8a9c519.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*6ApOC_G4Nr2R6RqqLfDHQg.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">滑动滑块布局偏移</figcaption></figure><p id="66e4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">只用几行CSS就可以很容易地解决这个问题，我们只需要确保我们的图像在脚本被解析和执行之前和之后具有相同的样式，在这种情况下，只需要做以下事情:</p><pre class="lc ld le lf gt nd nc ne nf aw ng bi"><span id="ce39" class="nh lh iq nc b gy ni nj l nk nl">.gallery &gt; .slide:not(:first-child) {<br/>    display: none;<br/>}</span><span id="6025" class="nh lh iq nc b gy nn nj l nk nl">.gallery &gt; .slide:first-child {<br/>    padding: 0 20px;<br/>}</span></pre><p id="0c7a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这样，我们隐藏了除了第一张幻灯片之外的所有内容，并在Slick加载后添加填充。Slick将向我们的幻灯片添加额外的包装元素，因此直接子选择器(&gt;)将使样式仅在加载之前应用。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/c75d2ab8d731134afe35e6e062e524d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*TxiY1RUXYwhmVK-qCo9d5w.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">改进CLS的光滑滑块</figcaption></figure><p id="5895" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很好，没有布局变化，通过隐藏额外的幻灯片，浏览器将为这些图像分配较低的优先级，这将提高我们的<strong class="ke ir"> FCP </strong>指标:</p><ul class=""><li id="9508" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz nm mq mr ms bi translated"><strong class="ke ir">总阻塞时间(TBT)</strong>:0毫秒</li><li id="ab67" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">第一幅令人满意的画(FCP)</strong>:1356毫秒<em class="my">(下降31)</em></li><li id="3b71" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">最大含量涂料(LCP)</strong>:2568毫秒<em class="my">(下降8)</em></li><li id="4c1b" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">内容布局移位(CLS) </strong> : 0 <em class="my">(减少100)</em></li><li id="4627" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">互动时间(TTI)</strong>:2746毫秒<em class="my">(减少6%)</em></li></ul><p id="8de2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些都是非常好的改进，但当你运行谷歌灯塔时，它们看起来并不那么好:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/d5d11d656ba6e73b455e904968800ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNFmpCaYx3xlMUnqEaQziA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用Slick的谷歌灯塔评分</figcaption></figure><blockquote class="np nq nr"><p id="a260" class="kc kd my ke b kf kg kh ki kj kk kl km ns ko kp kq nt ks kt ku nu kw kx ky kz ij bi translated">所有需要做的就是<strong class="ke ir"> jQuery </strong>和<strong class="ke ir"> Slick </strong>在一个几乎没有任何HTML或CSS的超级基础页面上将<strong class="ke ir">的分数降低9分</strong>。</p></blockquote><p id="47d5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">想想看，大多数网站(特别是电子商务网站)都有比这多得多的东西，所以当你正确看待它时，你会开始意识到如果不减少一些脂肪，就没有机会达到那个甜蜜的分数<strong class="ke ir"> 100 </strong>。</p><p id="8c57" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是为什么！？你可能会问，让我们分析一下我们的页面负载，看看它看起来怎么样:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/b12974c217315510e48727d67cf62187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nyxOV2Pv-BP1fUwjJkW9A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">光滑页面加载性能配置文件</figcaption></figure><p id="920c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Chrome DevTools profiler可能很吓人，但通常你关心的是行应该短，堆栈跟踪应该浅，较长的行意味着任务花费太长时间，较深的堆栈跟踪意味着函数不断调用其他函数，这会使任务变慢。请记住，在他们开始对我们大喊大叫之前，谷歌只给我们每项任务最多100毫秒的时间，所以我们需要充分利用这一点。</p><p id="0bd9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还看到在<strong class="ke ir">编写</strong> (JS执行/黄色)和<strong class="ke ir">布局</strong>(在屏幕上放置东西/紫色)上花费了大量时间，很可能是因为Slick需要运行大量计算来知道在屏幕上哪里放置幻灯片以及如何排列它们。</p><p id="f8d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们继续。</p><h1 id="38fe" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">猫头鹰旋转木马</h1><p id="6007" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">另一个广受欢迎的项目，Owl Carousel有着和Slick相似的特性，但是它有点小，这对于网络性能来说是一件好事，所以让我们来看看。</p><p id="3518" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和之前一样，我们只需要添加一些CSS，JS <code class="fe mz na nb nc b">script</code>标签，然后像这样初始化它:</p><pre class="lc ld le lf gt nd nc ne nf aw ng bi"><span id="99e4" class="nh lh iq nc b gy ni nj l nk nl">$(function () {<br/>    $('.js-slider').owlCarousel({<br/>        center: true,<br/>        stagePadding: 15<br/>    });<br/>});</span></pre><p id="7b49" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还需要在HTML中添加一些类，除非我们自定义初始化选项。现在让我们检查一下我们的主要资源:</p><ul class=""><li id="2bf6" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz nm mq mr ms bi translated"><strong class="ke ir"> JS </strong> : 117 Kb <em class="my">(减少7)</em></li><li id="b380" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir"> CSS </strong> : 6.8 Kb <em class="my">(增加38%)</em></li></ul><p id="d929" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，与Slick相比，我们的JS更少，但CSS更多，这可能看起来像一个糟糕的交易，但请记住，不是所有的字节都被平等对待，脚本的<a class="ae la" href="https://v8.dev/blog/cost-of-javascript-2019" rel="noopener ugc nofollow" target="_blank">成本比浏览器的任何其他资源都更重要</a>，因此在许多情况下，以样式或图像为代价减少javascript将产生更好的性能结果，如下所示:</p><ul class=""><li id="4e12" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz nm mq mr ms bi translated"><strong class="ke ir">总阻塞时间(TBT)</strong>:0毫秒</li><li id="f43f" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">第一个满意的油漆(FCP)</strong>:1324毫秒<em class="my">(下降33%)</em></li><li id="b755" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">最大含量涂料(LCP)</strong>:2545毫秒<em class="my">(下降8)</em></li><li id="801e" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">内容布局偏移(CLS) </strong> : 0.1295 <em class="my">(减少3%)</em></li><li id="5fb5" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">互动时间(TTI)</strong>:2376毫秒<em class="my">(减少19%)</em></li></ul><p id="3a9c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些结果比Slick的第一次实现要好，但我们仍然有一些布局偏移问题:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/d43564ffeb24d0b43bf70a0e55ee21ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*VHNOWMkwhQm5wEu3GSbjUw.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Owl旋转木马布局移位</figcaption></figure><p id="4d44" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">出于某种原因，Owl Carousel决定完全隐藏滑块，直到它完成加载。就像我们之前需要的那样，我们只需要几行CSS就可以解决这个问题，我们最终可以获得更好的结果:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/e9f6cdd2c7ccfecb42cc5e0570d1d36e.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*CKcNvXSkW-eD1LCYT_uCfw.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">改进CLS的猫头鹰转盘</figcaption></figure><p id="595b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们再次看看我们的指标:</p><ul class=""><li id="adaf" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz nm mq mr ms bi translated"><strong class="ke ir">总阻塞时间(TBT)</strong>:0毫秒</li><li id="a02c" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">第一个内容丰富的油漆(FCP)</strong>:1330毫秒<em class="my">(减少2%)</em></li><li id="a752" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">最大含量涂料(LCP) </strong> : 2396ms <em class="my">(下降6)</em></li><li id="9772" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">内容布局移位(CLS) </strong> : 0</li><li id="3979" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">互动时间(TTI)</strong>:2357毫秒<em class="my">(减少14%)</em></li></ul><p id="0a0c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">比起我们改进了的<strong class="ke ir"> CLS </strong>滑溜溜的版本要好得多，特别是当涉及到<strong class="ke ir"> TTI </strong>的时候。性能报告与Slick的非常相似，因此这里没有什么新内容。</p><h1 id="12b5" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">轻佻</h1><p id="e042" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">Flickity和Owl Carousel都有非常相似的结果，在我的测试中，这些指标只是略有不同，所以我认为不值得深入讨论。</p><p id="5077" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">继续前进…</p><h1 id="bcab" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">敏锐滑块</h1><p id="8457" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">Keen Slider是网络上最受欢迎的滑块的更新替代产品，它没有提供大量的功能，但它非常轻量级，没有依赖性，这使它非常适合我们简单的产品图库传送带。</p><p id="9770" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看它在资源方面是如何比较的:</p><ul class=""><li id="e7e3" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz nm mq mr ms bi translated"><strong class="ke ir"> JS </strong> : 10.3 Kb <em class="my">(减少91%)</em></li><li id="ab22" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir"> CSS </strong> : 3.7 Kb <em class="my">(减少24%)</em></li></ul><p id="3d8d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这只是Owl Carousel的JS的十分之一，Slick的CSS的四分之三。</p><ul class=""><li id="0467" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz nm mq mr ms bi translated"><strong class="ke ir">总阻塞时间(TBT)</strong>:0毫秒</li><li id="04ef" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">第一次内容丰富的绘画(FCP)</strong>:1275毫秒<em class="my">(减少3%)</em></li><li id="3a57" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">最大含量涂料(LCP)</strong>:1667毫秒<em class="my">(下降34)</em></li><li id="46e6" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">内容布局偏移(CLS) </strong> : 0.2456 <em class="my">(增加89%)</em></li><li id="b4ec" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">互动时间(TTI)</strong>:1740毫秒<em class="my">(减少26%)</em></li></ul><p id="fde1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">考虑到最终结果几乎相同，这是相当显著的改进:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/07f170e4b05320e2a61faa8adf101fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*MIYGrM6Jjcd4fj13z60Cig.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">敏锐的滑块布局变化</figcaption></figure><p id="4c03" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">像我们的其他例子一样，我们也有一些布局上的变化，但是用一些CSS修改起来非常简单，最终结果甚至更好:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/8dfcf854921d70ee357fe336b0565792.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*wgXdrQBdmrPRHF5Hp_kAuw.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">具有改进的CLS的敏锐滑块</figcaption></figure><p id="21a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这次改变后，大多数指标都是一样的，但是没有任何布局变化，我们最终实现了可接受的用户体验。</p><p id="a164" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以在页面负载上运行一个快速配置文件，以查看性能提升来自哪里，下面是我们运行时间最长的任务(初始化滑块)的摘要:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/981bc87fc259abd3d60e2448aea954fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ui-5v2fXDoj5Ec6AeRScyA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Keen Slider页面加载性能配置文件</figcaption></figure><p id="6f54" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如你所看到的，几乎没有什么工作要做，大部分时间都花在了<strong class="ke ir">编写脚本</strong>上，几乎没有什么<strong class="ke ir">布局</strong>工作。</p><blockquote class="nw"><p id="f9c8" class="nx ny iq bd nz oa ob oc od oe of kz dk translated">Keen Slider需要2.73毫秒来渲染我们的滑块，相比之下Slick需要<strong class="ak">125.23毫秒</strong>来做同样的事情。</p></blockquote><h1 id="07d1" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr og lt lu lv oh lx ly lz oi mb mc md bi translated"><strong class="ak"> Glider.js </strong></h1><p id="357d" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">到目前为止，Glider采用了一种非常不同的方法，它仍然是一个非常轻量级的库，但它的主要区别在于使用CSS滚动行为而不是CSS变换来制作幻灯片过渡动画。你可以把它想象成一个带有<code class="fe mz na nb nc b">overflow: auto</code>的<code class="fe mz na nb nc b">div</code>,上面还撒了一些JS，以允许箭头、导航和其他常见的滑块功能。</p><p id="7cdb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正因为如此，它提供的选项甚至比Keen Slider还要少，所以你不能做任何花哨的自动滚动、无限幻灯片、自定义放松等等，这让我想知道:<strong class="ke ir">如果我们只用CSS实现gallery slider并完全去掉JS会怎么样？</strong></p><h1 id="1437" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">纯CSS方法</h1><p id="1ac6" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">到目前为止，我们已经使用Javascript来呈现我们简单的产品图片库，如果我们愿意做出一些让步，我们可以将脚本减少到零。</p><p id="81bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以使用几个CSS特性，使构建我们的滑块变得轻而易举:<strong class="ke ir"> CSS Grid </strong>处理布局，<strong class="ke ir"> CSS Scroll Snap </strong>控制滚动体验。</p><p id="94de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">令人惊讶的是，只需要下面几行CSS代码就可以实现几乎与JS相同的结果:</p><pre class="lc ld le lf gt nd nc ne nf aw ng bi"><span id="4b0d" class="nh lh iq nc b gy ni nj l nk nl">.gallery {<br/>    display: grid;<br/>    grid-gap: 10px;<br/>    grid-auto-flow: column;<br/>    grid-auto-columns: calc(100% - 20px);<br/>    padding-left: 20px;<br/>    scroll-snap-type: x mandatory;<br/>    overflow: auto;<br/>}</span><span id="3748" class="nh lh iq nc b gy nn nj l nk nl">.slide {<br/>    scroll-snap-align: center;<br/>}</span><span id="e0a3" class="nh lh iq nc b gy nn nj l nk nl">.slide:last-child {<br/>    position: relative;<br/>}</span><span id="4eb8" class="nh lh iq nc b gy nn nj l nk nl">.slide:last-child::after {<br/>    content: '';<br/>    position: absolute;<br/>    top: 0;<br/>    width: 20px;<br/>    height: 100%;<br/>}</span></pre><p id="3e5e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<strong class="ke ir"> CSS网格</strong>我们可以将我们的图像定位在一行中，并调整它们的大小，以便部分显示下一个和上一个图像，使用<code class="fe mz na nb nc b">overflow: auto</code>我们可以实现水平滚动，使用<strong class="ke ir"> CSS滚动捕捉</strong>我们可以控制图像捕捉到中心，以便始终可以看到完整的图像。</p><p id="16a4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mz na nb nc b">:last-child</code>的技巧是在滑块的末端留出一些空间，因为即使有额外的填充，浏览器也不会在滚动容器的末端增加额外的滚动空间，这样可以防止图像到达屏幕边缘。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/a852705f73cb6dd1e69fc08c0cb1b936.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*im7dqbY1IWj59yWmswyV2g.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">仅CSS画廊滑块</figcaption></figure><p id="6141" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最终结果与我们想要的非常相似，只是有一些小缺点:</p><ul class=""><li id="02b7" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz nm mq mr ms bi translated">水平滚动条:你可以用CSS隐藏它，但我不介意，因为它提供了一种非侵入式的额外反馈。</li><li id="f099" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">当试图滚动到最后一张幻灯片的末尾时，没有“橡皮筋”效应:</strong>我愿意过没有它的生活。</li></ul><p id="9118" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">除此之外，你还可以获得一些额外的<strong class="ke ir">辅助功能</strong>不费吹灰之力，一些JS滑块就能提供一定程度的键盘导航，但以我的经验来看，它远没有这个好:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/0cf0bdf48b3bf2b214a2ed57710e6ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/1*XYf4x6oOR4rQqcifIQ-npw.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">仅CSS画廊键盘导航</figcaption></figure><p id="7e91" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，最终的性能指标要比基于JS的同类产品好得多:</p><ul class=""><li id="e958" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz nm mq mr ms bi translated"><strong class="ke ir"> JS </strong> : 0 Kb <em class="my"> (100%减少)</em></li><li id="5d56" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir"> CSS </strong> : 3.5 Kb <em class="my">(减少5%)</em></li><li id="3a71" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">总阻塞时间(TBT)</strong>:0毫秒</li><li id="59c1" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">第一幅内容丰富的画(FCP)</strong>:1284毫秒</li><li id="fb61" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">最大含量涂料(LCP)</strong>:1380毫秒<em class="my">(下降17)</em></li><li id="461b" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">内容布局移位(CLS) </strong> : 0</li><li id="72b1" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz nm mq mr ms bi translated"><strong class="ke ir">互动时间(TTI)</strong>:1358毫秒<em class="my">(减少22%)</em></li></ul><p id="5d0f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里有趣的是，在屏幕上呈现内容所花费的时间保持一致，但是一旦我们的第一个图像加载完毕，页面就完全交互了。无需等待下载、解析和执行昂贵的JS计算，我们终于可以对难以捉摸的分数<strong class="ke ir"> 100打招呼了。</strong></p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/56a062b05790b52d99b2046cb828ed10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZF_cOaVGGWO8L62jDmuT_Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">带有仅CSS滑块的Lighthouse乐谱</figcaption></figure><p id="6231" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想玩玩代码，这里有一个Codepen中的工作示例:<a class="ae la" href="https://codepen.io/javiervd/pen/qBNgPjN" rel="noopener ugc nofollow" target="_blank">https://codepen.io/javiervd/pen/qBNgPjN</a>👨🏾‍💻</p><h1 id="2b3d" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">摘要</h1><p id="313a" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">重要的是要知道，这是一个非常简单的滑块实现，如果你需要更多的功能，这显然是不够的，但这个练习的主要收获是问自己:</p><ol class=""><li id="6a62" class="mk ml iq ke b kf kg kj kk kn mm kr mn kv mo kz mp mq mr ms bi translated">你真的需要滑盖吗？如果没有，你可以节省额外的代码，用不同的方式显示你的内容(例如:网格、区块等)</li><li id="5411" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz mp mq mr ms bi translated">如果你这样做了，你能只使用CSS吗？你真的需要那个滑块每5秒自动滚动一次吗？(很烦BTW)</li><li id="2e50" class="mk ml iq ke b kf mt kj mu kn mv kr mw kv mx kz mp mq mr ms bi translated"><strong class="ke ir">如果没有，可以用keen slider或者Glider.js吗？</strong>它们会让你走得更远，而不会对性能造成巨大影响。</li></ol><p id="18f6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">滑块可以很棒，但是不值得在它们上面浪费你的性能预算，特别是当它可以用来取代像状态管理器或前端框架这样的库的时候。</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="0d47" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">[1]:我可能没有使用所有的JS滑块。</p></div></div>    
</body>
</html>