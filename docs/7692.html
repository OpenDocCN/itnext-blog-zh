<html>
<head>
<title>Creating Pac-Man clone in Python in 300 lines of code or less— Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用300行或更少的代码用Python创建Pac-Man克隆——第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-pac-man-in-python-in-300-lines-of-code-or-less-part-1-288d54baf939?source=collection_archive---------0-----------------------#2022-12-21">https://itnext.io/how-to-create-pac-man-in-python-in-300-lines-of-code-or-less-part-1-288d54baf939?source=collection_archive---------0-----------------------#2022-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7f91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">《吃豆人》是一款经典的平台游戏，大概今天大家都知道了。“吃豆人”这个名字来自日语单词“paku”，意思是张开和闭上嘴巴。创作者岩谷彻的灵感来自日本的一个故事，讲的是一种通过吃掉怪物来保护儿童免受怪物伤害的生物。在创作游戏时，他用故事中的关键词作为跳板，动词“吃”成为一切的基础。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ea48270afc1fecebb2a2aaa99bf9a5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X4-h-kLai3CPmzXs"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">到这篇文章结束时，你将已经和我一起创造了这个！</figcaption></figure><p id="7299" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些怪物被描绘成四个幽灵，它们连续攻击玩家，类似于太空入侵者。每个鬼魂也有独特的个性。在这个故事中，还有一个更重要的元素，生命力的概念“kokoro”，它允许生物吃怪物。在游戏中，这种能量表现为给吃豆人提供短期吃掉怪物的能力的能量饼干。</p><p id="c744" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在教程中，我将首先指导您完成基本设置，然后我们将为迷宫墙、Pac-Man和幽灵创建游戏对象，确保在迷宫中寻路，给幽灵随机移动，为玩家实现箭头控制，最后，在整个迷宫中放置饼干形式的食物。为了更好地表现，我会用图片和gif来说明一切。</p><h1 id="bf04" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">&gt;&gt;基本_设置</h1><p id="71e1" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">最终的游戏大约有300行代码，所以我在这里只列出最重要的部分。完整的代码可以在我的GitHub库上找到<a class="ae mh" href="https://github.com/janjilecek/pacman_python_pygame/blob/main/pacman.py" rel="noopener ugc nofollow" target="_blank">。第一步是安装必要的软件包。我们需要pygame，numpy和tcod。使用pip工具安装它们(您可以在关于Python应用程序的文章中找到如何安装)。如果您使用的是PyCharm之类的IDE(我推荐)，安装将在点击缺失包错误消息后发生。</a></p><p id="4dee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们将创建一个游戏窗口，类似于之前关于太空入侵者游戏(只有100行)的<a class="ae mh" href="https://medium.com/itnext/creating-space-invaders-clone-in-pygame-ea0f5336c677" rel="noopener">教程。在这里，我将准备用于指定窗口大小、游戏名称、刷新率和几个数据字段的参数，这些数据字段将保存对游戏对象和玩家的引用。tick函数迭代遍历所有游戏对象，并调用它们的内部逻辑和渲染。接下来要做的就是重新绘制整个游戏区域，并处理鼠标点击和键盘输入等输入事件。_handle_events函数将为此目的服务。</a></p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="43dc" class="mn lf it mj b be mo mp l mq mr">import pygame # import packages (install with "pip install pygame" in cmd)<br/>import numpy as np<br/>import tcod<br/><br/>class GameRenderer:<br/>    def __init__(self, in_width: int, in_height: int):<br/>        pygame.init()<br/>        self._width = in_width<br/>        self._height = in_height<br/>        self._screen = pygame.display.set_mode((in_width, in_height))<br/>        pygame.display.set_caption('Pacman')<br/>        self._clock = pygame.time.Clock()<br/>        self._done = False<br/>        self._game_objects = []<br/>        self._walls = []<br/>        self._cookies = []<br/>        self._hero: Hero = None<br/><br/>    def tick(self, in_fps: int):<br/>        black = (0, 0, 0)<br/>        while not self._done:<br/>            for game_object in self._game_objects:<br/>                game_object.tick()<br/>                game_object.draw()<br/><br/>            pygame.display.flip()<br/>            self._clock.tick(in_fps)<br/>            self._screen.fill(black)<br/>            self._handle_events()<br/>         print("Game over")<br/><br/>    def add_game_object(self, obj: GameObject):<br/>        self._game_objects.append(obj)<br/><br/><br/>    def add_wall(self, obj: Wall):<br/>        self.add_game_object(obj)<br/>        self._walls.append(obj)<br/><br/>    def _handle_events(self):<br/>        pass # we'll implement this later</span></pre><h1 id="0656" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">&gt;&gt;父母_游戏_对象</h1><p id="be04" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">接下来，我将创建一个名为game object的父游戏对象，其他类将从它继承功能。在游戏中，我们将有墙(墙)、吃豆人(英雄)、鬼(幽灵)和饼干(饼干)的对象。对于上面提到的可移动游戏实体，我稍后会创建一个名为MovableObject的类，它将是GameObject类的扩展，具有移动功能。</p><p id="20d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在对象初始化期间，我指定了它的颜色、形状和位置。每个对象还有一个对渲染surface _surface的引用，这样它就可以在主表面上处理自己的渲染。为此，我们有一个名为draw的函数，由之前创建的GameRenderer为每个游戏对象调用。根据is_circle参数的不同，对象要么呈现为圆形，要么呈现为矩形(在我们的例子中，我使用了一个带有略微圆角的正方形作为墙壁，一个圆形作为Pac-Man和cookies)。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="fa84" class="mn lf it mj b be mo mp l mq mr">class GameObject:<br/>    def __init__(self, in_surface, x, y,<br/>                 in_size: int, in_color=(255, 0, 0),<br/>                 is_circle: bool = False):<br/>        self._size = in_size<br/>        self._renderer: GameRenderer = in_surface<br/>        self._surface = in_surface._screen<br/>        self.y = y<br/>        self.x = x<br/>        self._color = in_color<br/>        self._circle = is_circle<br/>        self._shape = pygame.Rect(self.x, self.y, in_size, in_size)<br/><br/>    def draw(self):<br/>        if self._circle:<br/>            pygame.draw.circle(self._surface,<br/>                               self._color,<br/>                               (self.x, self.y),<br/>                               self._size)<br/>        else:<br/>            rect_object = pygame.Rect(self.x, self.y, self._size, self._size)<br/>            pygame.draw.rect(self._surface,<br/>                             self._color,<br/>                             rect_object,<br/>                             border_radius=4)<br/><br/>    def tick(self):<br/>        pass</span></pre><p id="76a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建wall类很简单。我根据最初的Pac-Man为墙壁选择了蓝色(颜色参数—蓝色255，其余为0)。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="ae4c" class="mn lf it mj b be mo mp l mq mr">class Wall(GameObject):<br/>    def __init__(self, in_surface, x, y, in_size: int, in_color=(0, 0, 255)):<br/>        super().__init__(in_surface, x * in_size, y * in_size, in_size, in_color)</span></pre><p id="07f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">准备用于渲染的代码和用于墙壁的对象。编写时，确保Wall和GameObject类在GameRenderer类之上，以便该类“看到”它们。下一步是在屏幕上渲染迷宫。但在此之前，我们必须创建一个助手类。</p><h1 id="c4ca" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">&gt;&gt;游戏_控制器_类</h1><p id="b241" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我将用ASCII字符将迷宫保存在新的PacmanGameController类的变量中。我将使用原始的迷宫尺寸——28x 31的瓷砖。稍后，我将不得不确保幽灵们能够正确地找到通过迷宫的路，并有可能找到玩家。首先我会把迷宫读成字符，转换成1和0的矩阵，其中墙是0，可通行空间是1。这些值作为所谓的成本函数服务于寻路算法。零表示通行成本无限大，因此数组中以这种方式标记的项目将被视为不可通行。注意reachable_spaces数组，它保存了迷宫中可以通过的部分。稍后我会详细介绍，首先我要准备类结构。可以从<a class="ae mh" href="https://github.com/janjilecek/pacman_python_pygame/blob/main/pacman.py" rel="noopener ugc nofollow" target="_blank"> my GitHub </a>中复制ASCII形式的迷宫。在人物符号中，我用“X”代表墙，“P”代表吃豆人，“G”代表幽灵。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="9649" class="mn lf it mj b be mo mp l mq mr">class PacmanGameController:<br/>    def __init__(self):<br/>        self.ascii_maze = [<br/>            "XXXXXXXXXXXXXXXXXXXXXXXXXXXX",<br/>            "XP           XX            X",<br/>            "X XXXX XXXXX XX XXXXX XXXX X",<br/>            "X XXXX XXXXX XX XXXXX XXXX X",<br/>            "X XXXX XXXXX XX XXXXX XXXX X",<br/>            "X                          X",<br/>            "X XXXX XX XXXXXXXX XX XXXX X",<br/>            "X XXXX XX XXXXXXXX XX XXXX X",<br/>            "X      XX    XX    XX      X",<br/>            "XXXXXX XXXXX XX XXXXX XXXXXX",<br/>            "XXXXXX XXXXX XX XXXXX XXXXXX",<br/>            "XXXXXX XX          XX XXXXXX",<br/>            "XXXXXX XX XXXXXXXX XX XXXXXX",<br/>            "XXXXXX XX X   G  X XX XXXXXX",<br/>            "          X G    X          ",<br/>            "XXXXXX XX X   G  X XX XXXXXX",<br/>            # shortened for article, full ascii on my github<br/>            "XXXXXXXXXXXXXXXXXXXXXXXXXXXX",<br/>        ]<br/><br/>        self.numpy_maze = []<br/>        self.cookie_spaces = []<br/>        self.reachable_spaces = []<br/>        self.ghost_spawns = []<br/><br/>        self.size = (0, 0)<br/>        self.convert_maze_to_numpy()<br/>        #self.p = Pathfinder(self.numpy_maze) # use later<br/><br/><br/>    def convert_maze_to_numpy(self):<br/>        for x, row in enumerate(self.ascii_maze):<br/>            self.size = (len(row), x + 1)<br/>            binary_row = []<br/>            for y, column in enumerate(row):<br/>                if column == "G":<br/>                    self.ghost_spawns.append((y, x))<br/><br/>                if column == "X":<br/>                    binary_row.append(0)<br/>                else:<br/>                    binary_row.append(1)<br/>                    self.cookie_spaces.append((y, x))<br/>                    self.reachable_spaces.append((y, x))<br/>            self.numpy_maze.append(binary_row)</span></pre><h1 id="54f4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">&gt;&gt;渲染_迷宫_迷宫</h1><p id="1597" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">渲染迷宫所需的一切都准备好了，所以剩下的就是创建我们的PacmanGameController类的实例，遍历具有墙位置的2D数组，并在这些位置创建一个墙对象(我使用的是add_wall函数，这里没有显示，同样，看看我的GitHub 上的完整代码<a class="ae mh" href="https://github.com/janjilecek/pacman_python_pygame/blob/main/pacman.py" rel="noopener ugc nofollow" target="_blank">)。我把刷新率设为每秒120帧。</a></p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="f627" class="mn lf it mj b be mo mp l mq mr">if __name__ == "__main__":<br/>    unified_size = 32<br/>    pacman_game = PacmanGameController()<br/>    size = pacman_game.size<br/>    game_renderer = GameRenderer(size[0] * unified_size, size[1] * unified_size)<br/><br/>    for y, row in enumerate(pacman_game.numpy_maze):<br/>        for x, column in enumerate(row):<br/>            if column == 0:<br/>                game_renderer.add_wall(Wall(game_renderer, x, y, unified_size))<br/><br/>    game_renderer.tick(120)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ms"><img src="../Images/a082c86266c88b8a63e017dd9c2af07d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NmgBOZXd-lhlD3FQ"/></div></div></figure><h1 id="968e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">&gt;&gt;来_加_鬼吧！</h1><p id="6eae" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">在最初的《吃豆人》中，有四个幽灵，分别叫布林基、平基、因基和克莱德，他们都有自己的个性和能力。这个游戏的概念是基于一个日本童话(更多的<a class="ae mh" href="https://www.gamedeveloper.com/design/the-pac-man-dossier" rel="noopener ugc nofollow" target="_blank">在这里</a>和<a class="ae mh" href="https://gameinternals.com/understanding-pac-man-ghost-behavior" rel="noopener ugc nofollow" target="_blank">在这里</a>)和日文中的原始名称也暗示了他们的能力(例如，Pinky有日文名称小偷，Blinky是影子)。然而，对于我们的游戏，我们不会进入这样的细节，每个幽灵将只使用原始版本中的基本行为循环，即追逐，分散和恐惧模式。我们将在第二部分描述和处理这些人工智能模式。</p><p id="9958" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ghost类将是简单的，从父MovableObject类继承其大部分行为(查看my <a class="ae mh" href="https://github.com/janjilecek/pacman_python_pygame/blob/main/pacman.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>，该类稍微复杂一些，包括向四个方向移动的逻辑，遵循一条路线，并检查与墙壁的碰撞)。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="5c7f" class="mn lf it mj b be mo mp l mq mr">class Ghost(MovableObject):<br/>    def __init__(self, in_surface, x, y, in_size: int, in_game_controller, in_color=(255, 0, 0)):<br/>        super().__init__(in_surface, x, y, in_size, in_color, False)<br/>        self.game_controller = in_game_controller</span></pre><p id="fa9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将把每个鬼的颜色的RGB值添加到PacmanGameController类中，并在main函数中生成四个彩色鬼。我还将准备一个用于坐标转换的静态函数，该函数简单地转换迷宫坐标(例如，x=16 y=16大约是迷宫的中心，乘以单元格或瓷砖的大小，得到游戏表面上的坐标，以像素为单位)。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="98ea" class="mn lf it mj b be mo mp l mq mr"># inPacmanGameController<br/>self.ghost_colors = [<br/>        (255, 184, 255),<br/>        (255, 0, 20),<br/>        (0, 255, 255),<br/>        (255, 184, 82)<br/>    ]<br/><br/># in main<br/>for i, ghost_spawn in enumerate(pacman_game.ghost_spawns):<br/>    translated = translate_maze_to_screen(ghost_spawn)<br/>    ghost = Ghost(game_renderer, translated[0], translated[1], unified_size, pacman_game,<br/>                  pacman_game.ghost_colors[i % 4])<br/>    game_renderer.add_game_object(ghost)<br/><br/># General functions for coordinate conversion, place at the beginning of the code<br/>def translate_screen_to_maze(in_coords, in_size=32):<br/>    return int(in_coords[0] / in_size), int(in_coords[1] / in_size)<br/><br/>def translate_maze_to_screen(in_coords, in_size=32):<br/>    return in_coords[0] * in_size, in_coords[1] * in_size</span></pre><p id="491e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个阶段，四个幽灵将在游戏启动时在迷宫中呈现。我们现在想让他们搬走。</p><h1 id="7ad4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">&gt;&gt;迷宫_寻路</h1><p id="1e09" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">现在可能是最复杂的部分。在2D空间或图中寻找路径是一个困难的问题。实现一个算法来解决这样的问题将需要另一篇文章，所以我们将使用一个现成的解决方案。最有效的寻路算法是A*算法。这是我们一开始安装的tcod包提供的。</p><p id="ea20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了移动幽灵，我将创建一个名为<code class="fe mt mu mv mj b">Pathfinder</code>的类。在构造函数中，我将用传递的代价初始化一个numpy数组(前面描述过的一个由1和0组成的数组),并创建一个类变量<code class="fe mt mu mv mj b">pf</code>,它将保存A* pathfinder的一个实例。当使用迷宫中的坐标(从哪里，到哪里)调用时，<code class="fe mt mu mv mj b">get_path</code>函数将计算并返回路径，作为一个数组中的一系列步骤。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="0ece" class="mn lf it mj b be mo mp l mq mr">class Pathfinder:<br/>    def __init__(self, in_arr):<br/>        cost = np.array(in_arr, dtype=np.bool_).tolist()<br/>        self.pf = tcod.path.AStar(cost=cost, diagonal=0)<br/><br/>    def get_path(self, from_x, from_y, to_x, to_y) -&gt; object:<br/>        res = self.pf.get_path(from_x, from_y, to_x, to_y)<br/>        return [(sub[1], sub[0]) for sub in res]</span></pre><p id="be82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我现在将向main函数添加一个部分来演示寻路。我选择路线的起点坐标[1，1]和终点[24，24]。这是可选代码。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="7102" class="mn lf it mj b be mo mp l mq mr"># draw path - optional<br/>red = (255, 0, 0)<br/>green = (0, 255, 0)<br/>_from = (1, 1)<br/>_to = (24, 24)<br/>path_array = pacman_game.p.get_path(_from[1], _from[0], _to[1], _to[0])<br/><br/>print(path_array)<br/># [(1, 2), (1, 3), (1, 4), (1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5), (6, 6), (6, 7) ...<br/><br/>white = (255, 255, 255)<br/>for path in path_array:<br/>    game_renderer.add_game_object(Wall(game_renderer, path[0], path[1], unified_size, white))<br/><br/>from_translated = translate_maze_to_screen(_from)<br/>game_renderer.add_game_object(<br/>    GameObject(game_renderer, from_translated[0], from_translated[1], unified_size, red))<br/><br/>to_translated = translate_maze_to_screen(_to)<br/>game_renderer.add_game_object(<br/>    GameObject(game_renderer, to_translated[0], to_translated[1], unified_size, green))</span></pre><p id="3faf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在游戏中，最短路线的渲染是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1f1c86f4acb46f49f4df7a0e02872f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h7LgDzThdXYHg2ur"/></div></div></figure><h1 id="7764" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">&gt;&gt;随机化_幽灵_运动</h1><p id="1c24" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">现在，我们将在PacmanGameController类中创建一个新函数，用于从reachable_spaces数组中选择一个随机点。每个幽灵到达目的地后都会使用这个功能。这样，鬼魂将简单地选择一条路径，从他们在迷宫中的当前位置到一个随机的目的地。我们将在下一部分实现更复杂的行为，比如追逐和逃离玩家。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="7846" class="mn lf it mj b be mo mp l mq mr">def request_new_random_path(self, in_ghost: Ghost):<br/>    random_space = random.choice(self.reachable_spaces)<br/>    current_maze_coord = translate_screen_to_maze(in_ghost.get_position())<br/><br/>    path = self.p.get_path(current_maze_coord[1], current_maze_coord[0], random_space[1],<br/>                           random_space[0])<br/>    test_path = [translate_maze_to_screen(item) for item in path]<br/>    in_ghost.set_new_path(test_path)</span></pre><p id="c98f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Ghost类中，我们添加了跟踪路径的新逻辑。每一帧都调用reached_target函数，检查重影是否已经到达其目标。如果有，它将确定迷宫路径的下一步是哪个方向，并开始向上、向下、向左或向右改变其位置(移动的逻辑在父级MovableObject类中调用)。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="be71" class="mn lf it mj b be mo mp l mq mr">def reached_target(self):<br/>    if (self.x, self.y) == self.next_target:<br/>        self.next_target = self.get_next_location()<br/>    self.current_direction = self.calculate_direction_to_next_target()<br/><br/>def set_new_path(self, in_path):<br/>    for item in in_path:<br/>        self.location_queue.append(item)<br/>    self.next_target = self.get_next_location()<br/><br/>def calculate_direction_to_next_target(self) -&gt; Direction:<br/>    if self.next_target is None:<br/>        self.game_controller.request_new_random_path(self)<br/>        return Direction.NONE<br/>    diff_x = self.next_target[0] - self.x<br/>    diff_y = self.next_target[1] - self.y<br/>    if diff_x == 0:<br/>        return Direction.DOWN if diff_y &gt; 0 else Direction.UP<br/>    if diff_y == 0:<br/>        return Direction.LEFT if diff_x &lt; 0 else Direction.RIGHT<br/>    self.game_controller.request_new_random_path(self)<br/>    return Direction.NONE<br/><br/>def automatic_move(self, in_direction: Direction):<br/>    if in_direction == Direction.UP:<br/>        self.set_position(self.x, self.y - 1)<br/>    elif in_direction == Direction.DOWN:<br/>        self.set_position(self.x, self.y + 1)<br/>    elif in_direction == Direction.LEFT:<br/>        self.set_position(self.x - 1, self.y)<br/>    elif in_direction == Direction.RIGHT:<br/>        self.set_position(self.x + 1, self.y)</span></pre><p id="717b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，重影在原始ASCII迷宫中由字母“G”指示的位置创建，并开始搜索随机路径。我把三个鬼魂关在笼子里——和原版吃豆人一样，他们会被一个个释放——还有一个在迷宫里游荡:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8c18cb37d28868207a5fde76268f6409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jJ9_d0pgiuNp5CIb"/></div></div></figure><h1 id="53a0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">&gt;&gt;玩家控制</h1><p id="3a1c" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">为了添加播放器功能，我将创建一个名为Hero的类。控制玩家和幽灵的大部分逻辑都在MovableObject类中处理，所以我们只需要几个函数来指定玩家的行为。在最初的吃豆人游戏中，玩家可以通过箭头键控制向四个方向移动。如果没有箭头键被按下，玩家将继续在最后一个有效的方向。如果在玩家不能移动的方向上按下一个键，该方向将被保存并在下一个可用回合使用。我将在我们的游戏中复制这一行为，并添加了Pacman从迷宫的一端传送到另一端的能力——我将检查玩家是否在游戏区域的左侧或右侧，并相应地将他们的位置设置为迷宫的对面。Pacman也有一个修改过的渲染函数，我们需要用它通常占据正方形一半的大小来渲染它(使用pygame.rect)。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="addd" class="mn lf it mj b be mo mp l mq mr">class Hero(MovableObject):<br/>    def __init__(self, in_surface, x, y, in_size: int):<br/>        super().__init__(in_surface, x, y, in_size, (255, 255, 0), False)<br/>        self.last_non_colliding_position = (0, 0)<br/><br/>    def tick(self):<br/>        # TELEPORT<br/>        if self.x &lt; 0:<br/>            self.x = self._renderer._width<br/><br/>        if self.x &gt; self._renderer._width:<br/>            self.x = 0<br/><br/>        self.last_non_colliding_position = self.get_position()<br/><br/>        if self.check_collision_in_direction(self.direction_buffer)[0]:<br/>            self.automatic_move(self.current_direction)<br/>        else:<br/>            self.automatic_move(self.direction_buffer)<br/>            self.current_direction = self.direction_buffer<br/><br/>        if self.collides_with_wall((self.x, self.y)):<br/>            self.set_position(self.last_non_colliding_position[0], self.last_non_colliding_position[1])<br/><br/>        self.handle_cookie_pickup()<br/><br/>    def automatic_move(self, in_direction: Direction):<br/>        collision_result = self.check_collision_in_direction(in_direction)<br/><br/>        desired_position_collides = collision_result[0]<br/>        if not desired_position_collides:<br/>            self.last_working_direction = self.current_direction<br/>            desired_position = collision_result[1]<br/>            self.set_position(desired_position[0], desired_position[1])<br/>        else:<br/>            self.current_direction = self.last_working_direction<br/><br/>    def handle_cookie_pickup(self):<br/>        collision_rect = pygame.Rect(self.x, self.y, self._size, self._size)<br/>        cookies = self._renderer.get_cookies()<br/>        game_objects = self._renderer.get_game_objects()<br/>        for cookie in cookies:<br/>            collides = collision_rect.colliderect(cookie.get_shape())<br/>            if collides and cookie in game_objects:<br/>                game_objects.remove(cookie)<br/><br/>    def draw(self):<br/>        half_size = self._size / 2<br/>        pygame.draw.circle(self._surface, self._color, (self.x + half_size, self.y + half_size), half_size)</span></pre><p id="30b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在main函数的末尾实例化了Hero类。我将位置设置为坐标[1，1] — unified_size是一个图块的大小。我们还需要将输入事件的处理添加到GameRenderer类中，以便我们可以控制游戏角色。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="d590" class="mn lf it mj b be mo mp l mq mr"># in GameRenderer class<br/>def add_hero(self, in_hero):<br/>        self.add_game_object(in_hero)<br/>        self._hero = in_hero<br/><br/>def _handle_events(self):<br/>    for event in pygame.event.get():<br/>        if event.type == pygame.QUIT:<br/>            self._done = True<br/><br/>    pressed = pygame.key.get_pressed()<br/>    if pressed[pygame.K_UP]:<br/>        self._hero.set_direction(Direction.UP)<br/>    elif pressed[pygame.K_LEFT]:<br/>        self._hero.set_direction(Direction.LEFT)<br/>    elif pressed[pygame.K_DOWN]:<br/>        self._hero.set_direction(Direction.DOWN)<br/>    elif pressed[pygame.K_RIGHT]:<br/>        self._hero.set_direction(Direction.RIGHT)<br/><br/><br/># at the end of main function<br/>pacman = Hero(game_renderer, unified_size, unified_size, unified_size)<br/>game_renderer.add_hero(pacman)<br/>game_renderer.tick(120)</span></pre><p id="520b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在推出游戏后，我们就可以控制玩家了——吃豆人！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6d2ef512dd95aec7e81c582a030fcaa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zclKr4jl6ThnOvS4"/></div></div></figure><h1 id="130e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">&gt;&gt;添加_ cookies</h1><p id="732a" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">迷宫里没有饼干就不是吃豆人了。从游戏性的角度来看，它们决定了对世界的探索程度，一些饼干甚至逆转了鬼魂和吃豆人的能力。因此，它们是玩家的最终奖励，也是他们通过关卡的主要指标。在今天的游戏中，游戏设计者想要鼓励玩家的行为通常会得到奖励。一个美丽的例子是今年的Elden Ring，任何探索世界每个角落的人都会得到奖励。越危险越偏僻，奖励越大。另一方面，像《现代刺客信条》这样的游戏支持任务完成，所以你在玩的时候会有一种你是在工作而不是在玩的感觉。</p><p id="6e8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加cookies将是整个教程中最简单的事情，这就是为什么我把它留到了最后，作为顶部的樱桃。我将创建一个名为Cookie的类。它的实例总是四个像素大小，黄色，圆形。在main函数中，我将在开始时保存在cookie_spaces数组(与reachable_spaces相同)中的所有瓦片上创建cookie。我会给播放器添加一个名为handle_cookie_pickup的函数，在这个函数中，我不断地检查播放器是否与任何cookie发生冲突。如果是这种情况，我将从数组中删除cookie，它将不再被呈现。</p><pre class="kp kq kr ks gt mi mj mk bn ml mm bi"><span id="2472" class="mn lf it mj b be mo mp l mq mr">class Cookie(GameObject):<br/>    def __init__(self, in_surface, x, y):<br/>        super().__init__(in_surface, x, y, 4, (255, 255, 0), True)<br/><br/># in GameRenderer class <br/>def add_cookie(self, obj: GameObject):<br/>        self._game_objects.append(obj)<br/>        self._cookies.append(obj)<br/><br/># in Hero class<br/>def handle_cookie_pickup(self):<br/>    collision_rect = pygame.Rect(self.x, self.y, self._size, self._size)<br/>    cookies = self._renderer.get_cookies()<br/>    game_objects = self._renderer.get_game_objects()<br/>    for cookie in cookies:<br/>        collides = collision_rect.colliderect(cookie.get_shape())<br/>        if collides and cookie in game_objects:<br/>            game_objects.remove(cookie)<br/><br/># in main function:<br/>for cookie_space in pacman_game.cookie_spaces:<br/>    translated = translate_maze_to_screen(cookie_space)<br/>    cookie = Cookie(game_renderer, translated[0] + unified_size / 2, translated[1] + unified_size / 2)<br/>    game_renderer.add_cookie(cookie)</span></pre><p id="7075" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是我们努力的结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6fc0304737787fb8460700c143955be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lA5xBXQFmw9E5c9w"/></div></div></figure><p id="3823" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结尾有一个有趣的事实——在最初的游戏中，吃豆人在吃完每块饼干后会停下来一帧，所以幽灵们可以在游戏开始时更容易地抓住他，那时场地仍然是满的。在下一部分，我们将实现类似的游戏机制，你也可以期待人工智能的幽灵，分数跟踪，声音，动画，纹理，开机，屏幕震动效果，生活，和结束游戏状态。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/c15a56a33c288240cebff7b97c36c6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zrX6nvCcN2PalcLZ"/></div></div></figure></div></div>    
</body>
</html>