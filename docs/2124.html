<html>
<head>
<title>GraphQL with Ruby On Rails: Queries in Multiple Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Ruby On Rails的GraphQL:多个文件中的查询</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-with-ruby-on-rails-queries-in-multiple-files-3a7b818354a2?source=collection_archive---------1-----------------------#2019-04-04">https://itnext.io/graphql-with-ruby-on-rails-queries-in-multiple-files-3a7b818354a2?source=collection_archive---------1-----------------------#2019-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d70b9df02ee0268b6fa5f0cbbe563aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2Vj-6neP9P7URGNJAsOmg.jpeg"/></div></div></figure><div class=""/><p id="712b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一集，我们添加了针对GraphQL突变的RSpecs测试。如果你需要更多关于这个话题的见解，你可以在这里查看文章<a class="ae kz" href="https://medium.com/@IreneuszSkrobis/testing-graphql-mutations-in-ruby-on-rails-with-rspec-219fbb1e71ab" rel="noopener"/>。今天，我们将为GraphQL查询添加规范(同样，我们将只关注愉快的路径)。但是对于当前的查询实现，有一点我不喜欢。我们在一个文件中定义了一切:<code class="fe la lb lc ld b">app/graphql/types/query_type.rb</code></p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="686b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以想象这个文件会随着时间的推移而增长。我想向您展示如何将逻辑分成许多更小的部分。</p><h1 id="b21f" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">每个重构的第一步</h1><p id="286a" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">没有合适的规范，很难进行重构。因此，我们将首先添加规格。但是为了使文章更简短，更容易理解，我们将采用我们公司非常重视的方法。我们将进行测试驱动的开发。这意味着我们将编写最终规格。因此，我们将为未来的实现添加规范，而不是在以前的实现中添加规范，在未来的实现中，每个查询都定义在一个单独的文件中。</p><p id="f104" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望有一个结构，所有的查询都在<code class="fe la lb lc ld b">app/graphql/queries/</code>文件夹内。因此，我们的规格将在<code class="fe la lb lc ld b">specs/graphql/queries/</code>目录中结束。</p><p id="8d4b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">specs/graphql/queries/author_spec.rb</code></p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="9d8a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">specs/graphql/queries/authors_spec.rb</code></p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="497a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">specs/graphql/queries/book_spec.rb</code>和<code class="fe la lb lc ld b">specs/graphql/queries/books_spec.rb</code>几乎相同，所以我不打算在这里粘贴代码。相反，如果你愿意，你可以检查gist上的文件:<a class="ae kz" href="https://gist.github.com/kayinrage/f668ba82b492058e47bc26dcf56fb5e2" rel="noopener ugc nofollow" target="_blank"> book_spec.rb </a>和<a class="ae kz" href="https://gist.github.com/kayinrage/bc272ac8cffb54ec4c31425736f1d1b1" rel="noopener ugc nofollow" target="_blank"> books_spec.rb </a></p><p id="4bc4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所看到的，我们的新规格看起来真的很像我们写的突变。我们有一个<code class="fe la lb lc ld b">query</code>方法，用于构建GraphQL查询，并检查查询结果是否符合我们的预期。</p><h1 id="a0be" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">将查询分成单独的文件</h1><p id="a1cc" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">现在，当所有需要的规范都准备好了，我们终于可以进行重构了。我不打算在本文中展示一个合适的TDD，因为它需要一遍又一遍地执行这些操作:运行spec，查看错误，修复错误，再次运行spec查看另一个错误，修复那个错误，等等。这很难理解，所以我将给出最终的解决方案，并解释其背后的想法。</p><p id="9448" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望有一个与突变相似的结构，但它不被支持，我们需要寻找替代方案。我们通常用来拆分查询的是<code class="fe la lb lc ld b">Resolvers</code>。</p><p id="ceb1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">免责声明:并不总是推荐。有关更多信息，请查看文档。</p><p id="1e69" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我多次提到的，我们希望我们的<code class="fe la lb lc ld b">query_type.rb</code>像<code class="fe la lb lc ld b">mutation_type.rb</code>一样工作，这意味着<code class="fe la lb lc ld b">app/graphql/types/query_type.rb</code>的新版本应该是这样的:</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="f205" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们去掉了所有的逻辑。相反，我们定义什么查询是可用的，以及该查询的解析器(一个我们可以找到它的地方)。</p><p id="7a58" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们要遵循变异的做事方式，我们需要一个额外的文件:<code class="fe la lb lc ld b">app/graphql/queries/base_query.rb</code></p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="9891" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它现在是空的，但在未来的剧集中，我们会用它来做一些很酷的事情。</p><p id="aff8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们终于可以看到新查询的实现了:</p><p id="cde9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">app/graphql/queries/author.rb</code></p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="5ecf" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">app/graphql/queries/authors.rb</code></p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="c52e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">app/graphql/queries/book.rb</code></p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="6f1d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">app/graphql/queries/books.rb</code></p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="b34d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个查询的代码都从<code class="fe la lb lc ld b">query_type.rb</code>中删除，没有任何改变。使之成为可能的神奇之处在于从<code class="fe la lb lc ld b">Queries::BaseQuery</code>继承而来，而后者又继承自<code class="fe la lb lc ld b">GraphQL::Schema::Resolver</code>。就是这样。</p><h1 id="4d0c" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">摘要</h1><p id="55de" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">在这一点上，我们已经测试了所有的端点，我们(几乎)有了一个易于构建的结构。在接下来的几集中，我们将讨论分页、认证、授权等等。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="4844" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mu">原载于</em><a class="ae kz" href="https://selleo.com/blog/graphql-with-ruby-on-rails-queries-in-multiple-files" rel="noopener ugc nofollow" target="_blank"><em class="mu">selleo.com</em></a><em class="mu">。</em></p></div></div>    
</body>
</html>