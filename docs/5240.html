<html>
<head>
<title>Serverless with OpenFaaS and .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器，带OpenFaaS和。网</h1>
<blockquote>原文：<a href="https://itnext.io/serverless-with-openfaas-and-net-6a66b5c30a5f?source=collection_archive---------0-----------------------#2021-01-20">https://itnext.io/serverless-with-openfaas-and-net-6a66b5c30a5f?source=collection_archive---------0-----------------------#2021-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3cfe67103b27294fb85dd5450d0985c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D71GeVhIKcFN_CB92SQ2Mg.png"/></div></div></figure><p id="5de2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我们很可能至少听说过无服务器计算。然而，市场上最流行的选项与平台紧密相关，如果我们想与不同的提供商或多个提供商合作，这可能是一个问题。</p><p id="fdee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">OpenFaaS改变了这一点，从某种意义上说，in几乎可以在任何地方运行；Kubernetes，Docker Swarm甚至单机。这意味着你可以使用Azure、Google Cloud、Digital Ocean、bare metal或Raspberry Pi部署你的功能。</p><p id="beac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当谈到你想使用的编程语言时，OpenFaaS也非常灵活；Go，Python，Java，C#只是少数。你甚至可以使用Dockerfile文件。今天我们将关注。NET和C#，但我们最后会触及F#支持。</p><h1 id="1fbe" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">设置环境</strong></h1><p id="4a28" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">安装OpenFaaS有多种选择，包括与云提供商如Azure、Google或AWS合作的托管kubernetes集群。为了简单起见，今天我们将使用<a class="ae lz" href="https://minikube.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> minikube </a>。</p><h2 id="7c3d" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">阿尔凯德</h2><p id="2d90" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Arkade是OpenFaaS社区开发的一个很棒的工具，它极大地简化了我们将舵图安装到kubernetes集群中的方式。我们还可以用它下载各种CLI工具，比如<code class="fe mm mn mo mp b">kubectl</code>、<code class="fe mm mn mo mp b">helm</code>甚至<code class="fe mm mn mo mp b">minikube</code>。我们将在这里使用它。</p><h2 id="7668" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated"><strong class="ak"> OpenFaaS </strong></h2><p id="7224" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">此时，我将假设<code class="fe mm mn mo mp b">kubectl</code>指向minikube集群。所以，我们用Arkade安装OpenFaaS吧。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="b793" class="ma kx iq mp b gy my mz l na nb">$ arkade install openfaas</span></pre><p id="15c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了验证OpenFaaS是否已经启动，我们使用下面的命令，正如安装脚本所建议的那样。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="40a7" class="ma kx iq mp b gy my mz l na nb">$ kubectl -n openfaas get deployments -l “release=openfaas, app=openfaas”</span></pre><p id="aca3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要安装<code class="fe mm mn mo mp b">faas-cli</code>。我们也可以对阿卡德这样做。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="f96d" class="ma kx iq mp b gy my mz l na nb">$ arkade get faas-cli</span></pre><p id="8a15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，按照OpenFaaS安装脚本的建议，我们转发网关。这需要部署网关，所以我们可以先检查一下。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="195a" class="ma kx iq mp b gy my mz l na nb">$ kubectl rollout status -n openfaas deploy/gateway<br/>deployment “gateway” successfully rolled out</span><span id="841f" class="ma kx iq mp b gy nc mz l na nb">$ kubectl port-forward -n openfaas svc/gateway 8080:8080 &amp;<br/>Forwarding from 127.0.0.1:8080 -&gt; 8080<br/>Forwarding from [::1]:8080 -&gt; 8080</span></pre><p id="439a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们用<code class="fe mm mn mo mp b">faas-cli</code>登录OpenFaaS网关。同样，按照安装脚本的建议。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="a4a2" class="ma kx iq mp b gy my mz l na nb">$ PASSWORD=$(kubectl get secret -n openfaas basic-auth -o jsonpath=”{.data.basic-auth-password}” | base64 — decode; echo)</span><span id="7b4f" class="ma kx iq mp b gy nc mz l na nb">$ echo -n $PASSWORD | faas-cli login — username admin — password-stdin<br/>Calling the OpenFaaS server to validate the credentials…<br/>Handling connection for 8080<br/>WARNING! Communication is not secure, please consider using HTTPS. Letsencrypt.org offers free SSL/TLS certificates.<br/>credentials saved for admin <a class="ae lz" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080</a></span></pre><p id="f7a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至此，我们的OpenFaaS集群已经可以使用了。</p><h1 id="a118" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">你好世界</h1><p id="28ef" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们的测试环境已经准备好了，所以…让我们用C#来做我们的Hello World。我们将从社区提供的官方模板开始。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="b910" class="ma kx iq mp b gy my mz l na nb">$ faas-cli new — lang csharp hello</span></pre><p id="4ab5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将创建一个<code class="fe mm mn mo mp b">hello.yml</code> YAML文件和一个<code class="fe mm mn mo mp b">hello</code>文件夹。快速浏览一下YAML的档案…</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="3b71" class="ma kx iq mp b gy my mz l na nb">version: 1.0<br/>provider:<br/>  name: openfaas<br/>  gateway: <a class="ae lz" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080</a><br/>functions:<br/>  hello:<br/>    lang: csharp<br/>    handler: ./hello<br/>    image: hello:latest</span></pre><p id="6ce0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们需要一个Docker注册中心来发布我们的图像，所以让我们更改<em class="nd">图像</em>标签并添加所需的前缀。这可以是私有或公共注册表。在这种情况下，我只是添加我的Docker Hub用户名作为前缀。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="193f" class="ma kx iq mp b gy my mz l na nb">functions:<br/>  hello:<br/>    lang: csharp<br/>    handler: ./hello<br/>    image: goncalooliveira/hello:latest</span></pre><p id="b6ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">快速看一下旧的<code class="fe mm mn mo mp b">hello</code>里面的<code class="fe mm mn mo mp b">FunctionHandler.cs</code>…</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="bb93" class="ma kx iq mp b gy my mz l na nb">using System;<br/>using System.Text;</span><span id="b313" class="ma kx iq mp b gy nc mz l na nb">namespace Function<br/>{<br/>    public class FunctionHandler<br/>    {<br/>        public string Handle(string input) {<br/>            return $"Hi there - your input was: {input}\n";<br/>        }<br/>    }<br/>}</span></pre><p id="b195" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们以最快的方式发布这个……<code class="fe mm mn mo mp b">up</code>命令将构建、推送和部署。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="888b" class="ma kx iq mp b gy my mz l na nb">$ faas-cli up -f hello.yml<br/>...<br/>Deployed. 202 Accepted.<br/>URL: <a class="ae lz" href="http://127.0.0.1:8080/function/hello.openfaas-fn" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/function/hello.openfaas-fn</a></span></pre><p id="6071" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切顺利，我们会看到一个已部署的消息和该函数的URL。那么，让我们试试我们的功能。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="7f83" class="ma kx iq mp b gy my mz l na nb">$ curl -d 'hello' <a class="ae lz" href="http://127.0.0.1:8080/function/hello.openfaas-fn" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/function/hello.openfaas-fn</a><br/>Handling connection for 8080<br/>Hi there - your input was: hello</span></pre><p id="3411" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！我们在C#中的第一个函数。</p><h1 id="7887" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">ASP.NET功能</strong></h1><p id="f136" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">尽管商店提供的<code class="fe mm mn mo mp b">csharp</code>模板可以工作，但它没有提供太多的功能或控制，并且它使用了经典<a class="ae lz" href="https://github.com/openfaas/classic-watchdog" rel="noopener ugc nofollow" target="_blank">版本的看门狗。对于更高吞吐量的情况，应使用新一代</a><a class="ae lz" href="https://github.com/openfaas/of-watchdog" rel="noopener ugc nofollow" target="_blank">看门狗。官方模板中又多了两个C#模板:</a><a class="ae lz" href="https://github.com/burtonr/csharp-kestrel-template" rel="noopener ugc nofollow" target="_blank"> csharp-kestrel </a>和<a class="ae lz" href="https://github.com/distantcam/csharp-httprequest-template" rel="noopener ugc nofollow" target="_blank"> csharp-httprequest </a>。第一个不再维护，最后一个已经有一段时间没有更新了，尽管它添加了一个<code class="fe mm mn mo mp b">HttpRequest</code>来获得更多的控制，但它使用了一个笨拙的元组<code class="fe mm mn mo mp b">&lt;int,string&gt;</code>响应。</p><p id="93af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一个模板还不是商店的一部分。不过是2020年末提交的，所以以后可能会。<a class="ae lz" href="https://github.com/goncalo-oliveira/faas-aspnet-template" rel="noopener ugc nofollow" target="_blank"> ASPNET函数</a>使用最新版本的看门狗，它内置了。NET 5和ASP.NET，并为那些习惯与ASP.NET一起工作的人提供了一个更容易识别的环境。此外，它支持依赖注入、配置、路由模板、认证和授权以及…调试。</p><h2 id="18a3" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">装置</h2><p id="9611" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">即使模板不是商店的一部分，它还是被安装了<code class="fe mm mn mo mp b">faas-cli</code>。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="f193" class="ma kx iq mp b gy my mz l na nb">$ faas-cli template pull <a class="ae lz" href="https://github.com/goncalo-oliveira/faas-aspnet-template" rel="noopener ugc nofollow" target="_blank">https://github.com/goncalo-oliveira/faas-aspnet-template</a></span></pre><h2 id="e128" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">你好ASPNET世界</h2><p id="17dc" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在模板已经安装好了，我们像以前一样创建一个新函数，这一次是用<code class="fe mm mn mo mp b">aspnet</code>模板。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="de1d" class="ma kx iq mp b gy my mz l na nb">$ faas-cli new --lang aspnet hello-aspnet</span></pre><p id="cfd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看已创建的<code class="fe mm mn mo mp b">hello-aspnet.yml</code> YAML文件，基本相同。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="68bf" class="ma kx iq mp b gy my mz l na nb">version: 1.0<br/>provider:<br/>  name: openfaas<br/>  gateway: <a class="ae lz" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080</a><br/>functions:<br/>  hello-aspnet:<br/>    lang: aspnet<br/>    handler: ./hello-aspnet<br/>    image: hello-aspnet:latest</span></pre><p id="114c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们像以前一样做同样的事情，并更改图像名称，以匹配我们的公共或私有注册表。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="4068" class="ma kx iq mp b gy my mz l na nb">functions:<br/>  hello-aspnet:<br/>    lang: aspnet<br/>    handler: ./hello-aspnet<br/>    image: goncalooliveira/hello-aspnet:latest</span></pre><p id="f5ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看<code class="fe mm mn mo mp b">hello-aspnet</code>文件夹，我们现在有两个文件，<code class="fe mm mn mo mp b">Function.cs</code>和<code class="fe mm mn mo mp b">Startup.cs</code>。我们从查看函数代码开始。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="d6fe" class="ma kx iq mp b gy my mz l na nb">using Microsoft.AspNetCore.Http;<br/>using Microsoft.AspNetCore.Mvc;<br/>using OpenFaaS;<br/>using System;<br/>using System.Threading.Tasks;</span><span id="a600" class="ma kx iq mp b gy nc mz l na nb">namespace OpenFaaS<br/>{<br/>    public class Function : HttpFunction<br/>    {<br/>        [HttpGet]<br/>        [HttpPost]<br/>        public override Task&lt;IActionResult&gt; HandleAsync( HttpRequest request )<br/>        {<br/>            var result = new<br/>            {<br/>                Message = "Hello!"<br/>            };</span><span id="9a77" class="ma kx iq mp b gy nc mz l na nb">return Task.FromResult&lt;IActionResult&gt;( Ok( result ) );<br/>        }<br/>    }<br/>}</span></pre><p id="62dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们立刻看到三个我们认识的东西。<code class="fe mm mn mo mp b">HttpRequest</code>输入，提供对请求的完全控制，<code class="fe mm mn mo mp b">IActionResult</code>响应和HTTP方法属性(默认为GET和POST)。</p><p id="a5c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们快速看一下<code class="fe mm mn mo mp b">Startup.cs</code>。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="99bf" class="ma kx iq mp b gy my mz l na nb">using Microsoft.Extensions.Configuration;<br/>using Microsoft.Extensions.DependencyInjection;</span><span id="a320" class="ma kx iq mp b gy nc mz l na nb">namespace OpenFaaS<br/>{<br/>    public class Startup<br/>    {<br/>        public Startup( IConfiguration configuration )<br/>        {<br/>            Configuration = configuration;<br/>        }</span><span id="d94a" class="ma kx iq mp b gy nc mz l na nb">public IConfiguration Configuration { get; }</span><span id="0337" class="ma kx iq mp b gy nc mz l na nb">// This method gets called by the runtime. Use this method to add services to the container.<br/>        public void ConfigureServices( IServiceCollection services )<br/>        {<br/>            services.AddHttpFunction&lt;Function&gt;();</span><span id="2091" class="ma kx iq mp b gy nc mz l na nb">// add your services here.<br/>        }<br/>    }<br/>}</span></pre><p id="39a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再说一次，我们认识一些东西。一个<code class="fe mm mn mo mp b">IConfiguration</code>实例和一个<code class="fe mm mn mo mp b">IServiceCollection</code>实例的DI设置。</p><p id="15e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们像第一个例子那样做，然后发布函数。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="cb7b" class="ma kx iq mp b gy my mz l na nb">$ faas-cli up -f hello-aspnet.yml<br/>...<br/>Deployed. 202 Accepted.<br/>URL: <a class="ae lz" href="http://127.0.0.1:8080/function/hello-aspnet.openfaas-fn" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/function/hello-aspnet.openfaas-fn</a></span></pre><p id="b7b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，如果一切顺利，我们会看到一个已部署的消息和该函数的URL。让我们试一试。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="f534" class="ma kx iq mp b gy my mz l na nb">$ curl <a class="ae lz" href="http://127.0.0.1:8080/function/hello-aspnet.openfaas-fn" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/function/hello-aspnet.openfaas-fn</a><br/>Handling connection for 8080<br/>{"message":"Hello!"}</span></pre><p id="3646" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅此而已。我们的功能起作用了。</p><h2 id="e3c6" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">为什么我应该使用ASPNET函数？</h2><p id="3584" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">那么这个模板到底能给我们带来什么呢？</p><p id="ffd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更新完毕</strong></p><p id="f561" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模板使用最新的看门狗版本，更适合高吞吐量的场景。它还使用最新版本的。NET和ASPNET。</p><p id="1b83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可以辨认</strong></p><p id="1a6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为它在幕后使用ASPNET，所以熟悉它的人可以认出许多东西。HTTP方法属性、<code class="fe mm mn mo mp b">IActionResult</code>和<code class="fe mm mn mo mp b">Ok()</code>、<code class="fe mm mn mo mp b">NoContent()</code>或<code class="fe mm mn mo mp b">BadRequest()</code>响应方法…</p><p id="0ec6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">依赖注入</strong></p><p id="0396" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们大多数使用ASPNET的人都使用依赖注入。<code class="fe mm mn mo mp b">Startup.cs</code>文件允许我们非常容易地配置DI容器，就像我们使用ASPNET应用程序一样。</p><p id="7d38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">配置</strong></p><p id="b0c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还提供了ASPNET配置模型。<code class="fe mm mn mo mp b">Startup.cs</code>中的<code class="fe mm mn mo mp b">IConfiguration</code>实例由环境变量和OpenFaaS <em class="nd">秘密</em>填充。在本地运行时，它还会读取一个<code class="fe mm mn mo mp b">config.json</code>文件(如果存在)。</p><p id="875d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">认证和授权</strong></p><p id="3edd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为它在幕后使用ASPNET，所以可以在<code class="fe mm mn mo mp b">Startup.cs</code>中配置认证。function类也可以用<code class="fe mm mn mo mp b">Authorize</code>属性来修饰，这样只有经过身份验证的请求才能执行它。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="0459" class="ma kx iq mp b gy my mz l na nb">namespace OpenFaaS<br/>{<br/>    [Authorize]<br/>    public class Function : HttpFunction<br/>    {<br/>        ...<br/>    }</span></pre><p id="a900" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">本地运行</strong></p><p id="3ad7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该功能可以通过<a class="ae lz" href="https://github.com/goncalo-oliveira/faas-run" rel="noopener ugc nofollow" target="_blank"> FaaS转轮</a>在本地执行。这对于在没有Kubernetes、Docker Swarm或<a class="ae lz" href="https://github.com/openfaas/faasd" rel="noopener ugc nofollow" target="_blank"> faasd </a>的环境中测试、调试(通过附加到进程)甚至运行该函数非常有用。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="357f" class="ma kx iq mp b gy my mz l na nb">$ dotnet build hello-aspnet/<br/>...<br/>$ faas-run hello-aspnet/bin/Debug/netstandard2.0/function.dll<br/>OpenFaaS ASPNET Function Loader</span><span id="bc58" class="ma kx iq mp b gy nc mz l na nb">To debug attach to process id 95587.</span><span id="f390" class="ma kx iq mp b gy nc mz l na nb">Loaded function assembly hello-aspnet/bin/Debug/netstandard2.0/function.dll.</span><span id="3501" class="ma kx iq mp b gy nc mz l na nb">Running...</span></pre><p id="e7e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我们可以用VS代码</strong>进行调试</p><p id="38b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用FaaS运行程序，我们可以通过附加到运行函数进程来进行调试。进程id显示在顶部。</p><p id="30ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以在<code class="fe mm mn mo mp b">launch.json</code>文件中创建一个配置来自动完成这项工作。下面是从模板自述文件中检索到的一个示例。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="38f3" class="ma kx iq mp b gy my mz l na nb">{<br/>    "name": ".NET Core Launch (faas run)",<br/>    "type": "coreclr",<br/>    "request": "launch",<br/>    "preLaunchTask": "build",<br/>    "program": "faas-run",<br/>    "args": ["bin/Debug/netstandard2.0/function.dll", "--no-auth"],<br/>    "cwd": "${workspaceFolder}",<br/>    "stopAtEntry": false,<br/>    "console": "internalConsole"<br/>},</span></pre><h2 id="4b3e" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">Hello F#世界</h2><p id="cb9c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">到目前为止，我们已经用C#做了所有的事情，但是ASPNET函数也有一个F#模板。在引擎盖下，它是完全一样的，功能也是一样的。</p><p id="4e76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们像以前一样创建一个新函数，这一次，使用<code class="fe mm mn mo mp b">aspnet-fsharp</code>模板。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="ccaa" class="ma kx iq mp b gy my mz l na nb">$ faas-cli new --lang aspnet-fsharp hello-fsharp</span></pre><p id="691d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看着创建的<code class="fe mm mn mo mp b">hello-fsharp.yml</code> YAML文件，差不多就是这样。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="d48c" class="ma kx iq mp b gy my mz l na nb">version: 1.0<br/>provider:<br/>  name: openfaas<br/>  gateway: <a class="ae lz" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080</a><br/>functions:<br/>  hello-fsharp:<br/>    lang: aspnet-fsharp<br/>    handler: ./hello-fsharp<br/>    image: hello-fsharp:latest</span></pre><p id="6865" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们像以前一样做同样的事情，并更改图像名称，以匹配我们的公共或私有注册表。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="f80b" class="ma kx iq mp b gy my mz l na nb">functions:<br/>  hello-fsharp:<br/>    lang: aspnet-fsharp<br/>    handler: ./hello-fsharp<br/>    image: goncalooliveira/hello-fsharp:latest</span></pre><p id="3840" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在我们来看一下<code class="fe mm mn mo mp b">hello-fsharp</code>文件夹。我们可以看到它的结构非常相似。我们的函数在<code class="fe mm mn mo mp b">Library.fs</code>文件中，还有一个<code class="fe mm mn mo mp b">Startup.fs</code>文件。让我们看看我们的功能。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="3297" class="ma kx iq mp b gy my mz l na nb">namespace OpenFaaS</span><span id="8ae1" class="ma kx iq mp b gy nc mz l na nb">open Microsoft.AspNetCore.Http<br/>open Microsoft.AspNetCore.Mvc<br/>open OpenFaaS<br/>open System<br/>open System.Threading.Tasks</span><span id="780b" class="ma kx iq mp b gy nc mz l na nb">type Function() =<br/>    inherit HttpFunction()</span><span id="3bd3" class="ma kx iq mp b gy nc mz l na nb">[&lt;HttpGet&gt;]<br/>    [&lt;HttpPost&gt;]<br/>    override this.HandleAsync( request : HttpRequest ) =<br/>        let result = {| Message = "Hello" |}<br/>        Task.FromResult( this.Ok( result ) :&gt; IActionResult )</span></pre><p id="a3d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">差不多吧，不过加了F#。让我们发表它。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="0782" class="ma kx iq mp b gy my mz l na nb">$ faas-cli up -f hello-fsharp.yml<br/>...<br/>Deployed. 202 Accepted.<br/>URL: <a class="ae lz" href="http://127.0.0.1:8080/function/hello-fsharp.openfaas-fn" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/function/hello-fsharp.openfaas-fn</a></span></pre><p id="b0b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，如果一切顺利，我们会看到一个已部署的消息和该函数的URL。让我们试一试。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="a5a4" class="ma kx iq mp b gy my mz l na nb">$ curl <a class="ae lz" href="http://127.0.0.1:8080/function/hello-fsharp.openfaas-fn" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/function/hello-fsharp.openfaas-fn</a><br/>Handling connection for 8080<br/>{"message":"Hello!"}</span></pre><p id="ef2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅此而已。我们的F#函数正在工作。</p><h1 id="e0fa" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">最后的话</h1><p id="3e02" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">OpenFaaS是一个很棒的无服务器功能框架，也是Azure Functions或AWS Lambda的优秀替代品。有了ASPNET函数，我们可以释放。NET，用它的C#和F#。</p><p id="c220" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章仅仅触及了表面，因此我强烈建议看看项目页面，包括<a class="ae lz" href="https://www.openfaas.com/" rel="noopener ugc nofollow" target="_blank"> OpenFaaS框架</a>和<a class="ae lz" href="https://github.com/goncalo-oliveira/faas-aspnet-template" rel="noopener ugc nofollow" target="_blank"> ASPNET函数</a>。如果你喜欢他们，给他们一颗星。</p></div></div>    
</body>
</html>