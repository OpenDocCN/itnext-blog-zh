<html>
<head>
<title>Custom UIViewController transitions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义UIViewController转换</h1>
<blockquote>原文：<a href="https://itnext.io/image-to-viewcontroller-transition-fe033d94b4af?source=collection_archive---------1-----------------------#2019-06-06">https://itnext.io/image-to-viewcontroller-transition-fe033d94b4af?source=collection_archive---------1-----------------------#2019-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1f56" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不要拘泥于仅仅是模态和推送。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d1db51fc0e4029188a3187da216a3530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uomiPB2s1tNqIZ5Q1nmcqg.jpeg"/></div></div></figure><p id="9911" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天我们将实现一个自定义过渡，使用<code class="fe ln lo lp lq b">UIViewControllerAnimatedTransitioning</code>将<code class="fe ln lo lp lq b">UIView</code>从半屏放大到全屏。在这个自定义转换中会发生什么只是一些简单的约束动画，但我们可以做几乎任何事情。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lr"><img src="../Images/a6e7fa62a29c7cb8e7fb725e2dcc083a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKzmoXurq_6YCs69X57vIg.png"/></div></div></figure><p id="7307" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从我在这里起草的这个quick-n-dirty方案中，你可以得到发生在转换上的想法。为了简单起见，我们只对每个屏幕使用一个视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="68e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为<code class="fe ln lo lp lq b">NSLayoutConstraints</code>，这看起来有点夸张，但事实上这里并没有太多。在我们到达<code class="fe ln lo lp lq b">Presenter</code>之前，请注意屏幕并不知道我们要做什么。逻辑与之完全隔绝。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="be8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">Presenter</code>是从<code class="fe ln lo lp lq b">UIViewControllerTransitioningDelegate</code>协议中实现这两个功能的协调器。我们在这里要做的就是以正确的方向将转换传递给每个<code class="fe ln lo lp lq b">animationController(for presented/for dismissed)</code></p><blockquote class="lu lv lw"><p id="1fc0" class="kr ks lx kt b ku kv jr kw kx ky ju kz ly lb lc ld lz lf lg lh ma lj lk ll lm ij bi translated">好了，是时候看看我们在这里的原因了:<code class="fe ln lo lp lq b"><em class="iq">Transition</em></code>。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="8429" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的，首先，我们有一个名为Direction的枚举，它包含两种情况，一种是present，另一种是discover。我们还保持方向，以便我们可以在我们的演示者中设置它。当符合协议<code class="fe ln lo lp lq b">UIViewControllerAnimatedTransitioning</code>时，我们必须实现<code class="fe ln lo lp lq b">transitionDuration</code>和<code class="fe ln lo lp lq b">animateTransition</code>功能。第一个简单地返回一个<code class="fe ln lo lp lq b">CGFloat</code>，它是过渡的持续时间，第二个是“<em class="lx">大交易</em>”。</p><p id="c1e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将现在分离出来，放入私有函数中，因此在animateTransition函数中，我们只需切换方向，并通过transitionContext调用适当的函数。另外，请注意，我们存储了两个NSLayoutConstraints数组。它们将保留已呈现的状态约束和已取消的状态约束。</p><ul class=""><li id="ff0c" class="mb mc iq kt b ku kv kx ky la md le me li mf lm mg mh mi mj bi translated">使用present函数上的上下文，我们可以获得将使用context.view(forKey:。到)。如果我们想在转换之前做些别的事情，我们也可以通过将键改为<strong class="kt ir">来检索将要呈现的视图。来自</strong></li><li id="a20d" class="mb mc iq kt b ku mk kx ml la mm le mn li mo lm mg mh mi mj bi translated">现在我们有了将要呈现的视图，我们将它添加为context.containerView中的子视图，这是在转换期间显示的视图，然后为每个状态设置约束:呈现和取消。</li><li id="e8a0" class="mb mc iq kt b ku mk kx ml la mm le mn li mo lm mg mh mi mj bi translated">我们需要做的最后一件事是纯粹的UIView动画约束，现在(真的)最后一件事是调用completeTransition(true)以显示正确的屏幕。</li></ul><p id="0df4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">解散的时候，我们正好反过来。玩约束和<em class="lx">瞧</em>。</p><p id="671d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个我们可以用它做什么的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/a335c7a95630a24613523db97ac7abba.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*28lXFvV1W5i-6LXvjKEptA.gif"/></div></figure></div></div>    
</body>
</html>