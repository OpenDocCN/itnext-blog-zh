<html>
<head>
<title>Git-Notes Your CI Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">git——记录您的CI流程</h1>
<blockquote>原文：<a href="https://itnext.io/git-notes-your-ci-process-46b2fd5ac52?source=collection_archive---------1-----------------------#2021-06-11">https://itnext.io/git-notes-your-ci-process-46b2fd5ac52?source=collection_archive---------1-----------------------#2021-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/27bc516279a99a0cac648a5007f8bc3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*PWSZqreEhex6WjLxlcMh9w.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图片由来自<a class="ae kb" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1080592" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kb" href="https://pixabay.com/users/jarmoluk-143740/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1080592" rel="noopener ugc nofollow" target="_blank"> Michal Jarmoluk </a>拍摄</figcaption></figure><p id="257c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">很长一段时间以来，我们一直使用Jenkins作为我们的CI系统。从构建过程的角度来看，这很好，但是它也有其<a class="ae kb" rel="noopener ugc nofollow" target="_blank" href="/jenkins-is-getting-old-2c98b3422f79">问题</a>。我们遇到的最恼人的问题之一是丢失构建历史。我们通常告诉Jenkins保留大约10个以前的版本。但是一旦他们离开，这些信息就永远消失了。现在，我们可以增加或完全取消限制，但是，硬盘空间不是无限的，随着更多的历史被创建，Jenkins需要越来越长的时间来呈现构建页面。此外，您保留的历史越多，Jenkins需要的内存(RAM/JVM堆)就越多。理想情况下，我们总是试图将詹金斯视为一种短暂的资源。</p><p id="f9ef" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们如何继续存储我们的构建历史，而不依赖于Jenkins或其他数据库？</p><p id="3347" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Git有一个很少被利用的特性，叫做<a class="ae kb" href="https://git-scm.com/docs/git-notes" rel="noopener ugc nofollow" target="_blank"> Git Notes </a>，它允许你在不改变原始提交散列的情况下将元数据附加到任何提交上。这对我们来说是完美的，因为我们试图在每次提交时开始构建，并且希望知道那些构建与原始提交一致的结果。现在，git-notes并不是没有批评者，但是只要做一点工作，我们就可以利用这个特性在git存储库中存储所有构建的构建信息。</p><h2 id="2256" class="la lb it bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">CI设置</h2><p id="28cd" class="pw-post-body-paragraph kc kd it ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz im bi translated">首先，我们需要设置CI流程，以便在构建结束时发布构建信息。鉴于我们使用Jenkins，本指南将重点关注这一点，但大多数构建系统都应该能够实现这一点。</p><p id="070a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Jenkinsfile:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="b3fa" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><em class="me"> post-always </em>将确保git-notes进程始终执行。我们需要一个节点，并会在一个超时执行以防万一。最后，我们需要签出代码，因为我们将与git存储库进行交互。最后，我们调用我们的<em class="me"> addNotes </em>方法。</p><p id="afb2" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><em class="me"> addNotes </em>方法捕获构建元数据，并使用Jenkins管道方法<a class="ae kb" href="https://www.jenkins.io/doc/pipeline/steps/pipeline-utility-steps/#writeyaml-write-a-yaml-from-an-object-or-objects" rel="noopener ugc nofollow" target="_blank"> writeYaml </a>将其存储到yaml文件中。最后，在一个credentials块中，我们调用git-notes shell脚本来推送notes。</p><p id="42a2" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">gitNotes.sh:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="161e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">有关详细信息，请参见脚本中的注释，但是基本的<em class="me">要点</em>(双关缩进)是gitNotes.sh脚本将:</p><ol class=""><li id="e9b0" class="mf mg it ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated">获取当前笔记</li><li id="db3c" class="mf mg it ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated">将注释yaml合并到名称为Jenkins的注释REF中，我们使用名称为<em class="me"> jenkins </em>的REF，但是您可以使用任何您希望的名称</li><li id="d1dc" class="mf mg it ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated">将重试循环中的结果回推到git存储库</li></ol><p id="f1de" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">重试循环非常重要，因为其他分支可能会同时推送到同一个回购，REF必须始终在最前面才能成功。</p><p id="5a1c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">为了阅读笔记，每个用户必须设置他们的本地git克隆来获取笔记。</p><h2 id="1d05" class="la lb it bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">用户设置</h2><p id="e888" class="pw-post-body-paragraph kc kd it ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz im bi translated">要获取笔记:</p><pre class="ly lz ma mb gt mt mu mv mw aw mx bi"><span id="60c3" class="la lb it mu b gy my mz l na nb">git fetch origin "refs/notes/*:refs/notes/*"</span></pre><p id="d984" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">或者，您可以编辑您的git配置来默认获取注释:</p><pre class="ly lz ma mb gt mt mu mv mw aw mx bi"><span id="e3ae" class="la lb it mu b gy my mz l na nb">[remote "origin"]<br/>  fetch = +refs/heads/*:refs/remotes/origin/*<br/>  fetch = +refs/notes/*:refs/notes/*</span></pre><p id="2a5d" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">要查看提交日志中的注释，请执行以下操作:</p><pre class="ly lz ma mb gt mt mu mv mw aw mx bi"><span id="dc4e" class="la lb it mu b gy my mz l na nb">git logs --notes=jenkins</span></pre><p id="17b2" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">样本输出:</p><pre class="ly lz ma mb gt mt mu mv mw aw mx bi"><span id="0e19" class="la lb it mu b gy my mz l na nb">commit ABCDEFG...<br/>Author: Jenkins &lt;<a class="ae kb" href="mailto:no-reply@optum.com" rel="noopener ugc nofollow" target="_blank">no-reply@github.com</a>&gt;<br/>Date:   Mon Jun 7 19:58:57 2021 +0000</span><span id="0c9a" class="la lb it mu b gy nc mz l na nb">Commit Message, hello</span><span id="47ff" class="la lb it mu b gy nc mz l na nb">Notes (jenkins):<br/>    build-job-env%2Fdev-93:<br/>      duration: 49 sec<br/>      full_display_name: 'github » build-job » env/dev #93'<br/>      id: '93'<br/>      number: 93<br/>      branch: env/dev<br/>      result: FAILURE<br/>      time: '2021-06-07T14:59:07.720Z'<br/>      causes:<br/>      - _class: jenkins.branch.BranchEventCause<br/>        shortDescription: Push event to branch env/dev<br/>      url: <a class="ae kb" href="https://jenkins-datacore-jenkins.ocp-elr-core-nonprod.optum.com/job/datacore/job/datacore-ops/job/env%252Fdev/93/" rel="noopener ugc nofollow" target="_blank">https://sample-url/job/github/job/github/job/env%252Fdev/93/</a></span></pre><p id="3351" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果同一个提交发生了多个作业，那么将会显示两个注释，因为我们合并了注释。</p><h2 id="559b" class="la lb it bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">摘要</h2><p id="a07d" class="pw-post-body-paragraph kc kd it ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz im bi translated">通过这种设置，我们能够在git存储库中保存Jenkins构建的历史，这是我们最终的事实来源。我们可能会丢失实际的构建控制台日志和任何Jenkins构建工件，但是随着时间的推移，它们的价值会逐渐减少。</p><p id="b334" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">有人可能会说，这种设置在像<a class="ae kb" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github Actions </a>或<a class="ae kb" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank"> Gitlab CI </a>这样的构建系统中价值有限，因为它们已经在本地存储了构建信息。但是，Github不再支持在web界面中查看git-notes。在Gitlab中可以看到注释。</p><p id="852b" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">然而，我们发现这对我们非常有用，因为:</p><ol class=""><li id="26ce" class="mf mg it ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated">我们利用内部(公司防火墙后)git存储库</li><li id="f4a3" class="mf mg it ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated">提供可追溯性</li><li id="90e7" class="mf mg it ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated">可以从命令行查看日志(即使脱机)</li><li id="357b" class="mf mg it ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated">与git日志很好地集成，提供搜索和解析</li><li id="1e0e" class="mf mg it ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated">确保我们不依赖任何供应商的git产品或web界面，只依赖原生git</li></ol></div></div>    
</body>
</html>