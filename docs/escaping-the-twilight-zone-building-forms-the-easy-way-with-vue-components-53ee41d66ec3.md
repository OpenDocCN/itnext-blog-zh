# 逃离阴阳魔界:用 Vue 组件建造简单的形式

> 原文：<https://itnext.io/escaping-the-twilight-zone-building-forms-the-easy-way-with-vue-components-53ee41d66ec3?source=collection_archive---------8----------------------->

不需要 Vuex！

*西班牙的传统是什么？哈斯梅洛·萨伯！如果有足够的时间，可以在最后一节用西班牙语翻译。*

最近，我发现自己需要在 Laravel 应用程序中构建一个 Vue 支持的表单。将 Vue 和 Laravel 一起使用通常是两全其美，将 Vue 的反应式前端功能与 Laravel 提供的直观后端搭建结合起来。然而，正如其他地方关于[的文章所写的](https://stimulusjs.org/handbook/origin#how-stimulus-differs-from-mainstream-javascript-frameworks)，使用前端 Javascript 库和后端框架——无论是 Laravel、Ruby on Rails，甚至是 Node——总是会导致一个小而不可避免的边缘地带，在那里你遇到的挑战可以通过两个框架解决，但是没有一个像你希望的那样干净利落。亲爱的读者，如果你发现自己陷入了这个开发者的困境，不要担心:一点独创性和一点 Google-fu 可以解决甚至最令人困惑的困境。

![](img/7dcca1ba54f0e83d440b54c359c51931.png)

在我的例子中，当我使用 Vue 和 Laravel 构建一个复杂的表单时，我进入了技术的边缘地带。因为 Vue 需要控制你提供给它的任何 HTML，所以我决定依赖传统的 Laravel 表单不是处理事情的最佳方式——一旦进入 Vue，最好使用完整的 Vue。

正如您所料，这导致了另一个问题。在 Laravel 中，实际上在一般的 PHP 中，通过 HTML 表单提交[数组是相对简单的。我很快了解到，如果您希望通过基于 JavaScript 的 AJAX 将表单提交发送到后端，这种基于 HTML 的方法并不适用。在这种情况下，除非您安装一个定制库来模拟 PHP 的表单数组，否则您只能在将数据发送到服务器之前手动集中数据。](http://php.net/manual/en/faq.html.php#faq.html.arrays)

用 JavaScript 发送 AJAX 请求的最快方式是利用 Axios 之类的 HTTP 库将请求发送到后端。事实上，我毫不费力地在更简单的形式上采用了这种精确的策略；对于更复杂的表单，我很快发现需要一种不同的方法。因为表单有多个自定义输入——图像上传、自动完成等。—我知道我必须使用子组件来存储一些表单数据。

对 Vue 有一定经验的人大概能预料到我的问题。传统上，Vue 中的数据从上到下，从父组件到子组件单向流动。在许多情况下，这种方法使开发变得轻而易举——只需将数据插入顶层组件，就万事大吉了。在这个特殊的例子中，这样的数据流并不完全符合我的需求。因为我需要将我的数据集中起来发出一个 AJAX 请求，所以我的父组件需要访问在子组件中创建的数据。

这又是一个转折点，阴阳魔界挫败了我最初寻求简单解决方案的努力。如果我正在构建一个 Vue 专用的前端，那么使用 Vue 的状态管理库 Vuex 将是显而易见的方法。然而，因为我利用 Laravel 来处理一些本来属于 Vuex 领域的状态管理，所以我很快决定设置 Vuex 所需的额外样板文件会给我的应用程序添加大量代码来完成一个相对较小的问题。虽然有时这种额外的开销是合理的，因为我知道我会在完成后将这个项目交给其他开发人员，但我决定采用一种更简单的方法来减少理解应用程序所需的代码量，使每个人在未来的生活更轻松。

所以，我来了。如果不使用 Vuex，我需要某种方法来维护 Vue 表单中的父子数据，以简化和集中 AJAX 请求。在尝试了几种要么不起作用要么使我的代码库规模翻倍的方法之后，我发现了两个不太为人知的 Vue 特性的组合，它们用不到 10 行代码就实现了我的目标。

下面是我如何在不使用专用状态管理库的情况下在 Vue 中构建基于组件的表单的内幕。

对于这个特殊的例子，我假设我们正在构建一个表单，向后端添加一组作者。我不会过多地讨论后端——如果有足够的需求，我会把它留给另一个专栏。

因此，让我们假设这就是我们希望我们的顶级 Vue 组件最终看起来的样子:

如果我们想把所有东西都放在我们的顶级组件中，这种方法可以很好地工作。然而，随着表单复杂性的增加，这种方法很快变得混乱，我们的目标是尽可能保持代码简单。

因此，将每个作者输入提取到它自己的组件中，并根据需要在顶层组件中添加/删除作者是有意义的。

因此，我们的代码如下所示:

这就是我们开始遇到问题的地方。我们正在修改我们的`AddSingleAuthor`组件中的数据，我们需要这些数据在我们的顶级组件中可用。这违背了 Vue 最佳实践...**然而**，Vue 1 中有一个特性，在 Vue 2.3 中重新引入，它对帮助我解决这个难题至关重要:`[.sync](https://vuejs.org/v2/guide/components.html#sync-Modifier)`。使用 vue 的`v-bind`指令和`.sync`，我们能够将数据传递给我们的子组件，并自动添加一个事件监听器，该监听器将修改父组件的数据以匹配子组件的数据。

将`v-model`指令切换到`v-bind`，我们得到如下所示的结果:

注意，我们将一个`author`属性传递给每个子`AddSingleAuthor`组件，该子组件与父组件中`authors`数组中的相应元素同步。

现在，让我们看看这个`AddSingleAuthor`组件可能是什么样子:

我给表单增加了一点复杂性，并在这个过程中引入了一个问题。你可能已经注意到，即使我们接受了`author`道具，我们实际上并没有用它做任何事情。

此外，我们实际上如何触发父组件对`AddSingleAuthor`组件中变化的数据做出反应并不明显。我们可以向每个输入字段添加侦听器，并编写单独更新每个属性的方法——但是，这样很快就会变得笨拙，并导致大量重复代码。不好玩。

因此，我所做的是将所有数据属性嵌套在一个单独的`author`属性下，得到如下所示的代码:

好的，酷，我们已经在一个中央`author`对象中获得了所有数据。现在怎么办？

我尝试的第一种方法涉及计算属性，但我很快意识到这不是我需要的。我不仅想监听每一个变化，还需要根据数据变化执行一些其他代码，而不是创建一个新的属性。

下一个显而易见的解决方案是使用`watch`属性。然而，当我发现默认情况下`watch`并不监听子属性的变化时，我很快就失望了。所以监视`author`属性是行不通的——我需要独立地监听每个子属性。

或者我会吗？

事实证明我不会，这要感谢`watch`属性的一个便利特性，在我发现它隐藏在文档中之前，我并不知道这个特性:**深度观察**。

尽管深度监视听起来像是胡佛时代 FBI 的战术，但这正是我们现在需要的。原来，通过将另一个属性传递给我们在`watch`中的`author`属性，我们可以在任何子属性被更新时触发回调。很酷的东西！

将它应用到我们的`AddSingleAuthor`组件看起来像这样:

使用`this.$emit`，我们将整个`newAuthor`对象发送到父组件，在那里使用`.sync`它将替换我们作为`author`道具传入的空字符串。

就是这样！这种设置是在表单中使用子组件所需要的，同时仍然保持用发送 AJAX 请求所需的所有数据填充顶级元素。您可以随意向子组件添加属性，而无需为每个子组件编写定制的`update`事件。只要您添加的属性附加到`newAuthor`对象，它们就会自动添加到父组件中。

观察力敏锐的人可能已经注意到，我们仍然没有在我们的子组件中使用`author` prop 做任何事情——你是完全正确的。事实上，我们可以完全删除`props`属性，但一切仍按预期工作。

就我个人而言，我喜欢传入空的 prop 并利用`.sync`指令——这样我就不用在父组件中编写`update`方法，而且对我来说，它使事情更具可读性。如果传递一个未使用的道具让您感到困扰，那么您可以随意移除它，并编写一个自定义的事件侦听器来完成同样的事情。我在这里不打算这样做，因为我尽量不写任何不必要的代码，但是如果你愿意的话，这是一个 100%的选择。

下次你发现自己处于边缘地带，也许同步或深度观察是解决办法！