<html>
<head>
<title>Reusing HttpClient didn’t solve all my problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重用HttpClient并没有解决我所有的问题</h1>
<blockquote>原文：<a href="https://itnext.io/reusing-httpclient-didnt-solve-all-my-problems-142a32a5b4d8?source=collection_archive---------3-----------------------#2018-06-26">https://itnext.io/reusing-httpclient-didnt-solve-all-my-problems-142a32a5b4d8?source=collection_archive---------3-----------------------#2018-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8c726e5989040abcb8dc6bc8914a0157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22kxTvZ-Z37q2CWZitZOaw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">你为什么不表演？</figcaption></figure><div class=""/><p id="4170" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://medium.com/@rahulbhuwal/httpclient-may-kill-your-system-be-careful-62b1533ad456" rel="noopener">在上一篇文章</a>中，我发布了处理HttpClient是如何频繁地阻塞我的Api并使服务器在巨大的负载下崩溃的。我们研究了更好的重用HttpClient的方法，避免了线程安全问题。重用HttpClient确实提高了Api的稳定性，但并没有提高我的系统的性能。我所说的性能是指触发多个并行http api调用，并在最少的时间内获得单独的响应。</p><h1 id="a9c8" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们为什么需要这个？</h1><p id="3c6a" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">让我们来看一个假设的例子，假设您正在构建一个Rest端点，它需要提供一个经销商列表，您可以从这些经销商那里订购修理汽车的零件。</p><p id="72db" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们假设您的Api接受Partids列表，您需要为这些列表找到经销商。您的请求负载如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6d84" class="mn lc jf mj b gy mo mp l mq mr">{<br/>    "partIds": [1, 2, 3, 4, 5, 6, 7, 8]<br/>}</span></pre><p id="57f7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设您的响应json看起来是这样的:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="644a" class="mn lc jf mj b gy mo mp l mq mr">{<br/>    "dealers": [{<br/>        "dealerId": 1,<br/>        "dealerName": "abc dealer",<br/>        "parts": [{<br/>            "partId": 1,<br/>            "partId": 2<br/>        }]<br/>    }, {<br/>        "dealerId": 2,<br/>        "dealerName": "def dealer",<br/>        "parts": [{<br/>            "partId": 3,<br/>            "partId": 4,<br/>            "partId": 5<br/>        }]<br/>    }, {<br/>        "dealerId": 3,<br/>        "dealerName": "xyz dealer",<br/>        "parts": [{<br/>            "partId": 6,<br/>            "partId": 7,<br/>            "partId": 8<br/>        }]<br/>    }]<br/>}</span></pre><p id="24f5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要生成此响应，假设您必须通过经销商调用库存Api，并向其提供您需要检查可用性的零件id列表。假设下面是标准的<strong class="ke jg">要求</strong>代理商库存api。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4836" class="mn lc jf mj b gy mo mp l mq mr">{<br/>    "parts": [{<br/>        "partId": 1,<br/>        "partId": 2,<br/>        "partId": 3,<br/>        "partId": 4,<br/>        "partId": 5,<br/>        "partId": 6,<br/>        "partId": 7,<br/>        "partId": 8<br/>    }]<br/>}</span></pre><p id="36cd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每个经销商的回复如下所示。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0951" class="mn lc jf mj b gy mo mp l mq mr">{<br/>    "parts": [{<br/>        "partId": 1,<br/>        "price": 255,<br/>        "isAvailable": true<br/>    }, {<br/>        "partId": 2,<br/>        "price": 55,<br/>        "isAvailable": true<br/>    }, {<br/>        "partId": 3,<br/>        "price": 155,<br/>        "isAvailable": true<br/>    }, {<br/>        "partId": 4,<br/>        "price": 255,<br/>        "isAvailable": false<br/>    }, {<br/>        "partId": 5,<br/>        "price": 255,<br/>        "isAvailable": false<br/>    }, {<br/>        "partId": 6,<br/>        "price": 255,<br/>        "isAvailable": false<br/>    }, {<br/>        "partId": 7,<br/>        "price": 255,<br/>        "isAvailable": false<br/>    }, {<br/>        "partId": 8,<br/>        "price": 255,<br/>        "isAvailable": false<br/>    }]<br/>}</span></pre><blockquote class="ms mt mu"><p id="9289" class="kc kd mv ke b kf kg kh ki kj kk kl km mw ko kp kq mx ks kt ku my kw kx ky kz ij bi translated">从上面的例子中你可以看到，如果你有和你有关系的经销商，那么对于每一个请求，你都需要给每个经销商打电话，最好是并行的，处理他们的回复。因此，对于每个传入请求，您必须打开15个出站请求。<a class="ae la" href="https://medium.com/@rahulbhuwal/httpclient-may-kill-your-system-be-careful-62b1533ad456" rel="noopener">如果你没有像前一篇文章中描述的那样重用HttpClient，你将很快耗尽可用的套接字，从而导致请求失败和用户体验下降。几乎失去了你的客户。</a>但是，即使按照我之前写的最佳实践，也不会减少出站请求的响应时间，因为越来越多的请求在出站套接字上排队。为此，您需要切换不同的“<a class="ae la" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.servicepointmanager?view=netframework-4.7.2" rel="noopener ugc nofollow" target="_blank"> ServicePointManager </a>”设置。</p></blockquote><h1 id="0732" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ServicePointManager。DefaultConnectionLimit是关键</h1><p id="a011" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">网上有很多文章说服务点管理员的默认连接限制是2，这是真的也是假的。查看<a class="ae la" href="https://referencesource.microsoft.com/#System/net/System/Net/ServicePointManager.cs,6a75423260490f3a" rel="noopener ugc nofollow" target="_blank">源代码文档</a>和我的观察，我可以有把握地告诉你，如果你不做任何更改默认连接限制，你的出站连接将被限制到ASP.NET管道最多10个出站连接。</p><figure class="me mf mg mh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mz"><img src="../Images/b17464a2bd6b90c862e526307fb0bde6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*grYQHoOflgCtufvvNyRinQ.png"/></div></div></figure><p id="0bda" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您对出站连接没有任何高吞吐量要求，您将永远不必担心切换此设置。但是对于我的用例来说，这是一个严重的限制，我开始想知道我还需要覆盖什么缺省值以及设置什么。</p><h1 id="a54f" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我是如何诊断问题的</h1><p id="124c" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我的集成测试将调用我的api中的一个端点，这将在内部进行15次api调用，将在顺序运行它们时顺利工作。但是当我并行运行它们时，一个或其他测试将永远无法执行，并最终以超时错误代码失败。如果您在托管api的服务器上运行fiddler，您可以看到给定时间的出站连接数。</p><p id="6aaa" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，通过简单的计算，如果我并行运行10个集成测试，我的api将有150个出站连接。这个问题让我走上了一条研究之路，并向有类似问题的其他工程师学习，但互联网上关于这些事情的文献非常少。因此，我采用了读书的老方法来解决问题，而不是浏览那些问题。</p><figure class="me mf mg mh gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6b8de933f401f7fe7eddfdf966575415.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*W7S43ysRAAVNMPd9nTa6Xg.jpeg"/></div></figure><p id="028e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我最喜欢的书之一。Net app调优是"<a class="ae la" href="https://www.amazon.com/Writing-High-Performance-NET-Code-Watson-ebook/dp/B07BF68842/ref=sr_1_1?ie=UTF8&amp;qid=1529985344&amp;sr=8-1&amp;keywords=high+performance+.net+code" rel="noopener ugc nofollow" target="_blank">写高性能。NET代码由本·沃特森</a>。这本书在第六章“优化HTTP设置和网络通信”中阐明了如何切换各种ServicePointManger设置。因此，我遵循了Ben的建议，令我惊讶的是，我的应用程序性能发生了巨大的变化。</p><h1 id="cf7c" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用于高吞吐量和高性能的最佳ServicePointManager设置</h1><p id="e44b" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">这里是我切换的属性，它对我的orchestraion api性能产生了巨大的影响。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5799" class="mn lc jf mj b gy mo mp l mq mr">ServicePointManager.UseNagleAlgorithm = false;</span><span id="7e1a" class="mn lc jf mj b gy nb mp l mq mr">ServicePointManager.Expect100Continue = false;</span><span id="822a" class="mn lc jf mj b gy nb mp l mq mr">ServicePointManager.DefaultConnectionLimit = int.MaxValue;</span><span id="2ae2" class="mn lc jf mj b gy nb mp l mq mr">ServicePointManager.EnableDnsRoundRobin = true;</span><span id="902f" class="mn lc jf mj b gy nb mp l mq mr">ServicePointManager.ReusePort = true;</span></pre><p id="ba60" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> DefaultConnectionLimit </strong> -每个端点的连接数。将这个值设置为最大值大大提高了我的总吞吐量。该设置在prod中成功运行，在任何服务器上都没有任何不稳定性。您也可以安全地为您的API打开它。</p><p id="f779" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> Expect100Continue- </strong>在发送post和put请求的大型对象以确保远程端点启动并运行之前，设置此设置是为了节省带宽。如果您在两端都拥有api，那么您应该关闭它，以减少每个api通信之间的延迟。</p><p id="ad08" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> UseNagleAlgorithm- </strong> Nagle的算法是一种通过减少需要通过网络发送的数据包数量来提高TCP/IP网络效率的方法。这可以减少总的传输开销，但是会导致数据分组到达的延迟。你也可以安全地关闭它。现代网络通信不应该依赖这种节省带宽的老方法。</p><p id="2f24" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这一章中提到的可以进一步提高性能的属性很少，但是我能够通过上面的更改成功地达到我的基准。</p><p id="de79" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我正在试验最后两个属性(EnableDnsRoundRobin和Reuse Port ),因为我还不能对它们在整个画面中的贡献进行基准测试，所以对最后两个属性要有所保留。</p><p id="e716" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后最重要的一点是，在进行任何api调用之前，在Global.asax.cs中更改服务点管理器。ServicePointManager一旦初始化，就会在应用程序的整个生命周期中以相同的配置保留在内存中，除非您为每个端点挑选ServicePoint对象。</p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4a51" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果这些改变也帮助你使你的Api更快，请分享。</p><p id="3fbd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">保持冷静，每个问题总有解决的办法，只要你努力去寻找！！！</p></div></div>    
</body>
</html>