<html>
<head>
<title>Dockerize a React app with Node.js backend connected to MongoDb</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用连接到MongoDb的Node.js后端对接一个React应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/dockerize-a-react-app-with-node-js-backend-connected-to-mongodb-63740fc0f9e7?source=collection_archive---------1-----------------------#2020-01-05">https://itnext.io/dockerize-a-react-app-with-node-js-backend-connected-to-mongodb-63740fc0f9e7?source=collection_archive---------1-----------------------#2020-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5fe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好亲爱的程序员，欢迎来到我的系列技术文章的最后一篇，献给<em class="kl"> Node.js </em>和<em class="kl"> Docker </em>。希望你喜欢！</p><p id="bae1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请找到系列的第一部分:<br/> 1。<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/dockerize-a-node-js-app-with-vs-code-bd471710dc22">“用VS代码Dockerize a node . js app”</a><br/>2。<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/dockerize-a-node-js-app-connected-to-mongodb-64fdeca94797"> " </a> <a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/dockerize-a-node-js-app-connected-to-mongodb-64fdeca94797">对接一个连接到MongoDb的node . js app</a>"</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/f62dc5e3aa868dec86d75eba02b66da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QT6KAYmJhU7iMRPTZUvWhQ.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">照片由<a class="ae km" href="https://unsplash.com/@kimsondoan" rel="noopener ugc nofollow" target="_blank"> Kimson Doan </a>在<a class="ae km" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="eda5" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">问题:</h1><p id="5e9d" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">我们已经从本系列的前一篇文章中了解了如何将Docker与Node和Mongo结合使用。为了完成我们的MERN堆栈应用程序，我们需要添加前端部分。在我们的例子中，frontend将使用React实现。让我们学习如何创建完整的前端，后端，数据库和运行Docker中的一切工作的应用程序！</p><h1 id="a4a5" class="lk ll iq bd lm ln mn lp lq lr mo lt lu lv mp lx ly lz mq mb mc md mr mf mg mh bi translated">1.克隆后端节点. js</h1><p id="9774" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">在本系列之前的<a class="ae km" href="https://dev.to/vguleaev/dockerize-a-node-js-app-connected-to-mongodb-5bp1" rel="noopener ugc nofollow" target="_blank">部分</a>中，我们使用MongoDb和Docker创建了一个Node.js应用程序。对于本教程，我们将需要相同的项目。从这里克隆<a class="ae km" href="https://github.com/vguleaev/Express-Mongo-Docker-tutorial" rel="noopener ugc nofollow" target="_blank">源代码</a>或者运行这个命令:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="1484" class="mx ll iq mt b gy my mz l na nb">git clone <a class="ae km" href="https://github.com/vguleaev/Express-Mongo-Docker-tutorial.git" rel="noopener ugc nofollow" target="_blank">https://github.com/vguleaev/Express-Mongo-Docker-tutorial.git</a></span></pre><p id="537b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">克隆完成后，将文件夹从<code class="fe nc nd ne mt b">test-mongo-app</code>重命名为<code class="fe nc nd ne mt b">api</code>。这将是我们的后端。</p><p id="9697" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试一切正常，打开<code class="fe nc nd ne mt b">api</code>文件夹并运行<code class="fe nc nd ne mt b">npm install</code>。安装完依赖项后，让我们检查一下是否一切正常。🍾</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="78c7" class="mx ll iq mt b gy my mz l na nb">docker-compose up</span></pre><p id="013e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个命令将使用我们的<code class="fe nc nd ne mt b">docker-compose.yml</code>来获取mongo映像并启动连接到MongoDb的express服务器。</p><p id="ec46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切正常，您应该在控制台中看到如下内容:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="93b4" class="mx ll iq mt b gy my mz l na nb">web_1 | Listening on 8080 <br/>web_1 | MongoDb connected</span></pre><p id="5296" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在浏览器中打开这个端点<a class="ae km" href="http://localhost:8080/users" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/users</a>，您应该得到一个空数组作为响应。这是正确的，因为我们的数据库现在完全是空的。</p><h1 id="5e1a" class="lk ll iq bd lm ln mn lp lq lr mo lt lu lv mp lx ly lz mq mb mc md mr mf mg mh bi translated">2.创建React应用</h1><p id="3dab" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">是时候开发我们的前端部分了。转到父目录并运行:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="9ceb" class="mx ll iq mt b gy my mz l na nb">npm i create-react-app -g <br/>create-react-app ui</span></pre><p id="877c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的文件夹结构应该是这样的:<br/><strong class="jp ir">…</strong><br/>├──/api<br/>└──/ui<br/>(<em class="kl">其中API是克隆的后端应用，ui是新创建的React应用。</em></p><p id="f48a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保一切正常，让我们打开<strong class="jp ir"> ui </strong>文件夹并启动React应用程序:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="e2aa" class="mx ll iq mt b gy my mz l na nb">cd ui<br/>npm start</span></pre><p id="c1c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你应该在<a class="ae km" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>看到基本的React app。🎈</p><h1 id="12c3" class="lk ll iq bd lm ln mn lp lq lr mo lt lu lv mp lx ly lz mq mb mc md mr mf mg mh bi translated">3.Dockerize React应用程序</h1><p id="2f90" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">在<strong class="jp ir"> ui的</strong>文件夹中创建一个<code class="fe nc nd ne mt b">.dockeringore</code>文件:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="67b4" class="mx ll iq mt b gy my mz l na nb">node_modules <br/>.git <br/>.gitignore</span></pre><p id="a105" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">(如果没有这个文件，我们的</em> <code class="fe nc nd ne mt b"><em class="kl">docker build</em></code> <em class="kl">命令将只是挂在Windows上。)</em></p><p id="59c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同时在<strong class="jp ir"> ui </strong>文件夹中创建一个<code class="fe nc nd ne mt b">Dockerfile</code>文件:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="5200" class="mx ll iq mt b gy my mz l na nb">FROM node:8<br/># Create app directory<br/>WORKDIR /usr/src/app<br/># Install app dependencies<br/>COPY package*.json ./<br/><br/>RUN npm install --silent<br/># Copy app source code<br/>COPY . .<br/><br/>#Expose port and start application<br/>EXPOSE 3000<br/>CMD ["npm", "start"]</span></pre><p id="c9b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们测试一下React在docker中的工作情况。首先，我们将使用标记react:app构建图像:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="e2e0" class="mx ll iq mt b gy my mz l na nb">docker build -t react:app .</span></pre><p id="01e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在运行我们的标记图像，并对docker使用相同的端口:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="5363" class="mx ll iq mt b gy my mz l na nb">docker run -p 3000:3000 react:app</span></pre><p id="57d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开<a class="ae km" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>，应该会看到Docker提供的React。👍</p><p id="8c23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">⚠️:如果你像往常一样用Ctrl+C关闭容器，它不会停止。要停止容器运行，执行<code class="fe nc nd ne mt b">docker ps</code>命令。</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="4c0f" class="mx ll iq mt b gy my mz l na nb">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES <br/>06c982ce6ae9 react:app "docker-entrypoint.s..." 12 days ago Up About a minute 0.0.0.0:3000-&gt;3000/tcp strange_montalcini</span></pre><p id="d5fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后选择所需的id并停止容器。</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="4c13" class="mx ll iq mt b gy my mz l na nb">docker stop 06c982ce6ae9</span></pre><h1 id="57fe" class="lk ll iq bd lm ln mn lp lq lr mo lt lu lv mp lx ly lz mq mb mc md mr mf mg mh bi translated">4.从React应用程序调用api</h1><p id="edd9" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">打开<strong class="jp ir"> ui </strong>文件夹，安装<code class="fe nc nd ne mt b">axios</code></p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="d358" class="mx ll iq mt b gy my mz l na nb">cd ui<br/>npm i axios</span></pre><p id="2489" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将稍微改变一下<code class="fe nc nd ne mt b">App</code>组件，让它有一个创建用户和显示用户id列表的按钮。我们将调用<em class="kl"> /user-create </em>和<em class="kl"> /users </em>从我们的Nodejs应用程序获取端点。</p><p id="2c01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将此粘贴到App.js文件中:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="dcd5" class="mx ll iq mt b gy my mz l na nb">import React, { Component } from 'react';<br/>import logo from './logo.svg';<br/>import axios from 'axios';<br/>import './App.css';<br/><br/>const apiUrl = `http://localhost:8080`;<br/><br/>class App extends Component {<br/>  state = {<br/>    users: []<br/>  };<br/><br/>  async createUser() {<br/>    await axios.get(apiUrl + '/user-create');<br/>    this.loadUsers();<br/>  }<br/><br/>  async loadUsers() {<br/>    const res = await axios.get(apiUrl + '/users');<br/>    this.setState({<br/>      users: res.data<br/>    });<br/>  }<br/><br/>  componentDidMount() {<br/>    this.loadUsers();<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;div className="App"&gt;<br/>        &lt;header className="App-header"&gt;<br/>          &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br/>          &lt;button onClick={() =&gt; this.createUser()}&gt;Create User&lt;/button&gt;<br/>          &lt;p&gt;Users list:&lt;/p&gt;<br/>          &lt;ul&gt;<br/>            {this.state.users.map(user =&gt; (<br/>              &lt;li key={user._id}&gt;id: {user._id}&lt;/li&gt;<br/>            ))}<br/>          &lt;/ul&gt;<br/>        &lt;/header&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<br/><br/>export default App;</span></pre><p id="6f3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们在端口3000上运行前端，但后端在端口8080上运行，我们将遇到一个<a class="ae km" href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" rel="noopener ugc nofollow" target="_blank"> CORS </a>问题。为了避免这种情况，请转到<strong class="jp ir"> api </strong>项目并安装cors包。</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="968f" class="mx ll iq mt b gy my mz l na nb">npm i cors</span></pre><p id="8179" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在<code class="fe nc nd ne mt b">server.js</code>文件中使用它:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="af53" class="mx ll iq mt b gy my mz l na nb">const express = require('express');<br/>const app = express();<br/>const connectDb = require('./src/connection');<br/>const User = require('./src/User.model');<br/>const cors = require('cors');<br/><br/>app.use(cors());<br/>// ...</span></pre><h1 id="ded9" class="lk ll iq bd lm ln mn lp lq lr mo lt lu lv mp lx ly lz mq mb mc md mr mf mg mh bi translated">5.在Docker中一起运行React和Node</h1><p id="8ec2" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">最后一步！现在从目录<strong class="jp ir"> api </strong>中移除<code class="fe nc nd ne mt b">docker-compose.yml</code>并在根文件夹中创建<code class="fe nc nd ne mt b">docker-compose.yml</code>。粘贴这个:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="5ee2" class="mx ll iq mt b gy my mz l na nb">version: '2'<br/>services:<br/>  ui:<br/>    build: ./ui<br/>    ports:<br/>      - '3000:3000'<br/>    depends_on:<br/>      - api<br/>  api:<br/>    build: ./api<br/>    ports:<br/>      - '8080:8080'<br/>    depends_on:<br/>      - mongo<br/>  mongo:<br/>    image: mongo<br/>    ports:<br/>      - '27017:27017'</span></pre><p id="db3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的根文件夹结构现在看起来是这样的:<br/><strong class="jp ir">…</strong><br/>├──/API<br/>├──/ui<br/>└──docker-compose . yml</p><p id="f305" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有一个docker-compose，它描述了我们希望在docker中运行的服务。在我们的例子中，我们有三个服务:<strong class="jp ir"> ui、api、mongo </strong>。🐋</p><p id="fb44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每个服务，将在每个项目中使用<code class="fe nc nd ne mt b">Dockerfile</code>创建docker图像。我们在行构建中指定路径。(例如<code class="fe nc nd ne mt b">build: ./ui</code>)</p><p id="a71a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<strong class="jp ir"> mongo </strong>我们没有构建图像的项目，因为我们使用来自docker <a class="ae km" href="https://hub.docker.com/_/mongo/" rel="noopener ugc nofollow" target="_blank"> hub </a>的预定义图像。(如<code class="fe nc nd ne mt b">image: mongo</code>)</p><p id="2ab2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还指定端口和依赖项。在我们的例子中，首先将在端口<em class="kl"> 27017 </em>上启动<strong class="jp ir"> mongo </strong>，因为api依赖于mongo。第二个容器是端口<em class="kl"> 8080 </em>上的<strong class="jp ir"> api </strong>，因为<strong class="jp ir"> ui </strong>依赖于它。最后一个容器是从端口<em class="kl"> 3000 </em>开始的<strong class="jp ir"> ui </strong>。</p><p id="74bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，从根文件夹运行所有的服务与一个命令！🧙</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="612b" class="mx ll iq mt b gy my mz l na nb">docker-compose up --build</span></pre><p id="0c7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开<a class="ae km" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>点击按钮创建用户。打开开发者工具查看调用。现在我们从docker运行前端和后端！</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nf"><img src="../Images/9ed33fe936797edee8f721711c19c7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DHA88hJ_qJFRZYoB.PNG"/></div></div></figure><h1 id="498c" class="lk ll iq bd lm ln mn lp lq lr mo lt lu lv mp lx ly lz mq mb mc md mr mf mg mh bi translated">6.使用React生产构建</h1><p id="68a9" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">现在，我们用开发服务器启动React应用程序，这可能不是我们想要在生产中使用的。但是我们可以很容易地解决这个问题。</p><p id="d25d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只需要在<strong class="jp ir"> ui </strong>项目中改变我们的<code class="fe nc nd ne mt b">Dockerfile</code>。我们将启动一个生产构建，并使用nginx服务器为其提供服务。将所有内容替换为:</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="ed0d" class="mx ll iq mt b gy my mz l na nb"># build environment<br/>FROM node:12.2.0-alpine as build<br/>WORKDIR /app<br/>ENV PATH /app/node_modules/.bin:$PATH<br/>COPY package.json /app/package.json<br/>RUN npm install --silent<br/>RUN npm install react-scripts@3.0.1 -g --silent<br/>COPY . /app<br/>RUN npm run build<br/><br/># production environment<br/>FROM nginx:1.16.0-alpine<br/>COPY --from=build /app/build /usr/share/nginx/html<br/>EXPOSE 80<br/>CMD ["nginx", "-g", "daemon off;"]</span></pre><p id="9561" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们现在暴露了端口80，我们需要在<code class="fe nc nd ne mt b">docker-compose.yml</code>将它从3000改为80。</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="4629" class="mx ll iq mt b gy my mz l na nb">ui:<br/>    build: ./ui<br/>    ports:<br/>      - '80:80'<br/>    depends_on:<br/>      - api</span></pre><p id="3a9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在再次运行神奇的命令来启动docker中的一切🔮</p><pre class="ko kp kq kr gt ms mt mu mv aw mw bi"><span id="73ac" class="mx ll iq mt b gy my mz l na nb">docker-compose up --build</span></pre><p id="9253" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开<a class="ae km" href="http://localhost/" rel="noopener ugc nofollow" target="_blank"> http://localhost/ </a>，您应该看到完全相同的工作应用程序，但是现在React正在生产模式下运行。</p><p id="5201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里看到<a class="ae km" href="https://github.com/vguleaev/React-Express-Mongo-Docker-tutorial/tree/master/react-express-mongo-app" rel="noopener ugc nofollow" target="_blank">源代码</a>。尽情享受吧！</p><p id="3081" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">恭喜你成功注册了React，Nodejs和Mongodb！🎉🎉🎉</p><p id="66b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀如果你从那篇文章中读到了一些有趣的东西，请喜欢并关注我的更多帖子。谢谢你亲爱的编码员！😏</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="bad8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于2020年1月5日</em><a class="ae km" href="https://dev.to/vguleaev/dockerize-a-react-app-with-node-js-backend-connected-to-mongodb-10ai" rel="noopener ugc nofollow" target="_blank"><em class="kl">https://dev . to</em></a><em class="kl">。</em></p></div></div>    
</body>
</html>