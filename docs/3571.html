<html>
<head>
<title>GraphQL performance tip: Select fields from requests all the way from the database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL性能提示:从数据库的所有请求中选择字段</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-performance-tip-database-projection-82795e434b44?source=collection_archive---------1-----------------------#2020-01-10">https://itnext.io/graphql-performance-tip-database-projection-82795e434b44?source=collection_archive---------1-----------------------#2020-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="78c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GraphQL的真正力量..指定从客户端请求一直到数据库的请求字段。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ea7ba5850be86b1c3cb44479b961d5a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eaVM-IJvQiWFEEscw2eIrg.png"/></div></div></figure><h2 id="9392" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">问题是</h2><p id="4e4d" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">GraphQL最强大的特性之一是客户端能够指定从响应返回的字段，从而减少通过网络传输的数据，从而避免数据溢出。</p><p id="5050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们真的在做更少的工作吗？后端服务器和数据库仍然必须完成查询数据库的所有工作，获取所请求对象的所有字段，然后只通过graph QL/网络层返回所请求的字段。</p><p id="0250" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们只是通过发送较小的响应来节省网络时间，但是我们的后端服务器和数据库仍然在做额外的不必要的工作来获取所请求对象的所有字段。这实际上是浪费了大量时间，而我们有可能优化这些时间。</p><h2 id="3406" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">解决办法</h2><p id="f863" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">如果有一种方法可以确定客户机请求了哪些字段，并从数据库层只返回这些字段，那会怎么样？</p><p id="674c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数现代数据库提供“投影”或“选择”特征，其中数据库驱动程序允许消费者指定应该从匹配数据库查询的文档中返回哪些字段，以避免返回所有不必要的字段，并加快对数据库的查询。</p><p id="f82a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对数据库查询性能有相当大的影响，因为它避免了不必要的工作，如果你想知道潜在的节省可能是什么样子，看看我之前写的<a class="ae lv" href="https://medium.com/faun/performance-tips-for-mongodb-mongoose-190732a5d382" rel="noopener">这篇文章</a>，它展示了MongoDB中有/没有投影的一些性能指标。</p><div class="lw lx gp gr ly lz"><a href="https://medium.com/faun/performance-tips-for-mongodb-mongoose-190732a5d382" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">如何优化MongoDB &amp; Mongoose的性能</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">提高API和数据库响应时间和性能的技巧</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kv lz"/></div></div></a></div><h2 id="840b" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">阿波罗-服务器的解析功能</h2><p id="68eb" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">因此，我们有可能从网络层以及数据库层做到这一点，唯一缺少的是在我们的服务器/解析器中找出它。</p><p id="e33b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用<a class="ae lv" href="https://github.com/apollographql/apollo-server" rel="noopener ugc nofollow" target="_blank"> apollo-server </a>编写的graphQL解析器函数通常有四个输入参数。<code class="fe mo mp mq mr b">root</code>、<code class="fe mo mp mq mr b">args</code>、<code class="fe mo mp mq mr b">context</code>和<code class="fe mo mp mq mr b">info</code>。例如，如果我们要编写一个从数据库返回所有用户的解析器，它看起来会像这样:</p><pre class="km kn ko kp gt ms mr mt mu aw mv bi"><span id="4233" class="kx ky iq mr b gy mw mx l my mz">resolvers = {</span><span id="c718" class="kx ky iq mr b gy na mx l my mz">  getUsers: function (root, args, context, info) {<br/>    const User = mongoose.model('User')</span><span id="c429" class="kx ky iq mr b gy na mx l my mz">    return User.find({})</span><span id="7faf" class="kx ky iq mr b gy na mx l my mz">  }</span><span id="1afe" class="kx ky iq mr b gy na mx l my mz">}</span></pre><p id="857b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mo mp mq mr b">root</code>对象通常是模式中该请求操作/字段的父对象。<code class="fe mo mp mq mr b">args</code>是传递给该操作的任何参数，<code class="fe mo mp mq mr b">context</code>包括传递给上下文对象的任何参数(通常用于认证)。然而，<code class="fe mo mp mq mr b">info</code>物体呢？它似乎包含了一些关于传入请求的信息。</p><p id="4dbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我在apollographql.com查阅了它的文档，这就是我所发现的</p><blockquote class="nb nc nd"><p id="f312" class="jn jo ne jp b jq jr js jt ju jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj kk ij bi translated">Info:这个参数应该只在高级情况下使用，但是它包含关于查询的执行状态的信息，包括字段名、从根到字段的路径等等。它只记录在GraphQL.js源代码中。</p></blockquote><p id="8680" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不是很有帮助，但是我认为它可能包括关于传入请求和被请求字段的所需信息，在查看在线库之后，我发现了graphql-fields。</p><h2 id="fa45" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">图表QL-字段</h2><p id="d007" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">我遇到了<a class="ae lv" href="https://github.com/robrichard/graphql-fields" rel="noopener ugc nofollow" target="_blank"> graphql-fields </a>，它可以根据<code class="fe mo mp mq mr b">info</code>参数返回请求的字段，它还可以处理高级情况，如联合类型、片段、子字段等..</p><p id="7176" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这样一个返回所有用户姓名和电子邮件的查询，它能做的如下</p><pre class="km kn ko kp gt ms mr mt mu aw mv bi"><span id="abe8" class="kx ky iq mr b gy mw mx l my mz">{</span><span id="d349" class="kx ky iq mr b gy na mx l my mz">  users {</span><span id="010f" class="kx ky iq mr b gy na mx l my mz">    name</span><span id="935a" class="kx ky iq mr b gy na mx l my mz">    email</span><span id="ea08" class="kx ky iq mr b gy na mx l my mz">  }</span><span id="8e0b" class="kx ky iq mr b gy na mx l my mz">}</span></pre><p id="902f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将是结果:['姓名'，'电子邮件']</p><p id="dcb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">用法:</strong></p><pre class="km kn ko kp gt ms mr mt mu aw mv bi"><span id="f108" class="kx ky iq mr b gy mw mx l my mz">const graphqlFields = require(‘graphql-fields’);<br/>function userResolver(root, args, context, info) {</span><span id="01e6" class="kx ky iq mr b gy na mx l my mz">  const topLevelFields = Object.keys(graphqlFields(info));<br/>  console.log(topLevelFields)<br/>  // prints [‘name’, ‘email’]<br/>}</span></pre><p id="5f3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，现在我们可以使用这个结果从数据库中只选择这些字段，而不是从数据库中为每个用户请求整个用户文档。</p><h2 id="cc91" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">使用结果</h2><p id="d83f" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在我的例子中，我使用MongoDB和<a class="ae lv" href="https://github.com/Automattic/mongoose" rel="noopener ugc nofollow" target="_blank">mongose</a>作为数据库驱动程序，因此mongose投影所需的语法看起来与我从<code class="fe mo mp mq mr b">graphql-fields</code>得到的结果略有不同。</p><p id="1661" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想要实现的等价查询如下所示:<code class="fe mo mp mq mr b">User.find({}).select({name: 1, email: 1}).lean()</code></p><p id="63d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以将来自<code class="fe mo mp mq mr b">graphql-fields</code>的结果转换为mongoose所需的选择对象的辅助函数可以编写如下:</p><pre class="km kn ko kp gt ms mr mt mu aw mv bi"><span id="31d7" class="kx ky iq mr b gy mw mx l my mz">export function getMongooseSelectionFromSelectedFields (info, fieldPath = null) {</span><span id="202b" class="kx ky iq mr b gy na mx l my mz">  const selections = graphqlFields(info)</span><span id="d836" class="kx ky iq mr b gy na mx l my mz">  const mongooseSelection = Object<br/>  .keys(fieldPath ? selections[fieldPath] : selections)<br/>  .reduce((a, b) =&gt; ({ …a, [b]: 1   }), {})</span><span id="d7b9" class="kx ky iq mr b gy na mx l my mz">  return mongooseSelection</span><span id="2002" class="kx ky iq mr b gy na mx l my mz">}</span></pre><p id="40e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">瞧，现在客户端请求的字段就是数据库请求并返回的字段，这使得我们的解析器速度大大加快！</p><p id="aec8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这与<a class="ae lv" href="https://www.apollographql.com/docs/apollo-server/performance/apq/" rel="noopener ugc nofollow" target="_blank">自动持久化查询(APQ) </a>和<a class="ae lv" href="https://www.apollographql.com/docs/apollo-server/performance/caching/" rel="noopener ugc nofollow" target="_blank">缓存</a>完美配合。另外两场表演轻松获胜。</p><p id="1097" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我添加了一个fieldPath参数来支持响应中的一级嵌套，以防从数据库请求数据的操作不是顶级操作。</p><p id="cb4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是新解析器的外观:</p><pre class="km kn ko kp gt ms mr mt mu aw mv bi"><span id="1c7c" class="kx ky iq mr b gy mw mx l my mz">resolvers = {</span><span id="10a9" class="kx ky iq mr b gy na mx l my mz">  getUsers: function (root, args, context, info) {<br/>    const mongooseSelection = getMongooseSelectionFromRequest(info)</span><span id="7d9f" class="kx ky iq mr b gy na mx l my mz">    return User.find({}).select(mongooseSelection).lean()</span><span id="ae15" class="kx ky iq mr b gy na mx l my mz">  }</span><span id="7fdc" class="kx ky iq mr b gy na mx l my mz">}</span></pre><h2 id="522d" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">结论</h2><p id="c455" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">GraphQL非常强大，它不仅可以优化客户端应用程序的性能，还可以用来优化后端性能，毕竟我们可以免费获得解析器中特别请求的字段。</p></div></div>    
</body>
</html>