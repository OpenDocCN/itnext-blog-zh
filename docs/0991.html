<html>
<head>
<title>Data structures in JS: Binary Trees React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS中的数据结构:二叉树反应应用</h1>
<blockquote>原文：<a href="https://itnext.io/data-structures-in-js-binary-trees-react-app-5443b951a46b?source=collection_archive---------3-----------------------#2018-06-29">https://itnext.io/data-structures-in-js-binary-trees-react-app-5443b951a46b?source=collection_archive---------3-----------------------#2018-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1522f22e9ee330a1a2795bd97ab87832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFa9JoR3zl8GfOGhNZBm-w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序的屏幕截图</figcaption></figure><p id="7af8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是JavaScript数据结构系列的第三部分。这是出版物的索引:</p><ul class=""><li id="d6b4" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/data-structures-in-js-hash-tables-app-with-react-b28b02a9e6b5">第1部分(散列表)</a></li><li id="eba0" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/@alonso.oliverio/data-structures-in-js-part-2-double-linked-lists-150facd7a90d" rel="noopener">第二部分(双向链表)</a></li><li id="0eac" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/@alonso.oliverio/data-structures-in-js-binary-trees-react-app-5443b951a46b" rel="noopener">第三部(二叉树)</a></li></ul><p id="b9ef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和前面一样，我用React创建了一个交互式SPA来理解二叉树的行为。</p><h1 id="06d2" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">二叉树是如何工作的？</h1><p id="ed76" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">二叉树由二进制节点形成，在这种情况下，二进制节点具有一对{Key，Value}，一个到左节点的链接和一个到右节点的链接。</p><p id="b967" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第一个节点名为root，像每个节点一样，有两个子节点。根的左子节点中的节点的键总是小于根的键。左侧子对象的关键点总是高于根对象的关键点。在上面的图片中你可以看到。</p><p id="76cd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在每次插入中递归地应用这些条件，直到找到一个具有实现它们的自由链接的节点。</p><p id="029d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">叶子是没有孩子的节点。下面是节点类:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c241" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很简单。二进制树数据甚至更简单:</p><pre class="ms mt mu mv gt my mz na nb aw nc bi"><span id="d42b" class="nd lq iq mz b gy ne nf l ng nh">class BinaryTreeNode {<br/>  constructor() {<br/>    this.root = null;<br/>  }<br/>  …<br/>}</span></pre><p id="c5d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">唯一的参考是根。它充当每个方法的入口点。</p><p id="e87e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好吧，让我们看看插入是如何工作的:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e3ef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第一个实例中，您用一个键/值对调用insert函数。它执行一些基本的检查，然后调用insertNode函数。它接收需要迭代的节点和要插入的节点。一旦该函数被调用，它将执行三重条件比较键:</p><ul class=""><li id="41dc" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">新节点低于入口点。如果左边的子节点是空闲的，那么newNode被赋值，否则，递归地检查左边的节点。</li><li id="f2cf" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">新节点高于入口点。相同的工作流，但在正确的节点。</li><li id="7f22" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">新节点键等于入口点键。在这种情况下，一个节点也具有所选的键，并且该值被覆盖。</li></ul><p id="15bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第二种方法是独立的，因为它被反复调用，并且不需要在每次迭代中检查先决条件。让我们使用删除方法:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d7d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">remove方法检查先决条件，并使用root作为入口点和该方法返回值的接收者来调用removeNode。</p><p id="8280" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RemoveNode像insertion一样递归工作，并且有一个类似的工作流。主要的区别出现在找到节点的时候。如果它是一片叶子，工作就完成了，在其他情况下，我们必须重新构建我们要删除的节点的子节点。</p><p id="3360" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种方法的圈复杂度是2n，因为我们必须寻找和重建。现在让我们检查查找方法:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6792" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">像insert方法一样，find的复杂度为O(log2 n ),因为你不需要遍历每一棵树的元素。算法很好理解。它递归地遍历childs，直到找到想要的节点。</p><p id="3611" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">二叉树有<strong class="ke ir"> 4条不同的路径</strong>:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><ul class=""><li id="85b1" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><strong class="ke ir">为了</strong>:接收一个入口点和一个要执行的函数，它递归地去左边的节点，然后是根(在它上面执行函数)，最后通过右边的节点。这些树目前的行为和排列。Inorder会做一个排序路径，因为在左树中会有较小的键。</li><li id="e3a8" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">前序</strong>:相同的行为，但是首先在节点上执行函数，然后递归地在左右节点上执行。</li><li id="2f83" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">后序</strong>:左右节点先递归运行，根是最后一个。</li></ul><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><ul class=""><li id="008d" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><strong class="ke ir">等级顺序:</strong>通俗易懂。从左到右。一旦它运行了整个级别，然后继续下一个级别，并迭代直到最后一个级别。这是理论，在实践中，我有一个长度为2^(level-1).的数组用于每一层在级别中，每个节点都有一个索引来引用其子节点，并知道将它们存储在级别数组中的什么位置。</li></ul><p id="a8b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个级别数组将填充n个元素，长度为n的元素为空。它们至少填充了1个元素。</p><p id="1e5b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们用一个例子来解释它们:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/0ba4166bab4f55a5a1d3f16d8afee29d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQ1t6ZVjdR9rNvpegFC4Qg.png"/></div></div></figure><p id="d6aa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">按顺序</strong> : 1 3 4 6 7 8 10 13 14</p><p id="4ae4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">预订</strong> : 8 3 1 6 4 7 10 14 13</p><p id="0ca5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">后序</strong> : 1 4 7 6 3 13 14 10 8</p><p id="3b3b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">等级顺序</strong> : [ [8]，[3，10]，[1，6，''，14]，[''，''，4，7，' '，13，' ']]；</p><p id="7cac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4级 4个阵列</p><p id="dd4d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在n级中，levelArray具有2^(n-1长度。在第4级:2 =8，所以8个项目。</p><h1 id="0206" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">什么时候以及为什么应该使用二叉树？</h1><p id="e779" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">有了每个节点中的一个<key>对，我们就可以在值中存储<strong class="ke ir">所有的</strong>，同时将键用于方法目的。在最坏的情况下，insert或find的复杂度是O(log2 n ),因为您不必遍历每个元素来找到您想要的元素。在上面的例子中，如果它是一个排序数组，你想找到元素13，你应该在找到13之前遍历6个元素。在树中，你只需要通过根，10和14。二叉树的排序方法是节省大量搜索时间的关键。插入函数具有相同的行为和开销，而删除函数的开销要大一些，O(n ),因为你必须重建被删除节点的子节点。但是在数组中，你还必须处理O(n)代价。</key></p><p id="3b7b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里唯一的限制是密钥的排他性。不能有重复的项目。但是，您可以在值中存储您想要的任何内容，因此根据您的需要，您可以存储类似于值数组的内容，并进行多次插入。在这种情况下，您应该修改该方法。</p><h1 id="3117" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">在哪里可以查看代码和应用程序？</h1><p id="9cca" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">应用程序存储在Heroku:</p><div class="nj nk gp gr nl nm"><a href="https://binary-trees-app.herokuapp.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">二叉树反应App @boxgames1</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">编辑描述</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">binary-trees-app.herokuapp.com</p></div></div></div></a></div><p id="de28" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">代码在Github里。请随时给我发送变化，改进或任何你认为有趣的拉请求。我对合作持开放态度。</p><div class="nj nk gp gr nl nm"><a href="https://github.com/boxgames1/binary-trees-app" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">box games 1/二叉树应用程序</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">这个应用程序展示了二叉树的行为</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jw nm"/></div></div></a></div><p id="617d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在推特上找到我<a class="ae lj" href="https://twitter.com/Oliver_AP" rel="noopener ugc nofollow" target="_blank"> (@Oliver_ap) </a></p></div></div>    
</body>
</html>