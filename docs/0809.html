<html>
<head>
<title>ReasonML: Create Bindings for NPM Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">原因:为NPM包创建绑定</h1>
<blockquote>原文：<a href="https://itnext.io/reasonml-create-bindings-for-npm-package-b8a3c6d0703e?source=collection_archive---------2-----------------------#2018-06-01">https://itnext.io/reasonml-create-bindings-for-npm-package-b8a3c6d0703e?source=collection_archive---------2-----------------------#2018-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c3cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ReasonML正在上升。最近的https://www.reason-conf.com/显示，许多人对这种来自脸书的语言感兴趣。</p><p id="eeab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以非常容易地将ReasonML添加到现有的JavaScript/TypeScript项目中，并获得强类型语言的全部好处，但许多库是用JS编写的，并发布到NPM。要从ReasonML中使用它们，您必须提供到包的绑定。有许多为不同库创建的绑定，例如:<a class="ae kl" href="https://github.com/reasonml-community/bs-moment" rel="noopener ugc nofollow" target="_blank">为MomentJS创建的绑定。</a></p><p id="4abf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将向你展示如何从头开始创建绑定，以及如何在你的ReasonML项目中使用它们:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/b91044e12ad67eee0974aa44284754b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWc0ahnd7TzbDSuLjKMN5w.png"/></div></div></figure><h1 id="fc6e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">入门指南</h1><p id="b6f1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">ReasonML提供了从ReasonML到/从JavaScript world的一个非常薄的绑定层。一个很好的起点是正式的BuckleScript文档。</p><p id="2870" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将为NPM官方的semver包编写绑定。</p><p id="c28c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个包公开了不同的函数，我们还可以实例化Semver类，就像这个JavaScript示例中一样:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="ed7d" class="mg kz iq mc b gy mh mi l mj mk">const semver <strong class="mc ir">=</strong> require('semver')</span><span id="7b4a" class="mg kz iq mc b gy ml mi l mj mk">semver.valid('1.2.3') <em class="mm">// '1.2.3'</em></span><span id="884b" class="mg kz iq mc b gy ml mi l mj mk">semver.valid('a.b.c') <em class="mm">// null</em></span><span id="4b37" class="mg kz iq mc b gy ml mi l mj mk">semver.clean('  =v1.2.3   ') <em class="mm">// '1.2.3'</em></span><span id="8fa9" class="mg kz iq mc b gy ml mi l mj mk">semver.satisfies('1.2.3', '1.x || &gt;=2.5.0 || 5.0.0 - 7.2.3') <em class="mm">// true</em></span></pre><h2 id="fa60" class="mg kz iq bd la mn mo dn le mp mq dp li jy mr ms lm kc mt mu lq kg mv mw lu mx bi translated">创建新的NPM包</h2><p id="64f4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">运行命令</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="50a3" class="mg kz iq mc b gy mh mi l mj mk">npm init</span></pre><p id="482f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将启动一个向导，创建一个新的NPM包。提供您想要的任何信息，只需给它一个带前缀“bs”(BuckleScript)的好名字。“bs”是BuckleScript或ReasonML绑定的社区约定。</p><p id="11d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建文件夹“src”:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="728e" class="mg kz iq mc b gy mh mi l mj mk">mkdir src</span></pre><p id="c7bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将包含我们绑定的所有源代码。</p><p id="2a0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建文件夹“__tests__ ”:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="82ef" class="mg kz iq mc b gy mh mi l mj mk">mkdir __tests__</span></pre><p id="2c83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将包含由<a class="ae kl" href="https://github.com/glennsl/bs-jest" rel="noopener ugc nofollow" target="_blank"> bs-jest库</a>执行的绑定测试。</p><h2 id="0837" class="mg kz iq bd la mn mo dn le mp mq dp li jy mr ms lm kc mt mu lq kg mv mw lu mx bi translated">添加bsconfig.json</h2><p id="7169" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">为了让我们的包与ReasonML编译器一起工作，我们必须添加一个bsconfig.json。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="dc73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的导入属性:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="1dd4" class="mg kz iq mc b gy mh mi l mj mk">name: '@gladimdim/bs-semver'</span></pre><p id="42eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">必须与您的package.json中的完全相同。</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="17e1" class="mg kz iq mc b gy mh mi l mj mk">sources: [...src....__tests__....]</span></pre><p id="2612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">指定将哪些文件夹编译成JavaScript代码。Tests文件夹的类型是“dev ”,所以它不会出现在建议中，也不会被编译到包中。</p><h2 id="d50d" class="mg kz iq bd la mn mo dn le mp mq dp li jy mr ms lm kc mt mu lq kg mv mw lu mx bi translated">编辑包. json</h2><p id="c007" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在打开package.json，我们必须向它添加一些特定于绑定的属性。</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="e19b" class="mg kz iq mc b gy mh mi l mj mk">"scripts": {<br/>  "clean": "bsb -clean-world", <br/>  "build": "bsb -make-world",<br/>  "watch": "bsb -make-world -w",<br/>  "test": "jest"<br/>},</span></pre><p id="ba77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些是脚本，用于构建、编译、测试和运行观察器。</p><p id="985e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提供开发部门:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="3f39" class="mg kz iq mc b gy mh mi l mj mk">"devDependencies": { <br/>  "bs-platform": "^3.0.0",  <br/>  "jest": "22.1.2", <br/>  "@glennsl/bs-jest": "0.3.2" <br/>},</span></pre><p id="a4ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，您必须提供“真正的”JavaScript NPM包dep，如“jest”，因为它们包含真正的代码，这些代码将在测试或编译任务期间由“bs-jest”的绑定使用。</p><p id="0556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在告诉NPM要包括哪些文件:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="ac26" class="mg kz iq mc b gy mh mi l mj mk">"files": [   <br/>  "src/semver.re", <br/>  "bsconfig.json"<br/> ]</span></pre><p id="123b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是应该发布到NPM注册中心的内容。包含bsconfig.json很重要，因为最终用户的构建过程会用到它。</p><h2 id="2e06" class="mg kz iq bd la mn mo dn le mp mq dp li jy mr ms lm kc mt mu lq kg mv mw lu mx bi translated">指定目标NPM程序包的对等依赖项</h2><p id="9c95" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当我们为semver包创建绑定时，我们必须告诉NPM让它成为一个对等依赖。我们的软件包的最终用户必须向我们提供这种对等依赖。</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="127f" class="mg kz iq mc b gy mh mi l mj mk">"peerDependencies": {    "semver": "^5.5.0"  },</span></pre><h1 id="4429" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何编写绑定</h1><p id="5a80" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在src文件夹中，创建一个名为“semver.re”的文件。这将是我们的主要和唯一的文件绑定。</p><p id="3081" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们为函数“clean”编写绑定，该函数作为semver包中的一个独立函数公开。</p><p id="d7df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们编写clean函数的主体之前，我们需要深入了解JS的可怕世界:</p><p id="ddfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你必须在运行时检查这些函数在现实生活中返回什么。</p><p id="94ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个npm软件包页面都有一个“使用RunKit测试”按钮，您可以使用它来调用函数，而无需安装软件包:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi na"><img src="../Images/c3099a99196a2e2be3bfef33f2699d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4hBNwdBskluPQKGKLPKUA.png"/></div></div></figure><p id="371e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数“clean”的问题如下:如果它无法解析输入的semver版本，它可能返回有效的semver字符串或null。所以，从理性的角度来看，这个函数的结果是一个选项。它要么返回字符串，要么不返回任何内容(None)。</p><p id="32b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用指令<strong class="jp ir"> @bs.module和@bs.val </strong>来表示，下一个函数没有ReasonML主体。相反，它将取自JavaScript世界。更多信息请阅读官方文档:<a class="ae kl" href="https://bucklescript.github.io/docs/en/intro-to-external.html" rel="noopener ugc nofollow" target="_blank">https://bucklescript . github . io/docs/en/intro-to-external . html</a></p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="be60" class="mg kz iq mc b gy mh mi l mj mk">[@bs.module "semver"] [@bs.val] <br/>external <strong class="mc ir">clean</strong> : string =&gt; Js.nullable(string) = "clean";<br/>let <strong class="mc ir">clean</strong> = a =&gt; clean(a) |&gt; Js.Nullable.toOption;</span></pre><p id="d3ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二行中的类型签名的含义如下:函数“clean”接受一个字符串作为输入参数，并输出一个字符串或null。指令@ bs . module“SEM ver”和“clean”会将其转换为JavaScript:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="0d3c" class="mg kz iq mc b gy mh mi l mj mk">semver.clean() </span></pre><p id="6400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以让它保持原样，但是我们想让这个函数的返回类型更加合理规范，并使用选项类型。这就是为什么在第3行我们有这个函数的主体。它以如下方式读取:函数“clean”获取参数a，将其发送到“clean”(SEM ver包中的JavaScript函数)，然后将其结果通过管道传输到toOption converter。ReasonML将从“外部清理”声明中继承类型定义，因此您不必重复它们。</p><p id="ff22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的ReasonML函数“clean”的输出将是一个字符串类型的选项。</p><p id="cb5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们编写绑定测试。在__tests__文件夹中创建一个文件semver_spec.re，其内容如下:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="73a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">semver模块将从我们的semver.re文件中自动加载。请记住，我们不测试Semver功能，我们测试我们的绑定。所以我们只需要验证，我们的绑定返回可选类型，结果是字符串。</p><p id="f0c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以从官方文档继续讨论其他简单的方法到SEM ver:<a class="ae kl" href="https://github.com/npm/node-semver" rel="noopener ugc nofollow" target="_blank">https://github.com/npm/node-semver</a></p><h1 id="b341" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何为“字符串”枚举创建类型</h1><p id="2181" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">函数<strong class="jp ir"> semver.cmp(a，c，b) </strong>接受3个参数:第一个版本，操作(字符串)，第二个版本。</p><p id="3a4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">绑定到它看起来像这样:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9030" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，第二个参数称为“操作”，它只能是特定“操作”集合中的字符串。比如:“、≤、≥、==、！== "等等。</p><p id="c475" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ReasonML中的用法如下:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="38a2" class="mg kz iq mc b gy mh mi l mj mk">Semver.cmp("1.5.0", "&lt;", "2.3.5");</span></pre><p id="60e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过定义第二个参数"</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="af15" class="mg kz iq mc b gy mh mi l mj mk">Semver.cmp("1.5.0", "hello", "2.3.5");</span></pre><p id="81a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">We could leave it as a string type, but in ReasonML I always prefer to have types for such important arguments.</p><p id="504d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">We have to introduce a type, which has take only valid for ‘cmp’ method strings:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="4117" class="mg kz iq mc b gy mh mi l mj mk">type comparator =  | LooseEqual  | LooseNotEqual  | Equal  | Empty  | NotEqual  | Gt  | Gte  | Lt  | Lte;</span></pre><p id="5193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">And to write a function, which converts these types into strings, as JavaScript expects a string as an input:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Now, enhance our binding:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a97c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">This ReasonML code will return a compilation error:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="bd8d" class="mg kz iq mc b gy mh mi l mj mk">Semver.cmp("1.5.0", "hello", "2.3.0");</span></pre><p id="ce21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">We have to reuse the provided type Semver.Gt:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="d001" class="mg kz iq mc b gy mh mi l mj mk">Semver.cmp("1.5.0", Semver.Gt, "2.3.0");</span></pre><p id="6ee0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">The binding will convert Semver.Gt into “&gt;"并将其发送给外部的' real '，JavaScript函数。</p><h1 id="0a5e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为Semver类创建类型</h1><p id="cbb5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Semver包还提供了实例化Semver类的可能性:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="ce8c" class="mg kz iq mc b gy mh mi l mj mk">const s = new semver("1.5.0");<br/>s.minor(); // 5</span></pre><p id="dcbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在ReasonML中定义一个类类型来覆盖所有的“semver”对象属性:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="62d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们添加“createSemver”函数，它将帮助我们使一切都是类型安全的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="59b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用法:</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="d902" class="mg kz iq mc b gy mh mi l mj mk">let a = Semver.createSemver("1.5.0");<br/>Js.log(a##minor); // 5</span></pre><h1 id="465d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="d5de" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我希望，这篇文章能帮助你为其他包创建你自己的类型。为<a class="ae kl" href="https://github.com/reasonml-community/bs-moment" rel="noopener ugc nofollow" target="_blank">https://github.com/reasonml-community/bs-moment</a>、<a class="ae kl" href="https://github.com/glennsl/bs-jest" rel="noopener ugc nofollow" target="_blank">https://github.com/glennsl/bs-jest</a>提供了很好的绑定。您可以查看它们的源代码，以获得关于如何编写绑定的更多见解。这其实就是我做的:-)</p><h2 id="9e2d" class="mg kz iq bd la mn mo dn le mp mq dp li jy mr ms lm kc mt mu lq kg mv mw lu mx bi translated">原因周刊时事通讯</h2><p id="3a59" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">要了解ReasonML的最新消息，您可以关注我们的Twitter:<a class="ae kl" href="https://twitter.com/@WeeklyReason," rel="noopener ugc nofollow" target="_blank">https://twitter.com/@WeeklyReason,</a>并订阅我们的每周简讯:<a class="ae kl" href="http://news.reasonml.online." rel="noopener ugc nofollow" target="_blank">https://news . reason ml . online</a>。</p><p id="5376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">bs-semver绑定的GitHub repo:<a class="ae kl" href="https://github.com/gladimdim/bs-semver" rel="noopener ugc nofollow" target="_blank">https://github.com/gladimdim/bs-semver</a></p><h1 id="1b1e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">谢谢</h1><p id="b068" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">非常感谢<a class="ae kl" href="https://twitter.com/RCTucker88" rel="noopener ugc nofollow" target="_blank">瑞安·塔克</a>的指正！</p></div></div>    
</body>
</html>