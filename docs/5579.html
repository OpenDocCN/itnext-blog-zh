<html>
<head>
<title>Using Matplotlib to Plot a Live Graph of Benford’s Law in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Matplotlib在Python中绘制Benford定律的动态图</h1>
<blockquote>原文：<a href="https://itnext.io/using-matplotlib-to-plot-a-live-graph-of-benfords-law-in-python-79ec2e987694?source=collection_archive---------1-----------------------#2021-04-08">https://itnext.io/using-matplotlib-to-plot-a-live-graph-of-benfords-law-in-python-79ec2e987694?source=collection_archive---------1-----------------------#2021-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="8fbe" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="f134" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在发表了我上一篇关于<em class="lj">计算第1，000，000个斐波那契数</em>的文章之后，我想到了如何使用这个数列来展示本福特定律，以及如何用Python(而不是Excel)来创建一个图表。在我们开始之前，我在写这篇文章之前从未使用过matplotlib，所以这篇教程是针对像我这样的初学者的。但是即使你知道你在做什么，请留下来，你可能会学到新的东西。</p><p id="4440" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">以下是我们将涉及的部分的快速列表:</p><ol class=""><li id="4f5b" class="lp lq iq kn b ko lk ks ll kw lr la ls le lt li lu lv lw lx bi translated">什么是本福德定律？</li><li id="a184" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">绘制静态频率图</li><li id="2792" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">绘制实时图表</li></ol><p id="ae70" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我也强烈推荐你在这里阅读我以前的文章<a class="ae md" href="https://kushm.medium.com/how-i-calculated-the-1-000-000th-fibonacci-number-with-python-e921d3642dbf" rel="noopener">，因为我们今天将使用一些斐波那契生成函数。</a></p><h1 id="f251" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是本福德定律？</h1><p id="d971" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">根据<a class="ae md" href="https://brilliant.org/wiki/benfords-law/" rel="noopener ugc nofollow" target="_blank">辉煌</a>，本福德定律是一个:</p><blockquote class="me mf mg"><p id="57ed" class="kl km lj kn b ko lk kq kr ks ll ku kv mh lm ky kz mi ln lc ld mj lo lg lh li ij bi translated">观察真实世界数据集中的数字的前导数字。凭直觉，人们可能会认为这些数字的前导数字是均匀分布的，因此从1到9的每个数字出现的可能性都是相等的。事实上，经常会出现这样的情况:1比2出现得更频繁，2比3出现得更频繁，以此类推。</p></blockquote><p id="5f7a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这种分布经常出现在现实世界的数据集中，几乎无所不包。这也意味着本福德定律有多种用途，其中一种是检测潜在欺诈的能力。这是因为我们(人们)很难创造出符合规律的数据，因为我们倾向于将数字均匀地分布在数据中。</p><p id="9dea" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">令人惊讶的是，计算从1到9的数字的实际分布非常简单和容易，为此我们可以使用下面的概率公式:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mk"><img src="../Images/b77a5d26771ea0a767afb540a47177b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JAKpfDpv1rA-UojmQ0iCfg.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">计算出现在数字开头的1到9之间的某个数字的概率的公式</figcaption></figure><p id="1436" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这个等式告诉我们，对于一个数字d，它出现在给定数据集中的概率等于1 + 1/d的以10为底的对数。我们还可以进一步证明，概率之和(其中d的范围从1到9)总计为1:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi na"><img src="../Images/a15ca376c017f6ec3235a3c893fed190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9smrsFutUkHH84X_obzKHw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">数字1到9的概率总和为1的证明</figcaption></figure><p id="5dbf" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们还可以计算我们期望看到的不同频率概率:</p><pre class="ml mm mn mo gt nb nc nd ne aw nf bi"><span id="45b8" class="ng jo iq nc b gy nh ni l nj nk">1 : 0.3010<br/>2 : 0.1761<br/>3 : 0.1249<br/>4 : 0.0969<br/>5 : 0.0792<br/>6 : 0.0669<br/>7 : 0.0580<br/>8 : 0.0512<br/>9 : 0.0457</span><span id="10ba" class="ng jo iq nc b gy nl ni l nj nk">(* Multiply these values by 100 to get the probabilities in percentage.)</span></pre><p id="c255" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在我们知道了什么是本福特定律，让我们开始用Python来绘制一些图形吧！</p><h1 id="0f9c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">绘制静态频率图</h1><p id="100b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要使用Python绘制图形，我们首先需要安装一个名为matplotlib的外部库。幸运的是，这非常简单，我们需要做的就是打开一个命令行并输入:<code class="fe nm nn no nc b">pip install matplotlib</code>。</p><p id="6cfb" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后，您可以从matplotlib导入pyplot函数并创建两个变量，这两个变量将在以后使用，一个用于为每个条形着色，另一个用于记录Fibonacci数中第一个数字的频率:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1a8d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">接下来要做的是创建一个函数，它可以返回斐波纳契数列中某个特定数字之前的所有数字:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b983" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在这里，我使用一个迭代解决方案将每个值添加到一个列表中，然后在函数结束时返回。如果你想知道更多关于我为什么使用比奈公式迭代解的信息，那么看看我的另一篇博文<a class="ae md" href="https://kushm.medium.com/how-i-calculated-the-1-000-000th-fibonacci-number-with-python-e921d3642dbf" rel="noopener">这里</a>。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="373a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后在我们程序的主要部分，我们可以调用函数并传递整数50，000给它，这将返回给我们前50，000个斐波那契数的列表。然后，我们遍历这个列表，在每次迭代中，我们可以将这个数字转换成一个字符串，这样我们就可以使用切片方法访问字符串中的第一个字符。则字母字典中的字符值递增。您的字母词典现在应该是这样的(您可以通过打印出来来查看):</p><pre class="ml mm mn mo gt nb nc nd ne aw nf bi"><span id="3ab9" class="ng jo iq nc b gy nh ni l nj nk">letters = {</span><span id="2b12" class="ng jo iq nc b gy nl ni l nj nk">    '1': 15052,</span><span id="5bad" class="ng jo iq nc b gy nl ni l nj nk">    '2': 8804,</span><span id="7ac0" class="ng jo iq nc b gy nl ni l nj nk">    '3': 6248,</span><span id="3bec" class="ng jo iq nc b gy nl ni l nj nk">    '4': 4844,</span><span id="baa8" class="ng jo iq nc b gy nl ni l nj nk">    '5': 3959,</span><span id="cbb3" class="ng jo iq nc b gy nl ni l nj nk">    '6': 3349,</span><span id="edaa" class="ng jo iq nc b gy nl ni l nj nk">    '7': 2898,</span><span id="9099" class="ng jo iq nc b gy nl ni l nj nk">    '8': 2558,</span><span id="5bc9" class="ng jo iq nc b gy nl ni l nj nk">    '9': 2288</span><span id="a59d" class="ng jo iq nc b gy nl ni l nj nk">}</span></pre><p id="11e3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">请确保您将它存储在某个地方，因为您不想在每次运行程序时等待并一次又一次地生成它们。</p><p id="d0b7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">接下来要绘制条形图，我们需要获取我们将分配给<em class="lj"> x </em>和<em class="lj"> y </em>值的值，它们分别是数字1到9以及数字的频率:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a3fa" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对于<em class="lj"> x </em>轴，我使用了字母字典上的按键功能，这将创建一个不同数字的列表。y轴可能看起来有点不同，但是不要担心它并不太难理解，它只是一个简单的列表。对字母字典的不同值进行迭代，在每次迭代中，该值除以50，000(因为我们有50，000个斐波那契数)，以获得频率。然后将该值四舍五入到4位小数，并添加到一个列表中，该列表在一个语句中返回。</p><p id="edeb" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后我们可以为图表设置标题，以及为<em class="lj"> x </em>和<em class="lj"> y </em>标签设置标签。我还设置了<em class="lj"> y </em>轴的范围，范围从0到0.35，这对我们来说是完美的:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6d1f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在这里，我通过提供<em class="lj"> x </em>和<em class="lj"> y </em>轴值来创建条形图。我还用我之前创建的颜色列表指定了颜色参数。这完全是可选的，但我认为它看起来很不错:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8aef" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">还有一个quick for循环，它遍历9个不同的条形，获取当前条形的高度，并在实际条形的上方进行注释。</p><p id="0b9e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">最后我们可以得到一个图表，在这里我们可以清楚地看到本福特定律。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nr"><img src="../Images/4e239a8870eb8c51ea1976c6cf22b5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7I37GX6J6Km_NWY7phBYlA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">直观展示本福特定律分布的静态图</figcaption></figure><p id="2c32" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们可以从图表上的值看到，它们与我们的预测值完全一致。这证明了斐波那契数列确实遵循本福特定律，正如我们所预期的那样，因为它是一个自然发生的序列。</p><h1 id="2dc6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">绘制实时图表</h1><p id="a8b2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，如果我们想看看这个图形如何随着斐波纳契数的增加而变化，那么我们需要绘制一个也实时更新的图形。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b3fc" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">首先，我们导入所需的库，itertools库中的count函数将保持我们当前所在的数字，matplotlib中的FuncAnimation函数允许我们在我们的图形上创建动画并更新它。我们将计数设置为从1开始，并像以前一样创建字母字典和颜色列表。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0d05" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后，我们可以使用这个迭代函数返回第n个斐波那契数，而不是一次性计算它们，我们会一边计算一边进行。</p><p id="d654" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">接下来，我们需要一个函数，每次都可以调用它来更新我们的图形:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="fa76" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在这个函数中，获取计数器的下一个值，并计算第n个斐波那契数，在此之后，第一个数字用于更新字母字典。其余的代码几乎是相同的，但是有一行额外的代码清除了前面的图形。这是因为当我们绘制新的图形时，它会覆盖上一个图形，这是我们不希望的。注意，这个函数需要一个参数，但是matplotlib会自动传递这个参数，所以我们根本不需要考虑这个问题。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="fbda" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">最后，我们可以使用导入的FuncAnimation函数创建动画。这需要几个参数，第一个是我们正在使用的当前“数字”。不要太担心这个，我们可以使用get current figure函数返回当前的数字。接下来，我们为我们的动画函数提供一个5的时间间隔，这是以毫秒为单位的，所以不要把这个值设置得太高，也不要太低，因为它可能会变得很慢。</p><p id="0c14" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">希望如果一切按计划进行，执行代码将创建一个图表，显示随着越来越多的斐波纳契数被计算，频率图如何变化。这里有一个例子(请注意，GIF可能需要一些时间来加载，你也可以在这里观看视频<a class="ae md" href="https://imgur.com/a/4IMJxkI" rel="noopener ugc nofollow" target="_blank">):</a></p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ns"><img src="../Images/2e0d5313748e4f1b1cbb26ebde85b7fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iidCrybghDSjRKSi-KhusA.gif"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">这是一个实时图表，展示了随着计算中使用更多的斐波纳契数，频率图是如何变化的</figcaption></figure><h1 id="d179" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">最后的想法</h1><p id="b3bd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当你观察实时图表时，它变得更加“准确”,并且随着我们拥有和能够使用的数据量的增加而稳定下来。这在真实的科学世界中是一样的，这也是为什么你在学校的老师可能会要求你多次重复一个实验，以获得更好的数据并消除异常。</p><p id="5856" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我希望你喜欢这篇文章。如果你有任何问题或反馈，请在下面评论，我会尽快回复。</p><p id="b860" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">感谢您的阅读！💖</p></div></div>    
</body>
</html>