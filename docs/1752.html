<html>
<head>
<title>Meta Programming in JavaScript with Proxies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用代理的JavaScript元编程</h1>
<blockquote>原文：<a href="https://itnext.io/meta-programming-in-javascript-with-proxies-64fa4898070e?source=collection_archive---------0-----------------------#2019-01-19">https://itnext.io/meta-programming-in-javascript-with-proxies-64fa4898070e?source=collection_archive---------0-----------------------#2019-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/12b71e0c010a843609ff927db1f06f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*idnlp_oGM1rBOJCc"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@photocapebreton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗朗西斯·麦克唐纳</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f68e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">以前，我写过一篇文章</em>  <em class="lb">关于通过手动定义对象的属性/访问器描述符来定制对象。从精神上讲，本文是那篇文章的延续，因为在我将描述符与我们可以从代理中获得的描述符进行比较时，我将假设一些描述符的知识。如果对描述符及其好处有任何疑问，我推荐阅读我以前的文章。</em></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="c06f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我学习JavaScript之前，我研究了几年Python。Python的一个非常好的地方是它努力做到对开发人员友好，它的一个亮点是使列表易于使用。对于任何类似数组的数据结构，开发人员的一个常见需求是能够根据数组的结尾(而不仅仅是开头)访问元素。幸运的是，在Python中，这就像写<code class="fe lj lk ll lm b">some_python_list[-1]</code>一样简单。</p><p id="a33c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，当我学习JavaScript并试图用同样的方法获取数组中的最后一个元素时，我有多惊讶:</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="a3d4" class="lv lw iq lm b gy lx ly l lz ma">javaScriptArray[-1]; // undefined</span></pre><p id="efe6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">真的吗？我不能用这个方法获取数组中的最后一个元素？我可以用类似Ruby的方法来代替吗？</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="129a" class="lv lw iq lm b gy lx ly l lz ma">javaScriptArray.last; // undefined</span></pre><p id="022f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不。不幸的是，为了得到最后一个元素，我们仍然需要使用笨拙的<code class="fe lj lk ll lm b">javaScriptArray[ javaScriptArray.length - 1 ]</code>技术。不幸的是，这使得代码更加冗长(因此有点难以阅读)，似乎一直是ECMAScript标准中的一个主要疏忽。</p><p id="eb5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，虽然负索引不是一个我们可以立即使用的特性，但是JavaScript确实有一个非常方便的特性，可以让我们创建这样的行为(等等！)自己:<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理</a>。</p><h1 id="d0f0" class="mb lw iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">委托书</h1><p id="e087" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">代理是一个对象，充当被执行的代码和被访问的实际对象之间的替身。代理的主要目的是公开一个接口，该接口拦截我们希望在对象上执行的各种操作，并以某种方式修改该操作的默认行为，以产生我们通常不会得到的结果。</p><p id="8095" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种修改代码执行的能力被称为元编程，它为JavaScript开发人员提供了很大的自由，可以对行为进行微小或剧烈的改变。这些偏差是以满足某些要求(称为“不变条件”)为代价的，目的是不允许代理的代码弯曲偏离那些在典型JavaScript对象上执行的操作太远。</p><p id="c601" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用代理的一些最佳用例是允许执行各种副作用(<em class="lb">例如</em>、控制台日志记录、API调用)或扩展默认行为，如获取/设置属性。为了说明其中的一些概念，我们将继续我上一篇关于属性描述符的文章中的数据库示例，尽管我们不是处理数据库中的一行，而是处理数据库本身。</p><p id="1d7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然代理可以拦截大量操作(称为“陷阱”)，但我们将举例说明的是:</p><ul class=""><li id="638f" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated"><code class="fe lj lk ll lm b">has</code></li><li id="9629" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated"><code class="fe lj lk ll lm b">get</code></li><li id="8b6b" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated"><code class="fe lj lk ll lm b">set</code></li><li id="2dbf" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated"><code class="fe lj lk ll lm b">ownKeys</code></li><li id="48ab" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated"><code class="fe lj lk ll lm b">deleteProperty</code></li></ul><h1 id="8774" class="mb lw iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">树立榜样</h1><p id="9715" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">因为我们的例子是我们以前的数据库系统的扩展，所以我们将用一些虚拟数据创建一个简单的数组。</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="7df7" class="lv lw iq lm b gy lx ly l lz ma">const db = [<br/>    {<br/>        name: 'John Doe',<br/>        age: 28,<br/>        lastModified: Date.now(),<br/>        lastAccessed: Date.now()<br/>    },<br/>    {<br/>        name: 'Jane Smith',<br/>        age: 30,<br/>        lastModified: Date.now(),<br/>        lastAccessed: Date.now()<br/>    },<br/>        {<br/>        name: 'Albert Einstein',<br/>        age: 52,<br/>        lastModified: Date.now(),<br/>        lastAccessed: Date.now()<br/>    }<br/>];</span></pre><p id="dbeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，目前我们只能做典型阵列能做的事情。我们不能使用负索引，获取和设置属性完全基于JavaScript的开箱即用的<code class="fe lj lk ll lm b">[[Get]]</code>和<code class="fe lj lk ll lm b">[[Set]]</code>规范，检索数组的键实质上会给我们一个数字索引列表。</p><p id="8e41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将改变这一切。我们的目标是实现以下行为:</p><ul class=""><li id="a7c3" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated">允许负指数</li><li id="43ed" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">以不同于我们习惯的方式获取和设置某些属性</li><li id="25b4" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">轻松检索数据库行使用的键集(而不是我们行的数字索引)</li><li id="7b30" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">无需显式调用<code class="fe lj lk ll lm b">Array.prototype.find()</code>即可确定数据库中是否存在某行</li><li id="3c9f" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">使用一个简单的<code class="fe lj lk ll lm b">delete</code>命令删除数据库行中的属性</li></ul><h1 id="61bc" class="mb lw iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">代理我们的数据库</h1><p id="2707" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">创建代理很容易:</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="4566" class="lv lw iq lm b gy lx ly l lz ma">const dbProxy = new Proxy(db, {});</span></pre><p id="b2a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将两个参数传递到我们的<code class="fe lj lk ll lm b">new Proxy()</code>调用中:被代理的对象(我们上面的示例数据库)和处理程序对象，指定我们想要捕获的内容。无论我们在这个对象中没有指定什么陷阱，都意味着我们希望JavaScript引擎使用默认行为。</p><p id="0f40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们建立我们的自定义功能。</p><h2 id="3363" class="lv lw iq bd mc nr ns dn mg nt nu dp mk ko nv nw mo ks nx ny ms kw nz oa mw ob bi translated"><code class="fe lj lk ll lm b">`get</code></h2><p id="f721" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">由于我们想使用负指数，我们可以创建一个名为<code class="fe lj lk ll lm b">get</code>的陷阱，将负指数转换为正指数:</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="dbf6" class="lv lw iq lm b gy lx ly l lz ma">const handler = {<br/>    get(tgt, prop, rcvr) {<br/>        const _prop = +prop;</span><span id="12fe" class="lv lw iq lm b gy oc ly l lz ma">        if (Number.isInteger(_prop) &amp;&amp; _prop &gt;= 0)<br/>            return tgt[_prop];<br/>        if (Number.isInteger(_prop) &amp;&amp; _prop &lt; 0)<br/>            return tgt[tgt.length + _prop];<br/>        <br/>        return tgt[prop];<br/>    }<br/>};</span></pre><p id="26bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe lj lk ll lm b">prop</code>转换为一个数字，并检查结果是否是一个整数(而不是一个浮点数，或者，如果<code class="fe lj lk ll lm b">prop</code>是字母数字，则是一个<code class="fe lj lk ll lm b">NaN</code>)，并将负的属性重写为正的。如果我们传递一个字母数字属性，我们只是把它当作我们试图正常访问一个属性。如果我们没有在最后指定<code class="fe lj lk ll lm b">return tgt[prop]</code>，我们将无法访问目标数组的任何其他属性，比如<code class="fe lj lk ll lm b">length</code>。</p><p id="3b2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于为我们的<code class="fe lj lk ll lm b">get</code>陷阱指定的参数的两个快速注释:</p><ol class=""><li id="528e" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la od nj nk nl bi translated"><code class="fe lj lk ll lm b">tgt</code>表示我们正在代理的底层对象，<code class="fe lj lk ll lm b">prop</code>表示我们正在访问的属性，<code class="fe lj lk ll lm b">rcvr</code>表示接收代理。因此，如果我们说<code class="fe lj lk ll lm b">dbProxy[-1]</code>，那么我们的参数最终将是<code class="fe lj lk ll lm b">db</code>、<code class="fe lj lk ll lm b">'-1'</code>、<code class="fe lj lk ll lm b">dbProxy</code>，分别对应于我们的陷阱中列出的顺序。我将使用简写的<code class="fe lj lk ll lm b">tgt</code>和<code class="fe lj lk ll lm b">rcvr</code>来帮助保持代码简洁。</li><li id="d931" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la od nj nk nl bi translated">在<code class="fe lj lk ll lm b">get</code>陷阱中访问<code class="fe lj lk ll lm b">rcvr</code>上的属性时，我们必须小心。这是因为<code class="fe lj lk ll lm b">rcvr</code>本身就是代理，所以如果我们在陷阱中访问它的一个属性，我们就要重新进入<code class="fe lj lk ll lm b">get</code>陷阱，我们冒着无限递归进入这个处理程序的风险，直到JavaScript引擎抛出一个callstack错误。</li></ol><h2 id="3e36" class="lv lw iq bd mc nr ns dn mg nt nu dp mk ko nv nw mo ks nx ny ms kw nz oa mw ob bi translated">更多的</h2><p id="1e8e" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">关于代理，我们还应该展示两件事:我们希望在任何时候访问它的一个属性时更新我们的<code class="fe lj lk ll lm b">lastAccessed</code>字段，并指定一个属性<code class="fe lj lk ll lm b">last</code>来检索数据库中的最后一行。</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="15d4" class="lv lw iq lm b gy lx ly l lz ma">const handler = {<br/>    get(tgt, prop, rcvr) {<br/>        const _prop = +prop;<br/>        <br/>        if (prop in tgt) tgt[prop].lastAccessed = Date.now();</span><span id="8b75" class="lv lw iq lm b gy oc ly l lz ma">        if (Number.isInteger(_prop) &amp;&amp; _prop &gt;= 0) <br/>            return tgt[_prop];<br/>        <br/>        if (Number.isInteger(_prop) &amp;&amp; _prop &lt; 0) {<br/>            const posProp = tgt.length + _prop;<br/>            if (posProp in tgt)<br/>                tgt[posProp].lastAccessed = Date.now();<br/>            return tgt[posProp];<br/>        }</span><span id="5937" class="lv lw iq lm b gy oc ly l lz ma">        if (prop === 'last') return rcvr[-1];<br/>        <br/>        return tgt[prop];<br/>    }<br/>};</span></pre><p id="6d80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，每当我们访问一个属性时，我们立即在我们正在访问的行上直接设置<code class="fe lj lk ll lm b">lastAccessed</code>(假设我们的属性实际上在数组中)，如果我们曾经调用过<code class="fe lj lk ll lm b">dbProxy.last</code>，我们简单地在我们的代理上访问<code class="fe lj lk ll lm b">-1</code>属性(然后它再次被捕获，但是这次解析为直接从底层<code class="fe lj lk ll lm b">tgt</code>数组中获取我们的一行，这样我们避免了无限递归)。</p><h2 id="5843" class="lv lw iq bd mc nr ns dn mg nt nu dp mk ko nv nw mo ks nx ny ms kw nz oa mw ob bi translated"><code class="fe lj lk ll lm b">`set`</code></h2><p id="0188" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">通常一个对象的属性可以很容易地随意改变，只需执行<code class="fe lj lk ll lm b">obj.prop = val</code>。通过调用像<code class="fe lj lk ll lm b">Object.preventExtensions()</code>或<code class="fe lj lk ll lm b">Object.freeze()</code>这样的函数来防止属性被改变是可能的，但是这些更多的是全有或全无的方法，并且没有对什么可以被改变的<em class="lb">进行粒度控制。</em></p><p id="71cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用我们的代理，我们将锁定添加任何新的属性，除非我们调用<code class="fe lj lk ll lm b">dbProxy.new = ...</code>，以及添加自定义排序我们的数据库的能力。</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="2785" class="lv lw iq lm b gy lx ly l lz ma">const handler = {<br/>    set(tgt, prop, val, rcvr) {<br/>        if (prop === 'sort') {<br/>            const { by, dir } = val;<br/>            tgt.sort(<br/>                (a, b) =&gt; dir === 'asc'<br/>                    ? (a[by] &lt; b[by] ? -1 : 1)<br/>                    : (b[by] &lt; a[by] ? -1 : 1)<br/>            );<br/>        }<br/>        <br/>        if (prop === 'new') {<br/>            tgt.push({<br/>                ...val,<br/>                lastModified: Date.now(),<br/>                lastAccessed: Date.now()<br/>            });<br/>        }<br/>        <br/>        return true;<br/>    }<br/>};</span></pre><p id="35a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以通过运行以下命令向数据库中添加一个新行</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="d3d1" class="lv lw iq lm b gy lx ly l lz ma">dbProxy.push({ name: 'Test', age: 100 });</span></pre><p id="1b05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的数据库没有任何变化，尽管调用<code class="fe lj lk ll lm b">dbProxy.new = ...</code>会给我们想要的结果。我们也可以简单地通过调用<code class="fe lj lk ll lm b">dbProxy.sort = { by: 'age', dir: 'asc' }</code>按照数据库的任何字段对数据库进行排序。</p><h2 id="1ce8" class="lv lw iq bd mc nr ns dn mg nt nu dp mk ko nv nw mo ks nx ny ms kw nz oa mw ob bi translated">`有'</h2><p id="62e2" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">假设我们想知道数据库中是否有符合特定标准的行。通常，我们会在数组上做<code class="fe lj lk ll lm b">.find()</code>并传入一个合适的函数。然而，相反，我们想简单地说一些类似于<code class="fe lj lk ll lm b">{ name: 'Albert Einstein' } in dbProxy</code>的东西，并得到一个<code class="fe lj lk ll lm b">true</code>或<code class="fe lj lk ll lm b">false</code>，而不必总是编写一个函数。</p><p id="394f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常<code class="fe lj lk ll lm b">in</code>要求我们检查一个字符串是否作为直接键存在于我们的对象上，但是trap允许我们写任何我们想要的存在检查逻辑。不幸的是，我们被限制在操作符的左边使用一个<em class="lb">字符串</em>，所以我们不能提供上面列出的对象。所以我们先把它转换成JSON就够了。</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="24cc" class="lv lw iq lm b gy lx ly l lz ma">const handler = {<br/>    has(tgt, prop) {<br/>        const obj = JSON.parse(prop);<br/>        const criteria = Object.entries(obj);<br/>        <br/>        return tgt.some(obj =&gt;<br/>            criteria.every( ([key, val]) =&gt;<br/>                obj[key] === val<br/>            )<br/>        );<br/>    }<br/>};</span></pre><p id="26c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将字符串(参数<code class="fe lj lk ll lm b">prop</code>)转换为一个对象，然后将其转换为一个条目数组，并检查我们的底层数组(参数<code class="fe lj lk ll lm b">tgt</code>)中至少有一个文档符合所有标准。</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="cc0a" class="lv lw iq lm b gy lx ly l lz ma">const johnDoe = JSON.stringify({ name: 'John Doe' });<br/>const albertEinstein = JSON.stringify(<br/>    { name: 'Albert Einstein', age: 50 }<br/>);</span><span id="f0c6" class="lv lw iq lm b gy oc ly l lz ma">johnDoe in dbProxy; // true<br/>albertEinstein in dbProxy; // false: ages don't match</span></pre><h2 id="3b24" class="lv lw iq bd mc nr ns dn mg nt nu dp mk ko nv nw mo ks nx ny ms kw nz oa mw ob bi translated">` ownKeys '</h2><p id="20b5" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">因为我们的数据库是一个文档风格的数据库，没有严格的模式，如果后面的文档添加了与前面不同的键，我们可能不知道当前使用的所有键(反之亦然)。因此，我们可以捕获像<code class="fe lj lk ll lm b">Object.keys()</code>或<code class="fe lj lk ll lm b">Reflect.ownKeys()</code>这样的调用来检索数据库行中使用的列(而不是数组的典型数字索引)。</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="9b84" class="lv lw iq lm b gy lx ly l lz ma">const handler = {<br/>    ownKeys(tgt) {<br/>        const keys = tgt.reduce(<br/>            (keys, doc) =&gt; {<br/>                const docKeys = Object.keys(doc);<br/>                docKeys.forEach(key =&gt; {<br/>                    keys.add(key);<br/>                });<br/>                <br/>                return keys;<br/>            },<br/>            new Set()<br/>        );<br/>        <br/>        return [ ...keys, 'length' ];<br/>    }<br/>};</span></pre><p id="4e72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个陷阱恰好是我们可以使用的最严格的陷阱之一，它限制了我们可以(并且必须)返回什么值，以及我们可能想要返回什么值。</p><p id="d9e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须只返回字符串或符号，任何不可配置的own属性必须在列表中——因此在我们的数组中返回了<code class="fe lj lk ll lm b">'length'</code>,它当然没有在我们的任何行中使用，但是它的省略抛出了一个<code class="fe lj lk ll lm b">TypeError</code>。</p><p id="e42f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，<code class="fe lj lk ll lm b">Reflect.ownKeys()</code>将返回预期的结果，而<code class="fe lj lk ll lm b">Object.keys()</code>只返回一个空数组，所以使用这个陷阱需要我们注意代理上使用了哪些按键抓取函数。</p><h2 id="70e6" class="lv lw iq bd mc nr ns dn mg nt nu dp mk ko nv nw mo ks nx ny ms kw nz oa mw ob bi translated">`删除属性'</h2><p id="c1a7" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">我们将使用<code class="fe lj lk ll lm b">deleteProperty</code>陷阱不删除代理本身的属性(实质上是从数据库数组中删除一个条目),而是删除数据库中每一行的属性。因此，如果我们决定不再需要一个<code class="fe lj lk ll lm b">lastModified</code>字段，我们可以简单地通过调用<code class="fe lj lk ll lm b">delete dbProxy.lastModified</code>来修剪我们的数据库。</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="6fa8" class="lv lw iq lm b gy lx ly l lz ma">const handler = {<br/>    deleteProperty(tgt, prop) {<br/>        const keys = this.ownKeys(tgt).slice(0, -1);<br/>        <br/>        if (keys.includes(prop)) {<br/>            tgt.forEach(row =&gt; {<br/>                delete row[prop];<br/>            });<br/>            <br/>            return true;<br/>        }<br/>        <br/>        return false;<br/>    }<br/>};</span></pre><p id="9973" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个陷阱使用了一个有趣的特性。在代理处理程序的上下文中，<code class="fe lj lk ll lm b">this</code>被绑定到处理程序本身，所以假设我们已经定义了其他陷阱，我们可以通过调用<code class="fe lj lk ll lm b">this.some_trap()</code>在特定的陷阱中使用它们。</p><p id="c250" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们假设已经定义了前一节中定义的<code class="fe lj lk ll lm b">ownKeys</code>陷阱，因此我们可以获得组成数据库模式的键，减去<code class="fe lj lk ll lm b">'length'</code>属性(因此，调用<code class="fe lj lk ll lm b">.slice(0, -1)</code>)。如果我们试图删除的属性实际上在我们的数据库中使用，我们从每一行中删除该属性，并返回<code class="fe lj lk ll lm b">true</code>表示成功。否则我们返回<code class="fe lj lk ll lm b">false</code>来表明这是不可能的。</p><h1 id="9571" class="mb lw iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">比较代理和描述符</h1><p id="84f3" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">我们可以在代理和属性/访问器描述符之间进行许多比较，部分原因是两者通过以下方式打开了许多相同的大门:</p><ul class=""><li id="e036" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated">允许在我们的行动中出现副作用</li><li id="2824" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">阻止手术发生</li><li id="7b5e" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">自定义某些操作的行为</li></ul><p id="3952" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，我们可以用描述符和代理做些什么呢？</p><p id="c606" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从技术上讲，我们可以用访问器描述符实现负索引。每当底层数组发生变化时，这将需要大量的开销来维护负索引到其正对应项的映射，而对于代理，我们基于数学等式进行重新映射。此外，使用描述符将意味着负索引实际上是数组上的键，而不是代理上的纯幻像键。</p><p id="6899" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe lj lk ll lm b">set</code>陷阱所做的事情大部分可以使用描述符来完成。通过设置<code class="fe lj lk ll lm b">.sort</code>属性和我们在<code class="fe lj lk ll lm b">.new</code>属性上插入的方式对数组进行排序，不需要代理就可以很容易地完成。然而，如果不调用像<code class="fe lj lk ll lm b">Object.freeze()</code>这样的辅助函数，他们不会允许我们取消所有其他的<code class="fe lj lk ll lm b">set</code>操作。</p><p id="f835" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在代理上使用的所有其他陷阱都不能以其他方式完成。当我们考虑到代理的目的是为<em class="lb">元</em>程序提供一种方法，并从根本上改变典型的代码执行行为时，这是显而易见的，而描述符只是一种特性，允许在<em class="lb">正常</em>编程期间更好地控制对象。</p><h1 id="a211" class="mb lw iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">结论</h1><p id="b1d0" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">我们已经看到了在使用代理拦截和修改典型的JavaScript操作时可以发挥的威力。虽然代理不会拦截每一个命令(<em class="lb">例如</em>，我们不能重载数学运算符)，但它们确实拦截了足够多的命令，非常有用。</p><p id="9430" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用上面的陷阱实现的东西是无穷无尽的(例如，我们没有实现像Python中如此常见的<code class="fe lj lk ll lm b">array[1:3]</code>这样的片段),我们也无法说明由代理暴露的其他一些非常重要的陷阱——主要是因为它们是基于函数的陷阱，我们只处理对象。它们非常重要，无论如何都值得单独讨论。</p><p id="0561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将把这个要点<a class="ae kc" href="https://gist.github.com/ryandabler/fbfb05313c4c42168bdc84ea15579b57" rel="noopener ugc nofollow" target="_blank">作为我们在本文中放在一起的代理的完整示例。</a></p></div></div>    
</body>
</html>