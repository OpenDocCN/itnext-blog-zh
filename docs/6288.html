<html>
<head>
<title>@MainActor in Swift — Detailed walkthrough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">@ Swift中的MainActor详细演练</h1>
<blockquote>原文：<a href="https://itnext.io/mainactor-in-swift-detailed-walkthrough-94044c83118b?source=collection_archive---------1-----------------------#2021-10-10">https://itnext.io/mainactor-in-swift-detailed-walkthrough-94044c83118b?source=collection_archive---------1-----------------------#2021-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="151a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在主线程中更新UI元素不再需要DispatchQueue.main.async。最新的Swift的@MainActor将取代它，使我们的编码更加简单易懂。</h2></div><p id="ee9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Swift中的@MainActor是Swift 5.5中一个有趣的新增功能。如果你还不熟悉Swift中的演员，我建议你读一下我的文章<a class="ae lb" href="https://devcracker.medium.com/swift-actors-e80ff0dc1832" rel="noopener">Swift中的演员</a>。因为了解演员会让你更了解@MainActor。简而言之，通过在Swift中引入Actor，Swift并发编程被带到了一个新的高度。Swift Actors通过消除我们的手动样板代码，将数据放在一个队列/线程中，帮助我们在没有数据竞争问题的情况下访问数据。</p><h2 id="3957" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使用Swift的@MainActor:</h2><p id="bd7c" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">现在，让我们深入到用例中。我们有一个典型的例子，我们在后台或新线程中从服务器或本地数据库获取数据，并发布我们将在UI组件中更新它们。下面是示例截图。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/9f9dd3fe961b944f2e78a72524cc35c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCkfmtHxI4vNyZ96i-YTRA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">获取数据并在非主线程中更新数据Swift中的@MainActor</figcaption></figure><p id="11f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码片段中，我们有一个问题。因为我们的标签正在后台线程中更新。会发生什么？当我们运行这段代码时，我们将得到这个警告和一个崩溃。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mq"><img src="../Images/e2cd656bb91d4bdbb07d37491b552f6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1ugFwc2XAmuow1bK4-lwA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">UI主线程警告swift中的@MainActor</figcaption></figure><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mr"><img src="../Images/cc81c3bab74a117174f38624ebe00a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ny37M_fPegyVmVxLCrI-DA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">在非主线程中访问UIKit时崩溃swift中的@MainActor</figcaption></figure><p id="5a17" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，为了解决这个问题，我们使用DispatchQueue.main.async { }调用该方法，如下所示。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ms"><img src="../Images/7ca1cbe3a5a5cdcc2d795f536a0e3d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4CGwhEi8FJH_ZZRkQEpTw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">调度队列main以更新UI元素swift中的@MainActor</figcaption></figure><p id="c3c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很好。但是，有时我们会忘记从调度主队列中调用这个方法，我们在执行类似操作的任何地方都必须这样做。</p><h2 id="9be9" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">swift中的@MainActor是什么:</h2><p id="4e2b" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">所以，最新的swift并发编程带来了@MainActor，让这个变得更简单更有效。再次，我想重复，如果你不熟悉，请阅读<a class="ae lb" href="https://devcracker.medium.com/swift-actors-e80ff0dc1832" rel="noopener">我在Swift </a>上关于演员的文章，以便更好地理解</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mt"><img src="../Images/4555931e1a9ea9b254748255aa007e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qxd7MBaL31YijU2CqDIGSg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">在swift中使用@MainActor</figcaption></figure><p id="7d76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们观察上面的截图，@MainActor是我们在函数声明中添加的属性，并删除了DispatchQueue.main.async .意思是，通过将这个操作转换到主线程，这个函数将在主线程中自动执行。Swift在最新的并发系统中为我们做了这件事。太酷了！！！。这有助于我们删除重复的代码，减少我们的人为错误。</p><blockquote class="mu mv mw"><p id="2ddd" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated">Swift中的这个主要参与者在主线程中执行所有操作。苹果在UIKit、SwiftUI等中明确使用它们…</p></blockquote><h2 id="ca81" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">带有@MainActor的类:</h2><p id="4a36" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们可以将一个完整的类声明为@MainActor，也就是说，该类中的属性和方法将在主线程中执行。下面的截图用@MainActor属性标记了我们的viewmodel类。因此，所有的方法和属性现在都流入了主线程。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nb"><img src="../Images/ff02ae380c92fb6a8799350980aafadc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ljRieto3cKMUEiaWcTAPSg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">使用@MainActor属性声明类</figcaption></figure><p id="2c2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这里有一个问题，如果我们有一个方法或者属性，不需要在这个类的主线程中，该怎么办？是的，我们可以将它们标记为“非隔离的”(<a class="ae lb" href="https://devcracker.medium.com/swift-actors-e80ff0dc1832#:~:text=Isolated%20access%20vs%20nonisolated%20access%3F" rel="noopener">Swift Actor</a>中的一个概念)。</p><h2 id="6370" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">继承在@MainActor上的表现。</h2><p id="1a7c" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">好了，我们有了一个类，并用@MainActor标记，如果继承了那个类会怎么样。按照最小惊奇原则，子类也将是@MainActor。</p><p id="d79c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">覆盖@MainActor方法也将成为@MainActor方法。</p><h2 id="cd0a" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">@协议中的主要角色用法:</strong></h2><p id="590d" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">假设我们有一个协议，它有一个带有@MainActor属性的方法，如下所示，</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/5ef6e313b0e97e15ef3702de9c3dfa79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*XONU1CYbwc5FNdyuUIrd1g.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">swift中作为@MainActor的协议方法</figcaption></figure><p id="1fb5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，这个类或任何类型用相同的方法确认这个协议，这也将成为@MainActor。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nd"><img src="../Images/38e218f21bf4b7e9c3af876078347c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KRQHUhSAlTRWATCGB8RUHw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">协议方法自动变成@MainActor</figcaption></figure><p id="847d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们更深入地了解协议的用法。我们可以将完整的协议标记为@MainActor吗？。是的，这是可能的。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/197b8dafc120b1907b93394347ab125f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*AVo_9O92z7kOF8Q0zRs9rg.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">作为@MainActor的完整协议</figcaption></figure><p id="cf98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好，不同情况下会有什么表现。💁</p><blockquote class="mu mv mw"><p id="6767" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated">在main定义或声明中确认该协议的类或类型将完全成为@MainActor，而如果该类或结构或任何其他类型在扩展中确认该协议，则只有那些方法成为@MainActor。</p></blockquote><p id="04f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了清楚起见，请参考下面的快照。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nf"><img src="../Images/d3f37d52dbaf339e1f2d685ae42f06fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*auOS1Lz-16iHIK3nz094vw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">通过确认@MainActor协议，以@MainActor完成类</figcaption></figure><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ng"><img src="../Images/2177db08033502b05b07aae1af24f242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIxPruPUFc2SLaEWR4B5og.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">@MainActor协议的扩展构造</figcaption></figure><p id="812c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样的事情也适用于其他类型，如struct或enum等。</p><p id="135f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前就这些。感谢阅读！！！。如果你喜欢我的文章，并认为我在这篇文章上花费的时间和精力值得赞赏，请与你的同事/朋友分享这一页，或者在这一页上为我鼓掌。</p></div></div>    
</body>
</html>