<html>
<head>
<title>Background Video Upload to Firebase Storage with Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flutter将背景视频上传到Firebase存储</h1>
<blockquote>原文：<a href="https://itnext.io/background-video-upload-to-firebase-storage-with-flutter-ee398b796656?source=collection_archive---------5-----------------------#2020-11-02">https://itnext.io/background-video-upload-to-firebase-storage-with-flutter-ee398b796656?source=collection_archive---------5-----------------------#2020-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d5b036e178948b98c0000030a09d44b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPNzFkyGgs9zBLI-irsMUQ.jpeg"/></div></div></figure><h1 id="4e23" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">我们正在建造的东西</strong></h1><p id="facf" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我写过几篇关于从Flutter上传视频到Firebase存储的帖子。</p><p id="55cf" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我发现真正缺失的一点是后台上传——一种上传大型视频文件的方式，即使应用程序关闭，这些文件也会继续上传。</p><p id="9a65" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">看起来Firebase团队正计划在<a class="ae mc" href="https://github.com/firebase/firebase-ios-sdk/issues/147" rel="noopener ugc nofollow" target="_blank">中增加这个功能</a>，但是同时，这里有一个替代的方法来完成它。</p><p id="5b29" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们将使用<a class="ae mc" href="https://pub.dev/packages/flutter_uploader" rel="noopener ugc nofollow" target="_blank"> flutter_uploader </a>插件来执行后台上传。它基于Android中的<em class="md"> WorkManager </em>和iOS中的<em class="md"> NSURLSessionUploadTask </em>，这是执行上传任务的平台特定方法，这些任务在后台继续，即使在退出应用程序后也是如此。</p><p id="2787" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">该插件只能通过URL上传，这是Firebase客户端SDK所不提供的。因此，我们将把生成上传URL的工作外包给一个云功能。</p><h1 id="8fae" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">系统设计</strong></h1><p id="4112" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">以下是每个视频将经历的步骤:</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/29139c271144048da5ac01d3c6b0dac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_RqtVwjOPyu-R711kDybA.jpeg"/></div></div></figure><p id="5a4a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">1.客户在Firestore中创建一个新文档，带有原始视频路径。</p><p id="74a9" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">2.“上传新视频”云功能由文档创建触发。</p><p id="6a9a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">3.云函数生成指向云存储中的新文件的可恢复上传url。</p><p id="b9a2" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">4.云功能用上传url更新Firestore文档。</p><p id="b8cc" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">5.客户端接收带有上传url的更新文档，生成缩略图，并在后台上传视频。</p><p id="8c2e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">6.上传完成后，触发<em class="md"> newStorageFile </em>云功能，将Firestore中的<em class="md"> uploadComplete </em>字段设置为<em class="md"> true </em>。</p><p id="2f2a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">7.客户端生成一个永久下载url，并将其保存到Firestore。</p><h1 id="ecb3" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">主要步骤</strong></h1><p id="7e47" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们一个接一个地浏览主要的上传步骤。我会尽量把重点放在重点上，略去细枝末节。</p><p id="ac10" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu"> 1。创建新的Firestore文档(步骤1) </strong></p><p id="1d60" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们将使用<a class="ae mc" href="https://pub.dev/packages/file_picker" rel="noopener ugc nofollow" target="_blank"> file_picker </a>插件来获取视频文件:</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/80d5d7afacc860265b25bef67141412e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zyYd565UQHv8H0QEXuHjwg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">主.镖</figcaption></figure><p id="8bf1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">一旦我们选择了一个视频，我们就创建一个新的Firestore文档，它基本上是一个占位符，用于触发第一个云功能。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/97055b35161764321a93f9773ddc713a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kzbRrBlW0f9FCqluWfoiHQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">firebase_provider.dart</figcaption></figure><p id="b1f1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">Firestore onCreate Cloud功能(步骤2-4)</strong></p><p id="fbb5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们将把firestore <em class="md"> onCreate </em>方法添加到我们的云函数的<em class="md"> index.js </em>文件中。这将在创建每个新文档时触发。</p><blockquote class="mp mq mr"><p id="ea1b" class="kz la md lb b lc lx le lf lg ly li lj ms lz lm ln mt ma lq lr mu mb lu lv lw im bi translated">关于如何在你的项目中设置云功能的指导，你可以查看我的<a class="ae mc" rel="noopener ugc nofollow" target="_blank" href="/serverless-video-upload-and-encoding-with-firebase-storage-cloud-functions-and-publitio-a4b2997b1508">上一篇文章</a></p></blockquote><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/44e20cf1e29e310faa08e68c36fc4e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3CLj-UnXxbPyZdtcaQ9kg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">索引. js</figcaption></figure><p id="b490" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这里的关键是调用Firebase管理存储SDK上的<a class="ae mc" href="https://googleapis.dev/nodejs/storage/latest/File.html#createResumableUpload" rel="noopener ugc nofollow" target="_blank">createrusemableupload</a>函数。这将创建一个新的Firebase存储对象和一个url，我们可以用它向对象上传数据。上传也是可恢复的，所以我们可以在我们的客户端上传器中利用这一点。</p><p id="edcc" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">一旦我们有了上传的url，我们就把它保存到同一个Firestore文档中，从而把它同步回客户端。</p><blockquote class="mp mq mr"><p id="f0c3" class="kz la md lb b lc lx le lf lg ly li lj ms lz lm ln mt ma lq lr mu mb lu lv lw im bi translated">注意:在实际场景中，您可能希望将此url保存在只有上传用户才能访问的Firestore路径中。</p></blockquote><p id="dd21" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">使用flutter_uploader后台上传(步骤5) </strong></p><p id="0209" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在我们的<em class="md"> initState </em>方法中，我们收听我们的Firestore集合。当视频发生变化时，我们会检查uploadUrl字段。如果它存在，我们知道我们可以开始上传。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/da908f922fcdbc8de91655fee70478c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUV5O_IxXb7c4QmqrULe-g.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">主.镖</figcaption></figure><p id="37e8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><em class="md"> _processVideo </em>方法包括使用<em class="md"> ffmpeg </em>生成缩略图(如<a class="ae mc" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-serverless-flutter-video-sharing-app-with-firebase-storage-including-hls-and-411e4fff68fa">以前的帖子</a>中所述)，将视频元数据保存到Firestore，最后使用<em class="md"> flutter_uploader </em>启动后台上传任务:</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/561b710564bef54351a1d5af169ede5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*-vyGI4EibLpT5cierdbkBw.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">主.镖</figcaption></figure><blockquote class="mp mq mr"><p id="44e7" class="kz la md lb b lc lx le lf lg ly li lj ms lz lm ln mt ma lq lr mu mb lu lv lw im bi translated">注意:可以添加更精细的后台任务处理，比如在flutter中显示成功/失败/进度状态，清除已完成的任务等。这是我们刚刚启动的任务，等待Firestore更新客户端状态。</p></blockquote><p id="e11b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">存储最终化的云功能(步骤6) </strong></p><p id="c3b8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">上传完成后，触发<em class="md"> newStorageFile </em>云函数，其作用只是将Firestore文档中的<em class="md"> uploadComplete </em>字段设置为真。这可以在上传完成后从客户端完成，但我认为从服务器端完成更健壮，因为客户端应用程序可能会在上传完成前关闭。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/14bb7643ae7729c7e80a8dcaa32e209c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qOGekmhKWU0uS3P3kdCUVg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">索引. js</figcaption></figure><blockquote class="mp mq mr"><p id="8f91" class="kz la md lb b lc lx le lf lg ly li lj ms lz lm ln mt ma lq lr mu mb lu lv lw im bi translated">注意:我们在这里使用了两个完成标志:uploadComplete和finishedProcessing。这个函数设置第一个，客户端设置最后一个。</p></blockquote><p id="fbfd" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">生成永久下载网址</strong></p><p id="8bbc" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">理想情况下，一旦上传完成，我们可以在云功能上为文件生成一个永久的下载URL。唉，管理SDK<a class="ae mc" href="https://github.com/googleapis/nodejs-storage/issues/697" rel="noopener ugc nofollow" target="_blank">缺少这个能力</a>，所以我们必须让客户端来做这个。</p><p id="3bd6" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">一旦上传完成，我们客户端的Firestore监听器将获得一个更新的文档，状态为<em class="md"> uploadComplete </em>。然后下载url可以保存到Firestore文档，并且<em class="md">完成处理</em>状态设置为真。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/833b77aa3be4c6a1edd3c901368f785a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jo6tjwBhQxkOFvCbrG9vQQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">主.镖</figcaption></figure><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/cbc05e5faeb456f8989ab3eb70f36379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxE8oyNQEEFp3wE1PVCw7Q.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">firebase_provider.dart</figcaption></figure><p id="ecc2" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在我们的视频已经可以通过下载网址在客户端上观看了！</p><p id="e380" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">完整来源</strong></p><p id="679d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">感谢阅读！完整的源代码可以在<a class="ae mc" href="https://github.com/syonip/flutter_fbstorage_background_upload" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到</p><p id="8744" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果您有任何问题，请留下您的评论！</p></div></div>    
</body>
</html>