<html>
<head>
<title>How to Use DataLoader to Resolve Properties Selectively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用DataLoader有选择地解析属性</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-dataloader-to-resolve-properties-selectively-ad4423b79fd2?source=collection_archive---------2-----------------------#2019-11-24">https://itnext.io/how-to-use-dataloader-to-resolve-properties-selectively-ad4423b79fd2?source=collection_archive---------2-----------------------#2019-11-24</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/189115698f952a6a26a91b34140791de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s8AK20aHdQ-vX3wG"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated">罗伯特·v·鲁杰罗在<a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="793c" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我的团队最近试图构建一个GraphQL服务器，它可以从各种其他REST服务中提取和连接数据。出于某种历史原因，其中一个服务在响应中展平了父数据中的部分而非全部子数据。</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="6836" class="ll lm ir lh b gz ln lo l lp lq"><br/>GET /user</span><span id="f62f" class="ll lm ir lh b gz lr lo l lp lq">[<br/>  {<br/>    "id": "123",<br/>    "name": "...",<br/>    <strong class="lh is">"addresses": [<br/>      {<br/>        "id": "222",<br/>        "city": "San Francisco"<br/>      }<br/>    ]</strong><br/>  },<br/>  ...<br/>]</span><span id="6f2e" class="ll lm ir lh b gz lr lo l lp lq">GET /address/222</span><span id="c2f2" class="ll lm ir lh b gz lr lo l lp lq">{<br/>  "id": "222",<br/>  "line1": "...",<br/>  "line2": "...",<br/>  "city": "San Francisco",<br/>  "state": "CA"<br/>}</span></pre><p id="5e8e" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">例如，用户可以拥有一个地址数组。除了包含地址<code class="fe ls lt lu lh b">id</code>之外，<code class="fe ls lt lu lh b">city</code>也作为用户地址的一部分返回。然而，如果我们想要得到<code class="fe ls lt lu lh b">state</code>，它并不包含在内，我们别无选择，只能用另一个REST API调用来获取地址222。</p><h1 id="ceb6" class="lv lm ir bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">问题是</h1><p id="e858" class="pw-post-body-paragraph ke kf ir kg b kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx mw kz la lb ik bi translated">调用获取地址并加入用户是合理的做法，因为外键是为地址提供的。在大多数情况下，解析器看起来像这样。</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="488f" class="ll lm ir lh b gz ln lo l lp lq">const resolvers = {<br/>  User: {<br/>    addresses: user =&gt; {<br/>      // For each address, load the address by its ID.<br/>      return user.addresses.map(address =&gt; loadAddress(address.id));<br/>    }<br/>  },<br/>}</span></pre><p id="0eb9" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">即使在加载用户列表时，解析器也能很好地工作，但是由于<a class="ae kd" rel="noopener ugc nofollow" target="_blank" href="/how-to-avoid-n-1-problem-in-apollo-federation-8b4f37729fc4"> N+1问题</a>，性能非常糟糕。通过使用<a class="ae kd" href="https://github.com/graphql/dataloader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>将所有单独的<code class="fe ls lt lu lh b">loadAddress()</code>调用批处理为单个<code class="fe ls lt lu lh b">loadAddresses()</code>调用，可以<em class="mx">可能</em>修复N+1问题。我说<em class="mx">可能</em>是因为这取决于你的REST服务是否提供批量API。</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="a0ee" class="ll lm ir lh b gz ln lo l lp lq">query GetUsers {<br/>  getUsers {<br/>    id<br/>    name<br/>    <strong class="lh is">addresses</strong> {<br/>      <strong class="lh is">id</strong><br/>      <strong class="lh is">city</strong><br/>    }<br/>  }<br/>}</span></pre><p id="5ba5" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">不管怎样，即使我们已经知道了<code class="fe ls lt lu lh b">city</code>是什么，上面的查询仍然必须至少调用<code class="fe ls lt lu lh b">loadAddress()</code>或<code class="fe ls lt lu lh b">loadAddresses()</code>一次。还记得REST API响应中包含的<code class="fe ls lt lu lh b">city</code>吗？</p><p id="f974" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">那么，推迟调用<code class="fe ls lt lu lh b">loadAddress()</code>到<code class="fe ls lt lu lh b">Address</code>的属性呢？如果我们这样做，我们只在必须解析属性时调用<code class="fe ls lt lu lh b">loadAddress()</code>。</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="473e" class="ll lm ir lh b gz ln lo l lp lq">const resolvers = {<br/>  User: {<br/>    addresses: user =&gt; {<br/>      // For each address, load the address by its ID.<br/>      return user.addresses.map(address =&gt; loadAddress(address.id));<br/>    }<br/>  },<br/>  Address: {<br/>    id: address =&gt; address.id,<br/>    line1: address =&gt; <strong class="lh is">loadAddress(address.id)</strong>.line1,<br/>    line2: address =&gt; <strong class="lh is">loadAddress(address.id)</strong>.line2,<br/>    city: address =&gt; address.city,<br/>    state: address =&gt; <strong class="lh is">loadAddress(address.id)</strong>.state,<br/>  }<br/>}</span></pre><p id="39a7" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">太好了。当我们查询<code class="fe ls lt lu lh b">id</code>或<code class="fe ls lt lu lh b">city</code>时，我们不必调用<code class="fe ls lt lu lh b">loadAddress()</code>。然而，如果我们在查询中包含<code class="fe ls lt lu lh b">line1</code>、<code class="fe ls lt lu lh b">line2</code>或<code class="fe ls lt lu lh b">state</code>，我们仍然会多次调用<code class="fe ls lt lu lh b">loadAddress()</code>。因此，该解决方案解决了一个问题，但引入了另一个问题。</p><h1 id="8d33" class="lv lm ir bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">解决方案</h1><p id="2913" class="pw-post-body-paragraph ke kf ir kg b kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx mw kz la lb ik bi translated">那么我们如何在引用<code class="fe ls lt lu lh b">line1</code>、<code class="fe ls lt lu lh b">line2</code>或者<code class="fe ls lt lu lh b">state</code>的时候最多调用一次<code class="fe ls lt lu lh b">loadAddress()</code>？这就是我们可以利用数据加载器来合并<code class="fe ls lt lu lh b">loadAddress()</code>的地方。</p><pre class="lc ld le lf gu lg lh li lj aw lk bi"><span id="f263" class="ll lm ir lh b gz ln lo l lp lq">const DataLoader = require('dataloader');<br/>const uniqWith = require('lodash/uniqWith');<br/>const isEqual = require('lodash/isEqual');<br/><br/><br/>async function getAddresses(addressIDs) {<br/>  // <em class="mx">Remove duplicate address IDs.</em><br/>  const uniqueAddressIDs = uniqWith(addressIDs, isEqual);</span><span id="8370" class="ll lm ir lh b gz lr lo l lp lq">  // <em class="mx">Each address is loaded once.</em><br/>  const addresses = await Promise.all(<br/>    uniqueAddressIDs.map(async addressID =&gt; loadAddress(addressID))<br/>  );</span><span id="d218" class="ll lm ir lh b gz lr lo l lp lq">  // <em class="mx">Return addresses in the same order of the addressIDs.</em><br/>  return addressIDs.map(addressID =&gt; {<br/>    const index = uniqueAddressIDs.findIndex(<br/>      uniqueAddressID =&gt; isEqual(uniqueAddressID, addressID)<br/>    );<br/>    return addresses[index];<br/>  });<br/>}<br/><br/>const addressDataLoader = new DataLoader(getAddresses);</span><span id="9e9e" class="ll lm ir lh b gz lr lo l lp lq">const resolvers = {<br/>  Address: {<br/>    id: address =&gt; address.id,<br/>    line1: address =&gt; <strong class="lh is">addressDataLoader.load(address.id)</strong>.line1,<br/>    line2: address =&gt; <strong class="lh is">addressDataLoader.load(address.id)</strong>.line2,<br/>    city: address =&gt; address.city,<br/>    state: address =&gt; <strong class="lh is">addressDataLoader.load(address.id)</strong>.state,<br/>  },<br/>  // ...<br/>}</span></pre><p id="91c8" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这就是了。通过几行代码和使用DataLoader，我们可以重用来自REST API响应的数据(<code class="fe ls lt lu lh b">id</code>和<code class="fe ls lt lu lh b">city</code>),并且只在必要时对每个唯一ID最多调用一次<code class="fe ls lt lu lh b">loadAddress()</code>。</p><div class="my mz gq gs na nb"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-avoid-n-1-problem-in-apollo-federation-8b4f37729fc4"><div class="nc ab fp"><div class="nd ab ne cl cj nf"><h2 class="bd is gz z fq ng fs ft nh fv fx iq bi translated">如何避免阿波罗联邦中的N+1问题</h2><div class="ni l"><h3 class="bd b gz z fq ng fs ft nh fv fx dk translated">如果不小心的话，联邦中也会有同样的陷阱。</h3></div><div class="nj l"><p class="bd b dl z fq ng fs ft nh fv fx dk translated">itnext.io</p></div></div><div class="nk l"><div class="nl l nm nn no nk np jx nb"/></div></div></a></div></div></div>    
</body>
</html>