<html>
<head>
<title>An illustrated guide to Kubernetes Networking [Part 3]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes网络图解指南[第3部分]</h1>
<blockquote>原文：<a href="https://itnext.io/an-illustrated-guide-to-kubernetes-networking-part-3-f35957784c8e?source=collection_archive---------0-----------------------#2018-12-09">https://itnext.io/an-illustrated-guide-to-kubernetes-networking-part-3-f35957784c8e?source=collection_archive---------0-----------------------#2018-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="571f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我所知道的关于Kubernetes网络的一切</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/784e1f30ff86786182c370ccb215f010.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dBYlyYsz0NsWHvh1lpUbzw.png"/></div></figure><p id="2535" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是关于Kubernetes网络系列的第三部分。如果你还没有看过 <a class="ae lk" href="https://medium.com/@ApsOps/an-illustrated-guide-to-kubernetes-networking-part-1-d1ede3322727" rel="noopener"> <em class="lj">第一部分</em> </a> <em class="lj">和</em> <a class="ae lk" href="https://medium.com/@ApsOps/an-illustrated-guide-to-kubernetes-networking-part-2-13fdc6c4e24c" rel="noopener"> <em class="lj">第二部分</em> </a> <em class="lj">，我推荐你先看看那些。</em></p><h2 id="d0bb" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kw lu lv lw la lx ly lz le ma mb mc md bi translated">集群动力学</h2><p id="a9b1" class="pw-post-body-paragraph kn ko iq kp b kq me jr ks kt mf ju kv kw mg ky kz la mh lc ld le mi lg lh li ij bi translated">由于Kubernetes和一般分布式系统不断变化的动态特性，pod(及其IP)一直在变化。原因可能从期望的滚动更新和扩展事件到不可预测的pod或节点崩溃。这使得Pod IPs无法直接用于通信。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/0a2e33d0c9fdb06d73847b27ea46490a.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*-K4giETzfM7LFO2M6RFWlw.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Kubernetes服务对象中的标签选择器</figcaption></figure><p id="eb32" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">进入Kubernetes服务—一个虚拟IP，以一组Pod IPs作为端点(通过标签选择器识别)。它们充当虚拟负载平衡器，其IP保持不变，而后端Pod IPs可能会不断变化。</p><p id="75ca" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">整个虚拟IP实现实际上是iptables(最近的版本可以选择使用IPVS，但这是另一个讨论)规则，由Kubernetes组件kube-proxy管理。现在这个名字其实是误导。在1.0版之前，它曾经是一个代理，由于在内核空间和用户空间之间的不断复制，它被证明是非常资源密集型的，并且速度较慢。现在，它只是一个控制器，像Kubernetes中的许多其他控制器一样，监视端点的api服务器的变化，并相应地更新iptables规则。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/abe216b99478aa9e2350869ece4c81d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0exvIsmyeyTlKE_DhaFlEA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Iptables DNAT</figcaption></figure><p id="1db7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">由于这些iptables规则，每当数据包以服务IP为目的地时，它都会被DNATed(DNAT =目的地网络地址转换)，这意味着目的地IP会从服务IP更改为iptables随机选择的一个端点(pod IP)。这可以确保负载在后端单元之间均匀分布。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mt"><img src="../Images/38829276cb5bdae32aea57b898c36fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9MhOY6Dkx3rFUlqGjmaOQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">conntrack表中的5元组条目</figcaption></figure><p id="7878" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当这个DNAT发生时，这个信息被存储在conntrack中Linux连接跟踪表(存储iptables已经完成的5元组转换:protocol、srcIP、srcPort、dstIP、dstPort)。这是为了当回复返回时，它可以un-DNAT，这意味着将源IP从Pod IP更改为服务IP。这样，客户端就不知道数据包流是如何在幕后处理的。</p><p id="bb1c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，通过使用Kubernetes服务，我们可以使用相同的端口而没有任何冲突(因为我们可以将端口重新映射到端点)。这使得服务发现变得非常容易。我们可以只使用内部DNS和硬编码服务主机名。我们甚至可以使用Kubernetes预设的服务主机和端口环境变量。<br/> <strong class="kp ir"> Protip </strong>:采取这第二种方法，省去了很多不必要的DNS调用！</p><h2 id="d79d" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kw lu lv lw la lx ly lz le ma mb mc md bi translated">出站流量</h2><p id="42d6" class="pw-post-body-paragraph kn ko iq kp b kq me jr ks kt mf ju kv kw mg ky kz la mh lc ld le mi lg lh li ij bi translated">到目前为止，我们讨论的Kubernetes服务都是在集群中工作的。然而，在大多数实际情况下，应用程序需要访问一些外部API/网站。</p><p id="6055" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">通常，节点可以同时拥有私有和公共IP。对于互联网访问，这些公共和私有IP存在某种1:1的NAT，尤其是在云环境中。</p><p id="6d89" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对于从节点到某个外部IP的正常通信，对于出站数据包，源IP从节点的专用IP更改为其公共IP，对于回复入站数据包，则相反。但是，当一个Pod发起到外部IP的连接时，源IP就是该Pod IP，云提供商的NAT机制并不知道这一点。它只会丢弃带有源IP而不是节点IP的数据包。</p><p id="fced" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以我们使用，你猜对了，更多的iptables！这些规则也是由kube-proxy添加的，进行SNAT(源网络地址转换)也称为IP伪装。这告诉内核使用该数据包发出的接口的IP，而不是源Pod IP。还保存了一个conntrack条目，以取消SNAT回复。</p><h2 id="b52f" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kw lu lv lw la lx ly lz le ma mb mc md bi translated">入境交通</h2><p id="4af6" class="pw-post-body-paragraph kn ko iq kp b kq me jr ks kt mf ju kv kw mg ky kz la mh lc ld le mi lg lh li ij bi translated">目前一切都很好。豆荚可以互相交谈，也可以上网。但是我们仍然缺少一个关键部分——为用户请求流量服务。到目前为止，有两种主要方法可以做到这一点:</p><p id="7500" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">节点端口/云负载平衡器(L4 — IP和端口)<br/> </strong>将服务类型设置为<code class="fe mu mv mw mx b">NodePort</code>在<code class="fe mu mv mw mx b">30000-33000</code>范围内为服务分配一个<code class="fe mu mv mw mx b">nodePort</code>。这个<code class="fe mu mv mw mx b">nodePort</code>在每个节点上都是开放的，即使某个节点上没有运行pod。该节点端口上的入站流量将被发送到其中一个pod(它甚至可能在其他某个节点上！)再次使用iptables。</p><p id="2412" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">云环境中的负载均衡器服务类型会在所有节点前面创建一个云负载均衡器(例如，ELB)，到达同一个节点端口。</p><p id="2728" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">入口(L7 — HTTP/TCP) </strong></p><p id="dc7f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一堆不同的工具，像nginx，traefik，haproxy等等。，保持http主机名/路径和各自后端的映射。像往常一样，这是负载平衡器和节点端口上流量的入口点，但优点是我们可以用一个入口来处理所有服务的入站流量，而不需要多个节点端口和负载平衡器。</p><h2 id="4c97" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kw lu lv lw la lx ly lz le ma mb mc md bi translated">网络策略</h2><p id="0164" class="pw-post-body-paragraph kn ko iq kp b kq me jr ks kt mf ju kv kw mg ky kz la mh lc ld le mi lg lh li ij bi translated">可以把这想象成pod的安全组/ACL。网络策略规则允许/拒绝跨pod的流量。确切的实现取决于网络层/CNI，但大多数只是使用iptables。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="01a7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">目前就这些。在<a class="ae lk" href="https://medium.com/@ApsOps/an-illustrated-guide-to-kubernetes-networking-part-1-d1ede3322727" rel="noopener">之前的</a> <a class="ae lk" href="https://medium.com/@ApsOps/an-illustrated-guide-to-kubernetes-networking-part-2-13fdc6c4e24c" rel="noopener">部分</a>中，我们学习了Kubernetes网络的基础以及叠加是如何工作的。现在我们知道了服务抽象如何在动态集群中提供帮助，并使发现变得非常容易。我们还讲述了出站和入站流量如何工作，以及网络策略如何有助于集群内的安全性。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="90f0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我意识到我花了太长时间来发表这篇文章(一年多！)，但过去的一年就像坐过山车一样🎢</p><blockquote class="nf"><p id="6c56" class="ng nh iq bd ni nj nk nl nm nn no li dk translated">我<em class="np">终于</em>在库比肯给了<a class="ae lk" href="https://youtu.be/auBNs9qpCJI" rel="noopener ugc nofollow" target="_blank">那次谈话</a><a class="ae lk" href="https://twitter.com/ApsOps/status/1020757402101088259" rel="noopener ugc nofollow" target="_blank">加入了Indeed.com，搬到了都伯林</a>！</p><p id="9ac8" class="ng nh iq bd ni nj nk nl nm nn no li dk translated">所以下周我会去kube con 18。我会在迪伊的摊位待一会儿。来打个招呼或者在推特上给我打电话。</p></blockquote></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="b515" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi">-</p></div></div>    
</body>
</html>