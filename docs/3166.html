<html>
<head>
<title>Multiple HTTP Requests in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular中的多个HTTP请求</h1>
<blockquote>原文：<a href="https://itnext.io/multiple-http-requests-in-angular-43df566016eb?source=collection_archive---------4-----------------------#2019-10-15">https://itnext.io/multiple-http-requests-in-angular-43df566016eb?source=collection_archive---------4-----------------------#2019-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/21498b6a74bdc62910f3bc654f7c3a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZzMHBAMq5C-5PY0m.png"/></div></div></figure><p id="5f8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">RxJS有时会令人困惑，一开始可能不清楚如何做某些事情。其中之一可能是如何以正确的方式处理多个HTTP请求——但很高兴这并不太复杂。</p><p id="7d74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行多个请求可能有两种不同的情况；一个接一个地(顺序地)或同时地(并行地)。</p><h1 id="5d27" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">要求</h1><p id="83cf" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这种方法依赖于Angulars`<a class="ae lz" href="https://angular.io/guide/http" rel="noopener ugc nofollow" target="_blank">http client</a>`——因此<code class="fe ma mb mc md b">this.http</code>将总是引用<code class="fe ma mb mc md b">HttpClient</code>。</p><p id="5667" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，为了更容易理解，本指南将使用一个简单的PHP脚本作为API:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ba61" class="mm kx iq md b gy mn mo l mp mq">&lt;?php<br/>header("Access-Control-Allow-Origin: *");<br/>header("Content-Type: application/json");</span><span id="dea9" class="mm kx iq md b gy mr mo l mp mq">$timeout = isset($_GET['timeout']) ? $_GET['timeout'] : 0;</span><span id="9ba3" class="mm kx iq md b gy mr mo l mp mq">sleep($timeout);</span><span id="66d4" class="mm kx iq md b gy mr mo l mp mq">echo json_encode([<br/>    'timeout' =&gt; $timeout<br/>]);</span></pre><p id="d15a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个脚本允许用一个<code class="fe ma mb mc md b">timeout</code>参数调用它，将等待给定的时间来响应，并用它已经等待的时间来响应。</p><h1 id="c774" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">继续地</h1><p id="0cad" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">从属查询是顺序执行HTTP请求的一个很好的例子；例如，您想要查询在不同端点查询的该用户的一些用户详细信息<em class="ms">和</em>项目。</p><p id="3248" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了完成这项工作，我们将利用管道中的函数。让我们看一个例子:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a039" class="mm kx iq md b gy mn mo l mp mq">import {concatMap, tap} from 'rxjs/operators';</span><span id="d85e" class="mm kx iq md b gy mr mo l mp mq">this.http.get('<a class="ae lz" href="http://test.localhost/api.php?timeout=1'" rel="noopener ugc nofollow" target="_blank">http://test.localhost/api.php?timeout=1'</a>)<br/>      .pipe(<br/>        tap(res =&gt; console.log('First result', res)),<br/>        concatMap((res: { timeout: number }) =&gt; this.http.get(`<a class="ae lz" href="http://test.localhost/api.php?timeout=${+res.timeout" rel="noopener ugc nofollow" target="_blank">http://test.localhost/api.php?timeout=${+res.timeout</a> + 1}`)),<br/>        tap(res =&gt; console.log('Second result', res)),<br/>        concatMap((res: { timeout: number }) =&gt; this.http.get(`<a class="ae lz" href="http://test.localhost/api.php?timeout=${+res.timeout" rel="noopener ugc nofollow" target="_blank">http://test.localhost/api.php?timeout=${+res.timeout</a> + 3}`)),<br/>        tap(res =&gt; console.log('Third result', res)),<br/>      )<br/>      .subscribe(res =&gt; console.log('Latest result', res));</span></pre><p id="6388" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">控制台输出:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="59f5" class="mm kx iq md b gy mn mo l mp mq">First result {timeout: "1"}<br/>Second result {timeout: "2"}<br/>Third result {timeout: "5"}<br/>Latest result {timeout: "5"}</span></pre><p id="38c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1秒后记录第一个输出，2秒后记录第二个，5秒后记录第三个(也是最新的一个)。正如您在管道中看到的，第一个请求之后的每个请求都依赖于前一个请求的响应。</p><h1 id="ccc8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">平行的</h1><p id="62f6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">请求可能是独立的，您需要在应用程序继续运行之前执行所有请求。想象一下查询你的应用程序设置(例如，默认主题、语言等等)、当前用户和当前视图数据(例如，你正在查看的当前帖子)——这些事情都不相互依赖，但是你需要所有这些才能让你的应用程序显示出来。</p><p id="2842" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一次一个地查询这些内容是浪费资源——我们可以只查询所有的内容，然后处理组合的结果。</p><p id="bee7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使我们的请求并行，我们将使用<code class="fe ma mb mc md b">forkJoin</code>。<code class="fe ma mb mc md b">forkJoin</code>中的请求是并行请求的，当所有请求完成时，可观察对象自身发出:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="f7aa" class="mm kx iq md b gy mn mo l mp mq">import {forkJoin} from "rxjs";<br/>import {tap} from "rxjs/operators";</span><span id="8d46" class="mm kx iq md b gy mr mo l mp mq">forkJoin([<br/>  this.http.get('api.php?timeout=1').pipe(tap(res =&gt; console.log(res)),<br/>  this.http.get('api.php?timeout=5').pipe(tap(res =&gt; console.log(res)),<br/>  this.http.get('api.php?timeout=3').pipe(tap(res =&gt; console.log(res)),<br/>]).subscribe(allResults =&gt; console.log(allResults));</span></pre><p id="06f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看控制台会显示以下结果:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="30c3" class="mm kx iq md b gy mn mo l mp mq">{timeout: "1"}<br/>{timeout: "3"}<br/>{timeout: "5"}<br/>(3) [{…}, {…}, {…}]<br/>  0: {timeout: "1"}<br/>  1: {timeout: "5"}<br/>  2: {timeout: "3"}</span></pre><p id="876a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前三行来自我们的<code class="fe ma mb mc md b">tap</code>中的<code class="fe ma mb mc md b">console.log</code>。您可以清楚地看到，即使3秒超时请求列在5秒请求的之后的<em class="ms">，3秒超时记录在5秒超时请求的</em>之前的<em class="ms">——因为我们的请求是单独并行执行的。</em></p><p id="4b28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们所有的观察对象都发出一个值之后(或者，换句话说，在5秒钟的请求结束之后)，<code class="fe ma mb mc md b">forkJoin</code>将发出一个值，最终导致我们的<code class="fe ma mb mc md b">subscribe</code>被调用。</p><p id="d1da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面提到的例子中，我们可以通过这样做来利用这一点:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="edfc" class="mm kx iq md b gy mn mo l mp mq">const postId = this.route.snapshot.paramMap.get("postId");</span><span id="3923" class="mm kx iq md b gy mr mo l mp mq">forkJoin([<br/>  this.http.get(`/api/settings`).pipe(tap(settings =&gt; this.store.dispatch(new LoadSettings(settings)))),<br/>      this.http.get(`/api/user`).pipe(tap(user =&gt; this.store.dispatch(new SetCurrentUser(user)))),<br/>      this.http.get(`/api/post/${postId}`).pipe(tap(post =&gt; this.store.dispatch(new SetCurrentPost(post))))<br/>]).subscribe(() =&gt; this.showApplication = true);</span></pre><p id="06ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在应用程序设置之后，当前用户和文章被加载，应用程序可以被显示。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="8298" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ms">如果你喜欢这篇文章，请留下你的👏，关注我上</em> <a class="ae lz" href="https://twitter.com/nehalist" rel="noopener ugc nofollow" target="_blank"> <em class="ms">推特</em> </a> <em class="ms">并订阅</em> <a class="ae lz" href="https://nehalist.io/newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">我的快讯</em> </a> <em class="ms">。本帖原载于</em><a class="ae lz" href="https://nehalist.io/multiple-http-requests-in-angular" rel="noopener ugc nofollow" target="_blank"><em class="ms">nehalist . io</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>