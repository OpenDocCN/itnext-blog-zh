<html>
<head>
<title>Don’t clone Back-End models in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要克隆有角度的后端模型</h1>
<blockquote>原文：<a href="https://itnext.io/dont-clone-back-end-models-in-angular-f7a749bdc1b0?source=collection_archive---------0-----------------------#2018-03-20">https://itnext.io/dont-clone-back-end-models-in-angular-f7a749bdc1b0?source=collection_archive---------0-----------------------#2018-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="01d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前端，模型-视图-控制器范式已经被明确抛弃，取而代之的是模型-组件:这在所有现代框架中都是如此，但如果你看看从AngularJS到Angular2+的演变，这在Angular world中尤其明显。</p><p id="fe6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">MVC在前端的不足的主要原因通常被认为是控制器的角色不明确，但是在这篇文章中我想关注这种不足的另一个方面:</em> <strong class="jp ir"> <em class="kl">模型在后端和前端的不同角色。</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/6db2b53e2b87a189112fb4bb1d0d920b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QntGItfrVvd7fHVWcqgAqA.png"/></div></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="9535" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">文章路线图</strong></h1><p id="6d1b" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">本文的目标是展示如何将后端模型复制到Angular应用程序中会导致架构问题(通常，这样的问题是如何由前端的后端方法引起的)；我会强调弱点，展示模式，提出解决方案。</p><p id="f492" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">因为这篇文章是关于Angular和AngularJS的，为了避免混淆，我总是把Angular称为“Angular 2+”；我将使用通用术语“Angular ”,不指定任何版本，仅当我打算讨论两个框架共有的通用概念时。</em></p><p id="904b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是这篇文章的大致路线图:</p><ol class=""><li id="4dec" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">我将介绍后端和前端之间的<strong class="jp ir">总体架构差异</strong></li><li id="9b06" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">在Angular的具体例子中，我将展示<strong class="jp ir">不同抽象层次</strong>之间的区别，从我们绑定到DOM的属性开始，直到后端模型:我将展示避免错误的最佳方式是如何<strong class="jp ir">将这些抽象清晰地分开</strong></li><li id="f183" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">我将展示几个简单的例子，说明将不必要的后端变量引入前端如何导致<strong class="jp ir">冗余</strong>并使角度应用程序容易出错</li><li id="64f5" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">我将展示后端返回的嵌套JSON的典型例子，我将展示这种JSON <strong class="jp ir"> </strong>的<strong class="jp ir"> naif AngularJS实现</strong>如何隐藏<strong class="jp ir">意外的结构问题</strong></li><li id="96ad" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">我将在Angular2+ 中提出基于<strong class="jp ir">组件模式的嵌套JSON的不同实现，并展示其优势</strong></li><li id="8a7a" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">我将重点介绍将数据从API传递到组件的最佳方式，并展示不管我们从后端接收的数据结构如何，决定前端的架构是多么重要</li><li id="a60e" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">我将提出一种不同的方法来用来自后端API的数据填充Angular2+组件，通过使用在组件级实例化的<strong class="jp ir">服务</strong></li><li id="8f6b" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">我将简要地讨论向API发送“<em class="kl"> /post </em>”调用的最佳方式，同时仍然保持前端与后端的分离</li><li id="b01e" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">我将简要地展示前端模型的用例，它们具有在后端没有任何对应关系的属性</li></ol></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="8515" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">后端和前端之间固有的架构差异</strong></h1><p id="068a" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">现在每个人都知道MVC不适合前端。许多人将此归咎于控制器(在关于控制器的好文章中，我可以推荐<a class="ae mw" href="https://medium.freecodecamp.org/is-mvc-dead-for-the-frontend-35b4d1fe39ec" rel="noopener ugc nofollow" target="_blank">这一篇</a>):但是MVC失败的更深层次的原因可能是因为<strong class="jp ir"> <em class="kl">我们试图将后端架构应用于前端</em> </strong>。</p><p id="171d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是后端和前端真的如此不同吗？</p><p id="252e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来是的，它们是:<strong class="jp ir"> <em class="kl">在后端解决问题的方法与在前端解决问题的方法有着本质的不同。</em>T11】</strong></p><ul class=""><li id="796f" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">后端开发必须实现所涉及的<strong class="jp ir"> <em class="kl">实体</em> </strong>的逻辑抽象表示，以便对于外部用户和应用，<em class="kl">能够在这些实体上执行操作，而不管上下文如何</em></li><li id="a663" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">前端开发必须实现所涉及的<strong class="jp ir"> <em class="kl">视图</em> </strong>的逻辑抽象表示，以便不仅<em class="kl">与用户</em>顺利交互，而且确保实现是<strong class="jp ir">优化的</strong>(因为它必须在浏览器上运行)和<strong class="jp ir">可伸缩的</strong> <em class="kl"> </em>(因为客户端的需求在前端比在后端变化得更快)。</li></ul><p id="2af7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直到大约2010年，当单页面应用程序开始普及时，这种差异才变得重要起来:在单页面应用程序出现之前，前端只是由CSS、HTML和一些零星的JavaScript组成，前端开发被认为是一项不需要特定模式或指南的任务。</p><p id="9f35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有人试图用前端的方法开发后端，会发生什么？他会试着推断实体的逻辑结构，只看它们在他必须开发的特定视图中是如何使用的；他将只为他需要做的事情创建一组功能，而不考虑这些功能是否会在实体的抽象逻辑中产生更深层次的后果:产生的后端将是<strong class="jp ir"> naif </strong>和<strong class="jp ir">不稳定</strong>，每个人都同意这一点。</p><p id="d182" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">现在，完全一样，如果我们把问题反过来，尝试用后端的方法开发前端，结果会是</em> naif <em class="kl">和</em>不稳定<em class="kl">。</em>T41】</strong></p><p id="395b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题的一个方面当然是控制器在MVC中的角色不明确，正如已经提到的；但是<em class="kl">在我看来，一个更深层次和更隐蔽的架构缺失是当一个具有后端思维的开发者试图定义一个JavaScript </em> <strong class="jp ir"> <em class="kl">模型</em> </strong> <em class="kl">的结构，这些模型是他们的后端副本的精确克隆。</em></p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="8407" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">后端和前端模型如何在角度上产生分歧</strong></h1><p id="345c" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">后端和前端模型都是一个<em class="kl">抽象</em>，但这并不意味着它们必须相同:<strong class="jp ir"> <em class="kl">原因是它们是不同事物的抽象。</em>T15】</strong></p><p id="d12e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种差异的第一个明显的例子是，当后端模型包含前端中没有使用的内部属性时(反之亦然，前端模型可能包含与后端不相关的属性)。</p><p id="dd9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是在Angular world中，DOM会随着应用程序状态的改变而自动更新，事情变得不那么简单了:我们所说的“<em class="kl">应用程序状态</em>”是什么意思？这种状态存储在哪里，它与模型有什么关系？</p><p id="245d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Angular2+中，应用状态存储在<strong class="jp ir">组件</strong>中；但是什么是真正的组件，它们如何与DOM交互？来自<a class="ae mw" href="https://angular.io/guide/template-syntax#html-attribute-vs-dom-property" rel="noopener ugc nofollow" target="_blank">angular 2+</a>中数据绑定技术的官方文档:</p><blockquote class="my mz na"><p id="a2f6" class="jn jo kl jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">当您编写数据绑定时，您专门处理目标对象的属性和事件。[…]数据绑定的目标是DOM中的某个东西。根据绑定类型，目标可以是(element | component | directive)属性、(element | component | directive)事件或(很少)属性名。</p></blockquote><p id="b239" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，<strong class="jp ir"> <em class="kl"> Angular2+的组件只不过是DOM </em> </strong>的(自然)扩展:DOM可以被视为由嵌套的原生元素和组件组成的分层树。让我们看一个例子:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b6ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们想要使用上面代码片段中定义的组件时，我们只需使用标识它的标签，传递输入变量“<em class="kl"> text </em>”，就像它是一个普通的HTML属性一样:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9e42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们使用标记“<em class="kl"> text-in-paragraph </em>”时，它看起来就像是一个常规的DOM元素:它确实可以被认为是一个DOM元素，因为它的行为方式完全相同(有一些扩展)。</p><p id="2f99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，定制组件除了DOM之外还有一个特性就是<em class="kl">数据绑定</em>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="42e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们将属性“<em class="kl"> text </em>”括在括号内时，意味着里面传递的表达式对应父组件中的一个变量:当该变量的值发生变化时，Angular2+更新子组件并重新加载其模板。</p><p id="8602" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际DOM和组件之间的相似之处超出了这个简单的例子(例如，在DOM中，组件可以使用别名属性，这些属性绑定到具有不同名称的属性)，但是核心概念是组件可以被安全地视为DOM的扩展。</p><p id="a05c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">更一般的，由嵌套的原生DOM元素、组件、指令及其所有公共属性组成的树，是Angular2+提供的DOM的抽象。</em>T3】</strong></p><p id="8c58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，回到后端和前端模型之间的区别:<em class="kl">DOM在Angular中的扩展可以被认为是第三种抽象 <em class="kl">，一种</em> <strong class="jp ir"> DOM模型</strong> <em class="kl">，这又必须与两者不同。</em></em></p><p id="4630" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在AngularJS中，概念是相同的，但实现是不同的:负责保存绑定到DOM的变量的实体被称为<strong class="jp ir">控制器</strong>。尽管AngularJS控制器并不完全是DOM的扩展，但最佳实践仍然是将它们与模型(前端和后端)分开。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="3d7b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">保持清晰分离的后端、前端和DOM模型</strong></h1><p id="df74" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我们只是区分了三个不同的抽象层:</p><ol class=""><li id="f169" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated"><strong class="jp ir">后端模型</strong>，保存实体的逻辑和一般抽象</li><li id="5606" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir">前端模型</strong>，它代表前端的一个实体(Angular2+中的<em class="kl">对应于TypeScript模型类</em>):这些模型中有许多与后端模型相似，但它们很少完全相同，另外在前端我们可能需要额外的实体来与用户交互</li><li id="3033" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir"> DOM模型</strong>，它抽象并扩展了DOM(angular 2中的<em class="kl">+它对应于组件类</em>)</li></ol><p id="b860" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">为了实现一个健康的、可伸缩的架构，这三个抽象必须保持清晰的分离。</em> </strong></p><p id="12ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当粗心地用后端方法开发Angular应用程序时，您可能会在不同程度上混合这三种抽象，并带来各种副作用:</p><ul class=""><li id="7a01" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">如果您<em class="kl">创建的前端模型是后端模型</em>的精确克隆，您很可能会遇到<strong class="jp ir">冗余</strong>和<strong class="jp ir">难以维护的胖组件/控制器</strong>的问题</li><li id="ed5a" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">如果你<em class="kl">将DOM直接绑定到一个前端模型</em>，你最终会产生一个<strong class="jp ir">复杂的HTML </strong>，你会冒<strong class="jp ir">失去组件隔离</strong>的风险，并且你会经历<strong class="jp ir">不可预知的副作用</strong></li><li id="2c46" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">如果您将DOM直接绑定到一个前端模型，这个前端模型是后端模型的精确克隆，那么您将会得到以上两点</li></ul><p id="eebd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文的目的是强调混淆后端、前端和DOM模型所带来的风险，并提出通过保持清晰的分离来避免这些风险的模式。让我们从一些实际例子开始。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="be40" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">例子:后端模型带来了不必要的变量</strong></h1><p id="ad57" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我们有一个用户模型，在后端用两个布尔属性表示，称为“<em class="kl">订阅</em>和“<em class="kl">确认</em>”。这些表示后端的两个内部状态，因此当且仅当两个布尔值都为真时，用户才被视为“<em class="kl"> pro </em>”用户。</p><p id="68de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前端，"<em class="kl">订阅</em>"和"<em class="kl">确认</em>"是不相关的，我们唯一需要知道的是用户是否是"<em class="kl"> pro </em>"</p><p id="6741" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，后端API返回一个用户JSON，其中包括"<em class="kl">订阅的</em>"和"<em class="kl">确认的</em>"，因此，如果我们运行一个AngularJS应用程序，我们会尝试这样做:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9d9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个实现很简单，但是它包含了潜在问题的种子，随着应用程序变大，这些问题会影响应用程序。</p><p id="66e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DOM被绑定到表达式“<em class="kl"> isPro </em>”，这不是DOM模型的属性，而是一个基于相应前端模型的两个变量动态计算其值的函数:这是一个潜在的性能风险，因为这样的函数必须在每个“<em class="kl"> $digest </em>”循环中调用。</p><p id="f729" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反过来，前端模型是后端模型的副本，因为变量"<em class="kl"> subscribed </em>"和"<em class="kl"> confirmed </em>"没有直接暴露在前端:每次我们想要处理"<em class="kl"> user </em>"模型时，我们都必须处理这种冗余，这给应用程序增加了不必要的复杂性。</p><p id="350e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别是，如果API希望我们在创建或修改用户时发送整个对象，那么前端不应该负责记住将“<em class="kl"> subscribed </em>”和“<em class="kl"> confirmed </em>”都附加到有效负载上:这应该由后端来完成。</p><p id="3380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这个例子中得到的教训是:<strong class="jp ir"> w <em class="kl">当你设计一个前端模型时，你应该在包含来自后端的任何数据之前仔细考虑。</em></strong></p><p id="41ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我见过后端开发人员，他们只有在前端完全复制了后端模型的完整结构，有时甚至包括一组用JavaScript编写的单元测试时，才会感到舒服。这种复杂性是不合适的，因为它已经存在于它应该存在的后端。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="3c48" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">关于表格的简要说明</h1><p id="e960" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">表单是一个特别容易混合前端模型和DOM模型的例子，因为它们自动做很多事情，开发人员倾向于认为它们是“神奇的”(Angular中的表单将输入绑定到您的数据，并随着框架的发展以更复杂的方式保持更新)。</p><p id="c6ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们听听文件本身，其中有一个关于模型之间的区别的明确警告:</p><blockquote class="my mz na"><p id="48c1" class="jn jo kl jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">该组件必须将<em class="iq">数据模型</em>中的英雄值复制到<em class="iq">表单模型</em>中。</p><p id="bbf1" class="jn jo kl jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">有两个重要的含义:开发人员必须理解<em class="iq">数据模型</em>的属性如何映射到<em class="iq">表单模型的属性；并且</em>用户将流程从DOM元素更改为<em class="iq">表单模型</em>，而不是<em class="iq">数据模型</em>。</p><p id="e2c6" class="jn jo kl jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">表单控件从不更新<em class="iq">数据模型</em>。</p></blockquote><p id="e6ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的引用中，“<em class="kl">数据模型</em>对应于我在本文中称之为前端模型的东西，而“<em class="kl">表单模型</em>对应于我称之为DOM模型的东西。</p><p id="567d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我有太多的事情要说，以至于没有足够的空间在Angular中给出绑定到表单的详细例子，你会在<a class="ae mw" href="https://angular.io/guide/user-input" rel="noopener ugc nofollow" target="_blank">文档</a>中找到很多。出于本文的目的，我只想说明Angular的表单是DOM的另一种扩展。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="38ac" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">一个有意义的例子:具有嵌套子模型的后端模型</strong></h1><p id="102a" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">这是我会一直坚持到文章结尾的例子，因为它是有争议的，有很多含义。我说“有争议”是因为，乍一看，将嵌套模型直接绑定到DOM似乎是一个自然的选择:但由此产生的体系结构在可伸缩性(以及性能，特别是在糟糕的情况下)方面可能会有不可预知的问题。</p><p id="292a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想用的例子是一个有评论和回复的帖子；这是我们的API返回的JSON结构:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="e82d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第一个naif实现(以AngularJS表示)</h1><p id="1a90" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">从这个JSON构造前端的最直接的方法是简单地将它绑定到DOM，使用两个对应于注释和回复的嵌套循环。</p><p id="73de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将使用AngularJS来展示这个实现，因为它不强制组件模式，并且更容易显示这个错误的方法看起来有多简单。我在这个例子中选择AngularJS的事实并不意味着在AngularJS中你必须使用非执行模式。</p><p id="380a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望显示与帖子相关的评论和回复，并提供添加和删除评论和回复的可能性。这是控制器:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ed5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是相应的模板，包含两个嵌套的“<em class="kl"> ng-repeat </em>”指令循环。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cf4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个实现没有什么特别的，如果你对AngularJS有点熟悉的话，你会毫无问题地理解它。我使用控制器作为名称空间，所以很明显这个例子与臭名昭著的<a class="ae mw" href="https://toddmotto.com/no-scope-soup-bind-to-controller-angularjs/" rel="noopener ugc nofollow" target="_blank">作用域汤</a>(这不是本文的主题)没有任何关系。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="f983" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">naif实现分析:将嵌套JSON直接绑定到DOM隐藏的架构缺陷</strong></h1><p id="56b6" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">正如在我们分析的第一个例子中，我试图尽我最大的努力将后端、前端和DOM模型混合在一起。</p><p id="5f0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开门见山，看看出问题的最明显症状:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ab42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一行的目的是删除回复。但是它看起来有点太长了，不是吗？首先，您必须返回到“<em class="kl"> post </em>对象，提取评论，然后获取对应于当前“<em class="kl"> commentId </em>”的评论，提取回复，获取正确的评论并将其从数组中删除。</p><p id="7bc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们需要做的只是从DOM中移除一个简单的节点。那么为什么一直到我们模型的父模型的父模型？</p><p id="a3be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会反对点击回复上的“delete”按钮是一个有意义的事件，它超出了删除DOM中的一个节点的行为:因为用户不只是想从DOM中获得乐趣，他的目标实际上是从数据库中删除回复。</p><p id="0021" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你错了，用户的动作背后没有隐藏的意义，至少在DOM模型的抽象层面上没有。<strong class="jp ir"><em class="kl">DOM模型唯一的责任就是删除那个节点:通知API用户想要删除回复是别人的任务。</em>T13】</strong></p><p id="d335" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这正是我在谈论保持抽象分离时的意思:<em class="kl">三个模型中最前面的只是DOM的扩展，它应该只关注于此。我们稍后会考虑如何通知API。</em></p><p id="23e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">双重嵌套调用会给我们带来什么意想不到的后果？<strong class="jp ir">答案是，缺乏可伸缩性</strong>:我们正在分析的例子非常简单，<em class="kl">但是在前端世界中，事情变化很快，那行看似无害的代码很容易变成一场噩梦。</em>例如，如果我们想要异步删除评论和回复，将它们保存在DOM中直到API做出响应，该怎么办？或者，如果我们需要添加几个嵌套回复，直到某个最大深度，该怎么办？这条线会变得多长多复杂？</p><p id="bb04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们从DOM后退一步，关注这个实现的另一方面:告诉后端更新帖子的API调用。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0fbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，这可能是与API通信的最简单的选择:我们有这个大对象，当用户与应用程序交互时，我们会不断更新它，让我们将它全部发布到API。</p><p id="614e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但事情并不像看起来那么简单:<strong class="jp ir"> <em class="kl">发布整个JSON的策略之所以有效，只是因为我们的实现假设这样完整的对象总是可用的。</em>T3】</strong></p><p id="5255" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不得不重复自己的话，<strong class="jp ir">前端客户的需求变化很快</strong>:一个简单的静态帖子和嵌套的评论和回复可以很快变成高度动态的东西，你需要单独保存单个评论，或者只修改帖子的文本而不触及评论和回复。或者谁知道还有什么？</p><p id="63fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这已经是事情不对劲的早期征兆了:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="02dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们想要创建一个新的注释时，DOM需要将一个"<em class="kl"> input </em> " HTML标签绑定到控制器中的一个变量:理想情况下，将这样一个变量集成到我们现有的体系结构中的自然选择是在我们的JSON中的注释列表后面添加一个新的空"<em class="kl"> comment </em>"。</p><p id="3cc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">但是这意味着，如果用户留下一个不完整的评论，然后执行一些其他的动作，将整篇文章提交给API，他的评论草稿将会和其他的一起被发送，并被保存。</em></p><p id="49a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，为了使它工作，我们已经开始将事情复杂化，并且创建了一个单独的"<em class="kl"> newComment </em>"对象，我们只在提交评论时将它附加到"<em class="kl"> post </em>"上:同样，这不是一个可靠的架构，随着应用程序的增长，它很容易变得过于复杂。</p><p id="d71d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，如果我们看看空注释生成器的实现，我们会发现另一个潜在的问题:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2ca4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“<em class="kl"> userId </em>”属性在用户创建的每个新评论或回复中重复出现。这是多余的，因为评论用户的ID总是相同的，我们不需要随身携带并到处复制它:它应该只存储在一个地方，以备我们需要向API发布内容时使用。</p><p id="0b0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于API的简单说明:我知道有时候它们不是为前端优化而设计的，我也知道它们经常不能按照你的意愿进行修改。<strong class="jp ir"> <em class="kl">所以你有可能被迫向API提交一个完整的嵌套对象，但这并不意味着你必须将这样的对象直接绑定到DOM。</em> </strong></p><p id="3929" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最好的解决方案是将您的API封装在一个适配器中，该适配器负责保持对象的更新，我将在文章的最后详细介绍。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="4e35" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">“哥白尼革命”:组件模式方法</h1><p id="a8b3" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">如果我必须用几句话来总结为什么之前的实现不正确，我会说:<strong class="jp ir">我们围绕一个不代表它的对象开发了前端。</strong></p><p id="ee00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个"<em class="kl">帖子</em> " JSON with nested " <em class="kl">评论</em>"和"<em class="kl">回复</em>"是一个非常好的逻辑抽象，描述了帖子、评论和回复在我们头脑中的实际表现方式:这就是为什么选择这样一个数据结构在后端表现它们。</p><p id="e2f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是在前端，我们需要关注一些不同的东西，我们需要让用户编写内部输入，添加文本，并做任何种类的交互事情:因此，我们在前端使用的模型必须是这些  <strong class="jp ir"> <em class="kl">交互</em> </strong>的良好抽象。在Angular中更是如此，在Angular中，DOM被绑定到自己的模型并自动更新。</p><p id="194e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">事实上，在Angular中，DOM不能被手动修改，这并不意味着您应该将它绑定到后端模型并期望它神奇地更新:通过将它绑定到JavaScript对象来扩展DOM的想法，旨在提供一种更强大和可靠的方法来操作它，而不是将某种自动HTML附加到后端模型上并绕过前端。</strong></p><p id="e613" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们尝试用一种完全不同的方式来解决我们的问题:<em class="kl">我们不会从后端的模型开始，围绕它们来构建前端，而是分析视图，研究它需要以何种方式与用户交互，并对其进行抽象</em>(这就是为什么我称之为“哥白尼革命”，因为我们从相反的角度来看待同一问题)。</p><ol class=""><li id="5f48" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">首先，我们将视图分解成与用户交互的<strong class="jp ir">组件</strong>:我们将它们绑定到DOM，它们将形成我们的<strong class="jp ir"> DOM模型</strong>。</li><li id="9788" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">然后我们将决定我们需要哪个进一步的抽象来协调我们应用程序的不同部分:这将是前端模型。请注意，我们正在构建前端模型，但还不知道后端是否有相同的模型，也不知道它们是如何实现的。</li><li id="1647" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">最后，一旦设计好整个前端架构，<strong class="jp ir">我们将查看API </strong>并决定如何向后端发送数据，以及如何使来自后端的数据适应我们的架构。</li></ol><p id="2eed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步叫做<strong class="jp ir"> <em class="kl">组件模式</em> </strong>，这是<a class="ae mw" href="https://angular.io/guide/architecture#components" rel="noopener ugc nofollow" target="_blank">angular 2+</a>架构背后的基本概念。</p><p id="8b0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，让我们看看需求，决定我们需要哪些组件。让我们从最简单的事情开始，相对于评论的回复数组:这可以是一个组件，它需要做的就是让用户<strong class="jp ir">添加</strong>和<strong class="jp ir">删除</strong>一个回复。</p><p id="f447" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看前面的实现产生的HTML，这样一个组件将对应于这个位:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4038" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个组件本身非常简单，不需要知道它上面是什么，但是我们仍然需要在用户添加或删除回复时向API发送调用:<strong class="jp ir">所以我们将让我们的组件向它的父组件</strong>发送一个事件。该事件将要么说“添加了一个带有此文本的回复”，要么说“删除了此索引处的回复”。</p><p id="4cd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个组件可以是注释列表，对应于这个HTML:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b981" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该组件看起来与第一个组件相同，只是它还侦听子组件“replies ”,并使用子组件所附加的注释索引来确定原始消息的范围。</p><p id="18c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，最后一个组件应该是代表“<em class="kl">职位</em>的组件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="4cf2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">组件模式方法的实现(使用Angular2+) </strong></h1><p id="8e60" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">对于这个实现，我将使用Angular2+，因为这个框架更容易展示组件模式的好处；这并不意味着AngularJS不适合实现组件模式，如果你感兴趣，我建议你阅读<a class="ae mw" href="https://teropa.info/blog/2015/10/18/refactoring-angular-apps-to-components.html" rel="noopener ugc nofollow" target="_blank">这篇非常有趣和详细的文章</a>。</p><p id="550e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在接下来的实现中，我将只限于DOM模型(TypeScript中的组件和相应的HTML模板)；所以，我将暂时省略:</p><ul class=""><li id="23d2" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">当用户与DOM交互(与后端模型的交互)时，从API检索数据并将其推回的机制；</li><li id="d382" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">DOM模型后面的前端模型的定义(省略它们意味着我将把相应的类型设置为“<em class="kl"> any </em>”)。</li></ul><p id="282e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这之后的段落中，我将扩展这个例子，依次解释(1)如何使组件与API通信，以及(2)如何创建表示我们需要的前端模型的类型。</p><p id="1f6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，让我们开始吧，让我们从"<em class="kl"> post </em>"组件的实现开始。这是打字稿部分:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e684" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是(非常简单的)HTML模板:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="66ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这部分实现没有什么特别之处:模板将一篇文章的三个主要属性绑定到dom，并调用组件“<em class="kl"> comments </em>”。</p><p id="8ffb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个组件的简单性也是它的优点。<em class="kl">TypeScript类中唯一存在的变量是我们绑定到DOM的变量:一般来说应该遵守这个准则，因为</em> <strong class="jp ir"> <em class="kl">我们正在创建一个DOM模型，它的主要目的是扩展DOM。</em>T19】</strong></p><p id="234b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到，我们没有向"<em class="kl"> comments </em>"组件传递任何东西:现在不要担心这个问题，稍后当我描述与API的交互时，我会回到这个问题。目前，我唯一的目标是关注用户交互和DOM模型。</p><p id="37e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们前进到第二个组件，它代表注释:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="04ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模板:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6240" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是实现中的关键组件，因为它是主动向API发送数据的组件。</p><p id="1242" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过读取绑定到组件的每个函数，简单地列出组件做的所有事情。让我们首先用对应于DOM交互的两个函数来做这件事(另外两个函数用于对发生在子组件“<em class="kl">回复</em>”层的事件做出反应):</p><ul class=""><li id="4282" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">当用户点击评论上的“<em class="kl"> delete </em>”时，组件从评论数组中删除相应的索引，并向API发送一个通知(这里没有实现)</li><li id="4633" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">当用户在新的评论输入上点击“<em class="kl">保存</em>时，组件将新的评论添加到评论数组中，<strong class="jp ir">在运行中添加用户的名字</strong>；它清空输入以便用户可以再次评论；另外，它将新的注释和用户ID(这里没有实现)一起发布到API</li></ul><p id="6d60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个动作的关键点是<strong class="jp ir">关注点分离</strong>:</p><ul class=""><li id="d870" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">有一个对象表示DOM(注释数组)，这个对象<strong class="jp ir"> <em class="kl">包含了我们渲染这些注释所需要的内容，没有其他内容。</em>T15】</strong></li><li id="c21a" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">另外，我们有一个外部API(这里没有实现，我们将在后面实现)<strong class="jp ir"> <em class="kl">您只需将API需要知道的基本数据传递给它。</em>T19】</strong></li></ul><p id="95b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们详细分析每个抽象层所需的最少数据:</p><ol class=""><li id="c3f9" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">DOM模型是一个注释数组，每个注释由一个文本和一个用户名组成</li><li id="3d12" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">通知API删除注释的调用只包含要删除的注释的<strong class="jp ir">索引</strong></li><li id="972c" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">通知API创建注释的调用只包含<strong class="jp ir">文本</strong>和<strong class="jp ir">用户ID </strong></li></ol><p id="1171" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看另外两个函数，处理回复的函数。我们正在使用Angular2+的一个非常好的特性，它允许我们将子组件发送的输出事件视为清晰的输出事件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ffab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一行的意思是，子组件“<em class="kl">回复</em>”预计会发送两个可能的事件:</p><ul class=""><li id="788b" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">名为“<em class="kl"> deleteEvent </em>”的事件，该参数是要删除的<strong class="jp ir">回复</strong>的<strong class="jp ir">索引</strong></li><li id="55f4" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">一个名为“<em class="kl"> submitEvent </em>的事件，其参数是已经创建的<strong class="jp ir">回复的<strong class="jp ir">文本</strong></strong></li></ul><p id="f547" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建在这些事件<strong class="jp ir">之上的<a class="ae mw" href="https://angular.io/guide/template-syntax#template-expressions" rel="noopener ugc nofollow" target="_blank">模板表达式</a>将注释的索引添加到从子组件发送的原始参数</strong>中，并将所有内容传递给“<em class="kl"> comments </em>”组件的相应方法<strong class="jp ir">，该组件唯一的职责是通知API关于变化的信息</strong>。</p><p id="4909" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么我们从“<em class="kl">回复</em>到“<em class="kl">评论</em>”发送事件，而不是在“<em class="kl">回复</em>”中直接触发事件？<strong class="jp ir"> <em class="kl">因为子组件没有足够的信息来通知API:它是扁平的，它不知道它被附加到了哪个注释上。我们这样做是为了简化与DOM的交互。</em> </strong></p><p id="7b80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候最后看看最后一个组件了，它代表回复:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3d22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和(简单的)模板:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="051c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个组件是<strong class="jp ir">父母不可知的</strong>:它简单地实现了与用户的两个交互，当用户删除或添加回复时发送一个信号；与信号一起发送的唯一参数是相对于回复的具体列表，<strong class="jp ir"> <em class="kl">它不包括任何关于这些回复附加到</em> </strong>的信息。</p><p id="0943" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，DOM模型的实现是<strong class="jp ir">扁平的</strong>并且容易:我们只存储我们需要来呈现DOM的<strong class="jp ir">精确变量，并且当用户想要改变DOM时，我们能够直接修改它们。</strong></p><p id="6747" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想强调Angular2+的两个技术细节:首先是<strong class="jp ir">输出声明</strong>，它是我们在"<em class="kl"> comments </em>"模板中绑定的事件的组件副本:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a2cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">被迫为每个组件声明一个输入和输出列表是如此美好和清晰:它让你保持架构的整洁，尤其是当与<a class="ae mw" href="https://angular.io/guide/dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>一起使用时。</p><p id="acc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">二、看<a class="ae mw" href="https://angular.io/guide/template-syntax#template-reference-variables--var-" rel="noopener ugc nofollow" target="_blank">模板变量</a>“<em class="kl"># new reply</em>”的用法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="aa00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我决定在这个例子中避免双向绑定:<a class="ae mw" href="https://angular.io/guide/template-syntax#two-way-binding---" rel="noopener ugc nofollow" target="_blank">双向绑定</a>是我一直试图避免的事情，因为数据必须流动，在每一次击键时，从用户到DOM模型，然后返回到DOM，这是对能量的极大浪费。有时双向绑定是必要的，<em class="kl">但是</em> <em class="kl">在这个特定的例子中，我只需要读取输入的值，并在用户提交时清空它，一个模板变量让我安全地完成这个任务</em>。</p><p id="ce64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这是我们新的DOM模型</strong>；总而言之，与第一个naif实现相比，我们获得了以下好处:</p><ul class=""><li id="1965" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">在每个组件中，我们的模型只包含<strong class="jp ir">渲染</strong>DOM部分所需的数据</li><li id="6634" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">这样的<strong class="jp ir">数据是立即可用的</strong>，我们不需要进入嵌套JSONS的列表:这是因为<strong class="jp ir">我们将DOM模型与我们需要向API发送数据的任何结构分开</strong></li><li id="01ab" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">我们没有被迫保留人工对象来存储空的评论或回复，每一个信息都被DOM自然地获取并发送给API</li><li id="f14b" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">DOM 中不需要的用户数据没有冗余；实际上，我们提取用户ID的唯一地方是组件“<em class="kl"> comments </em>”，因为它是唯一向API发送数据的组件</li><li id="c846" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">这三个组件都受益于<strong class="jp ir">隔离</strong>和<strong class="jp ir">封装</strong>，这使得<strong class="jp ir">更有可能成为可重用的</strong>，尤其是“<em class="kl">回复</em>”:这是一个很好的成就，因为可重用性在前端更加困难。</li></ul></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="b10b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从API到DOM的数据流:一般思想</h1><p id="c913" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">为了完成我们的例子的实现，我们需要关心API(与后端模型的交互)，它将把我们的小实现变成完整的、自给自足的；之后，我们将讨论前端模型的设计，这对于一个独立的工作示例来说并不是绝对必要的，但是对于使组件与前端的其余部分进行交互来说却是必需的。</p><p id="1e18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于与API的交互，这本身就是一个我们应该分解成两个子任务的任务:</p><ol class=""><li id="debe" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">如何让数据从API流向DOM</li><li id="4119" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">作为DOM与用户交互的结果，如何向API发送信息</li></ol><p id="15d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">从API到DOM的数据流</strong>是本节及以下几段的主题；我想详细谈谈这个问题，因为我发现这是一个有争议的话题，会引起很多误解<strong class="jp ir"/>:<em class="kl">在我看来，这样的数据流通常是人们错误地围绕后端模型开发Angular应用程序的原因。</em></p><p id="6815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经看到了如何在第一个naif AngularJS实现中处理这样的数据流:API返回给我们一个嵌套的JSON，我们简单地用它来构造DOM。如果我们忘记了实现的所有其他缺陷，而只关注我们绑定到来自API的DOM数据的方式，我们可以概括出它背后的两个概念如下:</p><blockquote class="ng"><p id="9ba8" class="nh ni iq bd nj nk nl nm nn no np kk dk translated">我们将DOM直接绑定到“post”对象的属性上，只是因为API返回给我们一个“post”对象，并且很容易直接使用它</p></blockquote><p id="8ff3" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">然后，关于嵌套结构:</p><blockquote class="ng"><p id="4b62" class="nh ni iq bd nj nk nl nm nn no np kk dk translated">我们决定将回复绑定到父评论，将评论绑定到父帖子，只是因为API以嵌套JSON的形式返回数据</p></blockquote><p id="00f4" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated"><strong class="jp ir">换句话说，我们根据从后端接收到的任意数据结构来决定前端的架构。</strong></p><p id="6824" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不管我们设计的DOM模型有多好，我们使用的特定框架有多复杂和设计得多好，这样的架构决策仍然会严重影响我们的应用程序的质量，所以总是知道我们在做什么很重要。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="8d2d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从API到DOM的数据流:Angular2+中的naif实现</h1><p id="2697" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我现在将描述一个“混合”实现:我将在我们两段前开发的良好的Angular2+ DOM模型之上添加一种从API接收数据的方法，这是我们在AngularJS中实现的第一个naif实现的Angular2+模拟。</p><p id="9b64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">我的目标是表明，一个好的DOM模型不足以保证我们的应用程序设计良好且容易出错:不管DOM模型如何，如果我们没有正确使用从API接收的数据，我们的应用程序将会很脆弱，并容易出现不可预测的错误。</em> </strong></p><p id="3402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了不使我的代码片段变得太大，在下面的实现中，我将只关注如何使用我们从API获取的数据:我将在组件的装饰器中内嵌HTML，在某些情况下，我不会重复我们在两段之前已经描述过的一些函数和节点。</p><p id="fe89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是<em class="kl">岗位</em>的实现:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4d9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是对<em class="kl">注释</em>的实现</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a3cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后“<em class="kl">回复</em>”:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该实现引入的两个关键特性是:</p><ol class=""><li id="88cb" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">我们没有将DOM绑定到组件“<em class="kl"> PostComponent </em>”的属性，而是将它们绑定到对象“<em class="kl"> post </em>”的属性；(我们会发现这本身并不是一个问题，<em class="kl">问题在于我们使用了从API </em>接收到的同一个对象。)</li><li id="c0a3" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">数据不再传递给“<em class="kl">注释</em>”和“<em class="kl">回复</em>”，而是直接从API、<em class="kl">获取，而是从父组件传递给子组件，遵循API返回的JSON的嵌套结构</em>(在实现中，“<em class="kl"> post </em>”是唯一负责从API获取数据的组件，也是唯一实现“<em class="kl"> ngOnInit </em>”的组件)</li></ol><p id="0dfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个决定的结果是，出于我们示例的特定目的，<strong class="jp ir">尽管有Angular2+的语法和我们设计的DOM模型，最终的架构不是封装的，也不是稳固的</strong>。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="9cf8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从API到DOM的数据流:naif实现的意外、不可预测的错误</h1><p id="55b7" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">为了了解我们在做什么并分析新的实现，<em class="kl">我们需要至少对变更检测算法如何工作有一个大致的了解</em>。</p><p id="a4dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不打算详细说明:如果你想更深入地阅读，我建议你阅读这篇关于变化检测的伟大文章，还有这篇关于DOM插值的文章。</p><p id="b1f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变化检测使用一个<strong class="jp ir">递归算法</strong>:</p><ul class=""><li id="b202" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">该算法从<strong class="jp ir">根组件</strong>开始:它做的第一件事是重新计算和更新组件上的“<em class="kl"> @Input() </em>”绑定</li><li id="b1f0" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">然后，它提取子组件列表，并更新每个子组件上的“<em class="kl"> @Input() </em>”绑定</li><li id="97f2" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">该算法继续递归地做同样的事情，<strong class="jp ir">直到它找到一个叶组件</strong>(一个没有子组件的组件):在叶组件上，它传递到下一步，即<strong class="jp ir">更新对应于它们的模板的DOM </strong></li><li id="b92c" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">然后，它返回到父组件，并更新与其模板对应的DOM</li><li id="4ead" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">它递归地重复相同的操作，直到它回到一切开始的根组件:<strong class="jp ir">现在整个DOM被更新</strong></li></ul><p id="552e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使这是一个非常简单的变化检测算法的描述，它也比你在网上找到的大多数描述更多，因为它关注的是算法的递归性质，而这一点经常被忽略。</p><p id="8fa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，<strong class="jp ir">递归性是变更检测过程<strong class="jp ir">的核心</strong>，</strong>特别是决定<strong class="jp ir">如何更新一个组件</strong>的能力，仅仅基于它的状态和父组件的状态。</p><p id="d2bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当算法从父组件中寻找子组件时，它通常面临三种可能的情况:</p><ol class=""><li id="e88e" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">子组件<strong class="jp ir">只依赖于声明的输入</strong>，那些输入在它们的引用没有改变的情况下是不会改变的:<strong class="jp ir"> <em class="kl">这是最有利的情况，在这种情况下，你可以使用</em></strong><a class="ae mw" href="https://angular-2-training-book.rangle.io/handout/change-detection/change_detection_strategy_onpush.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kl">【on push】策略</em> </strong> </a> <strong class="jp ir"> <em class="kl">并从变更检测中分离出整个子组件的子树</em> </strong></li><li id="0833" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">子组件只依赖于声明的输入，但是那些输入是属性可以改变的<strong class="jp ir">对象，同时仍然保持相同的对象引用:<strong class="jp ir"> <em class="kl">在这种情况下，不可能跳过对子树的更改检测，因为Angular2+可能没有意识到子树中的某些内容已经改变</em> </strong>(出于性能原因，Angular2+只在引用改变时更新绑定)</strong></li><li id="2a6b" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">子组件<strong class="jp ir">不仅仅依赖于它的输入</strong>，因为它还从API或其他外部服务获取数据:<strong class="jp ir"> <em class="kl">在这种情况下，优化也是不可能的，并且必须对整个子树</em> </strong>运行变更检测</li></ol><p id="62d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们准备看看我们最新实现的具体情况；这是<em class="kl">后件</em>的模板:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ebc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当变更检测发现这个模板时，你能说出我们处于三个描述场景中的哪一个吗？</p><p id="790a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它不能是前两者中的任何一个，因为组件显然不依赖于它声明的输入:事实上，组件没有任何输入，因为它的全部内容是由对API的调用决定的。</p><p id="bbcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但问题是，令人惊讶的是，我们也不在第三种场景中，<strong class="jp ir">，因为模板的状态不仅仅取决于API </strong>。</p><p id="8f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们实际上是在第四个场景中，当我们开始查看变化检测算法时，这似乎是不可能的:<strong class="jp ir"> <em class="kl">用于填充模板的对象“post”不仅可由API修改，而且它可能被从API服务获取相同JSON的任何其他服务或组件修改。</em> </strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0ede" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码片段中，“<em class="kl"> ApiService </em>”将返回的JSON缓存在一个实例属性中，这是避免不必要的外部调用的好方法。<strong class="jp ir"> <em class="kl">但是，由于我们直接将从API服务接收到的对象绑定到DOM，我们的组件现在暴露于微不足道的错误</em> </strong>，就像“<em class="kl">AddMisterToUserNameService</em>中的错误。</p><p id="3afb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直接绑定到从API接收的DOM对象的组件并不是孤立的，不管你的DOM模型设计得有多好。</p><p id="f063" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何防止这个问题，并使我们的组件隔离？让我们退后一步，问自己另一个问题:我们真的希望我们的组件被隔离吗？</p><p id="8c7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，在某些情况下，最好在DOM中的任何地方自动传播模型中发生的变化；<em class="kl">但是，如果我们处于这种情况，我们应该有意识地决定传播这些变化:我们不应该把它作为将API适配器返回的对象绑定到DOM的副作用，仅仅因为它很容易。</em></p><p id="8b41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的具体例子中，特别是因为我们正在查看一个独立的例子，而不知道应用程序其余部分的上下文，我们肯定不希望能够全局更新对象“<em class="kl"> post </em>:所以让我们来看看实现封装的可能解决方案。</p><p id="de7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们希望我们的组件被隔离，我们应该<strong class="jp ir">在DOM模型中复制我们需要的每个属性</strong>，或者<strong class="jp ir">让API适配器在检索之前复制整个对象</strong>；如果我们选择第二个选项，实现它的最佳方式是将API数据包装到一个前端模型中。</p><p id="a05f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">如果我还没有谈到前端模型，那只是因为</em> <strong class="jp ir"> <em class="kl">我真的想把重点放在正确的架构设计流程上</em> </strong> <em class="kl">，那应该总是从DOM模型开始，然后，抽象前端模型；事实上，只有当您连接应用程序的不同部分时，您才开始需要前端模型，并且像我们正在研究的这样的独立示例可以在没有任何抽象模型的情况下完美地存在。无论如何，在这篇文章结束之前，我将把一些话献给前端模型。</em></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="195f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再看前端模型类的构造函数"<em class="kl"> Post </em>":</p><ul class=""><li id="169b" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">它<strong class="jp ir">将JSON的每个相关属性</strong>复制到一个本地属性中，所以每次我们实例化一个新的"<em class="kl"> Post </em>"对象时，我们都会得到这些属性的不同副本</li><li id="7c36" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">它过滤掉所有可能来自API的不必要的属性(我们忽略了冗余数据)</li><li id="affa" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">我将JSON类型保留为“<em class="kl"> any </em>”，因为JSON来自API，不受我们的控制</li></ul><p id="7b90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看API数据流的naif实现的另一个潜在风险:<em class="kl">回复数组被绑定到父“CommentsComponent”，注释数组被绑定到父“PostComponent”。</em></p><p id="d699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很明显，我们有同样的非隔离问题，正如我们对“<em class="kl"> Post </em>对象所评论的，因为那些数组都直接来自API适配器服务；但是在这种情况下，还存在额外的风险，因为阵列可能会被父组件本身意外修改:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d431" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码片段中，我们忘记了“<em class="kl"> post </em>对象已经有了一个名为“<em class="kl"> comments </em>的属性”(因为这样的组件没有在任何地方显式声明，因为我们是直接从API中注入的)，我们不小心用它存储了其他东西。这个错误的副作用是，我们会不小心抹掉所有与评论和回复相关的HTML(甚至可能破坏应用程序)。</p><p id="4292" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能这个特定的错误在真实的应用程序中不太现实，但它为我的目的服务:<em class="kl">我想强调我们漂亮的DOM模型是如何被我们从API导入数据的方式意外削弱的。</em></p><p id="67b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用我们设计的架构，我们让“<em class="kl">后置组件</em>”负责所有评论、回复和任何其他子组件的DOM呈现:<strong class="jp ir"> <em class="kl">和前面的例子一样，我们必须问自己是否真的想要实现它，或者我们是否因为来自API </em> </strong>的数据结构而意外地做到了。</p><p id="ff21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然在很多情况下，我们希望组件的子树可以从根组件完全修改(例如，在管理界面中，我们希望用户能够在任何嵌套级别对项目进行排序)，但是<strong class="jp ir">我们绝对不希望它出现在这里</strong>:用户不应该能够通过在"<em class="kl"> post </em>组件上执行操作来修改评论和回复。我们设计的所有子组件都应该被隔离。</p><p id="a5d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为在这样的架构错误背后有一个更深层次的问题:</p><blockquote class="ng"><p id="73d6" class="nh ni iq bd nj nk nl nm nn no np kk dk translated">人们经常混淆首次呈现和更新DOM的过程。</p></blockquote><p id="1930" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated"><strong class="jp ir">事实上，为了第一次呈现DOM，我们需要将评论连接到帖子和对评论的回复，这并不意味着这些连接实际上是使DOM与用户交互所必需的。</strong></p><p id="df04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想为这个问题提出的解决方案应该有一个单独的段落，所以我在这里总结一下。</p><p id="cf9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了结束这一段，我想用几句话再次总结以下重要概念:我们从一开始就说过，当设计DOM模型时，我们不应该受后端模型结构的影响；<strong class="jp ir"> <em class="kl">同样，当我们设计从后端到DOM的数据流时，我们不应该受到来自API </em> </strong>的数据结构的影响。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="4982" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从API到DOM的数据流:一种强制隔离的模式</h1><p id="a0b6" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">为了保持隔离，我们看到我们需要做以下事情:</p><ol class=""><li id="9351" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">不要在DOM模型(Angular2+ components)中使用API返回的相同JSON</li><li id="0683" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">削减来自API的内容，使其只包含我们需要的数据</li><li id="c75b" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">以某种方式使用API <strong class="jp ir">只是为了第一次</strong> <strong class="jp ir">渲染DOM</strong>，并且在第一次渲染之后保持组件相互隔离</li></ol><p id="8019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们在作为API适配器的同一个服务中实现了(1)和(2 );但是，最好不要去管API适配器，而是将这个逻辑放在一个单独的服务中，这样还可以处理第(3)点。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="725d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该服务充当API适配器和我们的DOM模型之间的<strong class="jp ir">中介</strong>:当您调用方法“<em class="kl"> storePost </em>时，该服务:</p><ul class=""><li id="3d80" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated"><strong class="jp ir">调用一次API适配器</strong></li><li id="ca18" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">使用对类型为"<em class="kl"> post </em>"、"<em class="kl"> comments </em>"和"<em class="kl"> replies </em>"的<strong class="jp ir">初始化前端模型对象</strong>(我们将删除不必要数据的责任委托给这些对象的类，并确保没有对原始JSON的引用)</li><li id="2064" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated"><strong class="jp ir">在</strong>内部存储这些对象 <strong class="jp ir">，并提供获取它们的方法</strong></li></ul><p id="bf9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，API适配器不再负责缓存响应，因为缓存是在"<em class="kl"> PostApiService </em>"中完成的:最好让API适配器只负责一件事，即与后端通信。</p><p id="d2bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何在我们的组件中使用这个服务？</p><p id="9357" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想到的想法是，根“<em class="kl">后置组件</em>”应该以某种方式初始化这个服务，然后<strong class="jp ir">使它只对它的子树</strong>中的所有组件可用:这样，如果其他的“<em class="kl">后置组件</em>”出现在同一个页面中，就不会有混淆的风险。</p><p id="4c39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Angular2+的依赖注入的一个很酷的特性就在这里出现了:<strong class="jp ir"> <em class="kl">通过在组件</em> </strong>的级别注入来创建一个提供者的单独实例。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5abf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">瞧啊。这是“<em class="kl">后组件</em>”的最终优化版本。</p><ul class=""><li id="d4e1" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">提供者"<em class="kl"> PostApiService </em>"是在组件级别注入的，因此该组件及其所有子组件将获得其单独的副本，不存在与"<em class="kl"> PostComponent </em>"的其他实例冲突的风险</li><li id="dba1" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">帖子的ID作为输入传递给组件，然后组件使用它来初始化"<em class="kl">PostApiService</em>"；这发生在“<em class="kl"> ngOnInit </em>”生命周期挂钩期间，因此“<em class="kl"> PostApiService </em>”的实例将在子组件的所有“<em class="kl"> ngOnInit </em>”挂钩中可用(因为它们都是在父组件的“<em class="kl"> ngOnInit </em>”之后调用的)</li><li id="80f5" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">我们安全地将"<em class="kl"> Post </em>"的实例绑定到DOM，因为我们知道模型的接口包含了我们需要在DOM中公开的变量；此外，因为我们确信这个实例只属于我们，它不会在应用程序中传播，也不会有被意外修改的风险</li><li id="3225" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">我们不传递任何"<em class="kl"> @Input() </em>"绑定到组件"<em class="kl">注释</em>"，因为该组件已经知道如何通过我们提供的本地服务实例获取其数据</li></ul><p id="c2c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">顺便记住，当一个组件依赖于一个API调用时，你应该</em> <a class="ae mw" href="https://blog.thoughtram.io/angular/2016/10/10/resolving-route-data-in-angular-2.html" rel="noopener ugc nofollow" target="_blank"> <em class="kl">在路由器</em> </a> <em class="kl">中解析它，否则当API收到响应时DOM会闪烁。</em></p><p id="6fba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将用剩余两个组件的实现来结束这一段:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="18a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意"<em class="kl">comments component</em>" delegates "<em class="kl">PostApiService</em>"如何将数据发送到API:"<em class="kl">comments components</em>"不知道评论附加到的帖子的ID，但是因为它使用了"<em class="kl"> PostApiService </em>的特定实例，所以我们可以确保每个调用都在根帖子下面。</p><p id="f6c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还要注意，这一次我们使用了类型:将来自API的数据包装在前端模型中是一种安全的方式，可以防止应用程序其他部分的意外修改。</p><p id="4eaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，请注意我们是如何将父注释的索引传递给“<em class="kl"> RepliesComponent </em>”的，以及子组件是如何使用它从“<em class="kl"> PostApiService </em>”获取适当的回复数组的。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="05be" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">这种模式的概括:模型和责任的分离</h1><p id="6f1e" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">以上实现背后的关键词是<strong class="jp ir">分离</strong>:</p><ul class=""><li id="9f31" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">将DOM模型从后端模型的逻辑中分离出来，这有助于我们平稳、无干扰地设计DOM功能</li><li id="2ad5" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated"><strong class="jp ir">第一次渲染</strong>与随后与用户的交互分离，因为我们不绑定对评论的回复和对帖子的评论:在第一次渲染期间，我们更愿意使用外部服务作为将数据传递给子组件的替代方式</li><li id="7971" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated"><strong class="jp ir">职责分离</strong>，因为并非所有组件都负责与API交互</li></ul><p id="4b83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们选择<strong class="jp ir">从API </strong>获取数据的组件是根组件<em class="kl">后置组件</em>，因为这是唯一知道文章ID的组件。该组件不直接获取数据，但它通过初始化“<em class="kl"> PostApiService </em>”来获取数据，PostApiService 反过来调用API并安全地存储该组件及其子组件需要的所有对象。</p><p id="a52b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们选择<strong class="jp ir">向API </strong>发送数据的组件是“<em class="kl"> CommentsComponent </em>”，因为这是保存用户正在做什么的所有知识的组件(记住子组件“<em class="kl"> RepliesComponent </em>”是父组件不可知的)。</p><p id="d93b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个选择都是有意的，因为以不同的方式做事会给架构增加不必要的复杂性:</p><p id="cf15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果“<em class="kl"> CommentsComponents </em>”负责初始化“<em class="kl"> PostApiComponent </em>”，那么我们必须向其传递帖子的ID(冗余信息)；此外，如果将来我们必须向"<em class="kl">后置组件</em>"(即"<em class="kl"> CommentsComponent </em>")添加更多子组件，我们将如何获取数据来填充它们？</p><p id="b6d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，如果"<em class="kl">后置组件</em>"负责向API发送数据，我们将不得不从"<em class="kl"> CommentComponents </em>"转发四个不同的事件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f0cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这会给系统增加不必要的复杂性。</p><p id="dfdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于"<em class="kl"> PostApiService </em>"的作用，最后说一下:<em class="kl">这个服务可能是前端开发人员和不必要的API调用之间永恒斗争的解决方案。</em></p><p id="a4b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从前端架构的角度来看，用数据填充独立组件的理想方式是让每个组件直接从API获取自己的数据；但是，如果我们这样做，我们会用太多的外部呼叫来填充用户的连接，在低网络条件下，应用程序会变得太慢。</p><p id="4753" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是有了像我们设计的这样的作用域API适配器，我们就能够</p><ul class=""><li id="f880" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">查看API并确定单次调用可以提供的DOM的最大区域</li><li id="7bea" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">将该区域包装在一个空组件中，该组件唯一职责是初始化作用域API适配器</li><li id="4a07" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">API适配器调用API一次，并存储所有必需的对象</li><li id="1da0" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">最后，子树中的每个组件都可以调用API适配器，就像它是真正的API一样，而不需要对后端进行不必要的调用</li></ul></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="545f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">如何向“不友好”的API发送数据</h1><p id="c83c" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我们谈了很多关于从API到DOM模型的数据流，让我们花点时间谈谈另一个方向的数据流。</p><p id="b761" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当向后端提交数据时，主要问题在于<strong class="jp ir">API没有针对前端进行优化</strong>。例如，我们希望实现post加评论加回复的最佳API应该是这样的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fa67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，有时API并没有像上面那样设计得很好；而且通常API不在我们的控制之下，不容易修改(因为，例如，后端可能外包给外部公司)。下面是一个糟糕的API:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3389" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个API真的很难交互，因为它只接受帖子、评论、回复的完整JSON。前端开发人员可能会尝试让组件自己构建大型JSON，并在用户交互时保持更新:但我们已经看到这不是一个好的选择，并且<strong class="jp ir"> <em class="kl">我们不想仅仅因为API没有被正确设计而修改我们的前端架构</em> </strong>。</p><p id="920b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正确的解决方案是使用“<em class="kl"> PostApiAdaptor </em>”:在从API获取数据的时候，服务确实收到了表示帖子的JSON，所以存储它并在每次组件发送动作时保持它的更新就足够了。</p><p id="8803" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，组件使用最适合它们的<strong class="jp ir"> API与服务进行交互</strong> (" <em class="kl"> deleteComment </em>"，"<em class="kl"> postComment </em>"等等。):我们现在可以说我们的组件已经变成了<strong class="jp ir"> API不可知的</strong>，因为我们可以用任何其他API适配器替换“<em class="kl"> PostApiService </em>”来提供这些方法。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="ab30" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">前端模型保存的数据与后端模型中的任何数据都不对应</h1><p id="4c98" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">前端模型是前端实体的抽象:我们通常需要它们来保持这些实体在整个应用程序中的一致性。</p><p id="c885" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到，在本文大部分时间里我们所遵循的post + comments + replies的例子中，我们几乎从来没有提到过前端模型:只有当我们必须找到一种解决方案来应对将DOM绑定到整个应用程序共享的对象的风险时，我们才引入前端模型。</p><p id="38a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原因是，在我看来，在设计架构的时候，我们应该首先关注DOM模型:<strong class="jp ir"> <em class="kl">前端模型只有在DOM模型已经设计好之后才出现</em> </strong>，因为这些模型是进一步的抽象，其目的是使单独的组件相互交互并保持系统的一致性。因此，在一个单独的例子中，前端模型并不重要。</p><p id="24d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我从本文开始就一直重复的，前端模型通常与后端模型相似，但它们不可能完全相同。我已经说过，后端模型包含前端不需要的数据是多么常见，<strong class="jp ir"> <em class="kl">现在我想展示一个相反的例子:一个前端模型包含后端中没有对应关系的数据</em> </strong>。</p><p id="f94e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们想象一下，在我们应用程序的其他地方，有一个状态栏显示当前用户的统计数据，包括一个根据用户在过去24小时内发布的评论/回复数量而改变颜色的徽章。</p><p id="6471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了保持状态栏的一致性，我们需要某种共享服务来保存用户数据:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9630" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个前端模型“<em class="kl">用户</em>”包含了一个不能保存在后端的属性，<strong class="jp ir"> <em class="kl">，因为它抽象了一个只存在于前端</em> </strong>的纯视觉属性。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="c08e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">结论</strong></h1><p id="dc91" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">DOM模型应该只包含直接在DOM中使用的属性，以及直接从DOM中调用的函数；任何更长或更复杂的功能都应该被重构并提取到服务中。</p><blockquote class="ng"><p id="e4c2" class="nh ni iq bd nj nk nl nm nn no np kk dk translated">首先，设计用户交互，并将它们抽象在一个可靠的、良好的DOM模型中(甚至在查看后端的数据结构之前)</p></blockquote><p id="f873" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">前端模型应该是在前端看到的实体的抽象:除了后端的常规属性之外，它们还应该包含需要在前端的不同组件上共享的其他属性。</p><blockquote class="ng"><p id="9398" class="nh ni iq bd nj nk nl nm nn no np kk dk translated">第二，决定你必须在前端模型中抽象出哪些实体，以及如何抽象:在这个阶段，你已经可以有一个完全工作的应用程序，你只需要创建模拟与API交互的服务</p></blockquote><p id="258f" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">在设计前端架构时，后端模型和相关的API结构不应该影响您的选择。</p><blockquote class="ng"><p id="39f0" class="nh ni iq bd nj nk nl nm nn no np kk dk translated">最后，连接你的前端和后端:理想情况下，尝试简化和优化你的前端的API，如果不可能，使用你创建的API适配器来解决这个问题</p></blockquote></div></div>    
</body>
</html>