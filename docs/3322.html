<html>
<head>
<title>Deep in the Weeds with Reactime, Concurrent React _fiberRoot, and Browser History Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">《野草在深处:反应时间》、《并发反应_fiberRoot》和浏览器历史缓存</h1>
<blockquote>原文：<a href="https://itnext.io/deep-in-the-weeds-with-reactime-concurrent-react-fiberroot-and-browser-history-caching-7ce9d7300abb?source=collection_archive---------6-----------------------#2019-11-21">https://itnext.io/deep-in-the-weeds-with-reactime-concurrent-react-fiberroot-and-browser-history-caching-7ce9d7300abb?source=collection_archive---------6-----------------------#2019-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/504776cc0f5660adde3eefd7a93cd514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICAhYS7swXMI7kN8sN6MWw.jpeg"/></div></div></figure><p id="ad6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">Reactime me:开源Chrome开发工具，用于跟踪和可视化reaction应用程序中的状态变化</em></p><p id="d774" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">这是对构成Reactime核心功能的技术的低级审查。如果您对更高级别的概述感兴趣，</em> <a class="ae kx" href="https://medium.com/@chriswillsflannery_54084/time-traveling-state-debugger-reactime-now-supporting-concurrent-mode-routers-and-more-56f9ca6f7601" rel="noopener"> <em class="kw">请点击此处。</em> </a></p><p id="8c5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">简介</em> </strong></p><p id="bcff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Reactime是一个chrome扩展，允许开发人员逐步完成他们应用程序中的一系列状态更改，允许他们探索事件链是如何以很大的粒度启动的。它建立在一个类似于<a class="ae kx" href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en" rel="noopener ugc nofollow" target="_blank"> Redux DevTools </a>的用户界面上，但是适用于Hooks、Context API、常规的旧的有状态类组件，现在是并发模式(如果您不熟悉，不用担心——我们会讲到这一点。)听起来不错吧？很好，让我们潜入…</p><p id="6a4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="kw">reaction me是如何工作的？</em> </strong></p><p id="52bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在其核心，Reactime是一个<strong class="ka ir">函数</strong>导出另一个<strong class="ka ir">函数</strong>导出另一个<strong class="ka ir">函数</strong>。<em class="kw">深呼吸</em>。Reactime的核心位于linkFiber.js模块中，这是大多数业务逻辑的所在地。linkFiber.js本质上是一个助手函数链，它们按顺序相互调用，构建一个当前React Fiber树的副本，并检查我们使用的是哪种<em class="kw">类型的</em>状态(即有状态组件、钩子或上下文api ),并具有相应处理每种情况的逻辑。TL；灾难恢复:每次在附带的应用程序中进行状态更改时，Reactime扩展都会创建当前状态的树“快照”，并将其添加到扩展中快照的当前“缓存”中。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ky"><img src="../Images/dcb2fe60c63b0da43ff67a218a267a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bR9iMXLGQyz-h0vj"/></div></div></figure><p id="8935" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">我们需要更深入</em> </strong></p><p id="1104" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我说一个<strong class="ka ir">函数</strong>返回一个<strong class="ka ir">函数</strong>返回一个<strong class="ka ir">函数</strong>时，那意味着，linkFiber.js是一个模块，它导出一个存在于index.js中的生命，这个函数导出一个函数，它包装了我们的HTML结构的根，比如document.getElementById('root ')。通过获取DOM元素的根，我们能够基于应用程序中元素的层次结构构建纤程树，遍历树的每个分支，并根据需要适当地解析或丢弃元素(例如，我们选择<strong class="ka ir">保留</strong>有状态组件纤程，但<strong class="ka ir">丢弃</strong>悬念和其他符号类型表示的纤程)。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/113659d3ea875094cfe5e016ec15cfab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/0*crtMJxBRDIKHv3uA"/></div></figure><p id="c1fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">解析钩子组件&amp;与AST的</em> </strong>一起工作</p><p id="9dca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据您正在处理的状态的类型，纤程树的构造会有所不同——一些属性会“丢失”,一些属性会在其他位置，而一些全新的属性会出现。在一个使用React钩子的应用程序中，一些真正有趣的事情发生了。因为基于钩子的纤程树根明显缺少stateNode属性，取而代之的是一个填充的memoizedState，所以我们可以使用Acorn(一个解析库)从钩子结构中获取根类型并构造一个抽象语法树，以便提取钩子getters并将它们与对象中相应的setters相匹配。这个对象将被导出(由astParser.js ),并被发送回linkFiber.js，钩子将被保存在那里，我们可以移动到下一个子节点或兄弟节点，基本上重复这个过程。</p><p id="679f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里最有趣的设计选择之一是，之前负责Reactime的团队选择实现一个函数来改变<em class="kw"> setState </em> dispatch或hooks等价物的功能，在新的<em class="kw"> setState </em>中，它不仅调用旧的功能，还更新当前状态快照树，并将该快照发送回UI。当我们使用chrome扩展的时间旅行功能时，这允许我们实时查看UI更新。非常好的东西！</p><p id="21eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">纤根vs并发纤根</em> </strong></p><p id="f21f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还记得我在<em class="kw">深入</em>部分说过函数需要包装HTML根吗？这在并发模式下不太适用——因为设置有点不同。并发模式要求开发人员将HTML根包装在一个新的React函数中，该函数(在幕后)使用一系列函数来手动创建一个纤程根，进而呈现我们的&lt; App/ &gt;组件。然后，我们可以获取createRoot的计算结果，并使用_reactRootContainer调用reactime()来启动该流程。在并发模式下，如果我们试图以旧的方式调用react ime(document . getelementbyid(' root '))，它会出错——不会出现_fiberRoot(位于HTML结构顶部的一个不可见的顶级HTML组件)。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/8f82f0999625feef973a747a7883d0d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7ud1HskZwZLWf6Kg"/></div></div></figure><p id="628d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">上下文模仿通量架构</em> </strong></p><p id="dd44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Reactime利用React挂钩和带有功能组件的上下文API，使用Flux设计模式创建单个状态存储，使用useReducer处理复杂的状态逻辑，消除不必要的prop钻探和Redux实现的开销。Reactime将这种模拟的主状态用于功能组件，允许进行时间旅行调试。</p><p id="9d68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">T7】React路由器&amp;浏览器历史缓存T9】</strong></p><p id="f951" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当从不同的端点对先前状态进行时间旅行调试时，如果路由不持久，React路由器将无法在快照中挂载组件。我们可以利用浏览器的历史API为每次时间跳转推送State()，使Reactime能够重新装载当前快照中引用的组件。递归遍历React纤程树，我们寻找路由器节点来记录当前状态的路径，并将状态添加到浏览器的会话历史堆栈中。在调用pushState()后，浏览器不会尝试加载此URL，新的URL会相对于当前URL进行解析。</p><p id="2025" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">尚未解决的问题</em> </strong></p><p id="d808" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们仍在解决一些问题——我们还没有真正用GraphQL、Apollo和Relay广泛测试Reactime。此外，尽管我们可能会尝试，但我们似乎还没有弄清楚为什么第一次钩子点击没有在DOM中注册。根据Reactime 2.0合作者Andy:</p><p id="9635" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“我想我有一个好主意。在webpack配置设置中，创建一个模板，在其中将一个页脚div添加到所有客户端页面的最末尾。让树继续构建，只在页脚div渲染时创建快照。理论上，这应该是所有linkFiber linkedlists上的最后一个节点，也可能是您尝试用钩子捕获第一个点击问题的地方。”</p><p id="b60f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们会成功的——一步一步来。</p><p id="8f8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Reactime是一个开源项目，非常欢迎你——读者——参与合作，让它变得更好。我们当然会感谢任何和所有的帮助！即使你只是想尝试一下——到处玩，打破东西，在<a class="ae kx" href="https://github.com/open-source-labs/reactime" rel="noopener ugc nofollow" target="_blank"> github </a>上发表一期，检查一下，让我们知道你的想法。一定要下载<a class="ae kx" href="https://chrome.google.com/webstore/detail/reactime/cgibknllccemdnfhfpmjhffpjfeidjga" rel="noopener ugc nofollow" target="_blank"> chrome扩展</a>！</p><p id="055d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">干杯，</p><p id="26b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Reactime 3.0团队</p></div></div>    
</body>
</html>