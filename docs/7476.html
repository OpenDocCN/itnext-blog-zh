<html>
<head>
<title>Journey Of A Microservice Application In The Kubernetes World</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes世界的微服务应用之旅</h1>
<blockquote>原文：<a href="https://itnext.io/journey-of-a-microservice-application-in-the-kubernetes-world-eb0fb52e1bf0?source=collection_archive---------7-----------------------#2022-10-05">https://itnext.io/journey-of-a-microservice-application-in-the-kubernetes-world-eb0fb52e1bf0?source=collection_archive---------7-----------------------#2022-10-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a340" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">安全考虑:修复错误配置</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a3f3c5f4274ddc0d034254788d5405b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQBGYRfiu5CYyzA-BgeoNA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/fixing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@kilianfoto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kilian Seiler </a>拍摄的照片</figcaption></figure><h2 id="5fe3" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="a8b9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在本系列的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-6abd625c60fe">上一篇文章</a>中，我们介绍了一些用于审计集群和/或集群内运行的应用程序的安全工具。我们现在将使用其中一些工具的结果来修复配置问题，并确保应用程序的规范遵循一些最佳安全实践。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="6574" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">本系列文章</h2><ul class=""><li id="d516" class="mv mw it lx b ly lz mb mc li mx lm my lq mz mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-bdfe795532ef">web hooks . app的展示</a></li><li id="476a" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-3c2a9e701e9f">使用Helm在本地单节点Kubernetes上运行应用</a></li><li id="bd90" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-e800579f0be3#0174-87b0e3c1fcd3">在Civo Kubernetes集群上运行应用</a></li><li id="35a3" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-d9493b19edff">使用GitOps和Argo CD进行连续部署</a></li><li id="12ce" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-876f72ce1681">使用Loki堆栈的可观察性</a></li><li id="f5d5" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-e2f6475ddde1">使用Acorn定义应用</a></li><li id="f1c1" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-6abd625c60fe">安全注意事项:安全相关工具</a></li><li id="7bea" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">安全性考虑:修复错误配置(本文)</li><li id="3c61" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-f760cba7600f">安全考虑:政策执行</a></li><li id="321c" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">安全考虑:漏洞扫描(即将推出)</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="765e" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">强化webhooks应用程序</h2><p id="b7be" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">根据上一篇文章中介绍的工具的结果，我们已经可以通过以下更改使webhooks应用程序更加安全:</p><ul class=""><li id="543e" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated">添加一个<strong class="lx iu"> securityContext </strong>(在Pod和/或容器级别)以防止容器在不遵循安全最佳实践的情况下在集群中运行</li><li id="d7ad" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">如果不需要，确保ServiceAccount的令牌没有装入容器的文件系统中(阅读:如果Pod不需要与API服务器通信)</li><li id="6b4e" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">确保每个容器都为它需要使用的资源定义了请求和限制</li><li id="8bea" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">使用AppArmor配置文件来限制允许容器做什么</li></ul><p id="5ecc" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注意:我们将关注这些变化，并将在本系列的后续文章中详细介绍其他可能的增强</p><p id="e321" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">让我们以api微服务的简单部署为起点:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="2b1f" class="kz la it ns b gy nw nx l ny nz">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: api<br/>  name: api<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: api<br/>  template:<br/>    metadata:<br/>      labels:<br/>      app: api<br/>    spec:<br/>      containers:<br/>        - image: registry.gitlab.com/web-hook/api:v1.0.33<br/>          name: api</span></pre><p id="64fa" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">首先，我们在api容器下添加内存和cpu请求和限制:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="4df8" class="kz la it ns b gy nw nx l ny nz">resources:<br/>  requests:<br/>    memory: 256Mi<br/>    cpu: 200m<br/>  limits:<br/>    memory: 256Mi <br/>    cpu: 200m</span></pre><p id="a17d" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注意事项:</p><ul class=""><li id="1aff" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated">对<em class="oa">requests . CPU</em>/<em class="oa">limits . CPU、</em>和<em class="oa">requests . memory</em>/<em class="oa">limits . memory</em>使用相同的值可以确保Pod的QoS设置为有保证(在主机上发生资源争用的情况下，它不太容易被驱逐)</li><li id="fa2d" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">我们在这里为cpu和内存指定的值可以在以后根据我们在Loki堆栈中观察到的资源消耗进行优化</li></ul><p id="88a6" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">接下来，我们添加一个<em class="oa"> securityContext </em>属性(仍然在api容器下):</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="ce5b" class="kz la it ns b gy nw nx l ny nz">securityContext:<br/>  allowPrivilegeEscalation: false<br/>  readOnlyRootFilesystem: true<br/>  runAsUser: 10000<br/>  runAsNonRoot: true<br/>  seccompProfile:<br/>    type: RuntimeDefault<br/>  capabilities:<br/>    drop:<br/>    - ALL</span></pre><p id="05bb" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">这些设置确保:</p><ul class=""><li id="4412" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated">容器内的进程不能拥有比主进程更多的权限</li><li id="1bc0" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">该容器有一个只读文件系统(以避免攻击者在容器中安装额外的包，以防他设法在其中安装一个shell)</li><li id="880d" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">容器以非根用户的专用用户运行(指令<em class="oa"> runAsUser </em>和<em class="oa"> runAsNonRoot </em>都可以使用，因为它们进行不同的检查)</li><li id="d3ea" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">设置了一个seccomp配置文件，它限制了容器可以使用的系统调用</li><li id="71f4" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">容器无法访问他们不需要的功能</li></ul><p id="259b" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">接下来，我们在pod规范中添加以下属性，以确保服务帐户的令牌没有安装在容器的文件系统中。不需要与API服务器通信的Pod不需要访问ServiceAccount令牌。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="4d0a" class="kz la it ns b gy nw nx l ny nz">automountServiceAccountToken: false</span></pre><p id="84f2" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">接下来，我们添加一个注释，为api容器提供容器运行时的默认AppArmor配置文件:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="d062" class="kz la it ns b gy nw nx l ny nz">annotations:<br/> container.apparmor.security.beta.kubernetes.io/api: runtime/default</span></pre><p id="46f9" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">更新后，api微服务的部署规范如下所示:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="de3a" class="kz la it ns b gy nw nx l ny nz">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  <strong class="ns iu">labels:<br/>    app.kubernetes.io/name: api<br/>    app.kubernetes.io/part-of: webhooks<br/>    app.kubernetes.io/version: v1.0.33<br/>  annotations:<br/>    container.apparmor.security.beta.kubernetes.io/api: runtime/default</strong><br/>  name: api<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: api<br/>  template:<br/>    metadata:<br/>      labels:<br/>      app: api<br/>    spec:<br/>      <strong class="ns iu">automountServiceAccountToken: false</strong><br/>      containers:<br/>        - image: registry.gitlab.com/web-hook/api:v1.0.33<br/>          name: api<br/>          <strong class="ns iu">resources:<br/>            requests:<br/>              memory: 256Mi<br/>              cpu: 200m<br/>            limits:<br/>              memory: 256Mi <br/>              cpu: 200m<br/>          securityContext:<br/>            allowPrivilegeEscalation: false<br/>            readOnlyRootFilesystem: true<br/>            runAsUser: 10000<br/>            runAsNonRoot: true<br/>            seccompProfile:<br/>              type: RuntimeDefault<br/>            capabilities:<br/>              drop:<br/>              - ALL</strong></span></pre><p id="514a" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注意:同时我们也修改了部署元数据，所以它使用了一些推荐的标签</p><p id="a99e" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">在第一次尝试中，我们将对其他部署规范(ws、www、mongo和nats)执行完全相同的更改。。</p><p id="bce8" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">为了检查一切是否按预期运行，我们首先在一个本地集群上运行应用程序helm图表(我使用Helmfile，详见<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-3c2a9e701e9f">上一篇文章</a>):</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="a75f" class="kz la it ns b gy nw nx l ny nz">$ helmfile apply</span></pre><p id="5e9e" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">接下来，我们确保pod运行正常:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="e0e1" class="kz la it ns b gy nw nx l ny nz"><strong class="ns iu">$ kubectl get po -n webhooks<br/></strong>NAME                     READY  STATUS             RESTARTS      AGE<br/>nats-6bcb57fc6d-qp5m9    1/1    Running            0             46s<br/>ws-55fb4bc9f7-5b8zp      1/1    Running            0             46s<br/>mongo-7b8b4fb696-cvvjs   0/1    CrashLoopBackOff   2 (30s ago)   46s<br/>api-66869bffc4-nml64     0/1    CrashLoopBackOff   2 (25s ago)   46s<br/>www-548d4b5b8c-59rsc     0/1    CrashLoopBackOff   2 (17s ago)   46s</span></pre><p id="8e9f" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">从上面的结果我们可以看到，只有<em class="oa"> ws </em>和<em class="oa"> nats </em>在无错运行，为什么？嗯……我们在没有考虑每个微服务的特殊性的情况下，对每个部署都增加了限制。让我们逐一回顾一下，并尝试了解为什么有些pod没有运行。</p><ul class=""><li id="9473" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated"><strong class="lx iu"> api </strong></li></ul><p id="9705" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">这个微服务是用python / flask构建的，框架需要一个可写的临时文件夹。为此，我们可以创建一个<em class="oa"> EmptyDir </em>卷，并将其挂载到容器的文件系统中(在<em class="oa"> /tmp </em>中)。除了这个文件夹，容器的文件系统可以是只读的。</p><p id="fd6e" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">api微服务nows的部署规范如下所示:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="1483" class="kz la it ns b gy nw nx l ny nz">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: api<br/>  name: api<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: api<br/>  template:<br/>    metadata:<br/>      labels:<br/>      app: api<br/>    spec:<br/>      automountServiceAccountToken: false<br/>      containers:<br/>      - image: registry.gitlab.com/web-hook/api:v1.0.33<br/>        name: api<br/>        resources:<br/>          requests:<br/>            memory: 256Mi<br/>            cpu: 200m<br/>          limits:<br/>            memory: 256Mi <br/>             cpu: 200m<br/>        securityContext:<br/>          allowPrivilegeEscalation: false<br/>          readOnlyRootFilesystem: true<br/>          runAsUser: 10000<br/>          seccompProfile:<br/>            type: RuntimeDefault<br/>          capabilities:<br/>            drop:<br/>             - ALL<br/><strong class="ns iu">        volumeMounts:<br/>        - name: tmp<br/>          mountPath: /tmp<br/>      volumes:<br/>      - name: tmp<br/>        emptyDir: {}</strong></span></pre><ul class=""><li id="5d70" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated"><strong class="lx iu"> www </strong></li></ul><p id="6615" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">当<em class="oa"> readOnlyRootFilesystem </em>属性设置为<em class="oa"> true时，www部署出现问题。</em>这好像是下面用的nodejs / nextjs框架造成的。对于这一点，我们将暂时删除该属性(当我获得更多信息时，我将更新帖子，这将有助于以更安全、更优雅的方式修复该问题)。</p><ul class=""><li id="85d6" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated"><strong class="lx iu">蒙哥</strong></li></ul><p id="4ad8" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated"><strong class="lx iu">第一版保留mongo官方形象</strong></p><p id="aa1d" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">为了让mongodb Pod正常运行，我们需要做一些更改。首先我们定义2个<em class="oa"> emptyDir </em>卷:第一个卷用于存储数据(长期存储将在本系列的另一篇文章中详细介绍)，第二个卷用作mongo创建套接字的临时读写文件夹。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="7461" class="kz la it ns b gy nw nx l ny nz">containers:<br/>- image: mongo:{{ .Values.mongo.tag }}<br/>  name: mongo<br/>  <strong class="ns iu">...</strong><br/><strong class="ns iu">  volumeMounts:<br/>  - name: data<br/>    mountPath: /data/db<br/>  - name: tmp<br/>  mountPath: /tmp<br/>volumes:<br/>- name: data<br/>  emptyDir: {}<br/>- name: tmp<br/>  emptyDir: {}</strong></span></pre><p id="3ab8" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">接下来，我们需要删除<em class="oa"> runAsUser: 10000 </em>和<em class="oa"> runAsNonRoot </em>属性，因为在初始化步骤中mongodb容器需要成为Root。初始化后，该进程将被mongodb进程替换，该进程由一个专门的非root用户运行。为了实现这一点，我们需要在部署规范中提供额外的功能:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="8f83" class="kz la it ns b gy nw nx l ny nz">capabilities:<br/>  drop:<br/>  - ALL<br/>  add:<br/>  - CHOWN<br/>  - DAC_OVERRIDE<br/>  - SETGID<br/>  - SETUID</span></pre><p id="2912" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated"><strong class="lx iu">使用bitnami/mongodb图像的第二版</strong></p><p id="f719" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">我们也可以考虑使用<em class="oa"> bitnami/mongodb </em>镜像，而不是官方的<em class="oa"> mongo </em>镜像，因为bitnami的镜像不需要root用户。如果我们采用这种解决方案，我们最终会得到以下规范(由于需要进行额外的配置，这有点复杂):</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="a40b" class="kz la it ns b gy nw nx l ny nz">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app.kubernetes.io/name: mongo<br/>    app.kubernetes.io/part-of: webhooks<br/>    app.kubernetes.io/version: "{{.Values.mongo.tag}}"<br/>  annotations:<br/>    container.apparmor.security.beta.kubernetes.io/mongo: runtime/default<br/>  name: mongo<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: mongo<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mongo<br/>    spec:<br/>      automountServiceAccountToken: false<br/>      containers:<br/>      - image: bitnami/mongodb:{{ .Values.mongo.tag }}<br/>        name: mongo<br/>        command:<br/>        - "/opt/bitnami/scripts/mongodb/entrypoint.sh"<br/>        - "/opt/bitnami/scripts/mongodb/run.sh"<br/>        - "--bind_ip_all"<br/>        resources:<br/>          requests:<br/>            memory: 256Mi<br/>            cpu: 200m<br/>          limits:<br/>            memory: 256Mi<br/>            cpu: 200m<br/>        securityContext:<br/>          allowPrivilegeEscalation: false<br/>          readOnlyRootFilesystem: true<br/>          runAsNonRoot: true<br/>          runAsUser: 10000<br/>          seccompProfile:<br/>            type: RuntimeDefault<br/>          capabilities:<br/>            drop:<br/>            - ALL<br/>        volumeMounts:<br/>        - name: data<br/>          mountPath: /bitnami/mongodb/data/db<br/>        - name: tmp<br/>          mountPath: /opt/bitnami/mongodb/tmp<br/>      volumes:<br/>      - name: data<br/>        emptyDir: {}<br/>      - name: tmp<br/>        emptyDir: {}</span></pre><p id="f2d5" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">使用<em class="oa"> bitnami/mongodb </em>映像，我们可以为securityContext中的其他部署指定相同的属性(删除所有功能，runAsUser / runAsNonRoot)。</p><p id="6c02" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注意:<em class="oa"> bitnami/mongodb </em>镜像还不能用于<em class="oa"> arm64 </em>架构，因此不能在Mac M1上运行。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="434e" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试事物</h2><p id="721f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">现在我们已经修改了<em class="oa"> api </em>、<em class="oa"> www </em>和<em class="oa"> mongo </em>部署的规范，让我们更新应用程序:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="af27" class="kz la it ns b gy nw nx l ny nz"># Update the application (from config/app/webhooks)<br/><strong class="ns iu">$ helmfile apply</strong></span></pre><p id="5f43" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">确保所有的吊舱都在运行:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="b4ca" class="kz la it ns b gy nw nx l ny nz"># Checking the Pods' status<br/><strong class="ns iu">$ kubectl get po -n webhooks<br/></strong>NAME                     READY  STATUS   RESTARTS      AGE<br/>nats-6bcb57fc6d-qp5m9    1/1    Running  0             6m44s<br/>ws-55fb4bc9f7-5b8zp      1/1    Running  0             6m44s<br/>mongo-76b7b449dc-8qgvl   1/1    Running  0             32s<br/>www-5b85bc4db8-2qbrm     1/1    Running  0             32s<br/>api-6bc4c96b44-4jsqm     1/1    Running  0             32s</span></pre><p id="363d" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">然后，我们可以访问应用程序，获得一个专用令牌，并发送一个简单的有效载荷，这确认一切运行良好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/13983db54b475a0ce89bfb7add0d82d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JCM9PPSCrXCOCI5h.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">webhooks应用程序的仪表板</figcaption></figure><p id="8903" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">所有更新的规格都可以在webhooks应用程序的<a class="ae ky" href="https://gitlab.com/web-hook/config/-/tree/main/apps/webhooks/templates" rel="noopener ugc nofollow" target="_blank">舵图中找到。</a></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="6c63" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">包扎</h2><p id="8b47" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在本文中，我们使用了之前介绍的一些安全工具的结果。我们重点关注错误配置的检测，并展示了如何增强webhooks应用程序的每个微服务的yaml规范。</p><p id="0504" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">除此之外，我们还可以做很多事情，例如:</p><ul class=""><li id="95b2" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated">创建网络策略以在网络级别隔离单元</li><li id="eee5" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">添加映像扫描，以确保映像运行不包含漏洞(至少不包含高漏洞或关键漏洞)</li><li id="322c" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi">…</li></ul><p id="69a0" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-f760cba7600f">的下一篇文章</a>中，我们将讨论防止错误配置到达集群的策略执行。</p></div></div>    
</body>
</html>