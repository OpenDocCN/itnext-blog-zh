<html>
<head>
<title>Calling ReasonML from TypeScript (or Flow), the easy way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从类型脚本(或流)调用ReasonML，简单的方法</h1>
<blockquote>原文：<a href="https://itnext.io/calling-reasonml-from-typescript-or-flow-the-easy-way-6372cbf4ead3?source=collection_archive---------7-----------------------#2021-05-07">https://itnext.io/calling-reasonml-from-typescript-or-flow-the-easy-way-6372cbf4ead3?source=collection_archive---------7-----------------------#2021-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ba4bfed4f16c3f3568f0d5c1c85e4253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NzNOBrHri_DT6yk28QHww.jpeg"/></div></div></figure><h1 id="183a" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">一点背景知识</h1><p id="906e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我最近开始研究一个组件库，它实现了一些设计系统规范。这将使创建更复杂的用户界面和网站功能变得更容易，在我正在开发的产品上保持页面外观、用户体验和品牌风格的一致性。</p><p id="60f4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们选择使用React、styled-components和TypeScript来构建它，这样每个组件都更容易抽象、开发和测试。我们还想处理多个UI主题(暗/亮)，为什么不呢，也许将来会支持其他主题，样式化组件有一个很棒的内置主题提供程序来完成这项工作。</p><p id="81ef" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">那么，让我们看看如何使用这些技术实现一个简单的按钮:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5967" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">当然，这只是对实际按钮组件的简化，但它让我们能够理解我们是如何开始构建组件的。</p><p id="6115" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">因此，根据当前的主题(亮/暗)，我们的按钮看起来像这样:</p><p id="a277" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">太好了。现在的问题是我们需要多种样式(带轮廓的按钮，带有自定义图标，不同的颜色，等等)，所以我们想要构建一个非常抽象的组件:</p><p id="67a9" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们最终得到了这样的结果:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="263e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">每个帮手看起来都像这样:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="3eba" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">其他所有的助手也是如此(同样，我只是简化了上面例子中的事情)。但是正如你所看到的，这里我们实际上是针对一种特定的颜色进行模式匹配，然后我们提取一个“元组”的值，可以描述如下:<code class="fe mi mj mk ml b">[TextColor, BackgroundColor]</code>。</p><p id="15a3" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如您所见，在TypeScript中实现这一点非常容易，但我们在其他编程语言中实现了一种广泛使用的模式，如Elixir、Haskell…和ReasonML！那么，如果我必须与一对夫妇进行模式匹配呢？如果我不得不进行更复杂的计算来生成正确的字符串呢？对于像我这样的FP爱好者来说，这可能是TypeScript的一个很好的替代品，为什么不呢？</p><p id="de9f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">因此，这里出现了使用ReasonML重构至少那些助手的想法，保持与TypeScript的类型互操作性。</p><h1 id="71cf" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">ReasonML如何让它变得更简单</h1><p id="6250" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">首先，我们需要定义我们的理性类型。让我们从<code class="fe mi mj mk ml b">ButtonProps</code>类型开始(我们暂时不考虑<code class="fe mi mj mk ml b">theme</code>):</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="99a1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果我们试图实现<code class="fe mi mj mk ml b">getColor</code>助手，我们最终会写出这样的代码:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="985a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">用ReasonML编写这种函数感觉非常自然！模式匹配是函数式编程语言中广泛使用的特性。尽管如此，在下一个EcmaScript版本中实现它还没有稳定的规范(只有一个提议和一个巴别塔插件，<a class="ae mm" href="https://www.hackdoor.io/articles/BGJDaNkv/pattern-matching-proposal.html" rel="noopener ugc nofollow" target="_blank">在这里了解更多</a>)。</p><h1 id="3cd2" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">ReasonML和TypeScript之间的互操作性</h1><p id="bdc1" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们只是触及了你应该尝试理性的表面原因！(我不搞笑，我知道)但是现在我们写了我们的ReasonML函数，怎么从TypeScript调用呢？信不信由你，这比你想象的要容易得多！</p><p id="c482" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">首先，让我们为我们的<code class="fe mi mj mk ml b">theme</code>写下类型:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="6610" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在让我们用类型注释重写我们的助手函数，使它们更容易阅读:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="35fe" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">厉害！现在让我们向我们的typescript代码库添加两个新的依赖项:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="c7d0" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">第一个是需要通过Bucklescript编译器将ReasonML编译成JavaScript第二个用于生成TypeScript(甚至流)兼容的类型。</p><p id="96c2" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们向<code class="fe mi mj mk ml b">package.json</code>文件添加两个新脚本:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="7116" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">太好了，我们需要创建一个名为<code class="fe mi mj mk ml b">bsconfig.json</code>的新文件(类似于Node.js' <code class="fe mi mj mk ml b">package.json</code>文件):</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9488" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如您所见，您可以指定应该生成哪种类型。在这种情况下，我们将生成TypeScript兼容的类型。只是少了一样东西。我们需要向BuckleScript编译器指定应该分析哪些函数来生成类型，这非常容易做到:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="d547" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们可以通过在函数声明前添加<code class="fe mi mj mk ml b">[@genType]</code>来实现！</p><p id="9066" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在我们已经准备好通过运行<code class="fe mi mj mk ml b">yarn build:re</code>来构建我们的ReasonML函数。它将在与我们原来的<code class="fe mi mj mk ml b">.re</code>文件相同的目录下生成两个新文件(假设我们称之为<code class="fe mi mj mk ml b">helper.re</code> ): <code class="fe mi mj mk ml b">helper.bs.js</code>和<code class="fe mi mj mk ml b">helper.gen.tsx</code>。让我们看看他们看起来怎么样:</p><p id="3f02" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu"><em class="mn">helper . bs . js:</em></strong></p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="bdd0" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如您所见，BuckleScript生成的文件看起来与我们在第一段中编写的原始TypeScript解决方案极其相似！</p><p id="cb93" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu"><em class="mn">helper . gen . tsx:</em></strong></p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9791" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这有点复杂，并且利用了<code class="fe mi mj mk ml b">bs-platform</code>库来工作。但是正如你所看到的，它公开的类型和我们在第一段中编码的方式完全一样！它还会自动添加Eslint:disable注释，这样就不会与您的Eslint配置冲突。</p><p id="7b8d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">多棒啊。</p><p id="d243" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">你会用ReasonML和TypeScript构建什么？我打赌你会做一些伟大的事情！</p><figure class="mc md me mf gt ju gh gi paragraph-image"><a href="https://github.com/sponsors/micheleriva"><div class="gh gi mo"><img src="../Images/e05f00ed2cddfd2907284cb397168c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAIiY1uBKSNdw12oq2BbjA.png"/></div></a></figure></div></div>    
</body>
</html>