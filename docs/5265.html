<html>
<head>
<title>Spring Boot: Apprentice Cookbook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot:学徒食谱</h1>
<blockquote>原文：<a href="https://itnext.io/spring-boot-apprentice-cookbook-61db5a3f6450?source=collection_archive---------2-----------------------#2021-01-27">https://itnext.io/spring-boot-apprentice-cookbook-61db5a3f6450?source=collection_archive---------2-----------------------#2021-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d981846ac5d30e315855991a37daa509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*gxXLMIuJDHCH7fwIgEP1cg.png"/></div></figure><p id="b97b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"/>是建立在框架<a class="ae ks" href="https://spring.io/projects/spring-framework" rel="noopener ugc nofollow" target="_blank"> Spring </a>之上的一个web框架。它是为更容易使用和更快实施而设计的。这是通过尽可能自动地配置应用程序及其环境来实现的。作为一个新人，我可以说它让框架真的很容易进入。</p><p id="f183" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我的学识让我阅读了大部分的参考文档，这些文档写得很好，给了你很多关于Spring Boot内部行为的见解。该文档给出了很多细节，因此本文旨在采用相反的方法，并指出使用Spring Boot实现API所需的概念。我将用一组相关文档的链接来补充每个部分，如果你想进一步了解的话。</p><p id="4e9e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">顺便提一下，本文将在一个使用Gradle作为构建系统的Java项目中使用2.4.2版的框架。但是，这些信息仍然适用于任何兼容的语言和编译系统。</p><p id="680f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文将涵盖用Spring Boot创建API的以下几个方面:</p><ul class=""><li id="0942" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">启动项目</li><li id="deda" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">创建REST端点</li><li id="6e9d" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">处理错误</li><li id="9926" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">连接到持久层</li><li id="1189" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">对结果进行分页</li><li id="df5e" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">测试应用程序</li><li id="fc0c" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">打包应用程序</li></ul></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="a15b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">启动项目</h1><p id="614f" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">这部分可能是最简单的，因为在https://start.spring.io/<a class="ae ks" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">Spring Boot提供了一个包生成器。我们可以选择所有需要的模块，并检索带有构建系统、依赖项和主应用程序类的归档项目。</a></p><p id="c1bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个生成器之外，为了声明一个RESTful API，我们的项目应该定义Spring Boot <em class="mr"> starter web </em>依赖。starter<em class="mr">依赖项是由Spring Boot打包的一组现成可用的特性。</em></p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">引导Spring Boot项目的最小依赖性</figcaption></figure><p id="a583" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">应用程序的main方法应该包含在任何类中，我们应该在其上应用注释<code class="fe nc nd ne nf b">@SpringBootApplication</code>。这个注释负责大量的自动配置，即组件注入和web服务器启动。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">典型的Spring Boot应用</figcaption></figure><p id="f855" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">启动服务器就像使用嵌入式命令<code class="fe nc nd ne nf b">./gradlew bootRun</code>一样简单。服务器将启动，但是我们目前没有任何端点可以服务。</p><blockquote class="ng nh ni"><p id="e90c" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated">文档链接:</p><p id="99fb" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#using-boot-using-springbootapplication-annotation" rel="noopener ugc nofollow" target="_blank"> @SpringBootApplication </a></p><p id="e275" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#using-boot-starter" rel="noopener ugc nofollow" target="_blank">启动器依赖列表</a></p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="1b2b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">创建REST端点</h1><p id="83c7" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">要创建控制器，我们只需用<code class="fe nc nd ne nf b">@RestController</code>注释任何类。然后，我们可以使用<code class="fe nc nd ne nf b">@RequestMapping</code>将该控制器中的任何方法配置为端点。</p><p id="3edf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe nc nd ne nf b">@RequestMapping</code>通过提供URL、HTTP动词、预期的数据类型等等来帮助我们配置端点。它既可以应用在类上，也可以应用在方法上，应用在类上的配置将被下面的方法继承，并且路径被连接起来。</p><p id="3d80" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了控制我们的端点状态代码，我们将返回一个<code class="fe nc nd ne nf b">ResponseEntity</code>，包含响应消息和<code class="fe nc nd ne nf b">HttpStatus</code>。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">具有单个端点的简单REST控制器</figcaption></figure><p id="6b2e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用<code class="fe nc nd ne nf b">HttpStatus</code>作为响应代码，并将消息转换为JSON对象，<code class="fe nc nd ne nf b">ResponseEntity</code>将自动转换为HTTP响应。在将<em class="mr">映射</em>到JSON对象的基础上，Spring Boot配置<a class="ae ks" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank"> Jackson </a>将任何类的所有<code class="fe nc nd ne nf b">public</code>属性或getters映射到一个JSON对象。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">来自我们端点的响应</figcaption></figure><blockquote class="ng nh ni"><p id="eb11" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated">文档链接:</p><p id="451e" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#getting-started-first-application-annotations" rel="noopener ugc nofollow" target="_blank"> @RestController和@RequestMapping </a></p><p id="ee45" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMapping.html" rel="noopener ugc nofollow" target="_blank"> @RequestMapping API文档</a></p><p id="368e" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#howto-customize-the-jackson-objectmapper" rel="noopener ugc nofollow" target="_blank">自定义Json序列化</a></p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="0e26" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">高级端点配置</h1><p id="120a" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">现在我们有了一个控制器，我们可能想要定义动态HTTP端点。为此，需要记住的主要注释是:</p><ul class=""><li id="77d9" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><code class="fe nc nd ne nf b">@RequestBody</code>:通过java类定义body结构。</li><li id="cb10" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><code class="fe nc nd ne nf b">@PathVariable</code>:定义端点URL的可变子部分。</li><li id="56dc" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><code class="fe nc nd ne nf b">@RequestParam</code>:定义一个查询参数。</li></ul><p id="b65b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面的控制器展示了带有两个端点的三个注释，每个注释根据查询返回一个自定义的“Hello World”。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">端点配置展示</figcaption></figure><p id="a802" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面定义的端点可以如下使用:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">来自上述端点的响应</figcaption></figure><blockquote class="ng nh ni"><p id="6722" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated">文档链接:</p><p id="6ab4" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/spring-framework-reference/web.html#mvc-ann-requestbody" rel="noopener ugc nofollow" target="_blank"> @RequestBody </a></p><p id="3c51" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-uri-templates" rel="noopener ugc nofollow" target="_blank">@路径变量</a></p><p id="d4e9" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/spring-framework-reference/web.html#mvc-ann-requestparam" rel="noopener ugc nofollow" target="_blank"> @RequestParam </a></p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="d8f7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">处理错误</h1><p id="530e" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">默认情况下，对于任何成功的请求，Spring Boot将返回HTTP代码200，如果端点未注册，将返回404，对于任何错误，将返回500。我们已经看到，使用<code class="fe nc nd ne nf b">ResponseEntity</code>使我们能够为成功的请求覆盖这种行为，但是我们仍然需要更精细地处理错误代码。</p><p id="9996" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为此，我们将定义自定义API异常，这些异常将被自动转换为HTTP代码。这种转换是由一个扩展了<code class="fe nc nd ne nf b">ResponseEntityExceptionHandler</code>并用<code class="fe nc nd ne nf b">@ControllerAdvice</code>注释的类来完成的。在这个类中，我们可以使用注解<code class="fe nc nd ne nf b">@ExceptionHandler</code>和<code class="fe nc nd ne nf b">@ResponseStatus</code>来定义处理异常的方法。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">简单的异常处理向API添加400和404错误代码</figcaption></figure><p id="a295" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在项目中定义了<code class="fe nc nd ne nf b">ControllerAdvice</code>之后，控制器抛出的任何异常都将被解析并转换为绑定的<code class="fe nc nd ne nf b">ResponseStatus</code>。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">引发异常的端点示例</figcaption></figure><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">异常端点的错误代码</figcaption></figure><p id="07d9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的异常处理非常简单，不返回任何有效负载，但是可以在<code class="fe nc nd ne nf b">ResponseEntityExceptionHandler</code>的方法中实现异常解析。</p><blockquote class="ng nh ni"><p id="1f00" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated">文档链接:</p><p id="9039" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-error-handling" rel="noopener ugc nofollow" target="_blank">ResponseEntityExceptionHandler</a></p><p id="35b0" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice" rel="noopener ugc nofollow" target="_blank"> @ControllerAdvice </a></p><p id="af8d" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler" rel="noopener ugc nofollow" target="_blank">@异常处理程序</a></p><p id="9f3d" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler-return-values" rel="noopener ugc nofollow" target="_blank"> @ResponseStatus </a></p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="8d62" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">连接到持久层</h1><h2 id="b63c" class="nm lp iq bd lq nn no dn lu np nq dp ly kf nr ns mc kj nt nu mg kn nv nw mk nx bi translated">配置</h2><p id="a2ef" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">要使用数据库，我们需要<em class="mr"> Java持久性API </em> <strong class="jw ir"> </strong> (JPA)包和任何持久层的实现。前者将安装接口API，而后者将提供实现和驱动程序。</p><p id="70c7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了查明在两个不同的数据库之间切换所需的最小变化，我们将同时展示与<a class="ae ks" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>和<a class="ae ks" href="https://www.h2database.com/html/main.html" rel="noopener ugc nofollow" target="_blank"> H2 </a>的集成。首先，让我们声明我们的依赖关系:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">要添加到生成系统中的依赖项</figcaption></figure><p id="cdba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第二步是配置<code class="fe nc nd ne nf b">application.properties</code>中的访问。属性文件是我们第一次也是最后一次担心我们的持久性配置。在这个文件中，注释掉的3行是唯一要从PostgreSQL切换到H2的部分。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">比较H2和PostgreSQL配置的属性文件</figcaption></figure><blockquote class="ng nh ni"><p id="24dc" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated">文档链接:</p><p id="ccd6" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-configure-datasource" rel="noopener ugc nofollow" target="_blank">数据库配置</a></p><p id="5e54" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#data-properties" rel="noopener ugc nofollow" target="_blank">可用属性</a></p></blockquote><h2 id="cd4c" class="nm lp iq bd lq nn no dn lu np nq dp ly kf nr ns mc kj nt nu mg kn nv nw mk nx bi translated">定义模型</h2><p id="384e" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">定义模型就像使用在<a class="ae ks" href="https://www.jcp.org/en/jsr/detail?id=317" rel="noopener ugc nofollow" target="_blank"> JSR-317 </a>上定义的注释一样简单。这些注释可以通过包<em class="mr"> javax.persistence、</em>获得，该包可以通过JPA依赖项获得。</p><p id="883d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，下面的代码创建了一个<em class="mr">交付</em>实体。我们的实体标识符是字段<em class="mr"> id，</em>，由于注释<code class="fe nc nd ne nf b">@GeneratedValue</code>，它将在数据库中每个新保存的实体上自动初始化和增加。</p><p id="d52e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mr">注意:所有公开可用的属性都将被设置到API响应中实体的JSON表示中。</em></p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">交付Bean示例</figcaption></figure><p id="fd4e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了确保我们的数据类的一致性，我们应用了来自<a class="ae ks" href="https://jcp.org/en/jsr/detail?id=303" rel="noopener ugc nofollow" target="_blank"> JSR-303 </a>的<code class="fe nc nd ne nf b">@NotNull</code>验证，这些验证可以在端点上执行，我们将在下一节中看到。约束包含在包<em class="mr">javax . validation . constraints</em>中，可通过依赖关系<code class="fe nc nd ne nf b">spring-boot-starter-validation</code>获得。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">使用bean验证所需的依赖关系</figcaption></figure><blockquote class="ng nh ni"><p id="eb01" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated">文档链接:</p><p id="1549" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-entity-classes" rel="noopener ugc nofollow" target="_blank">实体声明</a></p><p id="e050" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/package-summary.html" rel="noopener ugc nofollow" target="_blank"> javax.persistence API文档(@Entity，@Column，@Enumerate，…) </a></p><p id="862b" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/GeneratedValue.html" rel="noopener ugc nofollow" target="_blank">@生成的值</a></p><p id="f69f" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://javaee.github.io/javaee-spec/javadocs/javax/validation/constraints/package-summary.html" rel="noopener ugc nofollow" target="_blank">javax . validation . constraints API文档(@NotNull) </a></p></blockquote><h2 id="2a96" class="nm lp iq bd lq nn no dn lu np nq dp ly kf nr ns mc kj nt nu mg kn nv nw mk nx bi translated">暴露模型</h2><p id="5309" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">为了与我们的模型进行交互，我们必须定义一个<a class="ae ks" href="https://docs.spring.io/spring-data/commons/docs/2.4.2/api/org/springframework/data/repository/Repository.html" rel="noopener ugc nofollow" target="_blank">存储库</a>，例如一个<code class="fe nc nd ne nf b">CrudRepository</code>。这样做就像用空类扩展类一样简单。Spring Boot将自动实现与实体交互的功能。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="15ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们对这个组件<code class="fe nc nd ne nf b">@Repository</code>进行注释，使其可用于依赖注入。然后，我们可以在任何类中注入和使用存储库，例如直接在控制器中。使用<code class="fe nc nd ne nf b">@Autowired</code>将自动检索上述<em class="mr">声明的<code class="fe nc nd ne nf b">@Repository</code>。</em></p><p id="5877" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mr">注意:</em> <code class="fe nc nd ne nf b"><em class="mr">@Repository</em></code> <em class="mr">和</em> <code class="fe nc nd ne nf b"><em class="mr">@Service</em></code> <em class="mr">的行为与主注射注释</em> <code class="fe nc nd ne nf b"><em class="mr">@Component</em></code> <em class="mr">完全相同，只是能够标记出语义上的不同。</em></p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">微型控制器创建和读取交货。</figcaption></figure><p id="0489" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们使用注释<code class="fe nc nd ne nf b">@Valid</code>来确保我们上面定义的约束在sent <em class="mr"> Delivery </em>主体上得到满足。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">与持久性API的交互</figcaption></figure><p id="1b8c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mr">注意:H2是一个内存数据库，所以每次服务器重启时数据都会被清除。</em></p><blockquote class="ng nh ni"><p id="2d28" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated">文档链接:</p><p id="2eb0" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-data/commons/docs/2.4.2/api/org/springframework/data/repository/CrudRepository.html" rel="noopener ugc nofollow" target="_blank"> CrudRepository API文档</a></p><p id="98f9" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#using-boot-spring-beans-and-dependency-injection" rel="noopener ugc nofollow" target="_blank">弹簧组件声明</a></p><p id="ad37" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://javaee.github.io/javaee-spec/javadocs/javax/validation/package-summary.html" rel="noopener ugc nofollow" target="_blank"> javax.validation API文档(@Valid) </a></p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="407b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">对结果进行分页</h1><p id="c07f" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">这一部分说明了Spring Boot如何很好地集成了web API的一些经典特性。为了对我们之前的实体<em class="mr">交付的访问进行分页，</em>我们只需将存储库的扩展类从<code class="fe nc nd ne nf b">CrudRepository</code>更改为<code class="fe nc nd ne nf b">PagingAndSortingRepository</code>。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">分页存储库实现</figcaption></figure><p id="dd2d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个存储库实现提供了一个新方法<code class="fe nc nd ne nf b">findAll(Pageable)</code>返回一个<code class="fe nc nd ne nf b">Page</code>。类<code class="fe nc nd ne nf b">Pageable</code>配置返回的页面和页面大小。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">展示分页的索引端点</figcaption></figure><p id="05ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，端点将根据请求提供整个<code class="fe nc nd ne nf b">Page</code>对象的数据。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><blockquote class="ng nh ni"><p id="5296" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated">文档链接:</p><p id="e779" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-data/commons/docs/2.4.2/api/org/springframework/data/repository/PagingAndSortingRepository.html" rel="noopener ugc nofollow" target="_blank">分页和分类存储API文档</a></p><p id="3010" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-data/commons/docs/2.4.2/api/org/springframework/data/domain/PageRequest.html" rel="noopener ugc nofollow" target="_blank">页面请求API文档</a></p><p id="b605" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-data/commons/docs/2.4.2/api/org/springframework/data/domain/Page.html" rel="noopener ugc nofollow" target="_blank">页面API文档</a></p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="5e13" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">测试应用程序</h1><p id="7d84" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">Spring Boot提供了各种工具，通过一组API和<a class="ae ks" href="https://en.wikipedia.org/wiki/Mock_object" rel="noopener ugc nofollow" target="_blank">模拟</a>来轻松测试控制器。大多数情况下，<code class="fe nc nd ne nf b">MockMvc</code>将使我们能够发送请求和断言响应内容，而不必担心技术问题。</p><p id="5e69" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，我们正在测试上一节中的<em class="mr"> POST </em>端点。其中一个测试成功地创建了一个<em class="mr">交付</em>实体，第二个测试模拟了一个来自数据库的错误。</p><p id="8f8a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了避免依赖持久层的物理实例，我们使用<code class="fe nc nd ne nf b">@MockBean</code>注入了我们的DeliveryRepository实例，它创建并注入了我们组件的模拟。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><blockquote class="ng nh ni"><p id="9413" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated">文档链接:</p><p id="7314" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-testing-spring-boot-applications" rel="noopener ugc nofollow" target="_blank"> @SpringBootTest </a></p><p id="b1fc" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-mock-environment" rel="noopener ugc nofollow" target="_blank"> @AutoConfiguredMockMvc </a></p><p id="3dd1" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-testing-spring-boot-applications-mocking-beans" rel="noopener ugc nofollow" target="_blank"> @MockBean </a></p><p id="8a9b" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/MockMvc.html" rel="noopener ugc nofollow" target="_blank"> MockMvc api文档</a></p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="f35d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">打包应用程序</h1><p id="3669" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">Spring boot还简化了作为独立jar或docker映像的应用程序打包。</p><ul class=""><li id="902b" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">要创建一个准备运行的<em class="mr"> fat jar </em>，执行<code class="fe nc nd ne nf b">./gradlew bootJar</code>。</li><li id="37ec" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">要构建一个<em class="mr"> docker映像</em>，执行<code class="fe nc nd ne nf b">./gradlew bootBuildImage</code>。</li></ul><p id="e2ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，docker不喜欢在图像名称中使用大写字符，但是我们可以轻松地自定义图像名称和版本。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">自定义您的docker图像名称</figcaption></figure><blockquote class="ng nh ni"><p id="4881" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated">文档链接:</p><p id="888c" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#getting-started-first-application-executable-jar" rel="noopener ugc nofollow" target="_blank">创建一个应用程序fat jar </a></p><p id="9615" class="ju jv mr jw b jx jy jz ka kb kc kd ke nj kg kh ki nk kk kl km nl ko kp kq kr ij bi translated"><a class="ae ks" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-container-images" rel="noopener ugc nofollow" target="_blank">配置Docker图像</a></p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="e8d7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="9b89" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">Spring Boot可以和一些注释一起使用，并且会为你管理大部分的配置。但是，如果需要的话，可以覆盖大部分配置来提供您自己的行为。这使得它成为一个很好的框架来设计概念的证明，同时如果项目增长了特定的需求，还保留了优化的空间。</p><p id="b9ce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你想更多地了解这个框架，我不能过分强调参考文档<a class="ae ks" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" rel="noopener ugc nofollow" target="_blank">的质量，它给出了非常好的细节。</a></p><p id="3c06" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你想玩一些代码，你可以在GitHub 上的一个示例交付API <a class="ae ks" href="https://github.com/aveuiller/frameworks-bootstrap/tree/master/SpringBoot" rel="noopener ugc nofollow" target="_blank">中找到所有这些概念。</a></p></div></div>    
</body>
</html>