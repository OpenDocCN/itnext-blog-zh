<html>
<head>
<title>Packaging, Deploying and Scaling FAST-CGI Applications in Docker for Kubernetes Done Right</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Docker for Kubernetes中打包、部署和扩展快速CGI应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/packaging-and-scaling-fast-cgi-applications-in-docker-for-kubernetes-done-right-8440829fe1e9?source=collection_archive---------5-----------------------#2019-03-05">https://itnext.io/packaging-and-scaling-fast-cgi-applications-in-docker-for-kubernetes-done-right-8440829fe1e9?source=collection_archive---------5-----------------------#2019-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c3b6e375bab55d4707f4da8612c81937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*afkK1deEdJkuN3IhnzuzKg.png"/></div></div></figure><p id="a35a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，像PHP这样的快速cgi语言的需求也在不断减少，我不时收到一些请求和问题，问我如何在不放弃docker和kubernetes所有优点的情况下正确部署这些应用程序。</p><p id="44e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尤其是像PHP这样的语言，它们经常伴随着像WordPress这样丑陋的应用程序，开发人员在这些应用程序的基础上引入了他们自己的问题。但是让我们从最初的问题开始，让你的应用程序实际上对网络可用。有许多如何“打包”应用程序的“指南”和“教程”。当您看到它们使用卷，在两个容器之间共享它们的文件，或者指示您在同一个容器中运行多个进程时，最好忽略它们，因为这不仅是一种不好的做法，而且还会引入它们自己的问题。但是首先，让我们从问题的根源开始，并提供适当的解决方案。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="af7c" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">构建过程</h1><p id="7a75" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在构建应用程序和docker容器时，有几个问题会直接出现。我应该使用变量x还是y，在我们的例子中是apache还是php-fpm？入口真的能接触到他们吗？我如何提供我的静态内容？动态内容呢？还有插件，比如…有点动态的那种？</p><p id="d619" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的共同想法似乎是构建一个包含nginx和执行代码文件的进程的容器来交付内容。对docker和docker最佳实践稍微熟悉一点的人都知道:等等，我不应该在每个docker容器中运行多个进程！那么接下来呢？一个快速的谷歌搜索带来了解决方案，创建两个容器并共享一个卷来在两者之间复制文件。听起来是个好主意！是吗？</p><p id="c8f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TL；DR；它不是，它实际上是一个可怕的想法！</p><p id="6b1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了理解如何正确地解决我们的问题，我们需要一些关于kubernetes的知识和一些通用的架构原则。</p><h2 id="b8e5" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">Kubernetes网络基础知识</h2><p id="06f3" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">如果我们将应用程序部署到两个容器中，我们如何处理另一个容器呢？或者我们可以直接指向入口，在我们的例子中是指向fcgi的nginx入口？</p><p id="b4f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个问题的答案是，在kubernetes中，我们有pods的概念，所以我们可以只处理localhost。这是可能的，因为一个pod可以包含共享同一个NIC的多个容器。如果你想更深入地了解网络是如何工作的，你可以在这里阅读我的深入文章kubernetes网络是如何工作的:<a class="ae mv" href="https://neuvector.com/network-security/advanced-kubernetes-networking/" rel="noopener ugc nofollow" target="_blank">https://neu vector . com/network-security/advanced-kubernetes-Networking/</a></p><p id="2102" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以第一个问题很容易解决，第二个问题的答案是两折。是的，我们可以，但我们可能不应该！这总是取决于您如何交付您的应用程序。如果你通过CDN交付你所有的静态内容，直接指向入口就可以了。但是，除此之外，无论如何您都将拥有静态内容，因此您将需要一个解决方案来交付它们。而这个解决方案就是nginx！简而言之，我们还没有考虑太多的第二个问题，静态内容，使得我们关于nginx的第二个容器的想法更有意义。它不再仅仅是一个中间人，通过交付我们的静态内容，它本身就有价值。</p><h2 id="0d20" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">可伸缩应用程序的架构原则</h2><p id="e266" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">构建可伸缩的应用程序有一些非常简单的原则。第一个是摆脱本地状态，尽一切办法避免共享磁盘状态。这意味着当你有文件需要服务时，把它们转移到一个专门的服务上。</p><p id="60b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是一些例子:</p><ul class=""><li id="9c58" class="mw mx it kd b ke kf ki kj km my kq mz ku na ky nb nc nd ne bi translated"><strong class="kd iu"> For Files </strong>:一个优化的图像服务服务，它有低级别的优化，比如通过haystack设计论文的发现优化的文件系统:<a class="ae mv" href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf" rel="noopener ugc nofollow" target="_blank">https://www . usenix . org/legacy/event/osdi 10/tech/full _ papers/beaver . pdf</a>。</li><li id="18a6" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated"><strong class="kd iu">移动状态</strong>:当我们谈论缓存时，在内存LRU 中保持一小部分<em class="nk">热，其余的转移到专用的缓存服务，如<em class="nk"> memcached </em>或<em class="nk"> redis </em>。</em></li><li id="5a5c" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated"><strong class="kd iu">持久数据</strong>:使用合适的分布式数据库，可以水平伸缩，比如<em class="nk">cocroach db</em>:<a class="ae mv" href="https://www.cockroachlabs.com/" rel="noopener ugc nofollow" target="_blank">https://www.cockroachlabs.com/</a></li></ul><p id="a66c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个重要的原则是:有一个可重复的过程，没有不必要的初始化。当您想要扩展时，这只会降低部署速度。这也意味着将数据从一个地方复制到另一个地方，以避免在同一个容器中有多个进程，因为在这里旧的unix原则仍然适用:“编写程序，使<strong class="kd iu">做一件事</strong>而<strong class="kd iu">做</strong>它<strong class="kd iu">做好</strong>”。</p><p id="9791" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，您为什么要避免缓慢的部署呢？</p><p id="36fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">答案很简单:如果你正在扩展你的服务，这个过程<strong class="kd iu">需要</strong>尽可能快地<strong class="kd iu"/>。想一想，你什么时候扩展，为什么？答案是当你<strong class="kd iu">需要</strong>的时候，如果你需要，这意味着否则你会失去一些东西。这可能是由于较长的加载时间而导致的较低的转换率，从而造成真正的金钱损失，甚至当您面临整个系统过载的风险并使其处于完全被拒绝的风险时，服务连续性也会受到影响。为了避免这一切，你需要尽可能快地设计整个部署，通常你的链中已经有足够多的慢组件，所以至少不要搞砸你自己的东西。以你的主机或云提供商为例，他们为你提供的现成系统不够快(尤其是像azure这样的大型云，通常非常慢，我已经经常需要5-15分钟来交付你的机器)。<br/>因此，请始终记住，时间就是金钱，因此要预测扩展需求，尽早开始扩展，并尽可能缩短扩展过程。</p><h1 id="d295" class="lg lh it bd li lj nl ll lm ln nm lp lq lr nn lt lu lv no lx ly lz np mb mc md bi translated">插件地狱</h1><p id="dfe0" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">进入下一个话题，插件。你马上会在这里遇到一个问题，那就是持久动态内容。其中之一就是插件，这也是为什么像wordpress这样的应用程序很难被正确部署，或者跨多个主机无问题扩展的原因。丑陋的事实是，这些应用程序的开发从来没有考虑到这些东西，而且有很多地方是“错误的”。它只是从插件开始，然后继续wordpress自带的自我升级机制。</p><p id="5f22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但这并不是说你不能手动安装任何插件，或者你必须使用wordpress的内置机制来更新它，而不是手动完成。事实上，手动操作才是你需要走的路。插件的安装需要发生在你的构建步骤中，对于wordpress的更新，你可以创建一个更新例程，在每次重建时运行。幸运的是，对于大多数(如果不是所有的话)为这种形式的可扩展性而构建的应用程序来说，这是正确的。如果你想以“正确”的方式做这件事，这是起码的。然而，存在一个问题:</p><p id="5eb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你失去了安慰！</p><p id="fe0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这对你来说可能不是问题，但如果你只是想为其他用户托管wordpress之类的应用程序，这些用户想安装他们自己的插件，但不愿意经历<em class="nk">“手动”</em>安装的过程，这就成问题了。在这种情况下，您实际上被迫回到任何网络文件系统，最好的情况是分布式的或者至少是复制的。这是一个例外，你基本上没有选择，但这样做并使用共享的“本地磁盘”状态，但你应该指示你的用户在扩展时有问题，至少要将所有数据卸载到CDN或minio等自托管S3存储，并设置代码文件的执行器将它们缓存在内存中，而不是从磁盘重新读取它们。</p><p id="0ffd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以无论如何，避免设计糟糕的软件。有软件证明你可以在不破坏可扩展性的情况下开发插件。这里举一个例子:vBulletin Board将它的插件和代码存储在数据库中，然后对其进行评估。虽然我从不建议使用任何评估，但这是保持可伸缩性的完美方法<strong class="kd iu">和</strong>让用户感到舒适。因此，坚持使用设计良好的软件，而不是在事后淋雨，那时已经太晚了。</p><h1 id="dc71" class="lg lh it bd li lj nl ll lm ln nm lp lq lr nn lt lu lv no lx ly lz np mb mc md bi translated">您自己的应用程序</h1><p id="5d3c" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">但是说够了，让我们假设您正在尽最大努力构建您的应用程序，并遵循所有的最佳实践和原则。</p><p id="cf27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你会很快体会到，一旦你熟悉了不同种类储物的合适解决方案，它们就会变得不需要动脑筋，并在你的书架上固定下来。这里有一个小奖励，这是一组不同类型存储的示例:</p><h2 id="41bc" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">隐藏物</h2><ul class=""><li id="ae3d" class="mw mx it kd b ke me ki mf km nq kq nr ku ns ky nb nc nd ne bi translated">https://memcached.org/的memcached <a class="ae mv" href="https://memcached.org/" rel="noopener ugc nofollow" target="_blank"/></li><li id="076f" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated">雷迪斯<a class="ae mv" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank">https://redis.io/</a></li><li id="fe1f" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated">redislab<a class="ae mv" href="https://redislabs.com/" rel="noopener ugc nofollow" target="_blank">https://redislabs.com/</a></li></ul><h2 id="50e0" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">文件</h2><ul class=""><li id="6bf0" class="mw mx it kd b ke me ki mf km nq kq nr ku ns ky nb nc nd ne bi translated">迷你尼奥(S3)<a class="ae mv" href="https://www.minio.io/" rel="noopener ugc nofollow" target="_blank">https://www.minio.io/</a></li><li id="c9fe" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated">seaweedfs —草堆设计实施<a class="ae mv" href="https://github.com/chrislusf/seaweedfs" rel="noopener ugc nofollow" target="_blank">https://github.com/chrislusf/seaweedfs</a></li></ul><h2 id="86fe" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">不变数据</h2><ul class=""><li id="13c7" class="mw mx it kd b ke me ki mf km nq kq nr ku ns ky nb nc nd ne bi translated">https://www.cockroachlabs.com/</li><li id="a7b3" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated">https://www.mongodb.com/</li><li id="ea62" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated">http://www.actordb.com/</li></ul><h2 id="25a9" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">图形数据</h2><ul class=""><li id="b3fc" class="mw mx it kd b ke me ki mf km nq kq nr ku ns ky nb nc nd ne bi translated">https://www.arangodb.com/</li></ul><p id="abe4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">配备了用于<strong class="kd iu">任务</strong>的<strong class="kd iu">右</strong>工具，您就准备好构建和发布您的<strong class="kd iu">可伸缩</strong>应用程序了。</p><p id="7930" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，看看我们的PHP应用程序，我们需要决定:PHP-FPM + NGINX或Apache。简而言之，有很多原因可以避免Apache而支持NGINX，最大的原因可能是Apache的可伸缩性有限，这是因为它的设计是每个连接只开放一个线程。但与Apache不同，PHP-FPM不能直接交付给客户端，它需要一个web服务器来处理它的HTTP请求，并通过FCGI传递它。我们将需要两个容器，一个装有NGINX，一个装有PHP-FPM，这似乎是一个开销，但这种开销可以通过给NGINX一些任务本身来减少，而不仅仅是一个通道。在web应用程序中，我们总是有这个任务，我们之前已经讨论过了:</p><p id="0b57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过构建一个已经包含静态内容的NGINX容器来交付静态内容。</p><p id="1633" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，我们从各个方面受益，PHP-FPM执行我们的PHP文件的性能和NGINX转发到PHP-FPM的性能，交付静态资产，甚至可能缓存。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/56a9e5e22e9a1d4809502002c33c8d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B21LfZ_Xoy-6CeZSQMqLYA.jpeg"/></div></div></figure><h1 id="8bab" class="lg lh it bd li lj nl ll lm ln nm lp lq lr nn lt lu lv no lx ly lz np mb mc md bi translated">构建我们的部署</h1><p id="d546" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">现在理论上一切都清楚了，让我们来看一些例子！</p><p id="d9c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中，我们不会将任何内容放入我们的容器中，而只是使用基本图像，您可能会使用。所以对于PHP用例，这将是简单的:<em class="nk"> php:7-fpm </em>和<em class="nk"> nginx。</em></p><p id="d5ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，我们将为包含两个容器的pod编写一个部署，以利用相同的网络堆栈。为了让nginx能够有效地访问php守护进程，根本不需要修改映像。我们可以挂载一个配置映射，我们将使用它来<strong class="kd iu">覆盖</strong>的<strong class="kd iu"/><em class="nk">default . conf .</em></p><p id="29d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们为php选择了一些基本的重写配置，你可以根据自己的需要进行调整，让nginx作为默认服务器监听端口80。没有更多的设置，没有虚拟主机通过服务器名称，事实上，我们留为空白“_”。只是一个愚蠢的nginx发送内容，或重定向，如果没有。</p><p id="070f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们将以下配置插入到配置图中，如下所示:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="d4e9" class="mj lh it nz b gy od oe l of og">---<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: nginxthroughpass<br/>data:<br/>  default.conf: |-<br/>    server {<br/>            listen 80 default_server;<br/>            server_name  _;<br/>            index index.php;</span><span id="485a" class="mj lh it nz b gy oh oe l of og">            location / {<br/>                try_files $uri $uri/ /index.php?$args;<br/>            }<br/><br/>            location ~ \.php$ {<br/>                fastcgi_split_path_info ^(.+\.php)(/.+)$;<br/>                fastcgi_pass 127.0.0.1:9000;<br/>                fastcgi_index index.php;<br/>                include fastcgi_params;<br/>                fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;<br/>            }<br/>        }</span></pre><p id="bf99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是这里的配置，我们基本上完成了，您当然可能有特殊要求，如您可能想要配置缓存。但是我会把它留给你。</p><p id="cf65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来的事情就是前面提到的，<strong class="kd iu">装上</strong>！</p><p id="6dab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以没有更多的话，这里是我们的部署配置，包括我们的配置图的<em class="nk">卷安装</em>。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="b0cd" class="mj lh it nz b gy od oe l of og">---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: phpapp<br/>  labels:<br/>    app: production<br/>    type: app<br/>    service: phpservice<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: production<br/>      type: app<br/>      service: phpservice<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: production<br/>        type: app<br/>        service: phpservice<br/>    spec:<br/>      containers:<br/>        - image: php:7-fpm<br/>          imagePullPolicy: IfNotPresent<br/>          name: app<br/>        - image: nginx<br/>          imagePullPolicy: Always<br/>          name: nginx<br/>          volumeMounts:<br/>            - mountPath: /etc/nginx/conf.d<br/>              name: nginxconf<br/>              readOnly: true<br/>      volumes:<br/>        - configMap:<br/>            defaultMode: 256<br/>            name: nginxthroughpass<br/>            optional: false<br/>          name: nginxconf</span></pre><p id="7771" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">部署和快速测试显示:</p><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/169316afc88b57f5174106409ba40478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJcxv2eljikGMO7txzwGQQ.png"/></div></div></figure><p id="6079" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从php-fpm而不是nginx 404中得到一个没有找到的文件。任务完成了！</p><p id="330e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">php-fpm日志现在显示:</p><figure class="nu nv nw nx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/76d990c600a541f5f9f68cd19b4264ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INvDOA3h9Fh10xBFfwAPfg.png"/></div></div></figure><p id="98ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以它重写了index.php，正如我们所期望的那样。所以我们现在都完成了！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ddd5" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="91de" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">为php和其他需要两个组件才能实际工作的fcgis构建一个适当的可伸缩设置并不太难，但是很难区分好的信息和坏的信息。最重要的是要记住，仅仅使用kubernetes和docker并不能让你的应用程序具有可伸缩性，只有这样，构建一个合适的构建和部署链才变得重要。<br/>所以，在开发过程中，要记住预先扩展的最佳实践，因为<strong class="kd iu">当你需要扩展时，已经太迟了</strong>。在这种情况下，我希望我成功地帮助您摆脱了糟糕的建议，更重要的是，我给了您不仅仅是一个指导，一些思考方式，关于如何正确地构建和打包您的应用程序，以及如何为正确的任务选择正确的工具。</p></div></div>    
</body>
</html>