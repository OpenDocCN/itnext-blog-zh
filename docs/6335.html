<html>
<head>
<title>Some patterns for HTTP and Unit Testing in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中HTTP和单元测试的一些模式</h1>
<blockquote>原文：<a href="https://itnext.io/some-patterns-for-http-and-unit-testing-in-go-221097a0597b?source=collection_archive---------0-----------------------#2021-10-19">https://itnext.io/some-patterns-for-http-and-unit-testing-in-go-221097a0597b?source=collection_archive---------0-----------------------#2021-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bcc04646e6b917115265bcd34cf0cc1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwimjJsssAXFU7uihG6HAw.jpeg"/></div></div></figure><h1 id="1df7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">每个人都写测试</h1><p id="48b4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我想马上得到一分。几年前，我和一个团队一起工作，他们不断地向构建贡献错误的代码。当我们研究该团队的开发实践时，我们发现了一个非常糟糕的反模式，即他们将团队分为“开发人员”和“测试人员”，而测试人员单独负责编写测试代码(包括单元测试)。没有人想成为一名测试人员，测试人员在确保测试覆盖率方面一直处于水下(更不用说确保测试实际上是好的)。</p><p id="604d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在我的团队中，<em class="lz">每个人都写测试</em>。我不知道你在这个问题上的立场，但是虽然我对很少的事情有宗教信仰，但是我在执行测试驱动的开发实践上立场相当坚定。如果你不知道如何测试你的代码，你不应该把它添加到构建中。实际上，如果您不知道如何测试您的代码，并且您不能花时间编写可靠的单元测试来防止回归，那么就不要提交。</p><p id="95cb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你不必同意我的立场，但我想提供一些背景。我认为，不仅每个人都需要知道如何编写测试代码，而且每个人<em class="lz">都应该</em>编写测试代码。</p><p id="f369" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">本文面向Go开发人员，他们可能已经使用过Go的内置<code class="fe ma mb mc md b">testing</code>包，但是(a)不熟悉一些可以帮助他们改进测试的好的测试工具，和/或(b)不确定如何为一些特定的场景编写单元测试——在本例中是HTTP客户端和服务器。</p><p id="807a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我经常看到开发人员仅仅依赖于客户端/服务器案例的集成测试，但是这样做太晚了。让集成测试驱动所有可能的负面(错误)案例通常是不可行的，这意味着在代码已经交付之后，边缘案例可能会泄漏并表现为bug。因此，我认为，掌握我将要演示的一些技术(或者类似的，甚至可能更好的技术)是HTTP开发人员技能/工具集的一个非常重要的部分。</p><h1 id="b806" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">文章的代码示例</h1><p id="ce6e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我在文章中使用的所有代码示例都可以在<a class="ae me" href="https://github.com/ScarletTanager/go-http-testing" rel="noopener ugc nofollow" target="_blank">https://github.com/ScarletTanager/go-http-testing</a>找到。您可以自由地复制/使用/修改您认为合适的代码，并且我欢迎对文章和/或代码示例的评论。</p><h1 id="48d1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Golang测试工具箱</h1><p id="8e12" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我将首先列出一些我在测试中使用(并提倡使用)的工具，我建议每个Go开发者都尝试一下并熟悉它们——我认为它们是值得投资的。</p><h2 id="ef41" class="mf jz iq bd ka mg mh dn ke mi mj dp ki lh mk ml km ll mm mn kq lp mo mp ku mq bi translated">银杏树</h2><p id="3ff9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Onsi Fakhouri的<a class="ae me" href="https://github.com/onsi/ginkgo" rel="noopener ugc nofollow" target="_blank">银杏包</a>为golang提供了一个健壮的行为驱动开发(BDD)框架。Ginkgo提供了一个库，开发人员可以用它来以一种更清晰、更有组织的方式构建测试，同时还提供了命令行工具<code class="fe ma mb mc md b">ginkgo</code>来运行测试。银杏与<code class="fe ma mb mc md b">testing</code>包完全兼容(例如，你可以用<code class="fe ma mb mc md b">go test</code>毫无问题地运行银杏测试)，因为它建立在这个包之上，而不是取代它。</p><p id="a302" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我曾听开发人员称银杏为语法糖，但我认为这是对银杏的漠视——它不仅仅是表达测试的一种方式。Ginkgo提供了状态管理(安装和拆卸都受支持)、嵌套上下文(例如，用于异常测试)和其他值得探索的特性。</p><p id="0245" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">银杏通常与匹配器库(提供测试结果的实际条件评估)一起使用，这里我推荐Onsi Fakhouri的另一个包…</p><h2 id="02b5" class="mf jz iq bd ka mg mh dn ke mi mj dp ki lh mk ml km ll mm mn kq lp mo mp ku mq bi translated">戈梅加</h2><p id="c820" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Gomega是一个非常健壮的Golang测试匹配器库。你可以阅读优秀的<a class="ae me" href="https://onsi.github.io/gomega/" rel="noopener ugc nofollow" target="_blank">文档</a>来找出它提供的一切，但是特性包括特定类型匹配器(字符串、布尔值、数字、列表类型等。)，同步和异步匹配器，并支持例如针对流数据的匹配。</p><p id="e665" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Gomega提供的一个特性是它为http客户端提供的特定于http的匹配器库，但我从未真正尝试过使用它(考虑到本文的主题，这有点奇怪)。也许有一天评估它并将其与我自己的模式进行比较将是另一篇文章的主题…</p><h2 id="12a2" class="mf jz iq bd ka mg mh dn ke mi mj dp ki lh mk ml km ll mm mn kq lp mo mp ku mq bi translated">伪造者</h2><p id="42d7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我最喜欢的一个工具是Max Brunsfeld的<a class="ae me" href="https://github.com/maxbrunsfeld/counterfeiter" rel="noopener ugc nofollow" target="_blank">伪造者</a>，这是一个为golang接口类型生成doubles(测试假货)的工具。在Go中还有其他可行的生成doubles的方法，但是如果可以选择的话，我每次都要使用伪造者。</p><p id="cc59" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">伪造者的问题是你需要使用接口，如果你的代码不容易使用接口，你可能无法从中获得同样多的价值，但幸运的是伪造者也可以用于为你不拥有的接口生成伪造品(例如，你想要伪造的来自go标准库包之一的接口)。</p><p id="f917" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="lz">在文章中，我通常交替使用“假”和“双”。一个术语相对于另一个术语的使用没有特别的含义。</em></p><p id="9884" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所有这些工具都被积极地维护着，我几乎没有因为推荐它们而创新。但是如果您还没有尝试过，它们非常值得您去研究。</p><h1 id="fa75" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">模仿来自HTTP服务器的响应</h1><p id="173e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一个最常见的用例是API(通常是RESTful的，但不仅仅是RESTful的)客户端，它需要能够处理来自服务器的特定响应。例如，您知道API服务器在某些情况下可能会返回401——在这种情况下，您的客户端需要做什么？</p><p id="8df7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这种情况下，开发人员需要模仿(模拟)服务器的行为，以便测试代码可以保证客户端处理的是401，并且只是401(或者客户端需要处理的任何其他代码/响应)。我们如何做到这一点？</p><p id="5048" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果我们坚持核心库所提供的，那么典型的方法是旋转一个<code class="fe ma mb mc md b">httptest.Server</code>的实例，并将我们的客户端请求发送给它。我们可以定制服务器的行为，这样我们就知道它会以一种特定的方式做出响应，这样我们就可以确信我们的客户端会为我们的测试处理正确的响应。</p><p id="6310" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">虽然这是一个完全有效的方法，并且是我们将在下面重新讨论的方法，但它也比我通常喜欢在客户端单元测试中使用的方法要“沉重”一些。一种简单得多(在测试执行方面也更快)的方法是模仿<em class="lz"> http客户端</em>，这样它就能产生正确的响应。</p><p id="a017" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们假设我们有一个如下所示的API客户端:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="306e" class="mf jz iq md b gy mz na l nb nc">package client</span><span id="4848" class="mf jz iq md b gy nd na l nb nc">import (<br/>  "errors"<br/>  "io"<br/>  "net/http"<br/>)</span><span id="46fd" class="mf jz iq md b gy nd na l nb nc">type ApplicationClient struct {<br/>  HttpClient *http.Client<br/>}</span><span id="b35d" class="mf jz iq md b gy nd na l nb nc">func (c *ApplicationClient) PerformQuery(body io.Reader) error {<br/>  r, _ := http.NewRequest(http.MethodPost, "/resource", body)<br/>  resp, _ := c.HttpClient.Do(r)<br/>  if resp.StatusCode == http.StatusUnauthorized {<br/>    return errors.New("Unauthorized")<br/>  }<br/>  return nil<br/>}</span></pre><p id="9aa7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，在这里，与其产生创建一个<code class="fe ma mb mc md b">httptest.Server</code>实例并定制其行为的开销(通过编写一个返回特定期望响应的处理函数)，我更喜欢模拟出<code class="fe ma mb mc md b">http.Client</code>。但是怎么做呢？</p><p id="3210" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">首先，伪造者只支持模仿<code class="fe ma mb mc md b">interface</code>类型，不支持<code class="fe ma mb mc md b">struct</code>类型。所以我需要我的<code class="fe ma mb mc md b">ApplicationClient</code>来包装一个<code class="fe ma mb mc md b">interface</code>。但是我从哪里得到这个<code class="fe ma mb mc md b">interface</code>？答案很简单，这要感谢Go处理<code class="fe ma mb mc md b">interface</code>类型的方式。</p><p id="903b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我需要做的就是定义我自己的简单的<code class="fe ma mb mc md b">MyHttpClient</code>接口，并重新定义我的<code class="fe ma mb mc md b">ApplicationClient</code>来包装它:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="b495" class="mf jz iq md b gy mz na l nb nc">type MyHttpClient interface {<br/>  Do(*http.Request) (*http.Response, error)<br/>}</span><span id="3951" class="mf jz iq md b gy nd na l nb nc">type ApplicationClient struct {<br/>  HttpClient MyHttpClient<br/>}</span></pre><p id="6b04" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">敏锐的读者会注意到这是<code class="fe ma mb mc md b">*http.Client</code>已经实现的方法之一——这意味着类型<code class="fe ma mb mc md b">*http.Client</code>的对象自动满足接口规范。所以到目前为止，这个简单的重构不应该破坏任何东西。</p><p id="4a49" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了模仿接口，我首先需要生成假的，为此我向类型定义添加了一个注释:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="6b6c" class="mf jz iq md b gy mz na l nb nc">//counterfeiter:generate . MyHttpClient<br/>type MyHttpClient interface {<br/> Do(*http.Request) (*http.Response, error)<br/>}</span></pre><p id="5e8c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe ma mb mc md b">counterfeiter</code>允许多种注释模式——查看文档并选择对您有意义的一种，但是一旦您运行(通常从您的项目根中运行)<code class="fe ma mb mc md b">go generate ./...</code>，最终结果将是相同的。在这里，我们会看到在我们的<code class="fe ma mb mc md b">client</code>包下，有一个名为<code class="fe ma mb mc md b">clientfakes</code>的子包。该包将包含对类型为<code class="fe ma mb mc md b">FakeMyHttpClient</code>的结构的定义，这是一个全功能的<code class="fe ma mb mc md b">MyHttpClient</code>接口的双重实现。</p><p id="d8be" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了在测试中使用生成的假代码，我可能会这样做:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="e35d" class="mf jz iq md b gy mz na l nb nc">package client_test</span><span id="baab" class="mf jz iq md b gy nd na l nb nc">import (<br/> "net/http"</span><span id="f652" class="mf jz iq md b gy nd na l nb nc"> . "github.com/onsi/ginkgo"<br/> . "github.com/onsi/gomega"</span><span id="bab1" class="mf jz iq md b gy nd na l nb nc"> "myapp/client"<br/> "myapp/client/clientfakes"<br/>)</span><span id="7ef7" class="mf jz iq md b gy nd na l nb nc">var _ = Describe("Client", func() {<br/>  var (<br/>    appClient  *client.MyApplicationClient<br/>    httpClient *clientfakes.FakeMyHttpClient<br/>  )</span><span id="8cc3" class="mf jz iq md b gy nd na l nb nc">  BeforeEach(func() {<br/>    httpClient = &amp;clientfakes.FakeMyHttpClient{}<br/>    appClient = &amp;client.MyApplicationClient{<br/>      HttpClient: httpClient,<br/>    }</span><span id="311c" class="mf jz iq md b gy nd na l nb nc">    httpClient.DoReturns(&amp;http.Response{}, nil)<br/>  })</span><span id="a970" class="mf jz iq md b gy nd na l nb nc">  Describe("PerformQuery", func() {<br/>    It("Executes and returns nil", func() {<br/>      Expect(appClient.PerformQuery()).NotTo(HaveOccurred())<br/>    })<br/>  })<br/>})</span></pre><p id="32c1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是一个微不足道的快乐路径测试——除了演示如何使用我们生成的fake之外，它真的没有做什么。这里需要注意的重要一行是:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="a69a" class="mf jz iq md b gy mz na l nb nc">httpClient.DoReturns(&amp;http.Response{}, nil)</span></pre><p id="319e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这里，我们模拟了<code class="fe ma mb mc md b">Do()</code>方法，使它返回我们希望它返回的内容，而不执行任何实际的底层http调用。为了做一些稍微更有意义的事情，我们可以将参数改为<code class="fe ma mb mc md b">DoReturns()</code>，以便测试我们的错误情况。如果您还记得<code class="fe ma mb mc md b">PerformQuery()</code>是如何工作的，那么只有当我们从服务器获得<code class="fe ma mb mc md b">http.StatusUnauthorized</code> (a 401)时，它才会返回一个错误。因此，让我们强制<code class="fe ma mb mc md b">Do()</code>返回一个带有该状态代码的响应，并测试我们是否返回了一个错误，正如我们期望我们的代码所做的那样:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="74d6" class="mf jz iq md b gy mz na l nb nc">Describe("PerformQuery", func() {<br/>  It("Executes and returns nil", func() {<br/>    Expect(appClient.PerformQuery()).NotTo(HaveOccurred())<br/>  })</span><span id="3c67" class="mf jz iq md b gy nd na l nb nc">  Context("When we get a 401", func() {<br/>    JustBeforeEach(func() {<br/>      httpClient.DoReturns(&amp;http.Response{<br/>        StatusCode: http.StatusUnauthorized,<br/>      }, nil)<br/>    })</span><span id="34af" class="mf jz iq md b gy nd na l nb nc">    It("Returns an error", func() {<br/>      Expect(appClient.PerformQuery()).To(HaveOccurred())<br/>    })<br/>  })<br/>})</span></pre><h1 id="4038" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">关于句法的一些注释</h1><h2 id="6ada" class="mf jz iq bd ka mg mh dn ke mi mj dp ki lh mk ml km ll mm mn kq lp mo mp ku mq bi translated">构建银杏测试文件</h2><p id="c59b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">银杏的一个好处是你可以灵活地组织你的测试文件。银杏提供了多种嵌套结构，惯例是按照从最外层到最内层的顺序使用它们:</p><ol class=""><li id="7caa" class="ne nf iq ky b kz lu ld lv lh ng ll nh lp ni lt nj nk nl nm bi translated">“这就是我所描述的(或测试的)”</li><li id="b4d4" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe ma mb mc md b">Context()</code>——“我在测试it的哪个方面(或者在什么条件下)”</li><li id="1986" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe ma mb mc md b">When()</code>——“在什么特定条件下”</li><li id="4a13" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe ma mb mc md b">It()</code> —“这是预期的行为(断言)”</li></ol><p id="0a7c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果你看我的代码，你会发现我不使用<code class="fe ma mb mc md b">When()</code>——这只是习惯，而不是有意识的选择。我倾向于使用两个级别的<code class="fe ma mb mc md b">Describe()</code>——一个用于我正在测试的包或(例如，在包包含多个复杂类型的情况下)类型，然后一个用于我正在测试的每个方法。对我来说，这更有意义，因为我正在描述一个特定方法的行为<em class="lz">，然后<code class="fe ma mb mc md b">Context()</code>表示方法行为被测试的<em class="lz">条件。</em>我知道其他golang程序员也使用其他模式。</em></p><p id="e485" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我喜欢广泛使用的一个特性是通过<code class="fe ma mb mc md b">BeforeEach()</code>和<code class="fe ma mb mc md b">JustBeforeEach()</code>模块嵌套前提条件/测试设置。刚接触银杏的开发人员有时会感到困惑，所以至少让我花一分钟来描述一下我是如何使用它们的。</p><p id="3530" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">从语义上来说，这两个块做同样的事情——这些函数接受一个匿名函数作为参数，该函数的主体在相同嵌套层(或更低嵌套层)的任何测试执行之前执行。因此它们通常用于测试设置。(如你所料，也有一个<code class="fe ma mb mc md b">AfterEach()</code>功能用于拆除——例如关闭测试服务器、销毁频道等。).但是在<code class="fe ma mb mc md b">BeforeEach()</code>和<code class="fe ma mb mc md b">JustBeforeEach()</code>之间有一个严格的顺序——假设我们有一个这样的文件:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="b036" class="mf jz iq md b gy mz na l nb nc">Describe("A Thing", func() {<br/>  BeforeEach("<strong class="md ir">Setup1</strong>", func() { ... } )</span><span id="6d6d" class="mf jz iq md b gy nd na l nb nc">  JustBeforeEach("<strong class="md ir">Setup2</strong>", func() { ... } )</span><span id="1048" class="mf jz iq md b gy nd na l nb nc">  Context("Some conditions", func() {<br/>    BeforeEach("<strong class="md ir">Setup3</strong>", func() { ... } )</span><span id="55b7" class="mf jz iq md b gy nd na l nb nc">    JustBeforeEach("<strong class="md ir">Setup4</strong>", func() { ... } )</span><span id="6382" class="mf jz iq md b gy nd na l nb nc">    When("Something is true", func() {<br/>      BeforeEach("<strong class="md ir">Setup5</strong>", func() { ... } )</span><span id="0ddb" class="mf jz iq md b gy nd na l nb nc">      JustBeforeEach("<strong class="md ir">Setup6</strong>", func() { ... } )</span><span id="fa31" class="mf jz iq md b gy nd na l nb nc">      It("Does something", func() { ... } )<br/>    })<br/>  })<br/>})</span></pre><p id="70c6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这里，我们在实际测试周围有三个嵌套层次。每一关我们都有一个<code class="fe ma mb mc md b">BeforeEach()</code>和一个<code class="fe ma mb mc md b">JustBeforeEach()</code>。为什么都是？正如您所料，当我们执行测试时，这些是按照从最外层到最内层的顺序执行的——<code class="fe ma mb mc md b">It()</code>调用。但是……它比那更复杂。这些命令的实际执行顺序如下:<code class="fe ma mb mc md b">Setup1</code>、<code class="fe ma mb mc md b">Setup3</code>、<code class="fe ma mb mc md b">Setup5</code>、<code class="fe ma mb mc md b">Setup2</code>、<code class="fe ma mb mc md b">Setup4</code>和<code class="fe ma mb mc md b">Setup6</code>。<em class="lz">中的所有</em> <code class="fe ma mb mc md b"><em class="lz">BeforeEach()</em></code> <em class="lz">调用将执行之前</em> <strong class="ky ir"> <em class="lz">中任何</em> </strong> <em class="lz">括起来的</em> <code class="fe ma mb mc md b"><em class="lz">JustBeforeEach()</em></code> <em class="lz">调用。</em>这使得<code class="fe ma mb mc md b">JustBeforeEach()</code>在您需要保证封装的代码是测试前运行的最后一个代码时特别有用。</p><p id="5ef0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，在我之前的测试中，我的<code class="fe ma mb mc md b">JustBeforeEach()</code>肯定会在之前对<code class="fe ma mb mc md b">BeforeEach()</code>的调用中覆盖对<code class="fe ma mb mc md b">DoReturns()</code>的调用。因此，我可以确定测试将在什么条件下执行，而不考虑之前的封闭设置。</p><p id="a62d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是，如果你在一个封闭层中调用<code class="fe ma mb mc md b">JustBeforeEach()</code>(就像我上面做的那样),然后在一个较低的层中调用<code class="fe ma mb mc md b">BeforeEach()</code>,这可能会导致问题——例如:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="5a5d" class="mf jz iq md b gy mz na l nb nc">Describe("A thing", func() {<br/>  var (<br/>    myValue int<br/>  )</span><span id="8c7a" class="mf jz iq md b gy nd na l nb nc">  JustBeforeEach(func() {<br/>    myValue = 20<br/>  })</span><span id="75d0" class="mf jz iq md b gy nd na l nb nc">  Context("When the value is 10", func() {<br/>    BeforeEach(func() {<br/>      myValue = 10<br/>    })</span><span id="ed5d" class="mf jz iq md b gy nd na l nb nc">    It("Equals 10", func() {<br/>      Expect(myValue).To(Equal(10))<br/>    })<br/>  })<br/>})</span></pre><p id="fa8e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">正如你可能已经猜到的那样，这是行不通的——<code class="fe ma mb mc md b">JustBeforeEach()</code>将在和<code class="fe ma mb mc md b">BeforeEach()</code>之后执行<em class="lz">,尽管处于封闭级别。所以在使用<code class="fe ma mb mc md b">BeforeEach()</code>和<code class="fe ma mb mc md b">JustBeforeEach()</code>时要小心，因为如果不小心很容易绊倒自己。</em></p><h2 id="f3cd" class="mf jz iq bd ka mg mh dn ke mi mj dp ki lh mk ml km ll mm mn kq lp mo mp ku mq bi translated">造假者嘲讽</h2><p id="6c1b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于被模仿界面中的每个方法，<code class="fe ma mb mc md b">counterfeiter</code>提供了许多方法来定制被模仿的行为。在上面的例子中，我使用了<code class="fe ma mb mc md b">DoReturns()</code>——对于任何方法<code class="fe ma mb mc md b">Foo()</code>，<code class="fe ma mb mc md b">FooReturns()</code>将指定对<code class="fe ma mb mc md b">Foo()</code>的调用返回特定的传递值——例如，如果<code class="fe ma mb mc md b">Foo()</code>返回一个<code class="fe ma mb mc md b">bool</code>，那么<code class="fe ma mb mc md b">FooReturns(true)</code>将意味着<em class="lz">对<code class="fe ma mb mc md b">Foo()</code>的所有</em>后续调用都将返回<code class="fe ma mb mc md b">true</code>。<code class="fe ma mb mc md b">counterfeiter</code>耗材，除了<code class="fe ma mb mc md b">XXXReturns()</code>方法，还有一个<code class="fe ma mb mc md b">XXXReturnsOnCall()</code>方法。如果您知道您在要测试的函数中调用了<code class="fe ma mb mc md b">Foo()</code>三次，并且您希望它第一次返回<code class="fe ma mb mc md b">true</code>，第二次返回<code class="fe ma mb mc md b">false</code>，第三次返回<code class="fe ma mb mc md b">true</code>，您可以这样做:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="542e" class="mf jz iq md b gy mz na l nb nc">FooReturnsOnCall(0, true)<br/>FooReturnsOnCall(1, false)<br/>FooReturnsOnCall(2, true)</span></pre><p id="6e82" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果<code class="fe ma mb mc md b">Foo()</code>被调用了十次，并且您只希望第七次调用返回<code class="fe ma mb mc md b">false</code>，但是其他所有调用都返回true，您可以这样做:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="31b5" class="mf jz iq md b gy mz na l nb nc">FooReturns(true)<br/>FooReturnsOnCall(6, false)</span></pre><p id="8435" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您想模仿函数做一些事情，而不仅仅是简单地返回一个硬编码的值，那么您可以将<code class="fe ma mb mc md b">XXXStub</code>变量设置为您希望在调用<code class="fe ma mb mc md b">XXX()</code>方法时执行的函数体——当然，签名必须与原始的<code class="fe ma mb mc md b">XXX()</code>方法的签名相匹配。</p><h1 id="a8b6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在服务器中添加</h1><p id="c55e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这一点上，我们已经看到，从客户端模拟http行为可以非常非常简单，并且在执行和设置方面比使用测试服务器要轻一些。但有时你真的需要一个测试服务器，所以接下来我们将看看这方面的一些情况。</p><h2 id="0188" class="mf jz iq bd ka mg mh dn ke mi mj dp ki lh mk ml km ll mm mn kq lp mo mp ku mq bi translated">也许我们所需要的只是一个操纵者…</h2><p id="d6b7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好吧，我撒谎了。我们还不打算建立一个完全成熟的测试HTTP服务器。如果您正在编写服务器端HTTP代码，您通常希望将处理程序与路由(mux)代码分开(这既是出于模块化的一般原因，也是因为您有多个路径调用同一个处理程序)。所以让我们从测试一些处理程序开始。没有服务器我们怎么做呢？</p><p id="6106" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">测试一个处理器不需要使用<code class="fe ma mb mc md b">counterfeiter</code>——但是我们将使用标准的<code class="fe ma mb mc md b">httptest</code>包。Go中的HTTP处理函数通常有一个签名<code class="fe ma mb mc md b">(http.ResponseWriter, *http.Request)</code>——虽然您当然可以使用不同的签名，并且仍然可以在您的处理函数中找到一种方法，但是没有什么好的理由偏离这种模式(这意味着您的处理函数可以与您选择的任何mux一起使用，无论是Gorilla、Echo、Gin还是Go已经有的内置mux)。</p><p id="4bd7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们编写一个非常基本的处理程序——我们将检查单个必需的头(<code class="fe ma mb mc md b">X-Account</code>)，如果没有找到，则返回400(错误请求)。我们还将检查请求方法——取决于您如何编写处理程序并将它们连接到mux，这可能完全是多余的——一个好的模式是拥有特定于方法的处理程序，并通过在mux层中指定方法来路由到它们(大多数，但不是所有，mux实现提供这种功能OOTB——例如，默认的Golang mux不提供)。我们可能会得到这样的结果:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="e9a5" class="mf jz iq md b gy mz na l nb nc">package server</span><span id="68d7" class="mf jz iq md b gy nd na l nb nc">import (<br/>  "net/http"<br/>)</span><span id="a16b" class="mf jz iq md b gy nd na l nb nc">const (<br/>  HEADER_KEY_X_ACCOUNT = "X-Account"<br/>)</span><span id="666b" class="mf jz iq md b gy nd na l nb nc">func HandleGET(w http.ResponseWriter, r *http.Request) {<br/>  // Check our required header<br/>  account := r.Header.Get(HEADER_KEY_X_ACCOUNT)</span><span id="6ee8" class="mf jz iq md b gy nd na l nb nc">  if account == "" {<br/>    w.WriteHeader(http.StatusBadRequest)<br/>  } else {<br/>    if r.Method != http.MethodGet {<br/>      w.WriteHeader(http.StatusInternalServerError)<br/>    } else {<br/>      // Process request<br/>      w.Write([]byte("Content!"))<br/>    }<br/>  }<br/>}</span></pre><p id="82ff" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">测试这一点非常简单——我们只需要给它一个请求，然后检查响应……但是我们如何在运行实际服务器之外做到这一点(至少，我们如何在测试用例中轻松做到这一点)？</p><p id="7610" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将利用<code class="fe ma mb mc md b">httptest</code>包中的两个函数— <code class="fe ma mb mc md b">httptest.NewRequest()</code>和<code class="fe ma mb mc md b">httptest.NewRecorder()</code>。第一个返回一个被填充的<code class="fe ma mb mc md b">*http.Request</code>，就好像它是由服务器路由的一样(与客户端生成的相反)。这意味着请求将把目标设置为<code class="fe ma mb mc md b">example.com</code>，除非所提供的URL是一个完全合格的URL。第二个返回类型为<code class="fe ma mb mc md b">*httptest.ResponseRecorder</code>的实例——真实的服务器会传入一个用于将输出路由回客户机的实现，但是在我们的例子中，我们只想捕获请求处理的结果。所以这基本上是一个方便的实现。</p><p id="209d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下面是我们的测试文件此时的样子:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="a2c0" class="mf jz iq md b gy mz na l nb nc">package server_test</span><span id="25d0" class="mf jz iq md b gy nd na l nb nc">import (<br/>  "net/http"<br/>  "net/http/httptest"</span><span id="79dd" class="mf jz iq md b gy nd na l nb nc">  . "github.com/onsi/ginkgo"<br/>  . "github.com/onsi/gomega"</span><span id="ca27" class="mf jz iq md b gy nd na l nb nc">  "myapp/go-http-testing/examples/server"<br/>)</span><span id="f0a4" class="mf jz iq md b gy nd na l nb nc">var _ = Describe("Server", func() {<br/>  var (<br/>    req     *http.Request<br/>    handler http.Handler<br/>    writer  *httptest.ResponseRecorder<br/>  )</span><span id="89ca" class="mf jz iq md b gy nd na l nb nc">  Describe("HandleGET", func() {<br/>    BeforeEach(func() {<br/>      handler = http.HandlerFunc(server.HandleGET)<br/>      req = httptest.NewRequest(http.MethodGet, "/", nil)<br/>      req.Header.Add(server.HEADER_KEY_X_ACCOUNT, "myaccount")<br/>      writer = httptest.NewRecorder()<br/>    })</span><span id="18c5" class="mf jz iq md b gy nd na l nb nc">    It("Processes a GET request successfully", func() {<br/>      handler.ServeHTTP(writer, req)<br/>      Expect(writer.Code).To(Equal(http.StatusOK))<br/>    })</span><span id="a9a5" class="mf jz iq md b gy nd na l nb nc">    Context("When we get the wrong method", func() {<br/>      JustBeforeEach(func() {<br/>        req.Method = http.MethodPost<br/>      })</span><span id="d10d" class="mf jz iq md b gy nd na l nb nc">      It("Returns an internal server error", func() {<br/>        handler.ServeHTTP(writer, req)<br/>        Expect(writer.Code).To(<br/>          Equal(http.StatusInternalServerError))<br/>      })<br/>    })<br/>  })<br/>})</span></pre><p id="ae4b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们首先将我们的处理函数包装在一个<code class="fe ma mb mc md b">http.HandlerFunc</code>中，它添加了<code class="fe ma mb mc md b">http.Handler</code>接口所需的<code class="fe ma mb mc md b">ServeHTTP</code>方法。当然，我们可以直接调用我们的<code class="fe ma mb mc md b">server.HandleGET()</code>函数，但是包装会强制执行标准的调用签名(这在这里本身就是一个很好的实践)。<code class="fe ma mb mc md b">writer</code>变量是我们的<code class="fe ma mb mc md b">*httptest.ResponseRecorder</code>对象，在调用<code class="fe ma mb mc md b">ServeHTTP()</code>之后，<code class="fe ma mb mc md b">writer</code>保存处理结果——在本例中是我们在断言中检查的HTTP状态代码。</p><h2 id="2e5b" class="mf jz iq bd ka mg mh dn ke mi mj dp ki lh mk ml km ll mm mn kq lp mo mp ku mq bi translated">好，现在我们启动一个服务器</h2><p id="b256" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">将我们的函数包装在<code class="fe ma mb mc md b">http.HandlerFunc</code>中还有另一个目的——创建一个测试服务器，我们需要传递一个<code class="fe ma mb mc md b">http.Handler</code>的实现，包装给了我们一个。</p><p id="492e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为什么我们要在这个时候启动服务器？我们已经有了我们认为是工作的处理程序，我们已经有了我们认为是工作的客户，我们都很好，对吗？嗯，确保API契约的双方实际上一起工作是一个好主意，这允许我们这样做。</p><p id="3999" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在上面的测试文件中，我们在最后一个<code class="fe ma mb mc md b">})</code>之前添加了以下内容:</p><pre class="mr ms mt mu gt mv md mw mx aw my bi"><span id="e2cb" class="mf jz iq md b gy mz na l nb nc">Describe("Server-side Request handling", func() {<br/>  var (<br/>    c   *client.MyApplicationClient<br/>    srv *httptest.Server<br/>  )</span><span id="095a" class="mf jz iq md b gy nd na l nb nc">  BeforeEach(func() {<br/>    handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>      Expect(r.URL.Path).To(Equal("/resource"))<br/>      w.WriteHeader(http.StatusCreated)<br/>    })<br/>  })</span><span id="0066" class="mf jz iq md b gy nd na l nb nc">  JustBeforeEach(func() {<br/>    srv = httptest.NewServer(handler)<br/>    c = client.NewApplicationClient(srv.Client())<br/>  })</span><span id="a900" class="mf jz iq md b gy nd na l nb nc">  AfterEach(func() {<br/>    srv.CloseClientConnections()<br/>    srv.Close()<br/>  })</span><span id="1c0a" class="mf jz iq md b gy nd na l nb nc">  It("Checks the resource path", func() {<br/>    c.PerformQuery()<br/>  })</span><span id="8608" class="mf jz iq md b gy nd na l nb nc">  Context("Use a different handler", func() {<br/>    BeforeEach(func() {<br/>      handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>        Expect(r.Method).To(Equal(http.MethodPost))<br/>        w.WriteHeader(http.StatusCreated)<br/>      })<br/>    })</span><span id="f550" class="mf jz iq md b gy nd na l nb nc">    It("Checks the request method", func() {<br/>      c.PerformQuery()<br/>    })<br/>  })<br/>})</span></pre><p id="632f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">注意我们对银杏测试设置/拆卸工具的使用——我们的第一个<code class="fe ma mb mc md b">BeforeEach()</code>调用设置了一个包含实际测试断言的默认处理程序。我们使用一个<code class="fe ma mb mc md b">JustBeforeEach()</code>来确保在测试之前执行的最后一个动作是启动服务器(作为参数传入我们的处理程序)。在我们的嵌套案例中(在内部<code class="fe ma mb mc md b">Context()</code>中)，我们使用另一个<code class="fe ma mb mc md b">BeforeEach()</code>来覆盖默认的处理程序——因为服务器本身是在一个<code class="fe ma mb mc md b">JustBeforeEach()</code>中启动的，我们保证服务器将在我们设置了我们的<code class="fe ma mb mc md b">handler</code>变量的值之后启动<em class="lz">,确保处理程序将测试正确的断言。</em></p><p id="332b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们还添加了对<code class="fe ma mb mc md b">AfterEach()</code>的使用——通常，测试服务器的拆除是在测试用例的清理阶段执行的。</p><h1 id="6205" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">整理想法</h1><p id="fbb0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于用golang测试HTTP代码来说，这是一组既不全面也不规范的例子。如果你在网上搜索，你肯定会看到不同的模式，包括一些使用我在这里使用的相同工具的模式。还有许多可能的排列我没有在这里演示(例如，测试你的多路复用/路由层)。我也没有试图深入研究银杏和(尤其是)Gomega所提供的东西，只是解释我的例子所需要的东西——两者都有很多很多更多的特性，值得作为通用golang BDD/TDD框架来研究。</p><p id="21ae" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此外，正如我在上面提到的，我没有演示Gomega的<code class="fe ma mb mc md b">ghttp</code>包——也许这是以后文章的主题。</p><p id="6e73" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是我希望这将被证明是有用的，特别是对于刚接触golang的开发人员和/或不知道如何开始测试HTTP代码的go开发人员。</p></div></div>    
</body>
</html>