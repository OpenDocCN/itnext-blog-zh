<html>
<head>
<title>Designing Restful APIs using an API-First Approach — Mocking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用API优先的方法设计Restful APIs模仿</h1>
<blockquote>原文：<a href="https://itnext.io/designing-apis-using-an-api-first-approach-mock-server-78ddbd9993f5?source=collection_archive---------1-----------------------#2020-09-03">https://itnext.io/designing-apis-using-an-api-first-approach-mock-server-78ddbd9993f5?source=collection_archive---------1-----------------------#2020-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f737" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几周前，我开始了一个新的帖子系列，讨论API优先和使用OpenAPI规范的API设计。</p><p id="b338" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你还没有看到这个系列的第一篇文章，我建议你停止阅读，点击<a class="ae kl" href="https://medium.com/@nicolastakashi/restful-using-api-first-cd305e59305d?source=friends_link&amp;sk=c7e0e73751dbd62ddea2cf9928dec49c" rel="noopener">这里</a>查看。</p><p id="8d41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在今天的帖子中，我将讨论如何使用OpenAPI文档构建一个模拟服务器来改善开发人员的体验和工作并行性。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/b2f2a23765381dc78836867dd8f5a8a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*frxTR92Vj92OovJr.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">【https://thesaurus.plus/ T2】号</figcaption></figure><h1 id="67ea" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">😎—模拟概念</h1><p id="dad3" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在我们使用OpenAPI文档深入研究Mock技术之前，让我们确保每个人都知道根据维基百科Mock是什么意思。</p><blockquote class="mb mc md"><p id="6942" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">在<a class="ae kl" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向对象编程</a>，<strong class="jp ir">模拟对象</strong>是以受控方式模仿真实对象行为的模拟对象，通常作为<a class="ae kl" href="https://en.wikipedia.org/wiki/Software_testing" rel="noopener ugc nofollow" target="_blank">软件测试</a>计划的一部分。程序员通常会创建一个模拟对象来测试一些其他对象的行为，就像汽车设计师使用一个<a class="ae kl" href="https://en.wikipedia.org/wiki/Crash_test_dummy" rel="noopener ugc nofollow" target="_blank">碰撞测试假人</a>来<a class="ae kl" href="https://en.wikipedia.org/wiki/Simulation" rel="noopener ugc nofollow" target="_blank">模拟</a>人类在汽车碰撞中的动态行为一样。该技术也适用于<a class="ae kl" href="https://en.wikipedia.org/wiki/Generic_programming" rel="noopener ugc nofollow" target="_blank">通用编程</a>。</p><p id="c91b" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Mock_object" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><h1 id="1064" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">💡—在HTTP级别进行模拟。</h1><p id="7f04" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在API世界中，mock的概念仍然和上面描述的一样，但是不是使用框架来模拟对象，比如Moq和RinoMock，而是使用一个Mock服务器来完成。</p><p id="7415" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模拟服务器将对预期的端点、不存在的端点的错误做出响应，如果客户端向其发送无效请求，通常甚至会提供真实的验证错误。</p><h2 id="bfb4" class="mi kz iq bd la mj mk dn le ml mm dp li jy mn mo lm kc mp mq lq kg mr ms lu mt bi translated">模拟服务器替代方案</h2><p id="543d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">创建模拟服务器有两种选择，每一种都有其利弊，下面你可以查看一个简短的选项列表。</p><ul class=""><li id="3967" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated"><a class="ae kl" href="http://www.mock-server.com/" rel="noopener ugc nofollow" target="_blank">模拟服务器</a></li><li id="4063" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated"><a class="ae kl" href="https://learning.getpostman.com/docs/postman/mock-servers/setting-up-mock/" rel="noopener ugc nofollow" target="_blank">邮递员模拟服务器</a></li><li id="04d0" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated"><a class="ae kl" href="https://github.com/nock/nock" rel="noopener ugc nofollow" target="_blank">诺克</a></li><li id="17f5" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated"><a class="ae kl" href="https://meta.stoplight.io/docs/prism/README.md" rel="noopener ugc nofollow" target="_blank">棱镜</a></li></ul><p id="374d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面列出的每一个选项都是很好的工具，并且肯定能按预期工作。但是这篇文章的目标是展示如何使用OpenAPI文档来构建一个模拟服务器。</p><p id="17c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住，只是<a class="ae kl" href="https://meta.stoplight.io/docs/prism/README.md" rel="noopener ugc nofollow" target="_blank"> Prism </a>为我们提供了一个内置的与Open-API的集成来创建一个模拟服务器，所以我们不需要写任何代码来做这件事。</p><h1 id="9708" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">🙌Prism简介</h1><p id="5b9b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Prism是一个命令行界面，它使用OpenAPI文档聚集了一组API模拟包，这是使用JavaScript和NodeJS开发的，在<a class="ae kl" href="https://github.com/stoplightio/prism" rel="noopener ugc nofollow" target="_blank"> Github Repository </a>上有一个巨大的社区和许多明星。</p><h2 id="af2d" class="mi kz iq bd la mj mk dn le ml mm dp li jy mn mo lm kc mp mq lq kg mr ms lu mt bi translated">入门指南</h2><p id="318c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在上一篇文章中，我在文章系列的代码中使用了一个<a class="ae kl" href="https://github.com/nicolastakashi/todoapp-openapidocuments" rel="noopener ugc nofollow" target="_blank"> Github库</a>，所以让我们继续在它的基础上工作，改进解决方案。</p><p id="e893" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们使用下面的一些命令将Prism添加到项目中。</p><pre class="kn ko kp kq gt ni nj nk nl aw nm bi"><span id="4916" class="mi kz iq nj b gy nn no l np nq">yarn add @stoplight/prism-cli<br/><em class="me"># or<br/></em>npm install --save @stoplight/prism-cli</span></pre><p id="cf87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Prism的HTTP模拟服务器通过提供API描述文档中描述的端点和验证规则来模拟真实的web API，像任何HTTP解决方案一样，它围绕请求消息和响应消息工作。</p><h2 id="e4cb" class="mi kz iq bd la mj mk dn le ml mm dp li jy mn mo lm kc mp mq lq kg mr ms lu mt bi translated">响应生成</h2><p id="4f23" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Prism将尝试基于它所拥有的任何信息返回有意义的响应，这意味着任何OpenAPI文档都可以使用，但是更好的文档会提供更好的结果。如果您想知道prism决策引擎如何生成响应，您可以查看这个<a class="ae kl" href="https://meta.stoplight.io/docs/prism/docs/guides/01-mocking.md#the-decision-engine" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><h2 id="e874" class="mi kz iq bd la mj mk dn le ml mm dp li jy mn mo lm kc mp mq lq kg mr ms lu mt bi translated">响应生成策略</h2><p id="072a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Prism有两种响应生成策略，<strong class="jp ir">静态生成、</strong>和<strong class="jp ir">动态生成</strong>，这些选项之间有一些差异，我们现在就来了解一下。</p><h2 id="f99b" class="mi kz iq bd la mj mk dn le ml mm dp li jy mn mo lm kc mp mq lq kg mr ms lu mt bi translated">静态生成策略</h2><p id="c57c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">默认情况下，Prism会使用一个静态的<strong class="jp ir">生成策略</strong>来创建一个响应消息，要使用它，你可以运行下面的命令。</p><pre class="kn ko kp kq gt ni nj nk nl aw nm bi"><span id="9c20" class="mi kz iq nj b gy nn no l np nq">prism mock &lt;path-to-openapi&gt;</span></pre><p id="008c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果所提供的OpenAPI文档有一个响应体示例，那么它将使用该示例，否则，将通过查看整个模式对象来创建一个假响应，从而创建响应体。</p><h2 id="b052" class="mi kz iq bd la mj mk dn le ml mm dp li jy mn mo lm kc mp mq lq kg mr ms lu mt bi translated">动态生成策略</h2><p id="889e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">反复测试完全相同的数据并不是构建健壮API的最佳方式，在现实世界中，数据是动态的，我们必须能够正确处理它，您可以运行下面的命令。</p><pre class="kn ko kp kq gt ni nj nk nl aw nm bi"><span id="31eb" class="mi kz iq nj b gy nn no l np nq">prism mock &lt;path-to-openapi&gt; -d</span></pre><p id="c3b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">动态模式通过根据所有属性的类型和其他信息(如格式)为所有属性生成一个随机值来解决这个问题，这意味着您的API描述得越详细，Prism在创建模拟响应时就能做得越好。</p><h2 id="9d4a" class="mi kz iq bd la mj mk dn le ml mm dp li jy mn mo lm kc mp mq lq kg mr ms lu mt bi translated">请求验证</h2><p id="9a4b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">基于API描述，文档Prism可以使用关键字<code class="fe nr ns nt nj b">type</code>、<code class="fe nr ns nt nj b">format</code>、<code class="fe nr ns nt nj b">maxLength</code>来考虑请求体、头部、查询参数的各种验证规则</p><h1 id="f44b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">👊Prism简介</h1><p id="6699" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在您已经知道了Prism的基础知识及其工作原理，让我们在我们的API项目中配置它，并启动一个新的模拟服务器。</p><p id="bba9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要用两个新命令<code class="fe nr ns nt nj b">mock</code>和<code class="fe nr ns nt nj b">premock</code>将<code class="fe nr ns nt nj b">package.json</code>修改成如下图所示。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d8c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，只需运行下面的命令来启动Prism，并在控制台上查看输出。</p><pre class="kn ko kp kq gt ni nj nk nl aw nm bi"><span id="208f" class="mi kz iq nj b gy nn no l np nq">yarn mock</span></pre><p id="f080" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们查看控制台输出，有一个模拟服务器正在通过<code class="fe nr ns nt nj b">localhost:4010</code>运行，从现在开始，我们能够对这个Prism服务器进行API调用。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nw"><img src="../Images/d3bdb412da49094a4359b7295f609dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2mKL08D39GazlewrCzifw.png"/></div></div></figure><h2 id="dc32" class="mi kz iq bd la mj mk dn le ml mm dp li jy mn mo lm kc mp mq lq kg mr ms lu mt bi translated">使用Swagger UI进行API调用</h2><p id="2082" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让我们通过Swagger UI发出一个请求调用，但在此之前，更改<code class="fe nr ns nt nj b">api.yaml</code>并添加servers部分，如下例所示。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">api.yaml</figcaption></figure><p id="e41b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果我们查看Swagger UI，我们会注意到一个新的下拉列表，其中包含可用服务器的列表，如下图所示。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi ob"><img src="../Images/9eebcf5b5de0db95d7cfd69e6cb18f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5F6eQyFkgPU1WAv0v7S-ZA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Swagger UI —服务器列表</figcaption></figure><p id="4e18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后但同样重要的是，让我们尝试创建一个任务，调用<code class="fe nr ns nt nj b">POST /tasks</code>并查看输出。</p><h2 id="0ac8" class="mi kz iq bd la mj mk dn le ml mm dp li jy mn mo lm kc mp mq lq kg mr ms lu mt bi translated">成功请求</h2><p id="1898" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">因为<code class="fe nr ns nt nj b">name</code>是必需的，我们发送了这个属性，所以request返回一个带有位置头的HTTP Created 201，如下图所示。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi oc"><img src="../Images/73c8a5c5e92c6b48daa51dcc2a0dc6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2QOKdXRPjUzPpsLEYr1BQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用有效参数创建新任务</figcaption></figure><h1 id="262e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">无效请求</h1><p id="6981" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在尝试创建一个没有名称的任务后，我们得到了HTTP错误请求，如OpenAPI文档中所述。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi od"><img src="../Images/3b61c6ea902132a5086c073f511395a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nE3IRKxUkBOtKhxZPhOD6g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用无效参数创建新任务</figcaption></figure><h1 id="4d67" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">🏁结论</h1><p id="505f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">今天到此为止，现在您已经有了关于模拟API的基础知识，我强烈建议您查看Prism官方文档，了解每一个特性，以及如何将它部署到您的客户，利用这一策略。</p><p id="e329" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">API Mock可以预见到API消费和系统集成之间可能存在的许多问题。</p><p id="1aeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在Github上查看这个项目，所有的东西都随着我们在这篇文章中所做的实现而更新。</p><p id="423e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢它，请让我知道你的反馈，在下面评论，并与你的朋友分享。</p></div></div>    
</body>
</html>