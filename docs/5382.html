<html>
<head>
<title>Virtual Filesystem in Go — Creating our Foundation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的虚拟文件系统——创建我们的基础</h1>
<blockquote>原文：<a href="https://itnext.io/a-virtual-filesystem-in-go-creating-our-foundation-9af62b0e82db?source=collection_archive---------5-----------------------#2021-02-21">https://itnext.io/a-virtual-filesystem-in-go-creating-our-foundation-9af62b0e82db?source=collection_archive---------5-----------------------#2021-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f8cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于文件系统实现的第一篇官方文章。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/ebcd6e34ebecda5750e13b47ad7bffd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*5VtbdmypcxOav7xQlMrIcw.jpeg"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">找到这些普通图片真的很难:(</figcaption></figure><p id="6de9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们终于到了第一天的读者，希望你已经准备好在Go中创建一个不可思议的漂亮而又不是超级快的虚拟文件系统，因为我们是在计划的同时进行构建的。为什么不在我的GitHub repo上跟进这个项目，并在<a class="ae kx" href="https://github.com/AlysonBee/GoVirtualFilesystem" rel="noopener ugc nofollow" target="_blank">https://github.com/AlysonBee/GoVirtualFilesystem</a>让我知道你的想法或分享你的想法。</p><p id="4d3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些简单的介绍，在我们进入实际的文件系统之前，让我们确保我们拥有了在这个项目中编码所需的一切。先决条件时间到了！</p><p id="dcc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">免责声明</strong>:我将在Windows 10上编写这个项目，但会在Windows 10和它附带的Ubuntu子系统上进行测试，以确保两个操作系统都支持它。这应该不是问题，但这是我第一次参加安全第一的竞技表演。</p><h2 id="4383" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">设置好一切</h2><p id="3bd9" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">编辑:原来我用的是过时的Go版本，从1.14升级到了1.16。</p><p id="5b96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们清单上的第一项也是最明显的一项就是确保你已经安装了Go(我正在使用的是Windows版的1.16)。你可以根据你的具体操作系统在https://golang.org/dl/<a class="ae kx" href="https://golang.org/dl/" rel="noopener ugc nofollow" target="_blank">下载。安装是一个简单的解压和双击，但具体的说明，你也可以在主要的Go网站上找到(</a><a class="ae kx" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">https://golang.org/doc/install</a>)。</p><p id="83ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这实际上是你最需要的东西。我们会尽可能的保密。</p><p id="7fda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每篇文章发表几天后，我会对每一步进行总结并添加到我的GitHub repo中。如果您只是想要代码本身，您可以跟随项目，而这些文章将进入我的设计决策的“如何”和“为什么”。请注意，回购结构将每个部分分为标记为数字(01，02…)的文件夹。这些文件夹的代码都是我们创建时的代码，没有其他的了。这些文件夹都不相互依赖，所以可以随意地将它们视为同一个项目的不同迭代版本。如果你跟着做的话，你可以把所有的工作放在一个文件夹里。</p><p id="ce87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们的准备工作。让我们开始吧。</p><h1 id="b709" class="lw kz iq bd la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm bi translated">设计</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/2d440c3c774dab19465af77a4fdd2268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgJ0qzbUrjzOvGtQuPvfJA.jpeg"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">项目的设计概述</figcaption></figure><p id="315a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是所有事物的整体结构以及各部分之间的关系。四个组件之间的关系非常简单。每个组件可以描述如下:</p><ul class=""><li id="c9e0" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated"><strong class="jp ir">用户对象</strong> —这代表用户以及与该特定用户身份相关的所有访问权限。我认为谷歌云是光秃秃的，而且严重不发达。这必须是充实和无缝的，因为这是用户体验应用程序的一部分，因为它将决定他们能做什么，不能做什么。</li><li id="2c83" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">交互式外壳</strong> —用户将用来与文件系统交互的外壳。该结构包含将用于与虚拟空间交互的函数库。像open、close、mkdir和ls这样的函数只是列举了几个实用程序，我们将为它们制作虚拟文件系统等价物。</li><li id="8add" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">虚拟文件系统</strong> —这是从您的原生文件系统提取到RAM中的文件和目录的集合，从您启动应用程序的目录开始，向下遍历嵌套的子目录。这里有很多发挥创造力的空间，因为我们的大多数性能瓶颈和/或问题(如延迟和冻结)都来自于最终的实现方式。</li><li id="8926" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">本地目录</strong> —文件系统将从中克隆自身的目录。当您完成编辑时，这也是您编辑的副本将保存到的位置。就我们与本机目录的交互而言，我们将从虚拟文件系统实现检查，以验证遍历深度以及在克隆文件时消耗的内存，从而检查内存溢出等问题。</li></ul><p id="48b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们现在的目标是对这些组件有一个基本的布局。每一部分都需要尽可能独立，以便于调试，同时确保以后添加功能时不会遇到大规模重构的麻烦；理想情况下，根本不需要重构，但是现在超越我们自己还为时过早。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="cddf" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">用户对象</h2><p id="6db5" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">用户对象既是最容易立即开始的方面，也是可以扩展到最大程度并变得最复杂的组件，因为这是安全性和易用性必须齐头并进的地方。像设置权限、向其他用户授予权限和继承访问权限等功能都将在这里发生。这些特性不会出现在第一个版本中，但是假设我们已经做到了，增加这些特性不会迫使我们放弃大部分之前的工作，所以我们将来会在这里花很多时间。</p><p id="0588" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码(<code class="fe nn no np nq b">user.go</code>):</p><pre class="km kn ko kp gt nr nq ns nt aw nu bi"><span id="8dc8" class="ky kz iq nq b gy nv nw l nx ny">package main</span><span id="c533" class="ky kz iq nq b gy nz nw l nx ny">import (<br/> "fmt"<br/> "math/rand"<br/>)</span><span id="f4ad" class="ky kz iq nq b gy nz nw l nx ny">// The main user object.<br/>type user struct {<br/> userID uint64             // A randomized integer representing the users's unique ID.<br/> username string           // The user's onscreen name.<br/> accessList map[string]int // A map containing the unique hashes and access rights for each file.<br/>}</span><span id="257e" class="ky kz iq nq b gy nz nw l nx ny">// generateRandomID generates a random userID value.<br/>func generateRandomID() uint64 {<br/> return uint64(rand.Uint32()) &lt;&lt; 32 + uint64(rand.Uint32())<br/>}</span><span id="be8c" class="ky kz iq nq b gy nz nw l nx ny">// createUser creates a user object.<br/>func createUser(username string) *user {<br/> return &amp;user{<br/>  userID: generateRandomID(),<br/>  username: username,<br/> }<br/>}</span><span id="b643" class="ky kz iq nq b gy nz nw l nx ny">// updateUsername updates the name of the current user.<br/>func (currentUser * user) updateUsername(username string) {<br/> currentUser.username = username<br/>}</span></pre><p id="ea3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最初，这种结构的影响只能在shell级别感受到，因为它允许用户设置自己的用户名来标记shell提示符。比如说；使提示符看起来像这样<code class="fe nn no np nq b">AlysonV$&gt;</code>或<code class="fe nn no np nq b">VivianS$&gt;</code>等等。我们文件系统的第一个版本没有定义访问权限，所以<code class="fe nn no np nq b">accessList</code>方法暂时不会被使用。不过，让我们稍微讨论一下最后一个细节，因为这是一个重要的文件系统概念。</p><p id="5865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">一些技术背景—Inode</strong></p><p id="4e9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数类似Unix的文件系统都使用称为Inodes的数据结构。这些基本上负责存储填充系统的文件和目录的信息。它们保存信息，如文件和目录的访问权限、哪些文件属于哪些目录和子目录、文件大小和文件类型数据等。我们将从Inode概念中使用的一个小设计思想是<code class="fe nn no np nq b">accessList</code>成员。这个想法是，创建的每个唯一的文件都有一个附带的哈希值。假设当前用户对目标文件有一定的访问限制，该信息将被存储在<code class="fe nn no np nq b">accessList</code>变量中；键是文件的唯一散列(唯一的无符号64位数字)，值是用户对该散列所属文件的唯一权限。</p><p id="7d1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是处理权限的最终想法。现在，每个人都可以访问任何东西，不管是谁。所以我们暂时把它放在一边。</p><h2 id="43d1" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">交互式外壳</h2><p id="a43d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">外壳是一种结构，它包含用户用来与文件交互的所有功能。它分为两部分:需要与系统和shell循环交互的库函数，用户将在shell循环中输入命令。</p><p id="e91c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图书馆(<code class="fe nn no np nq b">lib.go</code>):</p><pre class="km kn ko kp gt nr nq ns nt aw nu bi"><span id="d3c3" class="ky kz iq nq b gy nv nw l nx ny">package main</span><span id="49f9" class="ky kz iq nq b gy nz nw l nx ny">import (<br/> "fmt"<br/>)</span><span id="abf3" class="ky kz iq nq b gy nz nw l nx ny">// the base library object.<br/>type library struct {<br/>}</span><span id="053c" class="ky kz iq nq b gy nz nw l nx ny">// initLibrary initializes the library functions.<br/>func initLibrary() *library {<br/> fmt.Println("Importing library.")<br/> return &amp;Library{}<br/>}</span><span id="4b33" class="ky kz iq nq b gy nz nw l nx ny">// open will allow for opening files in virtual space.<br/>func (session * library) open() error {<br/> fmt.Println("open() called")<br/> return nil<br/>}</span><span id="d6af" class="ky kz iq nq b gy nz nw l nx ny">// close closes open virtual files.<br/>func (session * library) close() error {<br/> fmt.Println("close() called")<br/> return nil<br/>}</span><span id="91f3" class="ky kz iq nq b gy nz nw l nx ny">// mkDir makes a virtual directory.<br/>func (session * library) mkDir() error {<br/> fmt.Println("mkDir() called")<br/> return nil<br/>}</span><span id="70d5" class="ky kz iq nq b gy nz nw l nx ny">// removeFile removes a file from the virtual filesystem.<br/>func (session * library) removeFile() error {<br/> fmt.Println("removeFile() called")<br/> return nil<br/>}</span><span id="06eb" class="ky kz iq nq b gy nz nw l nx ny">// removeDir removes a directory from the virtual filesystem.<br/>func (session * library) removeDir() error {<br/> fmt.Println("removeDir() called")<br/> return nil<br/>}</span><span id="8018" class="ky kz iq nq b gy nz nw l nx ny">// listDir lists a directory's contents.<br/>func (session * library) listDir() error {<br/> fmt.Println("listDir() called")<br/> return nil<br/>}</span></pre><p id="69ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上是基本骨架。可以轻松地添加和删除功能，而不会破坏其他所有功能。下面是这些函数在shell中的工作方式。我希望有一种方法能使调用函数比一长串switch语句一个接一个地排列起来更容易，但是现在，这种方法是可行的。</p><p id="98dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">外壳循环代码(<code class="fe nn no np nq b">shell.go</code>):</p><pre class="km kn ko kp gt nr nq ns nt aw nu bi"><span id="6625" class="ky kz iq nq b gy nv nw l nx ny">package main</span><span id="3b3b" class="ky kz iq nq b gy nz nw l nx ny">import (<br/> "fmt"<br/> "bufio"<br/> "os"<br/>)</span><span id="f171" class="ky kz iq nq b gy nz nw l nx ny">// shellLoop runs the main shell loop for the filesystem.<br/>func shellLoop() {</span><span id="970e" class="ky kz iq nq b gy nz nw l nx ny">library := InitLibrary()<br/> reader := bufio.NewReader(os.Stdin)<br/> for {<br/>  fmt.Printf("$&gt;")<br/>  input, _ := reader.ReadString('\n')<br/> <br/>  if input == "\r\n" {<br/>   continue <br/>  }</span><span id="9be6" class="ky kz iq nq b gy nz nw l nx ny">input = input[:len(input) - 2]</span><span id="70e1" class="ky kz iq nq b gy nz nw l nx ny">switch input { <br/>  case "open":<br/>   library.Open()<br/>  case "close":<br/>   library.Close()<br/>  case "remove":<br/>   library.RemoveDir()<br/>  case "ls":<br/>   library.listDir()<br/>  default:<br/>   fmt.Println(input, ": Command not found")<br/>  }<br/> }<br/>}</span></pre><p id="5bd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个循环可能会因为它要做的所有工作而发生变化。这个版本只是给出了它将拥有的基本控制流的概述；它将读取用户的输入，并根据传入的命令运行某个库函数，或者在没有传入命令的情况下继续运行。像命令历史和自动完成这样的细节将被添加进来，使它更像Unix。</p><h2 id="4c1a" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">文件系统</h2><p id="483c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">文件系统实际上只有两个主要特性，这两个特性有可能以多种方式实现；这是初始化和拆卸。我怀疑我将有最大的麻烦，使这些工作合理地快，而不是在启动和退出时暂停系统。初始化将涉及递归遍历应用程序所在的目录及其所有子目录；克隆它遇到的每个文件，以便在虚拟空间中访问。这一步需要在检测失败的副本、内存溢出和最大打开文件描述符违反等方面有一定的健壮性(如果您不知道这意味着什么，现在没关系，我会解释何时有必要直接担心它们)。违规这么多，时间这么少。</p><p id="d490" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就优化而言，这一步可能会有很多创意。当我们开始一次将焦点缩小到一个组件时，将会更详细地讨论这一点。</p><p id="ae51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码(<code class="fe nn no np nq b">filesystem.go</code>):</p><pre class="km kn ko kp gt nr nq ns nt aw nu bi"><span id="4974" class="ky kz iq nq b gy nv nw l nx ny">package main</span><span id="d5aa" class="ky kz iq nq b gy nz nw l nx ny">import (<br/> "fmt"<br/>)</span><span id="8528" class="ky kz iq nq b gy nz nw l nx ny">// A global list of all files created and their respective names for<br/>// ease of lookup.<br/>var globalFileTable map[uint64]string</span><span id="4ee0" class="ky kz iq nq b gy nz nw l nx ny">// The data structure for each file.<br/>type file struct {<br/> name string         // The name of the file.<br/> pathFromRoot string // The absolute path of the file.<br/> fileHash uint64     // The unique file hash assigned to this file on creation.<br/> fileType string     // The type of the file.<br/> content byte        // The file's content in bytes.<br/> size uint64         // The size in bytes of the file.<br/>}</span><span id="a163" class="ky kz iq nq b gy nz nw l nx ny">//  The core struct that makes up the filesystem's file/directory<br/>type fileSystem struct {<br/> directory string         // The name of the current directory we're in.<br/> files []file             // The list of files in this directory.<br/> directories []fileSystem // The list of directories in this directory.<br/> prev *fileSystem         // a reference pointer to this directory's parent directory.<br/>}</span><span id="f888" class="ky kz iq nq b gy nz nw l nx ny">// Root node.<br/>var root *fileSystem</span><span id="1a2c" class="ky kz iq nq b gy nz nw l nx ny">// initFilesystem scans the current directory and builds the VFS from it.<br/>func initFilesystem() * fileSystem {<br/> // recursively grab all files and directories from this level downwards.<br/> fmt.Println("Welcome to the tiny virtual filesystem.")<br/> return root<br/>}</span><span id="d068" class="ky kz iq nq b gy nz nw l nx ny">// reloadFilesys Resets the VFS and scraps all changes made up to this point.<br/>// (basically like a rerun of initFilesystem())<br/>func (root * fileSystem) reloadFilesys() {<br/> fmt.Println("Refreshing...")<br/>}</span><span id="8d2a" class="ky kz iq nq b gy nz nw l nx ny">// tearDown gracefully ends the current session.<br/>func (root * fileSystem) tearDown() {<br/> fmt.Println("Teardown")<br/>}</span><span id="c4bd" class="ky kz iq nq b gy nz nw l nx ny">// saveState aves the state of the VFS at this time.<br/>func (root * fileSystem) saveState() {<br/> fmt.Println("Save the current state of the VFS")<br/>}</span></pre><p id="cb81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有占位符，用于存放初始化和拆卸代码，以及保存和刷新状态代码。在写这篇文章的时候还没有考虑保存和加载的系统，但是由于保存和加载可能对磁盘空间有很大的影响，它可能没有那么复杂。</p><h2 id="3a0b" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">原生目录(荣誉奖)</h2><p id="465d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">因此，它没有自己的代码，但它值得考虑与虚拟文件系统本身的关系。因为从本质上来说，我们的应用程序是与文件进行交互的，所以它绝不会对将要处理的原始文件做任何有潜在破坏性的事情，这一点很重要，所以必须非常注意文件系统部分。请注意，文件系统代码可能需要花费最多的时间来完成，并且可能需要最多的修订(如果有的话)。</p><h1 id="7067" class="lw kz iq bd la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm bi translated">结论——继续第2部分</h1><p id="c088" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这将是我们文件系统的总体布局。你的目录结构不一定是疯狂的；像这样的简单结构就足够了。</p><pre class="km kn ko kp gt nr nq ns nt aw nu bi"><span id="e130" class="ky kz iq nq b gy nv nw l nx ny">./src/<br/>    filesystem.go<br/>    user.go<br/>    lib.go<br/>    shell.go</span></pre><p id="f6ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有兴趣了解这些单独的结构此时是如何运行的，我将在GitHub上为我的代码编写单元测试，并添加测试每个文件及其功能的指令。这些会让你更好地理解执行是什么样子的。</p><p id="3e57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们的入门基础。接下来，我们将从处理用户对象以及它如何与shell交互开始。在进一步发布之前，我将花时间研究文件系统部分的实现细节。我想这会占用我们大部分时间。</p><p id="7da7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑:另外，我以后会坚持将“虚拟文件系统”简称为VFS；这句话我已经输入了很多次，现在大声说出来听起来很奇怪。</p><p id="e567" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次见。</p><p id="c7ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">项目回购:<a class="ae kx" href="https://github.com/AlysonBee/GoVirtualFilesystem" rel="noopener ugc nofollow" target="_blank">https://github.com/AlysonBee/GoVirtualFilesystem</a></p></div></div>    
</body>
</html>