<html>
<head>
<title>Hacking the Python syntax: Alternate lambda syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解Python语法:备用lambda语法</h1>
<blockquote>原文：<a href="https://itnext.io/hacking-the-python-syntax-alternate-lambda-syntax-c87c383dd1a3?source=collection_archive---------5-----------------------#2022-01-30">https://itnext.io/hacking-the-python-syntax-alternate-lambda-syntax-c87c383dd1a3?source=collection_archive---------5-----------------------#2022-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3be49c7ad5e04cef75d37fd8f99ba166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3j3Mos25Enb3FDsK8n2ew.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/s/photos/jenga?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jg" href="https://unsplash.com/@lastnameeaster?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> La-Rel Easter </a>拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="c38b" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">在60行代码中</h2></div><p id="75fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://remykarem.medium.com/hacking-the-python-syntax-part-0-introduction-9a1c054ec1e6" rel="noopener">简介</a> | <a class="ae jg" href="https://remykarem.medium.com/hacking-the-python-syntax-part-1-ternary-operator-bbcb04aa6ecb" rel="noopener">三元运算符</a> | <strong class="la jk">交替lambda语法</strong> |函数中无返回关键字(即将推出)|列表理解++(即将推出)</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="dbed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mb">变更日志:<br/>2022年12月31日—使用Medium的新代码块来突出显示语法</em></p><h1 id="6d43" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">目录</h1><ol class=""><li id="4fd9" class="mu mv jj la b lb mw le mx lh my ll mz lp na lt nb nc nd ne bi translated"><a class="ae jg" href="#64cd" rel="noopener ugc nofollow">匿名功能</a></li><li id="bed0" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated"><a class="ae jg" href="#7440" rel="noopener ugc nofollow">当前语法</a></li><li id="9e6e" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">其他人是怎么做的？</li><li id="fa2e" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated"><a class="ae jg" href="#606a" rel="noopener ugc nofollow">目标语法</a></li><li id="38d8" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated"><a class="ae jg" href="#0198" rel="noopener ugc nofollow">添加代币</a></li><li id="0e92" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated"><a class="ae jg" href="#f443" rel="noopener ugc nofollow">改变语法</a></li><li id="1145" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated"><a class="ae jg" href="#f88e" rel="noopener ugc nofollow">例题</a></li></ol><p id="809e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于环境设置，请阅读<em class="mb">简介</em>。完整的代码，看我的分叉<a class="ae jg" href="https://github.com/remykarem/cpython/tree/lambda-syntax" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="64cd" class="mc md jj bd me mf nk mh mi mj nl ml mm kp nm kq mo ks nn kt mq kv no kw ms mt bi translated">1.匿名函数</h1><p id="d692" class="pw-post-body-paragraph ky kz jj la b lb mw kk ld le mx kn lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">这是我的最爱(我私下希望Python在未来几年内会考虑改变这一点或类似的东西)！</p><p id="851d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个没有名字的函数，或者一个<a class="ae jg" href="https://en.wikipedia.org/wiki/Anonymous_function" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">匿名函数</strong> </a>，是一个在<a class="ae jg" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数编程</a>范例中普遍使用的构造，其中函数经常作为对象传递。</p><h1 id="7440" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">2.当前语法</h1><p id="5ac4" class="pw-post-body-paragraph ky kz jj la b lb mw kk ld le mx kn lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">在Python中，你写一个<a class="ae jg" href="https://docs.python.org/3/reference/expressions.html#lambda" rel="noopener ugc nofollow" target="_blank"><strong class="la jk">λ表达式</strong> </a>来创建一个匿名函数:</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="1790" class="ob md jj nx b be oc od l oe of">lambda x: x+1</span></pre><p id="b99d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个例子，我们使用匿名函数根据项目的长度对列表进行排序:</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="d92c" class="ob md jj nx b be oc od l oe of">&gt;&gt;&gt; items = ["applesss", "apple"]<br/>&gt;&gt;&gt; sorted(items, key=lambda x: len(x))<br/>["apple", "applesss"]</span></pre><p id="c35f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧，所以我的问题是为什么“lambda”这个词？感觉这个关键词不够直观。</p><p id="d9c4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个想法可能来自<a class="ae jg" href="https://en.wikipedia.org/wiki/Lambda_calculus" rel="noopener ugc nofollow" target="_blank">λ演算</a>，但这是一个深奥的概念(我最近才知道)。它也可能来自<a class="ae jg" href="https://www.gnu.org/software/emacs/manual/html_node/eintr/lambda.html" rel="noopener ugc nofollow" target="_blank">Lisp</a>——他们对匿名函数使用<code class="fe og oh oi nx b">lambda</code>关键字。</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="b30c" class="ob md jj nx b be oc od l oe of">(lambda (x) (1 + x))</span></pre><p id="6580" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么我们该怎么办呢？</p><h1 id="aaa1" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">3.其他人是怎么做的？</h1><p id="40b8" class="pw-post-body-paragraph ky kz jj la b lb mw kk ld le mx kn lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">使用Python定义参数加3的方式，</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="3090" class="ob md jj nx b be oc od l oe of">lambda x: x+3</span></pre><p id="f33d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看其他语言是如何做到这一点的(如果有不止一种选择，我将挑选出我认为更简洁的一种)。</p><p id="f62c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>(对于可以推断类型的<a class="ae jg" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#anonymous-functions" rel="noopener ugc nofollow" target="_blank">类型脚本</a>也是如此)</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="1422" class="ob md jj nx b be oc od l oe of">x =&gt; x+3<br/>(x) =&gt; x+3</span></pre><p id="b651" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener ugc nofollow" target="_blank"> Java 8 </a></p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="4df2" class="ob md jj nx b be oc od l oe of">(x) -&gt; x+3<br/>(x) -&gt; { x + 3}</span></pre><p id="9a90" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://kotlinlang.org/docs/lambdas.html#lambda-expressions-and-anonymous-functions" rel="noopener ugc nofollow" target="_blank">科特林</a></p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="86c9" class="ob md jj nx b be oc od l oe of">{ x -&gt; x+3 }</span></pre><p id="a8ca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://doc.rust-lang.org/rust-by-example/fn/closures.html" rel="noopener ugc nofollow" target="_blank">生锈</a>🦀</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="5317" class="ob md jj nx b be oc od l oe of">|x| x+3<br/>|x| -&gt; { x+3 }</span></pre><p id="f4b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">红宝石</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="0e9b" class="ob md jj nx b be oc od l oe of">{ |x| puts x+3 }</span></pre><p id="6817" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哈斯克尔</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="c338" class="ob md jj nx b be oc od l oe of">\x -&gt; x + 3</span></pre><p id="1b4e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://en.cppreference.com/w/cpp/language/lambda" rel="noopener ugc nofollow" target="_blank"> C++11 </a></p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="594e" class="ob md jj nx b be oc od l oe of">[](int value) { return x + 3; }</span></pre><p id="fd8e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">雨燕</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="dbd6" class="ob md jj nx b be oc od l oe of">{ $0 + 3}</span></pre><p id="86ca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://elixir-lang.org/crash-course.html#partials-and-function-captures-in-elixir" rel="noopener ugc nofollow" target="_blank">仙丹</a></p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="d942" class="ob md jj nx b be oc od l oe of">&amp;(&amp;1 + 3)</span></pre><p id="8d79" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://docs.scala-lang.org/overviews/scala-book/anonymous-functions.html" rel="noopener ugc nofollow" target="_blank"> Scala </a></p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="1b38" class="ob md jj nx b be oc od l oe of">i =&gt; i + 3<br/>_ + 3  // Are you kidding me? I love this!</span></pre><p id="ce1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Clojure(以下是<a class="ae jg" href="https://en.wikipedia.org/wiki/Polish_notation" rel="noopener ugc nofollow" target="_blank">前缀标注</a>；假设我们想要一个<a class="ae jg" href="https://en.wikipedia.org/wiki/Infix_notation" rel="noopener ugc nofollow" target="_blank">中缀</a>版本，它看起来像<code class="fe og oh oi nx b">#(% + 3)</code>。)</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="f05d" class="ob md jj nx b be oc od l oe of">#(+ % 3) </span></pre><p id="9adc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于这些语言，以下是我观察到的一些特征(并非相互排斥):</p><ul class=""><li id="657b" class="mu mv jj la b lb lc le lf lh oj ll ok lp ol lt om nc nd ne bi translated">使用<code class="fe og oh oi nx b">&amp;</code>、<code class="fe og oh oi nx b">#</code>、<code class="fe og oh oi nx b">\</code>或<code class="fe og oh oi nx b">{ ... }</code>的匿名函数的明确指示。在Python中，这是<code class="fe og oh oi nx b">lambda</code>。</li><li id="e86d" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt om nc nd ne bi translated">使用类似于<code class="fe og oh oi nx b">-&gt;</code>或<code class="fe og oh oi nx b">=&gt;</code>的分隔符在参数和正文之间使用“分隔符”,或者按照类似于<code class="fe og oh oi nx b">|x|</code>或<code class="fe og oh oi nx b">(x)</code>的语法将参数和正文分组，并将<code class="fe og oh oi nx b">{ ... }</code>作为正文。</li><li id="ff5e" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt om nc nd ne bi translated">对参数或位置参数的引用，如<code class="fe og oh oi nx b">_</code>、<code class="fe og oh oi nx b">%1</code>或<code class="fe og oh oi nx b">$0</code>。</li><li id="8ff8" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt om nc nd ne bi translated">表示返回值的关键字，如<code class="fe og oh oi nx b">return</code>或<code class="fe og oh oi nx b">puts</code>。</li></ul><h1 id="606a" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">4.目标语法</h1><p id="5455" class="pw-post-body-paragraph ky kz jj la b lb mw kk ld le mx kn lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">今天，我们将删除关键字，并用另一种语法替换它😈。我们需要一些能立即显示起点<code class="fe og oh oi nx b">x</code>和结果<code class="fe og oh oi nx b">x+1</code>的东西，并使用一些符号来建立这种关系。</p><p id="3f98" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我在想…</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="60e6" class="ob md jj nx b be oc od l oe of">|x| -&gt; x+1</span></pre><ol class=""><li id="6222" class="mu mv jj la b lb lc le lf lh oj ll ok lp ol lt nb nc nd ne bi translated">删除匿名函数的指示(<code class="fe og oh oi nx b">lambda</code>)</li><li id="ee06" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">用<code class="fe og oh oi nx b">|...|</code>和<code class="fe og oh oi nx b">-&gt;</code>改变参数和主体之间的“分隔线”,只是因为它更常见。</li></ol><p id="5f52" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是一些其他注意事项:</p><ul class=""><li id="49d2" class="mu mv jj la b lb lc le lf lh oj ll ok lp ol lt om nc nd ne bi translated">管道操作符<code class="fe og oh oi nx b">|</code>目前只被用作二元操作符(需要LHS和RHS参数),所以使用<code class="fe og oh oi nx b">|...|</code>应该对当前规则没有什么干扰</li><li id="2363" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt om nc nd ne bi translated"><code class="fe og oh oi nx b">=&gt;</code>第一次对我来说失败了，有点发毛，所以<code class="fe og oh oi nx b">-&gt;</code>就是了，虽然目前是用来注释<a class="ae jg" href="https://docs.python.org/3/library/typing.html" rel="noopener ugc nofollow" target="_blank">函数返回类型</a>。</li><li id="7599" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt om nc nd ne bi translated">增强的按位or <code class="fe og oh oi nx b">|=</code>会有问题</li></ul><h1 id="0198" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">5.添加令牌</h1><p id="3406" class="pw-post-body-paragraph ky kz jj la b lb mw kk ld le mx kn lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">不需要新的令牌。</p><ul class=""><li id="002b" class="mu mv jj la b lb lc le lf lh oj ll ok lp ol lt om nc nd ne bi translated"><code class="fe og oh oi nx b">|</code>令牌值(令牌名<code class="fe og oh oi nx b">VBAR</code>)已经用于<a class="ae jg" href="https://docs.python.org/3/library/operator.html#mapping-operators-to-functions" rel="noopener ugc nofollow" target="_blank">位或</a>。</li><li id="79b0" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt om nc nd ne bi translated"><code class="fe og oh oi nx b">-&gt;</code>令牌值(令牌名<code class="fe og oh oi nx b">RARROW</code>)也已经被用于<a class="ae jg" href="https://docs.python.org/3/library/typing.html#module-typing" rel="noopener ugc nofollow" target="_blank">注释函数返回类型</a>。</li></ul><h1 id="f443" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">6.改变语法</h1><p id="10d3" class="pw-post-body-paragraph ky kz jj la b lb mw kk ld le mx kn lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">改变这种语法稍微复杂一些。所以去喝杯咖啡吧！</p><h2 id="512c" class="on md jj bd me oo op dn mi oq or dp mm lh os ot mo ll ou ov mq lp ow ox ms oy bi translated">6.1 lambdef</h2><p id="4eab" class="pw-post-body-paragraph ky kz jj la b lb mw kk ld le mx kn lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">λ定义定义为<code class="fe og oh oi nx b">lambdef</code>。让我们在第5–7行创建lambda的新定义:</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="d613" class="ob md jj nx b be oc od l oe of">lambdef[expr_ty]:<br/>    | 'lambda' a=[lambda_params] ':' b=expression {<br/>        _PyAST_Lambda(<br/>            (a) ? a : CHECK(arguments_ty, _PyPegen_empty_arguments(p)), b, EXTRA) }<br/>    | '|' a=[lambda_params_new] '|' '-&gt;' b=expression {<br/>        _PyAST_Lambda(<br/>            (a) ? a : CHECK(arguments_ty, _PyPegen_empty_arguments(p)), b, EXTRA) }</span></pre><p id="68f1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它遵循以下伪语法:</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="4b9b" class="ob md jj nx b be oc od l oz of">| &lt;lambda_params_new&gt; | -&gt; &lt;expression&gt;</span></pre><p id="6dfa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现有的<code class="fe og oh oi nx b">lambda_params</code>定义及其嵌套定义看起来非常复杂。这就是为什么我们创造了一个新的定义叫做<code class="fe og oh oi nx b">lambda_params_new</code>。</p><h2 id="8a74" class="on md jj bd me oo op dn mi oq or dp mm lh os ot mo ll ou ov mq lp ow ox ms oy bi translated">_ params _ new</h2><p id="5b6c" class="pw-post-body-paragraph ky kz jj la b lb mw kk ld le mx kn lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">lambda参数的现有规则(<code class="fe og oh oi nx b">lambda_params</code>)进一步定义了lambda函数的结构，如斜线、星号、默认关键字等。</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="2536" class="ob md jj nx b be oc od l oe of">lambda_params[arguments_ty]:<br/>    | invalid_lambda_parameters<br/>    | lambda_parameters<br/><br/># lambda_parameters etc. duplicates parameters but without annotations<br/># or type comments, and if there's no comma after a parameter, we expect<br/># a colon, not a close parenthesis.  (For more, see parameters above.)<br/>#<br/>lambda_parameters[arguments_ty]:<br/>    | a=lambda_slash_no_default b[asdl_arg_seq*]=lambda_param_no_default* c=lambda_param_with_default* d=[lambda_star_etc] {<br/>        _PyPegen_make_arguments(p, a, NULL, b, c, d) }<br/>    | a=lambda_slash_with_default b=lambda_param_with_default* c=[lambda_star_etc] {<br/>        _PyPegen_make_arguments(p, NULL, a, NULL, b, c) }<br/>    | a[asdl_arg_seq*]=lambda_param_no_default+ b=lambda_param_with_default* c=[lambda_star_etc] {<br/>        _PyPegen_make_arguments(p, NULL, NULL, a, b, c) }<br/>    | a=lambda_param_with_default+ b=[lambda_star_etc] { _PyPegen_make_arguments(p, NULL, NULL, NULL, a, b)}<br/>    | a=lambda_star_etc { _PyPegen_make_arguments(p, NULL, NULL, NULL, NULL, a) }<br/><br/>lambda_slash_no_default[asdl_arg_seq*]:<br/>    | a[asdl_arg_seq*]=lambda_param_no_default+ '/' ',' { a }<br/>    | a[asdl_arg_seq*]=lambda_param_no_default+ '/' &amp;':' { a }<br/><br/>lambda_slash_with_default[SlashWithDefault*]:<br/>    | a=lambda_param_no_default* b=lambda_param_with_default+ '/' ',' { _PyPegen_slash_with_default(p, (asdl_arg_seq *)a, b) }<br/>    | a=lambda_param_no_default* b=lambda_param_with_default+ '/' &amp;':' { _PyPegen_slash_with_default(p, (asdl_arg_seq *)a, b) }<br/><br/>lambda_star_etc[StarEtc*]:<br/>    | '*' a=lambda_param_no_default b=lambda_param_maybe_default* c=[lambda_kwds] {<br/>        _PyPegen_star_etc(p, a, b, c) }<br/>    | '*' ',' b=lambda_param_maybe_default+ c=[lambda_kwds] {<br/>        _PyPegen_star_etc(p, NULL, b, c) }<br/>    | a=lambda_kwds { _PyPegen_star_etc(p, NULL, NULL, a) }<br/>    | invalid_lambda_star_etc<br/><br/>lambda_kwds[arg_ty]: '**' a=lambda_param_no_default { a }<br/><br/>lambda_param_no_default[arg_ty]:<br/>    | a=lambda_param ',' { a }<br/>    | a=lambda_param &amp;':' { a }<br/>lambda_param_with_default[NameDefaultPair*]:<br/>    | a=lambda_param c=default ',' { _PyPegen_name_default_pair(p, a, c, NULL) }<br/>    | a=lambda_param c=default &amp;':' { _PyPegen_name_default_pair(p, a, c, NULL) }<br/>lambda_param_maybe_default[NameDefaultPair*]:<br/>    | a=lambda_param c=default? ',' { _PyPegen_name_default_pair(p, a, c, NULL) }<br/>    | a=lambda_param c=default? &amp;':' { _PyPegen_name_default_pair(p, a, c, NULL) }<br/>lambda_param[arg_ty]: a=NAME { _PyAST_arg(a-&gt;v.Name.id, NULL, NULL, EXTRA) }</span></pre><p id="4608" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有很多逻辑。为了不弄乱现有的逻辑，我们将创建上面的副本，将<code class="fe og oh oi nx b">_new</code>附加到所有的规则上。然后，我们在这些站点用新语法替换旧语法(注意<code class="fe og oh oi nx b">'|'</code>):</p><ul class=""><li id="21b7" class="mu mv jj la b lb lc le lf lh oj ll ok lp ol lt om nc nd ne bi translated"><code class="fe og oh oi nx b">lambda_slash_no_default_new</code></li><li id="0ad4" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt om nc nd ne bi translated"><code class="fe og oh oi nx b">lambda_slash_with_default_new</code></li><li id="bfaf" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt om nc nd ne bi translated"><code class="fe og oh oi nx b">lambda_param_no_default_new</code></li><li id="7430" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt om nc nd ne bi translated"><code class="fe og oh oi nx b">lambda_param_with_default_new</code></li><li id="097a" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt om nc nd ne bi translated"><code class="fe og oh oi nx b">lambda_param_maybe_default_new</code></li></ul><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="d0b5" class="ob md jj nx b be oc od l oe of"># Lambda functions new syntax<br/># ---------------------------<br/><br/>lambda_params_new[arguments_ty]:<br/>    | invalid_lambda_parameters_new<br/>    | lambda_parameters_new<br/><br/># lambda_parameters etc. duplicates parameters but without annotations<br/># or type comments, and if there's no comma after a parameter, we expect<br/># a colon, not a close parenthesis.  (For more, see parameters above.)<br/>#<br/>lambda_parameters_new[arguments_ty]:<br/>    | a=lambda_slash_no_default_new b[asdl_arg_seq*]=lambda_param_no_default_new* c=lambda_param_with_default_new* d=[lambda_star_etc_new] {<br/>        _PyPegen_make_arguments(p, a, NULL, b, c, d) }<br/>    | a=lambda_slash_with_default_new b=lambda_param_with_default_new* c=[lambda_star_etc_new] {<br/>        _PyPegen_make_arguments(p, NULL, a, NULL, b, c) }<br/>    | a[asdl_arg_seq*]=lambda_param_no_default_new+ b=lambda_param_with_default_new* c=[lambda_star_etc_new] {<br/>        _PyPegen_make_arguments(p, NULL, NULL, a, b, c) }<br/>    | a=lambda_param_with_default_new+ b=[lambda_star_etc_new] { _PyPegen_make_arguments(p, NULL, NULL, NULL, a, b)}<br/>    | a=lambda_star_etc_new { _PyPegen_make_arguments(p, NULL, NULL, NULL, NULL, a) }<br/><br/>lambda_slash_no_default_new[asdl_arg_seq*]:<br/>    | a[asdl_arg_seq*]=lambda_param_no_default_new+ '/' ',' { a }<br/>    | a[asdl_arg_seq*]=lambda_param_no_default_new+ '/' &amp;'|' { a }<br/><br/>lambda_slash_with_default_new[SlashWithDefault*]:<br/>    | a=lambda_param_no_default_new* b=lambda_param_with_default_new+ '/' ',' { _PyPegen_slash_with_default(p, (asdl_arg_seq *)a, b) }<br/>    | a=lambda_param_no_default_new* b=lambda_param_with_default_new+ '/' &amp;'|' { _PyPegen_slash_with_default(p, (asdl_arg_seq *)a, b) }<br/><br/>lambda_star_etc_new[StarEtc*]:<br/>    | '*' a=lambda_param_no_default_new b=lambda_param_maybe_default_new* c=[lambda_kwds_new] {<br/>        _PyPegen_star_etc(p, a, b, c) }<br/>    | '*' ',' b=lambda_param_maybe_default_new+ c=[lambda_kwds_new] {<br/>        _PyPegen_star_etc(p, NULL, b, c) }<br/>    | a=lambda_kwds_new { _PyPegen_star_etc(p, NULL, NULL, a) }<br/>    | invalid_lambda_star_etc_new<br/><br/>lambda_kwds_new[arg_ty]: '**' a=lambda_param_no_default_new { a }<br/><br/>lambda_param_no_default_new[arg_ty]:<br/>    | a=lambda_param_new ',' { a }<br/>    | a=lambda_param_new &amp;'|' { a }<br/>lambda_param_with_default_new[NameDefaultPair*]:<br/>    | a=lambda_param_new c=default ',' { _PyPegen_name_default_pair(p, a, c, NULL) }<br/>    | a=lambda_param_new c=default &amp;'|' { _PyPegen_name_default_pair(p, a, c, NULL) }<br/>lambda_param_maybe_default_new[NameDefaultPair*]:<br/>    | a=lambda_param_new c=default? ',' { _PyPegen_name_default_pair(p, a, c, NULL) }<br/>    | a=lambda_param_new c=default? &amp;'|' { _PyPegen_name_default_pair(p, a, c, NULL) }<br/>lambda_param_new[arg_ty]: a=NAME { _PyAST_arg(a-&gt;v.Name.id, NULL, NULL, EXTRA) }</span></pre><p id="eaa0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还没有完全完成，因为我们还没有创建一些定义，即<code class="fe og oh oi nx b">invalid_lambda_</code>定义。</p><h2 id="af99" class="on md jj bd me oo op dn mi oq or dp mm lh os ot mo ll ou ov mq lp ow ox ms oy bi translated">6.3无效的_lambda_*</h2><p id="d7b7" class="pw-post-body-paragraph ky kz jj la b lb mw kk ld le mx kn lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">如果遇到不正确的语法，我们希望相应地引发错误。</p><p id="f22c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">快速搜索<code class="fe og oh oi nx b">invalid_lambda_</code>可以看到三个现有的规则:<code class="fe og oh oi nx b">invalid_lambda_parameters</code>、<code class="fe og oh oi nx b">invalid_lambda_parameters_helper</code>和<code class="fe og oh oi nx b">invalid_lambda_star_etc</code>。</p><p id="95b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，让我们创建一个副本，进行适当的编辑以适应新的语法，并将<code class="fe og oh oi nx b">_new</code>添加到规则名称中:</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="2589" class="ob md jj nx b be oc od l oe of">invalid_lambda_parameters_new:<br/>    | lambda_param_no_default_new* invalid_lambda_parameters_helper_new a=lambda_param_no_default_new {<br/>        RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "non-default argument follows default argument") }<br/><br/>invalid_lambda_parameters_helper_new:<br/>    | a=lambda_slash_with_default_new { _PyPegen_singleton_seq(p, a) }<br/>    | lambda_param_with_default_new+<br/><br/>invalid_lambda_star_etc_new:<br/>    | '*' ('|' | ',' ('|' | '**')) { RAISE_SYNTAX_ERROR("named arguments must follow bare *") }</span></pre><p id="8d0d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而且…我们应该准备好了！重新生成相关文件并运行解释器:</p><pre class="ns nt nu nv gt nw nx pa pb aw pc bi"><span id="9194" class="on md jj nx b gy pd pe l oz of"><strong class="nx jk">make</strong> regen-pegen &amp;&amp; <strong class="nx jk">make</strong> -j8 -s &amp;&amp; <strong class="nx jk">./python.exe</strong></span></pre><h1 id="f88e" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">7.例子</h1><p id="9ad7" class="pw-post-body-paragraph ky kz jj la b lb mw kk ld le mx kn lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">只有一个参数的匿名函数:</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="a380" class="ob md jj nx b be oc od l oe of">&gt;&gt;&gt; identity = |x| -&gt; x<br/>&gt;&gt;&gt; identity("hello")<br/>"hello'</span></pre><p id="a6d6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">具有多个参数的匿名函数:</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="ba2a" class="ob md jj nx b be oc od l oe of">&gt;&gt;&gt; product = |a, b, c| -&gt; a*b*c<br/>&gt;&gt;&gt; product(1, 8, 9)<br/>72</span></pre><p id="a157" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">没有参数的匿名函数:</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="3505" class="ob md jj nx b be oc od l oe of">&gt;&gt;&gt; display_hello = || -&gt; print("hello")<br/>&gt;&gt;&gt; display_hello()<br/>'hello'</span></pre><p id="22ef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">带有默认参数的匿名函数:</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="9b27" class="ob md jj nx b be oc od l oe of">&gt;&gt;&gt; exp = |x, power=2| -&gt; x**power<br/>&gt;&gt;&gt; exp(10)<br/>100<br/>&gt;&gt;&gt; exp(3, 3)<br/>27</span></pre><p id="9dd9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">匿名函数，用于列表排序:</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="582d" class="ob md jj nx b be oc od l oe of">&gt;&gt;&gt; items = ["applesss", "apple"]<br/><br/>&gt;&gt;&gt; sorted(items, key=lambda x: len(x))<br/>["apple", "applesss"]<br/><br/>&gt;&gt;&gt; sorted(items, key=|x|-&gt;len(x))<br/>["apple", "applesss"]</span></pre><p id="b407" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个匿名函数，用在Spark这样的转换管道中(见<a class="ae jg" href="https://spark.apache.org/examples.html" rel="noopener ugc nofollow" target="_blank">https://spark.apache.org/examples.html</a>):</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="a129" class="ob md jj nx b be oc od l oe of">&gt;&gt;&gt; text_file = sc.textFile("hdfs://...")<br/>&gt;&gt;&gt; counts = (<br/>...     text_file<br/>...     .flatMap(|line| -&gt; line.split(" "))<br/>...     .map(|word| -&gt; (word, 1))<br/>...     .reduceByKey(|a, b| -&gt; a + b)<br/>... )</span></pre><p id="6a74" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模糊一行程序中的匿名函数，改编自Python docs<a class="ae jg" href="https://docs.python.org/3/faq/programming.html#is-it-possible-to-write-obfuscated-one-liners-in-python" rel="noopener ugc nofollow" target="_blank">https://docs . Python . org/3/FAQ/programming . html # is-it-possible-to-write-obfuscated-one-liners-in-Python</a>。这个程序生成前十个斐波那契数。</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="f89b" class="ob md jj nx b be oc od l oe of">&gt;&gt;&gt; list(map(|x,f=x,f|-&gt;(f(x-1,f)+f(x-2,f)) if x&gt;1 else 1|-&gt;f(x,f),range(10)))<br/>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></pre><p id="6d2d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用第1部分中的三元运算符，我们可以使上面的内容更加简洁:</p><pre class="ns nt nu nv gt nw nx ny bn nz oa bi"><span id="4639" class="ob md jj nx b be oc od l oe of">&gt;&gt;&gt; list(map(|x,f=|x,f|-&gt;x&gt;1?f(x-1,f)+f(x-2,f):1|-&gt;f(x,f),range(10)))<br/>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="1257" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">暂时就这样吧！谢谢你让我和你分享我的黑客之旅。敬请关注函数中的<strong class="la jk">不返回关键字和<strong class="la jk">列表理解++ </strong>！</strong></p><p id="b591" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有点迷茫，你可能想先看看<a class="ae jg" href="https://remykarem.medium.com/hacking-the-python-syntax-part-1-ternary-operator-bbcb04aa6ecb" rel="noopener">破解Python语法:三元运算符</a>。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="cd1e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我发表关于人工智能、机器学习、编程语言和生产力的文章。</p><p id="dc0c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mb">如果您喜欢阅读更多关于编程语言的内容，您可以通过我的推荐链接</em> <a class="ae jg" href="https://remykarem.medium.com/subscribe" rel="noopener"> <em class="mb">订阅</em> </a> <em class="mb">以接收我发布的更新，或者</em> <a class="ae jg" href="https://remykarem.medium.com/membership" rel="noopener"> <em class="mb">注册</em> </a> <em class="mb">！请注意，您的会员费的一部分将作为介绍费分摊给我。</em></p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="5d85" class="mc md jj bd me mf nk mh mi mj nl ml mm kp nm kq mo ks nn kt mq kv no kw ms mt bi translated">参考</h1><ul class=""><li id="d36f" class="mu mv jj la b lb mw le mx lh my ll mz lp na lt om nc nd ne bi translated">改变CPython的语法(<a class="ae jg" href="https://devguide.python.org/grammar/" rel="noopener ugc nofollow" target="_blank">devguide.python.org</a>)</li><li id="446a" class="mu mv jj la b lb nf le ng lh nh ll ni lp nj lt om nc nd ne bi translated">CPython解析器指南(<a class="ae jg" href="https://devguide.python.org/parser/" rel="noopener ugc nofollow" target="_blank">devguide.python.org</a>)</li></ul></div></div>    
</body>
</html>