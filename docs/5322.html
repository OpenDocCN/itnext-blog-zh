<html>
<head>
<title>React, Notistack, and Material-UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应、通知堆栈和材质-用户界面</h1>
<blockquote>原文：<a href="https://itnext.io/react-notistack-and-material-ui-fcacc16a47f?source=collection_archive---------2-----------------------#2021-02-09">https://itnext.io/react-notistack-and-material-ui-fcacc16a47f?source=collection_archive---------2-----------------------#2021-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0f05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/iamhosseindhv/notistack" rel="noopener ugc nofollow" target="_blank"> Notistack </a>是处理堆叠通知的一个很好的队列。它有许多优秀的配置功能，在整个应用程序中一直是我们的一个很好的工具。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/5533160b7e470bc77bfb121266d0733f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SH-Q-_jqDK09uFHIOY26bg.png"/></div></div></figure><p id="24ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我与同事分享过几次的一件事是，我们如何设置它，以便可以从任何地方发出通知，而不必使用大量的导入或机械来实现它。</p><p id="418e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您使用React和Material，这就是您所需要的:</p><p id="d747" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">App.tsx:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="d2c3" class="ld le iq kz b gy lf lg l lh li">...<br/>  return (<br/>    &lt;SnackbarProvider<br/>      anchorOrigin={{<br/>        vertical: 'bottom',<br/>        horizontal: 'left'<br/>      }}<br/>      autoHideDuration={5000}<br/>    &gt;<br/>  &lt;&gt;<br/>    &lt;SnackbarUtilsConfigurator /&gt;<br/>    &lt;Suspense fallback={&lt;div id={'app'} /&gt;}&gt;<br/>      &lt;Routes /&gt;<br/>...</span></pre><p id="0864" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从文档来看，这里没有太大的区别。将Snackbar提供程序添加到App.tsx中。但是，如果我们必须在notistack的上下文中到处创建依赖关系，这有什么好处呢？如果我们想用一个不同的库来改变它，并保持相同或相似的API来发出消息，我们该如何封装它呢？</p><p id="b952" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的是，它在悬念和路线组件之外，因为我们不想在发出路线更改或通知时进行重新渲染。如果你发出一个信息，注意到一个路线变化，或者反复的路线变化，这就是为什么！</p><p id="7f2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意SnackbarUtilsConfigurator组件吗？这就是我们为Notistack创建Snack.tsx的地方:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="bea3" class="ld le iq kz b gy lf lg l lh li">import { useSnackbar, OptionsObject, WithSnackbarProps } from 'notistack';<br/>import React from 'react';<br/>import { LinearProgressEstimator } from 'custom-components';<br/><br/>export enum VariantType {<br/>  <em class="lj">default </em>= 'default',<br/>  <em class="lj">error </em>= 'error',<br/>  <em class="lj">success </em>= 'success',<br/>  <em class="lj">warning </em>= 'warning',<br/>  <em class="lj">info </em>= 'info'<br/>}<br/><br/>interface SnackProps {<br/>  setUseSnackbarRef: (showSnackbar: WithSnackbarProps) =&gt; void;<br/>}<br/><br/>const InnerSnackbarUtilsConfigurator: React.FC&lt;SnackProps&gt; = (props) =&gt; {<br/>  props.setUseSnackbarRef(useSnackbar());<br/>  return null;<br/>};<br/><br/>let useSnackbarRef: WithSnackbarProps;<br/>const setUseSnackbarRef = (useSnackbarRefProp: WithSnackbarProps) =&gt; {<br/>  useSnackbarRef = useSnackbarRefProp;<br/>};<br/><br/>export const SnackbarUtilsConfigurator = (props: {<br/>  children?: React.ReactNode;<br/>}) =&gt; {<br/>  return (<br/>    &lt;InnerSnackbarUtilsConfigurator setUseSnackbarRef={setUseSnackbarRef}&gt;<br/>      {props.children}<br/>    &lt;/InnerSnackbarUtilsConfigurator&gt;<br/>  );<br/>};<br/><br/>//sets a default length for all Snack messages<br/>const defaultSnackMessageLength = 1000;<br/><br/>const trimMessage = (<br/>  msg: string,<br/>  length: number = defaultSnackMessageLength<br/>) =&gt; {<br/>  return msg.substring(0, length);<br/>};<br/><br/>export default {<br/>  success(msg: string, options: OptionsObject = {}) {<br/>    this.toast(trimMessage(msg), { ...options, variant: VariantType.<em class="lj">success </em>});<br/>  },<br/>  warning(msg: string, options: OptionsObject = {}) {<br/>    this.toast(trimMessage(msg), { ...options, variant: VariantType.<em class="lj">warning </em>});<br/>  },<br/>  info(msg: string, options: OptionsObject = {}) {<br/>    this.toast(trimMessage(msg), { ...options, variant: VariantType.<em class="lj">info </em>});<br/>  },<br/>  error(msg: string, options: OptionsObject = {}) {<br/>    this.toast(trimMessage(msg), { ...options, variant: VariantType.<em class="lj">error </em>});<br/>  },<br/>  toast(msg: string, options: OptionsObject = {}) {<br/>    useSnackbarRef.enqueueSnackbar(msg, options);<br/>  },<br/>  loading(msg: string, options: OptionsObject) {<br/>    this.toast(trimMessage(msg), {<br/>      ...options,<br/>      variant: 'info',<br/>      persist: true,<br/>      content: (id: number, _message: string) =&gt; {<br/>        return (<br/>          &lt;div key={id} style={{ width: '100%' }}&gt;<br/>            {/* Should take about 4 min to get to 100% */}<br/>            &lt;LinearProgressEstimator velocity={0.4} /&gt;<br/>          &lt;/div&gt;<br/>        );<br/>      }<br/>    });<br/>  }<br/>};</span></pre><p id="31a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些，我们就可以导入组件并在应用程序中的任何地方调用它。组件只是简单地导出我们需要使用的方法，而<code class="fe lk ll lm kz b">Snack.loading</code>组件调用展示了定制内容仍然是可能的。它还可以接受覆盖作为第二个参数，这些选项与我们使用的API相同。总的来说，我们的目标是将这些参数用作边缘情况参数。</p><p id="f9f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读，并祝您好运堆叠这些通知！</p></div></div>    
</body>
</html>