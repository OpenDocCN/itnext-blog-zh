<html>
<head>
<title>Optimizing Kafka Cluster Deployments in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Kubernetes中的Kafka集群部署</h1>
<blockquote>原文：<a href="https://itnext.io/optimizing-kafka-cluster-deployments-in-kubernetes-ceda3f95c157?source=collection_archive---------3-----------------------#2020-04-20">https://itnext.io/optimizing-kafka-cluster-deployments-in-kubernetes-ceda3f95c157?source=collection_archive---------3-----------------------#2020-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d4eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们，在<a class="ae kl" href="https://axual.com/" rel="noopener ugc nofollow" target="_blank"> Axual </a>，以SaaS服务(Axual Cloud)的形式为银行和能源等各种领域的企业运行大容量、任务关键型Apache Kafka集群而自豪。为了花更少的时间管理基础设施，花更多的时间为我们的客户构建更酷的新功能，我们决定将我们的堆栈转移到Kubernetes。本文解释了如果您有合适的工具和信息，在Kubernetes中运行Apache Kafka并不困难。</p><p id="b15d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去的几年里，Kubernetes的受欢迎程度大幅上升，正如谷歌趋势图所示。不仅仅是创业公司和小公司，就连企业现在也在慢慢向Kubernetes或其企业版转移。这种增长很大程度上归功于Docker的容器化和微服务的流行。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/1b0a8a496b7893bd173f7a841ac1a798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g7-lczpusfI3rOEE"/></div></div></figure><p id="655f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最基本的，Kubernetes是一个调度器。它非常擅长以最优的方式调度容器，以允许有效地使用VM资源。Kubernetes无疑已经证明了自己是无状态应用程序的首选编制者。采用途径也已确立:</p><ol class=""><li id="273f" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">编译和构建工件。</li><li id="459a" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">根据12因素建议进行更改。</li><li id="8deb" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">用Docker把它包在一个容器里</li><li id="3ca5" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">让Kubernetes编排和安排您的容器。</li></ol><p id="2b4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是当涉及到有状态应用程序时，情况就大不相同了。</p><h1 id="7e78" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">有状态应用程序</h1><p id="0eee" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">如果您的应用程序不仅仅是一个web应用程序，那么您可能必须处理运行时状态。然而，应用程序什么时候变成有状态的呢？问自己这样一个问题:我能用另一个实例替换我的应用程序的一个实例吗？我能否针对应用程序的多个副本对请求进行负载平衡，而不会出错？在回答“是”之前，请仔细考虑您的应用程序在内存或磁盘上存储了什么。数据在运行时会改变吗？如果这些数据在被另一个实例替换时丢失，您的应用程序会崩溃吗？如果是这样，您就有了一个有状态的应用程序。</p><p id="92ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了正确编排有状态应用程序，Kubernetes在2016年末的1.5版本中提出了一个新的资源定义<strong class="jp ir"> StatefulSet </strong>(之前称为PetSet)。如果使用正确，StatefulSet可以用来在Kubernetes中运行有状态的应用程序。在本帖中，我们将尝试理解在Kubernetes中运行Apache Kafka(一个有状态的应用程序)需要什么。</p><h1 id="6659" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Apache Kafka作为有状态应用程序</h1><p id="cbee" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">Apache Kafka是一个实时流解决方案，是一个复杂的有状态应用程序。它有</p><ul class=""><li id="0d05" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk mp le lf lg bi translated">有身份的经纪人。更换经纪人不像更换pod那么简单。</li><li id="f9e3" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk mp le lf lg bi translated">对ZooKeeper的依赖——另一个支持Kafka分布式行为的有状态应用。</li><li id="6491" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk mp le lf lg bi translated">持久存储。由于复制，可能会丢失这些数据并进行恢复，但不应将其视为标准操作，尤其是在处理大量数据时。</li></ul><p id="712a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你正在考虑2020年在Kubernetes运行Apache Kafka，那就不需要自己设置了！有像Strimzi这样的可用选项。让我们来看看Strimzi Kafka Operator是如何让在Kubernetes中运行Kafka变得简单的。</p><h1 id="f449" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Strimzi算子</h1><p id="15d5" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">Strimzi是Kubernetes部署Kafka集群的操作员。它定义了一个名为“Kafka”的自定义资源定义(CRD ),代表了ZooKeeper和Kafka Cluster的组合。Kafka在Kubernetes部署的一个非常简单的例子如下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mq"><img src="../Images/03121d95ef334d82329bbca4938d172e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5IuGmwn6nTumekCj"/></div></div></figure><p id="418b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述配置将设置一个3节点ZooKeeper集群、3 broker Kafka集群以及一个100Gi持久性磁盘。这有效地转化为Kafka和ZooKeeper的StatefulSets，headless服务能够直接访问各个代理(而不是负载平衡)。</p><h1 id="4448" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">生效第2天操作</h1><p id="c50a" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">如您所见，在Kubernetes中部署Kafka集群非常容易。但是，当需要在Kafka集群上进行升级和维护时，如何保证稳定性和弹性呢？</p><p id="deb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes提供了许多资源，可以用来以更灵活的方式部署任何应用程序。让我们看看Strimzi是如何利用它们的。</p><h1 id="3775" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Pod中断预算</h1><p id="8f1a" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">任何被视为关键且不能接受停机(计划内或其他)的应用程序都必须定义Pod中断预算(PDB)。PDB告诉Kubernetes这个应用程序允许中断多少个pod。当Kubernetes集群管理员执行节点清空(kubectl drain)之类的维护操作时，该操作将考虑所有已配置的pdb，并且仅在中断预算允许的情况下移除pod。</p><p id="004e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Strimzi为ZooKeeper和Kafka各添加了两个pdb。让我们来看看卡夫卡式的PDB:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mq"><img src="../Images/7f7069a7bf99140c27dadfc21f272ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*36xrJSyremlVQzdH"/></div></div></figure><p id="185f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的PDB指出，在卡夫卡的所有代理人中，只有一个在任何给定的时间是不可用的。因此，如果您在3个不同的节点上有3个Kafka brokers，任何消耗1个以上节点的尝试都将被阻止，因为这违背了定义的PDB。对于大型Kafka集群，这可以定制为更高的值。</p><h1 id="992e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">网络策略</h1><p id="a461" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">网络策略可用于描述规则，这些规则确定哪些应用程序被允许在更高的抽象级别上连接到其他应用程序。Strimzi为ZooKeeper(只能由Kafka访问)和Kafka(不同的实体可以访问不同的侦听器端口)定义了网络策略。</p><p id="8be2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是Strimzi为Kafka定义的默认网络策略:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mq"><img src="../Images/2e46ee4c6abbd2ea22e9157ec66d6b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i0U-xZ_pCnA95iNw"/></div></div></figure><p id="52a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复制端口9091只能由Strimzi中定义的其他Kafka代理和操作员访问，以执行管理任务。纯文本端口9093和TLS端口9094不限于任何应用程序。</p><p id="2679" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意Kubernetes只提供了一个网络策略接口。实现工作留给了集群的管理员。例如，您可以安装一个像Calico这样的CNI插件来实现集群中的网络策略。如果没有这样的插件，这些网络政策将不起作用！</p><h1 id="6c8c" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">机架感知</h1><p id="3bdd" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">由于多种原因，在Kafka中正确配置rack非常重要。Kafka使用机架配置来确定分区副本的最终位置。例如，如果您有6个Kafka代理，平均分布在3个不同的可用性区域(或机架)(每个区域2个)。当创建复制因子为3的主题时，Kafka将选择位于不同区域的经纪人。在这种情况下，它将确保任何区域都不会有超过1个副本。这确保了最大的可用性。</p><p id="0b2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Strimzi允许在Kafka brokers中配置机架，如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mr"><img src="../Images/cb01031eda24d9ff930d1c6003abffa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vl20MhNKOxOjWWIp6d-Jwg.png"/></div></div></figure><p id="f0b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">topologyKey是一个标签，必须存在于Kubernetes集群的所有节点上。默认情况下，大多数云管理集群，如EKS、AKS和GKE，都提供这种功能。在EKS的情况下，传递给Kafka broker的机架值将类似于eu-central-1a。</p><p id="ea63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Strimzi使用上述机架配置来确保每个Kafka broker pod也分布在所有可用性区域中。它使用了Kubernetes的一个叫做亲和力的概念。让我们看看那个。</p><h1 id="6f99" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">吸引力</h1><p id="a105" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">作为一名指挥，Kubernetes做调度。调度程序处理基本问题:“在哪里运行pod？”。有时，您希望某些pod与另一个应用程序pod位于相同(或不同)的机器上。例如，传递大量数据的两个应用程序可以位于同一个节点上，以使流量保持在本地。或者您希望一个应用程序窗格位于具有更高CPU和内存的特定节点上。这样的场景可以在Kubernetes中使用Affinity来处理。</p><p id="eb1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种相似性:<strong class="jp ir">节点相似性</strong> —用于回答问题“在哪个节点上运行这个pod？”和<strong class="jp ir"> PodAffinity(或PodAntiAffinity) </strong> —用于回答“此pod是否应该与此<em class="ms">其他</em> pod运行在相同/不同的节点中？”两者都决定了pod将在哪个节点上运行，但规则是基于前者中的节点和后者中的pod。</p><p id="981e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果启用了机架配置，Strimzi将定义节点和机架关联。下面是NodeAffinity的一个示例:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mt"><img src="../Images/808f4fc7fc1b826fb7dc97f09a43bc7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FiEK0WnkVwtSONe8Cyn8vw.png"/></div></div></figure><p id="5990" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的配置可能看起来很复杂，但很容易做到。它告诉Kubernetes调度程序，Kafka broker pods <em class="ms">必须</em>被调度到带有关键字<strong class="jp ir">failure-domain.beta.kubernetes.io/zone.</strong>标签的节点上，因此您的worker节点必须有这个标签。对于像EKS、AKS和GKE这样的托管集群，这已经可用。</p><p id="05ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">超长的配置项<strong class="jp ir">requiredduringschedulingignoredduringeexecution</strong>意味着，在调度新的Kafka broker pods(<em class="ms">requiredDuringScheduling)</em>时，应该<strong class="jp ir">严格执行该规则，但对于在不满足该标准的节点上发现的任何已经运行的Kafka broker pods(<em class="ms">ignored during execution)</em>则可以放宽。</strong></p><p id="03a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是启用rack时Strimzi定义的PodAntiAffinity示例:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mu"><img src="../Images/81d516dd819d96a77517f4eeb50570ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xNJ9opnLVRGNmuPEfK9RFQ.png"/></div></div></figure><p id="2661" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解释这种配置，我们来看一下调度3个Kafka broker pods:</p><ol class=""><li id="0464" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">当调度代理1时，调度器将尝试在可用性区域AZ1中的节点上运行pod。上面的亲缘性配置说检查在这个节点上是否已经有Kafka broker pod在运行(基于strimzi.io标签),如果这样的pod是<em class="ms">而不是</em>在运行(反亲缘性),那么在AZ1上调度broker1，它将成功，</li><li id="6d29" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">下一个调度程序尝试在节点AZ1上调度代理2，但这次它发现代理1 pod已经在运行。因此，跳过该节点，找到不同的节点AZ2，调度代理2。</li><li id="2717" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">对于要在AZ3上调度的代理3，重复步骤2。</li></ol><p id="1610" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有第四个经纪人也要安排，会怎么样？它会在哪个节点上结束？这里，配置项<strong class="jp ir">在schedulingignoredduringeexecution</strong>中变得很重要。这意味着相似性规则是<em class="ms">首选的</em>，但不是强制性的。因此，当调度第4个代理时，将不会满足规则(假设只有3个唯一的az ),但无论如何都会在某个节点上进行调度。</p><h1 id="ddd9" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">健康检查</h1><p id="2abf" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">如果没有配置适当的健康检查，Kubernetes中的任何应用程序部署都不能被视为生产就绪。Kubernetes允许您配置两种检查——活性探测和就绪探测。</p><p id="6303" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">活性探测用于确定何时重启pod。常见的探测解决方案是TCP端口检查或HTTP GET调用。如果pod在一定时间间隔内没有响应，将会重新启动。</p><p id="6e2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">准备就绪探测用于确定pod应该何时开始接收流量。这是通过将负责流量的pod添加到这些pod的服务后端来实现的。</p><p id="21d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在卡夫卡的例子中，活性探针和准备就绪探针之间的区别是很重要的。卡夫卡启动了听众，但这并不意味着它已经准备好为客户服务。这可能是由于不同步的副本需要赶上其他代理。如果代理管理数千个分区，这个同步过程可能需要几分钟。因此，正确设置Kafka的就绪探针是很重要的。请记住，必须设置活动和就绪探测器。</p><h2 id="5df7" class="mv ln iq bd lo mw mx dn ls my mz dp lw jy na nb ma kc nc nd me kg ne nf mi ng bi translated">活性探针</h2><p id="0a11" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">Strimzi使用一个定制的bash脚本，通过netstat测试复制端口(9091)上的监听器。当这个活性探测成功时，它表明Kafka已经正确启动，并且复制侦听器被激活。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nh"><img src="../Images/94bdd96e20c0af3884def78b1e12ed49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJ0ekCCM6CAmSV9o14ZZsg.png"/></div></div></figure><h2 id="84fe" class="mv ln iq bd lo mw mx dn ls my mz dp lw jy na nb ma kc nc nd me kg ne nf mi ng bi translated">就绪探测</h2><p id="1943" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">为卡夫卡建立一个准备就绪的探测器是很棘手的。卡夫卡经纪人什么时候准备好服务客户？当代理启动时，它执行许多操作，如从ZooKeeper获取集群元数据，与控制器同步，日志健全性检查，获得分区的领导权，同步副本以加入分区的ISR列表等等。这些活动大多数发生在监听器启动之后，因此虽然代理是“活动的”，但它还没有“准备好”。</p><p id="1d63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当代理最终准备好服务来自客户端的请求时，它通过JMX度量kafka.server:type=KafkaServer，name=BrokerState报告这一情况。Strimzi在就绪探测中检查该指标，以确定Kafka broker何时准备好接收流量。这是在一个Java代理中完成的，该代理轮询这个指标，一旦达到所需的状态，就将一个文件写入磁盘，然后由就绪探测器检查该文件是否存在。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ni"><img src="../Images/2b809ef9d5456452dd5be9ba1aaafb6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Ou-xa5yRVS_Uj0LFqRoWA.png"/></div></div></figure><p id="3dab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拥有正确的探针设置可以确保Kafka代理的滚动升级不会出现停机时间。</p><h1 id="5adc" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="0a89" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在这篇文章中，我们看到了在Kubernetes中运行像Kafka这样的有状态应用程序是一项挑战。让我们回顾一下我们所学的内容。</p><ol class=""><li id="bf15" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">在Kubernetes中运行Kafka时使用Strimzi这样的操作符</li><li id="19bd" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">不要低估在Kubernetes中维护和运行有状态应用程序的重要性。</li><li id="9e95" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">有效利用Kubernetes的资源，如Pod-disruption预算、网络策略、亲缘关系和健康检查。</li></ol><p id="f70b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正确理解Kubernetes的各种结构，就有可能安全可靠地运行Kafka。祝你好运！</p><h1 id="9d3f" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">关于</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/7e07b74a2548b1897c55eb2b806ab0d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*p86c5OE5tJjEQgwRAm0q1w.jpeg"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">阿比纳夫声纳，软件工程师@ <a class="no np ep" href="https://medium.com/u/64a0ec88f168?source=post_page-----ceda3f95c157--------------------------------" rel="noopener" target="_blank"> Axual </a></figcaption></figure><p id="bacb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文由Axual团队成员<a class="ae kl" href="https://www.linkedin.com/in/abhinavsonkar/" rel="noopener ugc nofollow" target="_blank">阿比纳夫·松卡尔</a>撰写。</p><p id="b61c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们是一个对技术充满热情的爱好者俱乐部。每一天，我们都在挑战自己，拓展我们的职业和质量。</p><p id="7f8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Axual就是这样被创造出来的。从简化流媒体的目的出发。通过Axual，我们将每家公司都置于数据驱动之下。我们的软件支持整个组织的情境感知。</p><p id="7d7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们很高兴通过这些博客带你了解我们学习、创新、失败和改进的过程。</p><p id="35bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想了解更多？阅读我们的博客或访问www.axual.com的<a class="ae kl" href="http://www.axual.com" rel="noopener ugc nofollow" target="_blank"/></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nq"><img src="../Images/603cff6df6f7736f7fa4b0c4a36d7de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nft9Zasu8TwMwnD-bDMVtw.jpeg"/></div></div></figure></div></div>    
</body>
</html>