# 使用异步钩子作为状态管理库的替代方法来反应上下文 API

> 原文：<https://itnext.io/when-you-finally-decided-to-rid-yourself-of-redux-8fff0624d2fb?source=collection_archive---------1----------------------->

![](img/045fc3df005f20f11081f364899ba937.png)

图片借用自[本文](https://medium.muz.li/use-the-power-of-simplicity-to-deliver-awesome-digital-banking-5923aae65177)

与 Redux 合作并不总是愉快的。对于某些用例来说，它是一个很好的工具，但是对于一个普通的应用程序来说，它可能会成为一个瓶颈，因为它会膨胀代码库，并耗费开发人员的时间来进行最简单的更改。维护一个 Redux 应用程序并不像你希望的那么容易:跟踪从调度到动作、API 调用、reducer 到组件的数据流阻碍了敏捷性。随着更小(微型)应用程序的趋势，这些应用程序只是想从 API 中消费数据并将其呈现在页面上，Redux 是一个大材小用，这促使我探索我们的仪表板应用程序的替代品。

当试图决定是否应该使用 Redux 时，问问你自己你的数据有多持久，或者说你的数据有多短暂。例如，在执行搜索时，您是否会用新列表替换商店中的整个状态？当你对一个巨大的数据表进行排序时，你会在你的 API 中查询一组新的条目吗？当显示列表中某个条目的详细信息时，是从存储中回收数据还是从 API 中获取实体的完整版本？如果您可以切换到 GraphQL 并只获取您需要的东西，您还会使用相同的存储架构吗？

在我们的仪表板应用程序中，每次页面加载都要求我们重新加载所有数据，以确保数据是最新的。鉴于动作是由多个用户以及后端流程和第三方集成触发的，试图在多个页面或会话之间持久化数据是不可行的。因此，最大的问题是，当所有的数据都是短暂的，并且只要特定的页面被显示就存在于浏览器中，并且每当对这些数据执行一个动作就被重新加载时，我们为什么需要一个状态管理框架？我想不出在全局级别使用状态管理有什么好处，所以我决定探索一下上下文 API 如何使我们的应用程序更简单。

下面的方法是我想出来的，到目前为止，它被证明更容易使用。

让我们使用我最喜欢的 [CocktailDB API](https://www.thecocktaildb.com/api.php) 来构建一个鸡尾酒应用程序。

## 一次性数据

获取数据并且不需要在组件树中重用数据(或者可以将数据作为道具向下传递)的路由或组件实现起来非常简单。虽然您可以使用`useEffect`钩子，但我更喜欢使用由`[react-async-hook](https://github.com/slorber/react-async-hook#readme)` [库](https://github.com/slorber/react-async-hook#readme)提供的钩子。

如您所见，我们通过字母表中的一个字母来获取和显示鸡尾酒列表。每当一个字母改变时，async hook 被触发，新的数据被获取，组件被重新呈现。没什么特别的，但是用 Redux 实现这个会花费更多的精力，所以为什么要这么麻烦呢？

## 可重用数据

现在，让我们假设有这样一种情况，我们有多个组件依赖于来自多个来源的数据。在上面的例子中，我们必须重新获取每个组件的数据，这是不太实际的。这就是`Context`派上用场的地方，因为我们可以传递 react-async-hook 生成的承诺和回调作为上下文值，并允许每个组件在这些承诺解决或失败时接收相同的结果集。

在这个例子中，我们设置了`CocktailDetailsContext`,它有多个类似承诺的对象沿着组件树向下传递。我们可以拥有任意数量的可以以非阻塞方式呈现和更新的组件，也就是说，只要数据可用，就可以呈现单个较低级别的组件。我们可以根据需要创建尽可能多的依赖于相同端点数据的较低级部分，而不必多次获取数据。最重要的是，这些组件中的每一个都确切地知道获取结果是成功的、仍然未决的还是导致了错误，因此您可以采取适当的措施。此外，我们可以利用额外的`react-async-hook`方法，比如`reset`，我们可以将它与上下文一起传递，以允许较低级别的组件调用整页重载，或者`execute`，它将允许组件从特定的端点重新获取数据，而不会将代码简化为意大利面条。

今天到此为止。期待您的反馈。