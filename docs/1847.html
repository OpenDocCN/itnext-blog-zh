<html>
<head>
<title>Taming Side-Effects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">驯服副作用</h1>
<blockquote>原文：<a href="https://itnext.io/functional-architecture-e9031090ff18?source=collection_archive---------5-----------------------#2019-02-10">https://itnext.io/functional-architecture-e9031090ff18?source=collection_archive---------5-----------------------#2019-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/fe51f1810f095153253e9f692d6b4d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*geQ-8dHuX9q4KodQjnWAkw.png"/></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">功能核心，命令式外壳</figcaption></figure><div class=""/><p id="9d98" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个已经在这个行业中工作了7年多的人，我注意到许多软件都存在不能很好地处理副作用的问题。</p><h1 id="cc3e" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是副作用？</h1><p id="ddba" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">副作用是赋值操作——它改变了应用程序的全局状态。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2baf" class="mi kx jb me b gy mj mk l ml mm">private var n = 1 // global state</span><span id="9a32" class="mi kx jb me b gy mn mk l ml mm">func plus(_ value: Int) -&gt; Int {<br/>    n += value     // assignment<br/>    return n<br/>}</span></pre><h2 id="121f" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">为什么这样不好？</h2><p id="822d" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果我有一个返回结果的函数<code class="fe mz na nb me b">f(x)</code>，我希望它能通过测试<code class="fe mz na nb me b">XCTAssert(f(x), f(x))</code>。</p><p id="01b6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果函数依赖于变化的全局状态，这个测试将失败。让阅读该测试的开发人员感到困惑的是。在上面的例子中，<code class="fe mz na nb me b">XCTAssert(plus(1), plus(1))</code>将总是<strong class="ka jc"> <em class="nc">失败</em> </strong>，因为它依赖于变异变量<code class="fe mz na nb me b">n</code>。</p><p id="6aa2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这是一个相当人为的例子，但是您可以想象这可能会成为应用程序中其他状态片段的问题，特别是当您在这些变化的状态片段之上构建整个应用程序时。</p><p id="341f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">产生副作用的函数称为<strong class="ka jc"> <em class="nc">不纯</em> </strong>函数。</p><h2 id="ce77" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">不纯函数包括:</h2><ul class=""><li id="9c26" class="nd ne jb ka b kb lu kf lv kj nf kn ng kr nh kv ni nj nk nl bi translated">不可组合——我们需要以特定的顺序执行操作，否则我们会得到奇怪的竞争条件</li><li id="2b38" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">不可预测—结果随<strong class="ka jc"> <em class="nc">时间</em> </strong>变化</li><li id="174e" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">不是线程安全的——我们将需要一个锁来执行赋值。</li></ul><p id="3c27" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理想情况下，我们希望减少这种全球状态的失控突变。我们要<strong class="ka jc"> <em class="nc">纯</em> </strong>功能。</p><p id="c815" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="nc">纯粹的</em> </strong>函数只依赖于传入的参数，对于给定的输入总是返回相同的输出。没有副作用。</p><h2 id="3ec2" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated"><strong class="ak">纯功能有:</strong></h2><ul class=""><li id="ca30" class="nd ne jb ka b kb lu kf lv kj nf kn ng kr nh kv ni nj nk nl bi translated">可组合——你可以构建小块的功能，然后像乐高积木一样组合它们。</li><li id="8c32" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">高度可测试性——给定一个特定的输入，无论调用该函数多少次，都可以得到相同的输出。</li><li id="1d53" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">可重用——你可以将它复制并粘贴到另一个项目中，它不会抱怨缺少依赖项。</li><li id="40e4" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">线程安全——无论它们在什么线程上运行，都将返回相同的值。</li></ul><h2 id="18de" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">变量</h2><p id="029a" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一旦我们将<code class="fe mz na nb me b">var</code>引入代码，我们就必须处理<strong class="ka jc"> <em class="nc">时间</em> </strong>。由于变量会随时间变化，它会受到竞争条件和死锁的影响。</p><p id="a465" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Swift中，我们应该尽量减少代码中<code class="fe mz na nb me b">var</code>的数量，尤其是当它们存在于函数之外的时候。理想情况下，我们希望在大多数时候处理函数中的<code class="fe mz na nb me b">let</code>值或参数。</p><h2 id="4cc5" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">在命令式的世界中进行功能性思考</h2><p id="66ba" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><em class="nc"> Swift </em>是<strong class="ka jc">而不是</strong>一种<em class="nc">功能性</em>语言，它是一种<em class="nc">混合型</em>语言。这意味着我们可以利用函数式编程的优势来增强不变性和可预测性，并且有能力退出到OOP世界来执行副作用或处理用户交互。</p><h2 id="4fe1" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">流向</h2><p id="f4c1" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">最常见的架构是双向的，比如MVVM ( <code class="fe mz na nb me b">M&lt;-&gt;VM&lt;-&gt;V</code>)、MVP ( <code class="fe mz na nb me b">M&lt;-&gt;P&lt;-&gt;V</code>)、MVC ( <code class="fe mz na nb me b">M&lt;-&gt;VC</code>)。VIPER可能是最复杂的一个，需要一个<em class="nc">线框</em>来将所有的部分放在一起。</p><p id="e466" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过允许流双向发生，事件的顺序可以以任何顺序发生，由于竞争条件，稍后会产生调试噩梦。</p><p id="8fe4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，在MVP中，我可能会在<em class="nc">视图</em>设置之前调用<em class="nc">表示器</em>上的函数，这可能会导致意外行为或崩溃，具体取决于代码是如何实现的。</p><p id="5737" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了提高可预测性，降低复杂性，减少代码中的耦合，我们应该致力于使用单向架构。实现这一目标有许多不同的方式，有些方式比其他方式更复杂。</p><ul class=""><li id="f783" class="nd ne jb ka b kb kc kf kg kj nr kn ns kr nt kv ni nj nk nl bi translated">榆树可能是你能找到的最纯粹的树，然而有了这种纯粹，你可能会失去像动画一样的东西。有一些人已经走上了这条路，比如克里斯·埃德霍夫的《雨燕的茶》。</li><li id="c680" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated"><a class="ae nu" href="https://github.com/inamiy/RxAutomaton" rel="noopener ugc nofollow" target="_blank"> RxAutomaton </a>是一个轻量级的例子，但是它要求我们使用Rx，而我们可能并不总是需要Rx，这可能会让不熟悉这个框架的人感到困惑。</li><li id="3391" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated"><a class="ae nu" href="https://github.com/BrianSemiglia/Cycle.swift" rel="noopener ugc nofollow" target="_blank">cycle . Swift</a>Swift中Cycle.js的一个实现，它需要相当大的范式转换，并且不能很好地与现有的Rx框架兼容。然而，原则上其背后的逻辑是可靠的。</li><li id="2336" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated"><a class="ae nu" href="https://github.com/ReSwift/ReSwift" rel="noopener ugc nofollow" target="_blank">resswift</a>、<a class="ae nu" href="https://github.com/RxSwiftCommunity/RxState" rel="noopener ugc nofollow" target="_blank"> RxState </a>、<a class="ae nu" href="https://github.com/RxSwiftCommunity/RxReduce" rel="noopener ugc nofollow" target="_blank"> RxReduce </a>是Redux在Swift中的实现。Redux可能是最轻量级的单向架构，也是我选择在下面解释的架构——我不会使用框架，因为我相信如果你自己实现某个东西，它会更干净、更具可扩展性。</li></ul></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="e6e1" class="kw kx jb bd ky kz oc lb lc ld od lf lg lh oe lj lk ll of ln lo lp og lr ls lt bi translated">Redux是什么？</h1><p id="335a" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Redux是从大部分代码中抽象出副作用的方法之一。副作用仍然可能发生，但是它们只能以可控的方式发生，这使得它们在出错时更容易调试(比如竞争条件或死锁)。</p><p id="18b1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux使用了一些概念来实现这一点…</p><h2 id="4fcb" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">商店</h2><p id="2251" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一个集中的<code class="fe mz na nb me b">Store</code>，它将包含一个对最新<code class="fe mz na nb me b">State</code>的<em class="nc">引用</em>。</p><h2 id="77f0" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">行动</h2><p id="e495" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">改变<code class="fe mz na nb me b">State</code>的<strong class="ka jc">唯一的</strong>方式是向<code class="fe mz na nb me b">Store</code>分派一个<code class="fe mz na nb me b">Action</code>，然后将当前的<code class="fe mz na nb me b">State</code>和<code class="fe mz na nb me b">Action</code>传递给一个<code class="fe mz na nb me b">Reducer</code>。</p><h2 id="1e55" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">还原剂</h2><p id="8052" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">A <code class="fe mz na nb me b">Reducer</code>接收当前<code class="fe mz na nb me b">State</code>和<code class="fe mz na nb me b">Action</code>并返回新的<code class="fe mz na nb me b">State</code>和我们想要执行的任何<code class="fe mz na nb me b">Side Effects</code>。</p><p id="cbfa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后<code class="fe mz na nb me b">Store</code>将其<em class="nc">引用</em>更新为<em class="nc"> </em> <code class="fe mz na nb me b">State</code> <em class="nc"> </em>，并将<code class="fe mz na nb me b">Side Effects</code>传递给<code class="fe mz na nb me b">Interpreter</code>。</p><h2 id="3011" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">解释者</h2><p id="fd7d" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe mz na nb me b">Interpreter</code>是<strong class="ka jc">唯一能够访问外部<strong class="ka jc">依赖</strong>并能够实际<strong class="ka jc">作用于</strong>那些<code class="fe mz na nb me b">Side Effects</code>的地方。</strong></p><p id="c687" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是您实现保存到数据库、从网络获取、日志、分析、运行计时器等事情的地方。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="4e58" class="kw kx jb bd ky kz oc lb lc ld od lf lg lh oe lj lk ll of ln lo lp og lr ls lt bi translated">Redux有什么好处？</h1><h2 id="59ef" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated"><strong class="ak">易于调试</strong></h2><p id="c8f4" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">通过限制<strong class="ka jc">何时</strong>和<strong class="ka jc">发生</strong>副作用(在<code class="fe mz na nb me b">Interpreter</code>中)，我们对正在发生的事情完全透明(我们甚至可以按照它们发生的顺序记录它们)，这使得查找线程问题变得更加容易。</p><h2 id="b4f8" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated"><strong class="ak">易于测试</strong></h2><p id="1e43" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">测试再简单不过了，而且它几乎是自己写的。<em class="nc">给</em>一个特定的<code class="fe mz na nb me b">State</code>，<em class="nc">当</em>一个特定的<code class="fe mz na nb me b">Action</code>是<code class="fe mz na nb me b">Reduced</code>，<em class="nc">那么</em>我可以期待一个新的<code class="fe mz na nb me b">State</code>和<code class="fe mz na nb me b">Effects</code>。我们只需要测试一下<code class="fe mz na nb me b">Reducer</code>。</p><h2 id="4c74" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated"><strong class="ak">具有可预测的不可变状态，带有变化描述</strong></h2><p id="745f" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe mz na nb me b">Actions</code>是简单的<em class="nc">值</em>——包含一条可能与<code class="fe mz na nb me b">State</code>相关的信息的类型。</p><p id="d79b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mz na nb me b">Reducers</code>取一个旧的<code class="fe mz na nb me b">State</code>和一个<code class="fe mz na nb me b">Action</code>，返回一个新的<code class="fe mz na nb me b">State</code>和任何应该发生的<code class="fe mz na nb me b">Effects</code>。</p><h2 id="67c1" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated"><strong class="ak">防止状态相关的死锁和竞态条件</strong></h2><p id="a6b6" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们的<code class="fe mz na nb me b">Store</code>将一次只处理一个 <code class="fe mz na nb me b">Action</code>的<strong class="ka jc">，这防止了在不需要信号量和锁的情况下围绕突变状态的竞争条件/死锁问题。</strong></p><h2 id="3828" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">减少代码中不纯函数的数量</h2><p id="41ba" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">上述所有概念的重要之处在于，除了包含对<strong class="ka jc">最新</strong> <code class="fe mz na nb me b">State</code>的<em class="nc">引用</em>的<code class="fe mz na nb me b">Store</code>类<em class="nc">之外，它们都是<em class="nc">值类型(枚举、结构、原语)</em>和<em class="nc">纯</em>函数。</em></p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="ea07" class="kw kx jb bd ky kz oc lb lc ld od lf lg lh oe lj lk ll of ln lo lp og lr ls lt bi translated">与MVVM相比</h1><p id="4288" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们将Redux与典型的MVVM解决方案进行比较，因为这是iOS上常见的设计模式。</p><h2 id="62b8" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">状态</h2><ul class=""><li id="b8e0" class="nd ne jb ka b kb lu kf lv kj nf kn ng kr nh kv ni nj nk nl bi translated">视图不是将事件分派给视图模型，而是将<code class="fe mz na nb me b">Actions</code>分派给<code class="fe mz na nb me b">Store</code>。</li><li id="1376" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">它不是观察ViewModel中的视图状态，而是观察<code class="fe mz na nb me b">Store</code>中最新的<code class="fe mz na nb me b">State</code>。</li></ul><h2 id="3666" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">事件</h2><ul class=""><li id="d251" class="nd ne jb ka b kb lu kf lv kj nf kn ng kr nh kv ni nj nk nl bi translated">在MVVM，发送到ViewModel的事件将调用<em class="nc">服务</em>或<em class="nc">用例</em>，它们将使用新值进行响应。我们还经常需要组合多个值，以便用户界面能够理解它——这就是问题所在，因为异步代码是不可预测的。大多数时候，这些异步块是用队列、锁、信号量来管理的，或者在<em class="nc"> Rx </em>中，我们可以使用<code class="fe mz na nb me b">combineLatest</code>、<code class="fe mz na nb me b">merge</code>、<code class="fe mz na nb me b">zip</code>、<code class="fe mz na nb me b">flatMap</code>等操作…</li><li id="3e0c" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">在Redux中，<code class="fe mz na nb me b">Actions</code>将被发送到<code class="fe mz na nb me b">Reducer</code>以创建新的状态和/或<code class="fe mz na nb me b">Effects</code>。<code class="fe mz na nb me b">Interpreter</code>将调用服务或用例，这些服务或用例将执行并分派新的<code class="fe mz na nb me b">Actions</code>来更新<code class="fe mz na nb me b">State</code>。然后<code class="fe mz na nb me b">Actions</code>将按顺序执行，无需担心与状态相关的死锁或竞争条件。</li></ul><h2 id="a3d7" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">单元测试</h2><ul class=""><li id="75c3" class="nd ne jb ka b kb lu kf lv kj nf kn ng kr nh kv ni nj nk nl bi translated">在MVVM，我们需要测试ViewModel，但是如果你注意到上面我们有异步代码——这意味着我们需要创建尽快响应的模拟对象，探子来跟踪执行，并在XCTest中使用<em class="nc"> waitForExpectation </em>(或使用RxBlocking/RxTest) <em class="nc">创建测试调度程序。</em>这给测试我们的视图模型在基于执行顺序的众多场景中的正确行为带来了很大的复杂性。此外，如果一些异步逻辑发生变化，可能会破坏所有的测试。</li><li id="18f7" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">在Redux中，我们简单地测试一下，如果我们的<code class="fe mz na nb me b">Reducer</code>接收到一个特定的<code class="fe mz na nb me b">State</code>和一个<code class="fe mz na nb me b">Action</code>，它会返回一个新的<code class="fe mz na nb me b">State</code>和<code class="fe mz na nb me b">Effects</code>。这变得更容易测试，因为没有模拟或异步等待。因为我们比较的是简单的对象，我们甚至可以依靠快照测试框架。</li></ul></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="330c" class="kw kx jb bd ky kz oc lb lc ld od lf lg lh oe lj lk ll of ln lo lp og lr ls lt bi translated"><strong class="ak">结论</strong></h1><p id="2a6c" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">正如你在上面看到的，MVVM和Redux之间的对比对MVVM来说是致命的。</p><ul class=""><li id="4e11" class="nd ne jb ka b kb kc kf kg kj nr kn ns kr nt kv ni nj nk nl bi translated">当数据来自多个来源并需要组合时，MVVM使UI更新变得复杂。在Redux中我们简单观察<code class="fe mz na nb me b">State</code>。</li><li id="51c3" class="nd ne jb ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">MVVM还将看似简单的测试场景复杂化，增加了对模拟、间谍和等待的需求。在Redux中，我们根本不需要这些概念来测试我们的业务逻辑，因为没有<strong class="ka jc"><em class="nc"/></strong>时间组件，这意味着测试会执行得更快，也更容易维护。</li></ul><p id="f0eb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有兴趣了解上面提到的Redux概念，请看看我下面的示例项目，它包含一个操场和一个示例应用程序。</p><p id="210d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例子:<a class="ae nu" href="https://github.com/cjnevin/FunctionalRedux" rel="noopener ugc nofollow" target="_blank">https://github.com/cjnevin/FunctionalRedux</a></p><h2 id="f959" class="mi kx jb bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">参考资料:</h2><p id="023f" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">罗伯特·马丁介绍:<a class="ae nu" href="https://www.youtube.com/watch?v=7Zlp9rKHGD4" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=7Zlp9rKHGD4</a><br/>布兰登·威廉姆斯介绍:<a class="ae nu" href="https://www.youtube.com/watch?v=QOIigosUNGU" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=QOIigosUNGU</a></p></div></div>    
</body>
</html>