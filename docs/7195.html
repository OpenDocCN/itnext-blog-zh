<html>
<head>
<title>Unix Shells and Terminals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unix外壳和终端</h1>
<blockquote>原文：<a href="https://itnext.io/unix-shells-and-terminals-6012fe713e4f?source=collection_archive---------0-----------------------#2022-07-12">https://itnext.io/unix-shells-and-terminals-6012fe713e4f?source=collection_archive---------0-----------------------#2022-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8210" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Unix shell和Unix终端是一回事吗？</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/778154bea14c8ae7fc64d091b19faead.png" data-original-src="https://miro.medium.com/v2/format:webp/1*B7iOx5Eo3_QWZF-mpIAhJw.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">Unix不是在个人计算机上诞生的。它是通过电传终端编程的。</figcaption></figure><p id="34b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能以前见过Unix终端模拟器。下图来自macOS终端应用程序。这些有很多。我最喜欢的是<a class="ae lq" href="https://iterm2.com" rel="noopener ugc nofollow" target="_blank"> iTerm2 </a>。Linux用户可以使用GNOME终端，或者KDE应用程序Konsole。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/682a086a2ad75c4bc03b47cf737d91b0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0Sb812VrI2968XMkX3R9YA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">使用终端应用程序列出Godot目录的内容</figcaption></figure><p id="f336" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些界面的一个更通用的术语是CLI(命令行界面)。我第一次接触CLI实际上不是Unix系统或Microsoft DOS，而是在一台运行AmigaDOS的Amiga 1000计算机上，在一个蓝色的CLI窗口中。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/317facb3d2cfe621f34916819b1c497d.png" data-original-src="https://miro.medium.com/v2/1*kIlj_0R-Sc1LsJf3FO8Iog.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">运行AmigaDOS的Amiga命令行(CLI)。</figcaption></figure><p id="ad05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，CLI的概念是非常通用的，但是本文将集中讨论Unix命令行界面(CLI ),因为它们主宰了现代操作系统，如Linux、macOS，甚至Windows。是的，Windows有它的DOS和PowerShell CLIs，但是Unix命令行也通过<a class="ae lq" href="https://docs.microsoft.com/en-us/windows/wsl/about" rel="noopener ugc nofollow" target="_blank"> Windows子系统for Linux (WSL) </a>接管了Windows。</p><p id="c130" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于初学者来说，Unix命令行可能很难理解。人们对shell(如Bourne Again Shell <code class="fe lr ls lt lu b">bash</code>)、计算机终端(如<a class="ae lq" href="https://en.wikipedia.org/wiki/VT100" rel="noopener ugc nofollow" target="_blank"> VT100 </a>)和终端模拟器(如Konsole或GNOME终端)之间的区别感到困惑。为了增加更多的混乱，我们可以谈谈<a class="ae lq" href="https://en.wikipedia.org/wiki/Pseudoterminal" rel="noopener ugc nofollow" target="_blank">伪终端</a>。</p><p id="9004" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些例子中自然会出现几个问题:</p><ol class=""><li id="38af" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ma mb mc md bi translated">究竟为什么有一个命令行界面会如此复杂？</li><li id="7516" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ma mb mc md bi translated">我需要知道这些吗？我能活在无知的幸福中吗？</li></ol><p id="0b86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很长一段时间，我不知道Unix命令行的具体细节，仍然在使用它，没有遇到太多问题。然而，如果不理解底层技术，您将经常难以理解重要的事情。</p><p id="431e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我举一个Git版本控制系统的例子:很长一段时间，我试图坚持只知道要发出的命令。我试图只把Git作为一个用户。作为一个只知道使用命令的人。那没用。我非常沮丧，准备完全放弃Git。我的一个朋友恳求我不要放弃。所以，我做了最后的努力，读了一本关于Git的书。突然，一切都明白了。我实际上是基于这个经验做了一个演讲，它帮助了许多与Git作斗争的人:<a class="ae lq" href="https://www.youtube.com/watch?v=tHr0dOtDeXI" rel="noopener ugc nofollow" target="_blank">理解Git版本控制系统</a>。</p><p id="80fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Unix命令行非常相似。通过理解底层概念，您将能够使用命令行做更多的事情。</p><h1 id="6fe1" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">Unix CLI为什么这么复杂？</h1><p id="881e" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">如果您今天从头开始构建一个命令行界面，您可以使事情变得简单得多。它从一开始就是为鼠标、窗口和键盘设计的。在Windows和Linux上，复制粘贴可以像其他应用程序一样使用Ctrl-C和Ctrl-V。一次跳一个单词或一行的热键可以像其他文本编辑器一样工作。你可以很容易地将鼠标放在字母之间。然而，您通常不能在Unix终端中做任何这些事情，并且可能不清楚为什么这些看似任意的限制存在。</p><p id="3896" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">问题是，大量的Unix工具，如<code class="fe lr ls lt lu b">ls</code>、<code class="fe lr ls lt lu b">telnet</code>、<code class="fe lr ls lt lu b">ftp</code>、<code class="fe lr ls lt lu b">ed</code>、<code class="fe lr ls lt lu b">awk</code>、<code class="fe lr ls lt lu b">sed</code>、<code class="fe lr ls lt lu b">grep</code>、<code class="fe lr ls lt lu b">tar</code>、<code class="fe lr ls lt lu b">gzip</code>和其他许多工具是为已经不存在的计算机硬件开发的。人们不愿意放弃他们已经习惯使用的所有软件。他们宁愿不要从头重写所有这些软件。因此，随着Unix硬件和软件的发展，他们在上面创建了各种形式的仿真，以使现有的工具如<code class="fe lr ls lt lu b">grep</code>和<code class="fe lr ls lt lu b">tar</code>认为它们仍然运行在旧的Unix系统上。</p><p id="0edd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也是我们今天使用英特尔x86处理器的原因。指令集架构已经相当过时了。如果我们能从零开始设计一个微处理器，它看起来不像我们会做出来的东西。然而，设计并没有停滞不前。它已经发展和扩展了更多的功能来保持相关性。现代指令集架构将更接近于今天M1和M2 MAC电脑中使用的Arm，或者RISC-V指令集。</p><p id="0fb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编程语言也是如此。C++已经变成了一个怪物。如果从头开始，今天没有人会设计出像C++这样的东西。这种语言最初流行是因为开发人员可以重用他们的旧C代码。后来，在保持旧的C++代码运行的同时，它通过添加特性保持了相关性。</p><p id="924b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，理解今天任何广泛使用的技术，就像理解工程和程序设计一样，都是关于考古挖掘的。从1992年开始，我一直致力于用C++编写的3D建模工具。通常理解架构和设计不是通过考虑工程上的权衡来完成的，而是通过让老前辈给你上一堂关于过去美好时光的历史课来完成的。</p><p id="7ecb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">学习起来似乎是浪费时间和精力，但是我可以向您保证，理解Unix终端的历史将极大地帮助您理解系统为什么以这种方式工作。</p><h1 id="294d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">Unix终端的历史</h1><p id="060b" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">我在这一节的目的是让您掌握终端、shell和终端模拟器之间的相互关系。</p><p id="f97f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最初的Unix主机没有像你今天所用的电子显示器。它们不是个人电脑，而是供多个用户使用的大盒子。取而代之的是，计算机用户的办公桌上有一种叫做电传打字机的东西。你可能也听说过它们被称为电传打字机、电传打字机或TTY。这些机器工作起来就像一台集美化了的打字机和电报于一身的机器。它没有内存、微处理器或类似的东西。它主要是一种机电设备。你在上面输入字母，字母会像真的打字机一样出现在纸上，所以你可以看到你在输入什么。关键的区别在于，你输入的信件是通过串行电缆(RS-232)发送到Unix计算机的。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/1bbb8eec204f94adb0fac5ff03e9c271.png" data-original-src="https://miro.medium.com/v2/format:webp/1*mGvXSHZEtVhZgALjAnCMYg.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">运行在20世纪30年代电传打字机上的Linux。shell命令的结果打印在实际的纸上。</figcaption></figure><p id="d8e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了理解Unix计算机和电传打字机之间的关系，与我们现代网络驱动的世界进行类比是有帮助的。谷歌、亚马逊和其他公司有许多运行网络服务器软件的服务器。用户可以通过互联网从智能手机、平板电脑、笔记本电脑和运行Firefox、Chrome或Safari等网络浏览器的台式电脑连接到这些电脑。最终，多个用户通过网络电缆连接到同一台计算机。服务器用请求的网页进行响应。</p><p id="c4a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Unix大型机设置中，按照我们的现代标准，一切都更加原始。你连接的不是智能手机，而是一个电子机械设备，电传打字机，它甚至不是一台真正的计算机。电传打字机不能进行任何计算或运行任何软件。它所能做的就是记录你按下的字母，并通过串行电缆将它们发送到Unix主机。Unix主机将通过串行电缆发回信件来作出响应。当这些信到达时，它们会在你的打字机上打印出来。</p><p id="efe4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与我们现代的网络和互联网世界有几个显著的不同。网络以数据包的形式发送数据，例如TCP/IP数据包。甚至一根不起眼的USB电缆也能发送数据包。数据包是一个独立的小数据块。你可以把一个包想象成一封信:它写着它从哪里来，要去哪里，并且包含一些数据。这样，来自多个不同客户端的数据可以通过同一根网络电缆传输到服务器。当收到时，服务器可以分离出不同的包，以便它可以处理自己与不同的智能手机，桌子和笔记本电脑之间的通信，所有这些都只需要一根物理电缆。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/cd8b306d746f7658e361d824491da0a3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hIqHdLCOrvL4S9w60BkRTg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">Unix终端与现代Web客户端的比较</figcaption></figure><p id="e138" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Unix计算机不是这样的。每台电传打字机都需要一根单独的串行电缆。它不发送数据包。只要你一按下按键，它就会发送代表你所按按键的二进制数字。这是一项基本制度。它实际上并不是首先为计算机制造的。电传打字机被用来代替电报。你不用敲电报机，听到另一端的哔哔声，你可以奢侈地输入整个文本。不需要学习莫尔斯电码。</p><p id="ad4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">20世纪70年代，电传打字机演变成更现代的电子版本，如VT100。你可以把它看作是一个显示器和键盘连在一起的设备。因此，你可以把旧的Unix主机想象成一台允许你插入多个屏幕和键盘的计算机。每个键盘和屏幕组合服务于不同的用户。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/30cdac789096eac02db0824a65f9a927.png" data-original-src="https://miro.medium.com/v2/format:webp/1*QQWo1_UXgN0ynTEqeZUh3g.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">VT100终端。不是个人电脑。只和电脑交流。</figcaption></figure><p id="aab7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些终端不必连接到Unix主机。他们可以连接到许多其他系统，如VAX；因此它们是非常普通的设备。当Unix计算机缩小并成为个人用户如PC的台式计算机时，终端和计算机之间的关系发生了变化。Unix有一个窗口系统，叫做X Window System，在这里你可以运行不同的软件。您可以运行的一种应用程序是终端模拟器。一个早期的变体被简单地称为<code class="fe lr ls lt lu b">xterm</code>。</p><p id="1029" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">终端模拟器伪装成VT100之类的旧物理终端。底层Unix系统仍然认为您是在通过串行电缆连接的物理终端上输入。但是，如何才能让Unix认为终端模拟器的窗口是“真正的”终端呢？这是我们将探讨的下一个问题。</p><h2 id="e0f6" class="ng mk it bd ml nh ni dn mp nj nk dp mt ld nl nm mv lh nn no mx ll np nq mz nr bi translated">Unix设备文件，TTY和PTY</h2><p id="4f12" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在Unix上，文件系统更像是不同种类的操作系统资源的名称空间，而不仅仅是磁盘上的物理文件。大多数文件映射到硬盘上的文件。然而，在Unix上，文件也可以表示物理设备，如键盘、鼠标、声卡、硬盘、软盘驱动器、与调制解调器或终端的串行通信。</p><p id="3360" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在<code class="fe lr ls lt lu b">/dev</code>目录中找到代表这些设备的文件。这些文件提供了一种与设备驱动程序通信的方式，设备驱动程序处理与底层物理设备的通信。设备驱动程序是使底层硬件看起来像是<code class="fe lr ls lt lu b">/dev</code>目录中的文件的软件。在过去，Unix会通过<code class="fe lr ls lt lu b">/dev/ttyS0</code>、<code class="fe lr ls lt lu b">/dev/ttyS1</code>和<code class="fe lr ls lt lu b">/dev/ttyS2</code>文件(其中<code class="fe lr ls lt lu b">S</code>代表串口)与各个串行接口进行通信。</p><p id="5424" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个程序可以打开这些文件中的一个，并从中读出电传打字机正在打印的内容。这些程序可以写入文件，把信件送到电传打字机上的纸上。</p><p id="0844" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将这种与外界的联系表示为一个文件被证明是一种强大的抽象。Unix供应商可以编写新的驱动程序，使与终端模拟器的通信看起来一样。Unix程序会读写<code class="fe lr ls lt lu b">/dev/tty</code>文件，而不知道它们现在代表了图形用户界面中许多窗口中的一个。Unix一直延续到现代，很大程度上是因为它在早期创建了强大的抽象。</p><p id="59ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当Unix用户通过TTY设备连接物理终端时，他们会经常运行<code class="fe lr ls lt lu b">telnet</code>、<code class="fe lr ls lt lu b">rsh</code>、<code class="fe lr ls lt lu b">rcp</code>和<code class="fe lr ls lt lu b">rlogin</code>等命令(参见<a class="ae lq" href="https://en.wikipedia.org/wiki/Berkeley_r-commands" rel="noopener ugc nofollow" target="_blank"> r-commands </a>)。所有这些命令都意味着连接到另一台Unix机器。几台Unix机器可以通过TCP/IP网络连接起来。假设用户Bob坐在一台旧的电传终端旁边，通过一个串行端口连接到一台名为Asterix的Unix主机。在这台计算机上，他运行<code class="fe lr ls lt lu b">telnet</code>程序连接到另一台名为Obelix的Unix计算机，该计算机通过TCP/IP网络连接连接到Asterix。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/e056d8815e07e9ebfd15129d31fa9dca.png" data-original-src="https://miro.medium.com/v2/format:webp/1*UaNpfaxzlLpiqEJPHpSghw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">在另一台Unix主机上远程运行<strong class="bd ml"> ls </strong>命令，而不是Bob终端所连接的那台。</figcaption></figure><p id="9fce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在远程Obelix机器上，Bob发出诸如<code class="fe lr ls lt lu b">ls</code>的命令。<code class="fe lr ls lt lu b">ls</code>如何知道将它的输出发送到哪里？没有一台TTY设备可以工作，因为它们与物理端口相关，但是Bob通过TCP/IP连接进行连接。</p><p id="4791" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决方法是<a class="ae lq" href="https://en.wikipedia.org/wiki/Pseudoterminal" rel="noopener ugc nofollow" target="_blank">伪终端</a>简称PTY。这些被表示为<code class="fe lr ls lt lu b">/dev</code>下的文件，由网络应用程序动态创建。事实上，终端模拟器被当作一个伪终端来处理，因为它并不代表一个实际的物理端口，您可以随意创建多个终端窗口。在我使用的macOS上，它们有诸如<code class="fe lr ls lt lu b">/dev/ttys000</code>、<code class="fe lr ls lt lu b">/dev/ttys001</code>和<code class="fe lr ls lt lu b">ttys002</code>的名字。它们是在我创建新的终端窗口和标签时按顺序创建的。</p><p id="0417" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在macOS上，您可以通过发出<code class="fe lr ls lt lu b">tty</code>命令来检查您的终端仿真窗口正在与什么TTY设备通信。</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="1d90" class="ng mk it lu b gy nw nx l ny nz">❯ tty<br/>/dev/ttys000</span></pre><p id="313b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用带有<code class="fe lr ls lt lu b">-a</code>开关的process info命令来查看当前使用的所有TTY设备以及这些设备上正在运行的程序。从这个概述中可以看出，<code class="fe lr ls lt lu b">ttys000</code>创建后做的第一件事是运行<code class="fe lr ls lt lu b">login -fp erikengheim</code>命令。</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="857b" class="ng mk it lu b gy nw nx l ny nz">❯ ps -a<br/>  PID TTY           TIME CMD<br/>25797 ttys000    0:00.02 login -fp erikengheim<br/>25798 ttys000    0:00.10 -fish<br/>25898 ttys000    0:00.00 ps -a<br/>25849 ttys001    0:00.02 login -fp erikengheim<br/>25850 ttys001    0:00.09 -fish<br/>25897 ttys001    0:00.00 nc -l 1234</span></pre><p id="6c31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Unix程序运行时会创建我们称之为<em class="oa">的进程</em>。进程是操作系统中正在运行的程序的表示。一个进程可以创建一个子进程，或者<em class="oa">产生</em>一个子进程，就像我们通常所说的那样。<code class="fe lr ls lt lu b">login</code>进程衍生出<code class="fe lr ls lt lu b">fish</code> shell进程，后者最终衍生出<code class="fe lr ls lt lu b">ps -a</code>进程，后者给出了这个概述。</p><p id="403c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与此同时，在我打开的第二个窗口中，<code class="fe lr ls lt lu b">/dev/ttys001</code>我们得到了大量的其他进程。开始是一样的，但是我选择启动NetCat程序来监听端口1234上的连接。</p><p id="0b65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着我可以通过对本地主机上的端口1234进行常规的网络套接字连接来发送和接收来自NetCat的消息。然而，它最终所做的只是将数据转发到NetCat正在其中运行并监听端口1234的<code class="fe lr ls lt lu b">/dev/ttys001</code>伪终端。我们可以测试所有这些，看看它是如何工作的。创建两个独立的终端窗口:</p><ul class=""><li id="70b7" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ob mb mc md bi translated">服务器—在此窗口中启动<code class="fe lr ls lt lu b">nc -l 1234</code>。</li><li id="8f5d" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated">客户端—使用<code class="fe lr ls lt lu b">telnet localhost 1234</code>连接。</li></ul><p id="2e1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在客户端窗口中编写一条消息，以查看它是否会在服务器窗口中弹出:</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="7733" class="ng mk it lu b gy nw nx l ny nz">❯ telnet localhost 1234<br/>Trying 127.0.0.1...<br/>Connected to localhost.<br/>Escape character is '^]'.<br/>hello world</span></pre><p id="2632" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在服务器端，您应该会收到以下内容:</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="5609" class="ng mk it lu b gy nw nx l ny nz">❯ nc -l 1234<br/>hello world</span></pre><p id="b144" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你从另一台计算机连接，你需要使用<code class="fe lr ls lt lu b">telnet</code>连接，但是因为我们是本地的，我们可以作弊，直接从<code class="fe lr ls lt lu b">/dev/ttys001</code>伪终端读写。要离开<code class="fe lr ls lt lu b">telnet</code>，请按Ctrl-】。这将给出telnet提示符，允许您发出不同的命令。您只需输入<code class="fe lr ls lt lu b">quit</code>:</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="ac33" class="ng mk it lu b gy nw nx l ny nz">❯ telnet localhost 1234<br/>Trying 127.0.0.1...<br/>Connected to localhost.<br/>Escape character is '^]'.<br/>^]<br/>telnet&gt; quit<br/>Connection closed.<br/><br/>❯</span></pre><p id="c6e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们重新启动NetCat来做我们的小欺骗。首先，我们使用<code class="fe lr ls lt lu b">tty</code>命令来确保我们得到了正确的TTY设备。在我的macOS上，我会得到<code class="fe lr ls lt lu b">/dev/ttys001</code>，但是如果你在Linux上运行，你会得到不同的东西。</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="1c1d" class="ng mk it lu b gy nw nx l ny nz">❯ tty<br/>/dev/ttys001<br/><br/>❯ nc -l 1234</span></pre><p id="6447" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们切换到另一个终端窗口，尝试发送文本到<code class="fe lr ls lt lu b">/dev/ttys001</code>设备或你使用的任何TTY。</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="88a7" class="ng mk it lu b gy nw nx l ny nz">❯ echo we are cheating &gt; /dev/ttys001</span></pre><p id="34c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你应该会在另一个窗口看到“我们在作弊”。</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="ffd4" class="ng mk it lu b gy nw nx l ny nz">❯ nc -l 1234<br/>we are cheating</span></pre><p id="32f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe lr ls lt lu b">cat</code>，您同样可以很好地读取TTY，就像它是一个文件一样。在这种情况下，<code class="fe lr ls lt lu b">cat</code>将会阻塞，直到您写入消息。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/8643a97e4480af527595bd8fc15f617a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*-7xcuwqY_ZABo6iB3gc5xA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">用NetCat演示TTY通信</figcaption></figure><p id="9478" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以通过从NetCat发送一个<code class="fe lr ls lt lu b">Ctrl-D</code>来表示通信结束。另一端的<code class="fe lr ls lt lu b">cat</code>命令会将其解释为挂断并退出。从技术上讲，它映射到一个EOF(文件结束)。</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="3b16" class="ng mk it lu b gy nw nx l ny nz">❯ nc -l 1234<br/>we are cheating<br/>A message from NetCat</span></pre><p id="220b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在另一端，我们会看到:</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="073d" class="ng mk it lu b gy nw nx l ny nz">❯ cat /dev/ttys001<br/>A message from NetCat</span></pre><p id="b701" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任何允许你读写文件的程序都可以工作。例如，像<code class="fe lr ls lt lu b">vim</code>、<code class="fe lr ls lt lu b">kak</code>和<code class="fe lr ls lt lu b">emacs</code>这样的编辑器也可以工作。当您保存文件时，它将写入TTY设备，您将在NetCat窗口中看到您编辑的内容。</p><h2 id="b87e" class="ng mk it bd ml nh ni dn mp nj nk dp mt ld nl nm mv lh nn no mx ll np nq mz nr bi translated">USB电缆上的串行通信</h2><p id="df5a" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">伪造串行通信以保持向后兼容性在许多情况下都是有益的。我们让它看起来好像一个终端窗口正在通过RS-232电缆使用伪终端与Unix shell命令进行串行通信。在Mac上，它们由<code class="fe lr ls lt lu b">/dev/ttys</code>文件表示。这是软件中所有事情发生的一个例子。然而，我们也可以使用相同的技巧来使不是串行连接的硬件连接看起来像串行连接。</p><p id="243f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么这很有用？现在很少有计算机配备RS-232串行端口，取而代之的是USB端口。USB是一个复杂得多的连接器，更像是一个发送数据包的网络连接，而不是像老式的Unix TTY连接那样的单个字符。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/f07551641d2012a4d30fd01cc052180d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*imiep38B4CZYXThCXx6ivA.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">RS-232和USB连接器比较</figcaption></figure><p id="c5fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过模拟串行连接的软件接口，我们可以编写代码来与Arduino等微控制器通信，就好像我们通过老式的RS-232端口连接到它一样。在Arduino板上有一个USB连接器，它是一个可以转换成串行连接的硬件。因此，Arduino板上的AVR微控制器认为它正在通过串行电缆进行通信。它允许我们为通信链路两端的串行通信编写代码。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/a5f9063364521f6854ed945fdf420476.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Sy4r8iug9VCH1Hiw50A1iQ.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">Arduino UNO板作为USB-B端口。该板使用USB转串行硬件转换器。</figcaption></figure><p id="717b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你用USB线将Arduino插入Mac，就会弹出一个设备文件，比如<code class="fe lr ls lt lu b">/dev/cu.usbserial-10</code>。确切的名称会有所不同。你只要写下<code class="fe lr ls lt lu b">ls /dev/cu.*</code>就能找到它们。为什么是<code class="fe lr ls lt lu b">/dev/cu*</code>的名字而不是<code class="fe lr ls lt lu b">/dev/tty*</code>？前者用于模型拨号。你可以坐在家里，用你的终端通过调制解调器拨号到Unix主机。<code class="fe lr ls lt lu b">/dev/tty*</code>设备是供Unix主机大楼里的人直接连接的。</p><p id="f970" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关键区别在于RS-232端口上DTR(数据终端就绪)控制信号的使用。一个与DTR对话的程序将被阻止，直到DTR发出信号。一台电传打字机会向DTR发送一个信号，表示它已准备好进行通信。</p><p id="0d4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于调制解调器来说，这有一点不同，因为最初你给调制解调器的命令是关于与谁连接以及如何连接。所以在这种情况下，DTR被用来表示已经建立了连接。因此调制解调器将使用CU设备。</p><p id="045a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这不是一个太大的弯路。我详细阐述了这一点，是为了让大家明白，对于硬件层面上正在发生的事情，有许多方法可以呈现不同的外观，以及为什么这通常是有用的。</p><p id="6370" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管我们已经经历了这一切，但我仍然没有解释任何有助于理解为什么终端仿真器非常复杂，并且可以配置为仿真许多终端，如VT100、xterm、ANSI、rxvt等。</p><h1 id="928f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">控制代码和终端仿真器</h1><p id="0917" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">如果一个终端必须发送和接收的只是可见字符，那么一切都将非常简单。问题是我们需要的不仅仅是可见的角色。当向终端发送文本时，您需要一种方法来告诉它开始新的一行或开始新的一行。如果它有不同颜色的墨盒，你需要一种方法来告诉它改变打印在纸上的颜色。</p><p id="cccd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用户可能想要编辑或修改文本。因此，我们需要能够向前、向后、上下、下一页、删除一行等等移动光标。为了表现所有这些“看不见的”角色，我们开发了控制代码。不同的终端将使用不同的控制代码，这就是为什么它们不会彼此兼容的原因。</p><p id="a360" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，出现了一个ANSI标准，这是今天大多数使用终端的人将使用的标准。如果您曾经用C或受C启发的语言编程过，那么您可能知道其中的许多:</p><ul class=""><li id="0ea4" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ob mb mc md bi translated"><strong class="kw iu">换行</strong> <code class="fe lr ls lt lu b">0x0A</code> <code class="fe lr ls lt lu b">\n</code> -移动到下一行。用C代码写成<code class="fe lr ls lt lu b">\n</code>。在普通的Unix终端上，通过按Ctrl-J将它发送到TTY</li><li id="37b4" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><strong class="kw iu">回车</strong> <code class="fe lr ls lt lu b">0x0D</code> <code class="fe lr ls lt lu b">\r</code> -移动到行首。用Ctrl-M发送到TTY</li><li id="ef3e" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><strong class="kw iu">退格键</strong> <code class="fe lr ls lt lu b">0x08</code> <code class="fe lr ls lt lu b">\b</code> -向后(向左)移动一个字符，通常是删除原来的一个字母。用Ctrl-H发送到TTY</li><li id="d615" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><strong class="kw iu">标签</strong> <code class="fe lr ls lt lu b">0x09</code> <code class="fe lr ls lt lu b">\t</code> -右移8格。用Ctrl-I发送。</li><li id="d164" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><strong class="kw iu">垂直标签</strong> <code class="fe lr ls lt lu b">0x0B</code> <code class="fe lr ls lt lu b">\v</code> -垂直标签。向下移动。</li><li id="a571" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><strong class="kw iu">转义</strong> <code class="fe lr ls lt lu b">0x1B</code> <code class="fe lr ls lt lu b">\e</code>或<code class="fe lr ls lt lu b">\x</code> -开始一个转义序列或退出一些当前模式。与<code class="fe lr ls lt lu b">Ctrl-[</code>一起发送</li><li id="9a12" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><strong class="kw iu">EOT</strong>—<code class="fe lr ls lt lu b">0x04</code>—传输结束。当你按下<code class="fe lr ls lt lu b">Ctrl-D</code>时，你告诉终端你已经完成了字母的输入。你会经常看到这被称为<code class="fe lr ls lt lu b">EOF</code>，因为它可以用来在另一端引起一个文件结束条件。但是<code class="fe lr ls lt lu b">EOF</code>更多的是条件。文件的结尾不存储字符值<code class="fe lr ls lt lu b">0x04</code>，它们只是结束。</li></ul><p id="e5a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您知道您不是按Ctrl-J在终端中键入命令。相反，你是在敲真正的回车键。这是怎么回事？这是终端模拟器复杂性的一部分。您的终端模拟器将您点击return键、tab键和escape键转换为Ctrl-J和Ctrl-I等组合键，在某些情况下，您甚至可能想要更改这种映射。实际上，您可以查询您的TTY，以了解各种控制字符(cchars)是如何配置的:</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="e8e1" class="ng mk it lu b gy nw nx l ny nz">❯ stty -a<br/>speed 38400 baud; 15 rows; 69 columns;<br/>lflags: icanon isig iexten echo echoe echok echoke -echonl echoctl<br/>	-echoprt -altwerase -noflsh -tostop -flusho pendin -nokerninfo<br/>	-extproc<br/>iflags: -istrip icrnl -inlcr -igncr -ixon -ixoff ixany imaxbel iutf8<br/>	-ignbrk brkint -inpck -ignpar -parmrk<br/>oflags: opost onlcr -oxtabs -onocr -onlret<br/>cflags: cread cs8 -parenb -parodd hupcl -clocal -cstopb -crtscts -dsrflow<br/>	-dtrflow -mdmbuf<br/>cchars: discard = ^O; dsusp = ^Y; eof = ^D; eol = &lt;undef&gt;;<br/>	eol2 = &lt;undef&gt;; erase = ^?; intr = ^C; kill = ^U; lnext = ^V;<br/>	min = 1; quit = ^\; reprint = ^R; start = ^Q; status = ^T;<br/>	stop = ^S; susp = ^Z; time = 0; werase = ^W;</span></pre><p id="d684" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有如此多的转义码来做不同的事情，以至于当我们只有7或8位可用时，我们会很快用完字符。为此，有人制作了<em class="oa">转义码</em>。它们以escape键(ASCII码<code class="fe lr ls lt lu b">0x1B</code>)开始，并允许我们使用多个字符来指定我们想要的操作。如今使用的通用标准被称为<a class="ae lq" href="https://en.wikipedia.org/wiki/ANSI_escape_code" rel="noopener ugc nofollow" target="_blank"> ANSI转义码</a>。这里有一个有用的<a class="ae lq" href="https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797" rel="noopener ugc nofollow" target="_blank">备忘单</a>。</p><p id="9550" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">转义码允许我们做很多事情，比如移动光标到一个特定的位置，改变字符的颜色，清空屏幕，甚至切换换行。文本模式编辑器，如Emacs、Vim、Pico和<a class="ae lq" href="https://kakoune.org" rel="noopener ugc nofollow" target="_blank"> Kakoune </a>(用户友好的Vim)广泛使用这些转义码来创建基于文本的界面。一些例子:</p><ul class=""><li id="a9ff" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ob mb mc md bi translated"><code class="fe lr ls lt lu b">ESC[H</code> -移动到初始位置(0，0)。</li><li id="7127" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><code class="fe lr ls lt lu b">ESC[nA</code> -将光标上移<code class="fe lr ls lt lu b">n</code>行。</li><li id="4749" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><code class="fe lr ls lt lu b">ESC[n;mH</code> -移动到屏幕上的位置(n，m)。</li><li id="1a44" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><code class="fe lr ls lt lu b">ESC[0m</code> -重置所有模式和颜色。</li><li id="28c7" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><code class="fe lr ls lt lu b">ESC[31m</code> -将文本变成红色。</li></ul><p id="c9e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以启动一种编程语言，比如Julia或Python，并尝试这些转义码。这是一些Julia代码，它变成红色文本，写一些字母，然后进行重置。</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="8c2c" class="ng mk it lu b gy nw nx l ny nz">❯ julia<br/><br/>julia&gt; println("\e[31m Hello world \e[0m")<br/> Hello world</span></pre><p id="cf75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你也可以用Python来做，只是有点笨拙，因为你不能使用<code class="fe lr ls lt lu b">\e</code>转义码:</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="7160" class="ng mk it lu b gy nw nx l ny nz">❯ python<br/><br/>&gt;&gt;&gt; print("\x1b[31m Hello world \x1b[0m")<br/> Hello world</span></pre><p id="fe27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也可以在Unix终端本身实现这一点。不同的外壳支持它。我无法让它在Z Shell <code class="fe lr ls lt lu b">zsh</code>和Bourne Again Shell <code class="fe lr ls lt lu b">bash</code>上运行。然而，我让它在Fish shell <code class="fe lr ls lt lu b">fish</code>中工作。人们只需记住要避开方括号。</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="374c" class="ng mk it lu b gy nw nx l ny nz">❯ echo \e\[31mhello\e\[0m world<br/>hello world</span></pre><h1 id="5531" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">终端、文件描述符和管道</h1><p id="8505" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">我们越来越接近对终端如何工作有一个更完整的了解。有一个关键的缺失点:Unix命令和程序如何将它们的输出定向到正确的终端？有时，一个程序远程运行，需要通过网络上的伪终端发送它们的输出。</p><p id="e8bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，Unix程序远比这更灵活。不仅可以将输出发送到不同的终端，还可以发送到完全不同的文件。例如，如果我输入<code class="fe lr ls lt lu b">ls</code>，我会得到一个发送到我默认的TTY终端的目录列表。但是，如果写<code class="fe lr ls lt lu b">ls &gt; foo.txt</code>这个清单会被发送到一个名为<code class="fe lr ls lt lu b">foo.txt</code>的文件中。<code class="fe lr ls lt lu b">rev</code>命令通常会撤销我写的所有内容(按Ctrl-D退出)</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="0aed" class="ng mk it lu b gy nw nx l ny nz">❯ rev<br/>hello<br/>olleh<br/>world<br/>dlrow</span></pre><p id="0b95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是完全有可能通过编写<code class="fe lr ls lt lu b">rev &lt; foo.txt</code>从文件中获得对<code class="fe lr ls lt lu b">rev</code>的输入。这里有一个例子，我们创建了一个文件，稍后我们使用重定向符号<code class="fe lr ls lt lu b">&lt;</code>将该文件的内容提供给<code class="fe lr ls lt lu b">rev</code>。</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="a4b2" class="ng mk it lu b gy nw nx l ny nz">❯ cat &gt; hello.txt<br/>hello<br/>world  # Press Ctrl-D<br/><br/>❯ cat hello.txt<br/>hello<br/>world<br/><br/>❯ rev &lt; hello.txt<br/>olleh<br/>dlrow</span></pre><p id="dfea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你运行一个像<code class="fe lr ls lt lu b">rev</code>这样的程序时，你创建了一个<em class="oa">进程</em>(内存中运行程序的表示)。一个Unix进程使用编号为<em class="oa">的文件描述符</em>与文件通信。在幕后，当您打开一个文件时，会创建一个文件描述来引用该文件。</p><p id="5843" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个Unix进程有3个文件描述符，编号为0、1和2，它们总是打开的。这些代表:</p><ul class=""><li id="9f4b" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ob mb mc md bi translated">标准输入—标准输入</li><li id="a581" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated">标准输出—标准输出</li><li id="21f7" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated">标准错误—标准错误</li></ul><p id="2a9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其实你可以把它们看成<code class="fe lr ls lt lu b">/dev</code>下的文件。在这里，您可能会发现不同Unix操作系统之间的差异。我正在描述这是如何在macOS上工作的。这些文件中的每一个都是到编号文件描述符(fd)的链接。</p><ul class=""><li id="8ab1" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ob mb mc md bi translated"><code class="fe lr ls lt lu b">/dev/stdin</code> -链接到<code class="fe lr ls lt lu b">/dev/fd/0</code></li><li id="e600" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><code class="fe lr ls lt lu b">/dev/stdout</code> -链接到<code class="fe lr ls lt lu b">/dev/fd/1</code></li><li id="b2a1" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><code class="fe lr ls lt lu b">/dev/stderr</code> -链接到<code class="fe lr ls lt lu b">/dev/fd/2</code></li></ul><p id="e2de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这些例子中，我们将主要忽略<code class="fe lr ls lt lu b">stderr</code>并关注<code class="fe lr ls lt lu b">stdin</code>和<code class="fe lr ls lt lu b">stdout</code>。你可以把一个进程想象成有三个插座，分别标为<code class="fe lr ls lt lu b">stdin</code>、<code class="fe lr ls lt lu b">stdout</code>和<code class="fe lr ls lt lu b">stderr</code>，我们可以在那里插入不同的文件或类似文件的对象。在下图中，我只是展示了连接器，并将其缩短为<code class="fe lr ls lt lu b">in</code>和<code class="fe lr ls lt lu b">out</code>。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/eab9cc55ecf5db93774d14b230cf30a2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ipbsUhC20odJxOVBiQlsGQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">重定向来自文件的输入</figcaption></figure><p id="fd77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，<code class="fe lr ls lt lu b">/dev/stdin</code>和<code class="fe lr ls lt lu b">/dev/stdout</code>指向我们的默认终端<code class="fe lr ls lt lu b">/dev/tty</code>，它又指向一个特定的伪终端，比如<code class="fe lr ls lt lu b">/dev/ttys001</code>。使用<code class="fe lr ls lt lu b">&lt;</code>和<code class="fe lr ls lt lu b">&gt;</code>重定向符号，我们可以改变我们的进程实际插入的文件描述符的输入和输出。</p><p id="fdec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种抽象的一个巧妙创新是管道的概念。管道有点像文件，只是两个进程可以同时打开它。一个进程写入它，另一个进程读取它。</p><p id="036e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以用<code class="fe lr ls lt lu b">mkfifo</code>命令制作这样一个管道。我们正在制作一个名为<code class="fe lr ls lt lu b">tube</code>的管道。</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="11db" class="ng mk it lu b gy nw nx l ny nz">❯ mkfifo tube<br/><br/>❯ file tube<br/>tube: fifo (named pipe)</span></pre><p id="6814" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将在文件系统中创建一个名为<code class="fe lr ls lt lu b">tube</code>的条目，即使在您重启后它也将保留在那里。但是，从命名管道写入和读取的数据从不存储在磁盘上。它完全是在内存中处理的。让我们看看这在实践中是如何实现的。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/9f1e169a24e1290431f7a01cfd2ab30e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Jk3GNuOdQE2tsJ_Q9xIHtA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">设置命名管道通信</figcaption></figure><p id="6f74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你需要两个终端窗口来完成这项工作。在一个窗口中，你写下<code class="fe lr ls lt lu b">rev &lt; tube</code>，这意味着你试图从命名管道中读取。在另一个窗口中，你写下<code class="fe lr ls lt lu b">cat &gt; tube</code>，这意味着你在键盘上写的任何东西都将被发送到<code class="fe lr ls lt lu b">tube</code>中，并且<code class="fe lr ls lt lu b">rev</code>进程将意识到它可以从电子管中读取。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/a133aa7aac356a0960cf6e284286a71f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*fCxzAMWu3s3nfyKRvCJWFg.png"/></div></figure><p id="a7f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大多数时候我们不需要命名管道。我们对管道的名称或永久保留它不感兴趣。我们很乐意临时创建一个管道，这样我们就可以轻松地将数据从一个命令传递到另一个命令。我们可以使用管道<code class="fe lr ls lt lu b">|</code>字符来创建这样的管道。</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="2af4" class="ng mk it lu b gy nw nx l ny nz">❯ echo hello | rev<br/>olleh</span></pre><p id="f4d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从概念上讲，我们仍然创建了一个有两端的管道:一端用于写，另一端用于读，但是我们还没有给它命名。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/bbe9929fd8565297173b7b755cc4c9b2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*vnibgmWDDM6ay-WQMyrQnQ.png"/></div></figure><p id="e4f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">管道可以以复杂的方式组合，允许我们将许多不同命令提供的功能链接在一起。让我们看一个将<code class="fe lr ls lt lu b">ls</code>、<code class="fe lr ls lt lu b">head</code>和<code class="fe lr ls lt lu b">sort</code>链接在一起的例子:</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="a61f" class="ng mk it lu b gy nw nx l ny nz">❯ touch hotel golf foxtrot echo<br/><br/>❯ ls | head -3<br/>echo<br/>foxtrot<br/>golf<br/><br/>❯ ls | head -3 | sort -r<br/>golf<br/>foxtrot<br/>echo</span></pre><p id="dfd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">head -3</code>命令选择前三行，而<code class="fe lr ls lt lu b">sort -r</code>将反向排序输入。从概念上讲，进程的stdout和stdin通过管道连接，如下所示:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/351ef118b608d9d1724b14c30a82ddbc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4KYJkQqihn-39ejt6TFqFw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">使用管道将三个命令链接在一起的示例。</figcaption></figure><p id="35f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些管道例子巩固了Unix将输入和输出重定向到不同地方的能力，而相关的程序并不知道发生了什么。<code class="fe lr ls lt lu b">ls</code>命令不需要知道它发送的输出是去往管道、另一个文件，还是telnet客户端创建的伪终端。它甚至可以伪装成串行连接，通过USB电缆发送数据。</p><p id="db67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，当你用代码<code class="fe lr ls lt lu b">print("hello world")</code>创建一个简单的程序时，很多事情会在幕后发生:</p><ul class=""><li id="8f1a" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ob mb mc md bi translated">文本被写入文件<code class="fe lr ls lt lu b">/dev/stdout</code>，但这只是一个到<code class="fe lr ls lt lu b">/dev/fd/1</code>的链接</li><li id="830a" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><code class="fe lr ls lt lu b">/dev/fd/1</code>将再次指向<code class="fe lr ls lt lu b">/dev/tty</code>，这是您当前的TTY设备。</li><li id="c029" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ob mb mc md bi translated"><code class="fe lr ls lt lu b">/dev/tty</code>将指向一个实际的伪终端，例如<code class="fe lr ls lt lu b">/dev/ttys001</code>，它指向一个实际的终端仿真器窗口。</li></ul><p id="0a0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是“hello world”如何被发送到用户界面中的正确窗口。当然<code class="fe lr ls lt lu b">/dev/stdout</code>可以被重定向，在这种情况下，文本会被放到其他地方。</p><h1 id="d4fd" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">终端与外壳</h1><p id="0a46" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">Unix终端实际上只是一种将字符输入到<code class="fe lr ls lt lu b">/dev/tty</code>设备并从同一设备读取字符和控制字符的方法。终端本身并不提供太多的功能。</p><p id="b6f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了能够解析用户输入，将输入解释为运行和显示结果的命令，我们需要一个Unix Shell。Shell管理诸如prompt之类的东西，您可以在这里编写命令。</p><p id="ef0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">shell执行作业管理，比如让您在不同的运行进程之间切换，以防一个进程需要很长时间才能完成。不是每个shell都有相同的语法。从很多方面来说，你可以把Python、Ruby和Julia这样的编程语言看作是它们自身的外壳。然而，这些编程环境不太适合作为Unix shells，因为文件、进程、程序、目录和管道都不是一级对象。</p><p id="157c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像<code class="fe lr ls lt lu b">bash</code>这样的Unix shell不适合作为通用编程语言，但是它们擅长文件管理和作业控制。下图总结了端子和外壳之间的关系。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/c0618d252290fb354f23519e8f6d080d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*_fcS66nOYztUamKBj_fn3w.png"/></div></figure><p id="fea8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上图中，我把终端画成了物理设备。在现代世界，这当然是罕见的。它们通常以终端模拟器的形式存在于一些窗口系统中。</p><p id="3e19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您打开一个终端模拟器窗口时，它将运行<code class="fe lr ls lt lu b">login</code>程序，该程序将生成您的shell。如果您在macOS上，它将启动<code class="fe lr ls lt lu b">/etc/shells</code>文件中列出的一个shells:</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="2bb0" class="ng mk it lu b gy nw nx l ny nz">❯ cat /etc/shells<br/>/bin/bash<br/>/bin/csh<br/>/bin/ksh<br/>/bin/sh<br/>/bin/tcsh<br/>/bin/zsh<br/>/usr/local/bin/fish</span></pre><p id="52ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以看到这些年来制造了很多贝壳。在现代的macOS上，Z Shell <code class="fe lr ls lt lu b">zsh</code>已经成为默认，尽管Linux和macOS长期以来都使用Bourn Again Shell <code class="fe lr ls lt lu b">bash</code>作为默认。</p><p id="a8c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在过去，<code class="fe lr ls lt lu b">login</code>程序查看<code class="fe lr ls lt lu b">/etc/passwd</code>文件来登录用户。在那里，系统可以检查给定的用户是否存在以及是否给出了正确的密码。之后<code class="fe lr ls lt lu b">login</code>可以启动配置好的外壳。每个像在<code class="fe lr ls lt lu b">/etc/passwd</code>文件中的样子都是这样的:</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="78c3" class="ng mk it lu b gy nw nx l ny nz">tommy:x:1000:1000::/home/tommy:/bin/bash</span></pre><p id="99b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每一行都给出了用户名、主目录和要运行的shell。由于安全原因，这个文件已经失去了它的重要性。您不能再直接访问密码文件。黑客很容易利用它来进行字典攻击。相反，我们使用命令来修改用户数据，比如更改要使用的shell。要更改默认外壳，我们使用<code class="fe lr ls lt lu b">chsh</code>(更改外壳)命令。这是我如何改变使用<code class="fe lr ls lt lu b">fish</code>外壳:</p><pre class="ki kj kk kl gt ns lu nt nu aw nv bi"><span id="0ef0" class="ng mk it lu b gy nw nx l ny nz">❯ chsh -s /usr/local/bin/fish</span></pre><p id="b20a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不可能在一篇文章中涵盖Unix终端和shells的所有内容，所以我将在链接中添加相关的故事。</p><h1 id="889d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">相关故事</h1><p id="1fbd" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">与Unix、shells和终端相关的商店。</p><ul class=""><li id="df68" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ob mb mc md bi translated"><a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/unix-command-line-crash-course-453e409d62f5"> Unix命令行速成班</a>——重点讲解如何使用Unix命令。面向绝对的初学者。避免进入技术细节。</li></ul></div></div>    
</body>
</html>