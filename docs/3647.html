<html>
<head>
<title>Algebraic Data Types and Pattern Matching in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的代数数据类型和模式匹配</h1>
<blockquote>原文：<a href="https://itnext.io/algebraic-data-types-and-pattern-matching-in-scala-96859310a624?source=collection_archive---------3-----------------------#2020-01-23">https://itnext.io/algebraic-data-types-and-pattern-matching-in-scala-96859310a624?source=collection_archive---------3-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/86d92d4bb152aeebab591e4409d73c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7zKjE0bIN7pzZaU_y5558Q.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@franki?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗兰基·查马基</a>在<a class="ae kf" href="https://unsplash.com/s/photos/data-engineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9593" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代数数据类型(ADT)听起来像代码设计原则，但实际上它可以被看作是对代码进行分类的一种方式。由于模式匹配，它被广泛使用，它鼓励您避免使用非法的数据状态。</p><p id="16b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用Scala时，如果您使用带有不可变字段的<code class="fe le lf lg lh b">case class</code> es创建数据模型，而<code class="fe le lf lg lh b">case object</code>数据类型没有方法，那么您已经在编写ADT了。这使您能够通过类型创建富有表现力的、灵活的领域建模。</p><p id="8b5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在我们查看不同ADT类型的示例之前，让我们先来看几个相关的重要术语。</p><h1 id="4f39" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">编程中的代数是什么？</h1><p id="5522" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在编程中，抽象是关键。将现实生活中的概念转化为数字和关系，是我们每天在工作中所做的事情。代数是一切之母。</p><p id="75f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理论上，代数可以被认为是:</p><ul class=""><li id="1cd1" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">一组物体</li><li id="940c" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">可以应用于这些对象以创建新对象的操作</li></ul><h2 id="a4bf" class="mz lj it bd lk na nb dn lo nc nd dp ls kr ne nf lw kv ng nh ma kz ni nj me nk bi translated">数字代数</h2><p id="26ca" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">通过使用(a)整数(对象集)和(b)可用于这些对象的运算(+、—、*、/)，我们创建了新的数字(对象)。</p><pre class="nl nm nn no gt np lh nq nr aw ns bi"><span id="3572" class="mz lj it lh b gy nt nu l nv nw">1 + 1 = 2<br/>2 * 2 = 4</span></pre><h2 id="2cef" class="mz lj it bd lk na nb dn lo nc nd dp ls kr ne nf lw kv ng nh ma kz ni nj me nk bi translated">关系代数</h2><p id="fe2c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">这可以看作是一个关系数据库。(a)数据库表是“对象集”,( b) SELECT、UPDATE和JOIN是允许您创建新对象的“操作符”。</p><h2 id="3bcb" class="mz lj it bd lk na nb dn lo nc nd dp ls kr ne nf lw kv ng nh ma kz ni nj me nk bi translated">代码中的代数</h2><p id="caf3" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">下面是一个如何创建Scala操作符来从现有数据类型创建新数据类型的例子:</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="9477" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过<code class="fe le lf lg lh b">sealed trait</code>,我们保留了扩展抽象数据的一组有限的可能值。通过这样做，编译器可以检查我们的函数是否处理了所有可能的值。此外，编译器确保密封特征只能在定义它的文件中扩展。</p><p id="4138" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有三种代数数据类型。让我们在下一节看看代数数据类型的例子。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><h1 id="99cc" class="li lj it bd lk ll og ln lo lp oh lr ls lt oi lv lw lx oj lz ma mb ok md me mf bi translated">总和类型</h1><p id="b00e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">它只是枚举了该类型所有可能的实例。它的arity等于组成它的类型的arity之和。它也被称为“枚举类型”。关于总和类型的要点是:</p><ul class=""><li id="817c" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">通常以<code class="fe le lf lg lh b">sealed trait</code>作为基本类型创建</li><li id="0348" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">实例创建为<code class="fe le lf lg lh b">case object</code></li><li id="8473" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">当谈到和类型时，我们使用短语“是a”和“或”。例如，星期一<em class="ol">是</em>类型的一天，而一天是星期二<em class="ol">或</em>星期三<em class="ol">或</em>星期四<em class="ol">或</em> …</li></ul><p id="f43e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一些Sum类型的示例:</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="baa6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它本质上是一种在一个像元组一样的结构中输入多个值的方法。它的arity可以通过乘以所有构造函数字段可以获得的可能性的数量来计算。</p><p id="5809" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最简单的例子是使用布尔函数:</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2e5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于boolean可以有2种可能，而<code class="fe le lf lg lh b">Foo</code>有2个字段，所以它的arity是2*2 = 4。因此我们可以创建4种不同类型的<code class="fe le lf lg lh b">Foo</code>。</p><p id="9e42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，如何才能知道其他类型能有多少种可能性呢？以下是简短的答案列表:</p><ul class=""><li id="33ff" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">Nothing</code>有0个可能的值</li><li id="4572" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">Unit</code>有1个可能值</li><li id="61b7" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">Bool</code>有两个可能的值</li><li id="6bad" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">Byte</code>有256个可能值</li><li id="29da" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">Int</code>有232个可能的值</li><li id="2b64" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">String</code>有无限可能的值</li></ul><p id="beb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上，类型越少，代码就越简单。</p><p id="a1e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们看更多的例子之前，这里是产品类型用法的重要部分:</p><ul class=""><li id="78fe" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">一般用<code class="fe le lf lg lh b">final case class</code>创建</li><li id="a1e7" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">当谈论产品类型时，我们使用短语“has a”和“and”。Foo <em class="ol">有一个</em>字段1 <em class="ol">和</em>字段2。</li><li id="51ad" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">产品类型可以是递归的</li></ul><p id="8fdb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是几个产品类型示例:</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="449b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">模式匹配</h1><p id="aeab" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">使用模式匹配时，ADTs使您的生活更加轻松。</p><p id="2622" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模式匹配允许您使用提取器方法分解给定的ADT。它基本上提取了产品类型的字段。为此，case类的伴随对象需要实现<code class="fe le lf lg lh b">unapply</code>方法，以便成为提取器。</p><p id="9e98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们使用<code class="fe le lf lg lh b">sealed trait</code>定义一个代数数据类型时，如果我们在模式检查中遗漏了一个case条件，编译器会对我们大喊大叫。</p><p id="efa5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看scala文档中关于<a class="ae kf" href="https://docs.scala-lang.org/tour/pattern-matching.html" rel="noopener ugc nofollow" target="_blank">模式匹配</a>的例子:</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="fb2d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="3b2e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">当您使用代数数据类型时，对数据进行分类会使您的生活更加轻松。这将使您能够使用更强大的switch语句版本，如模式匹配，使您的代码更容易推理。</p></div></div>    
</body>
</html>