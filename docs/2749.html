<html>
<head>
<title>Elixir + Kubernetes = 💜 (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">仙丹+ Kubernetes =💜(第一部分)</h1>
<blockquote>原文：<a href="https://itnext.io/elixir-plus-kubernetes-part-1-80129eab14f0?source=collection_archive---------0-----------------------#2019-07-26">https://itnext.io/elixir-plus-kubernetes-part-1-80129eab14f0?source=collection_archive---------0-----------------------#2019-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ff02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何使用Elixir 1.9设置和自动扩展Elixir集群</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/60603126738aac241cac2cf8628de07f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyeXtobbr8z8mAQNIi2xvA.png"/></div></div></figure><blockquote class="kx ky kz"><p id="02ad" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">这是关于如何创建和部署能够在Kubernetes上自动伸缩的Elixir应用程序的系列文章的第1部分。<a class="ae le" href="https://medium.com/@groksrc/https-medium-com-groksrc-elixir-plus-kubernetes-part-2-a0579473d7f9" rel="noopener">第二部分</a>和<a class="ae le" href="https://medium.com/@groksrc/elixir-kubernetes-part-3-9bbd71c9c370" rel="noopener">第三部分</a>也可用。如果你只是想看源代码，可以在这里找到:【https://github.com/groksrc/el_kube<a class="ae le" href="https://github.com/groksrc/el_kube" rel="noopener ugc nofollow" target="_blank"/>如果你只是想看命令的摘要，可以在这里<a class="ae le" href="https://docs.google.com/presentation/d/1xN2Mi_Q-TfwGHNnJ3OczKTvhq_bFyOcMNBa1H4NPMak/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank">找到原话的幻灯片。</a></p></blockquote><p id="8979" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本系列旨在向您展示如何使用Elixir 1.9和Kubernetes创建自动伸缩的Elixir集群。那是什么意思？这意味着应用程序将启动，在erlang集群配置中自动连接，然后随着Kubernetes (k8s)配置的变化自动添加和删除erlang节点。</p><p id="caed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第1部分中，我们将着眼于创建应用程序本身。第2部分将向您展示如何对应用程序进行Dockerize，并确认容器可以工作。最后，在第3部分中，我们将使用minikube在Kubernetes上启动应用程序，并演示它如何随着部署的变化而自动伸缩。我们开始吧！</p><h1 id="c9b2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第1部分—创建应用程序</h1><p id="45af" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在你开始之前，你要确保你已经安装了<a class="ae le" href="https://elixir-lang.org/install.html" rel="noopener ugc nofollow" target="_blank">药剂1.9 </a>和OTP 22。您还需要确保您使用的是当前版本的<a class="ae le" href="https://hexdocs.pm/phoenix/installation.html#content" rel="noopener ugc nofollow" target="_blank"> Phoenix </a>，在撰写本文时是1.4.9版。此外，确保安装了<a class="ae le" href="https://github.com/kubernetes/minikube" rel="noopener ugc nofollow" target="_blank"> minikube </a>并且<a class="ae le" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>配置为使用minikube上下文。</p><p id="3dbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的应用程序将被命名为<code class="fe mi mj mk ml b">el_kube</code>，顺便说一句，所有这些代码都可以在我在<a class="ae le" href="https://github.com/groksrc/el_kube" rel="noopener ugc nofollow" target="_blank">https://github.com/groksrc/el_kube</a>的回购中获得。我在master中从一个空项目开始，然后在每个分支中，我只更改进行下一步所必需的文件。我最初在Simpli.fi技术讲座上展示了这项工作，因此您应该能够直接从<a class="ae le" href="https://docs.google.com/presentation/d/1xN2Mi_Q-TfwGHNnJ3OczKTvhq_bFyOcMNBa1H4NPMak/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank">幻灯片组</a>中发出命令并更改文件。如果你遇到任何麻烦，给我一个回复，我会尽力帮忙的。</p><h2 id="1601" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">00:新项目</h2><p id="5bcd" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">让我们从开发机器上的工作目录开始一个新的Phoenix项目。我把我的叫做el_kube，因为长生不老药和Kubernetes搅在一起。</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="d796" class="mm lg iq ml b gy nc nd l ne nf">$ mix phx.new el_kube</span></pre><p id="5957" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当被要求“获取并安装依赖项”时，一定要说“是”。[Yn]"</p><h2 id="e495" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">01:打开项目</h2><p id="1657" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">现在让我们切换到项目文件夹并打开我们的编辑器。以下所有命令都是从项目文件夹的根目录发出的。此外，我将<a class="ae le" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> vscode </a>与ElixirLS插件一起使用，因此您正在使用git，您可能希望添加。elixir_ls/文件夹添加到. gitignore。</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="101e" class="mm lg iq ml b gy nc nd l ne nf">$ cd el_kube &amp;&amp; code .</span></pre><h2 id="9676" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">02:编辑mix.exs</h2><p id="135e" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">项目在编辑器中打开后，弹出到项目根目录下的mix.exs文件。我们将在这里进行三项更改。</p><p id="3014" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先把<code class="fe mi mj mk ml b">project</code>键从1.5更新到1.9。这个项目需要使用Elixir 1.9。</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="11b1" class="mm lg iq ml b gy nc nd l ne nf">elixir: "~&gt; 1.9",</span></pre><p id="4141" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将添加对贵族的依赖，并设置<a class="ae le" href="https://github.com/mrluc/peerage" rel="noopener ugc nofollow" target="_blank">贵族</a>在启动时作为<code class="fe mi mj mk ml b">extra_application</code>启动。正如自述文件中所说，Peerage可以帮助erlang节点找到彼此。我们会用它来提供秘方让它发挥作用。</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="230a" class="mm lg iq ml b gy nc nd l ne nf">def application do<br/>  [<br/>    mod: {ElKube.Application, []},<br/>    extra_applications: [:logger, :runtime_tools, :peerage]<br/>  ]<br/>end</span></pre><p id="164a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和...</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="1674" class="mm lg iq ml b gy nc nd l ne nf">defp deps do<br/>    [<br/>      <!-- -->{:phoenix, "~&gt; 1.4.9"},<br/>      {:phoenix_pubsub, "~&gt; 1.1"},<br/>      {:phoenix_ecto, "~&gt; 4.0"},<br/>      {:ecto_sql, "~&gt; 3.1"},<br/>      {:postgrex, "&gt;= 0.0.0"},<br/>      {:phoenix_html, "~&gt; 2.11"},<br/>      {:phoenix_live_reload, "~&gt; 1.2", only: :dev},<br/>      {:gettext, "~&gt; 0.11"},<br/>      {:jason, "~&gt; 1.0"},<br/>      {:plug_cowboy, "~&gt; 2.0"},<br/>      {:peerage, "~&gt; 1.0"}<br/>    ]<br/>  end</span></pre><p id="785b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦这三个更改成为mix.exs，您就可以保存并关闭它。如果您的编辑器没有为您运行<code class="fe mi mj mk ml b">$ mix deps.get</code>，请不要忘记运行它。</p><h2 id="e8f3" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">02:初始化发布</h2><p id="3b8d" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">接下来，我们将使用新的mix命令为我们生成一些模板文件。这些模板文件用于帮助生成应用程序启动时执行的脚本。</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="e9c6" class="mm lg iq ml b gy nc nd l ne nf">$ mix release.init<br/>* creating rel/vm.args.eex<br/>* creating rel/env.sh.eex<br/>* creating rel/env.bat.eex</span></pre><p id="9294" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个命令在<code class="fe mi mj mk ml b">rel</code>目录中为您生成三个不同的Elixir模板。我们将忽略env.bat.eex。我不在windows上，但如果我在，我需要在那里应用相关的更改。相反，我将更新env.sh.eex，以便在启动时为我设置一些环境变量。</p><h2 id="e0f5" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">03:更新rel/env.sh.eex</h2><p id="1289" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在<code class="fe mi mj mk ml b">rel/env.sh.eex</code>中，我们将取消导出RELEASE_DISTRIBUTION和RELEASE_NODE的行的注释。然后将localhost IP更改为将动态传递的环境变量。对文件进行以下更改:</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="2343" class="mm lg iq ml b gy nc nd l ne nf">export RELEASE_DISTRIBUTION=name<br/>export RELEASE_NODE=&lt;%= @release.name %&gt;@${HOSTNAME}</span></pre><p id="2bea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将<code class="fe mi mj mk ml b">RELEASE_DISTRIBUTION</code>环境变量配置为<code class="fe mi mj mk ml b">name</code>将会配置erlang beam，使其能够使用长名称格式连接到集群中的其他节点。<code class="fe mi mj mk ml b">RELEASE_NODE</code>是使用长名称格式的erlang节点的名称。有关配置这些环境变量的更多详细信息，请参见mix <a class="ae le" href="https://hexdocs.pm/mix/Mix.Tasks.Release.html#module-environment-variables" rel="noopener ugc nofollow" target="_blank">任务文档</a>。</p><p id="3b92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于我们的目的，我们将动态传递k8s分配给容器的IP地址作为<code class="fe mi mj mk ml b">HOSTNAME</code>，但是您也可以在这里使用有效的集群DNS名称。把那个文件存起来，我们接着做下一个。</p><h2 id="2359" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">04:删除配置/产品.机密. exs</h2><p id="3dba" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">该文件不会被使用，因此我们将放弃它。</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="6939" class="mm lg iq ml b gy nc nd l ne nf">$ rm config/prod.secret.exs</span></pre><h2 id="c005" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">05:创建配置/版本. exs</h2><p id="e756" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">相反，我们将使用新的<code class="fe mi mj mk ml b">releases.exs</code>文件来帮助我们在启动时动态配置应用程序。让我们创建文件并在编辑器中打开它。</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="b75b" class="mm lg iq ml b gy nc nd l ne nf">$ touch config/releases.exs</span></pre><h2 id="2903" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">06:编辑配置/版本. exs</h2><p id="05dd" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">现在我们准备设置我们的动态配置。将此粘贴到文件中:</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="2b9c" class="mm lg iq ml b gy nc nd l ne nf">import Config<br/><br/>service_name = System.fetch_env!("SERVICE_NAME")<br/>db_url = System.fetch_env!("DB_URL")<br/>secret_key_base = System.fetch_env!("SECRET_KEY_BASE")<br/>port = System.fetch_env!("PORT")<br/><br/>config :el_kube, ElKube.Repo, url: db_url<br/><br/>config :el_kube, ElKubeWeb.Endpoint,<br/>  http: [port: port],<br/>  secret_key_base: secret_key_base,<br/>  url: [host: {:system, "APP_HOST"}, port: {:system, "PORT"}]<br/><br/>config :peerage, via: Peerage.Via.Dns,<br/>  dns_name: service_name,<br/>  app_name: "el_kube"</span></pre><p id="eb66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk ml b">service_name</code>将是应用程序的内部DNS名称。换句话说，集群上的一个节点将能够向DNS查询<code class="fe mi mj mk ml b">service_name</code>，并获得一个包含IP地址列表的响应。</p><p id="cdac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk ml b">db_url</code>是Postgres连接字符串。<code class="fe mi mj mk ml b">secret_key_base</code>用于Phoenix签署cookies，而<code class="fe mi mj mk ml b">port</code>是web端点将监听的端口。</p><p id="b90f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还会注意到在<code class="fe mi mj mk ml b">ElKubeWeb.Endpoint</code>中也加入了一个<code class="fe mi mj mk ml b">APP_HOST</code>环境变量。Phoenix有点古怪，因为在Elixir 1.9之前它确实允许一些动态配置。这里我们只是使用这个内置的构造来告诉Phoenix从环境中拉出<code class="fe mi mj mk ml b">APP_HOST</code>和<code class="fe mi mj mk ml b">PORT</code>。这两个值用于它的内部URL助手。把这份文件存档，然后转到下一份。</p><h2 id="e9c0" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">07:编辑配置/产品. exs</h2><p id="6a59" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">现在让我们看看生产配置文件。与以前的Elixir版本一样，特定于环境的配置位于基本config/config.exs之上，因此我们可以在这里设置一些不能更改的特定于生产的内容。首先，我们需要删除已经移到<code class="fe mi mj mk ml b">config/releases.exs</code>中的<code class="fe mi mj mk ml b">url</code>键，接下来我们需要添加端点配置键/值对<code class="fe mi mj mk ml b">server: true</code></p><p id="dc1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这告诉Phoenix在服务器启动时启动webserver端点。为什么这不是这个文件中的默认设置，我不确定，但是让我们做一些修改，然后继续。您的config/prod.exs文件现在应该是这样的。</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="b296" class="mm lg iq ml b gy nc nd l ne nf">use Mix.Config</span><span id="93e5" class="mm lg iq ml b gy ng nd l ne nf"># Lots of comments ...<br/>config :el_kube, ElKubeWeb.Endpoint,<br/>  cache_static_manifest: "priv/static/cache_manifest.json",<br/>  server: true</span><span id="1a12" class="mm lg iq ml b gy ng nd l ne nf"># Do not print debug messages in production<br/>config :logger, level: :info</span><span id="9fea" class="mm lg iq ml b gy ng nd l ne nf"># Lots more comments ...</span></pre><p id="57c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦！不要忘记向下滚动到文件的最底部，删除<code class="fe mi mj mk ml b">import_config "config/prod.secrets.exs"</code>，我在几次运行中错过了它，所以这就是我们之前删除它的原因。如果我们忘记了这一步，它现在会向我们抱怨。</p><h2 id="793a" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">08:编辑config/config.exs</h2><p id="8f5a" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">这一步不是完全必要的。当然，你可以在现实生活中任意配置你的应用程序。但出于演示的目的，我们将加入一些基本的Ecto配置，这样我们就可以证明它确实被选中了。打开config/config.exs文件并添加以下内容:</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="d4a0" class="mm lg iq ml b gy nc nd l ne nf">config :el_kube, ElKube.Repo,<br/>  adapter: Ecto.Adapters.Postgres,<br/>  pool_size: 10</span></pre><p id="c32d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再说一次，所有这些都可能不在这里。在现实生活中，您可能希望从config/releases.exs配置您的<code class="fe mi mj mk ml b">pool_size</code>,所以这纯粹是说教。</p><h2 id="dcc8" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">09:编辑配置/开发文件</h2><p id="cfc5" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">最后一个文件修改，我们就可以开始编译了。让我们在开发环境中让peerage开心，也因为我们通常不在开发模式下运行集群(peerage对此大声抱怨),让我们告诉它安静。将以下内容添加到config/dev.exs文件中:</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="699a" class="mm lg iq ml b gy nc nd l ne nf">config :peerage,<br/>  via: Peerage.Via.List,<br/>  node_list: [:"el_kube@127.0.0.1"],<br/>  log_results: false</span></pre><h2 id="437a" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">10:编译</h2><p id="de26" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">现在让我们切换到我们的终端，执行编译和冒烟测试。首先，我们需要为Phoenix的javascript端生成摘要文件。</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="8757" class="mm lg iq ml b gy nc nd l ne nf">$ mix phx.digest<br/>...<br/>==&gt; el_kube<br/>Check your digested files at "priv/static"</span></pre><p id="b3c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们生成发布:</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="1448" class="mm lg iq ml b gy nc nd l ne nf">$ MIX_ENV=prod mix release<br/>...<br/>...<br/>To list all commands:</span><span id="991d" class="mm lg iq ml b gy ng nd l ne nf">  _build/prod/rel/el_kube/bin/el_kube</span></pre><p id="89db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你看到了以上内容，你就取得了很大的进步！最后一步是为我们的应用程序创建一个数据库，以便在启动时进行连接。</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="a3af" class="mm lg iq ml b gy nc nd l ne nf">$ mix ecto.create<br/>The database for ElKube.Repo has been created</span></pre><p id="a61e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们准备运行发布，并确保它启动。这个命令必须传递我们之前考虑过的所有环境变量，除了一个我没有提到的变量<code class="fe mi mj mk ml b">RELEASE_COOKIE</code>。这一点在mix发布任务文档中也有涉及，但是我想在这里谈一下。<code class="fe mi mj mk ml b">RELEASE_COOKIE</code>是一种预共享密钥，erlang beam在节点连接时使用它进行身份验证。这里并没有严格的必要，但是我想在这里介绍它，因为您将在第3部分中再次看到它。</p><h2 id="6c5d" class="mm lg iq bd lh mn mo dn ll mp mq dp lp jy mr ms lt kc mt mu lx kg mv mw mb mx bi translated">11:烟雾测试</h2><p id="1cf7" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">下面是启动应用程序的命令:</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="9b0f" class="mm lg iq ml b gy nc nd l ne nf">DB_URL=ecto://postgres:postgres@localhost/el_kube_dev \<br/>RELEASE_COOKIE=foo \<br/>SECRET_KEY_BASE=foo \<br/>HOSTNAME=127.0.0.1 \<br/>SERVICE_NAME=localhost.svc \<br/>APP_HOST=localhost \<br/>PORT=4000 \<br/>_build/prod/rel/el_kube/bin/el_kube start</span></pre><p id="e804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经在上面介绍了所有这些环境变量的作用，所以我不再赘述。这里的新内容是，我们实际上正在执行我们的应用程序并传递start命令。执行此操作时，您应该会看到以下内容:</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="986b" class="mm lg iq ml b gy nc nd l ne nf">15:20:47.765 [info] Running ElKubeWeb.Endpoint with cowboy 2.6.3 at 0.0.0.0:4000 (http)<br/>15:20:47.765 [info] Access ElKubeWeb.Endpoint at <a class="ae le" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank">http://localhost:4000</a></span></pre><p id="1277" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你可以打开浏览器到那个地址或<code class="fe mi mj mk ml b">$ curl <a class="ae le" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank">http://localhost:4000</a></code>，你应该会看到一个网页回来。如果是的话，你就成功了！</p><p id="fbfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们通过启动另一个终端并连接到这个正在运行的实例来确认我们的数据库连接正在工作。一切都和前面的命令一样，除了这次不是在最后传递start，而是传递<code class="fe mi mj mk ml b">remote</code>参数:</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="c4e0" class="mm lg iq ml b gy nc nd l ne nf">DB_URL=ecto://postgres:postgres@localhost/el_kube_dev \<br/>RELEASE_COOKIE=foo \<br/>SECRET_KEY_BASE=foo \<br/>HOSTNAME=127.0.0.1 \<br/>SERVICE_NAME=localhost.svc \<br/>APP_HOST=localhost \<br/>PORT=4000 \<br/>_build/prod/rel/el_kube/bin/el_kube remote</span></pre><p id="8169" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，你应该进入一个药剂提示:</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="6dfc" class="mm lg iq ml b gy nc nd l ne nf">Erlang/OTP 22 [erts-10.4.4] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [hipe] [dtrace]</span><span id="dcba" class="mm lg iq ml b gy ng nd l ne nf">Interactive Elixir (1.9.1) - press Ctrl+C to exit (type h() ENTER for help)<br/>iex(el_kube@127.0.0.1)1&gt;</span></pre><p id="1b3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，您可以发出一个Ecto命令，您应该会得到一个<code class="fe mi mj mk ml b">:ok</code>元组。</p><pre class="km kn ko kp gt my ml mz na aw nb bi"><span id="5827" class="mm lg iq ml b gy nc nd l ne nf">iex(el_kube@127.0.0.1)1&gt; ElKube.Repo.query("select 1 as test")<br/>{:ok,<br/> %Postgrex.Result{<br/>   columns: ["test"],<br/>   command: :select,<br/>   connection_id: 41993,<br/>   messages: [],<br/>   num_rows: 1,<br/>   rows: [[1]]<br/> }}</span></pre><p id="e21c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你能走到这一步，恭喜你！现在你已经准备好进入第二部分并归档你的申请。</p><p id="85d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-g</p></div></div>    
</body>
</html>