<html>
<head>
<title>Creating Your Own Admission Controller in Kubernetes using Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Golang在Kubernetes中创建自己的准入控制器</h1>
<blockquote>原文：<a href="https://itnext.io/creating-your-own-admission-controller-in-kubernetes-using-golang-3fad3b3e0c81?source=collection_archive---------4-----------------------#2019-01-21">https://itnext.io/creating-your-own-admission-controller-in-kubernetes-using-golang-3fad3b3e0c81?source=collection_archive---------4-----------------------#2019-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="eab3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">库伯内特API是一个令人惊叹的领域。由于是围绕REST模型构建的，它使我们有可能使用HTTP请求来管理我们所有的工作负载。像<code class="fe kl km kn ko b">kubectl</code>或<code class="fe kl km kn ko b">Kubernetes dashboard</code>这样的工具利用了这一点，帮助管理不同的资源。但是Kubernetes API远不止这些。让我们更深入地看看它是如何构成的:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/cc5e903df9d60e11bdfc82bd2ff7442a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZTKiHAovX_J-5Ecp.png"/></div></div></figure><p id="9510" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这张图片突出显示了API组件中的不同组件。该请求启动了与身份验证控制器通信的API旅程。一旦请求被认证，授权模块指示请求发布者是否可以执行操作。请求被适当授权后，入场魔法开始发挥作用。</p><p id="98c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes中有两种类型的准入控制器。它们的工作方式略有不同。第一种类型是<strong class="jp ir">验证接纳控制器</strong>，它将请求代理给订阅的webhooks。Kubernetes API根据资源类型和请求方法注册webhooks。每个webhook都运行一些逻辑来验证传入的资源，并用一个结论来回复API。如果验证webhook拒绝请求，Kubernetes API会向用户返回一个失败的HTTP响应。否则，它继续下一次准入。</p><p id="5d7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二种类型中，有一个<strong class="jp ir">变异接纳控制器</strong>，它修改用户提交的资源，因此您可以进行一些默认设置或验证模式。集群管理员可以将变异webhooks附加到API上，以与验证相同的方式运行。事实上，变异逻辑在验证之前运行。</p><h1 id="d091" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">目标</h1><p id="4806" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们这里的目标是创建一个简单的验证控制器，使我们能够影响pod的创建。尽管有更多的可能性，并且逻辑可以根据您的需要而变得复杂。目标是创建一个进行简单验证的基本版本。你可以在底部的链接中找到更多真实的例子。</p><p id="713c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的示例控制器将被称为<code class="fe kl km kn ko b">grumpy</code>，并将拒绝所有名称不同于<code class="fe kl km kn ko b">smooth-app</code>的新pod。我们认识到在真实的集群中部署这个控制器可能很有诱惑力；).</p><h1 id="c368" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">API如何代理请求</h1><p id="3582" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">Kubernetes API服务器需要知道何时将传入的请求发送给我们的准入控制器。Kubernetes哲学主张总是使用声明性策略，这也不例外。下面我们定义一个<code class="fe kl km kn ko b">ValidationWebhookConfiguration</code>,它向API提供所需的信息:</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="ebda" class="mi lc iq ko b gy mj mk l ml mm">apiVersion: admissionregistration.k8s.io/v1beta1 kind: ValidatingWebhookConfiguration metadata: name: grumpy webhooks: - name: grumpy clientConfig: service: name: grumpy namespace: default path: "/validate" caBundle: "${CA_BUNDLE}" rules: - operations: ["CREATE"] apiGroups: [""] apiVersions: ["v1"] resources: ["pods"]</span></pre><p id="0903" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到有两个主要部分需要考虑。在第一个例子中，<code class="fe kl km kn ko b">clientConfig</code>，我们定义了在哪里可以找到我们的服务(它可以是一个外部URL)，以及我们的验证服务器将监听的<code class="fe kl km kn ko b">path</code>。另外，你会注意到有一个<code class="fe kl km kn ko b">CA</code>需要定义。由于安全性总是很重要，添加cert authority将告诉Kubernetes API使用HTTPS，并使用传递的资产验证我们的服务器。在下一节中，您将看到关于如何生成所有需要的证书的解释。</p><p id="925f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二部分指定API将遵循哪些规则来决定是否将请求转发给<code class="fe kl km kn ko b">grumpy</code>进行验证。此处配置为仅转发方法等于<code class="fe kl km kn ko b">CREATE</code>且资源类型为<code class="fe kl km kn ko b">pod</code>的请求。</p><h1 id="dcdd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">生成证书和CA</h1><p id="8968" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">由于本指南的范围不是教您如何构建PKI包，我们在<a class="ae mn" href="https://github.com/giantswarm/grumpy" rel="noopener ugc nofollow" target="_blank"> grumpy存储库</a>中创建了一个脚本<code class="fe kl km kn ko b">gen_cert.sh</code>，它为我们的grumpy服务器生成一个CA包和一个密钥对。我们还需要在上面显示的webhook中提供CA，以便允许Kubernetes API创建一个针对我们的shiny控制器的安全连接。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="04db" class="mi lc iq ko b gy mj mk l ml mm">// Clone repository in case you did not do it before $ git clone https://github.com/giantswarm/grumpy // Run the command to generate the certs under 'certs' folder $ cd grumpy $ ./gen_cert.sh</span></pre><p id="491c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>在前面提到的脚本中，有注释解释了执行的命令，以防您对幕后发生的事情感兴趣。</p><p id="92f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于本教程的目的，我们的验证webhook配置必须包含一个编码的证书颁发机构。除了创建证书和CA之外，脚本稍后会将它注入到用于部署我们的服务器的清单中。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="8c19" class="mi lc iq ko b gy mj mk l ml mm">$ cat manifest.yaml | grep caBundle</span></pre><p id="1e4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一步中，我们需要创建一个放置证书的密码。在我们应用了清单之后，pod将能够把秘密文件存储到一个目录中。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="4519" class="mi lc iq ko b gy mj mk l ml mm">$ kubectl create secret generic grumpy -n default \ --from-file=key.pem=certs/grumpy-key.pem \ --from-file=cert.pem=certs/grumpy-crt.pem</span></pre><h1 id="b297" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">部署验证控制器</h1><p id="c91e" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">为了部署服务器，我们将使用一个带有单个副本的部署，该副本安装生成的证书以公开一个安全的REST端点，pod请求将提交到该端点。同时，我们将通过服务公开控制器，以配置我们在webhook资源中定义的DNS。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="b03d" class="mi lc iq ko b gy mj mk l ml mm">apiVersion: apps/v1beta1 kind: Deployment metadata: name: grumpy namespace: default spec: replicas: 1 template: spec: containers: - name: webhook image: giantswarm/grumpy:1.0.0 ... volumeMounts: - name: webhook-certs mountPath: /etc/certs ... volumes: - name: webhook-certs secret: secretName: grumpy --- apiVersion: v1 kind: Service metadata: name: grumpy namespace: default spec: ports: - name: webhook port: 443 targetPort: 8080 ...</span></pre><p id="dff5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用清单应该足够了。还包含了之前评论过的webhook。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="3d92" class="mi lc iq ko b gy mj mk l ml mm">$ kubectl apply -f manifest.yaml</span></pre><p id="5426" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，服务器应该正在运行，并准备好验证新pod的创建。</p><h1 id="40a1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">验证验证控制器工作正常</h1><p id="4d8f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们尝试创建一个名称不匹配的简单pod。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="dcbc" class="mi lc iq ko b gy mj mk l ml mm">apiVersion: v1 kind: Pod metadata: name: non-smooth-app spec: containers: - image: busybox name: non-smooth-app</span></pre><p id="2319" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们尝试应用pod资源yaml。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="0621" class="mi lc iq ko b gy mj mk l ml mm">$ kubectl apply -f non-smooth-app.yaml Error from server: error when creating "non-smooth-app.yaml": admission webhook "grumpy-webhook" denied the request: Keep calm and don't add more crap to the cluster!</span></pre><p id="6e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">准入控制已截获该请求，它检查了名称，它与预期值不匹配，所以它被拒绝。</p><p id="b024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确认它的工作，现在让我们用一个正确的名字来试一试。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="3e12" class="mi lc iq ko b gy mj mk l ml mm">apiVersion: v1 kind: Pod metadata: name: smooth-app spec: containers: - image: busybox name: smooth-app</span></pre><p id="eeb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，Kubernetes API允许我们创建pod。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="39a2" class="mi lc iq ko b gy mj mk l ml mm">$ kubectl apply -f smooth-app.yaml pod/smooth-app created $ kubectl get pod smooth-app 0/1 Completed 0 6s</span></pre><h1 id="93e4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解释验证逻辑</h1><p id="5db9" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在这个例子中，我们选择在Go中创建准入控制器，只是因为它是Kubernetes事实上的语言，但是您可以使用您喜欢的任何语言，并且它应该以相同的方式工作。</p><p id="6fe8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始创建一个HTTP服务器，并从secret挂载证书。服务器将监听我们在webhook中定义的路径<code class="fe kl km kn ko b">validate</code>。</p><p id="bfb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>为了更容易理解，代码示例已经被去掉了。要获得更详细的信息，请浏览<a class="ae mn" href="https://docs.giantswarm.io/guides/creating-your-own-admission-controller/github.com/gianstwarm/grumpy" rel="noopener ugc nofollow" target="_blank">库</a>。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="00e5" class="mi lc iq ko b gy mj mk l ml mm">// Read the certs from the convined path and convert it to a X509 keypair flag.StringVar(&amp;tlscert, "tlsCertFile", "/etc/certs/cert.pem", "x509 Certificate for HTTPS.") flag.StringVar(&amp;tlskey, "tlsKeyFile", "/etc/certs/key.pem", "x509 private key to --tlsCertFile.") certs, _ := tls.LoadX509KeyPair(tlscert, tlskey) // Create a secure http server server := &amp;http.Server{ Addr: ":8080", TLSConfig: &amp;tls.Config{Certificates: []tls.Certificate{certs}}, } // Create a handler listening to the 'validate' path and start the server gs := GrumpyServerHandler{} mux.HandleFunc("/validate", gs.serve) server.ListenAndServeTLS("", "")</span></pre><p id="adb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在grumpy包中，我们定义了一个读取请求体的<code class="fe kl km kn ko b">serve</code>函数，然后它将数据转换为<code class="fe kl km kn ko b">Pod</code>数据类型，最后检查资源名是否有效。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="9cfa" class="mi lc iq ko b gy mj mk l ml mm">// Convert raw data in a Pod data type raw := arRequest.Request.Object.Raw pod := v1.Pod{} json.Unmarshal(raw, &amp;pod) // Actual validation logic if pod.Name != "smooth-app" { return }</span></pre><p id="67f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果请求名称不是预期的名称(<code class="fe kl km kn ko b">smooth-app</code>，我们的处理程序将创建一个响应，通知拒绝。否则，它返回，Kubernetes API服务器将跟踪请求的处理。</p><pre class="kq kr ks kt gt me ko mf mg aw mh bi"><span id="8e70" class="mi lc iq ko b gy mj mk l ml mm">// Create a response to return to the Kubernetes API ar := v1beta1.AdmissionReview{ Response: &amp;v1beta1.AdmissionResponse{ Allowed: false, Result: &amp;metav1.Status{ Message: "Keep calm and not add more crap in the cluster!", }, }, } resp, err := json.Marshal(ar)</span></pre><p id="f04e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您从本教程中看到的，实现一个简单的准入控制器是相当容易的。很明显，有很多方法可以让你的集群更加安全，更加坚固(接受已知的注册表，禁止最新的标签等等)。</p><p id="7865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同时，它拥有强大的力量，因为它可以影响集群中运行的关键组件。举个例子，你可以阻止CNI插件运行，以防你犯了一个错误，导致整个集群崩溃。所以要小心，尽量将准入逻辑的范围限定在一个名称空间或一组较小的动作上。</p><p id="0206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，值得一提的是，已经有一些项目利用这种模式来实现更高级别的功能。例如<a class="ae mn" href="https://github.com/open-policy-agent/kubernetes-policy-controller" rel="noopener ugc nofollow" target="_blank">kubernetes-policy-controller</a>使用准入webhooks来实现策略引擎(<a class="ae mn" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank"> OPA </a>)以在云本地环境上实施策略。</p><h1 id="3f6f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">进一步阅读</h1><ul class=""><li id="f7a3" class="mo mp iq jp b jq lz ju ma jy mq kc mr kg ms kk mt mu mv mw bi translated"><a class="ae mn" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/" rel="noopener ugc nofollow" target="_blank">官方文件</a></li><li id="e3e7" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><a class="ae mn" href="https://github.com/slok/kubewebhook/" rel="noopener ugc nofollow" target="_blank">转到创建变异/验证控制器的框架</a></li><li id="f9af" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><a class="ae mn" href="https://github.com/morvencao/kube-mutating-webhook-tutorial/" rel="noopener ugc nofollow" target="_blank">变异控制器教程</a></li><li id="207c" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><a class="ae mn" href="https://github.com/open-policy-agent/kubernetes-policy-controller" rel="noopener ugc nofollow" target="_blank">实现OPA框架的变异和验证控制器</a></li></ul><p id="9b7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由解决方案工程师Fernando Ripoll撰写@ <a class="ae mn" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型蜂群</a></p><div class="nc nd gp gr ne nf"><a href="https://twitter.com/pipo02mix" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">费尔南多·里波尔(@pipo02mix) |推特</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">费尔南多·里波尔的最新推文(@pipo02mix)。生命开发者。特鲁埃尔</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">twitter.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt kz nf"/></div></div></a></div></div></div>    
</body>
</html>