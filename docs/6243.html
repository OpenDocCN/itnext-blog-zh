<html>
<head>
<title>Performant image processing with Go pipelines and bounded concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有Go流水线和有限并发性的高性能图像处理</h1>
<blockquote>原文：<a href="https://itnext.io/performant-image-processing-with-go-pipelines-and-bounded-concurrency-3f721ec5dde8?source=collection_archive---------4-----------------------#2021-09-28">https://itnext.io/performant-image-processing-with-go-pipelines-and-bounded-concurrency-3f721ec5dde8?source=collection_archive---------4-----------------------#2021-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6ea3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将尝试设计一个尽可能高效的图像管理服务器。将介绍几种处理数据的方法:顺序、并发和利用流水线处理的方法。将收集、可视化和分析性能统计数据。你甚至可以从results up上阅读这篇文章！</p><p id="e5ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这里服务器的源代码是</strong><a class="ae kl" href="https://github.com/ele7ija/go-pipelines" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a><strong class="jp ir">，管道包是</strong> <a class="ae kl" href="https://github.com/ele7ija/pipeline" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">这里</strong> </a> <strong class="jp ir">。</strong></p><h1 id="7f27" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">介绍</h1><p id="400e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">自从我偶然发现了关于管道的官方博客后，我就对管道产生了兴趣。起初，我不知道这些例子对并发Go提供的高级语言支持有多好。它使用单向通道(<em class="lp">-&lt;-chan</em>，<em class="lp"> chan &lt; - </em>)，<em class="lp"> range </em> over通道中的元素，<em class="lp"> close </em> s通道，使用<em class="lp"> select </em>语句等。然而，我无法想象管道在现实世界中有任何应用，因为这些例子非常简单，并且是作为概念验证而编写的。</p><p id="9b5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">管道或<a class="ae kl" href="https://syedhasan010.medium.com/pipe-and-filter-architecture-bd7babdb908" rel="noopener">“管道和过滤器”设计模式</a>只是您肯定会遇到的一种设计模式，UNIX shell就是一个很好的例子:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="ca70" class="lz kn iq lv b gy ma mb l mc md"># find all students named 'Alice', save their results and count them<br/>$ cat results.txt | grep "Alice" | tee alices_results.txt | wc -l</span></pre><p id="5454" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在我在Go 中实现管道模式的<a class="ae kl" href="https://github.com/ele7ija/pipeline" rel="noopener ugc nofollow" target="_blank">中，我主要关注项目的批处理。项目经过过滤器，我提供了几种类型，主要是<em class="lp">串行</em>、<em class="lp">并行</em>和<em class="lp">有界并行</em>。它们的区别在于它们是逐个处理接收到的项目，还是同时处理它们，或者最多同时处理N个项目。</a></p><blockquote class="me mf mg"><p id="9d26" class="jn jo lp jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">管道模式只是使组合和独立更改数据处理阶段变得更加容易。让它快速高效运行的是对每个阶段进行基准测试，并对它创建的并发流数量进行限制。</p></blockquote><p id="963d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将介绍不同类型的处理方法如下:对于每一种处理方法，我将首先解释该处理方法的特点，然后我将提到它所达到的结果；之后，我将展示源代码和资源使用情况。最后，所有结果将被汇总并显示在一个表格中。</p><p id="a0f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每种处理类型，运行一个测试:<strong class="jp ir">每种处理类型处理3个POST请求，包含500个图像，平均大小为116KB </strong>。我测量了<em class="lp">处理请求的平均时间</em>(结果差异很小)<em class="lp">的资源使用</em>(内存使用和goroutines的数量，在<a class="ae kl" href="https://github.com/tevjef/go-runtime-metrics" rel="noopener ugc nofollow" target="_blank">这个包</a>的帮助下)。</p><h1 id="fb25" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">顺序加工</h1><p id="3f8a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">顺序图像处理应该类似于传统的图像处理方式:它们被一个接一个地处理。下面的代码设法在平均时间<strong class="jp ir"> 129942ms </strong>(超过2分钟)内处理了所有500张图像。</p><p id="5839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lp">免责声明</em>:这里显示的所有代码都被缩短了，以关注大图，因此没有任何错误检查、清理功能等。</p><figure class="lq lr ls lt gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">顺序图像处理的实现</figcaption></figure><figure class="lq lr ls lt gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/857ce9d69a3b5198b126f1d8eb31152f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OMWy4jNEz2C1AfB897JNzg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">顺序图像处理的资源使用(1个请求)</figcaption></figure><h1 id="f38b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">并行处理</h1><p id="3b1c" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">并发处理类似于加速图像处理的最简单的方法:每个图像都在它自己的<em class="lp"> goroutine </em>中处理。并发处理设法在平均时间<strong class="jp ir">24405毫秒内处理图像。</strong></p><figure class="lq lr ls lt gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">并行图像处理的实现</figcaption></figure><figure class="lq lr ls lt gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/9930230b9f29c9c255c8e67428419670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-d8IkHNrMgjhJoMSo8vEw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">并行图像处理的资源使用(3个请求)</figcaption></figure><h1 id="0543" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用串行过滤器的流水线处理</h1><p id="c9a3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这种管道处理使用过滤器来逐个处理每个项目。串行过滤器流水线处理的平均时间为<strong class="jp ir">46293毫秒</strong>。我将首先展示对于所有类型的管道处理都相同的处理程序:</p><figure class="lq lr ls lt gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">利用管道处理的处理程序</figcaption></figure><p id="b908" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们实例化管道本身。我们需要使<em class="lp"> Worker </em>对象基本上包围<em class="lp"> ImageService </em>以便它的方法符合接口。</p><figure class="lq lr ls lt gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">创建带有串行过滤器的管道</figcaption></figure><figure class="lq lr ls lt gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/8dde66ecc94d0b79c83ba0dd29a25c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdTBy5em1XdeT-4aeRKKhg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">具有串行过滤器的流水线图像处理的资源使用(1个请求)</figcaption></figure><h1 id="e8ad" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用并行过滤器的流水线处理</h1><p id="9b31" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">使用并行过滤器的管道处理具有在项目到来时处理项目的过滤器，但是是并发的。您将会看到所有滤波器串联和并联之间的细微差别。用并行滤波器<strong class="jp ir">流水线处理平均24387ms </strong>处理所有图像。</p><figure class="lq lr ls lt gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">创建具有并行过滤器的管道</figcaption></figure><figure class="lq lr ls lt gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/0acb4ac434f21c133a68ffef4e749ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jp8nTug9zPsyIZwv_oBHNA.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">具有并行滤波器的管线图像处理的资源使用(3个请求)</figcaption></figure><h1 id="fde0" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">具有有界并行过滤器的流水线处理</h1><p id="1922" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这个处理与前面的非常相似，唯一的区别是一个有界并行过滤器一次最多处理N个项目。</p><figure class="lq lr ls lt gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">创建具有有界并行过滤器的流水线</figcaption></figure><figure class="lq lr ls lt gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/1444a3ecaa7fcb0b82a889a533bc3f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTz4JBFweIA1g6je0VCh1w.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">具有有界并行滤波器的管线图像处理的资源使用(3个请求)</figcaption></figure><h1 id="48b6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结果</h1><figure class="lq lr ls lt gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">不同管道处理的汇总结果</figcaption></figure><p id="33ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个有趣的发现是，<strong class="jp ir">不仅使用有界过滤器的流水线处理速度最快，而且与其他类似放置的处理</strong>相比，它使用的内存量最少，创建的goroutines数量最少。对此唯一的解释是Go运行时无法同时处理这么多并发流。更准确地说[ <em class="lp">根据reddit </em> 的 <a class="ae kl" href="https://www.reddit.com/r/golang/comments/pxaxay/performant_image_processing_with_go_pipelines_and/hemlqx3/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank"> <em class="lp">建议编辑:</em></a></p><blockquote class="me mf mg"><p id="7063" class="jn jo lp jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">这种情况下的无限并行处理<strong class="jp ir">使CPU </strong>过饱和，浪费时间在上下文切换上，而不是做工作。</p></blockquote><p id="5536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个伟大的发现是<strong class="jp ir">使用串行过滤器的流水线处理不使用太多的内存</strong>，这对于流水线处理的实际应用来说是非常理想的。对此的解释非常简单:这种管道处理不会同时处理许多项——同时处理的最大项数等于过滤器的数量(过滤器之间的通道不会被缓冲)。</p><h1 id="67cd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="36d1" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在本文中，我介绍了我构建高效图像管理服务器的经验。引入了一些处理数据的方法，但是最快和最有效的方法是使用有限并发的流水线处理。</p><h1 id="b1c3" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">额外部分:为并发性绑定</h1><p id="d869" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">关于具有有限并发性的管道处理，或者通常对Go程序创建的goroutines的数量进行限制，最有问题的是<em class="lp">如何计算限制</em>。我是这样做的，非常简单:</p><figure class="lq lr ls lt gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi my"><img src="../Images/66313b47255f3d2245f1796b7dcf30a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K7k4naL9SKDCN3aw-wh7lw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">具有独立串行过滤器的流水线处理的统计</figcaption></figure><p id="7204" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我用<em class="lp">独立串行滤波器</em>替换了所有滤波器，并观察了结果。独立串行滤波器的作用是，在当前阶段完全完成之前，它们不会将数据转发到下一阶段。通过这种方式，您可以观察过滤器自身的表现(项目不进行管道处理)。</p><blockquote class="me mf mg"><p id="41cd" class="jn jo lp jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">接下来，公式非常简单:如果一个过滤器处理一个项目需要1秒，下一个需要3秒，为了实现最高效的管道，这些过滤器的界限应该是1:3的比率，这样就不会有过滤器等待下一个能够处理。</p></blockquote><p id="80d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，根据上图计算出的并发界限的比率大约为<em class="lp"> 10:15:20:1:20，</em>这就是具有有界并行过滤器的流水线处理的<em class="lp"> 30/35/40/10/40 </em>界限。我做了一些额外的基准测试，看看什么实际上效果最好。</p><p id="316a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并发边界也可以类似于一些外部API的限制。</p></div></div>    
</body>
</html>