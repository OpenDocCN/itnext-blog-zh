<html>
<head>
<title>Prototype Pollution attack on NodeJS applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对NodeJS应用程序的原型污染攻击</h1>
<blockquote>原文：<a href="https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7?source=collection_archive---------0-----------------------#2020-02-06">https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7?source=collection_archive---------0-----------------------#2020-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b476" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">原型污染攻击是Javascript中对对象原型的一种攻击形式，会导致逻辑错误，有时会导致在系统上执行片段任意代码。</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="gh gi gj"><img src="../Images/0b0ce28f18afdee77b2002ee561d5c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93uY2A4Oq-YownNHRanWLw.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">资料来源:https://thehackernews.com</figcaption></figure><p id="e308" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">原型污染攻击(Prototype Pollution attack)(顾名思义部分)是Javascript中对对象原型的一种攻击形式(添加/修改/删除属性)，导致逻辑错误，有时会导致在系统上执行片段任意代码(远程代码执行——RCE)。自2018年以来，在一些流行的JavaScript库JQuery中发现了该漏洞，最近在流行库之一的Lodash库中发现了该漏洞。让我们看看这种形式的攻击。</p><h1 id="053a" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">Javascript中的对象</h1><p id="5fe6" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">首先，我们需要了解javascript中的<code class="fe mq mr ms mt b">Object</code>。对象只是键和值对的集合，通常称为对象的属性。例如:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="gh gi mu"><img src="../Images/21458794956d37f516499348dea3ae3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IoR4C4DLB-TyaCnQbivOhA.png"/></div></div></figure><p id="86d8" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">使用{}有助于我们声明一个新对象，并为它分配相应的名称和年龄属性。声明完成后，我们可以像往常一样访问这些属性。然而，用户对象的内部不仅有我们已经分配的属性，还有许多其他信息，如上所述。那么这些属性从何而来呢？</p><p id="02fb" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在Javascript中，<code class="fe mq mr ms mt b">Object</code>是一个基本对象，是所有新建对象的模板。通过将<code class="fe mq mr ms mt b">null</code>传递给<code class="fe mq mr ms mt b">Object.create</code>，可以创建一个空对象。但是，新创建的对象也将具有与传递的参数相对应的类型，并继承所有基本属性。</p><pre class="ki kj kk kl gt mv mt mw mx aw my bi"><span id="c091" class="mz lu it mt b gy na nb l nc nd">console.log(Object.create(null)); // prints an empty object</span></pre><h1 id="55dd" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">Javascript中的函数/类</h1><p id="bbd2" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">在javascript中，类和函数的概念是相互关联的(函数本身充当类的构造函数，实际的性质在Javascript中没有“类”的概念)。让我们看下面的例子:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b4f3" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在上面的例子中，我们定义了一个名为<code class="fe mq mr ms mt b">person</code>的函数，并初始化了两个名为<code class="fe mq mr ms mt b">person1</code>和<code class="fe mq mr ms mt b">person2</code>的对象。如果我们查看新创建的对象的属性，我们可能会注意到两件事:</p><ul class=""><li id="7805" class="ng nh it kz b la lb ld le lg ni lk nj lo nk ls nl nm nn no bi translated">创建函数时，javascript引擎在函数中包含了<code class="fe mq mr ms mt b">prototype</code>属性。<code class="fe mq mr ms mt b">prototype</code>一个对象是否有一个构造函数属性指向包含它的函数？</li><li id="5227" class="ng nh it kz b la np ld nq lg nr lk ns lo nt ls nl nm nn no bi translated">当创建对象时，javascript引擎向新创建的对象添加一个<code class="fe mq mr ms mt b">__proto__</code>属性，该属性引用构造函数的原型对象。简而言之，<code class="fe mq mr ms mt b">object.__proto__</code>指向<code class="fe mq mr ms mt b">function.prototype</code>。</li></ul><h1 id="ea14" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated"><strong class="ak">建造师</strong></h1><p id="ee29" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated"><code class="fe mq mr ms mt b">Constructor</code>是一个特殊属性，它返回用于创建该对象的函数。对象<code class="fe mq mr ms mt b">prototype</code>有一个指向该函数的构造函数，而构造函数的构造函数将是全局构造函数。例如:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="3843" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">JavaScript中的原型</h1><p id="23d3" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">需要注意的一点是，在执行代码时，可以更改/修改/删除原型属性。例如:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ff7d" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">上面，我们改变了函数的原型，增加了一个新的属性<code class="fe mq mr ms mt b">details</code>。我们可以通过使用对象来做同样的事情:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a998" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">你看到什么奇怪的东西了吗？我们改变了<code class="fe mq mr ms mt b">person1</code>，但它也影响了<code class="fe mq mr ms mt b">person2</code>。原因是在前面的例子中，我们改变了<code class="fe mq mr ms mt b">person.prototype</code>来添加一个新的属性，但是在第二个例子中，我们改变了一个对象。因为构造函数会返回用来创建对象的函数，<code class="fe mq mr ms mt b">person1.constructor</code>会引用函数<code class="fe mq mr ms mt b">person</code>，<code class="fe mq mr ms mt b">person1.constructor.prototype</code>现在是<code class="fe mq mr ms mt b">person.prototype</code>。</p><h1 id="0d0a" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">原型污染</h1><p id="2138" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">比如<code class="fe mq mr ms mt b">obj[a][b] = value</code>。如果攻击者可以控制<code class="fe mq mr ms mt b">a</code>和<code class="fe mq mr ms mt b">value</code>的值，那么他只需要将<code class="fe mq mr ms mt b">a</code>的值调整为<code class="fe mq mr ms mt b">__proto__</code>(在javascript中，<code class="fe mq mr ms mt b">obj["__proto__"]</code>和<code class="fe mq mr ms mt b">obj.__proto__</code>是完全等价的)那么应用程序中所有现有对象的属性<code class="fe mq mr ms mt b">b</code>都会被赋给<code class="fe mq mr ms mt b">value</code>。</p><p id="c82e" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">然而，攻击并不像上一个那么简单，根据<a class="ae nu" href="https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>，我们只有在满足以下三个条件之一时才能攻击:</p><ul class=""><li id="1df6" class="ng nh it kz b la lb ld le lg ni lk nj lo nk ls nl nm nn no bi translated">执行递归合并</li><li id="c30d" class="ng nh it kz b la np ld nq lg nr lk ns lo nt ls nl nm nn no bi translated">按路径定义属性</li><li id="b425" class="ng nh it kz b la np ld nq lg nr lk ns lo nt ls nl nm nn no bi translated">克隆对象</li></ul><p id="5413" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们来看看一些错误:</p><h1 id="64cf" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">CVE-2019–11358:通过jQuery $进行原型污染攻击。扩展</h1><p id="6b05" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">$ .如果处理不当，extend会改变对象<code class="fe mq mr ms mt b">prototype</code>(应用程序中对象的模板)的属性。该属性将出现在所有对象上。注意，只有$的“深度”版本(即g)。extened受到影响。</p><p id="6c24" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">程序员经常使用这个函数来复制一个对象或者从一个默认对象中填充新的属性。例如:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f69a" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们可以想象<code class="fe mq mr ms mt b">myObject</code>是来自用户的输入字段，并被序列化到DB中)</p><p id="ba17" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在这段代码中，我们经常想，在运行时会把属性<code class="fe mq mr ms mt b">isAdmin</code>赋给新创建的对象。但本质上是直接分配给<code class="fe mq mr ms mt b">{}</code>然后<code class="fe mq mr ms mt b">{}.isAdmin</code>会是<code class="fe mq mr ms mt b">true</code>。如果在这段代码之后，我们执行以下检查:</p><pre class="ki kj kk kl gt mv mt mw mx aw my bi"><span id="28ce" class="mz lu it mt b gy na nb l nc nd">If (user.isAdmin === true) {<br/>    // do something for admin<br/>}</span></pre><p id="40b3" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果用户尚未存在(<code class="fe mq mr ms mt b">undefined</code>)，将在属性<code class="fe mq mr ms mt b">isAdmin</code>的父对象中搜索该属性，父对象是上面添加了值<code class="fe mq mr ms mt b">true </code>的对象<code class="fe mq mr ms mt b">isAdmin</code>。</p><p id="6771" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在JQuery 3.3.1上执行的另一个例子是:</p><pre class="ki kj kk kl gt mv mt mw mx aw my bi"><span id="5b40" class="mz lu it mt b gy na nb l nc nd">$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))<br/>console.log({}.devMode); // true</span></pre><p id="b646" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这些错误会影响很多Javascript项目，尤其是NodeJS项目，最实际的例子就是2018年12月帮助操作MongoDB的JS库Mongoose中的错误。</p><h1 id="d6e3" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">CVE-2018–3721，CVE-2019–10744:通过洛达什的原型污染攻击</h1><p id="d800" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated"><a class="ae nu" href="https://www.npmjs.com/package/lodash" rel="noopener ugc nofollow" target="_blank"> Lodash </a>也是一个知名的库，它提供了很多不同的功能，帮助我们更方便、更整洁地编写代码，每周下载量超过1900万次。它遇到了和JQuery一样的问题。</p><p id="0a5b" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz iu">CVE-2018–3721</strong></p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="17a7" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz iu">CVE-2019–10744</strong></p><p id="40af" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这个bug影响Lodash的所有版本，已经在4.17.11版本中修复。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="6eac" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">我能做些什么来预防？</h1><ul class=""><li id="51df" class="ng nh it kz b la ml ld mm lg nv lk nw lo nx ls nl nm nn no bi translated">用Object.freeze (Object.prototype)冻结属性</li><li id="4c30" class="ng nh it kz b la np ld nq lg nr lk ns lo nt ls nl nm nn no bi translated">根据应用程序的模式对JSON输入执行验证</li><li id="0480" class="ng nh it kz b la np ld nq lg nr lk ns lo nt ls nl nm nn no bi translated">避免以不安全的方式使用递归合并函数</li><li id="cf2a" class="ng nh it kz b la np ld nq lg nr lk ns lo nt ls nl nm nn no bi translated">使用没有原型属性的对象，例如<code class="fe mq mr ms mt b">Object.create(null)</code>，以避免影响原型链</li><li id="c3f2" class="ng nh it kz b la np ld nq lg nr lk ns lo nt ls nl nm nn no bi translated">使用<code class="fe mq mr ms mt b">Map</code>代替<code class="fe mq mr ms mt b">Object</code></li><li id="8963" class="ng nh it kz b la np ld nq lg nr lk ns lo nt ls nl nm nn no bi translated">定期更新库的新补丁</li></ul></div></div>    
</body>
</html>