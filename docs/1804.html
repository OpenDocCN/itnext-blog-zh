<html>
<head>
<title>How to deploy Gunicorn behind Nginx in a shared instance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在共享实例中在Nginx后面部署Gunicorn</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-deploy-gunicorn-behind-nginx-in-a-shared-instance-f336d2ba4519?source=collection_archive---------2-----------------------#2019-02-01">https://itnext.io/how-to-deploy-gunicorn-behind-nginx-in-a-shared-instance-f336d2ba4519?source=collection_archive---------2-----------------------#2019-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c422c4eae61f737801dc50e7264673b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*7Sc8yOdg73eXcFm8oB8fBw.png"/></div></figure><h2 id="542d" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="baed" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">尽管我更喜欢用Kubernetes和Containers来构建一个系统，但有时产品所有者的需求并不符合要求，我们必须适应使用期望的技术，并利用我们可用的工具从中提取最佳效果。按照下面的说明，学习如何使用Nginx、Gunicorn和Systemd在2个虚拟机中为Flask API部署3个环境。在我的下一篇文章中，我将讨论如何实现自动化。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="e3c6" class="pw-post-body-paragraph kq kr iq ks b kt ls kv kw kx lt kz la kd lu lc ld kh lv lf lg kl lw li lj lk ij bi translated">一年多以来，我作为Indellient 的一名<a class="ae lx" href="https://www.indellient.com/" rel="noopener ugc nofollow" target="_blank">软件开发人员，一直致力于实现在我们客户的Kubernetes平台上部署和管理应用程序的解决方案。这些解决方案需要“提升和转移”计划来将现有的应用程序容器化，在此基础上添加CI/CD和应用程序生命周期管理。</a></p><p id="54a2" class="pw-post-body-paragraph kq kr iq ks b kt ls kv kw kx lt kz la kd lu lc ld kh lv lf lg kl lw li lj lk ij bi translated">用于这些计划的工具以及经过认证的Kubernetes平台有Docker、Artifactory、Github和TravisCI等。</p><p id="d8dd" class="pw-post-body-paragraph kq kr iq ks b kt ls kv kw kx lt kz la kd lu lc ld kh lv lf lg kl lw li lj lk ij bi translated">Kubernetes是一个强大的工具。我很喜欢它让开发团队能够按照DevOps的文化和共享责任模型生活。</p><blockquote class="ly lz ma"><p id="5ccd" class="kq kr mb ks b kt ls kv kw kx lt kz la mc lu lc ld md lv lf lg me lw li lj lk ij bi translated">禁止:它在我的机器上工作…</p></blockquote><p id="c58a" class="pw-post-body-paragraph kq kr iq ks b kt ls kv kw kx lt kz la kd lu lc ld kh lv lf lg kl lw li lj lk ij bi translated">然而，并非所有都是鲜花，在这种情况下，产品所有者的要求与该公司的Kubernetes平台产品不兼容。这从支持水平到预算限制各不相同。</p><p id="245e" class="pw-post-body-paragraph kq kr iq ks b kt ls kv kw kx lt kz la kd lu lc ld kh lv lf lg kl lw li lj lk ij bi translated">客户选择在公司的私有云上使用2个云实例，我们应该使用现有的工具使其正常工作并为自动化做好准备。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="6036" class="mf jv iq bd jw mg mh mi jz mj mk ml kc mm mn mo kg mp mq mr kk ms mt mu ko mv bi translated">要求</h1><ol class=""><li id="99ac" class="mw mx iq ks b kt ku kx ky kd my kh mz kl na lk nb nc nd ne bi translated">私有云中的2个Ubuntu 16.04 LTS虚拟机</li><li id="9a39" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">创建3个环境(开发、UAT和生产)</li><li id="9cfc" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">没有容器:(</li><li id="0ca1" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">现有企业系统</li><li id="5b18" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">使用Python 3的Flask API</li><li id="a06b" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">加密通信:HTTPS</li></ol><h1 id="ec93" class="mf jv iq bd jw mg nk mi jz mj nl ml kc mm nm mo kg mp nn mr kk ms no mu ko mv bi translated">这些问题</h1><ol class=""><li id="9494" class="mw mx iq ks b kt ku kx ky kd my kh mz kl na lk nb nc nd ne bi translated">我们如何分别验证不同环境的变更？即代码和依赖关系。</li><li id="a2d7" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">我们将如何提供烧瓶API？</li><li id="07b7" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">我们如何在一个虚拟机中隔离两个环境，并为自动化做好一切准备，而无需在每个部署中进行大量手动配置？</li><li id="235f" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">最后，我们如何保护与现有系统的连接？</li></ol><h1 id="ab31" class="mf jv iq bd jw mg nk mi jz mj nl ml kc mm nm mo kg mp nn mr kk ms no mu ko mv bi translated">解决方案</h1><p id="7a44" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">因为每个问题都有可能是已经完全或部分解决的问题，所以我们卷起袖子继续研究阶段。我们在Python世界中找到了一系列常见的实践来解决我们的部分问题，并将它们合并到解决方案中。</p><ol class=""><li id="ade0" class="mw mx iq ks b kt ls kx lt kd np kh nq kl nr lk nb nc nd ne bi translated">Github上的3个长寿分支:<code class="fe ns nt nu nv b">master</code>、<code class="fe ns nt nu nv b">staging</code>、<code class="fe ns nt nu nv b">dev</code></li><li id="5587" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">Python虚拟人:<code class="fe ns nt nu nv b">app-env-dev</code>、<code class="fe ns nt nu nv b">app-env-test</code>和<code class="fe ns nt nu nv b">app-env-prod</code></li><li id="8adf" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">Gunicorn将Flask API作为systemd服务。</li><li id="468d" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">Nginx:反向代理、api网关和证书验证</li></ol><h1 id="a6db" class="mf jv iq bd jw mg nk mi jz mj nl ml kc mm nm mo kg mp nn mr kk ms no mu ko mv bi translated">建筑</h1><figure class="nx ny nz oa gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi nw"><img src="../Images/bd527c9ea830729166674e1609e3767c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96Q6OYaSivAxdi3NkZMTsQ.png"/></div></div></figure><h1 id="da32" class="mf jv iq bd jw mg nk mi jz mj nl ml kc mm nm mo kg mp nn mr kk ms no mu ko mv bi translated">我们是如何做到的</h1><p id="62ea" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">接下来的步骤都是从您的云实例中完成的，应该在那里安装和配置组件。</p><h2 id="79f4" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">获取代码</h2><p id="0d09" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">对于这一部分，您的存储库中应该有Flask应用程序(这里用<code class="fe ns nt nu nv b">App</code>表示)，Flask和Gunicorn被定义为<code class="fe ns nt nu nv b">requirements.txt</code>中的依赖项。</p><p id="a6b1" class="pw-post-body-paragraph kq kr iq ks b kt ls kv kw kx lt kz la kd lu lc ld kh lv lf lg kl lw li lj lk ij bi translated">为<code class="fe ns nt nu nv b">DEV</code>(开发)和<code class="fe ns nt nu nv b">TEST</code>(登台)创建目录。</p><ol class=""><li id="c5b8" class="mw mx iq ks b kt ls kx lt kd np kh nq kl nr lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ mkdir ~/DEV</code></li><li id="5c71" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ cd ~/DEV</code></li><li id="c7a9" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ git clone <a class="ae lx" href="https://github.com/App" rel="noopener ugc nofollow" target="_blank">https://github.com/App</a></code></li><li id="349a" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ git checkout dev</code></li></ol><p id="fd5b" class="pw-post-body-paragraph kq kr iq ks b kt ls kv kw kx lt kz la kd lu lc ld kh lv lf lg kl lw li lj lk ij bi translated">现在这个位置映射了您的<code class="fe ns nt nu nv b">dev</code>分支。这个想法是，一个简单的<code class="fe ns nt nu nv b">git pull</code>就足以带来变化并为测试进行部署。</p><h2 id="77a3" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">安装Python的virtualenv</h2><p id="e378" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">每个环境都应该有自己的Python虚拟环境。这样做的原因是:它使得对依赖关系的更改在根据声明的需求更新的环境中是可测试的。类似于Docker将应用程序环境包装在映像中的做法。相比之下，#2是你的Docker <code class="fe ns nt nu nv b">FROM</code>(“干净”的房间)，而#4是你的环境设置。这个想法</p><ol class=""><li id="5eed" class="mw mx iq ks b kt ls kx lt kd np kh nq kl nr lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ sudo apt-get install virtualenv</code></li><li id="945e" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ sudo virtualenv -p python3 /opt/app-env-dev</code></li><li id="0b99" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ source /opt/app-env-dev/bin/activate</code></li><li id="05d8" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">(app-env-dev)$ pip install -r ~/DEV/App/requirements.txt</code></li><li id="f936" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">(app-env-dev)$ deactivate</code></li></ol><h2 id="f10d" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">安装Nginx</h2><p id="dff4" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">Nginx将是我们的反向代理和API网关，根据前缀URL: <code class="fe ns nt nu nv b">/dev</code>和<code class="fe ns nt nu nv b">/test</code>重写到达不同环境的请求。</p><ol class=""><li id="e23d" class="mw mx iq ks b kt ls kx lt kd np kh nq kl nr lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ sudo apt-get install nginx</code></li><li id="5a61" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ sudo systemctl status nginx</code></li></ol><h2 id="1209" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建systemd服务来运行Gunicorn</h2><p id="3b13" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">每个环境还将通过自己的Python virtualenv运行自己的Gunicorn服务，并绑定到不同的unix套接字。</p><ol class=""><li id="8e8b" class="mw mx iq ks b kt ls kx lt kd np kh nq kl nr lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ sudo /etc/systemd/system/app-api-dev.service</code></li></ol><pre class="nx ny nz oa gt of nv og oh aw oi bi"><span id="2209" class="ju jv iq nv b gy oj ok l ol om">[Unit]<br/>Description=Gunicorn instance to serve app-api<br/>After=network.target<br/><br/>[Service]<br/>User=admin<br/>Group=www-data<br/>WorkingDirectory=/home/admin/DEV/App/src/web<br/>Environment="PATH=/opt/app-env-dev/bin"<br/>ExecStart=/opt/app-env-dev/bin/gunicorn --log-level debug --worker-class=gthread --threads=5 --bind unix:/opt/app-env-sock/dev.sock --access-logfile /var/log/gunicorn/dev/gunicorn_access.log -m 007 wsgi:app<br/><br/>[Install]<br/>WantedBy=multi-user.target</span></pre><h2 id="5dda" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">配置Nginx</h2><ol class=""><li id="8fde" class="mw mx iq ks b kt ku kx ky kd my kh mz kl na lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ sudo vi /etc/nginx/sites-available/api-gateway</code></li></ol><pre class="nx ny nz oa gt of nv og oh aw oi bi"><span id="c371" class="ju jv iq nv b gy oj ok l ol om">server {<br/>    listen 80;<br/>    server_name app-api.com;<br/>    return 301 https://$server_name$request_uri;<br/>}<br/><br/>server {<br/>    listen 443 ssl;<br/>    ssl_certificate /opt/ssl/crt.pem;<br/>    ssl_certificate_key /opt/ssl/key.pem;<br/><br/>    server_name app-api.com;</span><span id="83d9" class="ju jv iq nv b gy on ok l ol om">    location /dev {<br/>        include proxy_params;<br/>        rewrite ^/dev/(.*) /$1  break;<br/>        proxy_pass http://unix:/opt/app-env-sock/dev.sock;<br/>    }</span><span id="7823" class="ju jv iq nv b gy on ok l ol om">    #Add here location for /test environment</span><span id="bee0" class="ju jv iq nv b gy on ok l ol om">}</span></pre><p id="fb53" class="pw-post-body-paragraph kq kr iq ks b kt ls kv kw kx lt kz la kd lu lc ld kh lv lf lg kl lw li lj lk ij bi translated">请注意，我们在<code class="fe ns nt nu nv b">/opt/ssl</code>下有<code class="fe ns nt nu nv b">crt.pem</code>和<code class="fe ns nt nu nv b">key.pem</code>，并将位置传递给Nginx，它将负责:</p><ol class=""><li id="13d0" class="mw mx iq ks b kt ls kx lt kd np kh nq kl nr lk nb nc nd ne bi translated">将进入<code class="fe ns nt nu nv b">:80</code>的任何流量重定向到<code class="fe ns nt nu nv b">:443</code></li><li id="885f" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">根据客户端的请求验证SSL证书</li><li id="4afb" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated">重写传入请求URI以移除环境前缀并转发到相关联的Unix套接字。</li></ol><p id="1aa5" class="pw-post-body-paragraph kq kr iq ks b kt ls kv kw kx lt kz la kd lu lc ld kh lv lf lg kl lw li lj lk ij bi translated">我们现在应该让Nginx在共享环境中服务API网关。</p><p id="60de" class="pw-post-body-paragraph kq kr iq ks b kt ls kv kw kx lt kz la kd lu lc ld kh lv lf lg kl lw li lj lk ij bi translated"><code class="fe ns nt nu nv b">$ sudo ln -s /etc/nginx/sites-available/api-gateway /etc/nginx/sites-enabled</code></p><h2 id="bcd1" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">启动服务</h2><p id="f4a1" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">现在一切就绪，我们可以开始并启用服务了。</p><ol class=""><li id="7876" class="mw mx iq ks b kt ls kx lt kd np kh nq kl nr lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ sudo systemctl start app-api-dev</code>:启动Gunicorn开发环境</li><li id="f87a" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ sudo systemctl enable app-api-dev</code>:在虚拟机启动时启动Gunicorn开发环境</li><li id="42c8" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ sudo systemctl status app-api-dev</code>:验证服务状态</li><li id="9a4a" class="mw mx iq ks b kt nf kx ng kd nh kh ni kl nj lk nb nc nd ne bi translated"><code class="fe ns nt nu nv b">$ sudo systemctl restart nginx</code>:重启Nginx。</li></ol><h1 id="be8d" class="mf jv iq bd jw mg nk mi jz mj nl ml kc mm nm mo kg mp nn mr kk ms no mu ko mv bi translated">结论</h1><p id="2a3b" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">虽然从应用程序开发的角度来看，使用Kubernetes和Docker containers更有意义，但有时我们需要接受需求，并应用我们最好的知识来提供可行的解决方案，并为自动化做好准备。</p><p id="b6c1" class="pw-post-body-paragraph kq kr iq ks b kt ls kv kw kx lt kz la kd lu lc ld kh lv lf lg kl lw li lj lk ij bi translated">在下一篇文章中，我们将深入探讨如何使用TravisCI增强Git流程并自动化测试和部署该解决方案。</p></div></div>    
</body>
</html>