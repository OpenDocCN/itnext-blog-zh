<html>
<head>
<title>Measuring Patching Cadence on Kubernetes with GitOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitOps测量Kubernetes上的修补节奏</h1>
<blockquote>原文：<a href="https://itnext.io/measuring-patching-cadence-on-kubernetes-with-gitops-353bc4a1d25?source=collection_archive---------3-----------------------#2022-03-01">https://itnext.io/measuring-patching-cadence-on-kubernetes-with-gitops-353bc4a1d25?source=collection_archive---------3-----------------------#2022-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d5e86171e3ac99dd92793f1d6396aa08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u7LIVSzEZSHxNcfF.png"/></div></div></figure><p id="e58b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于GitOps和类似流程如何产生更易观察的部署管道，已经说了很多，但同样重要的是如何从已经观察到的数据中获得洞察力。在这篇文章中，我将分享在管理安装在Kubernetes上的第三方软件的背景下，如何使用这些数据来保持修补过程的正常进行。</p><h1 id="5037" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">平台“包”</h1><p id="5e06" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">运营Kubernetes不仅仅是关于etcd、API服务器和Kubelets。它也是关于在那之上运行的东西。我在家里操作一个Kubernetes集群，运行在Raspberry Pi上，其中托管了各种应用程序。为了增强平台的功能，许多支持性的第三方扩展服务也在其上运行，例如:</p><ul class=""><li id="3106" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">编织网络插件</li><li id="5f44" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">金属LB</li><li id="7776" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">证书管理器</li><li id="e1ee" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">普罗米修斯-格拉法纳公司</li><li id="9e13" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">看门人</li></ul><p id="3edd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管从某种意义上来说，它们是平台的一部分，但它们也是安装在基础平台之上的独立组件。将每个组件视为YAML清单的一个单独的“包”会很有帮助，它可以独立地更新或重新配置。</p><h1 id="8943" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">更新的需要</h1><p id="0a68" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">当您运行软件包时，与所有软件一样，您还必须担心保持最新，原因如下:</p><ul class=""><li id="80a9" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">久而久之，越来越多的旧软件CVE被发现，增加了被黑客攻击的风险。对于可从公共互联网访问的系统来说，这尤其危险，我运行的一些服务就是如此。</li><li id="368c" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">即使是不容易受到攻击的软件也可能会出现问题。如果围绕未更改的软件升级其他(易受攻击的)组件，新版本可能与旧API不兼容，集成可能会中断。</li><li id="4f3b" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">大多数软件在某种程度上都有问题。您经常会遇到bug和特性缺口——您的用例与作者预期的不同。软件更新中修复了许多此类问题。</li></ul><p id="c2dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这些原因，不仅安装软件很重要，保持软件更新也很重要。</p><h1 id="35c5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">更新设计</h1><p id="8f76" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">不幸的是，将您的系统设计成可更新的需要更多的关注，而不仅仅是安装一个软件包。您应该:</p><ul class=""><li id="27ed" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">使用基础设施作为代码，也就是签入git的包清单YAML文件，跟踪基础设施的当前状态</li><li id="9390" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">跟踪从哪里提取包，也可以定义一个升级过程。像<a class="ae mo" href="https://carvel.dev/vendir/docs/latest/" rel="noopener ugc nofollow" target="_blank"> Vendir </a>这样的工具可以用于此。</li><li id="f99b" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">跟踪您对包所做的任何定制，并为应用它们定义一个可重复的过程</li><li id="fbe2" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">定义一些过程来保持机密与已部署的包同步</li><li id="08d5" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">如果您有多个环境，请定义一个过程，将更新按顺序部署到这些环境中，并给出适当的特定于环境的参数</li></ul><p id="56b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些都不是免费的——每个方面都需要一些工程上的努力。当事情变得更加复杂时，很容易忽略大局。重要的是要确保我们不仅仅是货物养殖实践。我们不想为了自动化而自动化——我们想用它们来实现某些目标。也就是说，当升级可用时，可以更快地应用升级。因此，我们应该<em class="kw">确定我们想要改进的指标</em>，并且<em class="kw">测量它们的趋势</em>。</p><h1 id="c8ae" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">衡量绩效</h1><p id="3d5f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了选择合适的度量标准，我们可以参考连续交付的概念。对于开发和部署软件的团队来说，在这个领域已经做了很多关于良好实践的研究。即使我们不是自己开发这个软件，我们也可以借鉴相同的想法。</p><p id="a86f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">特别是，所谓的<a class="ae mo" href="https://www.blueoptima.com/blog/how-to-measure-devops-success-why-dora-metrics-are-important" rel="noopener ugc nofollow" target="_blank"> DORA (DevOps研究和评估)度量</a>是团队寻求提高软件开发性能的顶级度量。在我们寻求改进修补的过程中，跟踪这些指标也很重要:</p><ul class=""><li id="ae71" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">(增加)部署频率</li><li id="0eb4" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">交货提前期(减少)</li><li id="dc33" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">(递减)平均恢复时间(MTTR)</li><li id="2015" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">(增加)成功发布的比例</li></ul><p id="d1dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的是，这些是我们可以定量测量的精确的东西。在高层次上，您会这样计算它们:</p><ul class=""><li id="f1fb" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><em class="kw">频率</em> = <code class="fe mp mq mr ms b">(number of deployments) / (time period)</code></li><li id="add1" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><em class="kw">提前期</em> = <code class="fe mp mq mr ms b">(time of production deployment) - (time of associated code commit)</code></li><li id="2f5e" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><em class="kw"> MTTR </em> = <code class="fe mp mq mr ms b">(time an incident began) - (time an incident ended)</code></li><li id="0d95" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><em class="kw">更改故障率</em> = <code class="fe mp mq mr ms b">(number of releases triggering incidents) / (number of releases) = 1 - proportion of successful releases</code></li></ul><p id="c4cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从广义上讲，这四个指标与(1)部署事件的计数和收集时间(部署频率和交付时间)以及(2)将这些部署事件与服务事件的计数和时间(MTTR和变更失败率)相关联。</p><p id="aa06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用GitOps repo，您可以完全基于Git历史来测量<em class="kw">部署频率</em>和<em class="kw">交付周期</em>。这是我们将在这篇文章的后续部分深入探讨的内容。</p><p id="6703" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此之前，先给你提个醒。在连续交付模型中，我们希望自动化交付不仅要快速，而且要消除错误。试图优化这些指标以提高速度，而不关注更安全的发布，可能会导致<em class="kw">更差的</em>可靠性。因此，为了对您的交付绩效有一个<em class="kw">完整的</em>了解，我们始终建议<em class="kw">同时</em>通过MTTR和变更失败率指标来跟踪部署风险的度量。这些将使用来自您的事故管理系统的数据进行测量。</p><p id="c1c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，让我们深入了解git能够告诉我们的部署性能。为了帮助我们，我们将使用<code class="fe mp mq mr ms b">mergestat</code>。</p><h1 id="27eb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍<code class="fe mp mq mr ms b"><a class="ae mo" href="https://github.com/askgitdev/askgit" rel="noopener ugc nofollow" target="_blank">mergestat</a></code></h1><p id="1580" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><code class="fe mp mq mr ms b">mergestat</code>是一个通过SQL查询git回购历史的CLI工具。这将为我们提供一种方法来访问GitOps repo编码的关于部署历史的信息。</p><p id="6068" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以根据<a class="ae mo" href="https://docs.mergestat.com/getting-started-cli/installation" rel="noopener ugc nofollow" target="_blank">安装文件</a>进行安装。我确实遇到了一些基于包的安装的小问题——安装预构建的二进制文件似乎是最简单的方法。</p><p id="87fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在git历史中公开数据意味着您可以提出各种不同的问题。有一个<code class="fe mp mq mr ms b">commits</code>表，所以我们可以请求一个所有提交的列表，类似于用<code class="fe mp mq mr ms b">git log</code>得到的列表:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="1f53" class="nb ky iq ms b gy nc nd l ne nf">mergestat 'select * from commits'</span></pre><p id="b799" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了添加每次提交中更改的文件的详细信息，我们将交叉引用<code class="fe mp mq mr ms b">stats</code>表。这将允许我们识别发现和获取新包的提交(即“vendored”)。获取新包的工作流将创建一个包含更改的提交，将包签入到<code class="fe mp mq mr ms b">packages/vendored</code>目录。这使我们能够识别供应商提供的包的更新:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="086b" class="nb ky iq ms b gy nc nd l ne nf">mergestat "select * from commits, stats('', commits.hash) where file_path like 'packages/vendored/%'"</span></pre><p id="0ad1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似地，当提交包括代表生产的期望状态的变更文件时，我们将获得生产部署事件——这些文件在<code class="fe mp mq mr ms b">sync/prod</code>下:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="b50d" class="nb ky iq ms b gy nc nd l ne nf">mergestat "select * from commits, stats('', commits.hash) where file_path like 'sync/prod/%'"</span></pre><p id="3315" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像ArgoCD这样的GitOps工具的出现确保了对Git repo的这些更新产生实际的部署事件。</p><p id="66d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">mergestat</code>的另一个便利特性是能够将数据导出到SQLite数据库，命令如下:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="ea31" class="nb ky iq ms b gy nc nd l ne nf">mergestat export askgit-commits-stats-db.sqlite3 -e commits -e "select * from commits" -e stats -e "select * from commits,stats('', commits.hash)"</span></pre><p id="737e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于mergestat中随着时间的推移发生了一些模式更改，我们需要添加一些列重新映射，以便仪表板查询稍后能够正常工作:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="dfaf" class="nb ky iq ms b gy nc nd l ne nf">mergestat export askgit-commits-stats-db.sqlite3 -e commits -e "select hash as id,* from commits;" -e stats -e "SELECT commits.hash as "commit_id", stats.file_path as "file", stats.additions, stats.deletions FROM commits, stats('', commits.hash)"</span></pre><p id="5d83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">许多工具都很好地支持SQLite，所以一旦有了SQLite数据库，就有许多工具可以进一步处理数据。我使用<code class="fe mp mq mr ms b">pgloader</code>将数据加载到Postgres中，以便我们能够从Grafana查询它。您可以按照这些说明进行安装。</p><p id="2894" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将<a class="ae mo" href="https://github.com/benjvi/measuring-patching-cadence/blob/main/askgit-sqlite-to-postgres.txt" rel="noopener ugc nofollow" target="_blank">数据加载配置</a>下载到文件<code class="fe mp mq mr ms b">askgit-sqlite-to-postgres.txt</code>中。这指定了如何将数据加载到Postgres中，以便我们能够从Grafana查询它。</p><p id="7dc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您需要一个已经设置好的Postgres服务器来连接。使用服务器的连接详细信息自定义此配置文件。这不包含凭据。相反，导出<code class="fe mp mq mr ms b">PGUSER</code>和<code class="fe mp mq mr ms b">PGPASSWORD</code>环境变量供<code class="fe mp mq mr ms b">pgloader</code>读取。</p><p id="357a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置完成后，要加载数据，您将运行:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="91c4" class="nb ky iq ms b gy nc nd l ne nf">pgloader askgit-sqlite-to-postgres.txt</span></pre><p id="32fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还创建了一个KubernetesT5 】,您可以运行它来不断地从您的repo加载最新的数据(确保您更新它以指向您的repo！).</p><h1 id="2876" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">包更新流程</h1><p id="f9ea" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我的包的端到端更新过程如下所示:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4a2ebb224015fc7c9bbfa199b168bed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f-1TXPXYBdE-beoN.png"/></div></div></figure><ol class=""><li id="e94b" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv ng mg mh mi bi translated">有一个每天安排的售货工作流程，它运行<code class="fe mp mq mr ms b">vendir sync</code>并检查结果。这将根据<code class="fe mp mq mr ms b">vendir.yml</code>中的包规范将任何新的包版本添加到<code class="fe mp mq mr ms b">packages/vendored/</code>文件夹中</li><li id="a92d" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv ng mg mh mi bi translated">在这之后，会触发额外的工作流，将清单签入到<code class="fe mp mq mr ms b">sync/prod</code>文件夹，然后将更改推送到一个分支，最后提交一个PR</li><li id="fa85" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv ng mg mh mi bi translated">我手动审核PR并批准，合并到主分支。这将触发变更的自动部署</li><li id="b8ac" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv ng mg mh mi bi translated">ArgoCD在<code class="fe mp mq mr ms b">sync/prod</code>文件夹中部署更新的包(通过它的连续协调循环)</li></ol><p id="e4b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这一点，我们可以继续根据<em class="kw">提前期</em>和<em class="kw">频率</em>来衡量该流程的节奏。</p><h1 id="9353" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测量提前期</h1><p id="1b7b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">交付周期是衡量这一更新过程需要多长时间的指标。这是补丁优化中最重要的指标，因为它将告诉我们我们部署的版本落后于我们想要的版本多长时间。如果我们的交付时间超过几天，我们可能会开始承担运行过时软件的风险。总交付周期是从第一次发现一个更新包到它被部署到产品中的时间间隔。</p><p id="9f80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将它应用到上一节描述的实际部署工作流中。我们将假设ArgoCD工作得相当快，所以它在部署上的滞后可以忽略不计。因此，查询变成了:“从<code class="fe mp mq mr ms b">packages/vendored</code>到<code class="fe mp mq mr ms b">sync/prod</code>的变化需要多长时间？为了找到答案，我们应该查看每一对提交。我们首先考虑每个包的销售承诺。对于每个提交，我们可以搜索下一个相关的部署提交。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/352f15a45c3043c9358dfe8e23b15ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*REpBl2QDkZH6o5QV.png"/></div></div></figure><p id="2e26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，这在Postgres中变成了两个物化视图:</p><ul class=""><li id="fbe0" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><code class="fe mp mq mr ms b"><a class="ae mo" href="https://github.com/benjvi/measuring-patching-cadence/blob/d569177967bf4f583a44e9f66eee709f4c603981/create-package-deploy-view.sql#L4" rel="noopener ugc nofollow" target="_blank">package_folder_commits</a></code>按包和目的(销售、部署等)对提交的文件更改进行分类</li><li id="a691" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><code class="fe mp mq mr ms b"><a class="ae mo" href="https://github.com/benjvi/measuring-patching-cadence/blob/d569177967bf4f583a44e9f66eee709f4c603981/create-package-deploy-view.sql#L46" rel="noopener ugc nofollow" target="_blank">package_commit_pair_cause_to_deploy</a></code>将销售包更改与后续的包部署配对，并计算两次提交之间的时间差作为<code class="fe mp mq mr ms b">days_between_vendor_and_deploy</code>列</li></ul><p id="fd5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过下载这个SQL文件创建视图，为Postgres设置环境变量，并运行:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="df64" class="nb ky iq ms b gy nc nd l ne nf">psql -f "create-package-deploy-view.sql"</span></pre><p id="ba2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于此，我们可以通过查询视图获得每个包更新的部署延迟:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="0d85" class="nb ky iq ms b gy nc nd l ne nf">select deploy_commit_package, cause_commit_id, deploy_commit_id, days_between_vendor_and_deploy from package_commit_pair_cause_to_deploy;</span></pre><p id="3098" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定义这些视图确实有一些棘手的部分，并且有可能在数据中发现异常:</p><ul class=""><li id="d45c" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">在我的工作流中，作为触发的工作流的一部分，在所提供的更改之后，立即对部署文件夹进行提交(在分支上)。视图必须排除这个提交，而是只查看部署PR的时间戳。为此，我们需要<em class="kw">强制合并提交</em>，并且只使用那些提交来标识部署时间</li><li id="14a6" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">当部署过程发生变化时，很难始终如一地比较结果。我通过在几个月的查询中保留旧的和新的名字，设法解决了一些文件夹重组的问题。然而，一般来说，包含重构变更的提交很难处理。我发现的唯一真正的答案是单独分析任何异常提交。</li></ul><p id="03e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要做的最后一件事是创建这些数据的聚合，以便我们可以跟踪一段时间内的趋势，但首先，让我们看看如何从这些视图中获得部署数量。</p><h1 id="448a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测量部署频率</h1><p id="0fc0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">部署频率有助于我们了解正在进行的部署工作量，也就是说，部署更新包的次数。在打补丁的情况下，部署越多不一定越好，因为如果软件不需要打补丁也不是坏事。也就是说，我工作过的大多数团队总是在修补上落后，至少，这个指标应该显示至少<em class="kw">一些</em>修补正在进行。</p><p id="e143" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">具体来说，这里我们只想测量那些与包更新相关的部署。可能存在与其他事件(如配置更改)相关联的部署。因为我们已经必须将部署提交与供应商提交进行匹配以找到交付周期，所以我们将只考虑与供应商提交相匹配的部署提交。这可确保只计算与软件包更新相关的部署。</p><p id="631f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">过滤数据后，计算唯一部署提交的数量。我们可以基于上一节中定义的视图，使用以下查询来完成此操作:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="f32b" class="nb ky iq ms b gy nc nd l ne nf">select count(*) from package_commit_pair_cause_to_deploy;</span></pre><p id="d025" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了获得部署频率，我们需要选择一个时间段来测量这个计数。我们将在下一部分构建仪表板时完成这项工作。</p><p id="cc04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在已经有了所有需要的原始数据，所以我们可以开始构建一个Grafana仪表板，以便于跟踪趋势。作为dashboard安装的先决条件，您需要设置Postgres数据源，以便dashboard可以查询数据。</p><h1 id="801a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">包装交付时间</h1><p id="c181" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了得到总的交付时间，我们将计算所有已部署包的平均延迟时间。我们将每月计算一次。这将提供足够的数据来聚合，同时足够短以捕捉性能的变化。与SLO一样，通常在28天的时间窗口内汇总指标，这样做的目的是从高层次了解流程的运行情况，以及是否需要额外的努力来改进它。使用这些类型的指标，我们感兴趣的是跟踪几周和几个月的性能，而不是几小时和几天。</p><p id="eb3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获取每月提前期趋势的查询将是:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="51e8" class="nb ky iq ms b gy nc nd l ne nf">select<br/>  date_trunc('month',deploy_commit_author_when) as "time",<br/>  max(days_between_vendor_and_deploy),<br/>  percentile_cont(0.5) WITHIN GROUP (ORDER BY <br/>      days_between_vendor_and_deploy) as "median",<br/>  max(days_between_vendor_and_deploy) <br/>from package_commit_pair_cause_to_deploy<br/>WHERE $__timeFilter(deploy_commit_author_when)<br/>group by 1</span></pre><p id="b12b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这给了我们每个月的最大、最小和中间交货时间。请注意，这是计算每个日历月的值，而不是窗口期的值。如果不依赖于<a class="ae mo" href="https://docs.timescale.com/api/latest/hyperfunctions/time_bucket/" rel="noopener ugc nofollow" target="_blank">的timescaledb扩展</a>，在普通Postgres中不可能实现后者。但这种更简单的方式无论如何都符合我们的需求。有时候简单是一种美德——日历月份很容易理解。因此，相应的Grafana面板将如下所示:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/f15d4e4eb42601c8108c68e7ed102ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0rsfKFeuXfdRftz9.png"/></div></div></figure><p id="ece1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一个单独的面板给出:最重要的数字，本月的交货时间和过去3个月的平均值。</p><p id="e44a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现绘制原始数据也很有帮助，因此我们可以看到哪些包是异常值。因此，仪表板上有几个与交付周期相关的不同面板:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/427588fe7c94d4788abc626c39e33bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YTpjtQwkHrjSQTQ7.png"/></div></div></figure><p id="24ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们的前置时间！令人高兴的是，我的包裹交付时间似乎在下降。让我们看看频率。</p><h1 id="f256" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">包部署频率</h1><p id="3b35" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">与交付周期类似，我们将计算每个日历月的部署频率，计算不同包部署的数量:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="e1a6" class="nb ky iq ms b gy nc nd l ne nf">select<br/>  date_trunc('month',deploy_commit_author_when) as "time",<br/>  count(distinct (deploy_commit_id || deploy_commit_package))<br/>      as "total"<br/>from package_commit_pair_cause_to_deploy<br/>WHERE <br/>  $__timeFilter(deploy_commit_author_when)<br/>  and deploy_commit_parent_folder='prod'<br/>group by 1<br/>order by 1</span></pre><p id="db96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和以前一样，也有数字显示本月和过去三个月的部署频率。在这种情况下，我还发现引入第二个查询很有用，它按包划分部署数量:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/91f2e903fef0051df5536aa2a489bfaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0a7pC6rRj3NwS5uW.png"/></div></div></figure><p id="9b03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于其他上下文，仪表板还包括销售流程的相同频率统计数据:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/8ca23ff292866b9e4d60894c6e081c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y-ab5E299amlNxiw.png"/></div></div></figure><p id="face" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它包括所有软件包更新的计数，按软件包分类:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/290596cb05de010d64f7c943a9f1c1a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3SG635M_Ik2s10gq.png"/></div></div></figure><p id="365e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们有了一套很好的仪表板来分析部署频率。这些数字显示，每个月都在持续进行修补，由于需要“弥补”前几个月未应用的一些补丁，6月份又部署了一些补丁。</p><h1 id="5b1e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">概述</h1><p id="ea50" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了启动和运行控制面板，我们现在有:</p><ul class=""><li id="59aa" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">修改了文件<code class="fe mp mq mr ms b"><a class="ae mo" href="https://github.com/benjvi/measuring-patching-cadence/blob/main/askgit-sqlite-to-postgres.txt" rel="noopener ugc nofollow" target="_blank">askgit-sqlite-to-postgres.txt</a></code>和/或<code class="fe mp mq mr ms b"><a class="ae mo" href="https://github.com/benjvi/measuring-patching-cadence/blob/main/cronjob.yml" rel="noopener ugc nofollow" target="_blank">cronjob.yml</a></code>中要分析的Postgres和git repo的详细信息</li><li id="e30a" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">然后将数据加载到Postgres中—通过运行以下命令手动提取和加载数据:</li></ul><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="2112" class="nb ky iq ms b gy nc nd l ne nf">askgit export askgit-commits-stats-db.sqlite3 -e commits -e "select hash as id,* from commits;" -e stats -e "SELECT commits.hash as "commit_id", stats.file_path as "file", stats.additions, stats.deletions FROM commits, stats('', commits.hash)"</span><span id="6738" class="nb ky iq ms b gy nl nd l ne nf">pgloader askgit-sqlite-to-postgres.txt</span><span id="fed9" class="nb ky iq ms b gy nl nd l ne nf">psql -f "create-package-deploy-view.sql"</span></pre><ul class=""><li id="e962" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">或者通过应用Kubernetes CronJob: <code class="fe mp mq mr ms b">kubectl apply -f cronjob.yml</code>定期提取和加载数据，并等待它至少运行一次</li></ul><p id="4def" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以在Grafana中设置一个<code class="fe mp mq mr ms b">askgit</code> Postgres数据源，并导入<a class="ae mo" href="https://grafana.com/grafana/dashboards/14970" rel="noopener ugc nofollow" target="_blank">仪表板</a></p><p id="c125" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个仪表板包含我们想要测量的主要指标，因此现在我们可以考虑我们测量的局限性，以及它们如何适应更广泛的监控策略。</p><h1 id="cb7c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">建议的补充指标</h1><p id="c742" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这里，我们只测量通过定义的自动化流程部署或修补的软件包。在此过程之外部署的任何包都不会被考虑。因此，监控运行时系统上所有项目的特定属性的工具可以成为这些度量的有用补充，为版本新鲜度、CVE数量等属性提供保证，并允许对整体漏洞做出一些判断。为了突出这一点，仪表板包括一个使用Prometheus和<a class="ae mo" href="https://github.com/kaidotdev/kube-trivy-exporter" rel="noopener ugc nofollow" target="_blank"> kube-trivy-exporter </a>的面板，以显示具有关键cv的图像数量。</p><p id="2637" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，跟踪和考虑与部署风险相关的度量标准作为这些与速度相关的度量标准的另一个补充也是明智的。</p><h1 id="4625" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="d263" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们现在有了一个控制面板，可以显示我们的自动修补流程运行得有多好！至少，就节奏而言,<em class="kw">的表现如何。</em></p><p id="e68d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该仪表板涵盖了部署交付周期和部署频率，构成了DORA指标的一半。因此，我们现在知道了我们部署的节奏，并且能够随着时间的推移跟踪改进或恶化。在我使用dashboard的几个月里，它确实提醒了我，每当我忽略补丁部署时，就要更加注意它们。</p></div></div>    
</body>
</html>