<html>
<head>
<title>A newbie way to play with ScalaCheck</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个新手玩ScalaCheck的方法</h1>
<blockquote>原文：<a href="https://itnext.io/a-newbie-way-to-play-with-scalacheck-333cbabfc00a?source=collection_archive---------6-----------------------#2020-06-19">https://itnext.io/a-newbie-way-to-play-with-scalacheck-333cbabfc00a?source=collection_archive---------6-----------------------#2020-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="49bc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:发电机</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2506000012082d437e4171a7c208e484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7F8_0BRNpap4sPza4Xguog.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://www.flickr.com/photos/gerlos/" rel="noopener ugc nofollow" target="_blank">https://www.flickr.com/photos/gerlos/</a></figcaption></figure><h2 id="c598" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">测试的重要性</h2><p id="271e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">一个好的程序员总是假设他的应用程序会失败。他尽最大努力编写一个可靠的代码，但错误是不可避免的。这就是为什么测试是应用程序开发的关键部分。"在正确测试应用程序之前，它是不存在的."——这是我从我的Scala导师(<a class="ml mm ep" href="https://medium.com/u/a43d48be8213?source=post_page-----333cbabfc00a--------------------------------" rel="noopener" target="_blank">温德森·费雷拉</a>)那里听到的。</p><p id="71be" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">大多数程序员编写测试只有一个目的，那就是验证应用程序做了它应该做的事情。尽管这是一个很好的起点，但这种方法并不能涵盖所有可能的场景。适当的测试会揭示出你代码中的弱点。这将确保代码的新变化不会引入新的错误。测试还决定了应用程序在压力下的极限。</p><h2 id="f036" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为什么是斯卡拉切克？</h2><p id="e4f6" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在Scala语言中执行测试有三个主要角色:ScalaTest、specs2和ScalaCheck。如果你是一名Java程序员，你会想要探索ScalaCheck测试方法，因为它们与Scala.js扩展的帮助是兼容的。ScalaCheck可以与ScalaTest和specs2集成。如果你对函数式编程感兴趣，那么ScalaCheck绝对是值得一看的。</p><p id="4e42" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">ScalaCheck的优势在于并行执行自动化测试。它是专门设计来通过运行多个测试来检查您的代码的，这些测试使用自动为您的函数生成的数据。ScalaCheck解决了上述正确测试所需的所有场景。与JUnit或ScalaTest测试方式相比，ScalaCheck是一种不同的思维方式，需要时间来开发。ScalaCheck测试代码的属性，并不关注测试中使用的值。</p><h2 id="4f73" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">斯卡拉切克简介</h2><p id="e9fc" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">ScalaCheck不是一个容易进入并开始使用的资源。但是我认为这是可能的，即使对新手来说，只要你得到一本书或一位导师的良好指导。该资源的文档主要面向有经验的Scala用户。我将把它简化成初学者的语言，这样更多的人会对使用这个强大的测试工具感兴趣。</p><p id="374f" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">ScalaCheck的两个基本结构是<strong class="lu ir">属性</strong>，用于测试函数的行为，以及<strong class="lu ir">生成器</strong>，用于为代码中的参数生成数据。最简单的方法是理解ScalaCheck如何生成大量的值，既包括内置数据类型，如<em class="ms"> Int </em>和<em class="ms"> String </em>(在Scala中是对象，不是原始数据类型)，也包括定制的用法。</p><h2 id="2f58" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">实际例子</h2><p id="df09" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">例如，如何测试一个简单的<em class="ms">计算器</em>类的<em class="ms">计算器</em>方法？</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="b52d" class="kw kx iq mu b gy my mz l na nb">#code for a <em class="ms">Calculator</em> class</span><span id="c2d6" class="kw kx iq mu b gy nc mz l na nb">package caskApi<br/><br/>import caskApi.Operation.{Operation, <em class="ms">ADDITION</em>, <em class="ms">SUBTRACTION</em>, <em class="ms">DIVISION</em>, <em class="ms">MULTIPLICATION</em>}<br/><br/>case class Calculator(a: Int, b: BigDecimal) {<br/><br/>  def calculator(action: Operation): String = {<br/>    val calculation = action match {<br/>      case <em class="ms">ADDITION </em>=&gt; a + b<br/>      case <em class="ms">SUBTRACTION </em>=&gt; a - b<br/>      case <em class="ms">DIVISION </em>=&gt; a * b<br/>      case <em class="ms">MULTIPLICATION </em>=&gt; a / b<br/>    }<br/><br/>     "The answer is %s ".format(calculation)<br/>  }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d17e61f33b5ffb5b28853121b4373c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*s5sqewnduJFQDukcnAGDBw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我的项目内部结构</figcaption></figure><p id="5733" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">首先，将ScalaCheck添加到您的<em class="ms"> sbt </em>构建中以获得依赖关系。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="135f" class="kw kx iq mu b gy my mz l na nb"><em class="ms">name </em>:= "MyScalaProject"<br/><br/><em class="ms">version </em>:= "1.0"<br/><br/><em class="ms">scalaVersion </em>:= "2.13.1"<br/><br/><em class="ms">libraryDependencies </em>+= "org.scalacheck" %% "scalacheck" % "1.14.3" % <em class="ms">Test</em></span></pre><p id="9b57" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">类<em class="ms">计算器</em>的参数是数字数据类型，这个类<em class="ms">计算器</em>的一个方法有一个自定义<em class="ms">操作</em>变量。默认情况下，ScalaCheck中的生成器可以生成各种<em class="ms"> Int </em>和<em class="ms"> String </em>值。您想要创建自己的随机数范围而不依赖于ScalaCheck生成的值的原因是，首先，ScalaCheck不会为您定制的对象类型生成值(在我的示例中，是<em class="ms">操作</em>变量的值)。其次，有时你想要对你的测试有更多的控制。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="cb1f" class="kw kx iq mu b gy my mz l na nb">#code for default Generators</span><span id="8ce2" class="kw kx iq mu b gy nc mz l na nb">package caskApi<br/><br/>import caskApi.Operation.Operation<br/>import org.scalacheck.Gen<br/><br/>object ScalaCheck extends App {</span><span id="bdee" class="kw kx iq mu b gy nc mz l na nb">  val <em class="ms">aGen</em>: Gen[Int] = Gen.<em class="ms">choose</em>(-100, 1000)<br/><br/>  val <em class="ms">bGen</em>: Gen[BigDecimal] = for {<br/>    value &lt;- Gen.<em class="ms">chooseNum</em>(-100000000, 10000000)<br/>    valueDecimal = <em class="ms">BigDecimal</em>.<em class="ms">valueOf</em>(value)<br/>  } yield valueDecimal<br/>...</span></pre><p id="19ff" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">我在类<em class="ms">计算器</em>中的第一个参数是一个整数<em class="ms">一个</em>。因此，如果我想在一个特定的时间间隔内生成一个数，我使用一个基本的生成器<em class="ms"> Gen.choose </em>方法，并指定范围内的最小值和最大值。这是一个在给定的包含范围内生成随机值的生成器。</p><p id="bf8f" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">我在Calculator类中的第二个参数是BigDecimal类型的。如果你试图对这个数字类型使用相同的方法，那么Scala将不会这样做。你需要更有创意，把一个生成的数字变成这种类型。为此，我首先使用<em class="ms"> Gen.chooseNum </em>方法，该方法在给定的包含范围内生成数字，额外的权重为0、+/-1、两端以及提供的任何特殊数字。之后，你需要将生成的值转换成BigDecimal。为了结合这两个动作，我使用了Scala <em class="ms">作为</em>的理解构造，这是一个非常通用的构造。</p><p id="7c53" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">接下来，我将展示一个为我在代码中单独定义的结构生成定制生成器的示例。我定义了一个自定义类型<em class="ms">操作，</em>有四个可能的值(加、减、除、乘)。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="cad2" class="kw kx iq mu b gy my mz l na nb">#code for a custom object <em class="ms">Operation</em></span><span id="de97" class="kw kx iq mu b gy nc mz l na nb">package caskApi<br/><br/>object Operation extends Enumeration {<br/> type Operation = Value<br/>  val <em class="ms">ADDITION</em>, <em class="ms">SUBTRACTION</em>, <em class="ms">DIVISION</em>, <em class="ms">MULTIPLICATION </em>= Value<br/>}</span></pre><p id="91fe" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">这个自定义对象<em class="ms">操作</em>是在项目级别定义的，而所有生成器都是在测试级别的<em class="ms"> ScalaCheck </em>对象中定义的(参见上面我的项目内部结构)。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="0dd2" class="kw kx iq mu b gy my mz l na nb">#code for a custom Generator (in <em class="ms">ScalaCheck</em> test object)</span><span id="f118" class="kw kx iq mu b gy nc mz l na nb">val <em class="ms">operatorGen</em>: Gen[Operation] = Gen.<em class="ms">frequency</em>(<br/>  2 -&gt; Operation.<em class="ms">MULTIPLICATION</em>, 1 -&gt; Operation.<em class="ms">SUBTRACTION</em>,<br/>  4 -&gt; Operation.<em class="ms">DIVISION</em>, 5 -&gt; Operation.<em class="ms">ADDITION<br/></em>)</span></pre><p id="6b17" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">我们在<em class="ms"> operatorGen </em>中定义了一个运算分布，这意味着，例如，乘法运算的次数将是减法运算的2倍，加法运算的次数将是减法运算的5倍。</p><p id="985f" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">最后，我将展示为您的类和方法创建定制生成器的方法。为此，您需要组合以前生成的该类或方法的变量。同样，我们使用Scala灵活的<em class="ms">作为</em>语法。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="ff90" class="kw kx iq mu b gy my mz l na nb">#code for generating an instance of <em class="ms">Calculator</em> class (in <em class="ms">ScalaCheck</em> test object)</span><span id="3ed7" class="kw kx iq mu b gy nc mz l na nb">val <em class="ms">calculatorGen</em>: Gen[Calculator] = for {<br/>  a &lt;- <em class="ms">aGen<br/>  </em>b &lt;- <em class="ms">bGen<br/></em>}  yield Calculator(a, b)</span><span id="8d7b" class="kw kx iq mu b gy nc mz l na nb">#code for generating results for a method of a generated instance of class <em class="ms">Calculator</em> (in <em class="ms">ScalaCheck</em> test object)</span><span id="8ff6" class="kw kx iq mu b gy nc mz l na nb">val <em class="ms">methodCalcGen</em>: Gen[String] = for {<br/>  c &lt;- <em class="ms">calculatorGen<br/>  </em>operator &lt;- <em class="ms">operatorGen<br/></em>} yield c.calculator(operator)</span></pre><h2 id="0486" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">查看生成数据的样本</h2><p id="f48d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">为了测试ScalaCheck构造，您可以在您的智能中使用<em class="ms"> sbt </em> shell插件。首先调用&gt; <em class="ms">测试:控制台</em>和&gt;导入<em class="ms"> org.scalacheck.Gen._ </em>库包。然后像往常一样，定义所有想要在Scala中检查的参数。在这一点上，我的目标是使用一个<em class="ms">示例</em>方法来展示一种查看生成值的方式。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="70b1" class="kw kx iq mu b gy my mz l na nb">#Scala script in <em class="ms">sbt</em> shell</span><span id="3b79" class="kw kx iq mu b gy nc mz l na nb">scala&gt; import caskApi.{Calculator, Operation}<br/>...</span><span id="ffb4" class="kw kx iq mu b gy nc mz l na nb">scala&gt; val calculatorGen = for {<br/>       a &lt;- aGen<br/>       b &lt;- bGen<br/>       } <br/>       yield Calculator(a, b)<br/>...</span><span id="8cdf" class="kw kx iq mu b gy nc mz l na nb">scala&gt; calculatorGen.sample<br/>res1: Option[caskApi.Calculator] = Some(Calculator(0,-3000))</span></pre><p id="df21" class="pw-post-body-paragraph ls lt iq lu b lv mn jr lx ly mo ju ma lf mp mc md lj mq mf mg ln mr mi mj mk ij bi translated">在我的示例中，为了生成具有两个值的<em class="ms">计算器</em>类的实例，我需要导入在项目级别定义的对象(例如<em class="ms">计算器</em>和<em class="ms">操作</em>)并定义所有变量(例如<em class="ms">阿根</em>和<em class="ms"> bGen </em>，未显示，以及<em class="ms">计算器Gen </em>)。最后，将<em class="ms">样本</em>方法应用到<em class="ms">计算生成</em>变量。在上面的例子中，ScalaCheck Generator生成了一个类<em class="ms">计算器</em>的实例，值a=0，b=-3000。</p><h2 id="3971" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">ScalaCheck发电机奖金</h2><p id="4707" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">ScalaCheck生成器类可以在您的代码中用于数据生成目的，而不仅仅是在ScalaCheck测试的框架中。注意，如果您在项目级别而不是在您的测试包中使用ScalaCheck，那么您应该在您的build.sbt文件中删除% Test extension。如果你想生成数字或字符串，甚至是它们的组合，导入<em class="ms"> org.scalacheck.Gen </em>库，你会看到神奇的事情在几秒钟内发生。如果你对如何生成<em class="ms"> Int </em>和<em class="ms"> String </em>的组合感兴趣，可以在评论区问我。</p><h2 id="8b65" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">未完待续…</h2><p id="1f1a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在“玩ScalaCheck的新手方法”系列的第2部分中，我将展示如何测试一个行为，或者用ScalaCheck语言来说，测试代码的一个属性。</p></div></div>    
</body>
</html>