<html>
<head>
<title>Modern C++ in Advent of Code: Day18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++代码的出现:第18天</h1>
<blockquote>原文：<a href="https://itnext.io/modern-c-in-advent-of-code-day18-54942485460b?source=collection_archive---------0-----------------------#2021-12-18">https://itnext.io/modern-c-in-advent-of-code-day18-54942485460b?source=collection_archive---------0-----------------------#2021-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8edd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天是<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">代码</a>问世的第十八天。今天，我们将在数对树的顶部实现时髦的算法。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/15a222f6b86f6ab0cb4e33e24fa2ed3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsjbOFIbfgsqRtWbGqXY_g.png"/></div></div></figure><p id="46bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，请先尝试解决问题，然后再看解决方案。对于本系列中的所有文章，<a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">请看这个列表</a>。</p><h1 id="6d3f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第18天</h1><p id="3c22" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们第18天的任务是实现一个表示嵌套整数对的数值类型，例如<code class="fe mb mc md me b">[[1,2],3]</code>。然后我们需要实现一个加法运算，其中<code class="fe mb mc md me b">[a]+[b] = [[a],[b]]</code>。当然，这太简单了，所以我们有一个复杂的问题，那就是数字规范化:</p><ul class=""><li id="b376" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">如果任何一对嵌套在四对中，最左边的一对就会爆炸</li><li id="4c66" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果任何一个正则数是10或更大，最左边的这样的正则数分裂</li></ul><p id="d850" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们按照列出的优先级应用这两个操作，但是一个接一个地重复它们。因此，我们只在没有要爆炸的配对时才拆分数字，即等价于:</p><pre class="kn ko kp kq gt mt me mu mv aw mw bi"><span id="e691" class="mx kz iq me b gy my mz l na nb">do {<br/>  while (explode());<br/>} while (split());</span></pre><p id="5e70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分解一对时:</p><ol class=""><li id="1a84" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk nc ml mm mn bi translated">该对被零替换</li><li id="288f" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk nc ml mm mn bi translated">左值被加到左边的第一个常规数字(如果有的话)</li><li id="a5ee" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk nc ml mm mn bi translated">右值被添加到右边的第一个常规数字(如果有的话)</li></ol><p id="6966" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拆分常规数字时:</p><ol class=""><li id="b70b" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk nc ml mm mn bi translated">数字被一对代替</li><li id="d181" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk nc ml mm mn bi translated">该对的左值是除以2的数，向下舍入</li><li id="e076" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk nc ml mm mn bi translated">该对的正确值是该数除以2并向上取整</li></ol><p id="cc88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们感兴趣的是幅度，我们递归地计算为3 *左+2 *右，其中正则数的幅度就是数本身。</p><h2 id="2b64" class="mx kz iq bd la nd ne dn le nf ng dp li jy nh ni lm kc nj nk lq kg nl nm lu nn bi translated">那棵树</h2><p id="6b93" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">递归结构很好地映射到二叉树。每对都有两个元素，要么是正则数，要么是其他对。在C++中有几种方法可以实现这一点。我决定采用一种简单的方法，其中每个节点都包含指向其他节点的指针和一个值:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当两个指针都为空时(第17行)，节点作为一个数字。否则，两个指针都必须有效并指向其他节点。默认构造函数、移动构造函数和移动赋值可以是默认的(第2-4行)。然而，我们需要为我们的复制构造函数和赋值实现一个深度复制(第7、8行)。到<code class="fe mb mc md me b">uint64_t</code>的显式转换将实现幅度功能(第10行)。最后，我们需要实现输入、输出(第19、20行)和加号运算符(第21行)。</p><h2 id="a816" class="mx kz iq bd la nd ne dn le nf ng dp li jy nh ni lm kc nj nk lq kg nl nm lu nn bi translated">试验</h2><p id="b2a7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这样，我们可以使用来自AoC的数据来构建我们的测试:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fd05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<code class="fe mb mc md me b">one_explode</code>函数(第31行)，然后我们可以将它标记为我们类中的朋友，以允许白盒测试。通常不推荐白盒测试，但是我决定偷懒，因为AoC提供了只应用一次explode操作的例子。</p><h2 id="4625" class="mx kz iq bd la nd ne dn le nf ng dp li jy nh ni lm kc nj nk lq kg nl nm lu nn bi translated">深层拷贝</h2><p id="7583" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让我们从实现深度拷贝复制构造函数和赋值开始:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="412f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要关注终端节点。除此之外，我们可以通过构造一个唯一的指针递归调用复制构造函数(第4–5行和第18–19行)。</p><h2 id="ee20" class="mx kz iq bd la nd ne dn le nf ng dp li jy nh ni lm kc nj nk lq kg nl nm lu nn bi translated">解析和序列化</h2><p id="d13f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">幸运的是，格式很简单，所以我们只检查意外的特殊字符，否则解析整数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="3a04" class="mx kz iq bd la nd ne dn le nf ng dp li jy nh ni lm kc nj nk lq kg nl nm lu nn bi translated">重要</h2><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="77dd" class="mx kz iq bd la nd ne dn le nf ng dp li jy nh ni lm kc nj nk lq kg nl nm lu nn bi translated">加</h2><p id="3f14" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">最后，我们必须实现任务的复杂部分，即加号操作符。或者，准确地说，加法运算本身很简单:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8b7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这仍然给我们留下了分解和分割功能。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们保持递归(先左)并在第一次成功分割后终止。终止是由返回<code class="fe mb mc md me b">true</code>(第13行)引起的，然后它被捕获(第3行)并阻止搜索从该点继续向右。</p><p id="6768" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分解操作更加复杂:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2cef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了用零值替换该对(第28–30行)之外，我们还必须跟踪看到的最后一个常规数字(第15行)，一旦我们应用了拆分，就将左边的值加到这个数字上(第24–26行)。一旦我们应用了split，我们仍然需要继续搜索以找到下面的正则数字，然后我们将它增加(第9-11行)该对的右元素的值(第27行)。</p><p id="ce80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们找到了下面的常规数字，调用者将收到一个真返回值(来自第12行),或者如果我们没有找到，可选的将仍然保存一个值(第4行)。</p><h2 id="2bd5" class="mx kz iq bd la nd ne dn le nf ng dp li jy nh ni lm kc nj nk lq kg nl nm lu nn bi translated">解决方法</h2><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6aa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要做的就是读取所有的数字(第2行)并将它们相加(第3行)。然后，我们尝试所有的组合来计算所有二元和的最大值(第6-13行)。</p><h1 id="f80e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">链接和技术说明</h1><p id="4e88" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">每日解决方案存储库位于:<a class="ae kl" href="https://github.com/HappyCerberus/moderncpp-aoc-2021" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/moderncpp-aoc-2021</a>。</p><p id="218d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">看看这个列表，里面有关于《代码降临》</a>其他日子的文章。</p><p id="c7d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请不要忘记亲自尝试<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">降临码</a>。</p><h1 id="b199" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="dbee" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="198a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在推特或LinkedIn 上联系我。</p></div></div>    
</body>
</html>