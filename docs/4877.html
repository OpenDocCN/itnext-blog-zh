<html>
<head>
<title>Authentication in MERN Stack Using JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JWT的MERN堆栈中的认证</h1>
<blockquote>原文：<a href="https://itnext.io/authentication-in-mern-stack-using-jwt-25c966027f77?source=collection_archive---------0-----------------------#2020-10-14">https://itnext.io/authentication-in-mern-stack-using-jwt-25c966027f77?source=collection_archive---------0-----------------------#2020-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fcea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">github:<a class="ae kl" href="https://github.com/mehulk05/Blogapp-using-MERN" rel="noopener ugc nofollow" target="_blank">T3【https://github.com/mehulk05/Blogapp-using-MERN】T5</a></p><p id="08e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现场试玩:<a class="ae kl" href="https://mehulk05.github.io/Blogapp-using-MERN/#/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://mehulk05.github.io/Blogapp-using-MERN/</strong></a></p><p id="9804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">博客:<a class="ae kl" href="https://blogs-by-mehul.blogspot.com/2020/10/authentication-in-mern-stack-using-jwt.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://blogs-by-mehul . blogspot . com/2020/10/authentic ation-in-mern-stack-using-jwt . html</strong></a></p><h1 id="5ed5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">现场演示</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/45b0eede24b06bec58222118ed9ee618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*We-2toukriiKaJlD.gif"/></div></figure><p id="64a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web Token </a>是在您的MERN堆栈应用中实现认证系统的最佳标准之一。在这篇文章中，我们将只是看看认证在MERN堆栈应用程序使用JWT。</p><h1 id="64af" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">什么是JSON Web Token？</h1><p id="66cb" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">JSON Web Token (JWT)是一个开放标准(<a class="ae kl" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a>)，它定义了一种紧凑且独立的方式，以JSON对象的形式在各方之间安全地传输信息</p><h1 id="e9a3" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">什么时候应该使用JSON Web令牌？</h1><p id="1043" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">以下是JSON Web令牌有用的一些场景:</p><ul class=""><li id="bc21" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated"><strong class="jp ir">授权</strong>:这是使用JWT最常见的场景。用户登录后，每个后续请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是目前广泛使用JWT的一个特性，因为它的开销很小，并且能够很容易地跨不同的域使用。</li><li id="ef59" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">信息交换 : JSON Web令牌是一种安全传输信息的好方法。JSON Web令牌的结构是什么？</li></ul><p id="c543" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在其紧凑的形式中，JSON Web令牌由点(<code class="fe ml mm mn mo b">.</code>)分隔的三个部分组成，它们是:</p><ul class=""><li id="d83c" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">页眉</li><li id="72a6" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">有效载荷</li><li id="ce84" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">签名</li></ul><p id="669d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，JWT通常如下所示。</p><p id="6809" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ml mm mn mo b">xxxxx.yyyyy.zzzzz</code></p><p id="d04a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为jwt可以被签名——例如，使用公钥/私钥对——所以您可以确保发送者就是他们所说的那个人。此外，由于签名是使用头部和有效载荷计算的，因此您还可以验证内容没有被篡改。</p><h1 id="414b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">服务器端部分:创建一个JWT</h1><p id="21be" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">所以代码片段有一个注册路径，它将检查用户是否存在。如果用户不存在，它将进一步使用bycrypt模块加密密码，并在创建完用户后返回200状态码。</p><p id="4085" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是登录路径，这里它将检查用户的电子邮件和密码是否匹配。如果在这里找到匹配的用户，我们将执行一个重要的步骤。在这里，我们将创建我们的JWT令牌。</p><pre class="ll lm ln lo gt mp mo mq mr aw ms bi"><span id="8d6a" class="mt kn iq mo b gy mu mv l mw mx">const token = jwt.sign(<br/>        { email: fetchedUser.email, userId: fetchedUser._id },<br/>        "secret_this_should_be_longer",<br/>        { expiresIn: "1h" }<br/>      );res.status(200).json({<br/>        token: token,<br/>        expiresIn: 3600,<br/>        userId: fetchedUser._id<br/>      });</span></pre><ul class=""><li id="a702" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">因此，我们在这里创建JWT令牌，其中“sign”方法的第一个参数是需要放入有效负载(然后放入令牌本身)的信息。</li><li id="bbfd" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">第二个参数是用于创建摘要的密钥。</li><li id="96de" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">第三是期权表示。在本例中，我以秒为单位设置了令牌的到期日期。</li></ul><h1 id="5e7c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">服务器端部分:检查和验证一个JWT(中间件)</h1><pre class="ll lm ln lo gt mp mo mq mr aw ms bi"><span id="3888" class="mt kn iq mo b gy mu mv l mw mx">// <strong class="mo ir">check-auth.js </strong><br/>const jwt = require("jsonwebtoken");module.exports = (req, res, next) =&gt; {<br/>  try { const token = req.headers.authorization.split(" ")[1];<br/> const decodedToken = jwt.verify(<br/>   token,<br/>   "secret_this_should_be_longer"<br/>); req.userData = {<br/>         email: decodedToken.email,<br/>         userId: decodedToken.userId <br/>   };    next();<br/>  } catch (error) {<br/>    res.status(401).json({ message: "Auth failed!" });<br/>  }<br/>};</span></pre><p id="29b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是另一个Node.js片段，用<a class="ae kl" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express.js </a>中间件实现，它拦截所有请求并检查JWT的存在。</p><p id="57fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用一个常见的实现，它期望将JWT传递到HTTP头中，以检查令牌是否包含所需的数据</p><p id="3e7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为验证例程的结果，如果令牌过期，我们将发送HTTP 401 Unauthorized，如果报头中缺少令牌，我们将发送HTTP 400 Bad请求。</p><h1 id="1b08" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">客户端部分:</h1><p id="4b3d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">因此，我们将react作为我们的客户端应用程序，我们将首先设置React应用程序。现在，我们将创建一个全新的react项目，我们将设置react项目与我们在上述步骤中创建的后端进行交互。</p><ol class=""><li id="be13" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk my md me mf bi translated"><strong class="jp ir">创建React应用</strong></li></ol><pre class="ll lm ln lo gt mp mo mq mr aw ms bi"><span id="ffbe" class="mt kn iq mo b gy mu mv l mw mx">npx create-react-app Blogapp-using-mern<br/>cd Blogapp-using-mern<br/>npm start</span></pre><p id="efb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。在Index.js中设置Axios</strong></p><pre class="ll lm ln lo gt mp mo mq mr aw ms bi"><span id="8c3a" class="mt kn iq mo b gy mu mv l mw mx">axios.defaults.baseURL = '<a class="ae kl" href="https://zany-periodic-fisherman.glitch.me/api'" rel="noopener ugc nofollow" target="_blank">https://zany-periodic-fisherman.glitch.me/api'</a>;</span><span id="9181" class="mt kn iq mo b gy mz mv l mw mx">let userData = JSON.parse(localStorage.getItem("userData"))<br/>let token</span><span id="fd0e" class="mt kn iq mo b gy mz mv l mw mx">if (userData) {<br/>  token = userData.token<br/>}<br/>axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;<br/>axios.defaults.headers.post['Content-Type'] = 'application/json';axios.interceptors.request.use(request =&gt; {<br/>  return request;<br/>}, <br/>error =&gt; {<br/>  //  console.log(error);<br/>  return Promise.reject(error);<br/>});</span><span id="48d4" class="mt kn iq mo b gy mz mv l mw mx">axios.interceptors.response.use(response =&gt; {<br/>  return response;<br/>},<br/> error =&gt; {<br/>  console.log(error.response);<br/>  return Promise.reject(error);<br/>});</span></pre><h1 id="49e6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">#9创建验证组件</h1><p id="9600" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">这里，在Auth组件中，我们将有一个表单，我们将根据状态使用它进行登录和注册。点击一个按钮，我们将我们的按钮切换到注册登录，反之亦然。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="d5ad" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">创建授权上下文来管理整个应用中的令牌</h1><pre class="ll lm ln lo gt mp mo mq mr aw ms bi"><span id="c98a" class="mt kn iq mo b gy mu mv l mw mx">import { createContext } from 'react';</span><span id="e6b9" class="mt kn iq mo b gy mz mv l mw mx">export const AuthContext = createContext({<br/>  isLoggedIn: false,<br/>  userId: null,<br/>  token: null,<br/>  login: () =&gt; {},<br/>  logout: () =&gt; {}<br/>});</span></pre><h1 id="80f7" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用AuthContext在App.js中处理身份验证</h1><p id="f854" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">现在，只要用户注册，我们的任务就会在auth组件本身中完成，我们可以在其中显示用户在数据库中创建的成功响应。但是当用户登录时，我们需要管理本地存储中的令牌，并在访问任何路由之前进行一些计算和检查令牌是否有效。这就是我选择app.js来完成所有这些任务的原因。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="dd1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以在上面的代码中，我们用AuthContext包装了所有的路由，它将负责执行Auth context中提供的函数并设置令牌。因此，一旦用户从auth组件登录，控制就转到应用程序组件，在那里遇到登录函数。</p><p id="8e21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在登录函数中，我们设置令牌到期日期和用户数据，并将相同的数据保存在localStorage中。因此，当执行任何路由时，Authcontext都会向所有这些路由提供这些数据。</p><h1 id="f44d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">如果用户通过身份验证，将后端限制为只能读写</h1><p id="51c9" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">有一些关于如何使用拦截器的注释，所有的注释都是依赖于应用程序上下文的，所以把这个片段看作是一个关于如何添加它的例子。</p><p id="64fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，我们使用了名为“authorization”的HTTP头和“Bearer”前缀，因为服务器希望它后面跟着我们从后端接收到的令牌。</p><p id="8103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，我们在本地存储中存储和读取令牌。像以前一样，这只是一个想法，你可能更喜欢一个<code class="fe ml mm mn mo b">SessionStorage</code>或其他东西。</p><p id="1eec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，如果我们想限制我们的后端只读写数据库，只有当用户被认证，我们可以使用我们创建的中间件做到这一点。查看下面的片段。</p><pre class="ll lm ln lo gt mp mo mq mr aw ms bi"><span id="4ac8" class="mt kn iq mo b gy mu mv l mw mx">router.get("/mypost", <br/>checkAuth,<br/>(req, res, next) =&gt; {<br/>    Post.find({creator: req.userData.userId}).then(post =&gt; {<br/>      if (post) {<br/>        res.status(200).json({<br/>            message: "Posts fetched successfully!",<br/>            posts: post<br/>        });<br/>      }<br/>    })<br/>    .catch(e=&gt;{<br/>        console.log(e)<br/>    });<br/>  });</span></pre><p id="4ca5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的<strong class="jp ir"> checkAuth </strong>是我们已经创建的中间件，它将检查请求中的令牌。</p><pre class="ll lm ln lo gt mp mo mq mr aw ms bi"><span id="8985" class="mt kn iq mo b gy mu mv l mw mx">{creator: req.userData.userId}</span></pre><p id="c579" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码行中，我们从中间件中获取创建者，我们将解码后的令牌存储在userID中。如果令牌存在，则只处理请求。</p><h1 id="0b7c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">演示:</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ca"><img src="../Images/0275acc5d5948012de4645ee4b5ffc8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-b_-VD6rawyq_w9-tDqsAA.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated"><strong class="bd ko">没有找到用户</strong></figcaption></figure><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nk"><img src="../Images/aec30c8ed376d6dc3a4de0b5d8084937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6dBCHT2MGdGT4t_xnUijJQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated"><strong class="bd ko">密码不正确</strong></figcaption></figure><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ff1272274124b85ce9d41a5a9d1b1a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/0*-k928fdHkmC4QtKd.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated"><strong class="bd ko">成功登录</strong></figcaption></figure><h1 id="eea0" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="6196" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">JSON Web Token得到了很好的支持。在<a class="ae kl" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank">官网</a>上，你可以找到几乎任何语言的库和工具来使用它，从<a class="ae kl" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>到。NET apps和<a class="ae kl" href="https://www.java.com/" rel="noopener ugc nofollow" target="_blank"> Java </a>到Node.js .这里我们已经使用MERN堆栈应用完成了完整的认证系统。</p><p id="55cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将需要几个小时来实现一个健壮的身份验证方法，但这绝对是值得的。你可以在下面找到相同代码的<a class="ae kl" href="https://github.com/mehulk05/Blogapp-using-MERN" rel="noopener ugc nofollow" target="_blank"> Github repo </a></p><div class="nm nn gp gr no np"><a href="https://github.com/mehulk05/Blogapp-using-MERN" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">mehulk 05/Blogapp-使用-MERN</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od lq np"/></div></div></a></div><h1 id="cb61" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">另外，请阅读我的博客</h1><div class="nm nn gp gr no np"><a href="https://medium.com/@mehulkothari05/blog-app-using-mern-stack-b0b4d69d7ea1" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">使用MERN堆栈的博客应用程序</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">github:https://github . com/mehulk 05/Blogapp-using-MERN</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od lq np"/></div></div></a></div><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/crud-operation-using-mean-stack-7dfa2f51ec8c"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">使用平均堆栈的CRUD操作</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">github:https://github . com/me hulk 05/Blog-using-mean</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">itnext.io</p></div></div><div class="ny l"><div class="of l oa ob oc ny od lq np"/></div></div></a></div><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/authentication-using-jwt-in-mean-stack-6b425247b7d8"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">在均值堆栈中使用JWT的认证</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">从头开始在一个平均堆栈应用程序中使用JWT进行身份验证</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">itnext.io</p></div></div><div class="ny l"><div class="og l oa ob oc ny od lq np"/></div></div></a></div></div></div>    
</body>
</html>