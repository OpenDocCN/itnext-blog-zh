<html>
<head>
<title>Best practices for deploying to Kubernetes using Helm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Helm部署到Kubernetes的最佳实践</h1>
<blockquote>原文：<a href="https://itnext.io/best-practices-for-deploying-to-kubernetes-using-helm-73be1f3040d2?source=collection_archive---------0-----------------------#2019-09-06">https://itnext.io/best-practices-for-deploying-to-kubernetes-using-helm-73be1f3040d2?source=collection_archive---------0-----------------------#2019-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/fefb0d8a73bf9c50b15497a56ff579c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZSKTdmyUh3XnWVld1-tPMA.jpeg"/></div></div></figure><div class=""/><p id="46f7" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这是一系列实用、安全和可重复的Kubernetes部署方法的一部分。这些帖子是建筑<a class="ae lb" href="http://deliverybot.github.io" rel="noopener ugc nofollow" target="_blank"><em class="la">delivery bot</em></a><em class="la">的一部分，是从GitHub部署到Kubernetes的缺失环节。</em></p><p id="ff43" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在上一篇文章中，我们讨论了使用裸Kubernetes清单和<a class="ae lb" href="https://medium.com/@colinjfw/kustomize-deploying-applications-using-the-new-kubernetes-templating-system-43f26706069" rel="noopener"> Kustomize来部署应用程序。Helm是“Kubernetes的包管理器”,因此已经成为管理应用程序部署的最常用工具之一。</a></p><p id="ebfc" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">然而，Helm是一个包格式。不是将代码部署到Kubernetes的工作流。在这篇文章中，我想讨论如何在不同类型的工作流中最有效地使用Helm，以便在Kubernetes上为您的基础设施提供简单而安全的部署。</p><p id="a000" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Helm是围绕图表构建的。基本上，这些是用go模板语言评估的Yaml文件集。图表允许我们为Kubernetes构建模块。我们可以在Helm中声明一组值，用户在部署一个图表来发布一个应用程序时提供这些值，这个图表抽象了向Kubernetes发布某些应用程序的复杂性。</p><h1 id="49c8" class="lc ld je bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">基本舵图</h1><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="76e2" class="mj ld je mf b gy mk ml l mm mn">~/charts/app<br/>├── Chart.yaml<br/>├── README.md<br/>├── templates<br/>│   ├── NOTES.txt<br/>│   ├── _helpers.tpl<br/>│   ├── deployment.yaml<br/>│   ├── ingress.yaml<br/>│   ├── secret.yaml<br/>│   └── service.yaml<br/>└── values.yaml</span></pre><p id="67bb" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">掌舵图的基础包括图表元数据(“Chart.yaml”和“values.yaml”)以及构成主图表的模板。主图表配置包括图表的命名和版本控制。值文件是我们声明由图表模板内部读取的值的地方，这些值可以由图表的用户在外部声明。这是Helm作为一个抽象层，简化了一组可以扩展成大量Kubernetes的值。</p><h2 id="8f47" class="mj ld je bd le mo mp dn li mq mr dp lm kn ms mt lq kr mu mv lu kv mw mx ly my bi translated">部署、服务和入口</h2><p id="61f4" class="pw-post-body-paragraph kc kd je ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz im bi translated">这是大多数专注于发布网络应用的掌舵图的核心。这三种资源是部署应用程序并能够从集群外部与应用程序对话的关键。非常简单:</p><ul class=""><li id="2b55" class="ne nf je ke b kf kg kj kk kn ng kr nh kv ni kz nj nk nl nm bi translated">部署发布您的代码。</li><li id="2b57" class="ne nf je ke b kf nn kj no kn np kr nq kv nr kz nj nk nl nm bi translated">服务在内部将流量路由到您的代码。</li><li id="2a69" class="ne nf je ke b kf nn kj no kn np kr nq kv nr kz nj nk nl nm bi translated">入口资源将进入集群的外部流量路由到您的代码。</li></ul><p id="d346" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这就是为什么这三种资源是发布网络化应用的支柱。让我们看一个Helm图表中服务资源的非常小的例子，以及模板化如何允许我们重新定义选项:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7f97" class="mj ld je mf b gy mk ml l mm mn">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: {{ include "app.fullname" . }}<br/>  labels:<br/>{{ include "app.labels" . | indent 4 }}<br/>spec:<br/>  type: {{ .Values.service.type }}</span></pre><p id="07a3" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这个基本服务资源示例展示了一些go模板工具，用于创建一个助手来指定资源的全名。创建此服务的相应值如下所示:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="433b" class="mj ld je mf b gy mk ml l mm mn">service:<br/>  type: ClusterIP<br/>  port: 80</span></pre><p id="d5cb" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这是一个简单的例子，说明了使用Helm抽象出底层资源的好处。</p><h1 id="c1b2" class="lc ld je bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">固执己见的发布工作流程</h1><p id="c2ee" class="pw-post-body-paragraph kc kd je ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz im bi translated">Helm旨在消除社区在集群中安装软件的重复工作。在选择Helm发布代码时，您最终将采用两种主要的工作流:</p><ol class=""><li id="ded1" class="ne nf je ke b kf kg kj kk kn ng kr nh kv ni kz ns nk nl nm bi translated">将第三方代码发布到集群中。这些代码通常是语义版本，以较慢的节奏发布，根据更新周期可能是每月或每年。</li><li id="4e9d" class="ne nf je ke b kf nn kj no kn np kr nq kv nr kz ns nk nl nm bi translated">持续交付到您的Kubernetes集群。这段代码经常每天发布，甚至比这更频繁。</li></ol><p id="5c88" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">第一种情况是Helm最初的设计目的。它要求图表实现语义版本控制，并使图表升级相对简单。为第三方软件包使用Helm的最有效方式是使用<a class="ae lb" href="https://www.terraform.io/docs/providers/helm/index.html" rel="noopener ugc nofollow" target="_blank"> Terraform提供者</a>。这允许在您的集群中有一个稳定一致的发布过程。这通常作为代码工作流与基础设施的其余部分联系在一起。</p><p id="2aa5" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这篇文章的主要目标是看看如何在连续交付中使用Helm。开始时，有效地做到这一点似乎很简单，但要确保您的部署是有效的，需要记住一些事情。</p><p id="9ac5" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">使用CLI部署Helm相对简单。指定以下命令集，使用生产值文件中的值在默认命名空间中发布新图表:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="38e0" class="mj ld je mf b gy mk ml l mm mn">helm upgrade --install release-name \<br/>  --namespace default \<br/>  --values ./production.yml</span></pre><p id="2653" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">当我运行这个命令时，实际上会发生什么？在引擎盖下，Helm有一个名为Tiller的服务器端实现。Helm打开一个到Kubernetes集群的连接，并将Helm图表以及作为参数传入的值写入这个连接。服务器端组件呈现带有这些值的模板，并将它们应用到Kubernetes集群中。</p><p id="19a5" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这些是使用Helm运行部署的基础。固执己见的部分和您的工作流涉及到计算什么值作为参数传递以及何时运行Helm upgrade命令。让我们讨论一下在您的组织中实现这一目标的一些正确方法。</p><h2 id="bba5" class="mj ld je bd le mo mp dn li mq mr dp lm kn ms mt lq kr mu mv lu kv mw mx ly my bi translated">避免每个服务都有一个图表</h2><p id="a78f" class="pw-post-body-paragraph kc kd je ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz im bi translated">使用掌舵图的一个好处是，您可以将整个组织或项目中可能一致的通用配置合并到一个图表中。在您想要部署的每个存储库中放置一个图表可能更简单，但是要投资拥有一组核心图表，用于整个组织的服务。</p><p id="529e" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这可以加快标准化运行状况检查路径的速度，并保持跨资源的通用配置。此外，如果您想随着Kubernetes资源的成熟而采用新的api版本，您将能够从一个中心位置做到这一点。</p><p id="7b0a" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">舵图会变得非常冗长，实际上很难写好。您需要注意确保未定义的变量会出错，标签是一致的，并且不会有任何Yaml缩进错误。最好将舵图的创作交给那些有使用Kubernetes经验的人，并允许您的开发人员将它们作为模块使用。</p><h2 id="933e" class="mj ld je bd le mo mp dn li mq mr dp lm kn ms mt lq kr mu mv lu kv mw mx ly my bi translated">分离生产和暂存配置值</h2><p id="5df8" class="pw-post-body-paragraph kc kd je ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz im bi translated">推入图表中的配置值应该在不同的环境中是不同的。构建简单的可扩展图表，可以根据环境进行覆盖。</p><p id="8df6" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">例如，一个好的工作流应该在每个环境中有不同的值文件，并且在配置上有特定的差异:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6500" class="mj ld je mf b gy mk ml l mm mn">~/myapp<br/>└── config<br/>    ├── production.yml<br/>    └── staging.yml</span></pre><p id="f4ae" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">每个值文件的使用取决于部署环境。这与使用if语句或其他逻辑将配置放入舵图形成对比。Helm是用来抽象出Kubernetes资源和价值的，文件是传递您的环境和应用程序特定信息的方式。</p><p id="9984" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">确保使用“require”语句和林挺工具，以确保在部署时没有未定义的值。如果未定义以下变量，实际上会导致相对严重的配置问题:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c4a2" class="mj ld je mf b gy mk ml l mm mn">host: {{ .Values.hostPrefix }}.example.com</span></pre><h2 id="bd98" class="mj ld je bd le mo mp dn li mq mr dp lm kn ms mt lq kr mu mv lu kv mw mx ly my bi translated">秘密管理</h2><p id="8441" class="pw-post-body-paragraph kc kd je ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz im bi translated">Kubernetes秘密是管理应用程序秘密的最简单的方法之一。Helm并没有试图以任何方式管理机密，你可能会陷入试图配置复杂的工作流程。秘密管理的一个简单的初步建议是:</p><ol class=""><li id="6403" class="ne nf je ke b kf kg kj kk kn ng kr nh kv ni kz ns nk nl nm bi translated">使用您的CI/CD提供商将机密存储在他们的仪表板中。</li><li id="853e" class="ne nf je ke b kf nn kj no kn np kr nq kv nr kz ns nk nl nm bi translated">在部署时将秘密值传递到图表值中。</li><li id="f25c" class="ne nf je ke b kf nn kj no kn np kr nq kv nr kz ns nk nl nm bi translated">当这些秘密值改变时，使用<a class="ae lb" href="https://github.com/helm/helm/blob/master/docs/charts_tips_and_tricks.md#automatically-roll-deployments-when-configmaps-or-secrets-change" rel="noopener ugc nofollow" target="_blank">校验和来推出pod</a>。</li></ol><p id="0658" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们希望将一个新的秘密发布到集群中，以便在我们的部署管道中可审计和可见。我们也希望开发者能够访问这个。一如既往，想出适合你情况的最佳解决方案。</p><p id="92c8" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><a class="ae lb" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> Vault </a>也是一个神奇的秘密管理工具，它与Kubernetes深度集成，提高了安全性。它可能需要较长的设置时间，但它提供了一些高级功能，您的组织可以在以后利用这些功能。</p><h2 id="d869" class="mj ld je bd le mo mp dn li mq mr dp lm kn ms mt lq kr mu mv lu kv mw mx ly my bi translated">编辑值</h2><p id="cc2c" class="pw-post-body-paragraph kc kd je ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz im bi translated">确保在使用Helm CLI时，只有Helm会更改Kubernetes清单中的值。例如，不要在Helm之外修改部署的副本，然后使用Helm更改值。如果你以前使用过Kubernetes，你可能使用过<code class="fe nt nu nv mf b">kubectl apply</code>工具。这是将基础设施应用到集群中的最简单的方法之一。Helm没有使用与Kubectl相同的技术<a class="ae lb" href="https://github.com/helm/helm/issues/2070#issuecomment-284839395" rel="noopener ugc nofollow" target="_blank">。这意味着，如果您在Helm之外编辑基础设施，下次运行Helm命令时可能会出现问题。</a></p><h2 id="a4da" class="mj ld je bd le mo mp dn li mq mr dp lm kn ms mt lq kr mu mv lu kv mw mx ly my bi translated">舵图储存库</h2><p id="9ec1" class="pw-post-body-paragraph kc kd je ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz im bi translated">Helm chart存储库只是提供图表资源的http服务器。你可以在github.com/helm/charts的<a class="ae lb" href="https://github.com/helm/charts" rel="noopener ugc nofollow" target="_blank">看到官方策划的图表资源。图表存储库主要是为语义版本化的图表设计的。因此，图表存储库不能很好地处理并发更新。避免在CI或模式中使用图表存储库，比如为每次提交创建一个新的舵图。</a></p><p id="49e4" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">舵图应该是语义版本化的模块。它们代表部署应用程序的底层基础设施。可以把它们想象成一个库，用来抽象掉Kubernetes的复杂性。将图表存储在整个组织都可以访问的存储库中，并允许开发人员使用组织中的最佳实践来轻松使用这些图表进行部署。</p><p id="65d5" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在组织中分发图表的一个简单方法是使用S3甚至GitHub版本作为图表的存储。一个简单的模式是拥有一个公共的<code class="fe nt nu nv mf b">myorg/charts</code>存储库，其中包含您的团队策划和构建的所有图表，可以安装到Kubernetes中。</p><h2 id="cd98" class="mj ld je bd le mo mp dn li mq mr dp lm kn ms mt lq kr mu mv lu kv mw mx ly my bi translated">握紧你的舵柄</h2><p id="d892" class="pw-post-body-paragraph kc kd je ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz im bi translated">如果您对Kubernetes集群有严格的访问控制，您可能会被Tiller(Helm的服务器端组件)在Kubernetes集群中作为超级用户运行的问题所困扰。有一些解决方法，但是需要一些更复杂的配置来解决。对于大多数团队，默认配置看起来像是当您连接到Helm时，您拥有对集群的管理员访问权限。</p><p id="ad90" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">解决这个问题的一个常见方法是在不同的名称空间中创建不同的Tiller实例。如果您有一个非常大的Kubernetes集群，这可能是一种分割特定团队的方式，以便只访问一个Tiller。Helm第3版在这方面有更多的更新，实际上只在客户端应用资源。</p><h1 id="b322" class="lc ld je bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">摘要</h1><p id="f5c5" class="pw-post-body-paragraph kc kd je ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz im bi translated">新的Kubernetes部署面临的最大挑战之一，是涉水通过所有的最佳实践和意见，让您的部署管道第一次就设置正确。Helm部署有很多问题，您需要正确导航到设置，但一旦设置完成，就可以提供灵活性和强大的功能来有效地连接您的部署。</p><p id="cdbc" class="pw-post-body-paragraph kc kd je ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><em class="la">请继续关注Kubernetes系列的下一个实用而安全的部署。我们将与GitHub讨论自动化工具，将所有这些最佳实践包装在代码中。</em></p></div></div>    
</body>
</html>