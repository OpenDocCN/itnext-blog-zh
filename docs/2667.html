<html>
<head>
<title>Node.js APIs caching made simple!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js APIs缓存变得简单！</h1>
<blockquote>原文：<a href="https://itnext.io/node-js-apis-caching-made-simple-f79c22b2c2fa?source=collection_archive---------4-----------------------#2019-07-07">https://itnext.io/node-js-apis-caching-made-simple-f79c22b2c2fa?source=collection_archive---------4-----------------------#2019-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/792acc65ccf4d755843800725fe289d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zhmf5Oigz7-GDTgSRFrj_g.jpeg"/></div></div></figure><p id="1e20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将讨论如何在分布式解决方案中轻松实现API缓存。<br/>描述了Node.js的实现，具体到伟大的<a class="ae kw" href="https://github.com/jkyberneees/http-cache-middleware" rel="noopener ugc nofollow" target="_blank"><em class="kx">http-cache-middleware</em></a>模块:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><h1 id="601a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">但是，什么是缓存？</h1><blockquote class="mc md me"><p id="5c92" class="jy jz kx ka b kb kc kd ke kf kg kh ki mf kk kl km mg ko kp kq mh ks kt ku kv ij bi translated"><strong class="ka ir">高速缓存</strong>是存储数据的硬件或软件组件，以便将来对该数据的请求可以得到更快的服务；存储在缓存中的数据可能是早期计算的结果，也可能是存储在其他地方的数据的副本。当请求的数据可以在缓存中找到时，发生缓存命中，而当不能找到时，发生缓存未命中。通过从缓存中读取数据来服务缓存命中，这比重新计算结果或从较慢的数据存储中读取要快；因此，缓存可以处理的请求越多，系统的执行速度就越快。</p><p id="9c74" class="jy jz kx ka b kb kc kd ke kf kg kh ki mf kk kl km mg ko kp kq mh ks kt ku kv ij bi translated">HTTPS://EN。WIKIPEDIA.ORG/WIKI/CACHE_(计算)</p></blockquote><p id="9299" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文的上下文中，我们将重点讨论软件缓存，特别是API响应缓存，以及它如何显著改善系统的以下方面:</p><ul class=""><li id="8689" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">潜伏</li><li id="151b" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">CPU要求</li><li id="2d51" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">网络带宽</li></ul><pre class="ky kz la lb gt mw mx my mz aw na bi"><span id="1968" class="nb lf iq mx b gy nc nd l ne nf">Again, statics assets caching is out of scope of this article!</span></pre><h1 id="a429" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">分布式系统的问题</h1><p id="c84b" class="pw-post-body-paragraph jy jz iq ka b kb ng kd ke kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv ij bi translated">当实现诸如微服务之类的分布式系统时，我们倾向于使用几十个(如果不是几百个的话)内部具有良好定义的接口和最小业务逻辑的微小服务。一方面，这有利于维护，允许运行时多样性并提高开发速度，然而这也给开发团队带来了许多架构问题，包括:<strong class="ka ir"> <em class="kx">数据聚合的成本！</em>T12】</strong></p><blockquote class="mc md me"><p id="885e" class="jy jz kx ka b kb kc kd ke kf kg kh ki mf kk kl km mg ko kp kq mh ks kt ku kv ij bi translated">在细粒度的分布式系统中，您将需要几个API调用来符合单个响应有效负载，从而暴露出您的体系结构中的依赖性管理和网络延迟问题。</p></blockquote><h2 id="d171" class="nb lf iq bd lg nl nm dn lk nn no dp lo kj np nq ls kn nr ns lw kr nt nu ma nv bi translated">“A”依赖于“B”，“B”依赖于“C”</h2><p id="e440" class="pw-post-body-paragraph jy jz iq ka b kb ng kd ke kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv ij bi translated">在分布式系统中我们不会有单一的数据库，因此为一个响应负载聚合数据将需要从不同的服务获取记录，从而并行和顺序地触发许多API调用。</p><h1 id="6dbb" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">缓存是你的朋友！</h1><p id="5698" class="pw-post-body-paragraph jy jz iq ka b kb ng kd ke kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv ij bi translated">如果您的记录集检索次数多于更新次数，那么您应该使用缓存。<br/>这将防止您一遍又一遍地重新计算您的数据，还会将API调用和网络往返次数降至最低。</p><h2 id="3d19" class="nb lf iq bd lg nl nm dn lk nn no dp lo kj np nq ls kn nr ns lw kr nt nu ma nv bi translated">“http-cache-middleware”拯救世界:</h2><blockquote class="mc md me"><p id="a70f" class="jy jz kx ka b kb kc kd ke kf kg kh ki mf kk kl km mg ko kp kq mh ks kt ku kv ij bi translated">Node.js的高性能类似连接的HTTP缓存中间件。因此您的延迟可以减少到个位数毫秒:<a class="ae kw" href="https://www.npmjs.com/package/http-cache-middleware" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/http-cache-middleware</a></p><p id="6841" class="jy jz kx ka b kb kc kd ke kf kg kh ki mf kk kl km mg ko kp kq mh ks kt ku kv ij bi translated">内部使用<code class="fe nw nx ny mx b">cache-manager</code>作为缓存层，因此支持多种存储引擎，即:Memory、Redis、Memcached、Mongodb、Hazelcast…</p></blockquote><p id="961c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个中间件与类似connect的框架兼容，例如<a class="ae kw" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> express </em> </a>，<a class="ae kw" href="https://github.com/jkyberneees/ana#readme" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> restana </em> </a>和许多其他框架…，使得在您的架构上实现本地和全局缓存策略变得非常容易:<strong class="ka ir"> <em class="kx">只需使用HTTP头，就这么简单！</em>T12】</strong></p><p id="27ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">缓存一周的<em class="kx"> GET /tasks </em>端点响应:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="cdcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果状态改变，使高速缓存无效:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><h1 id="ce68" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">全部缓存</h1><p id="8a76" class="pw-post-body-paragraph jy jz iq ka b kb ng kd ke kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv ij bi translated">正如我们提到的，分布式体系结构经常包括不同语言和运行时的服务，那么我们如何应用一个适用于所有这些服务的缓存层呢？</p><p id="755e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="kx">http-cache-middleware</em></strong>模块也与<a class="ae kw" href="https://www.npmjs.com/package/fast-gateway#gateway-level-caching" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="kx">fast-gateway</em></strong></a>兼容，通过这种组合，您可以一劳永逸地实现它，无论您的服务使用什么运行时或框架:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><h1 id="3f57" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="d8ee" class="pw-post-body-paragraph jy jz iq ka b kb ng kd ke kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv ij bi translated">在本文中，我们通过使用用于Node.js框架的<strong class="ka ir"><em class="kx">http-cache-middleware</em></strong>中间件(如express或restana……</p><p id="eb62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而你，你是如何使用缓存的？</p></div></div>    
</body>
</html>