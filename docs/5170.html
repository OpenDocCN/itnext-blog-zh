<html>
<head>
<title>Run Go service in Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Docker中运行Go服务</h1>
<blockquote>原文：<a href="https://itnext.io/create-go-service-the-easy-way-viii-157427e7cd35?source=collection_archive---------2-----------------------#2020-12-31">https://itnext.io/create-go-service-the-easy-way-viii-157427e7cd35?source=collection_archive---------2-----------------------#2020-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d91" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">额外的好处是可执行文件的大小减少了大约73%</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0243cd43ffd7d54cb5eb45bfb48a7270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InFe0jU-dOOJbhFISFyZXg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由Renee French创建的原始地鼠图像，使用由Maria Letta创建的地鼠图像</figcaption></figure><ol class=""><li id="ee11" class="ky kz it la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">部分:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-de827d7f07cf" rel="noopener">创建服务</a></li><li id="4667" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">部分:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-ii-c397fd17875" rel="noopener">改善服务</a></li><li id="bf5b" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">部分:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-iii-c84489cc1ee0" rel="noopener">网页升级</a></li><li id="3bc6" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">零件:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-iv-c1f6b91401c1" rel="noopener">添加SSE </a></li><li id="f73e" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">部分:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-v-63c260594ed9" rel="noopener">简单的javascript前端功能</a></li><li id="c5ae" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">部分:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-vi-1fc383d435bd" rel="noopener">前端—后端通信</a></li><li id="c118" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">部分:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-vii-2a550c9204a6" rel="noopener">服务器端日志</a></li><li id="7f31" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">part: <strong class="la iu">你现在正在看</strong></li><li id="8943" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">零件:<a class="ae lq" href="https://petrjahoda.medium.com/test-story-618d1cfca0cd" rel="noopener">添加数据库容器</a></li><li id="d77b" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">零件:<a class="ae lq" href="https://petrjahoda.medium.com/communication-between-go-service-and-postgres-database-both-running-in-docker-ae0fd53a25b8" rel="noopener">数据库—服务通信</a></li></ol><p id="ea56" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">追加1: <a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/go-functions-methods-pointers-and-interfaces-1c034fd198d3">函数、方法、指针和接口</a>T22】追加2: <a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/websocket-communication-between-two-go-programs-the-easy-way-d8c9cf40043f"> websocket通信</a>T25】追加3: <a class="ae lq" href="https://petrjahoda.medium.com/plain-socket-communication-between-two-go-programs-the-easy-way-bd5ac5819eb6" rel="noopener"> socket通信</a></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="75fe" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">为什么要使用Docker呢？</h1><p id="880e" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">当然，您可以为每个系统创建Go可执行文件，并且可以在任何您想要的地方运行它。确实如此。</p><p id="314b" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">通过使用Docker，您可以为自己创建一个整洁的部署系统。你不关心最终的机器上实际运行的是什么系统。你只想让机器运行Docker。您可以轻松地停止和启动多个程序(如果您喜欢这个术语，可以选择多个服务)。您可以轻松地更改Go web服务器的端口，而无需更改Go代码本身。您可以同时运行多个不同的数据库。</p><p id="abb3" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">你可以使用Docker做很多事情，我建议你花时间去学习它。</p><p id="fd5d" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">对于不熟悉Docker的人，我推荐Bret Fisher的<a class="ae lq" href="https://www.udemy.com/course/docker-mastery/" rel="noopener ugc nofollow" target="_blank"> Docker Mastery </a>。这帮助我从<em class="nn">“Docker是什么鬼东西”</em>到<em class="nn">“太好了，我还能用Docker做什么”</em>。</p><p id="c083" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">对于那些已经熟悉Docker，但还想了解更多的人来说，<a class="ae lq" href="https://www.youtube.com/watch?v=8fi7uSYlOdc" rel="noopener ugc nofollow" target="_blank">这个讲座</a>可以让你对容器有更多的了解。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="03e3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">准备项目</h1><p id="63db" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">打开Goland并在项目目录中创建名为<strong class="la iu"> Dockerfile </strong>的新文件。在下面插入代码。这些命令将使用<code class="fe no np nq nr b">FROM scratch</code>创建空图像，然后从css、html、js和linux目录中复制内容。</p><p id="a345" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">但是等等，现在还没有linux目录。原因是，我们没有开发我们的软件。我们没有制作任何可执行文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="4220" class="nu mr it bd ms nv nw dn mw nx ny dp na lf nz oa nc lh ob oc ne lj od oe ng of bi translated">创建Go可执行文件</h2><p id="6cf4" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">有许多方法，如何构建我们的软件…如何创建这个可执行文件。一种方法是使用Goland的内置功能。</p><p id="c944" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">通过复制第一个配置来创建新配置。在这一新配置中，有四项变化:</p><ol class=""><li id="d7f0" class="ky kz it la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">名称…这个名称将被用作可执行文件的名称，并且必须与<code class="fe no np nq nr b">CMD [“/medium_service”]</code>匹配，所以我们使用medium_service，Goland将自动在文件名中添加_linux</li><li id="cdf6" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">选择输出目录(linux，因为我们将使用linux容器)</li><li id="4019" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">在构建后运行时取消勾选<em class="nn"/></li><li id="30e3" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">将环境设置为<code class="fe no np nq nr b">GOOS=linux</code></li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/c8d0f8b33421fd4def1b927644405205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7Y3cydN2RWLsG8h4OBqmg.png"/></div></div></figure><p id="f9e3" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated"><strong class="la iu"> <em class="nn">旁注:</em> </strong> <em class="nn">通过定义GOOS你可以为</em><a class="ae lq" href="https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63" rel="noopener ugc nofollow" target="_blank"><em class="nn"/></a><em class="nn">可用的任何系统和任何架构构建可执行文件。</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="76e4" class="nu mr it bd ms nv nw dn mw nx ny dp na lf nz oa nc lh ob oc ne lj od oe ng of bi translated">将可执行文件缩减了73%</h2><p id="1d70" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">当您运行这个配置时，您会立即看到一个新的可执行文件出现在这个linux目录中。这个可执行文件大约有<strong class="la iu"> 9.6MB </strong>，我们将做两个小技巧让它变得更小。首先给Go工具参数添加两个标志<code class="fe no np nq nr b">-ldflags=”-s -w”</code>，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/fb3d087a9b99e85bfda548590873a6ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7ptdw0gvPCBpSMQh8Zesw.png"/></div></div></figure><p id="65d1" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">再次运行这个配置，您可以看到，可执行文件大约为<strong class="la iu"> 6.9MB，</strong>减少了大约28%。第二个技巧是使用任何可用的可执行打包程序。我使用UPX，我也在生产中使用它，没有任何影响。使用命令<code class="fe no np nq nr b">upx medium_service_linux</code>，可执行文件的大小将缩小到大约<strong class="la iu"> 2.6MB </strong>，减少了73%。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="1ec5" class="nu mr it bd ms nv nw dn mw nx ny dp na lf nz oa nc lh ob oc ne lj od oe ng of bi translated">使用脚本创建Go可执行文件</h2><p id="8207" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">我更喜欢使用的另一种方法是使用脚本，无论是bash还是powershell脚本。由于我使用苹果设备，所以下面你可以看到我的bash脚本。这个脚本名为<strong class="la iu"> create.sh </strong>，放在项目目录中。它做了很多事情。</p><p id="75e0" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">首先，它将通过使用<code class="fe no np nq nr b">name=${PWD##*/}</code>获得当前工作目录的名称，然后它将更新所有模块(没有必要，但我喜欢所有模块的最新版本)，然后它将使用<code class="fe no np nq nr b">GOOS=linux go build -ldflags=”-s -w” -o linux/”$name”</code>构建我们的可执行文件，然后移动到那个linux文件夹，将可执行文件与UPX打包并移出。</p><p id="cd64" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">这一切做完之后，它终于会用docker做点什么了。通过使用<code class="fe no np nq nr b">docker rmi -f petrjahoda/”$name”:latest</code>，它将删除之前已经创建的任何图像，通过使用<code class="fe no np nq nr b">docker build -t petrjahoda/”$name”:latest .</code>，它将创建图像。这个<strong class="la iu">点</strong>表示它将在执行该命令的目录中搜索Dockerfile。最后，它会使用<code class="fe no np nq nr b">docker push petrjahoda/”$name”:latest</code>将该图像推送到docker hub。为了让这个最后的命令工作，你需要让你自己的库工作，并且你必须在你的机器上登录Docker。</p><p id="c352" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated"><strong class="la iu"> <em class="nn">旁注:</em> </strong> <em class="nn">不要忘记</em> <code class="fe no np nq nr b">chmod +x create.sh</code> <em class="nn">并删除前面的可执行文件，以</em><strong class="la iu"><em class="nn">_ Linux</em></strong><em class="nn">结尾。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="9035" class="nu mr it bd ms nv nw dn mw nx ny dp na lf nz oa nc lh ob oc ne lj od oe ng of bi translated">运行脚本</h2><p id="01a1" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">当您运行这个脚本时，您会看到许多事情正在发生(见下文)。一切完成后，您可以在docker hub存储库中找到您的映像。在我的箱子里，它在这里。</p><pre class="kj kk kl km gt oi nr oj ok aw ol bi"><span id="7def" class="nu mr it nr b gy om on l oo op">go: golang.org/x/sys upgrade =&gt; v0.0.0–20201223074533–0d417f636930<br/> Ultimate Packer for eXecutables<br/> Copyright © 1996–2020<br/>UPX 3.96 Markus Oberhumer, Laszlo Molnar &amp; John Reiser Jan 23rd 2020</span><span id="f223" class="nu mr it nr b gy oq on l oo op">File size Ratio Format Name<br/> — — — — — — — — — — — — — — — — — — — — — — — — -<br/> 6901760 -&gt; 2630120 38.11% linux/amd64 medium_service</span><span id="706f" class="nu mr it nr b gy oq on l oo op">Packed 1 file.<br/>Error: No such image: petrjahoda/medium_service:latest<br/>[+] Building 0.4s (8/8) FINISHED <br/> =&gt; [internal] load build definition from Dockerfile 0.0s<br/> =&gt; =&gt; transferring dockerfile: 135B 0.0s<br/> =&gt; [internal] load .dockerignore 0.0s<br/> =&gt; =&gt; transferring context: 2B 0.0s<br/> =&gt; [internal] load build context 0.2s<br/> =&gt; =&gt; transferring context: 5.26MB 0.1s<br/> =&gt; [1/4] COPY /css /css 0.0s<br/> =&gt; [2/4] COPY /html html 0.0s<br/> =&gt; [3/4] COPY /js js 0.0s<br/> =&gt; [4/4] COPY /linux / 0.0s<br/> =&gt; exporting to image 0.0s<br/> =&gt; =&gt; exporting layers 0.0s<br/> =&gt; =&gt; writing image sha256:1df9b9adbc1167cb1fcb1fc66d74cf33964c35530dc04fa4f5434e917bc50a53 0.0s<br/> =&gt; =&gt; naming to docker.io/petrjahoda/medium_service:latest 0.0s<br/>The push refers to repository [docker.io/petrjahoda/medium_service]<br/>bc5cf960a3a7: Pushed <br/>6eec7c2c219c: Pushed <br/>2038e7a8e302: Pushed <br/>95541ba72fa1: Pushed <br/>latest: digest: sha256:4584ba804f99d001a57d84bc85b6624eb8f9ab2b8edc9e226e43e670a0ce51b3 size: 1149</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="7f8b" class="nu mr it bd ms nv nw dn mw nx ny dp na lf nz oa nc lh ob oc ne lj od oe ng of bi translated">测试将Go服务作为Docker容器运行</h2><p id="e40c" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">看来我们做的一切都是对的。是时候测试一下了。</p><p id="ba77" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">打开你的终端，或者控制台，或者使用Goland的内置终端运行<code class="fe no np nq nr b">docker run — name medium_service -p 90:81 petrjahoda/medium_service:latest</code>。这将运行一个名为<strong class="la iu"> medium_service </strong>、<strong class="la iu">的新容器，将内部端口81映射到外部端口90 </strong>，并使用已经创建的带有<code class="fe no np nq nr b">latest</code>标签的映像。当您运行该命令时(在我的示例中，我必须使用端口82，因为我在我的应用程序中使用了它),您会看到来自应用程序的日志。</p><p id="010c" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">打开浏览器，导航到<a class="ae lq" href="http://localhost:90" rel="noopener ugc nofollow" target="_blank"> http://localhost:90 </a>。你的网页必须运行。如果您尝试点击<strong class="la iu">询问数据</strong>按钮，您会立即看到，它已被成功记录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/2ed48ad282e6e437b8b7a758c27b1491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33hk1bPpw-lpKoCKvRTlZA.png"/></div></div></figure><h2 id="d553" class="nu mr it bd ms nv nw dn mw nx ny dp na lf nz oa nc lh ob oc ne lj od oe ng of bi translated">让Docker容器在后台运行</h2><p id="e2bf" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">为了让这个docker容器一直运行，现在使用CTRL+C结束它，并使用<code class="fe no np nq nr b">docker rm medium_service</code>删除它。现在再次运行它，这次添加了<strong class="la iu"> -d参数:</strong> <code class="fe no np nq nr b">docker run — name medium_service -p 90:81 -d petrjahoda/medium_service:latest</code>。这将运行容器并且<strong class="la iu">从容器上分离</strong>。因此，现在您的控制台可以自由使用或关闭，您的web服务器在后台工作。</p><p id="874c" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">你可以通过使用<code class="fe no np nq nr b">docker ps -a</code>来检查你的容器是否工作，它将显示你所有未移除的<em class="nn">容器，或者通过使用<code class="fe no np nq nr b">docker stats</code>(见下图)来实时监控你正在运行的容器。在我的情况下，我有更多的运行容器，中型服务在顶部。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/f63f3e8667be768dd69c0cb494c15f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQLv-RNS9pg3nCpR2joWjQ.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="c107" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated"><strong class="la iu">恭喜</strong>。您有自己的web服务运行在Docker容器中。软件的每个部分都在正常运行，通过使用<code class="fe no np nq nr b">FROM scratch</code>，我们使我们的容器非常安全(但另一方面，你不能从容器内部ping命令)。</p><p id="64a8" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">通过使用<code class="fe no np nq nr b">docker image ls</code>，你可以看到我们的图像大约有5.26MB(去可执行文件和所有其他文件)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f4a6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">额外功能</h1><p id="15ca" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">下面是我的<strong class="la iu"> create.sh </strong>文件，我用在每个软件的生产中。有两件不同的事情。首先你会看到，它运行<code class="fe no np nq nr b">./update</code>，最后还有三个docker命令。</p><p id="fd6b" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">这样做的原因是，我喜欢我的软件有一个正确的版本，不需要考虑它。所以在main.go的每个软件中我都有一个常量T7，当服务启动时，我喜欢使用类似T8的东西。</p><p id="1834" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">这个<strong class="la iu">。/更新</strong>做两件事。更新这个常量并更新create.sh中的最后三行代码，包含version。</p><p id="d73d" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">结果是，<strong class="la iu">最新的docker映像实际上总是最新的</strong>，并且由于我的软件是用正确的版本号构建的，所以会有更多的映像。例如，版本2020.4.3.13是这样组合的:</p><ul class=""><li id="8150" class="ky kz it la b lb lc ld le lf lg lh li lj lk ll ot ln lo lp bi translated">2020年是一年</li><li id="588c" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll ot ln lo lp bi translated">4是一年的第四季度</li><li id="36ea" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll ot ln lo lp bi translated">3是本季度的第三个月</li><li id="a27a" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll ot ln lo lp bi translated">13是一个月中的第几天</li></ul><p id="ad5f" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">你可以看到使用这种方法，例如这里的<a class="ae lq" href="https://github.com/petrjahoda/system_webservice_beta" rel="noopener ugc nofollow" target="_blank"/>。更新后可执行文件也在项目目录中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="952b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">摘要</h1><p id="f270" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">这篇文章帮助你知道，如何…</p><ul class=""><li id="d271" class="ky kz it la b lb lc ld le lf lg lh li lj lk ll ot ln lo lp bi translated">使用两种不同的方法创建Go可执行文件</li><li id="1392" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll ot ln lo lp bi translated">创建Docker映像并将其推入Docker Hub</li><li id="1de8" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll ot ln lo lp bi translated">使用不同的参数运行Docker映像</li><li id="1d5c" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll ot ln lo lp bi translated">在后台运行Docker image(并检查日志)</li><li id="1bc0" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll ot ln lo lp bi translated">将Go可执行文件缩减约73%</li><li id="2fb7" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll ot ln lo lp bi translated">添加一些自动版本控制作为额外的功能</li></ul><div class="ou ov gp gr ow ox"><a href="https://github.com/petrjahoda/medium_service/tree/Chapter_8" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">petrjahoda/中型服务</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">中等_服务。在GitHub上创建一个帐户，为petrjahoda/medium-service的发展作出贡献。</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">github.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>