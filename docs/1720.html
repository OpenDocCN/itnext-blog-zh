<html>
<head>
<title>Hello, Elixir — The First Month</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你好，长生不老药——第一个月</h1>
<blockquote>原文：<a href="https://itnext.io/hello-elixir-the-first-month-d24255860b?source=collection_archive---------0-----------------------#2019-01-10">https://itnext.io/hello-elixir-the-first-month-d24255860b?source=collection_archive---------0-----------------------#2019-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6bccde07210c13456a0a7ee17fb4bbfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rw6r7w98d6L2tpensAuTw.png"/></div></div></figure><h1 id="fdeb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">TL；博士——我已经用了一个月的灵药，基本上很喜欢</h1><p id="8334" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="ae lu" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elixir </a>是一种基于<a class="ae lu" href="http://www.erlang.org/" rel="noopener ugc nofollow" target="_blank"> Erlang/OTP </a>和<a class="ae lu" href="https://redmonk.com/sogrady/2018/03/07/language-rankings-1-18/" rel="noopener ugc nofollow" target="_blank">快速增长社区</a>的函数式编程语言。它拥有令人印象深刻的功能集:可伸缩性、容错、热插拔代码和开箱即用的轻松并发。</p><p id="5033" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在用Java和Javascript构建了许多应用程序之后，Elixir中数据的功能性质和强制不变性要求对程序结构采用稍微不同的方法。然而，语言的简单性、文档的彻底性和代码的可读性显著地缩短了学习曲线。</p><h1 id="15c6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="d6e0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我从萨莎·尤里奇的书<a class="ae lu" href="https://www.manning.com/books/elixir-in-action" rel="noopener ugc nofollow" target="_blank">开始了长生不老药之旅。除了阅读，我还加入了</a><a class="ae lu" href="https://exercism.io/tracks/elixir" rel="noopener ugc nofollow" target="_blank">exercisem</a>的Elixir track(一个免费的在线平台，有数千个指导的编码挑战)。</p><p id="84e9" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我最惊讶的是语言的表现力。将我对Elixir 中的<a class="ae lu" href="https://exercism.io/tracks/elixir/exercises/roman-numerals/solutions/6d1f1fbafdf041e6b3f5740e215b478d" rel="noopener ugc nofollow" target="_blank">罗马数字问题的递归解决方案与Javascript </a>中的<a class="ae lu" href="https://stackoverflow.com/questions/9083037/convert-a-number-into-a-roman-numeral-in-javascript" rel="noopener ugc nofollow" target="_blank">类似解决方案进行对比。那是在我发现</a><a class="ae lu" href="https://elixir-lang.org/getting-started/modules-and-functions.html" rel="noopener ugc nofollow" target="_blank">单行函数声明</a>之前，而且与许多面向对象语言中的类似解决方案相比，Elixir代码显然更具可读性。</p><h1 id="e6f1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">熟悉的</h1><p id="8152" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">奇怪的是，这种语言让人感觉很熟悉。Elixir采用了许多常见的范例，通常还进行了额外的改进。</p><p id="86ef" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir">管道操作员</strong></p><p id="2994" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">以方法链接为例，在Javascript中可能是这样的:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="e9da" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">可以使用Elixir中的<a class="ae lu" href="https://elixirschool.com/en/lessons/basics/pipe-operator/" rel="noopener ugc nofollow" target="_blank">管道操作符</a>编写相同的代码:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="ce2d" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">它甚至可以内联:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="df1a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">然而，使用管道运算符的两个示例似乎都比:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="27d9" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir">管道操作符接受一个表达式的结果，并将它(作为第一个参数)传递给下一个表达式</strong>。这将生成在视觉上近似于英语阅读方式的代码:从左到右。</p><p id="077e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir">守卫</strong></p><p id="4cca" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">守卫是另一个受欢迎的语言特征。<strong class="ky ir">守卫评估布尔表达式以确定调用哪个函数声明</strong>。尽管它们在很大程度上是语法糖，但在像Elixir这样的注重递归的语言中，它们有助于阐明分支模式。</p><p id="c9fe" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">以Javascript中的斐波那契数列为例:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="3676" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">可以用药剂中的守卫来写:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="c544" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在这两个例子中，基本情况都有定义，但在酏剂中更明确。另一个用例是<a class="ae lu" href="https://beginnersbook.com/2013/05/method-overloading/" rel="noopener ugc nofollow" target="_blank">方法重载</a>:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="e80f" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><code class="fe mg mh mi mj b">Greet.hey</code>可以接受一个原子(即<code class="fe mg mh mi mj b">Greet.hey(:Joe)</code>)或一个二进制(即<code class="fe mg mh mi mj b">Greet.hey("Joe")</code>)，这使得API更加方便。也可以独立处理每种情况。</p><p id="f8ef" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir">注释</strong></p><p id="3d04" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">从技术上讲<a class="ae lu" href="https://medium.com/@cowen/annotations-in-elixir-450015ecdd97" rel="noopener">模块属性</a>，Elixir提供了一种在编译时声明信息的机制。最突出的用法是<a class="ae lu" href="https://elixir-lang.org/getting-started/typespecs-and-behaviours.html" rel="noopener ugc nofollow" target="_blank">类型规格</a>。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="be41" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">Elixir是动态类型的，但是使用像<a class="ae lu" href="http://www.erlang.org/doc/man/dialyzer.html" rel="noopener ugc nofollow" target="_blank">透析器</a>这样的工具，你可以执行静态代码分析。就<a class="ae lu" href="https://elixir-lang.org/getting-started/meta/domain-specific-languages.html#storing-information-with-attributes" rel="noopener ugc nofollow" target="_blank">元编程</a>而言，模块属性与Java 中的<a class="ae lu" href="https://en.wikipedia.org/wiki/Java_annotation" rel="noopener ugc nofollow" target="_blank">注释具有相似的可访问性。</a></p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="aa88" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">据说<strong class="ky ir"> Elixir是几个函数加上一些胶水</strong>，这与事件驱动开发并没有很大的偏差。如果Javascript有这些特性，它可能有助于逃离回调地狱。</p><h1 id="938f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">不太熟悉的</h1><p id="f056" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">learning Elixir更具挑战性的方面是模式匹配、递归和列表操作。</p><p id="0c02" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir">模式匹配</strong></p><p id="4f77" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">模式匹配非常强大，因为除了递归，它<a class="ae lu" href="https://www.reddit.com/r/elixir/comments/34jyto/what_are_the_benefits_of_pattern_matching_as/" rel="noopener ugc nofollow" target="_blank">最小化了临时变量赋值和嵌套条件的使用</a>。虽然它看起来像任务，但它更复杂，也更有能力。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="744a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在某些方面，它类似于ES6中的<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构</a>，在那里你解包一个对象或数组，并将感兴趣的部分赋给局部变量。</p><blockquote class="mk ml mm"><p id="9fde" class="kw kx mn ky b kz lv lb lc ld lw lf lg mo lx lj lk mp ly ln lo mq lz lr ls lt ij bi translated">模式匹配非常适合递归，递归允许您轻松地将转换分解成一系列步骤。— <a class="ae lu" href="https://www.reddit.com/user/ABC_AlwaysBeCoding" rel="noopener ugc nofollow" target="_blank"> ABC_AlwaysBeCoding </a></p></blockquote><p id="95e4" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir">兰姆达斯</strong></p><p id="fa53" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">Elixir的另一个有趣特性是无需显式定义参数就能编写lambdas。比较Javascript的箭头函数:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="d3f3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在酏剂中具有功能:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="3c90" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">或者用<a class="ae lu" href="https://dockyard.com/blog/2016/08/05/understand-capture-operator-in-elixir" rel="noopener ugc nofollow" target="_blank">捕捉操作符</a>:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="4a36" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">虽然capture操作符似乎与清晰的焦点相反，但如果仅限于简单的用例，它确实提供了一种受欢迎的简洁形式。</p><h1 id="2e3b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="0dfc" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当其他人对面向对象编程说再见的时候，我还没有准备好放弃像Java或Javascript这样的语言。这两种语言都有大量的库和框架，这些库和框架对它们进行了改编和扩展，以适应从移动开发到分布式web服务的各种环境。但是，一般来说，函数式编程也有缺点，特别是对于Elixir，我希望在另一篇文章中分享。</p><p id="8996" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">尽管如此，我对学习长生不老药如此容易感到高兴，至少达到了基本熟练的程度。我希望很快能有机会使用开源工具如<a class="ae lu" href="https://phoenixframework.org/" rel="noopener ugc nofollow" target="_blank">凤凰</a>、<a class="ae lu" href="https://github.com/bitwalker/distillery" rel="noopener ugc nofollow" target="_blank">酒厂</a>和<a class="ae lu" href="https://github.com/absinthe-graphql/absinthe" rel="noopener ugc nofollow" target="_blank">苦艾酒</a>从事网络服务工作。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="eaf7" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir">跟随</strong><code class="fe mg mh mi mj b">|&gt;</code><a class="ae lu" href="https://www.linkedin.com/in/tombarrasso/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">LinkedIn</strong></a><code class="fe mg mh mi mj b">|&gt;</code><a class="ae lu" href="https://github.com/Tombarr" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">GitHub</strong></a><code class="fe mg mh mi mj b">|&gt;</code><a class="ae lu" href="https://medium.com/@tbarrasso" rel="noopener"><strong class="ky ir">中型</strong> </a></p></div></div>    
</body>
</html>