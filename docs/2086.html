<html>
<head>
<title>Mastering Session Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握会话认证</h1>
<blockquote>原文：<a href="https://itnext.io/mastering-session-authentication-aa29096f6e22?source=collection_archive---------0-----------------------#2019-03-28">https://itnext.io/mastering-session-authentication-aa29096f6e22?source=collection_archive---------0-----------------------#2019-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e196" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何使用MongoDB、Express、React和Node构建基于会话的身份验证应用程序的完整演练</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/21c093cc03a807a69f908aa30ee0fc39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWwbBrelwUr3gkEnQqxGOA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">原始照片由<a class="ae kv" href="https://unsplash.com/@samuelzeller" rel="noopener ugc nofollow" target="_blank">塞缪尔·泽勒</a>拍摄</figcaption></figure><p id="5bac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们开始了构建MERN堆栈认证应用的旅程，该应用将提供:输入验证、错误处理、会话认证、受保护的前端路由和持久登录——即使服务器重启或用户刷新页面。</p><p id="76f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个<em class="ls">一步一步的指南/教程</em>，因为我会尽可能详细地介绍，同时在需要时提供文档链接。<br/>在我们开始之前，这里有一份我们将使用的技术清单:<br/> <strong class="ky ir"> MongoDB Atlas、Mongoose、Joi、BCrypt、ESM、Express、Express-Session、React、Redux、Node.js、Postman、</strong> heavy <strong class="ky ir"> ES6+ </strong>用法</p><p id="168f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！这几乎是我们整个项目所需要的一切。<br/> <strong class="ky ir">我们将不使用Passport.js或JWTs </strong>。<br/>最后，我喜欢造型，但我们的用户界面将会非常简单&amp;无风格。这样我们就可以专注于业务逻辑，并且这个项目可以作为未来项目的框架。</p><p id="bdce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，事不宜迟，我们开始吧！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="33ee" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">步骤1: Node.js设置</h1><p id="2f56" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们首先创建一个项目目录并初始化我们的节点应用程序。如果你还没有安装Node.js，去<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">他们的网站</a>按照下载说明操作。</p><p id="b277" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你这样做了，在你的终端中运行这三个命令:<br/> <code class="fe mx my mz na b">mkdir SessionAuth &amp;&amp; cd SessionAuth</code> <br/> <code class="fe mx my mz na b">mkdir backend &amp;&amp; cd backend</code> <br/> <code class="fe mx my mz na b">npm init esm -y</code>。esm 将允许我们在后端使用心爱的导入/导出语法。<br/> <strong class="ky ir"> -y </strong>简单跳过填写姓名、描述、作者等的问题。(如果您愿意，您可以更新这些内容)<br/><strong class="ky ir">NPM init ESM-y</strong>命令为我们创建了一些东西，但是下一步是设置我们的项目目录结构。这里我将使用一个非常简单的方法:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="15a9" class="nf mb iq na b gy ng nh l ni nj">SessionAuth/<br/>   <strong class="na ir">|— backend/</strong><br/>      |— node_modules/<br/>      <strong class="na ir">|— .gitignore</strong><br/>      |— package-lock.json<br/>      |— package.json<br/>      <strong class="na ir">|— src/</strong><br/>         <strong class="na ir">|— models/<br/>         |— routes/<br/>         |— util/<br/>         |— validations/</strong><br/>         |— index.js<br/>         |— <strong class="na ir">server.js</strong> &lt;= renamed <em class="ls">main.js</em> to <em class="ls">server.js</em></span></pre><p id="e377" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> ** </strong> <code class="fe mx my mz na b"><strong class="ky ir">All boldened lines in the code snippets represent new code.</strong></code> ** <br/>我将<strong class="ky ir"> main.js </strong>重命名为<strong class="ky ir"> server.js </strong>，因为这将包含所有与服务器相关的逻辑。让我们快速更新我们的<strong class="ky ir"> index.js </strong>导入:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="b95f" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/src/index.js ---</em><br/>require = require("esm")(module/*, options*/)<br/>module.exports = require("<strong class="na ir">./server.js</strong>")</span></pre><p id="c096" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">。gitignore </strong>文件是可选的，但是如果你正在使用git，我<em class="ls">强烈</em>建议现在创建一个并添加这两行:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="4d2e" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/.gitignore ---</em><strong class="na ir"><em class="ls"><br/></em>/node_modules<br/>config.js</strong></span></pre><p id="e72b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> node_modules </strong>文件夹不需要签入版本控制，我们还没有创建<strong class="ky ir"> config.js </strong>文件，但是现在最好忽略它。<br/>在你的文件结构看起来像上面这样之后，让我们在我们的终端中确保我们在<strong class="ky ir">后端</strong>目录中。如果没有，<code class="fe mx my mz na b">cd backend/</code>。现在我们可以安装后端依赖项了。下面是终端命令:<br/> <code class="fe mx my mz na b">npm i bcryptjs connect-mongo crypto-js express express-session joi mongoose<br/></code>我会在我们使用它们的时候解释每一个包，所以现在请耐心等待。我们还想安装一个名为<strong class="ky ir"> nodemon </strong>(节点监视器)的开发依赖项。这将使我们在修改时不必重启服务器:<code class="fe mx my mz na b">npm i -D nodemon<br/></code>现在让我们整理一下我们的<strong class="ky ir">包</strong></p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="82ea" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/package.json ---<br/></em>{<br/>  "name": "backend",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "<strong class="na ir">./src/index.js</strong>",<br/>  "module": "<strong class="na ir">./src/server.js</strong>",<br/>  "scripts": {<br/><strong class="na ir">    "start": "node index.js",<br/>    "dev": "nodemon index.js"</strong><br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "bcryptjs": "^2.4.3",<br/>    "connect-mongo": "^2.0.3",<br/>    "crypto-js": "^3.1.9-1",<br/>    "esm": "^3.2.20",<br/>    "express": "^4.16.4",<br/>    "express-session": "^1.15.6",<br/>    "joi": "^14.3.1",<br/>    "mongoose": "^5.4.19"<br/>  },<br/>  "devDependencies": {<br/>    "nodemon": "^1.18.10"<br/>  }<br/>}</span></pre><p id="0af3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们更新我们的“main”和“module ”,以查看我们创建的<strong class="ky ir"> src/ </strong>文件夹。<br/>我们去掉了“<strong class="ky ir">测试</strong>”脚本，添加了“<strong class="ky ir">启动</strong>”和“<strong class="ky ir">开发</strong>”脚本。在本演练中，我们将主要使用dev脚本。记下所有的依赖项和我们的devDependencies，并仔细检查你的文件看起来是否相同，但是不要担心你的版本号是否不同。只要你像我一样安装它们，你的就会是最新的。</p><p id="0a6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以开始玩了！</p><h1 id="1540" class="ma mb iq bd mc md nk mf mg mh nl mj mk jw nm jx mm jz nn ka mo kc no kd mq mr bi translated">步骤2:服务器设置</h1><p id="fa34" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们从基础开始。在<strong class="ky ir"> src/ </strong>文件夹中创建一个名为<strong class="ky ir"> config.js </strong>的文件(还记得我们忽略的那个吗？).这个文件将包含我们所有的环境变量。在生产过程中，这些将由<a class="ae kv" href="https://nodejs.org/api/process.html#process_process_env" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">process . env</strong></a><strong class="ky ir"/>对象设置。我们稍后将在这里添加更多的变量，但现在，我的看起来是这样的:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="48e8" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/config.js ---<br/></em><strong class="na ir">export const {<br/>  PORT = 5000,<br/>  NODE_ENV = 'development'<br/>} = process.env;</strong></span></pre><p id="03a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能看起来很有趣，但是我们在这里所做的就是从<strong class="ky ir"> process.env </strong>对象中析构<strong class="ky ir"> PORT </strong>和<strong class="ky ir"> NODE_ENV </strong>变量，并在它们不存在的情况下给出默认值(在我们的例子中，它们不存在——默认值是我们将要使用的)。除了 3000，你可以选择任何端口<em class="ls">。我们将为我们的客户节省3000英镑。</em></p><p id="5aa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在进入我们的<strong class="ky ir"> server.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="dc72" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/server.js ---<br/></em><strong class="na ir">import express from 'express';<br/>import { PORT, NODE_ENV } from './config';</strong></span><span id="bf3f" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const app = express();</strong></span><span id="6619" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">app.disable('x-powered-by');</strong></span><span id="2928" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">app.use(express.urlencoded({ extended: true }));<br/>app.use(express.json());</strong></span><span id="8f4a" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">app.listen(PORT, () =&gt; console.log(`Listening on port ${PORT}`));</strong></span></pre><p id="30b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们导入<strong class="ky ir"> express </strong>函数，调用它——返回一个对象——并将其保存到常量<strong class="ky ir"> app </strong>(常规命名)中。<br/>接下来，我们禁用<strong class="ky ir">‘x-powered-by’</strong>，这使得用户更难看出我们在使用Express。为什么这是一件好事？黑客对我们的堆栈了解得越少越好。<br/>然后，我们添加两行中间件，记为<strong class="ky ir"> app.use( </strong> <em class="ls">中间件</em> <strong class="ky ir"> ) </strong>。我们过去必须安装一个名为body-parser的独立依赖项，但是现在Express内置了这些好东西。这两行允许我们解析HTTP请求的主体和JSON有效负载。<br/>然后，我们调用应用程序上的<strong class="ky ir"> listen </strong>方法，从<strong class="ky ir"> config.js </strong>传入我们的端口和一个回调，让我们知道我们已连接。让我们前往我们的终端，看看它是否工作！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/763a59f2f86bdd7631953b5ceed20730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBvEFnXl7DeNu9YWiBQPrg.png"/></div></div></figure><p id="db44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行<code class="fe mx my mz na b">npm run dev</code>之后，我们应该会看到输出“监听端口5000”。<br/>转到<a class="ae kv" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/</a><br/>你应该看到“<strong class="ky ir">无法得到/</strong>”<br/>听起来是个错误，我知道，但这正是我们想要的。</p><p id="7fba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那好吧。开始路由吧。在我们的routes文件夹中，让我们创建两个文件:<strong class="ky ir"> index.js </strong>和<strong class="ky ir"> user.js </strong>。我们的索引路由将简单地导出一个包含所有后端路由的对象。现在，它看起来像这样:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="ebb2" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/routes/index.js ---<br/></em><strong class="na ir">import userRoutes from './user';</strong></span><span id="03e7" class="nf mb iq na b gy np nh l ni nj">// syntactic sugar for { userRoutes: userRoutes }<br/><strong class="na ir">export { userRoutes };</strong></span></pre><p id="f425" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的用户路线，让我们这样做:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="2337" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/routes/user.js ---<br/></em><strong class="na ir">import express from 'express';</strong></span><span id="83a7" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const userRoutes = express.Router();</strong></span><span id="61b7" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">userRoutes.post("", (req, res) =&gt; {<br/>  res.send(req.body);<br/>});</strong></span><span id="4019" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export default userRoutes;</strong></span></pre><p id="80c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们使用<strong class="ky ir"> express创建一个路由器。Router() </strong>我们在上面定义了一个“post”方法，对应一个POST请求。第一个参数是路径(但它是一个空字符串！一会儿再详细介绍)，第二个是接收请求和响应对象的回调。在这个回调函数中，我们定义了我们希望路由做什么。这里我们告诉响应“发送”回请求的“主体”。</p><p id="0778" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，回到我们的<strong class="ky ir"> server.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="e127" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/server.js ---<br/></em>import express from 'express';<br/><strong class="na ir">import { userRoutes } from './routes/index';</strong><br/>import { PORT, NODE_ENV } from './config';</span><span id="e8f1" class="nf mb iq na b gy np nh l ni nj">const app = express();</span><span id="6c68" class="nf mb iq na b gy np nh l ni nj">app.disable('x-powered-by');</span><span id="c638" class="nf mb iq na b gy np nh l ni nj">app.use(express.urlencoded({ extended: true }));<br/>app.use(express.json());</span><span id="77fb" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const apiRouter = express.Router();<br/>app.use('/api', apiRouter);<br/>apiRouter.use('/users', userRoutes);</strong></span><span id="1d64" class="nf mb iq na b gy np nh l ni nj">app.listen(PORT, () =&gt; console.log(`Listening on port ${PORT}`));</span></pre><p id="d493" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的<strong class="ky ir"> server.js </strong>中，导入我们的<strong class="ky ir"> userRoutes </strong>，然后做两件事:<br/> 1。我们像之前一样设置了另一个路由器，名为<strong class="ky ir"> apiRouter </strong>，并告诉我们的<strong class="ky ir">应用</strong>对任何以“<strong class="ky ir"> /api </strong>开头的路径使用这个路由器。<br/> 2。然后我们告诉我们的<strong class="ky ir"> apiRouter </strong>使用我们的<strong class="ky ir"> userRoutes </strong>，对于任何以“<strong class="ky ir"> /users </strong>开头的路径。<br/>这就是为什么我们在<strong class="ky ir"> routes/user.js </strong>中使用空字符串作为路径——因为我们在server.js中提供了“/users”路径。</p><p id="b07a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们来测试一下！我将使用<a class="ae kv" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>。在我写这篇文章的时候，Google Chrome扩展已经过时了，所以我正在使用可以免费下载的原生应用。您可以随意使用任何选项来测试HTTP请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/b1fbdf9dbc963ca09351f61fb226e0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bPatenLW3Kzdc2KNoZsiEQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">如果这是你第一次使用Postman，它可能看起来像有一百万个按钮、旋钮和下拉框。我已经突出显示并标记了我们测试的一步一步的工作流程。</figcaption></figure><p id="b2b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一切顺利，我们应该得到一个200级别的响应，从请求中发送回主体。我们进展顺利。让我们保持下去！🙌</p><h1 id="4069" class="ma mb iq bd mc md nk mf mg mh nl mj mk jw nm jx mm jz nn ka mo kc no kd mq mr bi translated">步骤3:MongoDB/mongose集成</h1><p id="cc13" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">该去实地考察了！让我们创建我们的MongoDB Atlas帐户。我记得第一次使用Atlas时，我感到非常失落…所以我们将一起做这件事。(如果你是地图集专家，请直接跳过)。</p><p id="01d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.首先去https://www.mongodb.com/<a class="ae kv" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank">创建一个免费账户。一旦你的帐户被创建，你应该被引导到一个页面，在那里你可以创建你的第一个“集群”。选择您的首选项，我使用了所有预先选择的选项:AWS、my region、free-tier storage，并且没有费心更改集群名称。然后将开始集群创建过程(这可能需要几分钟时间)。<br/> 2。在“Clusters”页面中，单击页面中间附近的<strong class="ky ir"> Security </strong>选项卡，然后单击“<strong class="ky ir">Add new user”</strong>按钮。创建用户名/密码，并使用所有默认设置。我们希望这个用户拥有“<strong class="ky ir">读写权限</strong>”。<br/> 3。接下来，仍然在<strong class="ky ir">安全</strong>选项卡中，单击<strong class="ky ir"> IP白名单</strong>子选项卡。然后点击<strong class="ky ir">添加IP地址</strong>按钮和<strong class="ky ir">添加当前IP地址</strong>按钮。(我们快好了！)<br/> 4。现在，转到安全选项卡旁边的<strong class="ky ir">概述</strong>选项卡。在页面中间附近，单击<strong class="ky ir">连接</strong>，然后单击“<strong class="ky ir">连接您的应用程序”</strong>按钮(对我来说，这是中间的选项)。复制提供的连接字符串。我们将在我们的<strong class="ky ir"> config.js </strong>中使用它:</a></p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="2c47" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/config.js ---<br/></em>export const {<br/>  PORT = 5000,<br/>  NODE_ENV = 'development',</span><span id="2e65" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">  MONGO_URI = 'mongodb+srv://<em class="ls">YOURUSERNAME</em>:<em class="ls">YOURPASSWORD</em>@cluster0bdxbr.mongodb.net/testretryWrites=true'</strong></span><span id="80c0" class="nf mb iq na b gy np nh l ni nj">} = process.env;</span></pre><p id="eb62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提醒:如果你正在使用GitHub或者你正在上传你的代码，在你的<strong class="ky ir">中忽略这个配置文件。gitignore </strong>。<br/> <strong class="ky ir">不要分享我们放在config.js中的任何信息<br/> </strong>请确保填写您的真实用户名&amp;密码。<br/>现在，让我们更新我们的<strong class="ky ir"> server.js </strong>并连接这个数据库。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="6b5f" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/server.js ---<br/></em>import express from 'express';<br/><strong class="na ir">import mongoose from 'mongoose';</strong><br/>import { userRoutes } from './routes/index';<br/>import { PORT, NODE_ENV, <strong class="na ir">MONGO_URI</strong> } from './config';</span><span id="8168" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">(async () =&gt; {<br/></strong>  <strong class="na ir">try {</strong><br/>    <strong class="na ir">await mongoose.connect(MONGO_URI, { useNewUrlParser: true });<br/>    console.log('MongoDB connected');</strong></span><span id="84ef" class="nf mb iq na b gy np nh l ni nj">    const app = express();<br/>    app.disable('x-powered-by');<br/>    app.use(express.urlencoded({ extended: true }));<br/>    app.use(express.json());</span><span id="a7bb" class="nf mb iq na b gy np nh l ni nj">    const apiRouter = express.Router();<br/>    app.use('/api', apiRouter);<br/>    apiRouter.use('/users', userRoutes);</span><span id="4bed" class="nf mb iq na b gy np nh l ni nj">    app.listen(PORT, () =&gt; console.log(`Listening on port ${PORT}`));<br/>  <strong class="na ir">} catch (err) {<br/>    console.log(err)</strong><br/>  <strong class="na ir">}<br/>})();</strong></span></pre><p id="8994" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇…这是怎么回事？我们来分解一下。<br/>首先我们导入<a class="ae kv" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">猫鼬</strong> </a>，一个对象数据建模(ODM)库。我们还将<strong class="ky ir">蒙戈_URI </strong>添加到我们的配置导入中。<br/>然后，我们使用mongoose连接到我们的MongoDB Atlas，使用我们导入的URI和一个包含<code class="fe mx my mz na b">useNewUrlParser: true</code>的options对象(这允许我们的URI被解析)。<br/>整个过程是<em class="ls">异步的</em>，我们不希望我们的服务器在数据库连接之前启动。<br/>我们<em class="ls">可以</em>用<strong class="ky ir">。然后是</strong>，但是对于整个应用程序，我们将使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">异步/等待</strong> </a>。为了适应这种情况，我们将所有代码包装在一个异步的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">life</a>(立即调用的函数表达式)中。<br/>最后，我们使用一个<strong class="ky ir"> try/catch </strong>块，如果出现问题，它将记录控制台中的任何错误。如果一切顺利，我们应该会看到两个<strong class="ky ir"> console.log </strong>输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/5258fcd0a3e495787de427d67506200d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LT4oIBsg_bF657drtmIXhQ.png"/></div></div></figure><h1 id="6077" class="ma mb iq bd mc md nk mf mg mh nl mj mk jw nm jx mm jz nn ka mo kc no kd mq mr bi translated">步骤4:模型和验证</h1><p id="caf0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这一步可能有点复杂，但是不要担心！我们在一起。<br/>在我们的<strong class="ky ir"> models/ </strong>文件夹中，创建一个<strong class="ky ir"> user.js </strong>文件。<br/>我们将使用<a class="ae kv" href="https://www.npmjs.com/package/bcryptjs" rel="noopener ugc nofollow" target="_blank"> Bcrypt </a>对用户的密码进行加盐和哈希处理，然后将它们保存到数据库中。<strong class="ky ir">切勿保存纯文本密码</strong>。<br/>我使用BCrypt的<strong class="ky ir"> sync </strong>版本函数(它使用<strong class="ky ir"> async/await </strong>)来保持我们的代码更干净。我把这个分成两部分:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="9786" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/routes/user.js ---<br/></em><strong class="na ir">import mongoose from 'mongoose';<br/>import { compareSync, hashSync } from 'bcryptjs';</strong></span><span id="db8f" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const UserSchema = new mongoose.Schema({<br/>  username: {<br/>    type: String,<br/>    validate: {<br/>      validator: username =&gt; User.doesNotExist({ username }),<br/>      message: "Username already exists"<br/>    }<br/>  },<br/>  email: {<br/>    type: String,<br/>    validate: {<br/>      validator: email =&gt; User.doesNotExist({ email }),<br/>      message: "Email already exists"<br/>    }<br/>  },<br/>  password: {<br/>    type: String,<br/>    required: true<br/>  }<br/>}, { timestamps: true });<br/>...</strong></span></pre><p id="98e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来分析一下。我们从导入<strong class="ky ir">mongose</strong>和我们需要的Bcrypt函数开始。<br/>接下来，我们定义一个<strong class="ky ir">用户模式</strong>。这基本上是如何将我们的用户对象保存在我们的数据库中的蓝图。我们的用户很简单，只需要用户名、电子邮件和密码(<a class="ae kv" href="https://mongoosejs.com/docs/guide.html" rel="noopener ugc nofollow" target="_blank">更多关于mongoose模式)</a>。我们指定这些字段将是<strong class="ky ir">字符串</strong>，为用户名和电子邮件添加一个定制的<strong class="ky ir">验证器</strong>，为密码添加一个简单的<strong class="ky ir">必需的</strong>验证器，以及<strong class="ky ir">时间戳</strong>。我们需要在这里再补充一点:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="a657" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/routes/user.js ---<br/></em><strong class="na ir">...<br/>UserSchema.pre('save', function () {<br/>  <em class="ls">if</em> (<em class="ls">this</em>.isModified('password')) {<br/>    <em class="ls">this</em>.password = hashSync(<em class="ls">this</em>.password, 10);<br/>  }<br/>});</strong></span><span id="c910" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">UserSchema.statics.doesNotExist = async function (field) {<br/>  <em class="ls">return</em> <em class="ls">await</em> <em class="ls">this</em>.where(field).countDocuments() === 0;<br/>};</strong></span><span id="ace5" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">UserSchema.methods.comparePasswords = function (password) {<br/>  <em class="ls">return</em> compareSync(password, <em class="ls">this</em>.password);<br/>};</strong></span><span id="cc84" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const User = mongoose.model('User', UserSchema);<br/>export default User;</strong></span></pre><p id="d5c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要为我们的UserSchema添加一个“pre-hook”<strong class="ky ir"/>或“中间件”。这段代码将在我们的用户实例保存之前运行。由于词法范围的原因，我们不能对这三种方法使用箭头函数。<br/><strong class="ky ir">这个</strong>就是我们的<strong class="ky ir"> pre </strong>方法所指的用户实例。我们仔细检查是否提供了一个密码，然后将该密码重置为它的salted和hashed版本。<br/>然后我们定义我们的自定义验证器，<strong class="ky ir">不存在，</strong>，它是在我们的<strong class="ky ir"> UserSchema </strong>上定义的<em class="ls">类方法</em>。使用两个mongoose方法和一个比较操作符，我们可以确定用户是否存在。这是一个异步步骤，所以我们使用async/await。<br/>我们还定义了一个<em class="ls">实例方法</em>、<strong class="ky ir"> comparePasswords、</strong>，它简单地将一个纯文本密码与一个用户实例的散列密码进行比较。<br/>最后，我们明确定义或<strong class="ky ir">用户</strong>模型并导出。</p><p id="24d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一站:验证。我们将使用<a class="ae kv" href="https://www.npmjs.com/package/joi" rel="noopener ugc nofollow" target="_blank"> Joi </a>进行验证。但是你可能会问，“我们不是刚刚在模型中添加了验证吗？”是的……但是，这些本质上是我们的数据库级验证，我们希望在创建用户实例之前，在上面再检查一层验证。在Joi的帮助下，我们也可以变得更具体。在我们的<strong class="ky ir"> validations/ </strong>文件夹中创建一个<strong class="ky ir"> user.js </strong>文件，如下所示:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="6e91" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/validations/user.js ---<br/></em><strong class="na ir">import Joi from 'joi';</strong></span><span id="fa9c" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const email = Joi.string().email().required();<br/>const username = Joi.string().alphanum().min(3).max(30).required();</strong></span><span id="d074" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const message = 'must be between 6-16 characters, ' +<br/>  'have at least one capital letter, ' +<br/>  'one lowercase letter, one digit, ' +<br/>  'and one special character';</strong></span><span id="ed9e" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const password = Joi.string()<br/>  .regex(/<em class="ls">^</em>(?=.*[A-Za-z])(?=.*\d)(?=.*[!@#$%^&amp;*])[a-zA-Z0-9!@#$%^&amp;*]{6,16}<em class="ls">$</em>/)<br/>  .options({<br/>    language: {<br/>      string: {<br/>        regex: {<br/>          base: message<br/>        }<br/>      }<br/>    }<br/>});</strong></span><span id="7edd" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export const signUp = Joi.object().keys({<br/>  email,<br/>  username,<br/>  password<br/>});</strong></span><span id="d0c3" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export const signIn = Joi.object().keys({<br/>  email,<br/>  password<br/>});</strong></span></pre><p id="bd9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<a class="ae kv" href="https://www.npmjs.com/package/joi" rel="noopener ugc nofollow" target="_blank">文档</a>很精彩，我不会花太多时间解释这里发生了什么。我们看到我们定义了一个<strong class="ky ir">电子邮件</strong>、<strong class="ky ir">用户名</strong>和<strong class="ky ir">密码</strong>，每个都附加了验证。默认情况下，Joi会在某些内容无效时提供一条消息，但是对于密码字段，它实际上会打印出用户猜测的密码。密码应该永远不可见。因此，我们创建了一个定制的<strong class="ky ir">消息</strong>并深入到<strong class="ky ir">选项</strong>对象中来传递它。然后，我们使用正则表达式来获取密码验证的具体细节。<br/>接下来，我们使用我们的<strong class="ky ir">电子邮件</strong>、<strong class="ky ir">用户名</strong>和<strong class="ky ir">密码</strong>来创建和导出两个<strong class="ky ir"> Joi对象</strong>。我们将使用这些来验证用户的输入。</p><p id="05f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们回到我们的<strong class="ky ir"> routes/user.js </strong>文件:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="26c1" class="nf mb iq na b gy ng nh l ni nj"><strong class="na ir">import Joi from 'joi';</strong><br/>import express from 'express';<br/><strong class="na ir">import User from '../models/user';<br/>import { signUp } from '../validations/user';</strong></span><span id="bb6e" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const userRouter = express.Router();<br/>userRouter.post("", async (req, res) =&gt; {<br/>  <em class="ls">try</em> {<br/>    const { username, email, password } = req.body<br/>    <em class="ls">await</em> Joi.validate({ username, email, password }, signUp);</strong></span><span id="9c6a" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">    const newUser = new User({ username, email, password });<br/>    <em class="ls">await</em> newUser.save();<br/>    res.send({ userId: newUser.id, username });<br/>  } <em class="ls">catch</em> (err) {<br/>    res.status(400).send(err);<br/>  }<br/>});</strong></span><span id="393f" class="nf mb iq na b gy np nh l ni nj">export default userRouter;</span></pre><p id="6227" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们引入了<strong class="ky ir"> Joi </strong>，我们的<strong class="ky ir">用户</strong>模型，以及我们的<strong class="ky ir">注册</strong>验证器。<br/>然后我们修改我们的<strong class="ky ir"> post </strong>方法，使用<strong class="ky ir"> async </strong>和一个<strong class="ky ir"> try/catch </strong>块。<br/>接下来，我们析构<strong class="ky ir"> req.body </strong>并调用<strong class="ky ir"> Joi.validate </strong>方法，传递一个包含用户输入和我们的<strong class="ky ir">注册</strong>验证器的对象。如果通过，我们定义一个<strong class="ky ir">新用户</strong>实例并尝试保存该用户。如果通过了，我们就发送回我们希望我们的前端可以访问的内容。如果有任何失败，它将被捕获，我们通过将状态代码设置为<strong class="ky ir"> 400 </strong>并发回错误来做出响应(我们将在以后改进我们的错误处理)。有人可能会问，“如果req.body只包含一个包含用户名、电子邮件和密码的JSON对象，为什么还要将其析构呢？为什么不直接将整个主体传递给我们的验证器和新的用户函数呢？”嗯……问题是我们不知道这是否是身体所包含的全部。我们已经看到使用Postman，用户可以在请求的主体/参数中放入任何他们想要的东西。有了我们定义的验证器和模式，这里没有太大的风险，但是一个好的经验法则是永远不要相信来自用户的输入。</p><p id="80dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用Postman来测试一下！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/c53ec00da312795233619b17d2cb4420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6dGW4MoKkY6A0ecaWM7yg.png"/></div></div></figure><p id="8300" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就服务器而言，这里的情况看起来很好。注意到我们得到的回应了吗？我们的Redux商店以后会喜欢的。<br/>现在，让我们转到我们的MongoDB Atlas帐户，从主集群页面中，单击“<strong class="ky ir">集合</strong>”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/999057f015c328167de806c1b8434c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_YXGmIiszstT60iOlTmjg.png"/></div></div></figure><p id="e485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的用户来了！您可以看到密码确实经过了哈希处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/8c355e6ca087f03a53acecc0efc8be04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CCfuokNkD-gehMFKP_DsQA.png"/></div></div></figure><p id="baf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们试图输入任何无效的内容，我们会得到一个包含一条好消息的响应，稍后我们将在客户端使用这条消息向用户显示。</p><p id="1a78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在进入前端之前，我们还有一个后端步骤要完成。<br/>现在不能停！✊</p><h1 id="23a6" class="ma mb iq bd mc md nk mf mg mh nl mj mk jw nm jx mm jz nn ka mo kc no kd mq mr bi translated">第五步:会话</h1><p id="9f30" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们进入正题。在我们的<strong class="ky ir"> config.js </strong>中，我们需要再添加几行代码:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="53c2" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/config.js --<br/>  </em>...<br/>  <strong class="na ir">SESS_NAME = 'sid',<br/>  SESS_SECRET = 'secret!session',<br/>  SESS_LIFETIME = 1000 * 60 * 60 * 2</strong><br/>} = process.env;</span></pre><p id="7391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们析构/定义一个会话<strong class="ky ir">名称</strong>，<strong class="ky ir">秘密</strong>，和<strong class="ky ir">寿命</strong>(我只用了两天)。这个<strong class="ky ir"> SESS_SECRET </strong>用于使用HMAC散列sessionID。这个秘密通常应该是在您的环境中定义的深奥的东西(例如Heroku等)，但是对于开发来说，这是可以的。<strong class="ky ir"> SESS_NAME </strong>稍后将用于引用我们的会话。</p><p id="f001" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，让我们回到我们的<strong class="ky ir"> server.js </strong>文件。我会把它一分为二:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="6e87" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/server.js ---</em><br/>import express from 'express';<br/>import mongoose from 'mongoose';<br/><strong class="na ir">import session from "express-session";</strong><br/><strong class="na ir">import connectStore from "connect-mongo";</strong><br/>import { userRoutes } from './routes/index';<br/>import {<br/>PORT, NODE_ENV, MONGO_URI, <strong class="na ir">SESS_NAME</strong>, <strong class="na ir">SESS_SECRET</strong>, <strong class="na ir">SESS_LIFETIME</strong><br/>} from "./config";</span><span id="5428" class="nf mb iq na b gy np nh l ni nj">(async () =&gt; { <br/>...</span></pre><p id="1ceb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们处理一些进口商品。<br/>使用<strong class="ky ir">快速会话</strong>时，我们应该注意一些事情:</p><blockquote class="nw nx ny"><p id="f125" class="kw kx ls ky b kz la jr lb lc ld ju le nz lg lh li oa lk ll lm ob lo lp lq lr ij bi translated"><em class="iq"/><strong class="ky ir"><em class="iq">警告</em> </strong>默认的服务器端会话存储<code class="fe mx my mz na b"><em class="iq">MemoryStore</em></code>，是<em class="iq">特意</em>不为生产环境设计的。它在大多数情况下会泄漏内存，不会扩展到单个进程之外，并且只用于调试和开发。”<br/> <em class="iq"> — </em> <a class="ae kv" href="https://github.com/expressjs/session" rel="noopener ugc nofollow" target="_blank"> <em class="iq">快速-会话文档</em> </a></p></blockquote><p id="30d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">啊哦。我们应该做点什么，对吗？<br/>进入<a class="ae kv" href="https://github.com/jdesboeufs/connect-mongo" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">连接-mongo </strong> </a>。这将把我们的会话信息保存到数据库中，并允许在我们的服务器关闭或重启时重新建立连接。当我们<em class="ls">注销时销毁</em>我们的会话时，这个会话信息会自动从我们的数据库中删除。很酷，对吧？让我们继续前进:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="6d6f" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/server.js ---</em><br/>    ...<br/>    const app = express();<br/>    <strong class="na ir">const MongoStore = connectStore(session);</strong></span><span id="791e" class="nf mb iq na b gy np nh l ni nj">    app.use(express.urlencoded({ extended: true }));<br/>    app.use(express.json());<br/><strong class="na ir">    app.use(session({<br/>      name: SESS_NAME,<br/>      secret: SESS_SECRET,<br/>      saveUninitialized: false,<br/>      resave: false,<br/>      store: new MongoStore({<br/>        mongooseConnection: mongoose.connection,<br/>        collection: 'session',<br/>        ttl: parseInt(SESS_LIFETIME) / 1000<br/>      }),<br/>      cookie: {<br/>        sameSite: true,<br/>        secure: NODE_ENV === 'production',<br/>        maxAge: parseInt(SESS_LIFETIME)<br/>      }<br/>    }));<br/>    ...</strong></span></pre><p id="32c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们调用<strong class="ky ir"> connectStore </strong>传入我们的<strong class="ky ir">会话</strong>中间件，并将其保存到常量<strong class="ky ir"> MongoStore </strong>中。<br/>现在，我们告诉我们的<strong class="ky ir">应用</strong>使用<strong class="ky ir">会话</strong>中间件，并传入一个选项对象。我们已经覆盖了<strong class="ky ir">名称</strong>和<strong class="ky ir">秘密</strong>，但是我们又传递了两个选项:<br/><code class="fe mx my mz na b">saveUninitialized: false</code>；这符合在设置cookie之前需要许可的法律。<br/>T1；如果会话未被修改，这可以防止不必要的重新保存。<br/>商店<strong class="ky ir">选项是我们插入<strong class="ky ir"> MongoStore </strong>的地方。我们将通过它的三个选项:<br/><code class="fe mx my mz na b">mongooseConnection: mongoose.connection</code>；这使用了我们在上面建立的连接，这样我们就不必连接Mongo两次。<br/>T3；这指定了我们的会话信息在数据库中的保存位置。<br/>T4；(“生存时间”)我们希望这与我们的<strong class="ky ir"> SESS_LIFETIME </strong>相匹配，除了connect-mongo使用秒而不是毫秒，所以我们除以1000。我们在这里和下面也使用<strong class="ky ir"> ParseInt() </strong>，因为一些环境变量在生产中经常被设置为字符串。我们想要一个数字。<br/>接下来给我们的<strong class="ky ir"> cookie </strong>一些选项:<br/><code class="fe mx my mz na b">sameSite: true</code>；这有助于防止CSRF袭击。<br/><code class="fe mx my mz na b">secure: NODE_ENV === ‘production’</code>；我们只在生产过程中将cookie设置为安全的。<em class="ls">成为</em> <strong class="ky ir">真<em class="ls"> </em> </strong> <em class="ls">需要一个支持https的网站。</em> <br/> <strong class="ky ir"> maxAge </strong>简单地指定了我们的cookie的年龄。<br/>我只是为这些选项提供一个高层次的解释，还有<em class="ls">许多默认选项正在设置</em>。<a class="ae kv" href="https://github.com/expressjs/session" rel="noopener ugc nofollow" target="_blank">文档</a>详细解释了所有这些。</strong></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="79d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在完成后端之前，我们还有两个文件要处理。在创建会话路由之前，我们将在<strong class="ky ir"> util/helpers.js </strong>中定义两个助手方法:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="1be0" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/util/helpers.js ---<br/></em><strong class="na ir">export const parseError = err =&gt; {<br/>  if (err.isJoi) return err.details[0];<br/>  return JSON.stringify(err, Object.getOwnPropertyNames(err));<br/>};</strong></span><span id="533a" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export const sessionizeUser = user =&gt; {<br/>  return { userId: user.id, username: user.username };<br/>}</strong></span></pre><p id="59df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个函数将允许我们区分<strong class="ky ir"> Joi </strong>错误和我们稍后抛出的自定义<strong class="ky ir">错误</strong>并提取消息，我们将消息发送给客户端并显示给我们的用户。<br/>第二个函数返回一个对象，该对象包含我们希望保存到会话中并稍后发送回Redux存储的内容。<br/>让我们将我们的错误解析器添加到<strong class="ky ir"> routes/user.js </strong>，并将我们的用户保存到我们的<strong class="ky ir">会话</strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="32ce" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/routes/user.js ---<br/></em>import Joi from 'joi';<br/>import express from 'express';<br/>import User from '../models/user';<br/>import { signUp } from '../validations/user';<br/><strong class="na ir">import { parseError, sessionizeUser } from "../util/helpers";</strong></span><span id="9d2e" class="nf mb iq na b gy np nh l ni nj">const userRouter = express.Router();<br/>userRouter.post("", async (req, res) =&gt; {<br/>  try {<br/>    const { username, email, password } = req.body;<br/>    await Joi.validate({ username, email, password }, signUp);</span><span id="985d" class="nf mb iq na b gy np nh l ni nj">    const newUser = new User({ username, email, password });<br/>    <strong class="na ir">const sessionUser = sessionizeUser(newUser);</strong><br/>    await newUser.save();</span><span id="bcc7" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">    req.session.user = sessionUser;</strong><br/>    res.send(<strong class="na ir">sessionUser</strong>);<br/> } catch (err) {<br/>   res.status(400).send(<strong class="na ir">parseError(err)</strong>);<br/>  }<br/>});</span><span id="23d0" class="nf mb iq na b gy np nh l ni nj">export default userRouter;</span></pre><p id="a0cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在设置了<strong class="ky ir">快速会话</strong>之后，我们可以访问会话对象<em class="ls">，该对象只保存在服务器端</em>(客户端不能访问该会话)。记住这一点，我们将用户的id和用户名保存到我们的会话中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/c7cd0e9dde13d8d8bb7f76a48add0972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_gFKpTVMju4CZA_Ct7PUQ.png"/></div></div></figure><p id="b328" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了展示它的工作原理，我在我们存储用户的地方放了一个<strong class="ky ir">console . log(req . session)</strong>。然后我用Postman创建了另一个用户，他就在那里！</p><p id="219b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在让我们在<strong class="ky ir"> routes/ </strong>文件夹中创建一个<strong class="ky ir"> session.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="be32" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/routes/session.js ---<br/></em><strong class="na ir">import express from "express";<br/>import Joi from "joi";<br/>import User from "../models/user";<br/>import { signIn } from "../validations/user";<br/>import { parseError, sessionizeUser } from "../util/helpers";<br/>import { SESS_NAME } from "../config";</strong></span><span id="79bf" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const sessionRouter = express.Router();<br/></strong><em class="ls">...</em></span></pre><p id="b70d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们进口我们需要的一切。除了可能<strong class="ky ir"> SESS_NAME </strong>之外，这里没有什么好惊讶的，你很快就会明白为什么我们需要它。然后，我们定义<strong class="ky ir">会话路由器</strong>，就像我们定义<strong class="ky ir">用户路由器</strong>一样。</p><p id="b214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将从登录开始定义三个API端点:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="1284" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/routes/session.js ---<br/>...</em><br/><strong class="na ir">sessionRouter.post("", async (req, res) =&gt; {<br/>  try {<br/>    const { email, password } = req.body<br/>    await Joi.validate({ email, password }, signIn);</strong></span><span id="e1b6" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">    const user = await User.findOne({ email });<br/>    if (user &amp;&amp; user.comparePasswords(password)) {<br/>      const sessionUser = sessionizeUser(user);</strong></span><span id="c3dc" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">      req.session.user = sessionUser<br/>      res.send(sessionUser);<br/>    } else {<br/>      throw new Error('Invalid login credentials');<br/>    }<br/>  } catch (err) {<br/>    res.status(401).send(parseError(err));<br/>  }<br/>});<br/>...</strong></span></pre><p id="0332" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来谈谈这个。我们在我们的<strong class="ky ir"> sessionRouter </strong>上定义了一个post方法，我们添加了<strong class="ky ir"> async </strong>，从请求体中提取了<strong class="ky ir"> email </strong>和<strong class="ky ir">密码</strong>，并使用了我们的<strong class="ky ir">sign in</strong><strong class="ky ir">Joi</strong>validator。<br/>如果通过，我们使用<strong class="ky ir">findOne</strong>mongose方法查询我们的用户集合，确保使用<strong class="ky ir"> await </strong>。然后我们检查我们是否得到了一个用户，以及提供的密码是否与散列密码匹配(这里的逻辑顺序很重要)。如果成功，我们将用户会话化，将他们的数据存储在会话对象中，并将他们的信息发送给客户端。否则，我们捕捉任何错误，无论是一个<strong class="ky ir"> Joi </strong>错误还是我们说<code class="fe mx my mz na b">new Error(‘Invalid login credentials’)</code>时抛出的错误，设置一个失败状态代码，并发回解析后的错误。</p><p id="cb24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步:注销。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="57de" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/routes/session.js ---<br/>...<br/></em><strong class="na ir">sessionRouter.delete("", ({ session }, res) =&gt; {<br/>  try {<br/>    const user = session.user;<br/>    if (user) {<br/>      session.destroy(err =&gt; {<br/>        if (err) throw (err);</strong></span><span id="c8dc" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">        res.clearCookie(SESS_NAME);<br/>        res.send(user);<br/>      });<br/>    } else {<br/>      throw new Error('Something went wrong');<br/>    }<br/>  } catch (err) {<br/>    res.status(422).send(parseError(err));<br/>  }<br/>});<br/>...</strong></span></pre><p id="4575" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们从请求对象中析构出<strong class="ky ir">会话</strong>(因为我们不需要任何其他东西)并将用户从该会话中拉出。如果有，我们调用内置的<strong class="ky ir">销毁</strong>方法。<br/>然后我们在我们的响应上调用<strong class="ky ir">clear cookie(</strong><em class="ls">session _ name</em><strong class="ky ir"><em class="ls">)</em></strong>方法，将用户发送回客户端。</p><p id="e343" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的最后一个端点只是检查用户是否登录。这个很简单:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="3dc3" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/routes/session.js ---<br/>...<br/></em><strong class="na ir">sessionRouter.get("", ({ session: { user }}, res) =&gt; {<br/>  res.send({ user });<br/>});</strong></span><span id="2c5e" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export default sessionRouter;</strong></span></pre><p id="902f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将请求分解给用户。这要么是我们的用户，要么是未定义的。在任何情况下，我们发送回一个<strong class="ky ir">用户</strong>的对象，该对象指向我们从会话中得到的任何内容。</p><p id="82ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只有两个任务要完成了！在<strong class="ky ir"> routes/index.js </strong>中:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="b20c" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/routes/index.js ---<br/></em>import userRoutes from './user';<br/><strong class="na ir">import sessionRoutes from './session';</strong></span><span id="ba6e" class="nf mb iq na b gy np nh l ni nj">export { userRoutes, <strong class="na ir">sessionRoutes</strong> };</span></pre><p id="c279" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Annnnd in our <strong class="ky ir"> server.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="ff93" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- backend/server.js ---</em><br/>    ...<br/>    const apiRouter = express.Router();<br/>    app.use('/api', apiRouter);<br/>    apiRouter.use('/users', userRoutes);<br/><strong class="na ir">    apiRouter.use('/session', sessionRoutes);<br/>    ...</strong></span></pre><p id="96b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！我们的后端现在完成了！🎉给自己一个鼓励。你刚刚从头开始写了一个后端！👍</p><h1 id="0084" class="ma mb iq bd mc md nk mf mg mh nl mj mk jw nm jx mm jz nn ka mo kc no kd mq mr bi translated">步骤6:反应/还原设置</h1><p id="b9a0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在继续之前，如果这是您第一次使用React和Redux，这些概念可能听起来有点混乱，但是不要担心！它们非常重复，只是需要练习。和往常一样，我将从高层次上解释事情，但如果你感到头晕，我强烈推荐<a class="ae kv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae kv" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>文档。他们太棒了！最后，注意<em class="ls">隐式返回</em>。我们会用到很多。准备好了吗？</p><p id="3127" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将目录向上切换到我们的根项目目录，<strong class="ky ir"> SessionAuth </strong> : <code class="fe mx my mz na b">cd ..</code> <br/>现在运行这个命令:<code class="fe mx my mz na b">npx create-react-app frontend<br/></code>这将设置一个React应用程序，而不需要任何构建配置。这给我们制造了相当多的时间，所以我们需要做一些清理工作。<br/>你可以随意保留任何你想要/需要的文件。我对这个应用程序进行了精简，以便它可以在未来的应用程序中重复使用，没有任何负担。我删除了<code class="fe mx my mz na b">public/<strong class="ky ir">favicon.ico</strong>, <strong class="ky ir">manifest.json</strong>, src/<strong class="ky ir">App.css</strong>, <strong class="ky ir">App.test.js</strong>, <strong class="ky ir">index.css</strong>, <strong class="ky ir">logo.svg</strong>, <strong class="ky ir">serviceWorker.js</strong></code>，并重新整理了我的文件结构，如下所示:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="86b1" class="nf mb iq na b gy ng nh l ni nj">SessionAuth/<br/>   |— backend/<br/>   |— frontend/<br/>      |— node_modules/<br/>      |— public/<br/>         |— index.html<br/>      |— src/<br/>         <strong class="na ir">|— actions/<br/>         |— components/<br/>            </strong>|— App.js &lt;= moved<strong class="na ir"><br/>         |— reducers/</strong><br/><strong class="na ir">            |— errors/<br/>            |— session/<br/>         |— store/<br/>         |— util/<br/>        </strong> |— index.js<br/><strong class="na ir">        </strong> |— .gitignore<br/><strong class="na ir">        </strong> |— package-lock.json<br/><strong class="na ir">        </strong> |— package.json</span></pre><p id="a13f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我也给index.html修剪了一下:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="947a" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/public/index.html ---<br/></em>&lt;!DOCTYPE <em class="ls">html</em>&gt;<br/>&lt;html <em class="ls">lang</em>="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta <em class="ls">charset</em>="utf-8" /&gt;<br/>    &lt;meta<br/>      <em class="ls">name</em>="viewport"<br/>      <em class="ls">content</em>="width=device-width, initial-scale=1, shrink-to-fit=no"<br/>    /&gt;<br/>    &lt;title&gt;<strong class="na ir">Session Auth</strong>&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;<br/>  &lt;div <em class="ls">id</em>="root"&gt;&lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="2d9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一站是我们的<strong class="ky ir"> App.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="4363" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/components/App.js ---<br/></em><strong class="na ir">import React from 'react';</strong></span><span id="7282" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export default () =&gt; (<br/>  &lt;&gt;<br/>    &lt;h1&gt;Hello world&lt;/h1&gt;<br/>  &lt;/&gt;<br/>);</strong></span></pre><p id="7456" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在非常高的层面上，<a class="ae kv" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">组件</strong> </a>只是返回<a class="ae kv" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">【JSX】</strong></a>的函数，这些函数产生<strong class="ky ir"> React元素</strong>，这些元素随后被渲染到DOM中。为了简单起见，我们不会使用任何有状态的组件。<br/>我们将使用<a class="ae kv" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">片段</a>，它允许我们对元素进行分组，而无需向DOM添加额外的节点。这里我们用一个来安置我们的<strong class="ky ir"> h1 </strong>。我们过会儿会回到这里。</p><p id="3184" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在为我们的<strong class="ky ir"> index.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="618e" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/index.js ---<br/></em>import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import App from '.<strong class="na ir">/components</strong>/App';<br/>// delete old imports we don't need</span><span id="dada" class="nf mb iq na b gy np nh l ni nj">ReactDOM.render(<br/>  &lt;App /&gt;, <br/>  document.getElementById('root')<br/>);</span></pre><p id="f126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稍后我们会在这里添加更多的内容，但是现在，这已经很好了。我们正在渲染来自我们的<strong class="ky ir">index.html</strong>的<code class="fe mx my mz na b">&lt;div <em class="ls">id</em>=”root”&gt;&lt;/div&gt;</code>内的<strong class="ky ir"> App </strong>组件，它反过来渲染那个<strong class="ky ir"> h1 </strong>。<br/> <br/>还记得我们为客户保存<strong class="ky ir">端口3000 </strong>的时候吗？嗯，我们仍然需要一种方法让我们的客户端与我们的后端进行通信。为此，我们将使用一个<a class="ae kv" href="https://facebook.github.io/create-react-app/docs/proxying-api-requests-in-development" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">代理</strong> </a>。<br/>在我们的<em class="ls">前端</em>底部<strong class="ky ir"> package.json </strong>我们添加:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="3358" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/package.json ---<br/>    </em>...<br/>     "browserslist": [<br/>      "&gt;0.2%",<br/>      "not dead",<br/>      "not ie &lt;= 11",<br/>      "not op_mini all"<br/>    ],<br/>  <strong class="na ir">"proxy": "http://localhost:5000"</strong><br/>}</span></pre><p id="3c47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这告诉我们的服务器在我们向“/api/session”这样的东西发出请求时使用我们的后端资源。</p><p id="93c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<strong class="ky ir">在一个单独的终端标签或窗口中，</strong>保持后端服务器运行，将目录更改到我们的<strong class="ky ir"> frontend/ </strong>文件夹:<code class="fe mx my mz na b">cd frontend/</code>，并运行这个命令:<code class="fe mx my mz na b">npm start</code> <br/>现在转到<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>，您应该会看到“Hello world”。</p><p id="4b4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在在<strong class="ky ir">另一个单独的</strong>终端标签或窗口中(你现在应该至少打开三个)，确保你在<strong class="ky ir">前端/ </strong>目录中并安装这些依赖项:<code class="fe mx my mz na b">npm i react-redux react-router-dom redux redux-thunk<br/></code>好的。现在一切就绪，我们可以开始集成Redux了！<br/>让我们从在<strong class="ky ir"> util/session.js </strong>中创建HTTP请求函数开始:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="1d47" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/util/session.js ---<br/></em><strong class="na ir">export const signup = user =&gt; (<br/>  fetch("api/users", {<br/>    method: "POST",<br/>    body: JSON.stringify(user),<br/>    headers: {<br/>      "Content-Type": "application/json"<br/>    }<br/>  })<br/>);</strong></span><span id="9be0" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export const login = user =&gt; (<br/>  fetch("api/session", {<br/>    method: "POST",<br/>    body: JSON.stringify(user),<br/>    headers: {<br/>      "Content-Type": "application/json"<br/>    }<br/>  })<br/>);</strong></span><span id="3d4b" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export const logout = () =&gt; (<br/>  fetch("api/session", { method: "DELETE" })<br/>);</strong></span></pre><p id="048a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank"> Fetch API </a>来访问我们的三个后端端点。还记得我们在使用Postman的时候选择了“<strong class="ky ir">应用/json </strong>”吗？我们想在这里做同样的事情，但是我们通过使用<strong class="ky ir"> json.stringify() </strong>来确保我们请求的<strong class="ky ir">主体</strong>是JSON格式的。</p><p id="f15c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们继续前进之前，让我们来讨论一下我们希望如何塑造我们的前端状态——指的是我们的Redux存储。</p><p id="87d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当考虑状态形状时，问这两个问题是有好处的。在任何给定时刻，我们的应用程序需要访问哪些数据？<br/> 2。我们如何以一种<a class="ae kv" href="https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape" rel="noopener ugc nofollow" target="_blank">规范化</a>的方式组织这些数据？<br/>由于这个应用程序将只包括跟踪会话和注册/登录错误，以下是我现在的想法:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="3990" class="nf mb iq na b gy ng nh l ni nj">{<br/>  session: { id, username },<br/>  errors: ""<br/>}</span></pre><p id="84bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们把它保持得非常简单。<br/>现在让我们设置我们的<strong class="ky ir">行动</strong>。在<strong class="ky ir">动作/ </strong>中创建一个<strong class="ky ir"> session.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="55f9" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/actions/session.js ---<br/></em><strong class="na ir">import * as apiUtil from ‘../util/session’;</strong></span><span id="7bdb" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export const RECEIVE_CURRENT_USER = ‘RECEIVE_CURRENT_USER’;<br/>export const LOGOUT_CURRENT_USER = ‘LOGOUT_CURRENT_USER’;</strong></span><span id="59e3" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const receiveCurrentUser = user =&gt; ({<br/>  type: RECEIVE_CURRENT_USER,<br/>  user<br/>});</strong></span><span id="050e" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const logoutCurrentUser = () =&gt; ({<br/>  type: LOGOUT_CURRENT_USER<br/>});<br/>...</strong></span></pre><p id="2111" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们将获取函数作为<strong class="ky ir"> apiUtil </strong>导入，因此在使用<strong class="ky ir">注册/登录/注销</strong>时，我们不会有任何名称空间冲突。<br/>接下来，我们定义两种<strong class="ky ir">动作类型</strong>，这将帮助我们的reducers决定如何处理我们的动作。使用字符串常量并导出它们可以确保我们的reducers不会让一个打字错误悄悄溜走。此外，当处理较大的应用程序时，所有这些都可以抽象到一个<strong class="ky ir"> actionTypes.js </strong>文件中。之后，我们定义了两个<strong class="ky ir">动作</strong>。动作是JavaScript对象，为我们的Redux存储提供数据负载(在本例中来自我们的后端)。</p><p id="18ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稍后，我们将使用中间件，它根据对象是<em class="ls">函数</em>还是<em class="ls"> POJO </em>(普通的ol' JavaScript对象)这一前提来决定是进行更多的API调用还是进入下一步——reducers。<br/>为此，我们将定义<strong class="ky ir">动作创建者，</strong>我们的组件将<strong class="ky ir">分派</strong>哪些动作创建者从后端收集资源。<br/>在这些请求发出后，这些<strong class="ky ir">动作创建者</strong>将会<strong class="ky ir">分派</strong>我们的<strong class="ky ir">动作</strong>。然后<strong class="ky ir">reducer</strong>将过滤数据，并在我们的Redux存储中分配它的位置。</p><p id="3f4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，那么…让我们来定义这些动作创建者:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="0fb7" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/actions/session.js ---<br/></em><strong class="na ir">...<br/>export const login = user =&gt; async dispatch =&gt; {<br/>  const response = await apiUtil.login(user);<br/>  const data = await response.json();</strong></span><span id="246b" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">if (response.ok) {<br/>    return dispatch(receiveCurrentUser(data));<br/>  }<br/>  // todo: handle errors<br/>};</strong></span><span id="a85d" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export const signup = user =&gt; async dispatch =&gt; {<br/>  const response = await apiUtil.signup(user);<br/>  const data = await response.json();<br/>  <br/>  if (response.ok) {<br/>    return dispatch(receiveCurrentUser(data));<br/>  }<br/>  // todo: handle errors<br/>};</strong></span><span id="d734" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export const logout = () =&gt; async dispatch =&gt; {<br/>  const response = await apiUtil.logout();<br/>  const data = await response.json();</strong></span><span id="b3fd" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">if (response.ok) {<br/>    return dispatch(logoutCurrentUser());<br/>  }<br/>  // todo: handle errors<br/>};</strong></span></pre><p id="010a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这三个函数遵循相同的逻辑:返回一个异步函数，该函数将<strong class="ky ir"> dispatch </strong>作为参数，发出一个HTTP请求，并从响应中提取数据。<br/>如果响应没问题(200级)，调度一个<strong class="ky ir">动作</strong>我们上面定义的有效载荷。如果响应不正常，那么我们处理错误。这样想象会有所帮助:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="fe07" class="nf mb iq na b gy ng nh l ni nj">export const login = function(user) {<br/>  return async function(dispatch) {<br/>    ...<br/>  };<br/>};</span></pre><p id="808d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是因为我们是JavaScript专家，我们将保持它的ESNext。<br/>让我们迅速找到处理这些错误的方法。在我们的<strong class="ky ir"> actions/ </strong>文件夹中创建一个<strong class="ky ir"> error.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="5266" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/actions/error.js ---<br/></em><strong class="na ir">export const RECEIVE_ERRORS = 'RECEIVE_ERRORS';<br/>export const CLEAR_ERRORS = 'CLEAR_ERRORS';</strong></span><span id="5de0" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export const receiveErrors = ({ message }) =&gt; ({<br/>  type: RECEIVE_ERRORS,<br/>  message<br/>});</strong></span><span id="d2ed" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export const clearErrors = () =&gt; ({<br/>  type: CLEAR_ERRORS<br/>});</strong></span></pre><p id="4f98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样的模式。现在，回到我们的<strong class="ky ir">会话。js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="01e7" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/actions/session.js ---<br/></em>import * as apiUtil from ‘../util/session’;<strong class="na ir"><br/>import { receiveErrors } from "./error";<br/>...<br/></strong>if (response.ok) {<br/>    return dispatch(receiveCurrentUser(data));<br/>  }<strong class="na ir"><br/>  return dispatch(receiveErrors(data));</strong><br/>};<br/>...<br/>if (response.ok) {<br/>    return dispatch(receiveCurrentUser(data));<br/>  }<strong class="na ir"><br/>  return dispatch(receiveErrors(data));</strong><br/>};<br/>...<br/>if (response.ok) {<br/>    return dispatch(logoutCurrentUser());<br/>  }<strong class="na ir"><br/>  return dispatch(receiveErrors(data));<br/></strong>};</span></pre><p id="53f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的行动结束了！💪</p><p id="5a69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始我们的减速器！在<strong class="ky ir"> reducers/root.js </strong>中:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="6ed2" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/reducers/root.js ---<br/></em><strong class="na ir">import { combineReducers } from 'redux';<br/>import errors from './errors/errors';<br/>import session from './session/session';</strong></span><span id="a350" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export default combineReducers({<br/>  session,<br/>  errors<br/>});</strong></span></pre><p id="5cbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还没有创建我们的<strong class="ky ir">错误</strong>和<strong class="ky ir">会话</strong>减少器，但是<strong class="ky ir">组合减少器</strong>做了我们在这里所期望的事情。它结合了我们的减速器，将它们放在我们前端状态的<em class="ls">相同深度水平</em>。这些可以嵌套得更深，尽管嵌套太深的状态会产生代码味道。你经常会在这里看到一个<strong class="ky ir">实体</strong>缩减器，实体缩减器将会合并更多的缩减器，比如用户、帖子等等…</p><p id="0c0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们创建这两个减速器。让我们在<strong class="ky ir"> reducers/ </strong>中创建另一个<strong class="ky ir"> session.js </strong>文件:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="51c2" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/reducers/session/session.js ---<br/></em><strong class="na ir">import {<br/>  RECEIVE_CURRENT_USER,<br/>  LOGOUT_CURRENT_USER<br/>} from "../../actions/session";</strong></span><span id="1912" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const _nullSession = { userId: null, username: null }</strong><br/><strong class="na ir">export default (state = _nullSession, { type, user }) =&gt; {<br/>  Object.freeze(state);<br/>  switch (type) {<br/>    case RECEIVE_CURRENT_USER:<br/>      return user;<br/>    case LOGOUT_CURRENT_USER:<br/>      return _nullSession;<br/>    default:<br/>      return state;<br/>  }<br/>};</strong></span></pre><p id="dcfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们稍微讨论一下这个。<strong class="ky ir">缩减器</strong>是一个接受两个参数的函数——当前状态和动作。关于减速器我想指出三点:<br/> 1。它们进入<em class="ls">的状态并不是整个状态</em>。例如，<em class="ls">这个</em> <strong class="ky ir">会话</strong>减速器<em class="ls">不能</em>影响我们<strong class="ky ir">错误</strong>的状态形状或状态的任何其他部分。只有<strong class="ky ir">会话</strong>。<br/> 2。<em class="ls">每一个动作都击中每一个减速器</em>。这就是为什么所有的动作都有一个<strong class="ky ir">类型</strong>属性，以及为什么reducers使用switch语句。<br/> 3。<strong class="ky ir">千万不要突变状态。</strong> <em class="ls">永不突变的状态。</em>让Redux做它的事。</p><p id="5166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样一来，这里的代码就不会太差了。首先，我们导入动作类型。然后我们定义一个<strong class="ky ir"> _nullSession </strong>，这样我们就可以一直调用<strong class="ky ir">。用户名</strong>或<strong class="ky ir">。如果没有用户登录，就不会出错。<br/>接下来，我们给传入状态一个默认值——我们的空会话——并析构action对象。我们还冻结了状态，这防止了任何意外的突变，并让其他人知道他们正在使用我们的代码，“后退！”<br/>开个玩笑。但它清楚地表明。<br/>最后，根据动作<strong class="ky ir">类型</strong>，我们返回的代码可能会也可能不会改变我们的Redux存储。</strong></p><p id="adc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的误差减少器将非常相似。<strong class="ky ir">reducers/errors/errors . js</strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="f907" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/reducers/errors/errors.js ---<br/></em><strong class="na ir">import { RECEIVE_CURRENT_USER } from "../../actions/session";<br/>import { CLEAR_ERRORS, RECEIVE_ERRORS } from "../../actions/error";</strong></span><span id="9a7c" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export default (state = "", { message, type }) =&gt; {<br/>  Object.freeze(state);<br/>  switch (type) {<br/>    case RECEIVE_ERRORS:<br/>      return message;<br/>    case RECEIVE_CURRENT_USER:<br/>    case CLEAR_ERRORS:<br/>      return "";<br/>    default:<br/>      return state;<br/>  }<br/>};</strong></span></pre><p id="2e34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里唯一的区别是，当我们接收当前用户时，我们也会清除错误。这就是你经常会看到不同的动作触发状态的不同部分。</p><p id="aa87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唉，我们快满足Redux了… <br/>让我们创建我们的<strong class="ky ir"> store/store.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="2a52" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/store/store.js ---<br/></em><strong class="na ir">import { createStore, applyMiddleware } from "redux";<br/>import thunk from "redux-thunk";<br/>import reducer from "../reducers/root";</strong></span><span id="56ab" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export default preloadedState =&gt; (<br/>  createStore(<br/>    reducer,<br/>    preloadedState,<br/>    applyMiddleware(thunk)<br/>  )<br/>);</strong></span></pre><p id="27fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是将所有东西结合在一起的东西。<strong class="ky ir"> createStore </strong>，嗯，创建我们的Redux store，它包含我们精心制作的前端状态。Redux Thunk 是帮助我们简化异步操作的中间件。我们导出一个函数，它接受一个预加载状态作为参数，并返回我们的存储。这个<strong class="ky ir">预加载状态</strong>是我们保持用户登录的方式。</p><p id="38ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们通过前往我们的<strong class="ky ir"> index.js </strong>将Redux插入我们的应用程序:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="7900" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/index.js ---<br/></em>import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import App from './components/App';<br/><strong class="na ir">import configureStore from './store/store';<br/>import { Provider } from "react-redux";</strong></span><span id="2946" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">let preloadedState = {};<br/>const store = configureStore(preloadedState);</strong></span><span id="6215" class="nf mb iq na b gy np nh l ni nj">ReactDOM.render(<br/>  <strong class="na ir">&lt;Provider <em class="ls">store</em>={store}&gt;</strong><br/>    &lt;App /&gt;<br/><strong class="na ir">  &lt;/Provider&gt;,</strong><br/>  document.getElementById("root")<br/>);<br/><strong class="na ir"><em class="ls">// FOR TESTING, remove before production<br/></em>window.getState = store.getState;</strong></span></pre><p id="1194" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们导入我们在<strong class="ky ir"> store.js </strong>和<strong class="ky ir"> Provider </strong>中创建的函数。我们让预加载状态现在等于一个空对象，并定义我们的<strong class="ky ir">存储</strong>。通过将我们的<strong class="ky ir">应用</strong>包装在<strong class="ky ir">提供者</strong>中，并将<strong class="ky ir">商店</strong>作为道具传递，我们可以在应用的任何地方访问我们的Redux商店。<strong class="ky ir"> Props </strong>可以被认为是提供给组件的参数，因为它们是通过<strong class="ky ir"> prop </strong>对象访问的。<br/>最后，我们将<strong class="ky ir"> getState </strong>方法保存到窗口中，这样我们可以在控制台中看到我们的状态，然而对于更大的应用程序，我推荐<a class="ae kv" href="https://github.com/LogRocket/redux-logger" rel="noopener ugc nofollow" target="_blank"> redux-logger </a>。</p><p id="0de4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们前往<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>以确保一切仍然正常，并尝试我们的<strong class="ky ir"> getState </strong>函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/7bc437e8cbdc8c4918e8ed41568f92f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOH0S1I4-SfwRQTAUhk7aw.png"/></div></div></figure><p id="f2b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用谷歌Chrome开发者工具，<br/> Windows: <code class="fe mx my mz na b">CTRL-SHIFT-J</code>或<code class="fe mx my mz na b">F12</code> <br/> Mac: <code class="fe mx my mz na b">⌥-⌘-J</code>，<br/>我们可以看到我们的状态！</p><p id="b808" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redux现在准备好摇滚了！第6步到此结束！😅</p><h1 id="71be" class="ma mb iq bd mc md nk mf mg mh nl mj mk jw nm jx mm jz nn ka mo kc no kd mq mr bi translated">第七步:组件</h1><p id="3d26" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><strong class="ky ir">这是最后一步。我们的旅程即将结束。我们所要做的就是创建一些组件，为其中一些组件添加保护，并实现一种方法，让用户在刷新页面时保持登录。<br/>让我们从组件开始——总共有五个组件，包括<strong class="ky ir"> App.js </strong>。<br/>创建一个<strong class="ky ir">组件/Welcome.js </strong>:</strong></p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="bf49" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/components/Welcome.js ---<br/></em><strong class="na ir">import React from 'react';<br/>import { Link } from 'react-router-dom';</strong></span><span id="a78c" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export default () =&gt; (<br/>  &lt;&gt;<br/>    &lt;h1&gt;Welcome!&lt;/h1&gt;<br/>    &lt;Link to='/login'&gt;Login&lt;/Link&gt;<br/>    &lt;Link to='/signup'&gt;Signup&lt;/Link&gt;<br/>    &lt;Link to='/dashboard'&gt;Dashboard&lt;/Link&gt;<br/>  &lt;/&gt;<br/>);</strong></span></pre><p id="55c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一如既往，我们从进口开始。<strong class="ky ir"> Link </strong>除了其路径是绝对的之外，其行为就像一个锚标签。除此之外，我们使用另一个片段，添加一条欢迎消息和三个链接。很简单。<br/>接下来是<strong class="ky ir"> components/Signup.js </strong>。我把它分成三份:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="e5ae" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/components/Signup.js ---<br/></em><strong class="na ir">import React from "react";<br/>import { connect } from "react-redux";<br/>import { Link } from "react-router-dom";<br/>import { signup } from "../actions/session";</strong></span><span id="465c" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const mapStateToProps = ({ errors }) =&gt; ({<br/>  errors<br/>});</strong></span><span id="2028" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const mapDispatchToProps = dispatch =&gt; ({<br/>  signup: user =&gt; dispatch(signup(user))</strong><br/><strong class="na ir">});<br/>.</strong>..</span></pre><p id="844e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们进口中唯一的新来者是<strong class="ky ir">通。这个函数将允许我们的组件访问我们的Redux存储。我们接着定义两个函数:<br/><strong class="ky ir">mapStateToProps</strong>；这将<strong class="ky ir">状态</strong>作为一个参数，并让我们的组件访问Redux存储的特定部分(在本例中是我们的错误)。<br/><strong class="ky ir">mapdispatctoprops</strong>；这将<strong class="ky ir">分派</strong>作为一个参数，并赋予我们的组件分派我们之前定义的<strong class="ky ir">动作</strong>的能力。<br/>我们继续:</strong></p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="06cf" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/components/Signup.js ---<br/></em>...<br/><strong class="na ir">const Signup = ({ errors, signup }) =&gt; {<br/>  const handleSubmit = e =&gt; {<br/>    e.preventDefault();<br/>    const user = {<br/>      username: e.target[0].value,<br/>      email: e.target[1].value,<br/>      password: e.target[2].value<br/>    };<br/>    signup(user);<br/>  };</strong></span><span id="a17a" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Signup&lt;/h1&gt;<br/>      &lt;p&gt;{errors}&lt;/p&gt;<br/>      &lt;form onSubmit={handleSubmit}&gt;<br/>        &lt;label&gt;<br/>          Username:<br/>          &lt;input type="text" name="username" /&gt;<br/>        &lt;/label&gt;<br/>        &lt;label&gt;<br/>          Email:<br/>          &lt;input type="email" name="email" /&gt;<br/>        &lt;/label&gt;<br/>        &lt;label&gt;<br/>          Password:<br/>          &lt;input type="password" name="password" /&gt;<br/>        &lt;/label&gt;<br/>        &lt;input type="submit" value="Submit" /&gt;<br/>      &lt;/form&gt;<br/>      &lt;Link to="/login"&gt;Login&lt;/Link&gt;<br/>    &lt;/&gt;<br/>    );<br/>  };</strong><br/>...</span></pre><p id="e2df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来有点可怕，但这里并没有发生太多的事情。这是我们在这个文件中实际的<strong class="ky ir">组件</strong>。首先，我们接受<strong class="ky ir">道具</strong>作为参数，并析构我们需要的东西。这些来自于<strong class="ky ir">mapStateToProps</strong>/<strong class="ky ir">mapDispatchToProps。</strong> <br/>接下来，我们创建一个提交处理函数，其中“<strong class="ky ir">e</strong>”<strong class="ky ir"/>是事件对象。我们阻止默认行为(刷新页面)，通过从表单中提取输入值来创建一个<strong class="ky ir">用户</strong>对象，并调用我们的<strong class="ky ir">登录</strong>函数。<br/>通常，你会想要一个<a class="ae kv" href="https://reactjs.org/docs/forms.html#controlled-components" rel="noopener ugc nofollow" target="_blank">受控组件</a>在这里，但是我们保持事情简单。<br/>最后，我们归还我们的JSX。在这种情况下，它只是一个标题、我们的错误*、一个表单和另一个链接。*这些是来自我们Redux商店的错误。如果没有，React不会渲染任何东西。花括号是我们在组件返回语句中添加JavaScript代码的方式。<br/>注意到<code class="fe mx my mz na b">&lt;form onSubmit={handleSubmit}&gt;</code>？这将在我们的表单上放置一个<strong class="ky ir"> onsubmit </strong>事件，传递我们在上面定义的函数作为回调。<br/>最后一点:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="82ee" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/components/Signup.js ---<br/></em>...<br/><strong class="na ir">export default connect(<br/>  mapStateToProps,<br/>  mapDispatchToProps<br/>)(Signup);</strong></span></pre><p id="e46c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是连接是如何发生的。这里我们将我们的<strong class="ky ir">注册</strong>组件“连接”到Redux商店。</p><p id="b78e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们创建我们的<strong class="ky ir">组件/Login.js </strong>文件:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="f6b1" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/components/Login.js ---<br/></em><strong class="na ir">import React from "react";<br/>import { connect } from "react-redux";<br/>import { Link } from "react-router-dom";<br/>import { login } from "../actions/session";</strong></span><span id="43bc" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const mapStateToProps = ({ errors }) =&gt; ({<br/>  errors<br/>});</strong></span><span id="5356" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const mapDispatchToProps = dispatch =&gt; ({<br/>  login: user =&gt; dispatch(login(user))<br/>});</strong></span><span id="d624" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const Login = ({ errors, login }) =&gt; {<br/>  const handleSubmit = e =&gt; {<br/>    e.preventDefault();<br/>    const user = {<br/>      email: e.target[0].value,<br/>      password: e.target[1].value,<br/>    };<br/>    login(user);<br/>  }</strong></span><span id="f47c" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Login&lt;/h1&gt;<br/>      &lt;p&gt;{errors}&lt;/p&gt;<br/>      &lt;form onSubmit={handleSubmit}&gt;<br/>        &lt;label&gt;<br/>          Email:<br/>          &lt;input type="email" name="email" /&gt;<br/>        &lt;/label&gt;<br/>        &lt;label&gt;<br/>          Password:<br/>          &lt;input type="password" name="password" /&gt;<br/>        &lt;/label&gt;<br/>        &lt;input type="submit" value="Submit" /&gt;<br/>      &lt;/form&gt;<br/>      &lt;Link to="/signup"&gt;Signup&lt;/Link&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</strong></span><span id="3ede" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export default connect(<br/>  mapStateToProps,<br/>  mapDispatchToProps<br/>)(Login);</strong></span></pre><p id="3da3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里唯一的不同是我们导入了<strong class="ky ir">登录</strong>而不是注册，并且少了一个表单字段。</p><p id="6fa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干得好！<br/>让我们继续我们的<strong class="ky ir">组件/Dashboard.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="4882" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/components/Dashboard.js ---<br/></em><strong class="na ir">import React from "react";<br/>import { connect } from "react-redux";<br/>import { logout } from "../actions/session";</strong></span><span id="0b57" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const mapStateToProps = ({ session }) =&gt; ({<br/>  session<br/>});</strong></span><span id="5e1a" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const mapDispatchToProps = dispatch =&gt; ({<br/>  logout: () =&gt; dispatch(logout())<br/>});</strong></span><span id="1173" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const Dashboard = ({ logout, session }) =&gt; (<br/>  &lt;&gt;<br/>    &lt;h1&gt;Hi {session.username}&lt;/h1&gt;<br/>    &lt;p&gt;You are now logged in!&lt;/p&gt;<br/>    &lt;button onClick={logout}&gt;Logout&lt;/button&gt;<br/>  &lt;/&gt;<br/>);</strong></span><span id="804a" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export default connect(<br/>  mapStateToProps,<br/>  mapDispatchToProps<br/>)(Dashboard);</strong></span></pre><p id="e96e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意到模式了吗？我们做同样的事情映射状态和分派到道具和连接我们的组件在底部。我们使用会话信息通过用户名问候用户，并添加一个按钮让用户注销。</p><p id="b558" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们更新我们的<strong class="ky ir"> App.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="a5d4" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/components/App.js ---<br/></em>import React from "react";<strong class="na ir"><br/>import { Route } from "react-router-dom";<br/>import Welcome from "./Welcome";<br/>import Login from "./Login";<br/>import Signup from "./Signup";<br/>import Dashboard from "./Dashboard";</strong></span><span id="5a39" class="nf mb iq na b gy np nh l ni nj">export default () =&gt; (<br/>  &lt;&gt;<strong class="na ir"><br/>    &lt;Route exact path="/" component={Welcome} /&gt;<br/>    &lt;Route path="/login" component={Login} /&gt;<br/>    &lt;Route path="/signup" component={Signup} /&gt;<br/>    &lt;Route path="/dashboard" component={Dashboard} /&gt;<br/></strong>  &lt;/&gt;<br/>);</span></pre><p id="6032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🤔嗯，我们进口我们的组件，但这是什么<strong class="ky ir">路线</strong>的事情？当URL与<strong class="ky ir">路径</strong>匹配时，<strong class="ky ir">路由</strong>组件接受一个<strong class="ky ir">组件</strong>属性。“<strong class="ky ir"> exact </strong>”标志指定路径必须完全是“/”。如果没有这个，我们的<strong class="ky ir"> Welcome </strong>组件将在每个页面上呈现，因为所有路径都以“/”开头。(这可能对<strong class="ky ir">导航</strong>组件有用！)</p><p id="d4ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，为了使用<strong class="ky ir">路径</strong>，我们必须将<strong class="ky ir">应用</strong>包装在其中，就像我们对<strong class="ky ir">提供者</strong>所做的那样:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="9609" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/index.js ---<br/>...<br/></em><strong class="na ir">import { BrowserRouter } from "react-router-dom";</strong><br/><em class="ls">...</em><br/>ReactDOM.render(<br/>  &lt;Provider <em class="ls">store</em>={store}&gt;<br/>    <strong class="na ir">&lt;BrowserRouter&gt;</strong><br/>      &lt;App /&gt;<br/>    <strong class="na ir">&lt;/BrowserRouter&gt;</strong><br/><strong class="na ir">  </strong>&lt;/Provider&gt;,<br/>  document.getElementById("root")<br/>);<br/><strong class="na ir"><em class="ls">...</em></strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/31d7606d1cc0ae2eb07b2b8036d1eeee.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*mWSslG0KhNUBRzI7A9GZKg.png"/></div></figure><p id="305f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在浏览器中测试，我们可以看到我们的路线和网页的工作。让我们测试一下我们的错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/243d0b3f7a1a50547e30213d33d3756b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVWdE9lI7ZvtViGx-A3MeQ.png"/></div></div></figure><p id="4d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不错！好吧，如果我试着注册呢？似乎什么都没发生…还是真的发生了？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/82dfa6a2bb0191599970b9097f2a8c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*513sJ4nwr8DE1FvAL2LnbQ.png"/></div></div></figure><p id="da9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在Chrome控制台中再次查看我们的状态，我们可以看到它确实让用户登录了。如果我们看看我们的饼干:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/692fa2d30d4596a7fdae5bec720cbf7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nydt9b7x_B1ch6fbH7OneA.png"/></div></div></figure><p id="c6e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用的是<a class="ae kv" href="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg?hl=en" rel="noopener ugc nofollow" target="_blank"> Edit This Cookie </a> Chrome扩展，但这也可以使用Chrome开发者工具查看。<br/>我们看到我们的饼干在那里！</p><p id="d181" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我导航到仪表板(通过手动键入URL)并注销，cookie就会消失。我们的后端工作！<br/>但是我们的网站有点问题……<br/>让我们来解决这个问题。</p><p id="42a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的下一步是创建<strong class="ky ir">保护路由</strong>和<strong class="ky ir">授权路由</strong>。受保护的路由将不允许已注销的用户访问它们，并将它们重定向到登录页面。授权路由将不允许已登录的用户访问登录/注册页面。如果有，我们会将它们重定向到仪表板。从概念上讲，这听起来很简单，但是这里的代码有点复杂。别担心，我们已经到了最后关头，现在我们不能放弃！让我们开始吧。在您的<strong class="ky ir"> util/ </strong>文件夹中创建一个<strong class="ky ir"> route.js </strong>文件:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="db87" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/util/route.js ---<br/></em><strong class="na ir">import React from "react";<br/>import { connect } from "react-redux";<br/>import { Redirect, Route, withRouter } from "react-router-dom";</strong></span><span id="8c9a" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const mapStateToProps = ({ session: { userId} }) =&gt; ({<br/>  loggedIn: Boolean(userId)<br/>});<br/>...</strong></span></pre><p id="c7a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还没有太疯狂的事。我们的导入中的两个新成员是<strong class="ky ir">重定向</strong>和<strong class="ky ir">带路由器</strong>。第一个简单地重定向到我们选择的URL。第二个就像<strong class="ky ir"> connect </strong>一样使用，除了它为我们的组件提供了与路线/参数/位置等相关的有用属性。我们不会使用这些属性中的任何一个，但是我在这里添加了<strong class="ky ir"> withRouter </strong>,因为理想情况下，我们希望在我们的应用程序中使用该功能。接下来，我们去拜访我们的好朋友。我们深度地析构了我们的状态对象，并提供了一个简单地回答这个问题的道具，“我们登录了吗？”让我们继续:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="61ec" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/util/route.js ---<br/>...<br/></em><strong class="na ir">const Auth = ({ loggedIn, path, component: Component }) =&gt; (<br/>  &lt;Route<br/>    path={path}<br/>    render={props =&gt; (<br/>      loggedIn ?<br/>      &lt;Redirect to='/dashboard' /&gt; :<br/>      &lt;Component {...props} /&gt;<br/>    )}<br/>  /&gt;<br/>);</strong></span><span id="f7bc" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const Protected = ({ loggedIn, path, component: Component }) =&gt; (<br/>  &lt;Route<br/>    path={path}<br/>    render={props =&gt; (<br/>      loggedIn ?<br/>      &lt;Component {...props} /&gt; :<br/>      &lt;Redirect to='/login' /&gt;<br/>    )}<br/>  /&gt;<br/>);</strong><br/><em class="ls">...</em></span></pre><p id="6d99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从语法上来说，我已经尽可能地让它可读性更好。这两个功能几乎相同——唯一的区别是<strong class="ky ir">重定向</strong>。<br/>我们来分解一下。在高层次上，这些只是隐式返回一个<strong class="ky ir"> Route </strong>组件的组件，该组件可能呈现另一个组件或重定向。我们从破坏我们的道具开始。需要<code class="fe mx my mz na b">component: Component</code>以便React知道这是作为道具出现的整个组件。<br/>接下来，我们通过使用我们提供的路径建立我们的<strong class="ky ir">路线</strong>。<br/>然后，我们不使用<code class="fe mx my mz na b">component={SomeComponent}</code>，而是使用<strong class="ky ir"> render </strong> prop，它允许我们提供一个匿名函数，该函数使用三元组来显示我们的组件或重定向。<br/>我们还利用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展操作符</a>将我们的道具传递给渲染组件。还有一步:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="bf7a" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/util/route.js ---<br/>...<br/></em><strong class="na ir">export const AuthRoute = withRouter(<br/>  connect(mapStateToProps)(Auth)<br/>);</strong></span><span id="8e95" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">export const ProtectedRoute = withRouter(<br/>  connect(mapStateToProps)(Protected)<br/>);</strong></span></pre><p id="b7cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们用路由器和<strong class="ky ir">连接</strong>这些组件来包装<strong class="ky ir">中的所有东西。<br/>现在回到我们的<strong class="ky ir"> App.js </strong>:</strong></p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="84cc" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/util/routes.js ---<br/>...<br/></em><strong class="na ir">import { AuthRoute, ProtectedRoute } from "../util/route";</strong></span><span id="98c8" class="nf mb iq na b gy np nh l ni nj">export default () =&gt; (<br/>  &lt;&gt;<br/>    &lt;Route exact path="/" component={Welcome} /&gt;<strong class="na ir"><br/>    &lt;AuthRoute path="/login" component={Login} /&gt;<br/>    &lt;AuthRoute path="/signup" component={Signup} /&gt;<br/>    &lt;ProtectedRoute path="/dashboard" component={Dashboard} /&gt;</strong><br/>  &lt;/&gt;<br/>);</span></pre><p id="2cc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意到它们有多容易使用了吗？我们可以像使用普通路线一样使用它们！此外，现在我们总是有这些在我们的处置。</p><p id="af25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在去<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>测试一下。如果一切顺利，你应该不能访问仪表板。<br/>甜！还有一件事要做——而且很简单！</p><p id="84f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的<strong class="ky ir"> util/session.js </strong>中，让我们再添加一个函数:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="3d87" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/util/session.js ---<br/>...<br/></em><strong class="na ir">export const checkLoggedIn = async preloadedState =&gt; {<br/>  const response = await fetch('/api/session');<br/>  const { user } = await response.json();<br/>  let preloadedState = {};</strong><br/>  <strong class="na ir">if (user) {<br/>    preloadedState = {<br/>      session: user<br/>    };<br/>  }<br/>  return preloadedState;<br/>};</strong></span></pre><p id="6355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们点击最后一个API端点来检查会话是否存在。<br/>现在在我们的<strong class="ky ir"> src/index.js </strong>:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="fb8e" class="nf mb iq na b gy ng nh l ni nj"><em class="ls">--- frontend/src/index.js ---<br/>...<br/></em><strong class="na ir">import { checkLoggedIn } from "./util/session";</strong></span><span id="315e" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">const renderApp = preloadedState =&gt; {<br/>  const store = configureStore(preloadedState);<br/>  ReactDOM.render(<br/>    &lt;Provider store={store}&gt;<br/>      &lt;BrowserRouter&gt;<br/>        &lt;App /&gt;<br/>      &lt;/BrowserRouter&gt;<br/>    &lt;/Provider&gt;,<br/>    document.getElementById("root")<br/>  );<br/>};</strong></span><span id="8a77" class="nf mb iq na b gy np nh l ni nj"><strong class="na ir">(async () =&gt; renderApp(<em class="ls">await</em> checkLoggedIn()))();</strong></span></pre><p id="1748" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将与渲染我们的<strong class="ky ir">应用</strong>相关的一切封装到一个函数中。然后我们使用另一个生命，就像我们在我们的服务器中所做的一样。使用<strong class="ky ir"> checkLoggedIn </strong>的返回值，我们的<strong class="ky ir"> renderApp </strong>函数拥有启动我们的应用程序所需的一切。<br/>不过说够了，我们来测试一下吧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/788ccfaf7235d3dd7713c1260dbcbf1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*7Kn61eRASJ8q0SqfeOY03Q.png"/></div></div></figure><p id="8fad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">登录后，我们被自动重定向到仪表板(因为登录/注册页面是<strong class="ky ir"> AuthRoute </strong> s)。</p><p id="cc9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以刷新并保持登录状态！</p><p id="75b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注销后，我们会被自动重定向到登录页面(因为仪表板页面是一个<strong class="ky ir">受保护的路由</strong>)。我们的控制台没有错误、红灯或故障，一切都运行顺利。</p><h1 id="50c4" class="ma mb iq bd mc md nk mf mg mh nl mj mk jw nm jx mm jz nn ka mo kc no kd mq mr bi translated">🏆任务已完成🏆</h1><p id="ca78" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我知道这篇文章很长，而且这是我第一次在网上写东西，但是我真的很享受这种体验。当然，最重要的是，我希望你喜欢这个！</p><p id="7306" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次见！</p><p id="e976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/christiancashiola/SessionAuth" rel="noopener ugc nofollow" target="_blank">在GitHub上查看代码库。</a> <br/> <a class="ae kv" href="http://christiancashiola.me/" rel="noopener ugc nofollow" target="_blank">更多关于我。</a></p></div></div>    
</body>
</html>