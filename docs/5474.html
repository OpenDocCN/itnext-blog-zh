<html>
<head>
<title>[V8 Deep Dives] Understanding Array Internals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[V8深度探讨]了解阵列内部</h1>
<blockquote>原文：<a href="https://itnext.io/v8-deep-dives-understanding-array-internals-5b17d7a28ecc?source=collection_archive---------0-----------------------#2021-03-15">https://itnext.io/v8-deep-dives-understanding-array-internals-5b17d7a28ecc?source=collection_archive---------0-----------------------#2021-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/20f1d990f4e7bf84d1060fc3deb61d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D4kbOK4Q7catQuwa"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@angarav?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Antonio Garcia </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3693" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本系列的前一部分中，我们讨论了ES6中引入的标准集合Map和Set。这一次我们将关注JavaScript数组。</p><p id="37fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组本质上是类似列表的对象，是该语言的核心特性之一，每个JavaScript开发人员都有使用它们的丰富经验。这篇博客文章并不试图让您理解公共API，而是旨在简要介绍V8内部JS数组实现的各个方面，这些方面对我来说很有价值:内存布局、大小限制和其他有趣的实现细节。</p><p id="bcb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简单起见，博文的剩余部分假设V8运行在64位系统上。</p><p id="cc81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TL；博士的粉丝可能想跳到博客文章的最后一部分，在那里你可能会找到一个摘要。</p><p id="bcd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">免责声明。下面写的是特定于V8 8.9的实现细节，捆绑了Node.js的最新开发版本(更准确地说是<a class="ae kc" href="https://github.com/nodejs/node/commit/49342fe6f2ca6cedd5219d835a0a810e6f03cdd7" rel="noopener ugc nofollow" target="_blank"> commit 49342fe </a>)。像往常一样，您不应该期望任何超出规范的行为，因为实现细节在任何V8版本中都可能发生变化。</strong></p><h2 id="0a2c" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">从前在REPL</h2><p id="c521" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">您可能会问自己:什么可能比JavaScript数组更简单？它必须由一个固定大小的数组支持，即一个连续的内存块。所有操作都应该是对存储在底层数组中的数据的直接操作。但是正如我们将在后面看到的，现实比这要复杂一些。</p><p id="aaa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更实际，我们将观察一个<a class="ae kc" href="https://nodejs.org/api/repl.html" rel="noopener ugc nofollow" target="_blank"> Node.js REPL </a>中数组的内部转换。更少的单词，更多的代码，让我们运行它:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0312" class="lb lc iq me b gy mi mj l mk ml">$ node --allow-natives-syntax</span><span id="281d" class="lb lc iq me b gy mm mj l mk ml">Welcome to Node.js v16.0.0-pre.</span><span id="798b" class="lb lc iq me b gy mm mj l mk ml">Type “.help” for more information.</span><span id="f946" class="lb lc iq me b gy mm mj l mk ml">&gt;</span></pre><p id="9c09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe mn mo mp me b">--allow-natives-syntax</code>标志来使用<code class="fe mn mo mp me b">%DebugPrint()</code> V8函数。这个函数打印给定对象或原始值的内部调试信息。</p><p id="3157" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们创建一个空数组并打印它的调试信息:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8eb8" class="lb lc iq me b gy mi mj l mk ml">&gt; const arr = [];<br/>undefined<br/>&gt; %DebugPrint(arr);<br/>DebugPrint: 0x3db6370d4e51: [JSArray]<br/> - map: 0x3de594a433f9 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]<br/> - prototype: 0x3a5538d05849 &lt;JSArray[0]&gt;<br/> - elements: 0x357222481309 &lt;FixedArray[0]&gt; [PACKED_SMI_ELEMENTS]<br/> - length: 0<br/> - properties: 0x357222481309 &lt;FixedArray[0]&gt;<br/> - All own properties (excluding elements): {<br/>    0x357222484909: [String] in ReadOnlySpace: #length: 0x0f4cc91c1189 &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor<br/> }<br/>...</span><span id="00b2" class="lb lc iq me b gy mm mj l mk ml">[]</span></pre><p id="02ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初的输出相当冗长，所以我对它进行了删减。我们感兴趣的是输出的<code class="fe mn mo mp me b">- elements: ... &lt;FixedArray[0]&gt; [PACKED_SMI_ELEMENTS]</code>部分。它告诉我们，我们的数组使用一个<a class="ae kc" href="https://github.com/nodejs/node/blob/49342fe6f2ca6cedd5219d835a0a810e6f03cdd7/deps/v8/src/objects/fixed-array.h#L99" rel="noopener ugc nofollow" target="_blank">固定大小的数组</a>来存储数据(V8对此使用“后备存储”术语)，正如我们所预期的那样。该数组的大小为零。</p><p id="c0bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调试输出还告诉我们，我们的JS数组具有PACKED_SMI_ELEMENTS元素类型。元素种类是V8跟踪的元数据，用于优化数组操作。它描述了存储在数组中的元素的类型。如果你不熟悉这个概念，你应该读一读V8团队的这篇伟大的<a class="ae kc" href="https://v8.dev/blog/elements-kinds" rel="noopener ugc nofollow" target="_blank">博客文章</a>。</p><p id="2dbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PACKED_SMI_ELEMENTS是最特殊的元素类型，这意味着数组中的所有元素都是从-2到2 -1范围内的小整数。基于这些元数据，V8可以在处理数组时避免不必要的检查和值转换。对我们来说，另一个重要方面如下。当一个JS数组被修改时，它的元素种类可能会从一个更具体的种类转变为一个不太具体的种类，而不是相反。例如，如果数组的元素类型由于插入而从PACKED_SMI_ELEMENTS更改为其他类型，那么对于这个特定的数组实例，就没有办法返回到原始的(更具体的)类型。</p><p id="b842" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了查看内部数组是如何增长的，我们将添加它的第一个元素，一个小整数:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7fc1" class="lb lc iq me b gy mi mj l mk ml">&gt; arr.push(42);<br/>&gt; %DebugPrint(arr);<br/>DebugPrint: 0xe61bd5eb321: [JSArray] in OldSpace<br/>...<br/> - elements: 0x0e61bd5e7501 &lt;FixedArray[17]&gt; [PACKED_SMI_ELEMENTS]<br/> - length: 1<br/>...<br/> - elements: 0x0e61bd5e7501 &lt;FixedArray[17]&gt; {<br/>           0: 42<br/>        1-16: 0x357222481669 &lt;the_hole&gt;<br/> }<br/>...</span><span id="e785" class="lb lc iq me b gy mm mj l mk ml">[ 42 ]</span></pre><p id="dd2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们看到用作后备存储的内部数组已经更改为<code class="fe mn mo mp me b">&lt;FixedArray[17]&gt; [PACKED_SMI_ELEMENTS]</code>。新数组具有相同的元素种类，但地址不同，内部数组大小等于17。在我们的64位系统上，这意味着它需要17 * 8=136字节的内存(为了简单起见，我们忽略对象头)。这也意味着分配的内部数组比我们请求的要大。这允许V8对于增长数组的<code class="fe mn mo mp me b">push()</code>和类似操作实现恒定的<a class="ae kc" href="https://en.wikipedia.org/wiki/Amortized_analysis#Dynamic_array" rel="noopener ugc nofollow" target="_blank">摊销时间</a>。下面的<a class="ae kc" href="https://github.com/nodejs/node/blob/49342fe6f2ca6cedd5219d835a0a810e6f03cdd7/deps/v8/src/objects/js-objects.h#L542" rel="noopener ugc nofollow" target="_blank">公式</a>用于在内部数组不足的情况下确定新的大小:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0abf" class="lb lc iq me b gy mi mj l mk ml">new_capacity = (old_capacity + 50%) + 16</span></pre><p id="0d1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，<code class="fe mn mo mp me b">old_capacity</code>代表旧的内部数组大小加上插入项的数量，因此在我们的例子中它等于1，而<code class="fe mn mo mp me b">new_capacity</code>被计算为1 + 16 = 17。</p><p id="6e1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的输出中还有一个更有趣的细节。也就是说，数组内容中的<code class="fe mn mo mp me b">1-16: ... &lt;the_hole&gt;</code>文本告诉我们，内部数组中未使用的部分被“洞”填满了。这个洞是一个特殊的值，V8使用它来标记未分配或已删除的数组项(不仅仅是它们)。这是一个永远不会“泄露”到JS代码中的实现细节。在我们的例子中，V8使用这个洞来初始化数组中未使用的部分。</p><p id="c90a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能想知道内部数组是否会收缩。在减少数组长度的操作中，如<code class="fe mn mo mp me b">pop()</code>或<code class="fe mn mo mp me b">shift()</code>，它似乎确实会收缩。如果超过一半的元素(对于小数组有一些填充)不会被用作操作的结果，就会发生这种情况。</p><p id="5fe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到我们的REPL会话，我们的数组中的PACKED_SMI_ELEMENTS类型假设没有漏洞，但是如果我们以某种方式改变它，该类型将转换为一个不太具体的类型。让我们开始吧:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e64d" class="lb lc iq me b gy mi mj l mk ml">&gt; arr[2] = 0;<br/>&gt; %DebugPrint(arr);<br/>...<br/> - elements: 0x0e61bd5e7501 &lt;FixedArray[17]&gt; [HOLEY_SMI_ELEMENTS]<br/> - length: 3<br/>...<br/> - elements: 0x0e61bd5e7501 &lt;FixedArray[17]&gt; {<br/>           0: 42<br/>           1: 0x357222481669 &lt;the_hole&gt;<br/>           2: 0<br/>        3-16: 0x357222481669 &lt;the_hole&gt;<br/> }</span></pre><p id="ceb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们指定了数组的第二项，跳过了包含洞的第一项。因此，数组的元素种类转换为HOLEY_SMI_ELEMENTS。这种类型假设数组只包含SMI或holey值。就性能而言，这种元素比压缩元素稍慢，因为V8在迭代数组或修改数组时必须执行值检查以跳过漏洞。</p><p id="3e25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不打算用数组支持的其他元素种类做进一步的实验。这是留给好奇读者的一个练习。然而，提到V8优化64位浮点数的数组是有意义的:PACKED_DOUBLE_ELEMENTS和HOLEY_DOUBLE_ELEMENTS类型在后备数组中存储数字，避免每个数字的堆上指针。</p><p id="c751" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步我们感兴趣的是知道用于数组项的后备存储是否可以不同于固定大小的数组。让我们在REPL会议上再做一个实验:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f177" class="lb lc iq me b gy mi mj l mk ml">&gt; arr[32 &lt;&lt; 20] = 0;<br/>&gt; %DebugPrint(arr);<br/>...<br/> - elements: 0x10f6026db0d9 &lt;NumberDictionary[16]&gt; [DICTIONARY_ELEMENTS]<br/> - length: 33554433<br/>...<br/> - elements: 0x10f6026db0d9 &lt;NumberDictionary[16]&gt; {<br/>   - max_number_key: 33554432<br/>   2: 0 (data, dict_index: 0, attrs: [WEC])<br/>   0: 42 (data, dict_index: 0, attrs: [WEC])<br/>   33554432: 0 (data, dict_index: 0, attrs: [WEC])<br/> }<br/>...</span></pre><p id="6fcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">刚刚发生了什么？我们的数组不再使用基于数组的后备存储，取而代之的是使用一个<code class="fe mn mo mp me b">NumberDictionary[16]</code>，它是一个基于散列表的<a class="ae kc" href="https://github.com/nodejs/node/blob/49342fe6f2ca6cedd5219d835a0a810e6f03cdd7/deps/v8/src/objects/dictionary.h#L301" rel="noopener ugc nofollow" target="_blank">集合</a>，专门用于数字键。如果您对其他细节感兴趣，散列表使用<a class="ae kc" href="https://en.wikipedia.org/wiki/Hash_table#Open_addressing" rel="noopener ugc nofollow" target="_blank">开放寻址</a>和二次探测。</p><p id="d4e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">元素种类也转变为DICTIONARY_ELEMENTS，这意味着JS数组的“慢”路径。通过这种方式，V8旨在减少有很多孔的稀疏数组的内存占用，因为哈希表只存储非孔数组元素。另一方面，哈希表操作比数组慢，因为我们需要支付哈希代码计算、条目查找和重新哈希的成本。稍后，我们将进行一些微基准测试来了解成本。</p><p id="36ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">dictionary类型用于大于某个阈值的数组，所以这就是为什么我们的数组在达到极限<a class="ae kc" href="https://github.com/nodejs/node/blob/49342fe6f2ca6cedd5219d835a0a810e6f03cdd7/deps/v8/src/objects/js-array.h#L120" rel="noopener ugc nofollow" target="_blank">时会转换成这种类型。就内存而言，这意味着一个数组烘焙的JS数组不能超过268MB。</a></p><p id="64aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至于基于字典的数组，它们的最大大小受到<a class="ae kc" href="https://262.ecma-international.org/11.0/#sec-arraycreate" rel="noopener ugc nofollow" target="_blank"> ECMAScript规范</a>的限制，不能超过32位无符号整数(2 — 1)的最大值。</p><p id="9b5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了。现在，当我们对V8如何处理JS数组有了更好的理解后，让我们做一些基准测试。</p><h2 id="bf0e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">一些愚蠢的基准</h2><p id="9a86" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在我们进一步讨论之前，我需要警告你，下面的微基准是完全不科学的，不公平的基准，所以要有所保留。基准测试是在我的开发机器上完成的，使用i5–8400h CPU、Ubuntu 20.04和Node.js v15.11.0。</p><p id="e204" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们试着理解不同元素种类在数组迭代方面的区别。在第一个基准测试的<a class="ae kc" href="https://github.com/puzpuzpuz/microbenchmarks/blob/91672594d559f8c3dca69cc0a9241309bc6a7467/src/dictionary-array-iteration.js" rel="noopener ugc nofollow" target="_blank">中，我们迭代一个数字数组，并简单地计算其元素的总和。结果如下所示。</a></p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/eba8750e6edb848510929debd09e57db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XZzd8QAAZnuOYb4G"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">数组迭代基准测试结果。</figcaption></figure><p id="065e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，字典类的结果几乎看不出来，因为它比打包类的结果小两个数量级(注意:事实上，<a class="ae kc" href="https://medium.com/p/90035b3325f9" rel="noopener">这里的差异</a>是一个数量级，这仍然很多)。至于有孔的那种，只比打包的慢23%。</p><p id="0e06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们对基本的变异操作进行一些测量，比如<code class="fe mn mo mp me b">push() </code>和<code class="fe mn mo mp me b">pop()</code>。在第二个基准测试中，我们将1K个元素放入数组，然后在每次迭代中取出所有元素。结果如下。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/c2a092fcbaaa5606c3c6d9fc2922bc85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kqmdvh2nC4UfHc-i"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">推送/弹出基准测试结果。</figcaption></figure><p id="91f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次，字典类的结果甚至是不可见的(是的，我不擅长数据可视化)，因为对于基于数组的类型，它是每秒大约200对大约238K的操作。</p><p id="3a83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是，如果我们用<code class="fe mn mo mp me b"><a class="ae kc" href="https://v8.dev/blog/jitless" rel="noopener ugc nofollow" target="_blank">--jitless</a></code> <a class="ae kc" href="https://v8.dev/blog/jitless" rel="noopener ugc nofollow" target="_blank">标志</a>禁用V8中的JIT，结果变成每秒大约200次对大约16K次操作。这清楚地显示了V8的JIT编译器在优化基于数组的循环方面有多好。</p><p id="3a4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然绝对数字并不重要，但是上面的结果说明了JS应用程序应该避免处理基于字典的数组，除非绝对必须这样做。</p><p id="462a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是时候总结并列出我们今天的发现了。</p><h2 id="e687" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">摘要</h2><ul class=""><li id="eee0" class="mr ms iq kf b kg lu kk lv ko mt ks mu kw mv la mw mx my mz bi translated">每个JS数组都与一种元素相关联，V8跟踪元数据以优化数组操作。这些种类描述了存储在数组中的元素的类型。</li><li id="3806" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated">足够小的数组的元素存储在一个内部固定大小的数组中。V8在内部数组中分配一些额外的空间，以便为<code class="fe mn mo mp me b">push()</code>和类似的增长数组的操作实现恒定的摊销时间。当数组长度减少时，内部数组也可能收缩。</li><li id="a1bb" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated">一旦JS数组变大(这也包括多孔数组)，V8就开始使用哈希表来存储数组元素。该数组现在与“慢速”字典元素类型相关联。</li><li id="f1c7" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated">对于热循环，“慢”类型可能比基于数组的类型慢几个数量级。</li><li id="cb36" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated">V8的JIT编译器擅长为基于数组的类型优化循环。</li><li id="566f" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated">通常，当编写在热路径上操作大型数组的代码时，您应该让V8为您的数组使用最特定的元素种类。</li></ul><p id="3db0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢你阅读这篇文章。如果你对V8深潜系列的下一篇文章有想法，请告诉我。关于不一致或不正确假设的反馈也非常受欢迎。</p></div></div>    
</body>
</html>