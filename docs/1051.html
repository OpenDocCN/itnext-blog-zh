<html>
<head>
<title>How to Make Legacy Code Reactive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使遗留代码具有反应性</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-make-legacy-code-reactive-2debcb3d0a40?source=collection_archive---------0-----------------------#2018-07-12">https://itnext.io/how-to-make-legacy-code-reactive-2debcb3d0a40?source=collection_archive---------0-----------------------#2018-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5b5d0cdd6fa0e9e7670b627f3231fa7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bc1yzysBBvN48z0CCHCAZw.jpeg"/></div></div></figure><p id="b588" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你喜欢反应流。太好了。您正在使用的应用程序是非反应性的，并且充满了阻塞调用。不太好。在本文中，我们将探索连接反应式和非反应式代码的选项，并潜在地使应用程序更具性能。</p><p id="39d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:这些例子以Java和Spring Reactor为特色，但是所有反应库的原理和缺陷都是相似的。如果您正在使用RxJS，文章<a class="ae kw" href="https://blog.angularindepth.com/the-extensive-guide-to-creating-streams-in-rxjs-aaa02baaff9a" rel="noopener ugc nofollow" target="_blank">中关于在RxJS </a>中创建流的广泛指南可能会有所帮助。如果您不使用Spring Reactor:</p><ul class=""><li id="058c" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">在反应库中通量是可观察到的</li><li id="c632" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">Mono在一些ReactiveX库中是单一的。这是一个只发出一个值(或者没有值)的可观测值。有点像承诺或未来。</li></ul><h1 id="fb48" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">调度程序</strong></h1><p id="00c6" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在我们开始反应之前，让我们来谈谈调度程序。它们是反应流的重要组成部分，即使你可能从未接触过它们。调度器决定何时在哪个线程(注意:不在RxJS中)上执行操作。</p><p id="28cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有的反应库都允许你使用<code class="fe mo mp mq mr b">publishOn</code>或<code class="fe mo mp mq mr b">subscribeOn</code>操作符来改变默认行为。我最近写了关于这个的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/reactive-streams-and-multithreading-efd63b67de9a">。我强烈推荐Spring Reactor投稿人Simon Baslé的一篇演讲，他以简洁的可视化展示了这些操作符是如何工作的(从16:49开始)。</a></p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4047" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可用的排定程序类型因库而异。您可以在ReactiveX文档的<a class="ae kw" href="http://reactivex.io/documentation/scheduler.html" rel="noopener ugc nofollow" target="_blank">调度器部分或您的图书馆文档中找到您喜欢的口味列表。</a></p><p id="d68f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，您可以选择使用共享调度程序或创建自己的调度程序。在Spring Reactor中创建的三个最重要的组件是:</p><ul class=""><li id="a39f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">单线程:<code class="fe mo mp mq mr b">Schedulers.single(...)</code>创建一个由所有操作共享的线程</li><li id="783b" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">有限并行性:<code class="fe mo mp mq mr b">Schedulers.parallel(...)</code>创建一个固定的线程池，允许您并行运行操作</li><li id="bb29" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">无限并行:<code class="fe mo mp mq mr b">Schedulers.newElastic(...)</code>根据需要创建新线程，重用它们并丢弃未使用的线程。</li></ul><p id="0c72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建自己的调度程序有什么意义？您可以完全控制线程行为。如果应用程序中使用共享调度程序的任何流包含阻塞或昂贵的操作，那么使用同一调度程序的所有其他流都会受到影响—它们会被阻塞。然而，如果一个流使用一个定制的调度器(你所需要的只是一行代码)，它就不会受到影响。</p><h1 id="3510" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">取消阻止呼叫</h1><p id="81d5" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">以下面的代码为例:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="7743" class="ne lm iq mr b gy nf ng l nh ni">class MyService {<br/>  <br/>  public String blockingMethod() {<br/>    ...<br/>    return this.blockingWebService();<br/>  }</span><span id="8c2c" class="ne lm iq mr b gy nj ng l nh ni">}</span></pre><p id="8249" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们调用<code class="fe mo mp mq mr b">blockingMethod</code>时，调用者不得不等待，线程被阻塞。引入反应流的一种简单方法是将<code class="fe mo mp mq mr b">blockingWebService</code>包装成这样的流:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="8b29" class="ne lm iq mr b gy nf ng l nh ni">public Mono&lt;String&gt; blockingMethod() {<br/>    ...<br/>    return Mono.just(this.blockingWebService());<br/>}</span></pre><p id="b2f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这毫无意义。<code class="fe mo mp mq mr b">blockingWebService</code>在我们返回流之前被称为<strong class="ka ir">。我们至少可以做的是<strong class="ka ir">推迟</strong>调用<code class="fe mo mp mq mr b">blockingWebService</code>直到订阅。最简单的方法是使用<code class="fe mo mp mq mr b">fromSupplier</code>:</strong></p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="f5b6" class="ne lm iq mr b gy nf ng l nh ni">public Mono&lt;String&gt; blockingMethod() {<br/>    ...<br/>    return Mono.fromSupplier(() -&gt; this.blockingWebService());<br/>}</span></pre><p id="20ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在<code class="fe mo mp mq mr b">blockingWebService</code>在有人订阅返回的<code class="fe mo mp mq mr b">Mono</code>时执行。这也意味着调用者可以让它在不同的线程上运行:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="d265" class="ne lm iq mr b gy nf ng l nh ni">myService.blockingMethod()<br/>  .subscribeOn(Schedulers.single())<br/>  .subscribe();</span></pre><p id="fbbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调用者仍然需要知道该方法包含阻塞代码。让我们关心自己的线程。</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="3caa" class="ne lm iq mr b gy nf ng l nh ni">class MyService {</span><span id="8ff7" class="ne lm iq mr b gy nj ng l nh ni">  private Scheduler scheduler = Schedulers.newElastic("myThreads");<br/>  <br/>  public String blockingMethod() {<br/>    ...<br/>    return Mono.fromSupplier(() -&gt; this.blockingWebService())<br/>               .subscribeOn(this.scheduler);<br/>  }</span><span id="9c6b" class="ne lm iq mr b gy nj ng l nh ni">}</span></pre><p id="3d2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能想知道为什么我使用了弹性调度器。如果我使用一个固定的池或者一个单独的线程，当足够多的调用者调用这个方法时，这个方法将会阻塞。</p><p id="b40c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个陷阱:链中每一个后面的<code class="fe mo mp mq mr b">subscribeOn</code>都会覆盖我们的<code class="fe mo mp mq mr b">subscribeOn</code>。不过，这是打电话者的选择。</p><p id="866a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切都好吗？哦，那取决于订户的数量。下一节还有一件事。</p><h1 id="438a" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">转换异步结构</h1><p id="38a6" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">也许你的代码已经使用了异步结构，比如期货或承诺。它们通常可以很容易地转换成流:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="a0b3" class="ne lm iq mr b gy nf ng l nh ni">class MyService {<br/>  <br/>  public CompletableFuture&lt;String&gt; nonBlockingMethod() {<br/>    ...<br/>    return this.blockingWebService();<br/>  }</span><span id="2c40" class="ne lm iq mr b gy nj ng l nh ni">}</span><span id="9bce" class="ne lm iq mr b gy nj ng l nh ni">Mono.fromFuture(myService.nonBlockingMethod())<br/>  .subscribe(...);</span></pre><p id="2f1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果代码已经在另一个线程中运行，我们就没事了。还是我们？调用web服务不会阻塞，但是会在任何人订阅之前立即调用该服务。让我们解决这个问题，并返回流:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="bb3d" class="ne lm iq mr b gy nf ng l nh ni">public Mono&lt;String&gt; nonBlockingMethod() {<br/>  ...<br/>  return Mono.defer(<br/>           () -&gt; Mono.fromFuture(this.blockingWebService())<br/>         );<br/>}</span></pre><p id="5ce2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完美。差不多了。像我们这样推迟执行有一个副作用:为每个订户执行代码。你可能想要也可能不想要。如果您选择这种解决方案，那么记录行为，以便客户可以在必要时调整他们的行为。</p><h1 id="22f3" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">转换回调</h1><p id="a37a" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果你使用一个支持回调的API，那已经是异步的了。但是我们怎么能把它变成一条小溪呢？大多数库使用<code class="fe mo mp mq mr b">create</code>函数/方法，或者<code class="fe mo mp mq mr b">Observable</code>构造函数。</p><p id="4e1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个没有流的简单示例:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="e791" class="ne lm iq mr b gy nf ng l nh ni">callWebService("http://foo", response -&gt; {<br/>  //process the response<br/>});</span></pre><p id="b9c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在有了流:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="62b2" class="ne lm iq mr b gy nf ng l nh ni">Mono.create(sink -&gt; {<br/>  callWebService("http://foo", response -&gt; {<br/>   sink.success(response);<br/>  });<br/>})<br/>.map(...)<br/>.subscribe(...);</span></pre><p id="4044" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们所要做的就是创建一个只向流发出的回调。然后，您可以使用流操作符处理结果。一些图书馆有专门的功能。例如RxJS有<code class="fe mo mp mq mr b">bindCallback</code>和<code class="fe mo mp mq mr b">fromEventPattern</code>。</p><h1 id="8375" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">并行运行代码</h1><h2 id="b3a7" class="ne lm iq bd ln nk nl dn lr nm nn dp lv kj no np lz kn nq nr md kr ns nt mh nu bi translated">异步运行昂贵的代码</h2><p id="0124" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">想象这样的代码:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="7b82" class="ne lm iq mr b gy nf ng l nh ni">class MyService {<br/>  <br/>  public String expensiveMethod() {<br/>    //expensive calculations<br/>    return result;<br/>  }</span><span id="4f47" class="ne lm iq mr b gy nj ng l nh ni">}</span><span id="193d" class="ne lm iq mr b gy nj ng l nh ni">value = myService.expensiveMethod();</span></pre><p id="63b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这没有什么问题，但是线程可能会被阻塞很长时间。这也没有错。但是，如果这会阻塞您的应用程序或服务，使其不可用，那么您应该让它异步运行。</p><p id="f6a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于反应流，一种方法是将计算提取到另一种方法中，并使用前面介绍的技术:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="9d93" class="ne lm iq mr b gy nf ng l nh ni">class MyService {</span><span id="fea5" class="ne lm iq mr b gy nj ng l nh ni">  private Scheduler scheduler = Schedulers.newElastic("myThreads");<br/>  <br/>  public Mono&lt;String&gt; expensiveMethod() {<br/>    return Mono.fromSupplier(() -&gt; this.expensiveCalculations())<br/>               .subscribeOn(this.scheduler);<br/>  }</span><span id="cdcc" class="ne lm iq mr b gy nj ng l nh ni">  private String expensiveCalculations() {<br/>    ...<br/>  }</span><span id="4b8f" class="ne lm iq mr b gy nj ng l nh ni">}</span><span id="2a9d" class="ne lm iq mr b gy nj ng l nh ni">// Or</span><span id="9f9c" class="ne lm iq mr b gy nj ng l nh ni">  public Mono&lt;String&gt; expensiveMethod() {<br/>    return Mono.create(sink -&gt; {<br/>                  //expensive calculations<br/>                  sink.success(result);<br/>                })<br/>               .subscribeOn(this.scheduler);<br/>  }</span></pre><h2 id="2c6a" class="ne lm iq bd ln nk nl dn lr nm nn dp lv kj no np lz kn nq nr md kr ns nt mh nu bi translated">并行处理数据</h2><p id="ba87" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">Java 8 streams引入的一个好处是，只需调用<code class="fe mo mp mq mr b">parallel()</code>，就可以让数据被多个线程并行处理。我们可以对反应流做同样的事情，并且我们对线程有更多的控制。注意:不是所有的库都支持这个。</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="4257" class="ne lm iq mr b gy nf ng l nh ni">Scheduler scheduler = Schedulers.newParallel("foo");</span><span id="45d8" class="ne lm iq mr b gy nj ng l nh ni">myStream<br/>  .parallel()<br/>  .runOn(scheduler)<br/>  .map(...)<br/>  .subscribe(...);</span></pre><p id="1975" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，<code class="fe mo mp mq mr b">parallel()</code>仅<strong class="ka ir">准备</strong>并行处理的流。实际的线程行为由<code class="fe mo mp mq mr b">runOn</code>定义。没有任何争论<code class="fe mo mp mq mr b">parallel</code>将工作分成和CPU核心一样多的部分。如果我们有四个，那么四个元素<strong class="ka ir">可以被并行处理。我们的调度程序提供了与CPU内核一样多的线程。完全匹配。</strong></p><p id="13f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个场景是并行运行几个<strong class="ka ir">独立的</strong>操作，并在所有操作完成后做一些事情。一些库提供了一个<code class="fe mo mp mq mr b">forkJoin</code>操作符，但是更通用的解决方案是<code class="fe mo mp mq mr b">zip</code>。</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="5b10" class="ne lm iq mr b gy nf ng l nh ni">Flux.zip(stream1, stream2, stream3)<br/>  .subscribe(combinedResult -&gt; ...);</span><span id="c4bc" class="ne lm iq mr b gy nj ng l nh ni">// Produces<br/>// [ value stream1, value stream2, value stream3] |</span></pre><p id="2190" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Spring Reactor中，组合的结果是一个<code class="fe mo mp mq mr b">Tuple</code>。在其他库中，它可以是数组或列表。如果你的流发出一个以上的值，第一个，第二个，等等。所有流的合并。</p><p id="df16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有几点需要考虑。如果流运行在不同的线程上，它们只能并行运行。根据流的不同，可能需要为一个、一些或所有流引入调度程序:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="5824" class="ne lm iq mr b gy nf ng l nh ni">Scheduler scheduler = Schedulers.newElastic("foo");</span><span id="a324" class="ne lm iq mr b gy nj ng l nh ni">Flux.zip(<br/>  stream1.subscribeOn(scheduler), <br/>  stream2.subscribeOn(scheduler),<br/>  stream3.subscribeOn(scheduler)<br/>  )<br/>  .subscribe(combinedResult -&gt; ...);</span></pre><p id="dad0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个问题是，如果一个流失败，合并的流也会失败。如果你需要所有的操作都成功才能继续，那很好。否则，我们可以用回退值或回退流来解决问题:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="d3d1" class="ne lm iq mr b gy nf ng l nh ni">Flux.zip(<br/>  stream1.onErrorReturn("),<br/>  stream2.onErrorReturn("),<br/>  stream3.onErrorReturn(")<br/>  )<br/>  .subscribe(combineResult -&gt; ...);</span></pre><p id="5f77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，Spring Reactor不允许<code class="fe mo mp mq mr b">null</code>值。订户必须能够处理回退值。另一个选项是<code class="fe mo mp mq mr b">merge</code>结合<code class="fe mo mp mq mr b">onErrorResume</code>:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="4849" class="ne lm iq mr b gy nf ng l nh ni">Flux.merge(<br/>    stream1.onErrorResume(e -&gt; Flux.<em class="nv">empty</em>()),<br/>    stream2.onErrorResume(e -&gt; Flux.<em class="nv">empty</em>()),<br/>    stream3.onErrorResume(e -&gt; Flux.<em class="nv">empty</em>())<br/>  )<br/>  .buffer(3)<br/>  .subscribe(combineResult -&gt; ...);</span></pre><p id="5199" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果发生错误，我们返回一个空流。你可能会奇怪我为什么用<code class="fe mo mp mq mr b">buffer</code>。如果没有它<code class="fe mo mp mq mr b">merge</code>，我们将有一个发出3个元素的流，每个元素对应一个源流(假设每个源流只发出一个元素)。Buffer将元素组合成一个类似于<code class="fe mo mp mq mr b">zip</code>的列表(在一些库中是数组)。如果一个流失败了，我们需要知道哪个流成功了，因为我们需要处理结果，那么我们需要映射源流的结果:</p><pre class="mu mv mw mx gt na mr nb nc aw nd bi"><span id="2947" class="ne lm iq mr b gy nf ng l nh ni">Flux.merge(<br/>    stream1.onErrorResume(e -&gt; Flux.<em class="nv">empty</em>())<br/>      .map(v -&gt; Tuples.<em class="nv">of</em>(1, v)),<br/>    stream2.onErrorResume(e -&gt; Flux.<em class="nv">empty</em>())<br/>      .map(v -&gt; Tuples.<em class="nv">of</em>(2, v)),<br/>    stream3.onErrorResume(e -&gt; Flux.<em class="nv">empty</em>())<br/>      .map(v -&gt; Tuples.<em class="nv">of</em>(3, v))<br/>  )<br/>  .buffer(3)<br/>  .subscribe(combineResult -&gt; ...);</span><span id="e844" class="ne lm iq mr b gy nj ng l nh ni">// Produces<br/>// [ [1, value stream1], [2, value stream2], [3, value stream3]] |</span></pre><h1 id="cd20" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="c1e2" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">反应式编程的最佳解决方案是使用完全反应式堆栈。这并不总是可能的。使用我介绍的技术，您仍然可以实现高度的“反应性”。调度程序和并行处理可以帮助您轻松提高性能。</p><p id="8714" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你知道一些其他有用的技术，请在评论中分享它们或链接到现有的资源。</p></div></div>    
</body>
</html>