# Scala 中的函数式反应式编程(第 2 部分)

> 原文：<https://itnext.io/functional-reactive-programming-in-scala-from-scratch-part-2-3d1559a11629?source=collection_archive---------5----------------------->

在这一系列的文章中，我们想从头开始为 Scala 中的函数式反应式编程开发一个小框架。如果你还没有阅读该系列的第一部分，请务必在这里查看。第 3 部分可以在这里找到[。](https://medium.com/@timo.stoettner/functional-reactive-programming-in-scala-from-scratch-part-3-d999dca5fa69)

![](img/5cf7df4b38a88f4f66b54915f2471454.png)

照片由[émile Perron](https://unsplash.com/@emilep?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

*注:你可以在* [*这个 GitHub 资源库*](https://github.com/timo-stoettner/frp-scala) *中找到有完整代码的笔记本。*

在上一篇文章中，我们从 Scala 中函数式反应式编程的一个小框架的实现开始。我们的目标是为`Signal`和`Var`编写实现，使我们能够做以下事情:

调用`total()`应该随时返回我们两个`BankAccount`的总余额。

我们实现了`BankAccount`的实现，它以我们预期的方式工作，但是整合还没有完全完成。原因是我们实现了`Signal`和`Var`，`consolidated`在初始化时计算一次，然后永远保持不变。概括地说，这是我们对`Signal`和`Var`的实现:

让我们的实现失败的是，当我们将`initVal`传递给`Signal`的构造函数时，我们立即对其求值。后面的更改无关紧要，因为`Signal`的值不会被重新评估。

那么我们如何解决这个问题呢？让我们使用一些函数式编程的工具。

# 利用函数式编程

我们想要实现的是，每当其中一个`BankAccount`的余额发生变化时，`total`都会被重新计算。换句话说，由`consolidated`返回的`Signal`应该是它所依赖的其他信号的*函数。(如果你略读了这一部分，你可能想再读一遍。)*

欢迎来到函数式编程。到目前为止，我们只传递了整数值。现在我们想传递任意的函数。

那么我们该怎么做呢？首先，我们需要确保我们实际上可以将任意表达式传递给我们的类，并且我们需要停止将自己局限于整数。我们通过将 Int 类型声明替换为泛型类型来做到这一点。

其次，我们需要以一种方式存储我们的表达式，确保它不会以按值调用的方式被求值。如果我们改变我们的构造函数参数为 call-by-name，它可以在任何改变的时候被重新评估。

(如果你对按值调用和按名称调用有些模糊，请查看[这个简单明了的解释](https://alvinalexander.com/source-code/scala/simple-scala-call-name-example))。

让我们看看这是如何实现的:

我们在这里做了一些改动:

1.  我们在所有适用的地方用泛型类型替换了整数类型。
2.  我们将`initVal`重命名为`expr`，以说明我们不再只是传递整数值，而是处理任意表达式。此外，我们将`expr`定义为按名称调用(`expr: => T`)，这意味着它不会立即被评估。
3.  我们添加了另一个变量`curExpr`,它存储我们的表达式而不计算它，并且可以在需要时更新为一个新的表达式。语法`var curExpr: () => T = () => expr`可能需要浏览几眼才能理解。它定义了一个类型为`() => T`(匿名函数)的`var`，其值为`() => expr`。然后我们可以调用`curExpr()`来计算表达式。
4.  我们的`update`方法现在更新了`curExpr`和`curVal`

这让我们离第一个工作实现更近了一步。但是你可能已经猜到了，它还没有工作。一旦我们到达`private var curVal = expr`，就会对`expr`进行评估。所以没有什么真正的改变。(如果您用这些`Signal`和`Var`的实现运行上一篇文章末尾的代码，您将得到相同的结果。我鼓励你亲自尝试一下。)

正如我在上面写的，每当我们的一个`BankAccount`平衡改变时，`total`需要被重新计算。为了确保这一点，我们需要跟踪依赖于(即“观察”)我们个人平衡的`Signal`。如果我们不知道哪些`Signal`依赖于我们的余额，我们就不知道一旦它们发生变化，我们需要重新计算什么。

在观察者模式中，我们通过让合并器显式订阅它所依赖的每个主题(即`BankAccount`)来解决这个问题。然而，我们希望编写比观察者模式更优雅的代码。观察者模式需要相当多的样板代码，我们想在这里避免。

那么我们如何为我们的`Signal`和`Var`实现解决这个问题呢？让我们看一看。

# 跟踪依赖性

一旦某个特定的`Signal`发生变化，跟踪哪些`Signal`需要重新计算的一个直接方法是将它所依赖的“主题”专门传递给它的构造函数。当我们初始化`Signal`时，我们需要告诉它两件事:

1.  它应该计算的表达式
2.  另一个是它应该观察变化，这样当它们变化时它可以重新计算它的值

让我们看看如何实现这样的东西:

我们在这里又改变了一些东西:

1.  现在有一个可选的构造函数参数`observed: List[Signal[_]] = Nil`。它可以用来传递定义的`Signal`所依赖的`Signal`列表。如你所见，默认为`Nil`。所以，如果你不传递任何东西，我们新定义的`Signal`不会在其他`Signal`改变它们的值时被更新。
2.  我们添加了一个初始化为空的`Set`的`private var observers`。当一个新的`Signal`被初始化时，它在`observed`上迭代，并将其自身添加到所有其观察到的`Signal` s: `observed.foreach( obs => obs.observers += this )`的`observers`
3.  我们添加了一个方法`computeValue`，它通过评估当前表达式来更新`Signal`的当前值，并让它的所有观察者也更新它们的值。
4.  `update`采用了我们的新方法`computeValue`

为了在我们的银行帐户示例中使用这个实现，我们还需要对我们的函数`consolidated`做一点修改——我们需要显式地传递我们的合并器所依赖的`Signal`:

好消息是，这是我们想要实现的第一个工作实现！如果您将代码放在一起并运行下面的小测试，您将得到预期的结果:

祝贺你第一次实现了函数式反应式编程！

然而，坏消息是，我们的代码非常重复并且容易出错。在定义我们的函数`consolidated`时，我们需要将它计算的函数(`accts.map(_.balance()).sum`)和它依赖的函数(`accts.map(_.balance)`)传递给`Signal`的构造函数。如您所见，这几乎是两次完全相同的代码——至少在这个简单的例子中是这样。

(此外，当更新我们在`Var`中的表达式时，我们目前不会更新`observed`信号。我们或许可以通过调用`update`来通过一个新的`observed`来解决这个问题，但是这被认为很快会变得很糟糕。)

谢谢你一直陪着我，直到这篇代码非常多的文章结束！如果您已经做到了这一步，那么这只是向更好的解决方案迈出的一小步。

在下一篇文章中，我们将会看到我们的`Signal`们如何为自己找出他们所依赖的其他`Signal`们。我们将提出最终的、更加优雅的实现。