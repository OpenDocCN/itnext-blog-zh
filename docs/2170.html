<html>
<head>
<title>Repository design pattern done right in Laravel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel中的存储库设计模式</h1>
<blockquote>原文：<a href="https://itnext.io/repository-design-pattern-done-right-in-laravel-d177b5fa75d4?source=collection_archive---------0-----------------------#2019-04-11">https://itnext.io/repository-design-pattern-done-right-in-laravel-d177b5fa75d4?source=collection_archive---------0-----------------------#2019-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c06b571148be52360a71546450b5f1cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3T_jDNDi9Hyaw48l"/></div></div></figure><div class=""/><p id="2790" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将向你展示如何在Laravel中从头开始设置存储库设计模式。我将使用Laravel 5.8.3版本，但Laravel版本应该不会有太大影响。在我们开始编码之前，您需要了解一些关于存储库设计模式的事情。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi kz"><img src="../Images/ec531d6dc0f3d039d146a133d25b20ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7JRxmo6yK_DLdoZl.png"/></div></div></figure><p id="dedc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">存储库设计模式允许您使用对象，而不必知道这些对象是如何持久化的。本质上，它是数据层的抽象。</p><p id="0b47" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着您的业务逻辑不需要知道数据是如何检索的或者数据的来源是什么。业务逻辑依赖存储库来检索正确的数据。</p><p id="85fc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关于这种模式，我经常看到一种误解，即存储库是以创建或更新记录的方式实现的。这是<strong class="kd jf">而不是</strong>一个存储库应该做的事情。存储库<strong class="kd jf">不应该</strong>创建或更新数据，但是<strong class="kd jf">应该只使用</strong>来检索数据。</p><h2 id="f1ae" class="le lf je bd lg lh li dn lj lk ll dp lm km ln lo lp kq lq lr ls ku lt lu lv lw bi translated">理论讲够了，让我们开始编码吧</h2><p id="2e35" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">因为我们将从头开始，所以让我们从创建一个新的Laravel项目开始:</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="f5d9" class="le lf je md b gy mh mi l mj mk">composer create-project --prefer-dist laravel/laravel repository</span></pre><p id="8fb1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本教程中，我将创建一个小型博客应用程序。现在我们已经创建了一个项目，我们需要为博客创建一个控制器和模型。</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="7780" class="le lf je md b gy mh mi l mj mk">php artisan make:controller BlogController</span></pre><p id="25f7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将在<em class="ml"> app/Http/Controllers </em>文件夹中创建BlogController。</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="a88b" class="le lf je md b gy mh mi l mj mk">php artisan make:model Models/Blog -m</span></pre><p id="63fa" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ml">注意:<br/>-m选项将创建数据库迁移。该文件可以在数据库/迁移文件夹中找到。</em></p><p id="5d79" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将创建您的博客模型，并将其存储在<em class="ml"> app/Models </em>文件夹中。这只是存储模型的一种方式，这也是我喜欢的方式。</p><p id="6c97" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了控制器和模型，是时候看看我们创建的迁移文件了。除了默认的Laravel时间戳字段，我们的博客现在只需要一个<em class="ml">标题、内容</em>和<em class="ml"> user_id </em>字段。</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="8d17" class="le lf je md b gy mh mi l mj mk">&lt;?php<br/><br/>use Illuminate\Support\Facades\Schema;<br/>use Illuminate\Database\Schema\Blueprint;<br/>use Illuminate\Database\Migrations\Migration;<br/><br/>class CreateBlogsTable extends Migration<br/>{<em class="ml"><br/>    </em>public function up()<br/>    {<br/>        Schema::create('blogs', function (Blueprint $table) {<br/>            $table-&gt;bigIncrements('id');<br/>            $table-&gt;string('title');<br/>            $table-&gt;text('content');<br/>            $table-&gt;integer('user_id');<br/>            $table-&gt;timestamps();<br/>            <br/>            <!-- -->$table-&gt;foreign('user_id')<br/>                  -&gt;references('id')<br/>                  -&gt;on('users');<br/>        });<br/>    }<br/><em class="ml"><br/>    </em>public function down()<br/>    {<br/>        Schema::dropIfExists('blogs');<br/>    }<br/>}</span></pre><p id="76ff" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ml">注意:<br/>如果您使用的是比Laravel 5.8更旧的版本，您应该替换以下行</em></p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="3ef0" class="le lf je md b gy mh mi l mj mk">$table-&gt;bigIncrements(‘id’);</span></pre><p id="f058" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ml">同</em></p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="37ee" class="le lf je md b gy mh mi l mj mk">$table-&gt;increments('id');</span></pre><h2 id="20b5" class="le lf je bd lg lh li dn lj lk ll dp lm km ln lo lp kq lq lr ls ku lt lu lv lw bi translated">设置数据库</h2><p id="efa7" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">对于这个例子，我将使用一个MySQL数据库。第一步是创建一个新的数据库。</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="d111" class="le lf je md b gy mh mi l mj mk">mysql -u root -p <br/>create database laravel_repository;</span></pre><p id="b8e2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将创建一个名为<em class="ml"> laravel_repository </em>的数据库。接下来，我们必须将数据库凭证添加到<em class="ml">中。env </em>文件。</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="d9de" class="le lf je md b gy mh mi l mj mk">DB_DATABASE=laravel_repository<br/>DB_USERNAME=root<br/>DB_PASSWORD=secret</span></pre><p id="f1bb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在你改变了<em class="ml">之后。我们必须清除配置缓存:</em></p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="2b1f" class="le lf je md b gy mh mi l mj mk">php artisan config:clear</span></pre><h2 id="c6fa" class="le lf je bd lg lh li dn lj lk ll dp lm km ln lo lp kq lq lr ls ku lt lu lv lw bi translated">运行迁移</h2><p id="2002" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在我们已经设置了数据库，我们可以运行迁移了:</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="6414" class="le lf je md b gy mh mi l mj mk">php artisan migrate</span></pre><p id="3a88" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将创建我们的<em class="ml">博客</em>表，带有我们在迁移中声明的<em class="ml">标题</em>、<em class="ml">内容</em>和<em class="ml">用户id </em>字段。</p><h2 id="7491" class="le lf je bd lg lh li dn lj lk ll dp lm km ln lo lp kq lq lr ls ku lt lu lv lw bi translated">实现存储库设计模式</h2><p id="a6c0" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">一切就绪后，我们现在可以开始实现存储库设计模式了。我们将首先在<em class="ml">应用程序</em>文件夹中创建一个<em class="ml">存储库</em>文件夹。我们将创建的第二个文件夹是<em class="ml">接口</em>文件夹。该文件夹将位于我们刚刚创建的<em class="ml">存储库</em>文件夹中。</p><p id="d6db" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="ml"> Interfaces </em>文件夹中，我们创建了一个<em class="ml">BlogRepositoryInterface</em>类<em class="ml"> </em>，它现在有两个方法:</p><ol class=""><li id="c01b" class="mm mn je kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">将返回所有博客的<em class="ml"> all </em>方法。</li><li id="b33a" class="mm mn je kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated"><em class="ml"> getByUser </em>方法将返回由特定用户创建的所有博客。</li></ol><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="0903" class="le lf je md b gy mh mi l mj mk">&lt;?php<br/><br/>namespace App\Repositories\Interfaces;<br/><br/>use App\User;<br/><br/>interface BlogRepositoryInterface<br/>{<br/>    public function all();<br/><br/>    public function getByUser(User $user);<br/>}</span></pre><p id="2dff" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们要创建的最后一个类是<em class="ml"> BlogRepository </em>，它将实现<em class="ml">blog repository interface</em>。我们将坚持一个非常简单的实现。</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="1421" class="le lf je md b gy mh mi l mj mk">&lt;?php<br/><br/>namespace App\Repositories;<br/><br/>use App\Models\Blog;<br/>use App\User;<br/>use App\Repositories\Interfaces\BlogRepositoryInterface;<br/><br/>class BlogRepository implements BlogRepositoryInterface<br/>{<br/>    public function all()<br/>    {<br/>        return Blog::<em class="ml">all</em>();<br/>    }<br/><br/>    public function getByUser(User $user)<br/>    {<br/>        return Blog::<em class="ml">where</em>('user_id'. $user-&gt;id)-&gt;get();<br/>    }<br/>}</span></pre><p id="a631" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您的<em class="ml">存储库</em>文件夹应该是这样的:</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="c49c" class="le lf je md b gy mh mi l mj mk">app/<br/>└── Repositories/<br/>    ├── BlogRepository.php<br/>    └── Interfaces/<br/>        └── BlogRepositoryInterface.php</span></pre><p id="ebc2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您现在已经成功创建了您的存储库！但是我们还没有完成。是时候开始使用我们的存储库了。</p><h2 id="d2b8" class="le lf je bd lg lh li dn lj lk ll dp lm km ln lo lp kq lq lr ls ku lt lu lv lw bi translated">运行中的存储库</h2><p id="bc55" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">开始使用<em class="ml"> BlogRepository </em>时，我们应该将它注入<em class="ml"> BlogController </em>中。因为存储库将被注入，所以很容易用另一个实现替换它。这是我们的控制器的样子:</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="09df" class="le lf je md b gy mh mi l mj mk">&lt;?php<br/><br/>namespace App\Http\Controllers;<br/><br/><br/>use App\Repositories\Interfaces\BlogRepositoryInterface;<br/>use App\User;<br/><br/>class BlogController extends Controller<br/>{<br/>    private $blogRepository;<br/><br/>    public function __construct(BlogRepositoryInterface $blogRepository)<br/>    {<br/>        $this-&gt;blogRepository = $blogRepository;<br/>    }<br/><br/>    public function index()<br/>    {<br/>        $blogs = $this-&gt;blogRepository-&gt;all();<br/><br/>        return view('blog')-&gt;withBlogs($blogs);<br/>    }<br/><br/>    public function detail($id)<br/>    {<br/>        $user = User::<em class="ml">find</em>($id);<br/>        $blogs = $this-&gt;blogRepository-&gt;getByUser($user);<br/><br/>        return view('blog')-&gt;withBlogs($blogs);<br/>    }<br/>}</span></pre><p id="5741" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，控制器中的代码很短，因此可读性很强。你不需要十行代码来获得你想要的数据集，所有的事情都可以在一行代码中完成，这多亏了这个库。这对于单元测试来说也很棒，因为存储库的方法很容易被模仿。</p><p id="c9fa" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">存储库设计模式也使数据源之间的转换变得非常容易。在这个例子中，我们使用数据库来检索我们的博客。我们依靠雄辩来为我们做到这一点。但是，假设我们在互联网上的某个地方看到了一个很棒的博客API，我们想使用这个API。我们所要做的就是重写BlogRepository来使用这个API，而不是雄辩。</p><h2 id="5c88" class="le lf je bd lg lh li dn lj lk ll dp lm km ln lo lp kq lq lr ls ku lt lu lv lw bi translated">RepositoryServiceProvider</h2><p id="3e37" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们将注入BlogRepositoryInterface，而不是在BlogController中注入BlogRepository，然后让服务容器决定使用哪个存储库。这可以在<em class="ml"> AppServiceProvider </em>的<em class="ml"> boot </em>方法中完成，但是我更喜欢为此创建一个新的提供者以保持整洁。</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="0c3f" class="le lf je md b gy mh mi l mj mk">php artisan make:provider RepositoryServiceProvider</span></pre><p id="6d09" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们为此创建一个新的提供者的原因是，当您的项目开始增长时，事情会变得非常混乱。假设一个项目有超过10个模型，每个模型都有自己的存储库。您的<em class="ml">应用服务提供者</em>将变得不可读。</p><p id="f399" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们的<em class="ml">RepositoryServiceProvider</em>的样子:</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="beae" class="le lf je md b gy mh mi l mj mk">&lt;?php<br/><br/>namespace App\Providers;<br/><br/>use App\Repositories\BlogRepository;<br/>use App\Repositories\Interfaces\BlogRepositoryInterface;<br/>use Illuminate\Support\ServiceProvider;<br/><br/>class RepositoryServiceProvider extends ServiceProvider<br/>{<br/>    public function register()<br/>    {<br/>        $this-&gt;app-&gt;bind(<br/>            BlogRepositoryInterface::class, <br/>            BlogRepository::class<br/>        );<br/>    }<br/>}</span></pre><p id="0add" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，用另一个存储库替换BlogRepository是多么容易。</p><p id="75c8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不要忘记将<em class="ml">RepositoryServiceProvider</em>添加到<em class="ml"> config/app.php </em>文件中的提供者列表中。之后，我们必须再次清除配置缓存。</p><pre class="la lb lc ld gt mc md me mf aw mg bi"><span id="6c7f" class="le lf je md b gy mh mi l mj mk">php artisan config:clear</span></pre><h2 id="7058" class="le lf je bd lg lh li dn lj lk ll dp lm km ln lo lp kq lq lr ls ku lt lu lv lw bi translated">好了</h2><p id="e2d5" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在，您已经成功地实现了存储库设计模式。没那么难，对吧？</p><p id="4966" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以选择通过添加一些路由和视图来扩展您的代码，但是我将在这里结束这篇文章，因为这篇文章是关于实现存储库模式的。</p><p id="5617" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这篇文章，或者如果这篇文章帮助你建立了存储库设计模式，请务必看看我的其他文章。如果您有任何反馈、问题或希望我写另一个与Laravel相关的主题，请随时留下您的评论。</p></div></div>    
</body>
</html>