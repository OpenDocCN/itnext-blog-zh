<html>
<head>
<title>Using Java to Read Really, Really Large Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Java读取非常非常大的文件</h1>
<blockquote>原文：<a href="https://itnext.io/using-java-to-read-really-really-large-files-a6f8a3f44649?source=collection_archive---------0-----------------------#2019-01-04">https://itnext.io/using-java-to-read-really-really-large-files-a6f8a3f44649?source=collection_archive---------0-----------------------#2019-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="f51c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Java就是为这种东西而生的。</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/8621be054d9da1043e7b6e4b0c9431a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bPLTMMYgxMDqAB5OOeTIQw.png"/></div></div></figure><p id="6574" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi lv translated">任何在我的编程生涯中对我相当了解的人都会知道，我并不偏爱Java。</p><p id="adf2" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我首先是一名JavaScript开发人员。这是我第一次学到的东西，在我开始掌握它之后，它让我困惑，然后又让我高兴，对我来说，它比Java有意义得多，因为它的编译，它需要声明每一个变量类型(是的，我知道Java的最新版本已经取消了对一些更简单的推理的这一要求)，以及它的大量地图、列表、集合等库。:哈希表，映射，哈希表，树映射，数组列表，链表，数组，等等。</p><p id="5561" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">也就是说，我确实努力提高Java水平，克服我没有传统计算机科学学位的缺点。如果你想了解更多关于我成为软件工程师的非典型途径，你可以在这里阅读我的第一篇博文<a class="ae me" href="https://medium.com/@paigen11/how-i-went-from-a-digital-marketer-to-a-software-engineer-in-4-months-7ed99c65d360" rel="noopener">。</a></p><p id="8d51" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">因此，当我告诉我的一个同事几个月前我遇到的一个编码挑战，以及我如何用JavaScript<a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/using-node-js-to-read-really-really-large-files-pt-1-d2057fe76b33">解决了它</a>(然后<a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/streams-for-the-win-a-performance-comparison-of-nodejs-methods-for-reading-large-datasets-pt-2-bcfa732fa40e">性能</a>测试了我的各种解决方案)，他回头看着我说:“你会如何用Java解决它？”</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/b85b5030b373ee41c99acb8c025d76c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*HhCRJcOTITfqMeERbp22zQ.jpeg"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">我对使用Java这个问题的最初反应。</figcaption></figure><p id="f7e1" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我盯着他，脑子里的轮子开始转动，我也接受了用Java寻找最优解的挑战。</p><p id="d2f2" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">所以在我开始讨论如何使用Java解决我的挑战之前，让我回顾一下需求。</p><h1 id="1bf2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我面临的挑战</h1><p id="cd52" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">正如我在我的<a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/using-node-js-to-read-really-really-large-files-pt-1-d2057fe76b33">原始文章</a>中所说，关于使用Node.js读取非常非常大的文件，这是一个发给另一个保险技术公司开发人员的编码挑战。</p><p id="5604" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">挑战很简单:从联邦选举委员会下载这个大的文本zip文件，从。txt文件，并提供以下信息:</p><ul class=""><li id="2deb" class="mp mq iq kz b la lb le lf li mr lm ms lq mt lu mu mv mw mx bi translated">写一个程序，打印出文件中的总行数。</li><li id="5b83" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">请注意，第8列包含一个人的姓名。编写一个程序，加载这些数据并创建一个包含所有名称字符串的数组。打印出第432号和第43243号姓名。</li><li id="720b" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">请注意，第5列包含一种日期形式。计算每个月有多少捐赠，并打印出结果。</li><li id="8417" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">请注意，第8列包含一个人的姓名。用每个名字创建一个数组。确定数据中最常见的名字及其出现的次数。</li></ul><p id="9b79" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">数据链接:<a class="ae me" href="https://www.fec.gov/files/bulk-downloads/2018/indiv18.zip" rel="noopener ugc nofollow" target="_blank">https://www.fec.gov/files/bulk-downloads/2018/indiv18.zip</a>*</p><p id="180a" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">注意:</strong>我在文件链接后面加了星号，因为自从我在2018年10月初下载以来，其他选择自己承担这项挑战的人实际上已经看到文件大小增加了。在最近的统计中，有人提到现在高达3.5GB，所以看起来这个数据仍然是实时的，并且一直在增加。我相信我下面提出的解决方案仍然有效，但是你的计数和数字会和我的不同。</p><p id="703a" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我喜欢这个挑战，并且想练习操作文件，所以我决定看看我是否能解决这个问题。现在，事不宜迟，让我们来谈谈我想到的用Java读取非常非常大的文件的一些不同的解决方案。</p><h1 id="b122" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我想到的三个Java解决方案</h1><p id="698a" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">Java长期以来一直是一种具有文件处理能力的标准编程语言，因此，有大量不断改进的方法可以用它来读取、写入和操作文件。</p><p id="a940" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">有些方法是直接放入核心Java框架中的，有些仍然是独立的库，需要导入并捆绑在一起才能运行。但是不管怎样，我想出了三种不同的方法来读取Java中的文件，然后我对它们进行了性能测试，看哪种方法更有效。</p><p id="8568" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">下面是<a class="ae me" href="https://marketplace.visualstudio.com/items?itemName=pnp.polacode" rel="noopener ugc nofollow" target="_blank"> Polacode </a>格式的我所有代码的截图以及各种代码片段，如果你想看所有的原始代码，你可以在这里访问我的Github repo<a class="ae me" href="https://github.com/paigen11/read-file-java" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="f16a" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您会注意到，我使用了相同的代码逻辑从每个文件中提取数据，主要区别在于初始文件连接和文本解析。我这样做是为了更准确地了解不同方法在我的评估中的性能部分是如何相互影响的。苹果与苹果的比较以及所有这些。</p><h2 id="ba8d" class="nd jo iq bd jp ne nf dn jt ng nh dp jx li ni nj kb lm nk nl kf lq nm nn kj no bi translated"><strong class="ak">Java</strong><a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/?java/io/FileInputStream.html" rel="noopener ugc nofollow" target="_blank"><strong class="ak">file inputstream()</strong></a><strong class="ak">&amp;</strong><a class="ae me" href="https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Scanner()</strong></a><strong class="ak">实现</strong></h2><p id="dd7a" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">我想到的第一个解决方案是使用Java内置的<code class="fe np nq nr ns b">FileInputStream()</code>方法结合<code class="fe np nq nr ns b">Scanner()</code>。</p><p id="f0d5" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">本质上，FileInputStream只是打开了到要读取的文件的连接，不管是图像还是字符等等。它并不特别关心文件实际上是什么，因为Java将输入流作为原始数据字节读取。另一个选择(至少对我来说)是使用专门用于读取字符流的<code class="fe np nq nr ns b">FileReader()</code>，但是我在这个特殊的场景中使用了<code class="fe np nq nr ns b">FileInputStream()</code>。我在后来测试的另一个解决方案中使用了<code class="fe np nq nr ns b">FileReader()</code></p><p id="ed2a" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">一旦建立了与文件的连接，Scanner就开始将文本字节解析成可读的数据字符串。<code class="fe np nq nr ns b">Scanner()</code>使用分隔符模式将其输入分解成标记，默认情况下匹配空白(但也可以被覆盖以使用regex或其他值)。然后，通过使用<code class="fe np nq nr ns b">Scanner.hasNextLine()</code>布尔值和<code class="fe np nq nr ns b">Scanner.nextLine()</code>方法，我可以逐行读取文本文件的内容，并提取出我需要的数据片段。</p><p id="c8a4" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe np nq nr ns b">Scanner.nextLine()</code>实际上让这个扫描器前进通过当前行，并返回跳过的输入，这就是我如何能够从每一行收集所需信息，直到没有更多行要读取，<code class="fe np nq nr ns b">Scanner.hasNextLine()</code>返回false，然后<code class="fe np nq nr ns b">while</code>循环结束。</p><p id="e2b9" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这里有一个使用<code class="fe np nq nr ns b">FileInputStream()</code>和<code class="fe np nq nr ns b">Scanner()</code>的代码示例。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="74c2" class="nd jo iq ns b gy nx ny l nz oa">File f = new File("src/main/resources/config/test.txt");<br/><br/>try {<br/>   FileInputStream inputStream = new FileInputStream(f);<br/>   Scanner sc = new Scanner(inputStream, "UTF-8");<br/>   do some things ...</span><span id="f195" class="nd jo iq ns b gy ob ny l nz oa">   while (sc.hasNextLine()) {<br/>      String line = sc.nextLine();<br/>      do some more things ...<br/>   } </span><span id="5920" class="nd jo iq ns b gy ob ny l nz oa">   do some final things<br/>}</span></pre><p id="b637" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这是我解决上述所有任务的完整代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/b95c24e43b668ca875564e1ca9ba6851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8VeyTOiBNWOu_EPkimxXg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">FileInputStream()和Scanner()逐行流过文本数据。</figcaption></figure><p id="e717" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在一次读取一行文件的数据后，只需获取必要的数据并对其进行操作以满足我的需求。</p><p id="aaf5" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">任务1:获取文件的总行数</strong></p><p id="bc38" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">获取整个文件的行数很容易。所涉及的只是在<code class="fe np nq nr ns b">while</code>循环之外声明了一个新的<code class="fe np nq nr ns b">int lines = 0</code>,每当循环再次运行时，这个值就会增加。请求1:完成。</p><p id="b095" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">任务2:创建所有姓名的列表，并找到第432和43243个姓名</strong></p><p id="cfdb" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">第二个请求是收集所有的名字并打印数组中的第432和第43243个名字，它要求我创建一个<code class="fe np nq nr ns b">ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();</code>和一个<code class="fe np nq nr ns b">ArrayList&lt;Integers&gt; indexes = new ArrayList&lt;&gt;();</code>，我很快用<code class="fe np nq nr ns b">indexes.add(433)</code>和<code class="fe np nq nr ns b">indexes.add(43244)</code>分别添加了432和43243的索引。</p><p id="aa2d" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我必须给每个索引加1来获得数组中正确的名字位置，因为一旦<code class="fe np nq nr ns b">Scanner.hasNextLine()</code>返回true，我就增加我的行计数(从0开始)。在<code class="fe np nq nr ns b">Scanner.nextLine()</code>返回前一行的内容后，我可以取出我需要的名字，这意味着它的真正索引(从索引0开始)实际上是行数减1的索引。(相信我，我检查了三遍，以确保我的计算是正确的)。</p><p id="2c4f" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我使用ArrayList作为名称，因为它维护了元素的插入顺序，这意味着在显示ArrayList元素时，结果集将总是具有与元素插入列表时相同的顺序。因为我是逐行遍历文件，所以元素总是以相同的顺序插入到列表中。</p><p id="4eb9" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">下面是我用来获取所有名字的完整逻辑，如果我在<code class="fe np nq nr ns b">indexes</code>数组列表中的索引与<code class="fe np nq nr ns b">lines</code>计数索引匹配，就打印出这些名字。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="2032" class="nd jo iq ns b gy nx ny l nz oa">int lines = 0;</span><span id="43e6" class="nd jo iq ns b gy ob ny l nz oa">ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();<br/><br/>// get the 432nd and 43243 names<br/>ArrayList&lt;Integer&gt; indexes = new ArrayList&lt;&gt;();<br/><br/>indexes.add(433);<br/>indexes.add(43244);<br/><br/>System.<em class="od">out</em>.println("Reading file using File Input Stream");<br/><br/>while (sc.hasNextLine()) {<br/>   String line = sc.nextLine();<br/>   lines++;</span><span id="5a92" class="nd jo iq ns b gy ob ny l nz oa">   // get all the names<br/>   String array1[] = line.split("\\s*\\|\\s*");<br/>   String name = array1[7];</span><span id="9095" class="nd jo iq ns b gy ob ny l nz oa">   names.add(name);<br/>   if (indexes.contains(lines)) {<br/>      System.<em class="od">out</em>.println("Name: " + names.get(lines - 1) + " at<br/>      index: " + (lines - 1));<br/>   } <br/>   ...<br/>}</span></pre><p id="1e2e" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">请求二:完成。</p><p id="6582" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">任务3:统计每个月有多少捐款</strong></p><p id="3dac" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">当我接近捐赠计数请求时，我想做的不仅仅是按月计数捐赠，我还想按月和年计数，因为我有2017年和2018年的捐赠。</p><p id="cfa6" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我做的第一件事是建立一个初始数组列表来保存我所有的日期:<code class="fe np nq nr ns b">ArrayList&lt;String&gt; dates = new ArrayList&lt;&gt;();</code></p><p id="1a25" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">然后，我取每行中的第5个元素，即原始日期，并使用<code class="fe np nq nr ns b">substring()</code>方法提取每笔捐赠的月份和年份。</p><p id="65af" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我将每个日期重新格式化成更容易阅读的日期，并将它们添加到新的<code class="fe np nq nr ns b">dates</code>数组列表中。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="bbb2" class="nd jo iq ns b gy nx ny l nz oa">String rawDate = array1[4];<br/>String month = rawDate.substring(4, 6);<br/>String year = rawDate.substring(0, 4);<br/>String formattedDate = month + "-" + year;<br/>dates.add(formattedDate);</span></pre><p id="a23b" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在我收集了所有的日期之后，我创建了一个HashMap来保存我的日期:<code class="fe np nq nr ns b">HashMap&lt;String, Integer&gt; dateMap = new HashMap&lt;&gt;();</code>，然后遍历<code class="fe np nq nr ns b">dates</code>列表，或者将日期作为键添加到HashMap中(如果它们还不存在的话)，或者增加它们的值计数(如果它们确实存在的话)。</p><p id="1d9f" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">一旦创建了散列表，我就通过另一个<code class="fe np nq nr ns b">for</code>循环运行新的映射，以获取每个对象的键和值，并打印到控制台。瞧。</p><p id="2ffb" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">日期结果没有按照任何特定的顺序排序，但是如果需要的话，可以通过将HashMap转换回ArrayList或LinkedList来排序。我选择不这样做，因为这不是一个要求。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="60fd" class="nd jo iq ns b gy nx ny l nz oa">HashMap&lt;String, Integer&gt; dateMap = new HashMap&lt;&gt;();<br/>for (String date : dates) {<br/>   Integer count = dateMap.get(date);<br/>   if (count == null) {<br/>      dateMap.put(date, 1);<br/>   } else {<br/>      dateMap.put(date, count + 1);<br/>   }<br/>}</span><span id="b6b4" class="nd jo iq ns b gy ob ny l nz oa">for (Map.Entry&lt;String, Integer&gt; entry : dateMap.entrySet()) {<br/>   String key = entry.getKey();<br/>   Integer value = entry.getValue();<br/>   System.<em class="od">out</em>.println("Donations per month and year: " +<br/>   entry.getKey() + " and donation count: " + entry.getValue());<br/><br/>}</span></pre><p id="6f80" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">请求三:完成。</p><p id="3847" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">任务4:确定最常见的名字&amp;出现的频率</strong></p><p id="ca84" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">第四个请求是只获取所有名字，并找出最常出现的名字，这是最棘手的。</p><p id="104e" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">它要求我首先检查<code class="fe np nq nr ns b">names</code>数组是否包含逗号(有些企业名称没有逗号)，然后检查逗号上的<code class="fe np nq nr ns b">split()</code>名称和<code class="fe np nq nr ns b">trim()</code>中任何多余的空格。</p><p id="215e" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">一旦清理完毕，我必须检查名字的前半部分是否有空格(意思是这个人有名字和中间名，或者可能有一个类似“女士”的名字)，如果有，再次<code class="fe np nq nr ns b">split()</code>，并<code class="fe np nq nr ns b">trim()</code>到新创建的数组的第一个元素(我认为几乎总是名字)。</p><p id="3c81" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果名字的前半部分没有空格，它将被添加到<code class="fe np nq nr ns b">firstNames</code>数组列表中。我就是这样从文件中收集到所有名字的。请参见下面的代码片段。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="b0e8" class="nd jo iq ns b gy nx ny l nz oa">// count the occurrences of first name<br/>ArrayList&lt;String&gt; firstNames = new ArrayList&lt;&gt;();<br/><br/>System.<em class="od">out</em>.println("Reading file using File Input Stream");<br/><br/>    while (sc.hasNextLine()) {<br/>        String line = sc.nextLine();<br/><br/>        // get all the names<br/>        String array1[] = line.split("\\s*\\|\\s*");<br/>        String name = array1[7];<br/>        names.add(name);<br/><br/>        if (name.contains(", ")) {<br/>            String array2[] = (name.split(", "));<br/>            String firstHalfOfName = array2[1].trim();<br/>  <br/>            if (firstHalfOfName != <em class="od">undefined </em>||<br/>                !firstHalfOfName.isEmpty()) {<br/>                     if (firstHalfOfName.contains(" ")) {<br/>                       String array3[] = firstHalfOfName.split(" ");<br/>                       String firstName = array3[0].trim();<br/>                       firstNames.add(firstName);<br/>                     } else {<br/>                        firstNames.add(firstHalfOfName);<br/>                     }<br/>                  }<br/>               }</span></pre><p id="533f" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">一旦我收集了所有我能收集到的名字，并且读取文件的<code class="fe np nq nr ns b">while</code>循环已经结束，就该对名字进行排序并找到最常见的一个了。</p><p id="87ff" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">为此，我创建了另一个新的HashMap: <code class="fe np nq nr ns b">HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</code>，然后遍历所有的名字，如果这个名字在Map中不存在，它就被创建为map的键，值被设置为1。如果这个名字已经存在于HashMap中，那么这个值就增加1。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="995c" class="nd jo iq ns b gy nx ny l nz oa">HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();<br/>for (String name : firstNames) {<br/>   Integer count = map.get(name);<br/>   if (count == null) {<br/>      map.put(name, 1);<br/>   } else {<br/>      map.put(name, count + 1);<br/>   }<br/>}</span></pre><p id="c3a6" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">但是等等——还有更多！一旦我们有了HashMap(本质上是无序的),就需要从最大值到最小值对它进行排序，以获得最常出现的名字，所以我将HashMap中的每个条目转换成一个LinkedList，可以对它进行排序和迭代。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="e13d" class="nd jo iq ns b gy nx ny l nz oa">LinkedList&lt;Entry&lt;String, Integer&gt;&gt; list = new LinkedList&lt;&gt;(map.entrySet());</span></pre><p id="cb91" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">最后，使用<code class="fe np nq nr ns b">Collections.sort()</code>方法对列表进行排序，并调用<code class="fe np nq nr ns b">Comparator interface</code>根据名称对象的值计数对其进行降序排序(最大值在前)。看看这个。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="ae92" class="nd jo iq ns b gy nx ny l nz oa">Collections.<em class="od">sort</em>(list, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()<br/>  {<br/>     public int compare(Map.Entry&lt;String, Integer&gt; o1,<br/>     Map.Entry&lt;String, Integer&gt; o2) {<br/>         return (o2.getValue()).compareTo(o1.getValue());<br/>       }<br/>  });</span></pre><p id="ba0e" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">一旦所有这些都完成了，LinkedList的第一个键值对就可以取出来显示给用户了。这是从文件中读出所有名字后整理出来的全部内容。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="1390" class="nd jo iq ns b gy nx ny l nz oa">HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();<br/>for (String name : firstNames) {<br/>   Integer count = map.get(name);<br/>   if (count == null) {<br/>      map.put(name, 1);<br/>   } else {<br/>      map.put(name, count + 1);<br/>   }<br/>}<br/><br/>LinkedList&lt;Entry&lt;String, Integer&gt;&gt; list = new LinkedList&lt;&gt;(map.entrySet());<br/><br/>Collections.<em class="od">sort</em>(list, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()<br/>  {<br/>     public int compare(Map.Entry&lt;String, Integer&gt; o1,<br/>     Map.Entry&lt;String, Integer&gt; o2) {<br/>         return (o2.getValue()).compareTo(o1.getValue());<br/>       }<br/>  });</span><span id="6fcf" class="nd jo iq ns b gy ob ny l nz oa">System.<em class="od">out</em>.println("The most common first name is: " + list.get(0).getKey() + " and it occurs: " + list.get(0).getValue() + " times.");</span></pre><p id="6773" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">请求4(可以说是所有任务中最复杂的):完成。</p><p id="d333" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">很好，现在我已经给了你我的大脑在Java中的逻辑独白，我可以给你更快的概述我尝试的从文件中读取文本数据的其他两种方法。(因为代码的逻辑部分完全一样。)</p><h2 id="077e" class="nd jo iq bd jp ne nf dn jt ng nh dp jx li ni nj kb lm nk nl kf lq nm nn kj no bi translated"><strong class="ak">Java</strong><a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html" rel="noopener ugc nofollow" target="_blank"><strong class="ak">buffered reader()</strong></a><strong class="ak">&amp;</strong><a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/?java/io/FileReader.html" rel="noopener ugc nofollow" target="_blank"><strong class="ak">FileReader()</strong></a><strong class="ak">实现</strong></h2><p id="eaa3" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">我的第二个解决方案涉及到Java的另外两个核心方法:<code class="fe np nq nr ns b">BufferedReader()</code>和<code class="fe np nq nr ns b">FileReader()</code>。</p><p id="e8c7" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">BufferedReader从字符输入流中读取文本，缓冲字符以提供对字符、数组和行的有效读取，它包装在FileReader方法周围，FileReader方法是读取指定文本文件的实际方法。BufferedReader使FileReader的操作更加高效，仅此而已。</p><p id="2112" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">BufferedReader的方法<code class="fe np nq nr ns b">readLine()</code>实际上是读回从流中读取的每行文本，允许我们提取所需的数据。</p><p id="3e7d" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">设置类似于FileInputStream和Scanner你可以在下面看到如何实现BufferedReader和FileReader。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="5377" class="nd jo iq ns b gy nx ny l nz oa">File f = new File("src/main/resources/config/test.txt");<br/><br/>try (BufferedReader b = new BufferedReader(new FileReader(f))) { <br/>   String readLine = "";<br/>   do some things ...</span><span id="2102" class="nd jo iq ns b gy ob ny l nz oa">   while ((readLine = b.readLine()) != null) { <br/>     do some more things...<br/>   } </span><span id="9cfa" class="nd jo iq ns b gy ob ny l nz oa">do some final things<br/>}</span></pre><p id="eb5a" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这里是我使用<code class="fe np nq nr ns b">BufferedReader()</code>和<code class="fe np nq nr ns b">FileReader()</code>的完整代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oe"><img src="../Images/79660614600effc35e9454a213a5ee12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IfTR8-2aLwCNEXM3LWeMJg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">BufferedReader()和FileReader()逐行流过文本数据。</figcaption></figure><p id="1ec0" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">但是，除了BufferedReader和FileReader实现之外，其中的所有逻辑都是相同的，所以现在我将继续讨论我的最后一个Java文件读取器实现:FileUtils.LineIterator。</p><h2 id="25b6" class="nd jo iq bd jp ne nf dn jt ng nh dp jx li ni nj kb lm nk nl kf lq nm nn kj no bi translated"><strong class="ak">Apache Commons IO</strong><a class="ae me" href="https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/LineIterator.html" rel="noopener ugc nofollow" target="_blank"><strong class="ak">FileUtils。LineIterator() </strong> </a> <strong class="ak">实现</strong></h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi of"><img src="../Images/4e2b4d8186af17084f25e032f9dbc46f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nr82T5k_C2TN8P9aQLoPw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">Apache负责这个方便的库。</figcaption></figure><p id="aa49" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我想到的最后一个解决方案涉及Apache制作的库，名为<code class="fe np nq nr ns b">FileUtils.LineIterator()</code>。包含依赖关系很容易。我在我的Java项目中使用了Gradle，所以我所要做的就是在我的<code class="fe np nq nr ns b">build.gradle</code>文件中包含<code class="fe np nq nr ns b">commons-io</code>库。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi og"><img src="../Images/311c9db26a881f03bc169073d4b4e28b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjYwhagi_RYSlUQoq8nrPQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">这是您需要为FileUtils.lineIterator()方法包含的依赖项。它不是内置在核心Java中的。</figcaption></figure><p id="4f92" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">LineIterator，顾名思义:它保存一个对open <code class="fe np nq nr ns b">Reader</code>的引用(就像我上一个解决方案中的<code class="fe np nq nr ns b">FileReader</code>),并遍历文件中的每一行。而且一开始设置LineIterator真的很容易。</p><p id="1e33" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">LineIterator有一个名为<code class="fe np nq nr ns b">nextLine()</code>的内置方法，它实际上返回包装阅读器中的下一行(与Scanner的<code class="fe np nq nr ns b">nextLine()</code>方法或BufferedReader的<code class="fe np nq nr ns b">readLine()</code>方法没有什么不同)。</p><p id="979b" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">下面是包含依赖库后设置<code class="fe np nq nr ns b">FileUtils.LineIterator()</code>的代码。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="1443" class="nd jo iq ns b gy nx ny l nz oa">File f = new File("src/main/resources/config/test.txt");<br/><br/>try {<br/>   LineIterator it = FileUtils.<em class="od">lineIterator</em>(f, "UTF-8"); <br/>   do some things ...</span><span id="7ec2" class="nd jo iq ns b gy ob ny l nz oa">   while (it.hasNext()) {<br/>      String line = it.nextLine(); <br/>      do some other things ...<br/>   }</span><span id="e6b0" class="nd jo iq ns b gy ob ny l nz oa">   do some final things<br/>}</span></pre><p id="affd" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这里是我使用<code class="fe np nq nr ns b">FileUtils.LineIterator()</code>的完整代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oh"><img src="../Images/d95024f43a2781eae761f8906739690d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-KQJ-RhtzLNnG6c9wROzQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">FileUtils。LineIterator()逐行读取文本数据。</figcaption></figure><p id="3e5b" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">注意:</strong>如果你在没有Spring Boot的帮助下运行一个普通的Java应用程序，有一点你需要注意。如果您想使用这个额外的Apache依赖库，您需要手动将它与您的应用程序的JAR文件捆绑到一个所谓的<strong class="kz ir"> fat JAR </strong>中。</p><blockquote class="oi oj ok"><p id="efa5" class="kx ky od kz b la lb lc ld le lf lg lh ol lj lk ll om ln lo lp on lr ls lt lu ij bi translated"><strong class="kz ir">fat jar(也称为uber jar)是一个自给自足的档案，包含运行应用程序所需的类和依赖项。</strong></p></blockquote><p id="9ae1" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">Spring Boot“自动地”将我们所有的依赖捆绑在一起，但它也有很多额外的开销和功能，对这个项目来说是完全不必要的，这就是为什么我选择不使用它。这使得项目变得不必要的繁重。</p><p id="ebbc" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在有可用的插件，但我只是想要一个快速简单的方法将我的一个依赖项与我的JAR捆绑在一起。所以我从Java Gradle插件修改了<em class="od"> jar </em>任务。默认情况下，该任务生成没有任何依赖关系的jar。</p><p id="709e" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我可以通过添加几行代码来覆盖这种行为。我只需要两样东西就能让它工作:</p><ul class=""><li id="c664" class="mp mq iq kz b la lb le lf li mr lm ms lq mt lu mu mv mw mx bi translated">清单文件中的一个<em class="od"> Main-Class </em>属性(检查，出于测试目的，我在演示报告中有三个主类文件)</li><li id="0b54" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">以及任何依赖关系jar</li></ul><p id="ad20" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">感谢<a class="ae me" href="https://www.baeldung.com/gradle-fat-jar" rel="noopener ugc nofollow" target="_blank"> Baeldung </a>帮忙制作这个肥罐子。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oo"><img src="../Images/ad7550d452bbb52ceac78ffa2b9e8584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGCyd8U4O0xERToOdlc9SA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">制造一个大罐子的代码——这是一个Java术语。</figcaption></figure><p id="0af4" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">一旦定义了主类文件(在我的<a class="ae me" href="https://github.com/paigen11/read-file-java" rel="noopener ugc nofollow" target="_blank">演示报告</a>中，我创建了三个主类文件，这让我的IDE困惑不已)并且包含了依赖项，您可以从终端运行<code class="fe np nq nr ns b">./gradlew assemble</code>命令，然后:</p><p id="b1e4" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe np nq nr ns b">java -cp ./build/libs/readFileJava-0.0.1-SNAPSHOT.jar com.example.readFile.readFileJava.ReadFileJavaApplicationLineIterator</code></p><p id="d156" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">并且您的程序应该运行包含的LineIterator库。</p><p id="c4ae" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果您使用IntelliJ作为您的IDE，您也可以在本地使用它的运行配置，将每个主文件指定为正确的主类，它也应该运行这三个程序。查看我的README.md了解更多信息。</p><p id="4aed" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">很好，现在我有三种不同的方法来读取和处理Java中的大型文本文件，我的下一个任务是:找出哪种方法更高效。</p><h1 id="4de6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我如何评估他们的表现和结果</h1><p id="eda4" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">为了对我的不同Java应用程序和其中的函数进行性能测试，我在Java 8中遇到了两个方便的现成函数:<code class="fe np nq nr ns b">Instant.now()</code>和<code class="fe np nq nr ns b">Duration.between()</code>。</p><p id="687c" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我想做的是看看读取同一文件的不同方式之间是否有任何可测量的差异。因此，除了不同的文件读取选项:FileInputStream、BufferedReader和LineIterator之外，我试图让代码(以及标记每个函数开始和停止的时间戳)尽可能地相似。我觉得效果很好。</p><p id="bf84" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe np nq nr ns b"><a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir">Instant.now()</strong></a></code></p><p id="fc9b" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">Instant.now()正如它的名字所暗示的那样:它保存时间轴上的一个瞬时点，存储为代表纪元秒的<code class="fe np nq nr ns b">long</code>和代表纳秒秒的<code class="fe np nq nr ns b">int</code>。这本身并不是非常有用，但是当它与Duration.between()结合使用时，就变得非常有用了。</p><p id="505a" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe np nq nr ns b"><a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir">Duration.between()</strong></a></code></p><p id="ae70" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">Duration.between()接受一个开始间隔和一个结束间隔，并查找这两个时间之间的持续时间。就是这样。时间可以转换成各种不同的可读格式:毫秒、秒、分钟、小时等等。</p><p id="e550" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">下面是一个在我的文件中实现Instant.now()和Duration.between()的例子。这个是计时获取整个文件的行数需要多长时间。</p><pre class="km kn ko kp gt nt ns nu nv aw nw bi"><span id="c3d9" class="nd jo iq ns b gy nx ny l nz oa">try {<br/>         LineIterator it = FileUtils.<em class="od">lineIterator</em>(f, "UTF-8");<br/><br/>         // get total line count<br/>         Instant lineCountStart = Instant.<em class="od">now</em>();<br/>         int lines = 0;<br/>         <br/>         System.<em class="od">out</em>.println("Reading file using Line Iterator");<br/><br/>         while (it.hasNext()) {<br/>            String line = it.nextLine();<br/>            lines++;<br/><br/>         }<br/><br/>         System.<em class="od">out</em>.println("Total file line count: " + lines);<br/>         Instant lineCountEnd = Instant.<em class="od">now</em>();<br/>         <br/>         long timeElapsedLineCount =<br/>         Duration.<em class="od">between</em>(lineCountStart, lineCountEnd).toMillis();<br/>         <br/>         System.<em class="od">out</em>.println("Line count time: " +<br/>         timeElapsedLineCount + "ms");<br/><br/>      } <br/>   }</span></pre><h2 id="7069" class="nd jo iq bd jp ne nf dn jt ng nh dp jx li ni nj kb lm nk nl kf lq nm nn kj no bi translated">结果</h2><p id="1dbd" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">下面是将<code class="fe np nq nr ns b">Instant.now()</code>和<code class="fe np nq nr ns b">Duration.between()</code>应用到Java中所有不同的文件读取方法后的结果。</p><p id="67b9" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我针对2.55GB的文件运行了我的三个解决方案，该文件总共包含1300多万行。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi op"><img src="../Images/bc95055915519e8d5df45bd18289373f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9u5PPKHcyC68EEMjPEDLyg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">LineIterator勉强击败BufferedReader，两者都轻松击败FileInputStream。</figcaption></figure><p id="1257" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">正如你从表中看到的，<code class="fe np nq nr ns b">BufferedReader()</code>和<code class="fe np nq nr ns b">LineIterator()</code>都进行得很好，但是他们的计时非常接近，这似乎取决于他们更愿意使用哪个开发者。</p><p id="fb40" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe np nq nr ns b">BufferedReader()</code>很好，因为它不需要额外的依赖，但是一开始设置起来稍微复杂一点，因为要用<code class="fe np nq nr ns b">FileReader()</code>来包装。而<code class="fe np nq nr ns b">LineIterator()</code>是一个外部库，但是在它作为一个依赖项被包含进来之后，它使得迭代文件变得非常容易。</p><p id="5d5d" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">上表末尾也列出了改进的百分比，以供参考。</p><p id="4ee9" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">有趣的是，被另外两个人轰出了水面。通过缓冲数据流或使用专门用于迭代文本文件的库，所有任务的性能提高了约73%。</p><p id="f257" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">以下是我的每个解决方案在终端上的原始截图。</p><p id="b2f6" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">方案一:</strong> <code class="fe np nq nr ns b"><strong class="kz ir">FileInputStream()</strong></code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oq"><img src="../Images/5b6842abd2973fd27d22e88e4df33707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rrhu0Nh1CjKW6tD-IM0Gmw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">使用FileInputStream()和Scanner()的解决方案。</figcaption></figure><p id="cd34" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">解决方案#2: </strong> <code class="fe np nq nr ns b"><strong class="kz ir">BufferedReader()</strong></code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi or"><img src="../Images/8fffef53b76a96150769466694793ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BS-GWu8iM6irykvQ2Ax4Xg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">使用BufferedReader()和FileReader()的解决方案。</figcaption></figure><p id="0b3c" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">解决方案#3: </strong> <code class="fe np nq nr ns b"><strong class="kz ir">FileUtils.lineIterator()</strong></code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi os"><img src="../Images/9dddd6fa67f79a1574ded2e9bb012400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8lnHJdH5Zh2NGKkYMucIg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">使用FileUtils.lineIterator()的解决方案。</figcaption></figure><h1 id="a238" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="2b06" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">最后，缓冲流和自定义文件读取库是在Java中处理大型数据集的最有效方式。至少对于我负责阅读的大型文本文件来说是这样。</p><p id="95c1" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">感谢阅读我的关于使用Java读取非常非常大的文件的帖子。如果你想看Node.js上激发这篇文章的原始帖子，你可以在这里看到第1部分<a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/using-node-js-to-read-really-really-large-files-pt-1-d2057fe76b33">，在这里</a>看到第2部分<a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/streams-for-the-win-a-performance-comparison-of-nodejs-methods-for-reading-large-datasets-pt-2-bcfa732fa40e?source=friends_link&amp;sk=11818162d84e2888187ed2b57b9e0118">。</a></p><p id="251f" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">过几周再来看看，我会用Express.js写关于Swagger的文章或者其他与web开发&amp; JavaScript相关的东西，所以请关注我，这样你就不会错过了。</p><p id="4578" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你想确保你不会错过我写的一篇文章，在这里注册我的时事通讯:<a class="ae me" href="https://paigeniedringhaus.substack.com/" rel="noopener ugc nofollow" target="_blank">https://paigeniedringhaus.substack.com</a></p><p id="09f4" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">感谢您的阅读，我希望这能让您了解如何用Java高效地处理大量数据，并对您的解决方案进行性能测试。非常感谢鼓掌和分享！</p><p id="043f" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他一些博客:</p><ul class=""><li id="d6b9" class="mp mq iq kz b la lb le lf li mr lm ms lq mt lu mu mv mw mx bi translated"><a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/using-node-js-to-read-really-really-large-files-pt-1-d2057fe76b33">使用Node.js读取非常非常大的数据集&amp;文件(Pt 1) </a></li><li id="e269" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/keep-code-consistent-across-developers-the-easy-way-with-prettier-eslint-60bb7e91b76c">用最简单的方法保持开发人员之间的代码一致——用更漂亮的&amp; ESLint </a></li><li id="0ea5" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/the-absolute-easiest-way-to-debug-node-js-with-vscode-2e02ef5b1bad">调试Node.js最简单的方法——用VS代码</a></li></ul></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><p id="8702" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">参考资料和更多资源:</strong></p><ul class=""><li id="0e19" class="mp mq iq kz b la lb le lf li mr lm ms lq mt lu mu mv mw mx bi translated">Github，在Java Repo中读取文件:<a class="ae me" href="https://github.com/paigen11/read-file-java" rel="noopener ugc nofollow" target="_blank">https://github.com/paigen11/read-file-java</a></li><li id="dce6" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">链接到外汇券数据:<a class="ae me" href="https://www.fec.gov/files/bulk-downloads/2018/indiv18.zip" rel="noopener ugc nofollow" target="_blank">https://www.fec.gov/files/bulk-downloads/2018/indiv18.zip</a></li><li id="9e1d" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">Oracle Java文档，文件输入流:<a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/?java/io/FileInputStream.html" rel="noopener ugc nofollow" target="_blank">https://docs.oracle.com/javase/8/docs/api/?Java/io/file inputstream . html</a></li><li id="90d7" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">Oracle Java文档，Scanner:<a class="ae me" href="https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/7/docs/API/Java/util/Scanner . html</a></li><li id="a915" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">Oracle Java文档，buffered reader:<a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/io/buffered reader . html</a></li><li id="9418" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">Oracle Java文档，文件阅读器:<a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/?java/io/FileReader.html" rel="noopener ugc nofollow" target="_blank">https://docs.oracle.com/javase/8/docs/api/?java/io/FileReader.html </a></li><li id="51de" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">Apache Commons Java文档，line iterator:<a class="ae me" href="https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/LineIterator.html" rel="noopener ugc nofollow" target="_blank">https://Commons . Apache . org/proper/Commons-io/javadocs/API-2.5/org/Apache/Commons/io/line iterator . html</a></li><li id="ca13" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">贝尔东，在格拉德创造一个胖罐子:<a class="ae me" href="https://www.baeldung.com/gradle-fat-jar" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/gradle-fat-jar</a></li><li id="d879" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">Oracle Java文档，即时:<a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/time/Instant . html</a></li><li id="4cd4" class="mp mq iq kz b la my le mz li na lm nb lq nc lu mu mv mw mx bi translated">Oracle Java文档，时长:<a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/time/Duration . html</a></li></ul></div></div>    
</body>
</html>