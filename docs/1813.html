<html>
<head>
<title>MVP: Model View Presenter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVP:模型视图演示者</h1>
<blockquote>原文：<a href="https://itnext.io/mvp-model-view-presenter-8d3654d8fa4c?source=collection_archive---------0-----------------------#2019-02-04">https://itnext.io/mvp-model-view-presenter-8d3654d8fa4c?source=collection_archive---------0-----------------------#2019-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="960d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">iOS或MacOS应用程序在Swift中的可能实施构想</p><h2 id="f007" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">您可以从这里下载我们将要创建的整个项目:</h2><p id="28c7" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated"><a class="ae lj" href="https://github.com/landhgames/mvp-expense" rel="noopener ugc nofollow" target="_blank">https://github.com/landhgames/mvp-expense</a></p><h1 id="ca2e" class="lk km iq bd kn ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx ly lz lc ma bi translated"><strong class="ak">简介</strong></h1><p id="99a4" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">1969年，人类登上了月球。为了这个非常复杂的任务，美国国家航空航天局聘请了麻省理工学院，委托他们建造阿波罗制导计算机(AGC)的项目，当然，还有在这台机器上运行的软件，将宇航员带到月球。与现代的iPhone(甚至不那么现代的iPhone 6)相比，AGC功能更弱！</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/bf4374c484b908b806575245f7225f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*JkRkEfsrn8n8TyXdZJ7SVA.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图一。AGC vs iPhone(这是西班牙语，但是你懂的)</figcaption></figure><p id="4607" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然iPhone比AGC强大很多倍，但在月球之旅中，你会信任哪个计算机系统？答案是(或者至少是我的)AGC及其软件！但是..等等！为什么有人会选择这样一台功能如此之弱的计算机呢？</p><p id="3c2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">测试</strong></p><p id="26ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原因是:很难保证AGC软件-硬件的效率和性能，不仅是因为硬件的可靠性，更重要的是因为软件的可靠性，因为NASA在软件开发中使用非常高的标准。他们有两个团队一起工作，一个团队编写一行代码，另一个团队测试这一行代码中的错误。(…)开发组织对单个模块进行内部代码审查和单元测试，然后对组装成软件负载的模块组进行集成测试</p><p id="50a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在我们的代码中达到如此高的效率标准，我们有一个非常强大的工具:单元测试。这个工具保证了我们代码的质量。它帮助我们测试软件的关键组件，并确保我们的代码做了设计要做的事情。</p><p id="c884" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还承诺帮助我们停止引入新的错误，避免倒退。那么，一旦我们决定开始实现单元测试，我们应该测试代码的哪些部分呢？</p><p id="c880" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在寻找测试内容的过程中，我找到了几本书，它们承诺会对我有所帮助:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/64c5ced8b4cd7e4718166007b654322e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*pFNQUDuXHZHLfXbzRQUosQ.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图2(其实不是推荐书籍)</figcaption></figure><p id="9469" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中一个人说:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/9985c8de6b84600523c4c362d5efff83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovLAh3l-Mqtwnv4CG4sHOg.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图3测试内容的一个不太有趣的想法</figcaption></figure><p id="75af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mn">“视图控制器的主要职责是确保表格视图连接到其数据源和委托，以便表格有事可做(…)”</em></p><p id="d877" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以添加一个测试来确保UITableView既有它的委托又有它的Datasource集将帮助我找到错误并停止回归？事实是，不！这不会帮助你发现错误和停止回归，这样的测试将是非常琐碎的，可以通过其他工具来解决，如UI测试，如<a class="ae lj" href="https://github.com/uber/ios-snapshot-test-case/" rel="noopener ugc nofollow" target="_blank">iosnapshottestcase</a>。</p><p id="c3d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题的答案是，在你正在编写的应用程序之下，应该有一个坚实而强大的设计。根本不使用任何设计可能会导致不可测试的代码。</p><p id="bd7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> MVC重述</strong></p><p id="ce46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不会深入MVC的细节，但我假设iOS和OSX的大多数Swift开发人员对这种设计模式都有些熟悉，因为编程工具和语言文档在iOS/OSX开发人员形成的最开始就提到了这种模式。</p><p id="66d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">设计模式作为工具</strong></p><p id="dcc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为帮助我们创建UI应用程序的“官方”设计模式，MVC还有其他几种模式。重要的是要注意，没有一个单一的“银弹”或独特的解决方案可以满足每个开发人员的需求。有几个，重要的是一个好的开发人员了解工具箱中的所有工具，知道在给定的程序中使用哪种模式，甚至知道在同一个应用程序中使用不同的模式。</p><p id="ff48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每种设计模式都有自己的优点和缺点、优势和劣势，以及在实现给定技术之前明智地考虑的开销。所有这些都应该被考虑并熟练运用，<em class="mn">强大的力量伴随着巨大的责任</em>。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mu"><img src="../Images/30c696dbc1329f4206c32e250cdb3c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_mHIIJdn4qzDx9nO_9X_Q.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图4。设计模式作为解决不同问题的工具</figcaption></figure><p id="8bf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> MVP:模型视图演示者</strong></p><p id="81e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MVP代表Model View Presenter，是由微软的Martin Fouler在20世纪90年代发明的(尽管有些人声称这实际上是在更早之前发明的；他们不总是这样吗？).</p><p id="8e40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与MVC一样，MVP使用Swift开发人员熟悉的几个组件，从视图开始。</p><p id="6158" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">视图(或实际上)视图控制器</strong></p><p id="ecf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视图组件具有与MVC实现中相同的职责。处理用户界面。在iOS和OSX开发中，我们不可分割地使用视图和UIViewController，这就构成了面向对象编程中“视图”的概念。</p><p id="ef4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为这个故事最重要的寓意之一是<em class="mn">我们想要创建一个如此愚蠢的视图控制器，以至于测试它几乎没有意义</em>。至少在做MVP的时候。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mv"><img src="../Images/487c06717fbc1994a3149e153ca8fef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JL9_mr54c-i3OSW1kgfCdw.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图5。MVP组件</figcaption></figure><p id="3d6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">型号</strong></p><p id="6c82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与MVC一样，模型代表了我们的程序所处理的抽象。这可以是抽象的实体，例如:用户、销售、产品等。我们用现实世界中的任何抽象来建模我们的程序。它可能是来自我们的应用程序正在消费的某个服务的类型。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mw"><img src="../Images/20ef6c94151f1c60d466c7dbc30c7987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cFRIxhuVU07lqO0txZJMA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图6。MVP组件(更广泛的观点)</figcaption></figure><p id="bddc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">演示者</strong></p><p id="31c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">表示者是一个抽象的实体，包含应用程序的业务逻辑，完全不知道实际的服务实现。MVP模式允许我们将ViewController从presenter中分离出来，然后再将Presenter从服务中分离出来。</p><p id="7b41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ViewController必须实例化服务和表示器，并将服务注入到表示器中。这个Presenter实体将成为测试实际程序的完美候选。</p><p id="aa06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它应该是这样工作的:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mx"><img src="../Images/bc849a1c9127a01c7f745098558f815c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTz4MBFPAgvOLo710rHOsA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图7。MVP组件之间的交互</figcaption></figure><p id="0e6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ViewController将引用presenter，并将用户与UI的任何可能的交互通知给presenter。如果演示者想要改变UI/UX中的某些内容，他必须请求ViewController进行更新。演示者还将在ViewController和服务(网络、数据库等)之间进行协调。</p><p id="c1e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">足够的理论，让我们开始看看这是什么样子，以及一个实际的项目可以做什么。因此，我们一如既往地使用同一个应用程序:一个帮助我们记录开销的应用程序。</p><p id="b8d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们看看ViewController是什么样子的:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="be19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，与普通的ViewController没有什么不同，除了:</p><ul class=""><li id="97ed" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated">它在第5行和第6行中包含了loginPresenter和loginService的变量</li><li id="7387" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">在ViewDidLoad中(第11行到第14行),我们为呈现者创建了实际的实例，我们还注入了实际的服务</li><li id="3fb1" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">在didPressLogin按钮中，我们检查一切都已正确完成(如果没有显示错误消息)，但是如果没问题，我们就调用<strong class="jp ir"><em class="mn">func loginUserSaveSessionAndGetUserList()</em></strong>，它当然位于Presenter中，并(顾名思义)尝试登录用户。如果不能，它还会显示一个警报。</li></ul><p id="a109" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看演示者的样子:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2da7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，演示者和视图控制者是完全不同的生物。</p><ul class=""><li id="ac7c" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated">LoginPresenter似乎根本不处理UI的东西，它的函数非常干净，只接受它们需要的参数(大部分是字符串，没有花哨的IBOutlets或类似的东西，没有UIKit的东西)</li><li id="1d0f" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">它有一个<strong class="jp ir"> init </strong>，简单地将服务设置为它的成员变量，还有两个函数，基本上是服务，或者实际上是从ViewController中调用和使用的Presenter API</li><li id="f083" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">最终，演示者内部的方法将调用转发给服务(例如在<strong class="jp ir"><em class="mn">func loginUserSaveSessionAndGetUserList()</em></strong>的情况下),但它也检查结果，如果一切顺利，它将用户保存在会话对象中。夏威夷大学（TheUniversityofHawaiiatManoa）..</li><li id="f6b2" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated"><strong class="jp ir"><em class="mn">func get userlist(…)</em></strong>函数不执行任何检查，它只是将结果和错误发送到ViewController，这可能是因为在这一点上，演示者对该数据做些什么没有多大意义，尽管它可能会这样做。</li></ul><p id="ea50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">测试(续)</strong></p><p id="7569" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在剩下的问题是，我们应该测试什么？所有这些类和设计都非常花哨，(尽管它们可能会造成瓶颈并使代码更加复杂)，那么这样做有什么好处呢？正如前面提到的<strong class="jp ir"> <em class="mn">我们获得了</em> </strong>测试我们程序模型的能力。在我们的例子中，这将是演示者的功能。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在测试包中，我们创建了LoginServiceMock对象。这个服务基本上等同于真正的LoginService，但是(它实际上是它的一个子类),并将覆盖演示者从那个组件使用的方法。在这个LoginServiceMock中，我们将:</p><ul class=""><li id="561b" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated">检查模型是否被很好地初始化和解析</li><li id="9f98" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">检查(使用标志)方法是否确实被调用</li><li id="be50" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">保存我们可以从对象调用中推断出的任何新状态(这样我们以后就可以断言这些状态)</li></ul><p id="4ec4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们设置组件的其余部分，直到我们到达函数<strong class="jp ir"><em class="mn">【func testlogin flow()</em></strong>，在这里我们基本上调用服务内部的he方法，并断言服务内部的相应调用已经完成。</p><p id="e9c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">下载整个项目</strong></p><p id="0be9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里下载整个项目:<a class="ae lj" href="https://github.com/landhgames/mvp-expense" rel="noopener ugc nofollow" target="_blank">https://github.com/landhgames/mvp-expense</a></p><p id="f8b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题、建议或意见？你可以在推特上找到我。</p><p id="6219" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住，按住<em class="mn">喜欢</em>按钮，你可以留下任意多的喜欢；— )</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="5488" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">有用链接&amp;参考</strong></p><ul class=""><li id="f64d" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated">[1] <a class="ae lj" href="https://history.nasa.gov/computers/Ch4-5.html" rel="noopener ugc nofollow" target="_blank"> NASA航天飞机软件开发历史</a></li><li id="1a5d" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">[2] <a class="ae lj" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html" rel="noopener ugc nofollow" target="_blank">苹果公司的模型-视图-控制器</a></li><li id="0223" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">[3]<a class="ae lj" href="https://www.youtube.com/watch?v=amVstam84Xo" rel="noopener ugc nofollow" target="_blank">John Sundell——编写具有强大可测试性的Swift代码</a></li><li id="07fa" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated"><a class="ae lj" href="http://iyadagha.com/using-mvp-ios-swift/" rel="noopener ugc nofollow" target="_blank">哑用户界面是好用户界面:在iOS中使用MVP和swift </a></li></ul></div></div>    
</body>
</html>