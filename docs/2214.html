<html>
<head>
<title>Istio Observability with Go, gRPC, and Protocol Buffers-based Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Go、gRPC和协议缓冲区的微服务的Istio可观测性</h1>
<blockquote>原文：<a href="https://itnext.io/istio-observability-with-go-grpc-and-protocol-buffers-based-microservices-d09e34c1255a?source=collection_archive---------2-----------------------#2019-04-17">https://itnext.io/istio-observability-with-go-grpc-and-protocol-buffers-based-microservices-d09e34c1255a?source=collection_archive---------2-----------------------#2019-04-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5fd3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Jaeger、Zipkin、Prometheus、Grafana和Kiali在谷歌云的GKE和Istio服务网格上观察分布式系统</h2></div><p id="27c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最近的两篇文章中，<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-bed3dd0fac0b">基于Kubernetes的微服务与Istio服务网格的可观察性</a>和<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/azure-kubernetes-service-aks-observability-with-istio-service-mesh-4eb28da0f764"> Azure Kubernetes服务(AKS)与Istio服务网格的可观察性</a>，我们探讨了Istio服务网格中包含的可观察性工具。这些工具目前包括用于指标收集、监控和警报的<a class="ae le" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>和<a class="ae le" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>，用于分布式跟踪的<a class="ae le" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>，以及用于基于Istio服务网格的微服务可视化和监控的<a class="ae le" href="https://www.kiali.io/" rel="noopener ugc nofollow" target="_blank"> Kiali </a>。结合云平台原生的监控和日志服务，比如GCP上的<a class="ae le" href="https://cloud.google.com/monitoring/" rel="noopener ugc nofollow" target="_blank"> Stackdriver </a>，AWS上的<a class="ae le" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank"> CloudWatch </a>，Azure上的<a class="ae le" href="https://docs.microsoft.com/en-us/azure/azure-monitor/overview" rel="noopener ugc nofollow" target="_blank"> Azure Monitor </a> logs，我们就有了一套完整的现代、分布式、基于云的应用的可观测性解决方案。</p><p id="d863" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何使用Istio的可观察性工具来监控基于Go的微服务，这些微服务通过<a class="ae le" href="https://grpc.io" rel="noopener ugc nofollow" target="_blank"> gRPC </a> (gRPC远程过程调用)和<a class="ae le" href="https://en.wikipedia.org/wiki/HTTP/2" rel="noopener ugc nofollow" target="_blank"> HTTP/2 </a>使用<a class="ae le" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>(又名<em class="lf"> Protobuf </em>)进行客户端-服务器通信，而不是通过HTTP(超文本传输协议)使用更传统的基于REST的JSON (JavaScript对象表示法)。我们将看到Kubernetes、Istio、Envoy和observability工具如何与gRPC无缝协作，就像它们在<a class="ae le" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank">Google Kubernetes Engine</a>(GKE)上通过HTTP与JSON无缝协作一样。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/d078da0d4053a5225aad33f0ba536669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVWt1z7biUy1Kw3V9HHNhA.png"/></div></div></figure><h1 id="672c" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">技术</h1><h2 id="8ae3" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">gRPC</h2><p id="fc18" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">据<a class="ae le" href="https://grpc.io" rel="noopener ugc nofollow" target="_blank"> gRPC项目</a>介绍，<a class="ae le" href="https://www.cncf.io/" rel="noopener ugc nofollow" target="_blank"> CNCF </a>在孵项目gRPC是一个现代的、高性能的、开源的、通用的<a class="ae le" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank">远程过程调用</a> (RPC)框架，可以在任何地方运行。它使客户机和服务器应用程序能够透明地通信，并使构建连接的系统变得更加容易。gRPC的原始开发者Google已经使用gRPC中的底层技术和概念很多年了。当前的实现用于几个Google云产品和Google面向外部的API。它也被Square、网飞、CoreOS、Docker、CockroachDB、Cisco、Juniper Networks和许多其他组织使用。</p><h2 id="a449" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">协议缓冲区</h2><p id="c6ea" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">默认情况下，gRPC使用协议缓冲区。根据Google的说法，<a class="ae le" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a> ( <em class="lf">又名Protobuf </em>)是一种语言和平台中立的、高效的、可扩展的自动化机制，用于序列化结构化数据，以用于通信协议、数据存储等。协议缓冲区比XML小3到10倍，快20到100倍。一旦定义了消息，就可以在<code class="fe nb nc nd ne b">.proto</code>文件上运行应用程序语言的协议缓冲编译器来生成数据访问类。</p><blockquote class="nf ng nh"><p id="17cd" class="ki kj lf kk b kl km ju kn ko kp jx kq ni ks kt ku nj kw kx ky nk la lb lc ld im bi translated">协议缓冲区比XML小3到10倍，快20到100倍。</p></blockquote><p id="2d05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">协议缓冲区目前支持Java、Python、Objective-C和C++、Dart、Go、Ruby和C#中的生成代码。对于本帖，我们为Go编译了。你可以在Google的<a class="ae le" href="https://developers.google.com/protocol-buffers/docs/encoding" rel="noopener ugc nofollow" target="_blank">开发者门户</a>上阅读更多关于Protobuf的二进制wire格式。</p><h2 id="8a05" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">特使代理</h2><p id="1bb4" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">根据<a class="ae le" href="https://istio.io/docs/concepts/what-is-istio/#envoy" rel="noopener ugc nofollow" target="_blank"> Istio项目</a>，Istio使用了<a class="ae le" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a>代理的扩展版本。特使作为侧车部署到同一Kubernetes pod中的相关服务。由Lyft创建的Envoy是一个用C++开发的高性能代理，用于协调服务网格中所有服务的所有入站和出站流量。Istio利用Envoy的许多内置功能，包括动态服务发现、负载平衡、TLS终止、HTTP/2和gRPC代理、断路器、健康检查、分阶段部署、故障注入和丰富的指标。</p><p id="9f5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据Google的Harvey Tuch的文章<a class="ae le" href="https://blog.envoyproxy.io/evolving-a-protocol-buffer-canonical-api-e1b2c2ca0dec" rel="noopener ugc nofollow" target="_blank">Evolving a Protocol Buffer canonical API</a>，Envoy proxy采用了协议缓冲区，特别是<a class="ae le" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank"> proto3 </a>，作为Lyft的gRPC-first API版本2的规范规范。</p><h1 id="6d53" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">参考微服务平台</h1><p id="eee0" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">在前两篇文章中，我们探索了Istio的可观察性工具，使用了用Go编写的基于RESTful微服务的API平台，并使用JSON over HTTP进行服务到服务的通信。API平台由八个基于<a class="ae le" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go的</a>微服务和一个基于Angular 7 <a class="ae le" href="https://en.wikipedia.org/wiki/TypeScript" rel="noopener ugc nofollow" target="_blank">类型脚本的</a>前端web客户端组成。各种服务依赖于MongoDB和RabbitMQ进行基于事件队列的通信。下面，是基于HTTP的JSON平台架构。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nl"><img src="../Images/8d71ec0c29ab345ec4aa2fe96f1dd79c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSdUHacddypjAQQ3eueMmQ.png"/></div></div></figure><p id="1f22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面，当前基于Angular 7的web客户端界面。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/1c136e457f512177efabd46056f07f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptJ46gzI03ESsdJfMMS39A.png"/></div></div></figure><h1 id="2092" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">转换为gRPC和协议缓冲区</h1><p id="8baa" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">在这篇文章中，我修改了八个Go微服务，以使用谷歌的数据交换格式<a class="ae le" href="https://grpc.io" rel="noopener ugc nofollow" target="_blank"> gRPC </a>和<a class="ae le" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>。具体来说，服务使用版本3 <a class="ae le" href="https://github.com/protocolbuffers/protobuf/releases" rel="noopener ugc nofollow" target="_blank">版本</a>(又名<em class="lf"> proto3 </em>)的协议缓冲区。使用gRPC，gRPC客户端调用gRPC服务器。该平台的一些服务是gRPC服务器，另一些是gRPC客户端，还有一些同时充当客户端和服务器，如服务A、B和e。修改后的架构如下所示。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nm"><img src="../Images/8389b28a4087eb426af890c6f1a08da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-7udRZK9N4m_xx5sflBojQ.png"/></div></div></figure><h1 id="e44b" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">gRPC网关</h1><p id="89c3" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">为了演示起见，假设大多数API消费者仍然希望使用RESTful JSON over HTTP API进行通信，我已经为平台添加了一个<a class="ae le" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> gRPC Gateway </a>反向代理。gRPC网关是一个gRPC到JSON的反向代理，这是一个常见的架构模式，它代理基于HTTP的客户端上的JSON和基于gRPC的微服务之间的通信。来自<a class="ae le" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> grpc-gateway </a> GitHub项目站点的图表有效地展示了反向代理是如何工作的。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/d2be59bdc9267a3fae5b5a3f4378548e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*zQTQ1OoFDKbiraXB"/></div></figure><p id="3eab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lf">图片礼貌:</em><a class="ae le" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"><em class="lf">【https://github.com/grpc-ecosystem/grpc-gateway】</em></a></p><p id="242f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面修改后的平台架构图中，请注意反向代理的添加，它取代了API边缘的服务A。代理位于基于Angular的Web UI和服务a之间。另外，请注意，服务之间的通信方法现在是通过gRPC的Protobuf，而不是通过HTTP的JSON。Envoy代理的使用(通过Istio)没有变化，基于MongoDB Atlas的数据库和基于CloudAMQP RabbitMQ的队列也是如此，它们仍然在Kubernetes集群之外。</p><h2 id="a0f8" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">gRPC网关的替代方案</h2><p id="f14c" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">作为gRPC网关反向代理的替代方案，我们可以将基于TypeScript的Angular UI客户端转换为gRPC和协议缓冲区，并继续作为边缘服务与服务A直接通信。然而，这将限制API的其他消费者依赖gRPC，而不是HTTP上的JSON，除非我们也选择公开两个不同的端点gRPC和HTTP上的JSON，这是另一种常见的模式。</p><h1 id="ce94" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">示范</h1><p id="3255" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">在本文的演示中，我们将重复上一篇文章<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-bed3dd0fac0b">基于Kubernetes的微服务可观察性与Istio服务网格</a>中概述的相同安装过程。我们将在GCP的GKE部署修改后的基于gRPC的平台。您可以轻松地使用Istio服务网格遵循<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/azure-kubernetes-service-aks-observability-with-istio-service-mesh-4eb28da0f764"> Azure Kubernetes服务(AKS)的可观察性，并将平台部署到AKS。</a></p><h2 id="765e" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">源代码</h2><p id="e7dc" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">这篇文章的所有源代码都可以在GitHub上找到，包含在三个项目中。基于Go的微服务源代码、所有Kubernetes资源和所有部署脚本都位于新的<code class="fe nb nc nd ne b">grpc</code>分支中的<a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-backend" rel="noopener ugc nofollow" target="_blank">k8s-istio-observe-back end</a>项目存储库中。</p><pre class="lh li lj lk gt no ne np nq aw nr bi"><span id="1bda" class="mk lt it ne b gy ns nt l nu nv">git clone \ <br/>  <strong class="ne iu">--branch grpc</strong> --single-branch \<br/>  --depth 1 --no-tags \ <br/>  <a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-backend.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/k8s-istio-observe-backend.git</a></span></pre><p id="c968" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基于角度的web客户端源代码位于新的<code class="fe nb nc nd ne b">grpc</code>分支上的<a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-frontend" rel="noopener ugc nofollow" target="_blank">k8s-istio-observe-frontend</a>存储库中。源协议缓冲区<code class="fe nb nc nd ne b">.proto</code>文件和使用协议缓冲区编译器生成的代码位于新的<a class="ae le" href="https://github.com/garystafford/pb-greeting" rel="noopener ugc nofollow" target="_blank"> pb-greeting </a>项目存储库中。对于本文的演示，您不需要克隆这两个项目。</p><p id="5045" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">服务、UI和反向代理的所有Docker映像都位于<a class="ae le" href="https://hub.docker.com/search?q=%22garystafford&amp;type=image&amp;sort=updated_at&amp;order=desc" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>上。</p><h1 id="f608" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">代码更改</h1><p id="d54a" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">这篇文章不是专门为gRPC和Protobuf写Go的。然而，与HTTP上的JSON相比，为了更好地理解这些技术的可观察性需求和功能，回顾一些源代码是有帮助的。</p><h2 id="c6b0" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">微服务</h2><p id="f7e9" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">首先，将下面显示的<a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-backend/blob/grpc/services/service-a/main.go" rel="noopener ugc nofollow" target="_blank">服务A </a>的源代码与前一篇文章中的<a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-backend/blob/master/services/service-a/main.go" rel="noopener ugc nofollow" target="_blank">原始代码</a>进行比较。该服务的代码几乎完全重写。我依赖于几个参考资料来编写代码，包括:<a class="ae le" href="https://aspenmesh.io/2018/04/tracing-grpc-with-istio/" rel="noopener ugc nofollow" target="_blank">Aspen Mesh</a><a class="ae le" href="https://aspenmesh.io/" rel="noopener ugc nofollow" target="_blank">的Neeraj Poddar编写的使用Istio </a>跟踪gRPC，以及Masroor Hasan编写的<a class="ae le" href="https://medium.com/@masroor.hasan/tracing-infrastructure-with-jaeger-on-kubernetes-6800132a677" rel="noopener">使用Jaeger on Kubernetes </a>的分布式跟踪基础设施。</p><p id="0915" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">具体来说，请注意服务A的以下代码更改:</p><ol class=""><li id="42e3" class="nw nx it kk b kl km ko kp kr ny kv nz kz oa ld ob oc od oe bi translated">导入<a class="ae le" href="https://github.com/garystafford/pb-greeting" rel="noopener ugc nofollow" target="_blank"> pb-greeting </a> protobuf包；</li><li id="1fe0" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">本地问候语结构被替换为<code class="fe nb nc nd ne b">pb.Greeting</code>结构；</li><li id="7494" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">所有服务现在都托管在端口<code class="fe nb nc nd ne b">50051</code>上；</li><li id="a34a" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">HTTP服务器和所有API资源处理函数都被删除；</li><li id="b384" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">用于Jaeger分布式跟踪的头已经从HTTP请求对象转移到gRPC上下文对象中传递的元数据；</li><li id="3391" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">服务A编码为gRPC服务器，由gRPC网关反向代理(gRPC客户端)通过<code class="fe nb nc nd ne b">Greeting</code>函数调用；</li><li id="b019" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">返回服务问候的主要<code class="fe nb nc nd ne b">PingHandler</code>函数被<a class="ae le" href="https://github.com/garystafford/pb-greeting" rel="noopener ugc nofollow" target="_blank"> pb-greeting </a> protobuf包的<code class="fe nb nc nd ne b">Greeting</code>函数所取代；</li><li id="79b7" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">服务A编码为gRPC客户端，使用<code class="fe nb nc nd ne b">CallGrpcService</code>函数同时调用服务B和服务C；</li><li id="d767" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">CORS的处理工作交给了Istio</li><li id="9343" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">记录方法不变；</li></ol><p id="e3d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">修改后的基于gRPC的<a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-backend/blob/grpc/services/service-a/main.go" rel="noopener ugc nofollow" target="_blank">服务A </a>的源代码:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="a6f2" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">问候协议缓冲区</h2><p id="78f4" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">下面显示的是问候源协议缓冲区<code class="fe nb nc nd ne b">.proto</code>文件。最初在服务中定义的问候响应结构基本上保持不变。UI客户端响应看起来是一样的。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="bade" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当使用基于Go的协议编译器插件<code class="fe nb nc nd ne b">protoc</code>进行编译时，最初的27行源代码膨胀为将近270行生成的数据访问类，更易于编程使用。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="108a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是编译后代码的一小段，供参考。编译后的代码包含在GitHub上的<a class="ae le" href="https://github.com/garystafford/pb-greeting" rel="noopener ugc nofollow" target="_blank"> pb-greeting </a>项目中，导入到每个微服务和反向代理中。我们还为反向代理编译了一个单独的版本来实现。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="ecf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Swagger，我们可以查看greeting protocol buffers的单一RESTful API资源，该资源通过HTTP GET方法公开。我使用基于Docker版本的<a class="ae le" href="https://hub.docker.com/r/swaggerapi/swagger-ui/" rel="noopener ugc nofollow" target="_blank"> Swagger UI </a>来查看<code class="fe nb nc nd ne b">protoc</code>生成的Swagger定义。</p><pre class="lh li lj lk gt no ne np nq aw nr bi"><span id="7282" class="mk lt it ne b gy ns nt l nu nv">docker run -p 8080:8080 -d --name swagger-ui \<br/>  -e SWAGGER_JSON=/tmp/greeting.swagger.json \<br/>  -v ${GOAPTH}/src/pb-greeting:/tmp swaggerapi/swagger-ui</span></pre><p id="1fc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Angular UI向<code class="fe nb nc nd ne b">/api/v1/greeting</code>资源发出一个HTTP GET请求，该请求被转换为gRPC并代理给服务A，由<code class="fe nb nc nd ne b">Greeting</code>函数处理。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/5dc67c5afc46d52af9ed0a4d9c40292a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEgXMNrjYUJD2G_9y0SwLQ.png"/></div></div></figure><h2 id="1a60" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">gRPC网关反向代理</h2><p id="c9ab" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">如前所述，<a class="ae le" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> gRPC网关</a>反向代理服务是全新的。具体来说，请注意以下要点中的代码特征:</p><ol class=""><li id="67ca" class="nw nx it kk b kl km ko kp kr ny kv nz kz oa ld ob oc od oe bi translated">导入<a class="ae le" href="https://github.com/garystafford/pb-greeting" rel="noopener ugc nofollow" target="_blank"> pb-greeting </a> protobuf包；</li><li id="69bf" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">代理托管在端口<code class="fe nb nc nd ne b">80</code>上；</li><li id="a90c" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">用于Jaeger分布式跟踪的请求头从传入的HTTP请求中收集，并传递给gRPC上下文中的服务A；</li><li id="b07a" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">代理被编码为gRPC客户端，它调用服务A；</li><li id="e61e" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">日志记录基本没有变化；</li></ol><p id="f78d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://github.com/garystafford/k8s-istio-observe-backend/blob/grpc/services/service-rev-proxy/main.go" rel="noopener ugc nofollow" target="_blank">反向代理</a>的源代码:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="9a76" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">标题传播</h2><p id="5c1f" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">下面，在Stackdriver日志中，我们看到了JSON有效负载中一组HTTP请求头的示例，这些请求头从gRPC网关的反向代理向上游传播到基于gRPC的Go服务。标头传播确保请求在整个服务调用链中产生完整的分布式跟踪。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/4e42230d2b7566264e33d8dbc98886fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byW-K9PR0OcZDetVSduMYg.png"/></div></div></figure><h1 id="f44e" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">Istio VirtualService和CORS</h1><p id="0b18" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">根据该项目的<a class="ae le" href="https://github.com/grpc/grpc-web/issues/435#issuecomment-454113721" rel="noopener ugc nofollow" target="_blank"> GitHub问题</a>中的反馈，gRPC网关不直接支持跨源资源共享(CORS)策略。以我自己的经验，gRPC网关无法处理OPTIONS HTTP方法请求，必须由Angular 7 web UI发出。因此，我使用VirtualService资源的<a class="ae le" href="https://istio.io/docs/reference/config/networking/v1alpha3/virtual-service/#CorsPolicy" rel="noopener ugc nofollow" target="_blank"> CorsPolicy </a>配置，将CORS的职责交给了Istio。这使得CORS比将CORS配置编码到服务代码中更容易管理。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h1 id="3ab1" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">设置和安装</h1><p id="ea01" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">要将微服务平台部署到GKE，请遵循本文第一部分中的详细说明，<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-bed3dd0fac0b">基于Kubernetes的微服务可观察性与Istio服务网格:第一部分</a>或<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/azure-kubernetes-service-aks-observability-with-istio-service-mesh-4eb28da0f764"> Azure Kubernetes服务(AKS)可观察性与Istio服务网格</a> for AKS。您还应该在GitHub上查看这个项目的README文档。</p><ol class=""><li id="2fbc" class="nw nx it kk b kl km ko kp kr ny kv nz kz oa ld ob oc od oe bi translated">创建外部MongoDB Atlas数据库和CloudAMQP RabbitMQ集群；</li><li id="6dc2" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">为您自己的环境修改Kubernetes资源文件和bash脚本；</li><li id="bd16" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">在GCP或Azure上创建托管的GKE或AKS群集；</li><li id="086e" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">使用Helm将Istio配置和部署到受管理的Kubernetes集群；</li><li id="786f" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">为平台的公开资源创建DNS记录；</li><li id="0116" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">将基于Go的微服务、gRPC网关反向代理、Angular UI以及相关资源部署到Kubernetes集群；</li><li id="c4ba" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">测试平台部署并排除故障；</li><li id="e297" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated">观察结果；</li></ol><h1 id="ce62" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">三大支柱</h1><p id="2d3e" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">正如在第一篇文章中介绍的，日志、度量和跟踪通常被认为是可观察性的三大支柱。这些是我们可以观察到的系统的外部输出。随着现代分布式系统变得越来越复杂，观察这些系统的能力需要同样现代的工具，这些工具是在考虑到这种复杂程度的情况下设计的。传统的日志记录和监控系统往往难以应对当今的混合和多云、基于多语言、事件驱动、基于容器和无服务器、可无限扩展的短暂计算平台。</p><p id="a3b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像<a class="ae le" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio Service Mesh </a>这样的工具试图通过提供与几个同类最佳的开源遥测工具的本机集成来解决可观测性挑战。Istio的集成包括用于分布式跟踪的<a class="ae le" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>，用于Istio服务基于网格的微服务可视化和监控的<a class="ae le" href="https://www.kiali.io/" rel="noopener ugc nofollow" target="_blank"> Kiali </a>，以及用于指标收集、监控和警报的<a class="ae le" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>和<a class="ae le" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>。结合云平台原生的监控和日志记录服务，例如针对GKE的<a class="ae le" href="https://cloud.google.com/monitoring/" rel="noopener ugc nofollow" target="_blank"> Stackdriver </a>，针对亚马逊EKS的<a class="ae le" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank"> CloudWatch </a>，或针对AKS的<a class="ae le" href="https://docs.microsoft.com/en-us/azure/azure-monitor/overview" rel="noopener ugc nofollow" target="_blank"> Azure Monitor </a> logs，我们拥有针对现代、分布式、基于云的应用的完整可观测性解决方案。</p><h1 id="30ca" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">支柱1:伐木</h1><p id="8eb7" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">从JSON over HTTP迁移到gRPC不需要对基于Go的服务代码或Kubernetes资源的日志配置进行任何更改。</p><h2 id="e1c4" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">Logrus的Stackdriver</h2><p id="77c6" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">正如上一篇文章的第二部分所详述的，<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-bed3dd0fac0b">基于Kubernetes和Istio服务网格的微服务可观察性</a>，我们对八个基于Go的微服务和反向代理的日志策略仍然是使用<a class="ae le" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> Logrus </a>，这是一个流行的Go结构化日志记录器，以及Banzai Cloud的<a class="ae le" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank">Logrus-runtime-formatter</a>。</p><p id="0a26" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您还记得，Banzai格式化程序自动用运行时/堆栈信息标记日志消息，包括函数名和行号；排除故障时非常有用。我们也在使用Logrus的JSON格式化程序。下面，在Stackdriver控制台中，注意下面的每个日志条目如何包含消息中的JSON有效负载，以及日志级别、函数名、日志条目所在的行和消息。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/563ce9a3968a22f0dcee7ae4bd17530b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JipAO8ISQVr3NbS1iE06vQ.png"/></div></div></figure><p id="4963" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面，我们看到了特定日志条目的JSON有效负载的细节。在这种情况下，我们可以看到从下游服务传播的请求头。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/4e42230d2b7566264e33d8dbc98886fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byW-K9PR0OcZDetVSduMYg.png"/></div></div></figure><h1 id="b4d6" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">支柱2:衡量标准</h1><p id="0958" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">从JSON over HTTP迁移到gRPC不需要对基于Go的服务代码或Kubernetes资源的度量配置进行任何更改。</p><h2 id="7a1f" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">普罗米修斯</h2><p id="71c6" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">Prometheus 是一个完全开源的社区驱动的系统监控和警报工具包，最初于2012年左右在SoundCloud创建。有趣的是，普罗米修斯在2016年加入了<a class="ae le" href="https://cncf.io/" rel="noopener ugc nofollow" target="_blank">云原生计算基金会</a> (CNCF)，作为继<a class="ae le" href="http://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>之后托管的第二个项目。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/61018b25b7adc0d522b0be190c1faebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iLxeXV_kVv6sXKlL6967w.png"/></div></div></figure><h2 id="74c4" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">格拉夫纳</h2><p id="93d0" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">Grafana称自己是领先的时间序列分析开源软件。根据<a class="ae le" href="https://grafana.com/grafana" rel="noopener ugc nofollow" target="_blank"> Grafana Labs的说法，</a> Grafana允许您查询、可视化、提醒和了解您的指标，无论它们存储在哪里。您可以轻松创建、浏览和共享视觉效果丰富的数据驱动仪表板。Grafana允许用户为他们最重要的指标可视化地定义警报规则。Grafana将不断评估规则，并可以发送通知。</p><p id="80cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://istio.io/docs/tasks/telemetry/using-istio-dashboard/#about-the-grafana-add-on" rel="noopener ugc nofollow" target="_blank"> Istio </a>的说法，Grafana附加组件是Grafana的预配置实例。Grafana Docker基本映像已经过修改，可以在安装了Prometheus数据源和Istio仪表板的情况下启动。下面，我们看到两个预配置的仪表板，Istio Mesh仪表板和Istio Performance仪表板。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/51d7152d5596340ac37fd372d063c3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TS3f4dMj8oZQ3mC1z524vw.png"/></div></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/545becb18f64b86a88a2d5b77beae954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_w5CM4Ek9x4aBu2qucljQ.png"/></div></div></figure><h1 id="01c6" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">支柱3:痕迹</h1><p id="4ba1" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">从JSON over HTTP迁移到gRPC确实需要完全重写服务代码中的跟踪逻辑。事实上，我花了大部分时间来确保正确的报头从Istio入口网关传播到gRPC网关反向代理，传播到gRPC上下文中的服务A，并向上游传播到所有依赖的基于gRPC的服务。我确信在我当前的代码中有许多优化，关于跟踪的正确处理和这个信息如何在服务调用栈中传播。</p><h2 id="82fb" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">贼鸥</h2><p id="5f97" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">根据他们的网站介绍，<a class="ae le" href="https://www.jaegertracing.io/docs/1.10/" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>受<a class="ae le" href="https://research.google.com/pubs/pub36356.html" rel="noopener ugc nofollow" target="_blank"> Dapper </a>和<a class="ae le" href="http://zipkin.io/" rel="noopener ugc nofollow" target="_blank"> OpenZipkin </a>的启发，是一个由<a class="ae le" href="http://uber.github.io/" rel="noopener ugc nofollow" target="_blank">优步科技</a>开源发布的分布式追踪系统。它用于对基于微服务的分布式系统进行监控和故障排除，包括分布式上下文传播、分布式事务监控、根本原因分析、服务依赖性分析以及性能和延迟优化。Jaeger <a class="ae le" href="https://www.jaegertracing.io/docs/1.10/architecture/" rel="noopener ugc nofollow" target="_blank">网站</a>包含了Jaeger架构和一般追踪相关术语的出色概述。</p><p id="8239" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我们看到了积家界面的痕迹视图。在其中，我们看到了由<a class="ae le" href="https://github.com/rakyll/hey" rel="noopener ugc nofollow" target="_blank"> hey </a>生成的一系列跟踪，这是一个现代的负载生成器和基准测试工具，也是Apache Bench ( <code class="fe nb nc nd ne b">ab</code>)的一个有价值的替代品。与<code class="fe nb nc nd ne b">ab</code>不同，<code class="fe nb nc nd ne b">hey</code>支持HTTP/2。<code class="fe nb nc nd ne b">hey</code>的用法在之前的帖子里有详细介绍。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/b109ad13b94f5670fc38b0b6e275a7ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqasEdoWGOWwexaMwqeXAQ.png"/></div></div></figure><p id="82df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能还记得，跟踪是系统中的一条执行路径，可以被认为是<a class="ae le" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图</a> (DAG)的<a class="ae le" href="https://www.jaegertracing.io/docs/1.10/architecture#span" rel="noopener ugc nofollow" target="_blank">跨度</a>。如果您曾经使用过像Apache Spark这样的系统，那么您可能已经熟悉Dag了。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/5a2cd8b796ed5a18065b80eaab293a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HuTbDyhgf6GdVlz3dHrsg.png"/></div></div></figure><p id="cae8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我们看到的是Jaeger UI跟踪细节视图。示例跟踪包含16个跨度，包含九个组件—八个基于Go的服务中的七个、反向代理和Istio入口网关。轨迹和跨度都有计时。跟踪中的根跨度是Istio入口网关。在这个演示中，跟踪没有跨越RabbitMQ消息队列。这意味着您将看不到包含服务D到服务F之间通过RabbitMQ的解耦的、基于消息的通信的跟踪。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/6fc65c0344f05f52f50e6fe807562bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hp5M-ey-QnUWgZRjq3lEWg.png"/></div></div></figure><p id="dad5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Jaeger UI Trace Detail视图中，您还可以钻取包含附加元数据的单个范围。元数据包括被调用的URL、HTTP方法、响应状态和其他一些头。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/9dd423dc183a2034c6919aabebd47a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2c70_jiS0OwS2gQ2WtTcSg.png"/></div></div></figure><h1 id="9469" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">微服务可观察性</h1><p id="c6cd" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">从JSON over HTTP迁移到gRPC不需要对基于Go的服务代码或Kubernetes资源的Kiali配置进行任何更改。</p><h2 id="3d82" class="mk lt it bd lu ml mm dn ly mn mo dp mc kr mp mq me kv mr ms mg kz mt mu mi mv bi translated">基亚利</h2><p id="267b" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">根据他们的<a class="ae le" href="https://www.kiali.io/documentation/overview/" rel="noopener ugc nofollow" target="_blank">网站</a>，Kiali提供了以下问题的答案:我的Istio服务网中有哪些微服务，它们是如何连接的？Kiali在OpenShift或Kubernetes中与Istio合作，以可视化服务网状拓扑，提供对断路器、请求率等功能的可见性。它提供了从抽象应用程序到服务和工作负载的不同级别的网格组件的见解。</p><p id="7f00" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali UI中的图形视图是在Istio服务网格中运行的组件的可视化表示。下面，过滤集群的<code class="fe nb nc nd ne b">dev</code>名称空间，我们应该观察到Kiali已经映射了平台中的所有组件，以及丰富的元数据，比如它们的版本和通信协议。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/d078da0d4053a5225aad33f0ba536669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVWt1z7biUy1Kw3V9HHNhA.png"/></div></div></figure><p id="98a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Kiali，我们可以确认我们的服务对服务IPC协议现在是gRPC，而不是以前的HTTP。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/81cf4bb8911f90f52dc738e8e52ba05a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZsX_4RjlzFePsC-d-86rA.png"/></div></div></figure><p id="74cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然使用gRPC将HTTP上的JSON转换为协议缓冲区需要对服务进行重大的代码更改，但这并不影响我们使用Istio提供的工具(包括Prometheus、Grafana、Jaeger和Kiali)对这些服务进行高级别的观察。</p><p id="d4a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lf">本文表达的所有观点都是我个人的观点，不一定代表我现在或过去的雇主或他们的客户的观点。</em></p></div></div>    
</body>
</html>