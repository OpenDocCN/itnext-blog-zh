<html>
<head>
<title>How to use OTP service in your automation scripts with Selenium Web Driver.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Selenium Web驱动程序的自动化脚本中使用OTP服务。</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-otp-service-in-your-automation-scripts-with-selenium-web-driver-fe81607232b5?source=collection_archive---------0-----------------------#2020-07-11">https://itnext.io/how-to-use-otp-service-in-your-automation-scripts-with-selenium-web-driver-fe81607232b5?source=collection_archive---------0-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/da15e84a45f167cabc355194fa7bdfc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uc4p3eUHlfmQUiJ0Ul0Ftw.jpeg"/></div></div></figure><div class=""/><p id="6145" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时我们会面临使用用户名密码和一次性密码的组合来执行授权的任务。</p><p id="a13a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们需要使用web界面和Selenium WebDriver工具来输入数据，这项任务变得复杂了。</p><p id="9d75" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">动作的算法大致如下:</p><ul class=""><li id="7426" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在身份验证页面上，我们输入您的用户名、密码和电话号码。</li><li id="d046" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">服务器向我们发送请求，要求我们输入<strong class="ka jc">一次性密码</strong>。</li><li id="aadf" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">收到代码后，我们将其输入到身份验证表单中。</li></ul><p id="d6dd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi lk translated"><span class="l ll lm ln bm lo lp lq lr ls di"/>一次性密码(OTP)是仅对一次认证会话有效的密码。</p><p id="0238" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与静态密码相比，一次性密码的优势在于不能重复使用。因此，从成功的认证会话中截取数据的攻击者不能使用复制的密码来访问受保护的信息系统。</p><p id="351e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当在存储用户信息的任何站点上注册时，用户被要求创建认证密码。许多人认为唯一的密码可以安全地保护信息。但是用户密码的唯一性被高估了。在创建大多数密码时，我们使用逻辑:密码是日期、电话号码和姓氏。这个认证码很容易被发现、窃取或计算。但是，还有一种替代的数据保护系统——一次性密码，使用它，信息将得到安全的保护，因为临时密码只有效一次。最后，您决定通过实现基于一次性密码的身份验证来确保项目的最大安全性。很自然，问题出现了—我如何获得一次性代码？为此，您需要一个专门设计的一次性密码生成器“令牌”。令牌可以是专门设计的设备，也可以是您经常使用的小工具。因此，要开始使用OTP密码，您需要:在Protectimus站点上注册，选择适当的令牌，并为每次身份验证获取一次性密码。令牌或一次性密码生成器是一种设备或应用程序，当用户请求时，它使用特定的OTP生成算法来创建一次性密码。令牌是生成一次性密码的非常方便的解决方案，因为它们是无需访问网络即可工作的自主设备。基于一次性密码进行身份验证的硬件令牌可以使用不同的算法，例如基于时间的TOTP身份验证算法等等。有各种方法可以一次性得到。</p><p id="1933" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">认证过程:</p><ul class=""><li id="4cc4" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在授权期间，除了用户名和密码之外，还将请求一次性密码，用户必须在使用我们的一个令牌生成密码后在表单中输入该密码。</li><li id="2eed" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">一次性密码通过API发送。</li><li id="5126" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">实时检查OTR和用户，并立即向您的应用程序返回肯定或否定的响应。</li><li id="0542" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">您的应用程序会根据收到的响应来响应身份验证尝试。</li></ul><p id="1105" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，Selenium WebDriver不能与API一起工作。在软件开发的开源世界中，有大量使用API的框架。你可以在这篇<a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/testing-apis-using-advanced-rest-client-29edc785bfb1">文章</a>中读到更多关于他们的信息。我个人更喜欢T2的HTTP客户端Apache T3。</p><p id="9707" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们假设您的任务是在web服务中为用户认证组织服务测试。示例案例如下所示:</p><ul class=""><li id="f032" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">用户输入他们的电话号码，然后收到一条带有代码的短信。</li><li id="0a74" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">用户从短信中输入代码，应用程序对其进行验证和授权。</li></ul><p id="27c9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何组织一次模拟刺杀来使用我在这篇<a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-a-stub-for-testing-a-one-time-password-service-68e0de6f6641">文章</a>中写的一次性密码服务。</p><p id="8631" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在本文中，我们将看一个使用服务<a class="ae lt" href="https://www.twilio.com/" rel="noopener ugc nofollow" target="_blank"> Twilio </a>的例子</p><p id="30c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Twilio是一个创建短信、电话和其他通信的平台。你可以使用它来设置自动邮件列表和接收响应消息，进行语音通话和视频通话，在各种门户网站上获得授权的验证码，创建呼叫中心和聊天机器人。</p><p id="ff73" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要开始使用该服务，您需要注册。注册后，转到仪表板并创建一个电话号码。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lu"><img src="../Images/3bb2a92b0cef13e675c1f6e644c46676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIf8P3P7xeHIAuu2nGdzWQ.png"/></div></div></figure><p id="20dd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用这个电话号码来获取一次性密码。</p><p id="5b45" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了能够使用Twilio服务，您需要添加自己的项目依赖项:</p><p id="0b21" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于Maven:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="bfe1" class="me mf jb ma b gy mg mh l mi mj">&lt;dependency&gt;<br/>&lt;groupId&gt;com.twilio.sdk&lt;/groupId&gt;<br/>&lt;artifactId&gt;twilio&lt;/artifactId&gt;<br/>&lt;version&gt;7.54.0&lt;/version&gt;<br/>&lt;scope&gt;runtime&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="5bd7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于格雷尔:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="ae24" class="me mf jb ma b gy mg mh l mi mj">runtime group: <strong class="ma jc">'com.twilio.sdk'</strong>, name: <strong class="ma jc">'twilio'</strong>, version: <strong class="ma jc">'7.54.0'</strong></span></pre><p id="67b2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为以下对象创建基类:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="fff8" class="me mf jb ma b gy mg mh l mi mj"><em class="mk">/**<br/> * Sets up.<br/> */<br/></em>@BeforeClass<br/><strong class="ma jc">public static void </strong>start() {<br/>    <strong class="ma jc">final </strong>DesiredCapabilities capabilities = <strong class="ma jc">new </strong>DesiredCapabilities().<em class="mk">chrome</em>();<br/>    <strong class="ma jc">final </strong>Chrome chrome = <strong class="ma jc">new </strong>Chrome();<br/>    <strong class="ma jc">Twilio.init(ACCOUNT_SID, AUTH_TOKEN);</strong><br/>    DriverHolder.<em class="mk">setDriverThread</em>(chrome.createDriver(capabilities));<br/>    DriverHolder.<em class="mk">getDriverThread</em>().manage().timeouts().implicitlyWait(<strong class="ma jc"><em class="mk">DELAY</em></strong>, TimeUnit.<strong class="ma jc"><em class="mk">SECONDS</em></strong>);<br/>    DriverHolder.<em class="mk">getDriverThread</em>().manage().timeouts().pageLoadTimeout(<strong class="ma jc"><em class="mk">DELAY</em></strong>, TimeUnit.<strong class="ma jc"><em class="mk">SECONDS</em></strong>);<br/>    DriverHolder.<em class="mk">getDriverThread</em>().manage().timeouts().setScriptTimeout(<strong class="ma jc"><em class="mk">DELAY</em></strong>, TimeUnit.<strong class="ma jc"><em class="mk">SECONDS</em></strong>);<br/>    <em class="mk">navigateWebBrowser</em>().to("<strong class="ma jc"><em class="mk">Add your url</em></strong>");<br/>}</span></pre><p id="50a3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们根据页面对象模式来描述注册页面:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="3433" class="me mf jb ma b gy mg mh l mi mj"><em class="mk">/**<br/> * The method enterRegisterData.<br/> *<br/> * </em><strong class="ma jc"><em class="mk">@return </em></strong><em class="mk">RegisterPage.<br/> */<br/></em><br/><strong class="ma jc">public </strong>RegisterPage enterRegisterData() {<br/>    <br/><strong class="ma jc">final </strong>WaitCondition waitCondition = <strong class="ma jc">new </strong>WaitCondition();<br/>    waitCondition.waitForVisibilityOfElementLocatedBy(<strong class="ma jc"><em class="mk">PHONE</em></strong>).clear();<br/>    waitCondition.waitForVisibilityOfElementLocatedBy(<strong class="ma jc"><em class="mk">PHONE</em></strong>).sendKeys( "<strong class="ma jc">Add phone number for registration</strong>");<br/><br/>    waitCondition.waitForVisibilityOfElementLocatedBy(<strong class="ma jc"><em class="mk">VERIFY</em></strong>).click();<br/><br/>    waitCondition.waitForVisibilityOfElementLocatedBy(<strong class="ma jc"><em class="mk">FIRST_NAME</em></strong>).clear();<br/>    waitCondition.waitForVisibilityOfElementLocatedBy(<strong class="ma jc"><em class="mk">FIRST_NAME</em></strong>).sendKeys("<strong class="ma jc">Any name</strong>");<br/><br/>    waitCondition.waitForVisibilityOfElementLocatedBy(<strong class="ma jc"><em class="mk">PASSWORD</em></strong>).clear();<br/>    waitCondition.waitForVisibilityOfElementLocatedBy(<strong class="ma jc"><em class="mk">PASSWORD</em></strong>).sendKeys("<strong class="ma jc">qwerty123456</strong>");<br/><br/>    waitCondition.waitForVisibilityOfElementLocatedBy(<strong class="ma jc"><em class="mk">CODE</em></strong>).clear();<br/>    <strong class="ma jc">try </strong>{<br/>        waitCondition.waitForVisibilityOfElementLocatedBy(<strong class="ma jc"><em class="mk">CODE</em></strong>).sendKeys(<em class="mk">getVerificationCode</em>(getVerificationCode()));<br/>    } <strong class="ma jc">catch </strong>(URISyntaxException | IOException ex) {<br/>        <strong class="ma jc">if </strong>(<strong class="ma jc"><em class="mk">LOGGER</em></strong>.isLoggable(Level.<strong class="ma jc"><em class="mk">INFO</em></strong>)) {<br/>            <strong class="ma jc"><em class="mk">LOGGER</em></strong>.info(<strong class="ma jc">"The method getVerificationCode is down." </strong>+ ex.getMessage());<br/>        }<br/>    }<br/><br/>waitCondition.waitForVisibilityOfElementLocatedBy(<strong class="ma jc"><em class="mk">REGISTER</em></strong>).click();<br/><br/>    <strong class="ma jc">return this</strong>;<br/>}</span></pre><p id="db81" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建使用服务一次性密码API的方法:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="eb3b" class="me mf jb ma b gy mg mh l mi mj"><em class="mk">/**<br/> * The method getVerificationCode.<br/> *<br/> * </em><strong class="ma jc"><em class="mk">@param phone </em></strong><em class="mk">the phone.<br/> * </em><strong class="ma jc"><em class="mk">@return </em></strong><em class="mk">String. verification code.<br/> * </em><strong class="ma jc"><em class="mk">@throws </em></strong><em class="mk">URISyntaxException the uri syntax exception<br/> * </em><strong class="ma jc"><em class="mk">@throws </em></strong><em class="mk">IOException        the io exception<br/> */<br/></em><strong class="ma jc">public static </strong>String getVerificationCode(<strong class="ma jc">final </strong>String phone) <strong class="ma jc">throws </strong>URISyntaxException, IOException {<br/>    <strong class="ma jc">final </strong>URIBuilder uri = <strong class="ma jc">new </strong>URIBuilder("<strong class="ma jc">Add url for API"</strong>);<br/>    uri.setPath("<strong class="ma jc">Add endpoint for get OTP code</strong>");<br/>    uri.addParameter(<strong class="ma jc">"token"</strong>, <strong class="ma jc">your token</strong>);<br/>    uri.addParameter(<strong class="ma jc">"phone"</strong>, <strong class="ma jc">your phone</strong>);<br/>    <strong class="ma jc">final </strong>String codes = <em class="mk">getHtml</em>(uri.toString());<br/>    <strong class="ma jc">final </strong>JSONObject jsonObj = <strong class="ma jc">new </strong>JSONObject(codes);<br/>    <strong class="ma jc">final </strong>Object returnCode = jsonObj.get(<strong class="ma jc">"code"</strong>);<br/>    <strong class="ma jc">return </strong>String.<em class="mk">valueOf</em>(returnCode);<br/>}<br/>//Sometimes the API message doesn't mention the <strong class="ma jc">word CODE or OTP</strong>.<br/>// Our task is to find the digital code from the text and return it.<br/>// You can solve this problem using regular expressions.</span><span id="1e7f" class="me mf jb ma b gy ml mh l mi mj">// <strong class="ma jc">final </strong>String codes = <em class="mk">getHtml</em>(uri.toString());<br/>// <strong class="ma jc">final</strong> String OTPCode = codes.replaceAll("[^-?0-9]+"); </span></pre><p id="21bf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">get Html方法:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="49a2" class="me mf jb ma b gy mg mh l mi mj"><em class="mk">/**<br/> * The method getHtml.<br/> *<br/> * </em><strong class="ma jc"><em class="mk">@return </em></strong><em class="mk">String.<br/> */<br/></em><strong class="ma jc">private static </strong>String getHtml(<strong class="ma jc">final </strong>String urlToRead) <strong class="ma jc">throws </strong>IOException {<br/>    <strong class="ma jc">final </strong>StringBuilder result = <strong class="ma jc">new </strong>StringBuilder();<br/>    <strong class="ma jc">final </strong>URL url = <strong class="ma jc">new </strong>URL(urlToRead);<br/>    <strong class="ma jc">final </strong>URLConnection connection = url.openConnection();<br/>    <strong class="ma jc">if </strong>(connection == <strong class="ma jc">null</strong>) {<br/>        <strong class="ma jc">throw new </strong>TypeCastException(<strong class="ma jc">"null cannot be cast to non-null type java.net.HttpURLConnection"</strong>);<br/>    } <strong class="ma jc">else </strong>{<br/>        <strong class="ma jc">final </strong>HttpURLConnection conn = (HttpURLConnection) connection;<br/>        conn.setRequestMethod(<strong class="ma jc">"GET"</strong>);<br/>        <strong class="ma jc">final </strong>BufferedReader bufferedReader = <strong class="ma jc">new </strong>BufferedReader((Reader) (<strong class="ma jc">new </strong>InputStreamReader(conn.getInputStream())));<br/>        <strong class="ma jc">final </strong>Ref.ObjectRef line = <strong class="ma jc">new </strong>Ref.ObjectRef();<br/>        <strong class="ma jc">while </strong>(<strong class="ma jc">true</strong>) {<br/>            <strong class="ma jc">final </strong>String lines = bufferedReader.readLine();<br/>            line.<strong class="ma jc">element </strong>= lines;<br/>            <strong class="ma jc">if </strong>(lines == <strong class="ma jc">null</strong>) {<br/>                bufferedReader.close();<br/>                <strong class="ma jc">final </strong>String resultLines = result.toString();<br/>                Intrinsics.<em class="mk">checkExpressionValueIsNotNull</em>(resultLines, <strong class="ma jc">"result.toString()"</strong>);<br/>                <strong class="ma jc">return </strong>resultLines;<br/>            }<br/>            result.append((String) line.<strong class="ma jc">element</strong>);<br/>        }<br/>    }<br/>}</span></pre><p id="69c1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和自动化脚本可能看起来像这样:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="be78" class="me mf jb ma b gy mg mh l mi mj"><br/>@Test<br/><strong class="ma jc">public void </strong>testRegister() {<br/>    <strong class="ma jc">new </strong>RegisterPage()<br/>            .openLoginForm()<br/>            .cliclRegisterPage()<br/>            .enterRegisterData()<br/>            .checkApproveRegistration();<br/>}</span></pre><p id="f2af" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇文章对您有用，它提供了关于Selenium Web驱动程序和API交互的信息。</p><p id="6fe6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你已经读完这篇文章，我真的希望得到你的反馈。订阅我并为我鼓掌。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/f088adcba37a274cd21b903e4c24fef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*1fQkXeYMQqR53K2iwWPV5A.jpeg"/></div></figure></div></div>    
</body>
</html>