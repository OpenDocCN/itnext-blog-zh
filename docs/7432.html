<html>
<head>
<title>Storing Pandas dataframes efficiently in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python高效存储熊猫数据帧</h1>
<blockquote>原文：<a href="https://itnext.io/storing-pandas-data-frames-efficiently-in-python-cff669953485?source=collection_archive---------1-----------------------#2022-09-21">https://itnext.io/storing-pandas-data-frames-efficiently-in-python-cff669953485?source=collection_archive---------1-----------------------#2022-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e429105edd2e122589e93d50067536d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CNJhrRPisAMffWaf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="1517" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">介绍</h2><p id="a533" class="pw-post-body-paragraph lc ld it le b lf lg lh li lj lk ll lm kp ln lo lp kt lq lr ls kx lt lu lv lw im bi translated">如果您正在使用Python解决数据科学和/或机器学习问题，您可能会遇到Pandas，这是Python中最常见的数据分析和操作包之一。</p><p id="bf24" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">Pandas以一种称为DataFrame的形式存储数据，data frame是一种二维数据结构(类似于二维数组)，可以包含各种格式的数据(数字数据、分类变量等)。</p><p id="dd2b" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">因此，这里有一些以更有效的方式在数据帧中存储数据的技巧，可以提高内存和运行时性能。</p><h2 id="a08e" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">技巧1:强制转换分类变量</h2><p id="bf8a" class="pw-post-body-paragraph lc ld it le b lf lg lh li lj lk ll lm kp ln lo lp kt lq lr ls kx lt lu lv lw im bi translated">假设我们用1000个值填充名为<code class="fe mc md me mf b">color</code>的pandas列，这些值是由包含6个不同值的数组随机选取的(“白”、“黑”、“红”、“黄”、“蓝”和“绿”)。</p><p id="ba44" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">该列现在包含一个分类变量，因为它只能从一个<strong class="le iu">有限</strong>集中获取<strong class="le iu">离散</strong>和值。默认情况下，Pandas会将这类列存储为type object。</p><p id="f88b" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">下面的代码将打印我们刚刚定义的列的数据类型以及数据帧的“内存占用”。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">用分类变量定义数据帧</figcaption></figure><p id="085f" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">运行上面的代码后，我们会收到如下截图所示的结果。默认情况下，Pandas将数据类型<code class="fe mc md me mf b">object</code>分配给该列，该列使用大约60.4 KB的内存。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/a029e581b1574310a7ea1cc7230c40cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*8iZZ7rFkZAG9CVCXIiR6XQ.png"/></div></figure><p id="f0f5" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">现在让我们试着<strong class="le iu">将</strong>这个列转换成一个名为<code class="fe mc md me mf b">category</code>的数据类型，并再次打印数据帧的内存占用。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">将“颜色”列转换为“类别”类型</figcaption></figure><p id="9f9f" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">我们再次运行代码，我们看到以下结果。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/254036b39f4befa96ca327c19e8cdcfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*Vv8TtSvLA8l-pvrajeJKdA.png"/></div></figure><p id="f473" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">怎么了？令人惊讶的是，通过这个简单的改变<strong class="le iu">,我们成功地将内存中数据帧的大小减少了97%。</strong></p><p id="50c6" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">这是因为pandas处理分类值比处理一般值更有效，因为通过将它们声明为分类值，它知道它们是离散的，并且只能接受某些值。</p><p id="e543" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">然而，<strong class="le iu">不能保证</strong>内存占用的减少量，因为影响优化的主要因素是我们处理的变量的基数<strong class="le iu">。</strong></p><p id="560a" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">注意:基数是分类变量可以接受的不同值的数量(在我们的例子中，变量<code class="fe mc md me mf b">color</code>只能接受6个不同的值，因此基数为6)。</p><p id="d7de" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">根据经验，您可以放心地假设<strong class="le iu">分类变量的基数越低，使用上面演示的方法内存占用的减少就越多</strong>。</p><h2 id="9940" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">技巧#2:将变量转换为bool(技巧#1的特例)</h2><p id="88e0" class="pw-post-body-paragraph lc ld it le b lf lg lh li lj lk ll lm kp ln lo lp kt lq lr ls kx lt lu lv lw im bi translated">很多时候，在一个数据集中，我们可能会发现“分类”列只有两个离散值，如“是”和“否”或“男性”和“女性”，默认情况下，这些值将被pandas视为<code class="fe mc md me mf b">objects</code>。所以这个技巧是关于第一个技巧的一个特例。但是这一次，我们不会将这些值转换为<code class="fe mc md me mf b">category</code>，而是将<strong class="le iu">将</strong>映射为布尔值(真/假)。由于我认为对这种情况再次进行数学计算没有价值，我相信您能够理解这种移动将对具有上述特征的列的内存占用产生重大的积极影响。</p><p id="b9a6" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">因此，假设包含字符串值的列名为<code class="fe mc md me mf b">coin_toss</code>，并且该列只包含值<code class="fe mc md me mf b">HEAD</code>和<code class="fe mc md me mf b">TAILS</code>，我们可以使用下面的代码将该列转换为布尔值。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">将只有2个值的分类列转换为bool</figcaption></figure><h2 id="30ff" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">技巧3:尽可能向下转换整数</h2><p id="3e54" class="pw-post-body-paragraph lc ld it le b lf lg lh li lj lk ll lm kp ln lo lp kt lq lr ls kx lt lu lv lw im bi translated">现在假设我们想在熊猫数据帧的一列中保存1000个人的年龄。我们将通过随机选择[0，120]范围内的整数来填充该列(因为年龄总是非负的，并且在这种情况下观察到大于120的值是非常不可能的)。</p><p id="0352" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">下面的代码片段完成了上述所有工作，然后打印列的数据类型和数据集的内存占用。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">通过随机选取[0，120]范围内的整数值来创建“年龄”列</figcaption></figure><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/d8f3538ff152ff2b384460c3b3684ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*iz7f8VqLKFv0O0KQkkk3UA.png"/></div></figure><p id="6fe7" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">当我们运行代码时，我们观察到默认情况下pandas选择了<code class="fe mc md me mf b">int64</code>作为该列的数据类型，该列的总内存占用大约为7.9KB。</p><p id="0f33" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">此时，让我们记住，<code class="fe mc md me mf b">int64</code>数据类型最多可以存储2⁶⁴不同值<strong class="le iu">，而我们只需要存储120个值</strong> ( &lt; 2⁸)，这些值<strong class="le iu">可以安全地存储为一个8位整数</strong>。这实际上意味着，每行大约64-8 = 56位<strong class="le iu">在我们的场景中是完全无用的。正如你可能理解的那样，这是一个巨大的内存浪费，现在我们来看看如何避免它。</strong></p><p id="64ae" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">现在我们将<strong class="le iu">将</strong>该列向下转换到<code class="fe mc md me mf b">int8</code>并再次打印数据帧的内存占用。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/7d21effd8bc1179b56d09d0f7bd752f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*cXf0ITgf3HIvoOEDvtVlPA.png"/></div></figure><p id="6cff" class="pw-post-body-paragraph lc ld it le b lf lx lh li lj ly ll lm kp lz lo lp kt ma lr ls kx mb lu lv lw im bi translated">Yayyy！通过将列向下转换为<code class="fe mc md me mf b">int8</code>,我们成功地将内存占用减少到之前设置的1/8。</p><h2 id="2c50" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">结论</h2><p id="937c" class="pw-post-body-paragraph lc ld it le b lf lg lh li lj lk ll lm kp ln lo lp kt lq lr ls kx lt lu lv lw im bi translated">作为许多python应用程序的存储和数据操作层，正确有效地使用pandas数据帧对现代软件解决方案的性能有着重要的作用。正如本文中所展示的，能够以安全可靠的方式轻松实现的小优化可以显著提高整体性能。</p><div class="mo mp gp gr mq mr"><a href="https://petrosdemetrakopoulos.medium.com/membership" rel="noopener follow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">通过我的推荐链接加入Medium-Petros Demetrakopoulos</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">阅读Petros Demetrakopoulos(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">petrosdemetrakopoulos.medium.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf jz mr"/></div></div></a></div></div></div>    
</body>
</html>