# 面向模块的体系结构第 5 部分:隐式路由

> 原文：<https://itnext.io/module-oriented-architecture-part-5-implicit-routing-655b468ca1b4?source=collection_archive---------7----------------------->

…从[第 4 部分](https://medium.com/@poksi/module-oriented-architecture-part-4-non-conforming-modules-9c18ec2d2180)继续

我在本系列中几次提到，它的目标并不是最好地利用 Swift 语义和尽可能做出最好的 Swift 代码，因为它以非常通用的方式处理 MOA 问题，以语言不可知的方式描述问题和提出解决方案，它只是在 Swift 中实现它。

尽管如此，当一些代码问题可能会使架构有点破旧或为糟糕的编码打开一个潜在的漏洞时，那么我认为做一些内务处理是正确的，如果这使我们得到一些一般性的改进，那么让我们利用这个机会。

# 模块路由器问题

## 条件式

模块路由器听起来是一个不错的想法，尽管它可能会带来一些模糊性，并且很容易与来自 **VIPER** 架构的**路由器**相混淆，这当然不是。我们的路由器应该将调用路由到模块，而不是管理任何类型的**视图**线框。如果我们看看它在第 3 章中做了什么，它可能会变得非常清楚，随着向我们的模块添加方法/功能，它可以很快成为一个相当大的类，主要由一个大的`switch`子句定义。那是代码的味道，巨大的就像一个大而臭的代码，里面有一大罐有趣的豆子…

## 内存利用率

虽然内存在这里看起来不是一个大问题，因为我们将路由器定义为`lazy`，这仍然感觉不太对，因为路由器对象可能会用自己的图为几乎每个`path`初始化一个新的类。这可能会造成大量的内存使用，特别是如果我们必须处理一些来自 iOS SDK 的相当“繁重”的类。

# 解决办法

当条件成为一个决策链时，那么应用一些 ***多态性*** 通常是最好的方式。此外，就路由而言，被路由对象可以通过订阅潜在可路由类列表来很好地路由自己，并通过控制反转来自己执行路由。听起来是个不错的解决方案。其实就是这么整齐，省去了`ModuleRouter`。但是乐趣不止于此！函数`open`中的代码实际上非常通用，我们可以简单地将它移到`ModuleType`的扩展中，从而使它的实现更加精简！

让我们看看上面提到的代码中发生了什么:

## `1\. ModuleRouter is` 替换为`ModuleRoutable`:

你可以看到，想要被路由到的那个类，需要用某个模块路径来标识自己，这个路径稍后会在模块中被匹配，这样这里的函数`route`就可以被调用。静态函数是一种不幸的变通方法，因此具体的对象只能用它的类型来初始化。我们很快就会发现为什么使用反射。

下面是`PaymentsInteractor:`如何实现`ModuleRoutable`

我们在这里看到的是，我们已经将`route(parameters:callback:)`函数引入了被路由的类本身，使其成为隐式的。正如已经提到的，`routable()`仅仅是一个静态初始化器，而`getPath()`用特定的路径标识类，所以它可以从模块中被调用。有人可能会说，我们只是把`switch`语句放到了 Intercator 中，它肯定没有这个位置。好吧，现在我们不讨论内部模块架构，而是讨论我们如何从外部到内部再返回。在真实场景中，订阅模块为`ModuleRoutable`的对象可能是**演示者**和**视图模型**…但这将在其他时间处理。

## 2.模块支付模块变得非常通用

`ModuleType`获得新属性`subscribedRoutables`。该属性包含已预订的可传递类别的类型。它们不是用所有潜在的大对象图来初始化，而是只在路由到。

我们还可以看到，than 函数`open`现在已经移动到扩展中，我们的`PaymentsModule`现在只包含它的标识路由、路径和可路由类。

# 利益

嗯，我们实现了我们设定的目标。上面有一些很好的糖果:

*   在使用类型**路由器**方面不再有歧义，这可能会让一些使用**毒蛇**的开发者感到困惑
*   **【x】路由器**类如此消失，路由控制被给予那些应该被路由的路由器
*   **【x】模块**类现在几乎变成了声明性的、描述性的、零实现的、线程安全的类。

我们想在这个系列中展示的最后一件事是如何处理 **iOS 故事板**以及我们如何控制**【UX】**和**用户从 iOS 导航类到我们面向模块的架构的旅程**。

在这里检查 1.1 版本[的变化。](https://github.com/poksi592/module-architecture-demo/tree/1.1)

接下来[部分](https://medium.com/@poksi/module-oriented-architecture-part-6-outsmarting-the-mvc-26ef66111057)将讨论我们如何创建模块，在 iOS 故事板和视图控制器的情况下，这些模块也处理表示层。