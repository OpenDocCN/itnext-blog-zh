<html>
<head>
<title>Server-Side TypeScript with Node</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有节点的服务器端类型脚本</h1>
<blockquote>原文：<a href="https://itnext.io/server-side-typescript-with-node-c5cef1584684?source=collection_archive---------0-----------------------#2019-05-29">https://itnext.io/server-side-typescript-with-node-c5cef1584684?source=collection_archive---------0-----------------------#2019-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ff6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用TypeScript和Node构建API等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7bcab5bfcef0e91179811d7e6bdce7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FP5nWTNpRzLc2vv9WioJcw.png"/></div></div></figure><h2 id="186d" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">介绍</h2><p id="b4e1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">在本文中，我们将研究用<a class="ae mj" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>和<a class="ae mj" href="https://www.typescriptlang.org" rel="noopener ugc nofollow" target="_blank">类型脚本</a>创建API和其他工具的过程。TypeScript中强大而富于表现力的特性，加上Node的灵活性和可伸缩性，使之成为在相对较短的时间内构建高性能服务的绝佳组合。</p><p id="9a85" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">截至2019年，Node已经存在了大约十年，TypeScript已经存在了大约六年。这两种技术甚至在早期的alpha阶段就显示出了巨大的潜力，经过多年的生产使用和维护，它们已经成为可靠和成熟的工具，正在稳步获得普及和广泛采用，尤其是在软件被期望能够正常工作的快速开发时代。</p><p id="7694" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">示例项目将演示一个简单的HTTP服务器和命令行工具的组合，创建和保存具有类型和唯一非序列ID的车辆的新实例，并检索车辆的结果列表。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="a79e" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">入门指南</h2><p id="3558" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">本文中使用的项目的完整源代码可从<a class="ae mj" href="https://github.com/kenreilly/typescript-node-example" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="910c" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">如果您还没有这些工具，请获取一份<a class="ae mj" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>和<a class="ae mj" href="https://www.typescriptlang.org/#download-links" rel="noopener ugc nofollow" target="_blank">类型脚本</a>的副本。同样，如果您还没有支持这种环境的编辑器，流行的<a class="ae mj" href="https://code.visualstudio.com" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>支持现成的TypeScript，并会在项目打开时提供下载节点扩展的选项。</p><p id="cd05" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">一旦安装了Node和TypeScript编译器，就可以使用<code class="fe mw mx my mz b">tsc</code>从源目录中编译项目，然后使用<code class="fe mw mx my mz b">./start.sh</code>命令启动项目。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="9b6c" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">项目配置</h2><p id="d198" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">这个项目是用标准的<code class="fe mw mx my mz b">npm init</code>命令创建的。接下来，流行的<a class="ae mj" href="https://expressjs.com" rel="noopener ugc nofollow" target="_blank"> Express </a>服务器安装了<code class="fe mw mx my mz b">npm install --save express</code>。TypeScript编译器本身配置为将<code class="fe mw mx my mz b">./build</code>文件夹作为输出目录，将<code class="fe mw mx my mz b">esnext</code>作为<a class="ae mj" href="https://en.wikipedia.org/wiki/ECMAScript" rel="noopener ugc nofollow" target="_blank"> ECMAScript </a>的目标版本，将<code class="fe mw mx my mz b">commonjs</code>作为JS输出模块类型。另外，使用命令<code class="fe mw mx my mz b">install --save @types/node</code>为节点安装TypeScript类型。</p><p id="448b" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">我们来看看项目的<strong class="ls iu"> package.json </strong>和<strong class="ls iu"> tsconfig，json </strong>文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/31750215da390706c7903a098a845fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0xw9fBij-yGem16h1BBDA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated"><strong class="bd kw"> package.json </strong>和<strong class="bd kw"> tsconfig.json </strong>的内容</figcaption></figure><p id="6b8f" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">在<strong class="ls iu"> package.json </strong>中，该项目的<em class="nf">依赖</em>由<em class="nf">节点</em>和<em class="nf"> express </em>的类型以及<a class="ae mj" href="https://expressjs.com" rel="noopener ugc nofollow" target="_blank"> express </a>包本身组成。在<strong class="ls iu"> tsconfig.json </strong>中，指令编译器生成用<a class="ae mj" href="https://medium.freecodecamp.org/es5-to-esnext-heres-every-feature-added-to-javascript-since-2015-d0c255e13c6e" rel="noopener ugc nofollow" target="_blank"> <em class="nf"> esnext </em> </a>语法(ECMAScript的最新当前开发版本)编写的<a class="ae mj" href="https://en.wikipedia.org/wiki/CommonJS" rel="noopener ugc nofollow" target="_blank"> CommonJS </a>模块，并将它们与TypeScript中调试用的源代码图一起放在<code class="fe mw mx my mz b">./build</code>文件夹下。</p><p id="15a2" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">这涵盖了基本的项目设置，对类型和Node/Express有一些要求。其余的我们将从头开始实现，以便对环境和使用这些开发工具能做什么有个感觉。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="f28c" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">应用程序入口点</h2><p id="9d91" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">包配置文件中定义的主应用程序文件是<strong class="ls iu"> build/index.js </strong>，因此我们将查看其对应的源文件<strong class="ls iu"> src/index.ts </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/7e0099b4399f4ab38b25187897be6c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CUkGYlt7jFAHzPYjdMlEA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">主应用文件<strong class="bd kw"> src/index.ts </strong>的内容</figcaption></figure><p id="c922" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">在这个文件中，我们有一个<strong class="ls iu"> App </strong>类，它有一些通过命令行参数处理初始化的属性和方法，以及一个用于<em class="nf">端口的get访问器，</em>是我们的express服务器将监听的端口号。</p><p id="4646" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">静态的<strong class="ls iu"> init() </strong>方法接受一个命令行参数，这个参数可以是<code class="fe mw mx my mz b">start-server</code>或<code class="fe mw mx my mz b">list-vehicles</code>，这取决于操作者当时想要做什么。如果没有提供其中一个选项，将显示一条默认帮助消息，列出该程序的可用参数。</p><p id="ec1a" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated"><strong class="ls iu"> start_server() </strong>方法就是这样做的，它创建了一个<em class="nf"> express </em>的实例，并设置了两条路线，一条是显示帮助消息的<code class="fe mw mx my mz b">/</code>路线，另一条是接受查询字符串参数<code class="fe mw mx my mz b"><em class="nf">class</em></code> <em class="nf"> </em>的<code class="fe mw mx my mz b">/make-vehicle</code>，该参数应该对应于一种可用的车辆类型，我们稍后将进一步详细研究这种类型。如果<code class="fe mw mx my mz b">class</code>的值不是预期值之一，则会发送一条帮助消息来指示可用的车辆类别，我们将在下一节中对此进行介绍。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="bdf4" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">车辆类别定义</h2><p id="f507" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我们要检查的下一个文件是<strong class="ls iu"> src/vehicles.ts </strong>，其中包含我们的车辆定义:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/8acbcf54d1f60aa331b868c1c929dc1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ceNjWNaUKej63F_6N6ZDyA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">带有车型定义的文件<strong class="bd kw"> src/vehicles.ts </strong></figcaption></figure><p id="9c28" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">在这个文件中，我们有一些不同的东西有助于创建新的车辆实例。首先，<em class="nf"> crypto </em>库被导入以生成新的随机ID，而不是使用串行机制，这种机制容易出现同步问题以及经典的<a class="ae mj" href="https://en.wikipedia.org/wiki/Predictable_serial_number_attack" rel="noopener ugc nofollow" target="_blank">可预测序列号攻击</a>。当然，对于我们简单的API来说，这并不是什么大不了的事情，但是构建一些很难绕过默认设计的东西，而不是试图在以后的某个时间点附加安全性，这很少会起作用。</p><p id="8feb" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">接下来是VehicleColor和VehicleType的几个枚举定义，给我们一些关于这些车辆属性的约束，而不是让它们在我们的应用程序中被设置成无意义的东西，比如'<em class="nf"> transparent </em>或'<em class="nf"> UFO </em>'。</p><p id="3103" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">抽象的<strong class="ls iu"> Vehicle </strong>类定义了我们系统中任何车辆所期望的一组基本属性和方法，比如<em class="nf"> vehicle_id </em>、<em class="nf"> color </em>、<em class="nf"> type </em>以及其他一些。此外，该类定义了一个静态方法<strong class="ls iu"> generate_id() </strong>，用于生成<em class="nf"> vehicle_id </em>本身，当创建任何车辆时，构造函数都会调用该方法。这意味着任何扩展<strong class="ls iu"> Vehicle </strong>类的类都将有一个正确格式化的ID，而不需要任何进一步的实现。</p><p id="fdda" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">还定义了单个类别<strong class="ls iu">grocer getter</strong>、<strong class="ls iu">合作承包商</strong>和<strong class="ls iu">junk haul</strong>，每个类别的属性值都反映了车辆的类型。例如，跑车的速度是家用车的两倍，效率是家用车的一半，而卡车在这两方面都排在最后。每辆车都有一个<strong class="ls iu"> drive() </strong>的实现，它返回一个关于它如何前进的描述。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="caa7" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">API逻辑定义</h2><p id="c9f0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">接下来是API控制器文件本身，<strong class="ls iu"> src/simple-api.ts </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/005d37654c80163a7636acf71622f825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIC0e-WRmGYUQHl-JhbT_Q.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">带有<strong class="bd kw"> SimpleAPI </strong>类的文件<strong class="bd kw"> src/simple-api.ts </strong></figcaption></figure><p id="6db8" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">除了列出当前在数据存储中的车辆之外，SimpleAPI类还实现了一些基本的API逻辑来创建和保存新的车辆实例。<strong class="ls iu"> make_vehicle( </strong>得到的车辆最终作为<strong class="ls iu">承诺&lt;车辆&gt; </strong>对象返回给调用者。有关异步编程的更多信息，请参见本指南<a class="ae mj" href="https://codeburst.io/a-simple-guide-to-es6-promises-d71bacd2e13a" rel="noopener" target="_blank">中关于ES6的承诺</a>。</p><p id="ea40" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated"><strong class="ls iu"> list_vehicles() </strong>方法通过从<strong class="ls iu">数据存储</strong>中检索一个列表，然后对每个列表调用<em class="nf"> console.log() </em>，列出数据存储中存储的所有车辆。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="c414" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">简单的基于文件的数据存储</h2><p id="e4ed" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我们示例项目中的最后一个文件是<strong class="ls iu"> src/datastore.ts </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/0c5a75ce336df537f9691c70ba7f653f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5nczErQxMZhgwoHm6Nf-og.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated"><strong class="bd kw"> src/datastore.ts </strong>中的简单<strong class="bd kw"> DataStore </strong>类</figcaption></figure><p id="7194" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated"><strong class="ls iu"> DataStore </strong>类为这个项目实现了一个非常简单的基于文件的DataStore，它有一个<strong class="ls iu"> write( </strong> <em class="nf">路径，data </em> <strong class="ls iu"> ) </strong>方法用于存储车辆JSON数据，还有一个<strong class="ls iu">list(</strong><em class="nf">path</em><strong class="ls iu">)</strong>方法用于从先前存储的数据文件中检索车辆数组。带有所有回调的典型文件IO操作已经被包装在<strong class="ls iu"> Promise </strong>对象中，以使实现细节对程序的其余部分隐藏起来，这使得这些组件不会变得紧密耦合(这种情况会使<a class="ae mj" href="https://medium.com/me/stats/post/4c087d30a056" rel="noopener">很快失控</a>)。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="6e85" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">试车</h2><p id="2a90" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">有了文件定义之后，接下来要做的就是尝试我们的超简单演示服务的API和命令行特性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/5cd8c3691c972fe31b89dda9bc774967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5qMBqFt7EqSdHBIHZInyA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">从命令行运行简单API服务器</figcaption></figure><p id="dd07" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">使用<code class="fe mw mx my mz b">node build/index.js</code>不带任何参数地运行项目会产生一条帮助消息，这对那些不是每天都使用它的人来说很有用(比如一个项目维护人员，几个月或几年后，他会根据你让他们的工作变得容易或困难来爱你或恨你)。</p><p id="8c06" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">当我们用<code class="fe mw mx my mz b">node build/index.js start-server</code>再次运行它时，我们得到消息<code class="fe mw mx my mz b">Listening on port 3000</code> <em class="nf"> </em>，让我们知道一切都在按预期工作。现在，让我们尝试针对API运行一些<a class="ae mj" href="https://curl.haxx.se" rel="noopener ugc nofollow" target="_blank"> curl </a>请求:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/713feb8a815162dfb36b7df469859056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5yk7tdOcRumkJ5Sr7nISQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">对简单API服务器发出一些请求</figcaption></figure><p id="0751" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">在这里，我们可以看到帮助消息如何提供关于如何使用API的线索。有人可以从盲目地对它提出请求，到准确地理解如何正确地使用它，只需遵循帮助提示的几个简单命令。当然，在某些情况下，您可能不想提供帮助信息，但是对于简单的公共API，这对于使用您的应用程序web服务的开发人员来说是非常有用的。最后但同样重要的是，让我们看看通过调用API创建的列出所有车辆的特性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/3d36d1c21e951d29b34789d8f12f31cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRNcju-zkvvTevuxeniYWQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated"><strong class="bd kw">列表的输出-车辆</strong>命令行参数</figcaption></figure><p id="9c40" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated"><code class="fe mw mx my mz b">list-vehicles</code>参数从文件夹<code class="fe mw mx my mz b">data/vehicles</code>中获取一个<code class="fe mw mx my mz b">.json</code>文件列表，然后以一种漂亮的格式打印这个列表，显示API制造的闪亮新车的各种属性和类型。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="3928" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h2><p id="7e99" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">这个例子展示了现代服务器端技术(如带有TypeScript的Node)提供的功能和灵活性。通过几个简单的文件，我们定义了一个API来创建一个对象的实例，每个实例都有一个惟一的ID，此外还有一个基于定制文件的JSON数据存储和一个实用程序来列出所有已创建的车辆。这个项目可以扩展到创建一些很酷的东西，比如一个简单的通用数据库。</p><p id="fc8b" class="pw-post-body-paragraph lq lr it ls b lt mk ju lv lw ml jx ly ld mm ma mb lh mn md me ll mo mg mh mi im bi translated">对于这个和其他利用最先进的现代技术的示例项目的源代码，请查看<a class="ae mj" href="https://github.com/kenreilly" rel="noopener ugc nofollow" target="_blank">我的GitHub简介</a>。感谢阅读！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><blockquote class="nh"><p id="ab86" class="ni nj it bd nk nl nm nn no np nq mi dk translated">肯尼斯·雷利(<a class="ae mj" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a>)是<a class="ae mj" href="https://lvl-up.tech/" rel="noopener ugc nofollow" target="_blank"> LevelUP </a>的CTO</p></blockquote></div></div>    
</body>
</html>