<html>
<head>
<title>6 tips for better React performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高反应性能的6个技巧</h1>
<blockquote>原文：<a href="https://itnext.io/6-tips-for-better-react-performance-4329d12c126b?source=collection_archive---------0-----------------------#2019-02-28">https://itnext.io/6-tips-for-better-react-performance-4329d12c126b?source=collection_archive---------0-----------------------#2019-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d61dc134d87c8dbbf720ad97ebe34dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqWCHRZ5pzADJ7DTFPwWqA.png"/></div></div></figure><p id="d068" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我第一次开始学习React时，我完全赞同了解所有提高性能的小技巧和窍门。即使到目前为止，主要的性能提升是试图避免协调过程(React执行比较以决定DOM是否应该更新)。</p><p id="60cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将尝试列出一些简单的方法，通过简单的开发技巧来提高React应用程序的性能。这绝不意味着您需要一直应用这些技术，但是知道它们在那里总是好的。</p><p id="cb14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我们开始吧:</p><h2 id="2032" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">1.利用渲染保释技术</h2><p id="724d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">每当父组件更新时，不管子组件的属性是否改变，子组件都会更新。这意味着，即使子组件拥有与之前完全相同的道具，它仍然会重新渲染。澄清一下，当我说重新渲染时，我并不是指更新DOM，而是通过协调是否需要更新DOM的过程。这是昂贵的，特别是对于大组件树，因为本质上React将不得不应用一个不同的算法来检查先前的&amp;新计算的树是否有差异。</p><p id="0574" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以通过从<code class="fe lu lv lw lx b">React.PureComponent</code>扩展你的基于类的组件，利用<code class="fe lu lv lw lx b">shouldComponentUpdate</code>生命周期钩子，或者将你的组件包装在一个<code class="fe lu lv lw lx b">memo</code>更高阶的组件中，很容易地避免这种情况。这样你可以确保当你的组件的属性改变时，你的组件只更新<strong class="ka ir">。</strong></p><p id="ee0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我应该提到的是，通过对小组件这样做(就像下面例子中的那些)，你不仅没有实际的好处，而且你可能会使你的应用程序变慢一点点(因为你让React在组件的每个渲染上执行一个浅层比较<strong class="ka ir">)。因此，这种技术应该更积极地用于“重”组件，但对于渲染时间可以忽略不计的组件要谨慎使用。</strong></p><p id="0eda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ly">TLDR；使用</em> <code class="fe lu lv lw lx b"><em class="ly">React.PureComponent</em></code> <em class="ly">、</em> <code class="fe lu lv lw lx b"><em class="ly">shouldComponentUpdate </em></code> <em class="ly">或</em> <code class="fe lu lv lw lx b"><em class="ly">memo()</em></code> <em class="ly">表示“重”部件，但对于真正的小部件要避免使用。如果需要的话，把一个大的组件拆成更小的子组件，以便用</em> <code class="fe lu lv lw lx b"><em class="ly">memo()</em></code> <em class="ly">把后者包起来。</em></p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">在可能的情况下对渲染进行保释</figcaption></figure><h2 id="325e" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">2.避免内嵌对象</h2><p id="206e" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">每次内联对象时，React都会在每次渲染时重新创建对该对象的新引用。这导致接收该对象的组件将其视为引用上不同的对象。因此，该组件的<code class="fe lu lv lw lx b">props </code>上的浅等式将在每个渲染周期返回<code class="fe lu lv lw lx b">false</code>。</p><p id="b5c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是对很多人使用的内嵌样式的间接引用。在一个组件上内联<code class="fe lu lv lw lx b">styles</code>属性将迫使你的组件总是渲染(除非你写一个<strong class="ka ir">自定义</strong> <code class="fe lu lv lw lx b">shouldComponentUpdate</code>方法)，这可能会导致性能问题，这取决于组件下面是否有许多其他子组件。</p><p id="0922" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这个道具<strong class="ka ir">必须拥有</strong>一个不同的引用，有一个很好的技巧可以使用——例如，因为它是在一个<code class="fe lu lv lw lx b">.map</code>中创建的——使用ES6 spread操作符将其内容作为道具进行传播。每当一个对象的内容是原语(即不是函数、对象或数组)或者具有“固定”引用的非原语时，您可以将它们作为道具传递给<strong class="ka ir">而不是将包含它们的对象作为单个道具传递。这样做将允许您的组件通过引用比较它们的下一个和上一个道具，从呈现保释技术中受益。</strong></p><p id="20e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ly">TLDR；如果你内联你的样式(或者在一般对象中)，你不能从</em> <code class="fe lu lv lw lx b"><em class="ly">React.PureComponent</em></code> <em class="ly">或者</em> <code class="fe lu lv lw lx b"><em class="ly">memo()</em></code> <em class="ly">中获益。在某些情况下，您可以传播一个对象的内容，并将它们作为道具传递给组件来对抗这种情况。</em></p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">尽可能避免内嵌对象</figcaption></figure><h2 id="a350" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">3.避免匿名函数</h2><p id="53ec" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">虽然匿名函数是传递函数属性的好方法(尤其是需要用另一个属性作为其参数来调用的函数)，但它们在每次渲染时都会得到不同的引用。这类似于上面描述的内联对象。为了维护作为属性传递给React组件的函数的相同引用，您可以将其声明为类方法(如果您使用基于类的组件)，或者利用<code class="fe lu lv lw lx b">useCallback</code>钩子来帮助您保持相同的引用(如果您使用函数组件)。如果需要调用函数的每组参数都有不同的引用(例如，在<code class="fe lu lv lw lx b">.map</code>中计算的函数)，可以查看外面的<strong class="ka ir"> memoize </strong>函数(比如<a class="ae mj" href="https://lodash.com/docs/4.17.11#memoize" rel="noopener ugc nofollow" target="_blank"> lodash的memoize </a>)。这被称为“函数缓存”或“侦听器缓存”，帮助您以浏览器内存为代价在动态数量的匿名函数上拥有固定的引用。</p><p id="0014" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，有时候内联函数是最简单的方法，实际上不会给你的应用程序带来性能问题。这可能是因为您在一个非常“轻量级”的组件上使用了它，或者是因为父组件实际上<strong class="ka ir">必须</strong>在每次属性改变时重新呈现它的所有内容(因此您不关心函数是否获得了不同的引用，因为组件会重新呈现而不管它)。</p><p id="4a95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想强调的最后一件重要的事情是——默认情况下——渲染道具函数是匿名的。每当你使用一个函数作为组件的<code class="fe lu lv lw lx b">children</code>时，你可以在实际组件之外定义它，这样它总是有一个固定的引用。</p><p id="34a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ly">TLDR；尝试将函数道具绑定到方法，或者尽可能多地利用</em> <code class="fe lu lv lw lx b"><em class="ly">useCallback</em></code> <em class="ly">来从渲染保释技术中获益。这也适用于从render-props返回的函数。</em></p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">跨渲染保持对函数的相同引用</figcaption></figure><h2 id="bc88" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">4.延迟加载不是立即需要的组件</h2><p id="2129" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">这可能看起来与本文无关，但是组件反应装载得越少，装载得就越快。因此，如果您的初始渲染感觉相当糟糕，您可以在初始安装完成后，通过在需要时加载组件来减少混乱。同时，这将减少你的捆绑包，并允许用户更快地加载你的平台/应用。最后，通过分割初始呈现，您将JS工作负载分割成更小的任务，这将使您的页面具有更好的响应能力。这可以使用新的<code class="fe lu lv lw lx b">React.Lazy</code>和<code class="fe lu lv lw lx b">React.Suspense</code>轻松完成</p><p id="1ce8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ly">TLDR；尝试延迟加载那些对用户不可见(或不需要)的组件，直到用户与它们交互。</em></p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">我们延迟加载工具提示，因为它只有在用户看到时才可见。这将减少我们应用程序的初始启动时间</figcaption></figure><h2 id="c4ec" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak"> 5。调整CSS而不是强制组件挂载&amp;卸载</strong></h2><p id="ae97" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">渲染是昂贵的，<strong class="ka ir">尤其是当DOM需要改变的时候。每当您有某种折叠或标签功能时(一次只能看到一个项目)，您可能会尝试卸载不可见的组件，并在它变得可见时将其装回。</strong></p><p id="1052" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果被装载/卸载的组件很“重”，那么这个操作可能比需要的成本高得多，并导致延迟。在这种情况下，您最好通过CSS隐藏它，同时将内容保存到DOM中。我确实意识到有时这是不可能的，因为你可能会遇到这样的情况，同时安装这些组件可能会导致问题(即组件与窗口上无休止的分页竞争)，但当情况不是这样时，你应该选择这样做。</p><p id="3ce7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">额外的好处是，将<code class="fe lu lv lw lx b">opacity</code>调整为0对浏览器来说<strong class="ka ir">几乎是零</strong>成本(因为它不会导致回流)，并且应该尽可能优先于<code class="fe lu lv lw lx b">visibility</code> &amp; <code class="fe lu lv lw lx b">display</code>的改变。</p><p id="d7aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ly">TLDR；与其通过卸载来隐藏，有时通过CSS来隐藏，同时保持组件装载是有益的。对于需要大量装载/卸载时间的大型组件来说，这是一个巨大的进步。</em></p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">通过CSS隐藏而不是卸载组件</figcaption></figure><h2 id="c60c" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak"> 6。记忆昂贵的计算</strong></h2><p id="6c7d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">有时候渲染是不可避免的，但是由于React组件是一个函数组件，所以渲染会导致组件内的任何计算都被重新计算。使用新的<code class="fe lu lv lw lx b">useMemo</code>钩子，其值<strong class="ka ir">不会在每次渲染时</strong>改变的计算可以被“记忆”。通过这种方式，您可以通过使用从以前的渲染中计算的值来摆脱昂贵的计算。你可以在这里了解更多关于这个<a class="ae mj" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="9469" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的目标是减少JavaScript在组件呈现过程中的工作量，从而减少主线程被阻塞的时间。</p><p id="b988" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ly">TLDR；利用</em> <code class="fe lu lv lw lx b"><em class="ly">useMemo</em></code> <em class="ly">进行昂贵的计算缓存</em></p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">useMemo可以帮助优化计算</figcaption></figure><h1 id="c0cd" class="mk kx iq bd ky ml mm mn lb mo mp mq le mr ms mt lh mu mv mw lk mx my mz ln na bi translated">结论</h1><p id="c88a" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我有意省略了诸如“使用产品版本”、“在键盘监听器上使用节流”或“利用web workers”之类的东西，因为我认为这与React无关，而更与一般的web开发性能原则相关。我在这篇文章中试图指出的是，开发实践将有助于React更好地执行，释放更多的主线程，并最终为最终用户提供更快的应用程序。</p><p id="8d10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读:)</p><p id="a0ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ly">附页</em> </strong>👋<strong class="ka ir"> <em class="ly">嗨，我是</em></strong><a class="ae mj" href="https://aggelosarvanitakis.me" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ly">Aggelos</em></strong></a><strong class="ka ir"><em class="ly">！如果你喜欢这个，可以考虑在twitter上关注我，并与你的开发者朋友分享这个故事😀</em></strong></p></div></div>    
</body>
</html>