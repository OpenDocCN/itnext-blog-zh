<html>
<head>
<title>How to Build Real-Time Notification Service Using Server-Sent Events (SSE)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用服务器发送事件(SSE)构建实时通知服务</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-real-time-notification-service-using-server-sent-events-sse-5ffd9e27304f?source=collection_archive---------2-----------------------#2020-10-14">https://itnext.io/how-to-build-real-time-notification-service-using-server-sent-events-sse-5ffd9e27304f?source=collection_archive---------2-----------------------#2020-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/06a2edc62ea0e7eadaf684e5953463ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OmiOL8OfFMEtrDSlqCUYpQ.png"/></div></div></figure><p id="b750" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">互联网上的大部分通信直接来自客户端到服务器。客户端通常发送一个请求，服务器响应这个请求。它被称为客户机-服务器模型，在大多数情况下都能很好地工作。但是，在某些情况下，服务器需要向客户端发送消息。在这种情况下，我们有几个选择:我们可以使用短轮询和长轮询、webhooks、websockets或像Kafka这样的事件流平台。然而，还有一种技术，还没有普及到足够的程度，在很多情况下，这种技术非常适合这项工作。这项技术是服务器发送事件(SSE)标准。</p><h1 id="eb00" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">什么是服务器发送的事件？</h1><p id="5b96" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated"><strong class="ka ir"> SSE </strong>定义指出，它是一种http标准，允许web应用程序处理单向事件流，并在服务器发出数据时接收更新。简单地说，它是一种单向事件流的机制。</p><p id="5f12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">浏览器支持</strong></p><p id="8549" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，除了Internet Explorer之外，所有主流浏览器都支持它。</p><p id="331b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">消息格式</strong></p><p id="a75b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些事件只是规范定义格式的UTF-8编码文本数据流。这里重要的一点是，该格式定义了SSE消息应该具有的字段，但是它并没有强制规定有效负载的特定类型，而是让用户自由选择。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="a87b" class="ms lh iq mo b gy mt mu l mv mw">{ <br/>  "id": "message id &lt;optional&gt;",<br/>  "event": "event type &lt;optional&gt;", <br/>  "data": "event data -plain text, JSON, XML... &lt;mandatory&gt;" <br/>}</span></pre><h1 id="2180" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">SSE实施</h1><p id="ee5e" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">为了让SSE工作，服务器需要告诉客户机响应的内容类型是<em class="lf">文本/事件流</em>。接下来，服务器接收一个常规的HTTP请求，并保持HTTP连接打开，直到不再有事件或超时发生。如果超时发生在客户端接收到它期望的所有事件之前，它可以使用内置的重新连接机制来重新建立连接。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/15909306c62f5e9b8f5814cbf9fd8528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zh4zyBibwFsN1POp.jpg"/></div></div></figure><p id="7766" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">简单端点(通量):</strong></p><p id="8276" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Spring中SSE端点最简单的实现可以通过以下方式实现:</p><ul class=""><li id="4f04" class="my mz iq ka b kb kc kf kg kj na kn nb kr nc kv nd ne nf ng bi translated">将制作的媒体类型指定为<em class="lf">文本/事件流，</em></li><li id="9876" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">返回Flux类型，这是Java中事件流的反应式表示。</li></ul><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6cee" class="ms lh iq mo b gy mt mu l mv mw">@GetMapping(path = "/stream-flux", produces = MediaType.<em class="lf">TEXT_EVENT_STREAM_VALUE</em>)</span><span id="f1a0" class="ms lh iq mo b gy nm mu l mv mw">public Flux&lt;String&gt; streamFlux() {</span><span id="d5c7" class="ms lh iq mo b gy nm mu l mv mw">  return Flux.<em class="lf">interval</em>(Duration.<em class="lf">ofSeconds</em>(1))</span><span id="e96f" class="ms lh iq mo b gy nm mu l mv mw">  .map(sequence -&gt; "Flux - " + LocalTime.<em class="lf">now</em>().toString());</span><span id="c7ae" class="ms lh iq mo b gy nm mu l mv mw">}</span></pre><p id="94f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">服务器事件类:</strong></p><p id="a235" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Spring在4.2版中引入了对SSE规范的支持以及一个ServerSentEvent类。这里的好处是，我们可以跳过<em class="lf">文本/事件流</em>媒体类型显式规范，并且我们可以添加id或事件类型等元数据。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="dbfd" class="ms lh iq mo b gy mt mu l mv mw">@GetMapping("/sse-flux-2")</span><span id="0fa6" class="ms lh iq mo b gy nm mu l mv mw">public Flux&lt;ServerSentEvent&gt; sseFlux2() {</span><span id="58d9" class="ms lh iq mo b gy nm mu l mv mw">  return Flux.<em class="lf">interval</em>(Duration.<em class="lf">ofSeconds</em>(1))</span><span id="caf8" class="ms lh iq mo b gy nm mu l mv mw">    .map(sequence -&gt; ServerSentEvent.<em class="lf">builder</em>()</span><span id="49b1" class="ms lh iq mo b gy nm mu l mv mw">    .id(String.<em class="lf">valueOf</em>(sequence))</span><span id="d21d" class="ms lh iq mo b gy nm mu l mv mw">    .event("EVENT_TYPE")</span><span id="4a44" class="ms lh iq mo b gy nm mu l mv mw">    .data("SSE - " + LocalTime.<em class="lf">now</em>().toString())</span><span id="c613" class="ms lh iq mo b gy nm mu l mv mw">    .build());</span><span id="7532" class="ms lh iq mo b gy nm mu l mv mw">}</span></pre><p id="1625" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> SseEmitter类:</strong></p><p id="fd86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，SSE的全部功能来自SseEmitter类。它允许异步处理和发布来自其他线程的事件。此外，还可以存储对SseEmitter的引用，并在后续的客户端调用中检索它。这为构建强大的通知场景提供了巨大的潜力。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="d211" class="ms lh iq mo b gy mt mu l mv mw">@GetMapping("/sse-emitter")</span><span id="554f" class="ms lh iq mo b gy nm mu l mv mw">public SseEmitter sseEmitter() {</span><span id="70e1" class="ms lh iq mo b gy nm mu l mv mw">  SseEmitter emitter = new SseEmitter();</span><span id="f93b" class="ms lh iq mo b gy nm mu l mv mw">  Executors.<em class="lf">newSingleThreadExecutor</em>().execute(() -&gt; {</span><span id="693e" class="ms lh iq mo b gy nm mu l mv mw">    try {</span><span id="6889" class="ms lh iq mo b gy nm mu l mv mw">      for (int i = 0; true; i++) {</span><span id="b9b9" class="ms lh iq mo b gy nm mu l mv mw">        SseEmitter.SseEventBuilder event = SseEmitter.<em class="lf">event</em>()</span><span id="d5dd" class="ms lh iq mo b gy nm mu l mv mw">          .id(String.<em class="lf">valueOf</em>(i))</span><span id="9bb9" class="ms lh iq mo b gy nm mu l mv mw">          .name("SSE_EMITTER_EVENT")</span><span id="8c4e" class="ms lh iq mo b gy nm mu l mv mw">         .data("SSE EMITTER - " + LocalTime.<em class="lf">now</em>().toString());</span><span id="464e" class="ms lh iq mo b gy nm mu l mv mw">        emitter.send(event);</span><span id="de0c" class="ms lh iq mo b gy nm mu l mv mw">        Thread.<em class="lf">sleep</em>(1000);</span><span id="ff76" class="ms lh iq mo b gy nm mu l mv mw">      }</span><span id="0847" class="ms lh iq mo b gy nm mu l mv mw">    } catch (Exception ex) {</span><span id="8388" class="ms lh iq mo b gy nm mu l mv mw">      emitter.completeWithError(ex);</span><span id="953f" class="ms lh iq mo b gy nm mu l mv mw">    }</span><span id="5439" class="ms lh iq mo b gy nm mu l mv mw">  });</span><span id="329b" class="ms lh iq mo b gy nm mu l mv mw">  return emitter;</span><span id="db4f" class="ms lh iq mo b gy nm mu l mv mw">}</span></pre><p id="7139" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">客户端示例:</strong></p><p id="d051" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个用Javascript编写的基本SSE客户端示例。它简单地定义了一个EventSource，并以两种不同的方式订阅消息事件流。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="65f2" class="ms lh iq mo b gy mt mu l mv mw">// Declare an EventSource</span><span id="d298" class="ms lh iq mo b gy nm mu l mv mw">const eventSource = new <strong class="mo ir"><em class="lf">EventSource</em></strong>('http://some.url');</span><span id="6744" class="ms lh iq mo b gy nm mu l mv mw">// Handler for events without an event type specified</span><span id="7aea" class="ms lh iq mo b gy nm mu l mv mw">eventSource.onmessage = (e) =&gt; {</span><span id="33b3" class="ms lh iq mo b gy nm mu l mv mw">  // Do something - event data will be in e.data</span><span id="104a" class="ms lh iq mo b gy nm mu l mv mw">};</span><span id="1056" class="ms lh iq mo b gy nm mu l mv mw">// Handler for events of type 'eventType' only</span><span id="ab58" class="ms lh iq mo b gy nm mu l mv mw">eventSource.addEventListener('eventType', (e) =&gt; {</span><span id="8f47" class="ms lh iq mo b gy nm mu l mv mw">  // Do something - event data will be in e.data,</span><span id="9d7d" class="ms lh iq mo b gy nm mu l mv mw">});</span></pre><h1 id="7806" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">SSE与Websockets</h1><p id="22c5" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">当谈到SSE时，由于两种技术在使用上的相似性，它经常被与Websockets相比较。</p><ul class=""><li id="7c71" class="my mz iq ka b kb kc kf kg kj na kn nb kr nc kv nd ne nf ng bi translated">两者都能够将数据推送到客户端，</li><li id="3740" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">Websockets是双向的— SSE单向的，</li><li id="c5fb" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">在实践中，所有可以用SSE完成的，也可以用Websockets实现的事情，</li><li id="0b67" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">SSE可以更容易，</li><li id="7752" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">SSE通过简单的HTTP连接传输，</li><li id="1129" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">Websockets需要全双工连接和服务器来处理协议，</li><li id="6012" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">一些具有数据包检测功能的企业防火墙在处理Websockets时遇到了麻烦——对于SSE来说，情况并非如此，</li><li id="f244" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">SSE具有Websockets在设计上缺少的各种特性，例如，自动重新连接、事件id，</li><li id="7142" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">只有Websockets可以发送二进制和UTF-8数据，SSE仅限于UTF-8，</li><li id="c892" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">SSE受到最大打开连接数的限制(每个浏览器+域6个)。该问题被标记为<em class="lf">不会修复Chrome和Firefox中的</em>。</li></ul><p id="13b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">用例:</strong></p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/5314c528da88488457a219915b44b0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*maRaiLYMOGy-wwRK.jpg"/></div></div></figure><h1 id="6ada" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">通知服务示例:</h1><p id="f109" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">提供订阅事件和发布事件端点的控制器。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c2fe" class="ms lh iq mo b gy mt mu l mv mw">@Slf4j</span><span id="d742" class="ms lh iq mo b gy nm mu l mv mw">@RestController</span><span id="4ae4" class="ms lh iq mo b gy nm mu l mv mw">@RequestMapping("/events")</span><span id="8626" class="ms lh iq mo b gy nm mu l mv mw">@RequiredArgsConstructor</span><span id="1f7a" class="ms lh iq mo b gy nm mu l mv mw">public class EventController {</span><span id="cd2c" class="ms lh iq mo b gy nm mu l mv mw"> public static final String <em class="lf">MEMBER_ID_HEADER </em>= "MemberId";</span><span id="64d5" class="ms lh iq mo b gy nm mu l mv mw"> private final EmitterService emitterService;</span><span id="6754" class="ms lh iq mo b gy nm mu l mv mw"> private final NotificationService notificationService;</span><span id="86d7" class="ms lh iq mo b gy nm mu l mv mw"> @GetMapping</span><span id="fa4c" class="ms lh iq mo b gy nm mu l mv mw"> public SseEmitter subscribeToEvents(@RequestHeader(name =   <em class="lf">MEMBER_ID_HEADER</em>) String memberId) {</span><span id="8320" class="ms lh iq mo b gy nm mu l mv mw"><em class="lf">   log</em>.debug("Subscribing member with id {}", memberId);</span><span id="11e9" class="ms lh iq mo b gy nm mu l mv mw">   return emitterService.createEmitter(memberId);</span><span id="3fd0" class="ms lh iq mo b gy nm mu l mv mw"> }</span><span id="352f" class="ms lh iq mo b gy nm mu l mv mw"> @PostMapping</span><span id="c0ca" class="ms lh iq mo b gy nm mu l mv mw"> @ResponseStatus(HttpStatus.<em class="lf">ACCEPTED</em>)</span><span id="98a4" class="ms lh iq mo b gy nm mu l mv mw"> public void publishEvent(@RequestHeader(name = <em class="lf">MEMBER_ID_HEADER</em>) String memberId, @RequestBody EventDto event) {</span><span id="4c0f" class="ms lh iq mo b gy nm mu l mv mw"><em class="lf">   log</em>.debug("Publishing event {} for member with id {}", event,   memberId);</span><span id="7fc6" class="ms lh iq mo b gy nm mu l mv mw">   notificationService.sendNotification(memberId, event);</span><span id="c84b" class="ms lh iq mo b gy nm mu l mv mw"> }</span><span id="8b78" class="ms lh iq mo b gy nm mu l mv mw">}</span></pre><p id="2e9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用于发送事件的服务:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c311" class="ms lh iq mo b gy mt mu l mv mw">@Service</span><span id="7f11" class="ms lh iq mo b gy nm mu l mv mw">@Primary</span><span id="bc61" class="ms lh iq mo b gy nm mu l mv mw">@RequiredArgsConstructor</span><span id="e7ab" class="ms lh iq mo b gy nm mu l mv mw">@Slf4j</span><span id="1bc3" class="ms lh iq mo b gy nm mu l mv mw">public class SseNotificationService implements NotificationService {</span><span id="ea4b" class="ms lh iq mo b gy nm mu l mv mw"> private final EmitterRepository emitterRepository;</span><span id="68d2" class="ms lh iq mo b gy nm mu l mv mw"> private final EventMapper eventMapper;</span><span id="0039" class="ms lh iq mo b gy nm mu l mv mw"> @Override</span><span id="35da" class="ms lh iq mo b gy nm mu l mv mw"> public void sendNotification(String memberId, EventDto event) {</span><span id="46ff" class="ms lh iq mo b gy nm mu l mv mw">   if (event == null) {</span><span id="2224" class="ms lh iq mo b gy nm mu l mv mw"><em class="lf">     log</em>.debug("No server event to send to device.");</span><span id="f440" class="ms lh iq mo b gy nm mu l mv mw">     return;</span><span id="1074" class="ms lh iq mo b gy nm mu l mv mw">   }</span><span id="b320" class="ms lh iq mo b gy nm mu l mv mw">   doSendNotification(memberId, event);</span><span id="4998" class="ms lh iq mo b gy nm mu l mv mw"> }</span><span id="b54f" class="ms lh iq mo b gy nm mu l mv mw">private void doSendNotification(String memberId, EventDto event) {</span><span id="5178" class="ms lh iq mo b gy nm mu l mv mw">   emitterRepository.get(memberId).ifPresentOrElse(sseEmitter -&gt; {</span><span id="377c" class="ms lh iq mo b gy nm mu l mv mw">     try {</span><span id="a857" class="ms lh iq mo b gy nm mu l mv mw"><em class="lf">       log</em>.debug("Sending event: {} for member: {}", event, memberId);</span><span id="708d" class="ms lh iq mo b gy nm mu l mv mw">       sseEmitter.send(eventMapper.toSseEventBuilder(event));</span><span id="49c2" class="ms lh iq mo b gy nm mu l mv mw">     } catch (IOException | IllegalStateException e) {</span><span id="9bd2" class="ms lh iq mo b gy nm mu l mv mw"><em class="lf">     log</em>.debug("Error while sending event: {} for member: {} - exception: {}", event, memberId, e);</span><span id="fac0" class="ms lh iq mo b gy nm mu l mv mw">     emitterRepository.remove(memberId);</span><span id="4615" class="ms lh iq mo b gy nm mu l mv mw">     }</span><span id="50e8" class="ms lh iq mo b gy nm mu l mv mw">   }, () -&gt; <em class="lf">log</em>.debug("No emitter for member {}", memberId));</span><span id="bd5a" class="ms lh iq mo b gy nm mu l mv mw"> }</span><span id="cabc" class="ms lh iq mo b gy nm mu l mv mw">}</span></pre><p id="8de8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总而言之，对于单向数据流来说，服务器发送事件标准是一项伟大的技术，与Websockets或分布式流平台等更复杂的方法相比，它通常可以省去我们很多麻烦。</p><p id="11db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用服务器发送事件实现的完整通知服务示例可以在我的github上找到:<a class="ae nn" href="https://github.com/mkapiczy/server-sent-events" rel="noopener ugc nofollow" target="_blank">https://github.com/mkapiczy/server-sent-events</a></p><h1 id="0913" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">来源:</h1><ul class=""><li id="848d" class="my mz iq ka b kb me kf mf kj no kn np kr nq kv nd ne nf ng bi translated"><a class="ae nn" href="https://www.baeldung.com/spring-server-sent-events" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/spring-server-sent-events</a></li><li id="e592" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated"><a class="ae nn" href="https://www.w3.org/TR/eventsource/" rel="noopener ugc nofollow" target="_blank">https://www.w3.org/TR/eventsource/</a></li><li id="0d70" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated"><a class="ae nn" href="https://stackoverflow.com/questions/5195452/websockets-vs-server-sent-events-eventsource" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/5195452/web sockets-vs-server-sent-events-event source</a></li><li id="57a0" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated"><a class="ae nn" href="https://www.telerik.com/blogs/websockets-vs-server-sent-events" rel="noopener ugc nofollow" target="_blank">https://www . telerik . com/blogs/web sockets-vs-server-sent-events</a></li><li id="a35b" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated"><a class="ae nn" href="https://simonprickett.dev/a-look-at-server-sent-events/" rel="noopener ugc nofollow" target="_blank">https://simonprickett.dev/a-look-at-server-sent-events/</a></li></ul></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="abf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lf">原载于2020年10月14日</em><a class="ae nn" href="https://grapeup.com/blog/how-to-build-real-time-notification-service-using-server-sent-events-sse/" rel="noopener ugc nofollow" target="_blank"><em class="lf">【https://grapeup.com】</em></a><em class="lf">。</em></p></div></div>    
</body>
</html>