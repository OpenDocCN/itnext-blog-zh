<html>
<head>
<title>Consuming with RESTful APIs with Vertx HttpClient/WebClient</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Vertx HttpClient/WebClient使用RESTful APIs</h1>
<blockquote>原文：<a href="https://itnext.io/consuming-with-restful-apis-with-vertx-httpclient-webclient-6a2f61d94029?source=collection_archive---------3-----------------------#2021-07-23">https://itnext.io/consuming-with-restful-apis-with-vertx-httpclient-webclient-6a2f61d94029?source=collection_archive---------3-----------------------#2021-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c180" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经讨论了如何用基本的Eclipse Vertx Web特性构建RESTful APIs。在这篇文章中，我们将介绍如何创建一个<em class="kl"> Http客户端</em>并与RESTful APIs交互。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/2827a7fde31bda3478e8b3b1d8862fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2y5DM9RtKpVzypW4HUnJdA.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">约书亚·厄尔在<a class="ae lc" href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9f89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与创建HttpServer类似，您可以从<code class="fe ld le lf lg b">Vertx</code>实例创建一个HttpClient。</p><pre class="kn ko kp kq gt lh lg li lj aw lk bi"><span id="407e" class="ll lm iq lg b gy ln lo l lp lq">var options = new HttpClientOptions()<br/>    .setDefaultPort(8888);<br/>var client = vertx.createHttpClient(options);</span></pre><p id="f298" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您可以像下面这样向服务器发送请求。</p><pre class="kn ko kp kq gt lh lg li lj aw lk bi"><span id="8480" class="ll lm iq lg b gy ln lo l lp lq">client.request(HttpMethod.GET, "/hello")<br/>    .compose(req -&gt; req.send().compose(HttpClientResponse::body))<br/>    .onSuccess(...)<br/>    .onFailure(...)</span></pre><p id="c6a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ld le lf lg b">HttpClient</code>是一个低级API，提供对请求和响应信息的细粒度控制。Vertx提供了一个更高级的API来与服务器端握手，它被称为<code class="fe ld le lf lg b">WebClient</code>。</p><p id="e3e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于<code class="fe ld le lf lg b">HttpClient</code>的创建，像这样创建一个<code class="fe ld le lf lg b">WebClient</code>实例。</p><pre class="kn ko kp kq gt lh lg li lj aw lk bi"><span id="f5a6" class="ll lm iq lg b gy ln lo l lp lq">var options = new WebClientOptions()<br/>            .setDefaultHost("localhost")<br/>            .setDefaultPort(8888);<br/>var webclient = WebClient.create(vertx, options);</span></pre><p id="db7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者从现有的<code class="fe ld le lf lg b">HttpClient</code>实例创建一个<code class="fe ld le lf lg b">WebClient</code>。</p><pre class="kn ko kp kq gt lh lg li lj aw lk bi"><span id="5b64" class="ll lm iq lg b gy ln lo l lp lq">var webclient = WebClient.wrap(httpClient, options);</span></pre><p id="2cce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个使用WebClient发送请求的例子。</p><pre class="kn ko kp kq gt lh lg li lj aw lk bi"><span id="d925" class="ll lm iq lg b gy ln lo l lp lq">client.get("/posts")<br/>    .send()<br/>    .onSuccess(...)<br/>    .onFailure(...)</span></pre><p id="5873" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与<code class="fe ld le lf lg b">HttpClient</code>相比，它提供了更全面的发送请求体的方法，例如JSON对象、多部分形式等。</p><p id="b0a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来让我们来测试Vertx，并使用HttpClient/WebClient来测试RESTful API端点。</p><p id="8723" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子是一个简单的JUnit 5测试。</p><pre class="kn ko kp kq gt lh lg li lj aw lk bi"><span id="9dab" class="ll lm iq lg b gy ln lo l lp lq">@ExtendWith(VertxExtension.class)<br/>public class TestMainVerticle {<br/>    private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName());<br/>    HttpClient client;</span><span id="80be" class="ll lm iq lg b gy lr lo l lp lq">    @BeforeEach<br/>    void setup(Vertx vertx, VertxTestContext testContext) {<br/>        vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -&gt; testContext.completeNow()));<br/>        var options = new HttpClientOptions()<br/>            .setDefaultPort(8888);<br/>        this.client = vertx.createHttpClient(options);<br/>    }</span><span id="3244" class="ll lm iq lg b gy lr lo l lp lq">    @DisplayName("Check the HTTP response...")<br/>    void testHello(Vertx vertx, VertxTestContext testContext) {<br/>        client.request(HttpMethod.GET, "/hello")<br/>            .compose(req -&gt; req.send().compose(HttpClientResponse::body))<br/>            .onComplete(<br/>                testContext.succeeding(<br/>                    buffer -&gt; testContext.verify(<br/>                        () -&gt; {<br/>                            assertThat(buffer.toString()).isEqualTo("Hello from my route");<br/>                            testContext.completeNow();<br/>                        }<br/>                    )<br/>                )<br/>            );<br/>    }</span><span id="f0ec" class="ll lm iq lg b gy lr lo l lp lq">}</span></pre><p id="fa95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe ld le lf lg b">@ExtendWith(VertxExtension.class)</code>，它允许您在测试方法中注入<code class="fe ld le lf lg b">Vertx</code>和<code class="fe ld le lf lg b">VertxTestContext</code>参数。<code class="fe ld le lf lg b">VertxTestContext</code>包装一个<code class="fe ld le lf lg b">CountDownLatch</code>表示异步执行完成，你必须调用<code class="fe ld le lf lg b">completeNow</code>或<code class="fe ld le lf lg b">failNow</code>来结束执行，否则测试执行将被阻塞直到超时。</p><p id="91e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一个测试<em class="kl"> /posts </em>端点以获取所有帖子的例子。</p><pre class="kn ko kp kq gt lh lg li lj aw lk bi"><span id="0fa9" class="ll lm iq lg b gy ln lo l lp lq">@Test<br/>void testGetAll(Vertx vertx, VertxTestContext testContext) {<br/>    client.request(HttpMethod.GET, "/posts")<br/>        .flatMap(HttpClientRequest::send)<br/>        .flatMap(HttpClientResponse::body)<br/>        .onComplete(<br/>        testContext.succeeding(<br/>            buffer -&gt; testContext.verify(<br/>                () -&gt; {<br/>                    assertThat(buffer.toJsonArray().size()).isEqualTo(2);<br/>                    testContext.completeNow();<br/>                }<br/>            )<br/>        )<br/>    );<br/>}</span></pre><p id="7326" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子测试了返回404 HTTP状态码的<code class="fe ld le lf lg b">PostNotFoundException</code>。</p><pre class="kn ko kp kq gt lh lg li lj aw lk bi"><span id="e1a5" class="ll lm iq lg b gy ln lo l lp lq">@Test<br/>void testGetByNoneExistingId(Vertx vertx, VertxTestContext testContext) {<br/>    var postByIdUrl = "/posts/" + UUID.randomUUID();<br/>    client.request(HttpMethod.GET, postByIdUrl)<br/>        .flatMap(HttpClientRequest::send)<br/>        .onComplete(<br/>        testContext.succeeding(<br/>            response -&gt; testContext.verify(<br/>                () -&gt; {<br/>                    assertThat(response.statusCode()).isEqualTo(404);<br/>                    testContext.completeNow();<br/>                }<br/>            )<br/>        )<br/>    );<br/>}</span></pre><p id="ee77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户端操作可以被链接。下面是一个测试CRUD流的例子。</p><pre class="kn ko kp kq gt lh lg li lj aw lk bi"><span id="ae0f" class="ll lm iq lg b gy ln lo l lp lq">@Test<br/>void testCreatePost(Vertx vertx, VertxTestContext testContext) {<br/>    client.request(HttpMethod.POST, "/posts")<br/>        .flatMap(req -&gt; req.putHeader("Content-Type", "application/json")<br/>                 .send(Json.encode(CreatePostCommand.of("test title", "test content of my post")))<br/>                 .onSuccess(<br/>                     response -&gt; assertThat(response.statusCode()).isEqualTo(201)<br/>                 )<br/>                )<br/>        .flatMap(response -&gt; {<br/>            String location = response.getHeader("Location");<br/>            LOGGER.log(Level.INFO, "location header: {0}", location);<br/>            assertThat(location).isNotNull();</span><span id="042a" class="ll lm iq lg b gy lr lo l lp lq">            return Future.succeededFuture(location);<br/>        })<br/>        .flatMap(url -&gt; client.request(HttpMethod.GET, url)<br/>                 .flatMap(HttpClientRequest::send)<br/>                 .onSuccess(response -&gt; {<br/>                     LOGGER.log(Level.INFO, "http status: {0}", response.statusCode());<br/>                     assertThat(response.statusCode()).isEqualTo(200);<br/>                 })<br/>                 .flatMap(res -&gt; client.request(HttpMethod.PUT, url)<br/>                          .flatMap(req -&gt; req.putHeader("Content-Type", "application/json")<br/>                                   .send(Json.encode(CreatePostCommand.of("updated test title", "updated test content of my post")))<br/>                                  )<br/>                          .onSuccess(response -&gt; {<br/>                              LOGGER.log(Level.INFO, "http status: {0}", response.statusCode());<br/>                              assertThat(response.statusCode()).isEqualTo(204);<br/>                          })<br/>                         )<br/>                 .flatMap(res -&gt; client.request(HttpMethod.GET, url)<br/>                          .flatMap(HttpClientRequest::send)<br/>                          .onSuccess(response -&gt; {<br/>                              LOGGER.log(Level.INFO, "http status: {0}", response.statusCode());<br/>                              assertThat(response.statusCode()).isEqualTo(200);</span><span id="d040" class="ll lm iq lg b gy lr lo l lp lq">                          })<br/>                          .flatMap(HttpClientResponse::body)<br/>                          .onSuccess(body -&gt; assertThat(body.toJsonObject().getString("title")).isEqualTo("updated test title"))<br/>                         )<br/>                 .flatMap(res -&gt; client.request(HttpMethod.DELETE, url)<br/>                          .flatMap(HttpClientRequest::send)<br/>                          .onSuccess(response -&gt; {<br/>                              LOGGER.log(Level.INFO, "http status: {0}", response.statusCode());<br/>                              assertThat(response.statusCode()).isEqualTo(204);<br/>                          })<br/>                         )<br/>                 .flatMap(res -&gt; client.request(HttpMethod.GET, url)<br/>                          .flatMap(HttpClientRequest::send)<br/>                          .onSuccess(response -&gt; {<br/>                              LOGGER.log(Level.INFO, "http status: {0}", response.statusCode());<br/>                              assertThat(response.statusCode()).isEqualTo(404);<br/>                          })<br/>                         )<br/>                )<br/>        .onComplete(<br/>        testContext.succeeding(id -&gt; testContext.completeNow())<br/>    );<br/>}</span></pre><p id="dc3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，您可以在测试中使用<code class="fe ld le lf lg b">WebClient</code>。</p><p id="c57c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个使用RxJava 3绑定的<code class="fe ld le lf lg b">WebClient</code>的例子。</p><pre class="kn ko kp kq gt lh lg li lj aw lk bi"><span id="f581" class="ll lm iq lg b gy ln lo l lp lq">@Test<br/>void testGetAll(Vertx vertx, VertxTestContext testContext) {<br/>    client.get("/posts")<br/>        .rxSend()<br/>        .subscribe(<br/>        response -&gt; {<br/>            assertThat(response.statusCode()).isEqualTo(200);<br/>            assertThat(response.bodyAsJsonArray().size()).isEqualTo(2);</span><span id="dde6" class="ll lm iq lg b gy lr lo l lp lq">            testContext.completeNow();<br/>        }<br/>    );<br/>}</span></pre><p id="eb9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ld le lf lg b">WebClient</code>提供了更流畅的API。在大多数情况下，发送请求要比原始的HttpClient容易，尤其是。处理多部分表单。我们将在今后探索它。</p></div></div>    
</body>
</html>