<html>
<head>
<title>Better safe than worry: log the versions of all dependencies at runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全胜于担忧:在运行时记录所有依赖项的版本</h1>
<blockquote>原文：<a href="https://itnext.io/on-the-safe-side-log-your-3rd-party-package-versions-8b70ebdc9e1d?source=collection_archive---------2-----------------------#2021-12-22">https://itnext.io/on-the-safe-side-log-your-3rd-party-package-versions-8b70ebdc9e1d?source=collection_archive---------2-----------------------#2021-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3ad3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">简而言之:如何在运行时</em>  <em class="kl">轻松获得log4j2和其余Java依赖项</em> <strong class="jp ir"> <em class="kl">版本的教程。</em></strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/bd7c830454cd8a75e76730912be724e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V26PTWtprt5grsu3.jpg"/></div></div></figure><p id="4fc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">鉴于最近的<a class="ae ky" href="https://logging.apache.org/log4j/2.x/security.html" rel="noopener ugc nofollow" target="_blank"> log4j2漏洞</a>，经常发生的情况是，您必须升级某个第三方依赖项的版本，以便缓解最近发现的漏洞。</p><p id="803c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如何确定版本更新确实发生了呢？现在有了复杂的依赖规则，即使你在某个地方指定了一个显式的包版本，你选择的包管理器(例如Maven，Gradle)可能会决定将你的包版本设置为某个较低的版本，以符合你使用的另一个包的一些公共依赖。</p><h1 id="31db" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">在构建时列出依赖项</h1><p id="aef8" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">如果你使用Maven，你可以运行<code class="fe mc md me mf b">mvn dependency:resolve</code>，<code class="fe mc md me mf b">maven-dependency-plugin</code>会列出你的依赖项。但是这只适用于构建时。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8b69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建议将此命令添加到您的构建工作流中，以便在构建时已经清楚地记录了所有依赖项。</p><h1 id="08ab" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">在运行时列出依赖项</h1><p id="95ba" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">对于您的应用程序来说，在<strong class="jp ir"/>运行时打印/记录所有<strong class="jp ir">加载的</strong>包<strong class="jp ir">的版本是一个很好的实践，这样您就可以随时查看生产环境的日志，并确保有正确的版本。</strong></p><h2 id="e7fa" class="mi la iq bd lb mj mk dn lf ml mm dp lj jy mn mo ln kc mp mq lr kg mr ms lv mt bi translated">Kotlin/Java实现</h2><p id="b2c8" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">可以使用反射来获取所有加载的包。然后，对于每个包，从它的JAR清单中读取并打印实现元数据。下面是一个实现这一点的Kotlin示例代码。在演示中，我排除了内置的Java包。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="509a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是输出:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="80b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重要提示</strong>:上面的代码只打印在调用时加载到JVM的包。所以，在你的应用程序开始的时候，你想把它叫做<strong class="jp ir">而不是</strong>，但是只有在第三方组件已经初始化或启动之后。</p><h2 id="004b" class="mi la iq bd lb mj mk dn lf ml mm dp lj jy mn mo ln kc mp mq lr kg mr ms lv mt bi translated">更好的格式</h2><p id="e5a1" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">打印所有已加载的包版本可能会太冗长，因为您可能有数百个已加载的包。我还准备了另一种风格，它根据产品(标题)和版本对所有包进行分组。它还允许您决定是否打印每个产品中的所有包装。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="98b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出—无详细信息:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="08cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出—包含详细信息(剪辑):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><h2 id="2f92" class="mi la iq bd lb mj mk dn lf ml mm dp lj jy mn mo ln kc mp mq lr kg mr ms lv mt bi translated">保留依赖关系的清单</h2><p id="b775" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">由于上述方法依赖于JAR清单文件，如果您将应用程序打包到一个带有<code class="fe mc md me mf b">maven-assembly-plugin</code>(“big-JAR”)的JAR文件中，它将无法正常工作。相反，您将获得所有<code class="fe mc md me mf b">implementation*</code>字段的<code class="fe mc md me mf b">null</code>值。这是因为每个JAR可以有一个单独的清单文件，并且每个依赖项的原始清单在打包过程中会被忽略。<br/>解决方法:不要生成一个大的jar，而是使用<code class="fe mc md me mf b">maven-dependency-plugin</code>将依赖项的JAR复制到应用专用JAR文件下的<code class="fe mc md me mf b">lib</code>文件夹中。此外，使用<code class="fe mc md me mf b">maven-jar-plugin</code>将<code class="fe mc md me mf b">lib</code>文件夹添加到类路径中，如下所示。如果你有一个大罐子的解决方案，我很乐意知道。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="0b2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还建议如上图所示为<code class="fe mc md me mf b">maven-jar-plugin</code>设置<code class="fe mc md me mf b">&lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;</code>指令。这将从<code class="fe mc md me mf b">pom.xml</code>文件更新您自己的JAR中的<code class="fe mc md me mf b">MANIFEST.MF</code>文件中的<code class="fe mc md me mf b">Implementation-*</code>字段——这样您自己的包也将被正确地版本化。</p><h2 id="5d59" class="mi la iq bd lb mj mk dn lf ml mm dp lj jy mn mo ln kc mp mq lr kg mr ms lv mt bi translated">更简单的解决方案</h2><p id="c64a" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">但是等等——如果我们已经使用<code class="fe mc md me mf b">maven-dependency-plugin</code>复制了app.jar下的每个依赖JAR，还有一个更简单的解决方案！只记录<code class="fe mc md me mf b">.jar</code>文件的文件名。当使用依赖项管理器时，它们已经包含了版本号。与之前的方法相比，这种方法还有其他优点:</p><ul class=""><li id="e14b" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">它记录任何JAR的版本，不管它是否被加载。</li><li id="14c6" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">许多作者懒得在他们的JAR清单中设置<code class="fe mc md me mf b">implementation</code>字段，但是MavenCentral中的每个库都有一个文件版本，它被正确地保存在目录结构中。</li></ul><p id="b647" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是实现过程:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="6483" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出(削波):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><h2 id="c5cf" class="mi la iq bd lb mj mk dn lf ml mm dp lj jy mn mo ln kc mp mq lr kg mr ms lv mt bi translated">摘要</h2><p id="ecc7" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">无论您使用哪种语言，记录所有依赖项的版本都是一个很好的做法，这样可以确保已知的漏洞得到适当的缓解。我用Kotlin演示了几个实现替代方案。第一种方法基于打印加载到JVM中的包的版本。使用它你可以绝对确定每个软件包的版本。然而，它不如后一种简单地将依赖关系jar复制到一个已知的位置并打印它们的文件名的方法健壮。</p><p id="9ac9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以不要等下一个漏洞被发现！现在将依赖版本日志添加到您的引导代码中，您将能够立即确定是否需要缓解。</p></div></div>    
</body>
</html>