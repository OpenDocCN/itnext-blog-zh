<html>
<head>
<title>QT + ReactiveProgramming = ❤</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">QT +反应性编程= ❤</h1>
<blockquote>原文：<a href="https://itnext.io/qt-reactiveprogramming-1ba0106c17d8?source=collection_archive---------3-----------------------#2022-11-24">https://itnext.io/qt-reactiveprogramming-1ba0106c17d8?source=collection_archive---------3-----------------------#2022-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cb18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/victimsnino/ReactivePlusPlus" rel="noopener ugc nofollow" target="_blank"> ReactivePlusPlus </a>增加了对QT库的原生支持。所以，是时候向您展示如何将反应式编程范例轻松应用于QT，以使代码更加强大了！为此，让我们创建一些基于QT的应用程序！</p><h1 id="b1c9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">应用理念</h1><p id="269e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">它将是一种具有以下特征的文本预处理程序:</p><ol class=""><li id="1dcd" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">该应用程序有一个文本区插入键入一些文本</li><li id="f47c" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">存储结果的另一个文本区域(只读)</li><li id="f960" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">按钮将键入的文本从第一个区域追加到结果区域</li><li id="b757" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">两个复选框来修改我们想要插入的文本:<br/> 1)将所有符号设为大写<br/> 2)删除文本中的所有空格</li><li id="1294" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">预览模式:根据复选框实时显示修改后的文本。</li></ol><p id="e863" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi md"><img src="../Images/19774a3e0bfd71778d8a7b6d7003bcc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/1*8bHGd_y_fDJqV4AZeCAZIA.gif"/></div></figure><p id="2ae1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么我们需要反应式编程？为此，我们需要对用户的多个操作做出反应:</p><ul class=""><li id="5da8" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk ml lv lw lx bi translated">键入新符号-通过应用修改将其添加到预览文本中</li><li id="55f5" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk ml lv lw lx bi translated">复选框状态已更改—对预览文本重新应用修改</li><li id="4087" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk ml lv lw lx bi translated">单击按钮—添加已应用修改的文本并重置原始文本区域</li></ul><p id="d482" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此列表中的任何操作都会启动对另一个小部件的一系列操作/更改。此外，这些事件中的任何一个都是在“某个时间点”出现的，我们不知道“什么时候”，但是我们知道我们需要对那个事件做什么！而且有了反应式编程的帮助就容易多了！</p><h1 id="b369" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">实施:QT部分</h1><p id="3b7b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们从添加应用程序所需的所有小部件开始:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="825c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">实现:反应式逻辑</h1><p id="eaa5" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">正如我们上面讨论的，我们需要对3种类型的事件做出反应。让我们从最简单的复选框开始:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bdc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在那里，我们创建了两个<strong class="jp ir">观察对象</strong>，当它们的内部状态<strong class="jp ir">改变</strong>时，它们将发出<strong class="jp ir">复选框的新状态</strong>。因此，机罩下，一旦<strong class="jp ir"> QCheckBox </strong>的相应<strong class="jp ir">信号</strong>被<strong class="jp ir">发出</strong>，它就会发出数值。另外，我们想知道订阅时的状态。因此，observable从<strong class="jp ir">发出复选框的当前(默认)状态</strong>开始。</p><p id="3f22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，下一步是什么？现在我们需要处理输入事件，并根据我们的checkbox-observables应用修改。我们可以用下面的方法来做:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bfb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从监听<code class="fe mo mp mq mr b">textChanged</code>信号开始，因为它是代表我们打字的事件。因此，目前，我们有一个可观察的“什么都没有”，但我们想把它转换成当前的文本！为此，我们可以应用<code class="fe mo mp mq mr b">map</code>操作符，它将发出当前文本。</p><p id="c984" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后神奇的事情发生了:我们<strong class="jp ir">将来自<strong class="jp ir">两个</strong>可观察值</strong>的最新值与复选框的当前<strong class="jp ir">状态的<strong class="jp ir">当前文本</strong>和<strong class="jp ir">可观察值</strong>相结合，方法是将lambda应用于其中两个值。<br/>但<strong class="jp ir">当</strong>发生时呢？<code class="fe mo mp mq mr b">combine_latest</code>订阅这两个观察值，并在<strong class="jp ir">任何</strong>新值来自<strong class="jp ir">任何这些</strong>观察值:<br/> -文本更新<br/> -复选框的新状态时调用lambda。<br/>因此，我们在<strong class="jp ir">中<strong class="jp ir">跟踪变化</strong>两个可观测量</strong>！太神奇了！因此，我们为每个复选框做了两次！</strong></p><p id="1815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了跟踪进度，我们可以应用<code class="fe mo mp mq mr b">tap</code>操作符来添加一些日志记录。“只读”操作符不能影响可观察的发射！</p><p id="a08c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一点需要实现:我们需要在结果区域显示文本=提交+预览。我们可以用下面的方法来做！</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="577c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在那里，我们跟踪点击按钮事件。我们用<code class="fe mo mp mq mr b">with_latest_from</code>代替<code class="fe mo mp mq mr b">combine_latest </code>。它有类似的行为，但是lambda只有在主观察对象发出一个新值时才会被调用！<br/>所以，当点击按钮时，我们从文本区域获取当前文本，然后重置它(操作员<code class="fe mo mp mq mr b">tap</code>)以便能够放置新的文本！<br/>然后我们应用<code class="fe mo mp mq mr b">scan</code>操作符来累积结果文本区域的当前状态。它有内部的<code class="fe mo mp mq mr b">seed</code>值，用每个新的发射更新它，并发送每个更新的值。在我们的例子中，当我们点击按钮时，它只是在末尾添加新的文本并发送更新的值。</p><p id="06a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们想从一个空字符串开始，因为我们的最终文本区域的初始状态是一个空字符串！目前，在这一点上，我们有可观察发射文本的结果文本区域的当前实际状态。但是还有一点:预览文本。</p><p id="7532" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们需要将当前的累积状态与第一个文本区域的修改文本的可观察性结合起来。要做到这一点，我们应该再次使用<code class="fe mo mp mq mr b">combine_latest</code>！因此，我们可以在不修改实际累积状态的情况下添加预览文本。但是因为我们需要两次订阅相同的可观察值并保持相同的值(而不是生成一个新的可观察值),所以我们在<code class="fe mo mp mq mr b">text_to_append_obs</code>的末尾添加了<code class="fe mo mp mq mr b">publish().ref_count()</code>。</p><p id="4b03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要订阅这个可观察对象，只需更新结果文本区域的文本！</p><p id="a707" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链接到<a class="ae kl" href="https://github.com/victimsnino/ReactivePlusPlus/blob/main/src/examples/rppqt/interactive_window/interactive_window.cpp" rel="noopener ugc nofollow" target="_blank"> github </a>上的完整示例</p><p id="b75a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，请随意查看https://github.com/victimsnino/ReactivePlusPlus的<a class="ae kl" href="https://github.com/victimsnino/ReactivePlusPlus" rel="noopener ugc nofollow" target="_blank">库，将反应式编程应用到您的C++20代码中！</a></p></div></div>    
</body>
</html>