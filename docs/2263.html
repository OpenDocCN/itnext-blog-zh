<html>
<head>
<title>Practical RxJS and Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用RxJS和角度</h1>
<blockquote>原文：<a href="https://itnext.io/practical-rxjs-and-angular-b8d38189bb2c?source=collection_archive---------1-----------------------#2019-04-26">https://itnext.io/practical-rxjs-and-angular-b8d38189bb2c?source=collection_archive---------1-----------------------#2019-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7854" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个显示RxJS与Angular结合的实例</h2></div><p id="4558" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与RxJS <strong class="kh ir">一起工作有点像拥有超能力</strong>:你的能力允许你做非凡的事情，但它们很容易被滥用，当这种情况发生时——它会非常危险！</p><p id="d06d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我想谈谈我在使用Angular和RxJS时发现有用的实际场景，浏览一下您可能使用的有用模式以及需要注意的事项。</p><p id="f94e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从只涉及显示列表的基本情况开始，我们将进入更复杂的情况，例如停止正在进行的请求、延迟用户输入和用<em class="lb">主题</em>存储数据。</p><h1 id="118a" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">RxJS的基础</h1><h2 id="6507" class="lu ld iq bd le lv lw dn li lx ly dp lm ko lz ma lo ks mb mc lq kw md me ls mf bi translated">使用HTTP客户端获取和显示数据</h2><p id="926c" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在这个例子中，我们将使用Angular的HTTP客户端从Github的API获取存储库，并将其显示为一个列表。这是组件的外观:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/de1d42a35e3db52529fefb21deb05583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_yVBwZ0AluJFmDf2kxzxQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">告诉过你这很简单！</figcaption></figure><p id="a273" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们假设我们有一个使用CLI创建的功能性角度工作空间，并且我们创建了一个名为<em class="lb"> GithubRepositoriesComponent的新路径。</em>这是它最初的样子:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><blockquote class="nd ne nf"><p id="10a2" class="kf kg lb kh b ki kj jr kk kl km ju kn ng kp kq kr nh kt ku kv ni kx ky kz la ij bi translated">为了简单起见，我们将对组件中的所有逻辑进行编码。虽然我不建议这样做！</p></blockquote><p id="46dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们做以下事情:</p><ul class=""><li id="8020" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated">我们通过依赖注入来导入<em class="lb"> HttpClient </em></li><li id="14fd" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">我们声明了两个方法:<em class="lb"> onTextChange，</em>它只是输入元素的处理程序，以及<em class="lb"> fetchRepositories，</em>它负责执行对API的请求</li><li id="342e" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">我们将HTTP客户端返回的可观察值分配给<em class="lb"> searchResult$ </em></li></ul><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1c96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，由于使用了<em class="lb">异步</em>管道，我们不是在组件中而是在模板中订阅<em class="lb"> searchResult$ * </em>。是—我们让异步管道订阅它，而不是在组件内订阅并将结果值赋给本地属性。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ca49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是你可能已经注意到了，这是一个非常基本而且相当生疏的搜索表单。让我们通过一些RxJS魔法来改进它。</p><blockquote class="nd ne nf"><p id="3535" class="kf kg lb kh b ki kj jr kk kl km ju kn ng kp kq kr nh kt ku kv ni kx ky kz la ij bi translated">模板使用了一些有用的引导类来设计样式</p></blockquote><h2 id="bf09" class="lu ld iq bd le lv lw dn li lx ly dp lm ko lz ma lo ks mb mc lq kw md me ls mf bi translated">跳过请求</h2><p id="cfe8" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们想成为优秀的程序员，因此我们尽量不消耗我们服务中的宝贵资源。RxJS通过其强大的操作器帮助了我们，但不幸的是，我们最初的解决方案存在一些问题:</p><ul class=""><li id="15fc" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated">如果我们输入一个空格，请求会被再次发出</li><li id="fdbb" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">一旦模型发生变化，请求就会运行</li><li id="3d4c" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">如果用户在请求完成前输入了某些内容，请求会继续运行</li></ul><p id="e191" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用一些新的操作符来避免这些问题，但是我们也需要稍微重构一下我们的代码。</p><p id="ea5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们接下来要做的:</p><ul class=""><li id="3835" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated">我们没有在每次模型改变时重新分配我们的可观察值，而是在组件启动时创建一个单独的流。为了做到这一点，我们引入了一个<em class="lb">主题</em>，这是一个查询流</li><li id="3eeb" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">我们修剪并规范化我们的查询流，因此我们可以<strong class="kh ir">过滤</strong>空查询</li><li id="b0cc" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">我们添加操作符<em class="lb">去抖时间(500) </em>，以便<strong class="kh ir">每500毫秒去抖一次</strong>查询</li><li id="6e7a" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">我们添加了<em class="lb"> distinctUntilChanged，</em>，如果查询是连续输入的，那么<strong class="kh ir">将跳过</strong>个请求</li><li id="2930" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">我们用<em class="lb"> switchMap </em>将查询流映射到一个请求流</li></ul><p id="7a7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑对我们的初始解决方案进行以下更改:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="09b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">为什么选择switchMap？</em> switchMap不仅将查询映射到HTTP请求，还将取消任何正在进行的请求。请参见以下内容:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nx"><img src="../Images/0e5158b5949b8114eff1861726cef30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QOncAKIrICia9bNZPCh10A.gif"/></div></div></figure><p id="654a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我输入了一个可能要花很多时间的搜索词，所以在搜索请求运行时，我有足够的时间重新输入一个词。</p><p id="1282" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您在network选项卡中看到的，前三个请求被取消了！</p><p id="8176" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">耶！🎉</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="de6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的应用程序可以做的下一件事是，当我们将鼠标悬停在存储库名称上时，显示所有者的信息。我们可以显示姓名、头像、简历和所有者所属的组织，为此我们需要提出一个额外的请求。</p><p id="c190" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要做什么？</p><ul class=""><li id="9254" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated">当用户悬停并离开存储库项目时创建处理程序</li><li id="9af3" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">当鼠标悬停在存储库上时获取组织，当鼠标离开时重置</li><li id="7e17" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">因为在我们的列表中保留属于组织的存储库是没有意义的，我们将借助一个强大的自定义操作符来过滤它！</li><li id="8097" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">为了简化，稍微重构一下我们的初始代码</li></ul><h2 id="4dc6" class="lu ld iq bd le lv lw dn li lx ly dp lm ko lz ma lo ks mb mc lq kw md me ls mf bi translated">自定义运算符</h2><p id="f813" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">创建自定义操作符是一项非常有用的技术，对于重用我们在类似情况下最终会用到的一些逻辑，或者通过将通用操作符与我们的领域业务逻辑混合在一起，使其更具声明性，从而提高可读性，这种技术非常有用。</p><p id="fe9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在我们的应用程序中，我们想要添加一个操作符来过滤一个可观察到的存储库，其中只有存储库属于一个用户，而不属于一个组织。</p><p id="bfdc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码可能是这样的:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="cd18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码简单地对存储库数组应用了一个过滤函数，并将其映射为一个可观察对象。</p><h2 id="7325" class="lu ld iq bd le lv lw dn li lx ly dp lm ko lz ma lo ks mb mc lq kw md me ls mf bi translated">完整示例</h2><p id="4a23" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">代码的其余部分应该相当简单:</p><ul class=""><li id="1c93" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated">我们用<em class="lb">存储库$ </em>替换了<em class="lb">搜索结果$ </em></li><li id="0c97" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">我们添加了可观察的<em class="lb">组织$ </em>和<em class="lb">选择的存储$ </em>主题</li><li id="0c18" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">处理程序<em class="lb"> onRepositoryMouseEvent </em>负责更新<em class="lb"> selectedRepository$ </em></li><li id="d12f" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">自定义操作符<em class="lb"> filterByUOwnerType </em>被添加到<em class="lb">存储库$ </em>流中</li><li id="9208" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">在模板中，我们添加了组织列表和所有者部分，当存储库被悬停时会出现</li></ul><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="09d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是它看起来的样子:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi of"><img src="../Images/f7f9d2af22e8eaa4178dfa50f6002885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ukvZnxzqT3yTKitCVjvVJQ.gif"/></div></div></figure><p id="e455" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哦，对了，那是我！🙄</p><h1 id="6b31" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">状态管理</h1><p id="0a4c" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">不，这不是关于<em class="lb"> NGRX </em>，或者<em class="lb"> Redux </em>的另一种解释。</p><p id="fa57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想向你们展示一些问题，当我们从我们的观察对象和主题中获取当前状态时。</p><p id="a432" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比方说，我们想要检索最新收到的信息，而不需要通过模板，正如我们所看到的，这是相当容易的。</p><p id="963b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们添加一个按钮，允许用户导出当前的存储库列表(当然，我们不会实现该功能，但我们将只记录列表)。</p><p id="b3ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单，对吧？</p><p id="fe97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建导出函数:</p><pre class="mm mn mo mp gt og oh oi oj aw ok bi"><span id="a555" class="lu ld iq oh b gy ol om l on oo">exportRepos() {<br/>    <em class="lb">this</em>.repositories$.subscribe(repos =&gt; {<br/>        <em class="lb">console</em>.log(repos);<br/>        <em class="lb">// export function here<br/>    </em>});<br/>}</span></pre><p id="8e0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看它的表现如何:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi op"><img src="../Images/a739846a97b26c9e859359fb2882f723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0QLd2zSp8Dg6iXRUhYEtQw.gif"/></div></div></figure><p id="2a6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您可能已经看到的，日志直到可观察对象发出一个新值才出现！原因是可观察对象在发出值后被订阅<strong class="kh ir">。</strong></p><p id="ccac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我们引入了另一个叫做<em class="lb"> shareReplay的操作符。</em></p><p id="c46c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个操作员将保存一个我们以后可以订阅的排放记忆。在引擎盖下，它使用一个<em class="lb"> ReplaySubject </em>来保持状态。因为我们只希望它保存最新的发射，这是我们的当前状态，所以我们需要传递一个名为<em class="lb"> bufferSize </em>的参数，我们将它设置为<em class="lb"> 1，</em>用简单的英语来说就是“请在内存中保存最新的1次发射”。</p><p id="37ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们最终的结果:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oq"><img src="../Images/bbe5ea944a16ca2932157f18d5e53e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EkvWjPMk8eNWXJPbTXrFWw.png"/></div></div></figure><p id="aa00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看我们的应用程序将如何工作！</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi op"><img src="../Images/e82e85d57670225203fb88624c657b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-otqLWTJJ5g1L3iipnE03Q.gif"/></div></div></figure><p id="a636" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">等等，什么？你注意到了吗，当我输入“react”作为搜索词时，不用我们点击按钮，存储库又被记录了。这听起来确实像是一个错误，如果我可以补充的话，是一个非常常见的错误。</p><p id="565c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单——我们忘了更改导出函数，该函数应该订阅可观察对象，但是马上关闭订阅！我们手动退订吗？也许不需要。让我们使用操作符<em class="lb"> take，</em>一旦它发出的次数等于我们作为参数给它的次数，它就会取消订阅。</p><p id="e42b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们解决这个问题！我们用运算符<em class="lb">来表示我们的可观察值take(1): </em></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi or"><img src="../Images/59593f8b6f4d51edac6139de50274d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSCkhW5u6RH0vjhh1OKNxw.png"/></div></div></figure><h2 id="d557" class="lu ld iq bd le lv lw dn li lx ly dp lm ko lz ma lo ks mb mc lq kw md me ls mf bi translated">为什么这很重要？</h2><ul class=""><li id="a09d" class="nj nk iq kh b ki mg kl mh ko os ks ot kw ou la no np nq nr bi translated">这是逻辑错误的常见原因。方法在不应该被调用的时候被调用</li><li id="4bb2" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">这是内存泄漏的一个常见原因，因为订阅没有被清理！</li><li id="f35f" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">可观测辐射越频繁，问题就越大。尝试绝对热衷于此与可观的实时来源发射！</li><li id="959e" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">在NGRX中使用<em class="lb"> store.select() </em>是很常见的，所以在使用时要小心</li></ul><h1 id="2dfe" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">最后的话</h1><p id="8755" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">正如您可能已经看到的，我们用几行RxJS代码就完成了原本需要数百行代码才能完成的任务。它是一个强大的工具，如果理解得好，使用得正确，它真的可以让你的代码美观易读。</p><p id="eddd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您可能已经看到的，使用它也不需要太多的时间就可以犯错误。对某个行为的小小误解可能会导致bug和内存泄漏。如果您的团队开始使用它，这是需要考虑的事情——但是请放心——它是值得的。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="0d62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">如果你喜欢这篇文章，请关注我的</em> <a class="ae ov" href="https://medium.com/@.gc" rel="noopener"> <em class="lb">中的</em> </a> <em class="lb">或</em> <a class="ae ov" href="https://twitter.com/home" rel="noopener ugc nofollow" target="_blank"> <em class="lb">推特</em> </a> <em class="lb">以获取更多关于Angular、RxJS、Typescript等的文章！</em></p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="8cad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">最初发布于</em><a class="ae ov" href="https://frontend.consulting/practical-rx-js-and-angular" rel="noopener ugc nofollow" target="_blank"><em class="lb">https://frontend . consulting</em></a><em class="lb">。</em></p></div></div>    
</body>
</html>