<html>
<head>
<title>5 interesting technical challenges I faced when building FilePond</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在构建FilePond时面临的5个有趣的技术挑战</h1>
<blockquote>原文：<a href="https://itnext.io/filepond-frontend-trickery-a3073c934c77?source=collection_archive---------2-----------------------#2018-07-03">https://itnext.io/filepond-frontend-trickery-a3073c934c77?source=collection_archive---------2-----------------------#2018-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3263" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://pqina.nl/filepond" rel="noopener ugc nofollow" target="_blank"> FilePond </a>是2018年3月发布的MIT授权JavaScript文件上传库。它可以作为本地JavaScript插件使用，但也可以使用特殊的适配器组件与<a class="ae kl" href="https://github.com/pqina/react-filepond" rel="noopener ugc nofollow" target="_blank"> Vue </a>、<a class="ae kl" href="https://github.com/pqina/react-filepond" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae kl" href="https://github.com/pqina/ngx-filepond" rel="noopener ugc nofollow" target="_blank"> Angular </a>和<a class="ae kl" href="https://github.com/pqina/jquery-filepond" rel="noopener ugc nofollow" target="_blank"> jQuery </a>一起使用。</p><p id="c14e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将看看FilePond动画引擎，它渲染拖放区域的方式，图像预览插件如何利用新的createImageBitmap API，最后我们将研究我们的老朋友文件输入的局限性。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/0a0ddbe734df6d653856df26467a1288.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/1*S30UjPcfsrh95S3fnrOyzQ.gif"/></div></figure><h1 id="826a" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">动画引擎</h1><p id="8b6a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我想用一个中央动画循环驱动整个FilePond接口，因为在从DOM读取信息的同时用多个循环创建高性能动画会变得非常棘手。</p><p id="c7e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FilePond接口由一个视图树组成，每个视图都有一个根元素，并有一个<code class="fe lx ly lz ma b">read</code>和<code class="fe lx ly lz ma b">write</code>函数。对于核心动画循环的每个节拍，FilePond调用根视图的read方法，然后根视图调用其子视图的read方法，依此类推。然后，当所有视图都被读取后，它调用根视图上的write方法，这个视图调用其子视图上的write方法，依此类推，直到到达视图树的末尾。所以它基本上是在FilePond DOM子树上读，然后在同一个子树上写。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/4928e0777de6ca5f242111356e6b0403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oUamfM3H0z_bMR2fqYtduQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">Chrome图层检查器显示文件池视图</figcaption></figure><p id="623f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">read</code>方法从DOM中读取布局信息。这包含当前元素位置、宽度、高度和边距等数据。然后将检索到的布局信息存储在每个视图中，以便可以在write方法中使用。因为所有的读取被分组，所以浏览器只需要进行一次布局计算，随后对布局信息的请求是“自由的”。</p><p id="8d07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">write</code>方法负责更新视图。它将应用布局信息，更新文本元素，并应用附加到视图的动画。这些动画可以是补间动画或基于弹簧的动画。</p><p id="7b0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">核心动画循环一直运行，直到不再接收动作、视图已经更新、所有动画已经完成并且界面达到空闲状态。然后，FilePond等待，直到空闲状态被用户或API调用扰乱。</p><p id="e411" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为DOM读取和写入已经分组，我们只使用“变换”和“不透明度”来制作动画，所以没有<a class="ae kl" href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing" rel="noopener ugc nofollow" target="_blank">布局破坏</a>(写入方法不能使布局无效，因为读取已经完成)，浏览器只需进行合成，从而实现非常快的性能。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mk"><img src="../Images/0fb634906601c9c0093c4074f4ce945d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3ugtsvBmvt853CScedofw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">一个典型的6倍CPU速度的文件池帧:所有逻辑运行，DOM更新，浏览器重新计算样式，最后处理合成</figcaption></figure><h1 id="ef21" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">制作文件拖放区的动画</h1><p id="cfb4" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">文件池放置区域需要随着每个文件的放置而垂直增长。我非常想制作这个动画，因为所有其他元素都是动画，而且拖放区大小的改变让我感觉很不合适。</p><ul class=""><li id="3652" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">我可以使用<code class="fe lx ly lz ma b">scaleY</code>来缩放GPU上的拖放区域，但是缩放圆角矩形会导致圆角拉伸，这看起来很奇怪。</li><li id="633a" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">或者我可以制作<code class="fe lx ly lz ma b">height</code>属性的动画，但是那会非常慢，因为它不能在GPU上合成。此外，它没有子像素，所以你可以在下面的动画中看到，当左边的方块接近最大高度时，动画变得不太流畅。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/7f09a236b08b24809b63b6e9e4f8a74e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/1*UcwrLvi9bkoPCm-XVUuApQ.gif"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">左动画高度，右动画变换scaleY ( <a class="ae kl" href="https://codepen.io/rikschennink/pen/jKJgOb" rel="noopener ugc nofollow" target="_blank"> codepen </a>)</figcaption></figure><p id="b221" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避免这种情况，我们可以使用一种叫做<a class="ae kl" href="https://w3.eleqtriq.com/2014/03/the-holy-grail-of-image-scaling/" rel="noopener ugc nofollow" target="_blank"> 9切片缩放</a>的技术</p><p id="9856" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用三个独立的div来放置区域，而不是一个div。</p><ol class=""><li id="b9d2" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk na mr ms mt bi translated">呈现左上角和右上角圆角的静态顶部div。</li><li id="952b" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk na mr ms mt bi translated">在y轴上缩放的中间div。</li><li id="2536" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk na mr ms mt bi translated">被转换并呈现左下角和右下角的底部div。</li></ol><p id="975f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了模拟高度动画，我们将中间的div高度设置为<code class="fe lx ly lz ma b">1px</code>，并使用<code class="fe lx ly lz ma b">scaleY()</code>变换来改变它的高度。设置<code class="fe lx ly lz ma b">transform: scaleY(100)</code>将导致<code class="fe lx ly lz ma b">100px</code>高div。同时，我们可以使用<code class="fe lx ly lz ma b">transform: translateY(100px)</code>将底部div移动到100像素的垂直偏移量</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nb"><img src="../Images/78ad35ae8eedc7a89c54778cc9f9c979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrhiemLARXGutUjqo6eaKQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">这是它在Chrome web inspector图层视图中的外观</figcaption></figure><p id="1674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过结合这两种变换，我们可以创建动画高度的错觉，动画表现良好，我们的角落保持良好和尖锐，我们得到了子像素定位的平滑。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/6d0889f102cc92d9cec903a624529a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/1*cUGV5BD6wnTG4S0GV0iBcw.gif"/></div></figure><h1 id="edd0" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">假进度指示器</h1><p id="a7c0" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在高速连接下，一个微小的文件可以在眨眼之间上传到服务器上。这可能会让您的用户怀疑他们的文件是否已经上传，因为状态几乎立即切换到<em class="nd">“上传完成”</em>，跳过了“<em class="nd">忙上传...”</em>状态。</p><p id="b2fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了防止这种不确定性，FilePond将在每次上传的第一秒显示一个假的进度指示器。如果上传时间较长，则实际的文件上传过程将会接管。这可以给用户额外的信心，即文件实际上已经被上传。</p><p id="5c6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自己试试，哪个版本感觉更好？</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ne"><img src="../Images/1ec755b07bed33cf2d180f23940445fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*h2QzZa_3MjuQUf4L5COz6Q.gif"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">左:有假进度指示器，右:没有</figcaption></figure><h1 id="74e5" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">文件输入是怎么回事？</h1><p id="d8df" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">这是非常不幸的，但是除了严重的风格问题，我们心爱的文件输入有另一个更紧迫的限制。无法设置文件输入的<code class="fe lx ly lz ma b">files</code>属性。我尽力了。</p><p id="e018" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我完全理解为什么设置一个指向<code class="fe lx ly lz ma b">value</code>属性的路径是非常安全的(您可以将它指向用户文件系统上的一个文件)，但是选择将一个新创建的文件对象添加到文件列表会非常有用。</p><p id="2049" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前，拖放的文件必须异步上传。因为文件对象包含在drop事件中，所以它们不能存储在文件输入中。它们要么保存在内存中，要么使用<code class="fe lx ly lz ma b">XMLHttpRequest</code>(或<code class="fe lx ly lz ma b">fetch</code>)立即上传。</p><blockquote class="nf ng nh"><p id="54ee" class="jn jo nd jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">在浏览器中创建的文件对象也是如此。例如，用文本编辑器生成的文件，或者在客户端修改过的图像。</p></blockquote><p id="e1f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们可以设置或添加文件到文件输入的<code class="fe lx ly lz ma b">files</code>属性。</p><ul class=""><li id="d1d6" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">设置表单验证会更容易，因为拖放的文件和通过浏览窗口在文件系统上选择的文件都可以存储在同一个列表中。</li><li id="0b90" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">我们不再需要修改服务器来接受异步上传。通常我们想知道哪些文件已经上传，这样我们就可以在最终的表单提交中引用它们。</li><li id="4678" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">我们可以更容易地应用渐进增强技术。服务器将只接收文件列表，不管它们来自哪里。如果某个CMS在其表单模块中公开了一个文件输入，我们可以在前端做任何我们想做的事情，只要我们设置了文件列表。</li></ul><p id="a1e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避免这个问题，<a class="ae kl" href="https://github.com/pqina/filepond-plugin-file-encode" rel="noopener ugc nofollow" target="_blank"> FilePond文件编码插件</a>可以将文件编码为base64字符串。为了做到这一点而不停止动画文件被发送到一个工作线程进行编码。当worker完成编码时，base64编码的字符串被发送回来并存储在一个隐藏的输入字段中。</p><p id="2cc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦上传，base64字符串就可以在服务器上变回实际的文件。</p><p id="ab24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这创造了与父表单post同步发送文件的机会，但也产生了一些其他问题。一个已经说过了，数据需要在服务器上变回一个文件。另一个与内存使用有关。提交时，字符串比文件对象占用更多的内存。这导致一些浏览器在提交包含大量数据的表单时出错。另一件要记住的事情是，一些服务器安全软件会将表单数据标记为可疑的(由于值的长度)。</p><h1 id="eddb" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">图像加载</h1><p id="ba8a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">当把一张图片放到FilePond上时，我想展示一个预览，这给单调的体验增加了一点色彩。由于预览图像应该是可选的，我把这个功能移到了一个单独的插件中。然后，该插件将呈现拖放图像的预览，并根据图像裁剪插件提供的裁剪信息调整这些预览。</p><p id="5a42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是，如果你想渲染一个大的JPEG编码图像的预览，浏览器需要一些时间来解码图像和渲染结果位图数据。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nl"><img src="../Images/dceb6941003c553c16c2cb8c452efc7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPgqoTvUVwY9ATL05WuiSA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">6MB JPEG的解码时间在6x CPU速度变慢的情况下测得</figcaption></figure><p id="9240" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当浏览器正在解码时，主线程停止，一切都冻结了。对于任何正在运行的动画来说，这都是一个坏消息。</p><p id="fdf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，FilePond内部提供了一个选项来对CPU繁重的操作进行排队。它将等待运行这些操作，直到它处于空闲状态。这允许对繁重的操作进行计时，并防止动画意外冻结。</p><p id="c647" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为一旦浏览器被锁定，显示某种繁忙状态还是不错的。事实证明，我很幸运，<a class="ae kl" href="http://www.phpied.com/css-animations-off-the-ui-thread/" rel="noopener ugc nofollow" target="_blank">基于WebKit的浏览器可以运行CSS动画，即使主线程被冻结</a>。在处理重负载队列之前，文件池将切换到繁忙的<strong class="jp ir"> </strong>状态，并且文件进度指示器将开始其无限旋转动画(不受即将被阻塞的主线程的影响)。</p><p id="7295" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过在单独的线程上解码图像，可以进一步提高图像预览插件的速度。我们可以通过最近添加的<code class="fe lx ly lz ma b"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/createImageBitmap" rel="noopener ugc nofollow" target="_blank">createImageBitmap</a></code> API来做到这一点(在撰写本文时，Chrome和Firefox都支持它)。文件对象被发送给Web Worker，Web Worker使用<code class="fe lx ly lz ma b">createImageBitmap</code>对文件进行解码，然后返回一个<code class="fe lx ly lz ma b">BitmapImage</code>对象，该对象可以使用<code class="fe lx ly lz ma b">drawImage</code>方法呈现给<code class="fe lx ly lz ma b">&lt;canvas/&gt;</code>。</p><h1 id="32e9" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">暂时就这样吧！</h1><p id="e513" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">让我知道这是否有趣！我很乐意再写一些关于其他挑战的内容，比如渲染平滑的渐变，让屏幕阅读器可以访问FilePond，处理和读取JPEG EXIF方向，以及为React、Vue和Angular编写适配器组件。</p><p id="c431" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有任何问题，<a class="ae kl" href="https://twitter.com/rikschennink" rel="noopener ugc nofollow" target="_blank">在Twitter上找到我</a></p></div></div>    
</body>
</html>