<html>
<head>
<title>Promises &amp; Continuation Monad in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的承诺和延续单子</h1>
<blockquote>原文：<a href="https://itnext.io/promises-continuation-monad-in-javascript-f2d70ceb24a4?source=collection_archive---------2-----------------------#2019-03-26">https://itnext.io/promises-continuation-monad-in-javascript-f2d70ceb24a4?source=collection_archive---------2-----------------------#2019-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/17b7c62b325e6fa856bca8cb868c057d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cd-LFfz9YMUTTgERHgxWAA.png"/></div></div></figure><p id="f8cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是研究javascript异步编程的基础数学和机制的三部分中的一部分</p><ol class=""><li id="fa69" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae lf" href="https://medium.com/@dimpapadim3/promises-continuation-monad-in-javascript-f2d70ceb24a4" rel="noopener">承诺&amp;JavaScript中的延续单子</a> (this)</li><li id="6130" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><a class="ae lf" href="https://medium.com/@dimpapadim3/async-await-a-k-a-continuation-co-monad-in-javascript-3593f0092413" rel="noopener">JavaScript中的异步/等待延续协同单子</a></li><li id="308b" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">反应式扩展RxJs、连续单子和观察者模式</li></ol></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="c697" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我想理解延续时，我从基础开始:<strong class="ka ir"> <em class="ls">回调</em> </strong>经过多次重构，我发现了承诺，最后是<em class="ls">所有单子之母，它被称为:延续单子。</em></p><p id="2c0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设你有一个简单的函数</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3d7d" class="mc md iq ly b gy me mf l mg mh">const square = x =&gt;  x * x ;<br/>console.log(square(4));     // prints 16</span></pre><h1 id="2d27" class="mi md iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">第一部分</h1><h2 id="3b8a" class="mc md iq bd mj nf ng dn mn nh ni dp mr kj nj nk mv kn nl nm mz kr nn no nd np bi translated">1)使用回调并移除返回类型</h2><p id="3c26" class="pw-post-body-paragraph jy jz iq ka b kb nq kd ke kf nr kh ki kj ns kl km kn nt kp kq kr nu kt ku kv ij bi translated">您可以传递回调并移除返回类型。这就是著名的<a class="ae lf" href="https://en.wikipedia.org/wiki/Continuation-passing_style" rel="noopener ugc nofollow" target="_blank">传接式</a></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5947" class="mc md iq ly b gy me mf l mg mh">const square= <strong class="ly ir">(x,callback)=&gt;callback(x*x);</strong><br/>square(4,console.log);  // prints 16</span></pre><p id="7b2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以像这样用回调来构造函数:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="c010" class="mc md iq ly b gy me mf l mg mh">const square = (x,callback)=&gt;callback(x*x);<br/>square(2,<br/>         x=&gt;square(x,console.log));  // prints 16</span></pre><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="317e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这当然会导致<a class="ae lf" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">回调地狱</a>哪个<a class="ae lf" href="http://wiki.c2.com/?ArrowAntiPattern" rel="noopener ugc nofollow" target="_blank">是箭头反模式</a>的特例…</p><h2 id="52b0" class="mc md iq bd mj nf ng dn mn nh ni dp mr kj nj nk mv kn nl nm mz kr nn no nd np bi translated">2) <a class="ae lf" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">库里</a>回调</h2><p id="911c" class="pw-post-body-paragraph jy jz iq ka b kb nq kd ke kf nr kh ki kj ns kl km kn nt kp kq kr nu kt ku kv ij bi translated">如果我们<a class="ae lf" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank"> curry </a>这个动作并返回它的结果会怎么样？！我们可以这样做:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="2631" class="mc md iq ly b gy me mf l mg mh">const square = <strong class="ly ir">(x)=&gt;callback</strong>=&gt;callback(x*x);<br/></span></pre><p id="98c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你长时间观察这个并将<strong class="ka ir">回调</strong>重命名为<strong class="ka ir">解决</strong>，你会发现这实际上类似于一个<a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">承诺</strong> </a> <strong class="ka ir">。</strong>并这样使用它:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="4b5a" class="mc md iq ly b gy me mf l mg mh">square(4)(y=&gt;console.log(y));  // prints 4</span></pre><p id="bb0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[旁注:我们<strong class="ka ir">可以把它变成一个承诺</strong>，如果我们把回调封装到一个公开<strong class="ka ir">然后</strong>函数的对象中，就像这样:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="08f6" class="mc md iq ly b gy me mf l mg mh">const square = (x)=&gt;<strong class="ly ir">callback=&gt;callback(x*x)</strong>;// transform it into</span><span id="0f6a" class="mc md iq ly b gy nx mf l mg mh">const square = (x)=&gt;({<strong class="ly ir"><em class="ls">then</em></strong>:<strong class="ly ir">resolve=&gt;resolve(x*x)</strong>});</span><span id="aea6" class="mc md iq ly b gy nx mf l mg mh">square(2).then(r=&gt;console.log(r))</span></pre><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="232a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">附注结束]</p><p id="7e36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它看起来好一点，但我们可以做更多的重构动作。这个<strong class="ka ir">回调= &gt;回调(x*x) </strong>的返回类型实际上是<strong class="ka ir"> (int → ⊥) → ⊥ </strong>其中<strong class="ka ir"> ⊥ </strong>是<a class="ae lf" href="https://ncatlab.org/nlab/show/relation+between+type+theory+and+category+theory" rel="noopener ugc nofollow" target="_blank">初始对象<em class="ls">/空类型/false。</em> </a> <em class="ls">这是说，如果你给我一个函数，它取一个int i，不返回任何值</em> <strong class="ka ir"> (int → ⊥) </strong> <em class="ls">我会对它做一些处理，然后不返回任何值</em> <strong class="ka ir"> (int → ⊥) → ⊥ </strong>。</p><h2 id="4fc5" class="mc md iq bd mj nf ng dn mn nh ni dp mr kj nj nk mv kn nl nm mz kr nn no nd np bi translated">3)推广返回的延拓</h2><p id="9dee" class="pw-post-body-paragraph jy jz iq ka b kb nq kd ke kf nr kh ki kj ns kl km kn nt kp kq kr nu kt ku kv ij bi translated">如果我们想推广它，而不是⊥返回一个任意的类型t，那会怎么样呢？</p><p id="9c95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> (int → T) → T </strong>:</p><p id="92ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，如果你给我一个函数，它接受一个int i并给出一个T，我会对它做些什么，然后返回T，这是</p><p id="abe5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> (int → ⊥) → ⊥ </strong></p><p id="5015" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们使用非类型化的javascript，所以这并不重要，但是对于像Typescript这样的强类型js语言扩展，我们需要积极关注这一点。</p><p id="3644" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<strong class="ka ir">函数签名(U→ T) → T </strong>算是比较有名的，我们可以称之为<strong class="ka ir"> <em class="ls">延续</em> </strong></p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/2d67de733d70d9e96c286345d92d1915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjlAMtmZiQX-nk0ASvIkDw.jpeg"/></div></div></figure><h1 id="a4ef" class="mi md iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">第二部分</h1><p id="32ad" class="pw-post-body-paragraph jy jz iq ka b kb nq kd ke kf nr kh ki kj ns kl km kn nt kp kq kr nu kt ku kv ij bi translated">如果我们想更进一步，那么单子就来了。这部分有点复杂，跟着做就行了。我们可以从这个延续类型<strong class="ka ir"> (U→ T) → T </strong>组成一个单子就是<strong class="ka ir">回调= &gt;回调(x*x) </strong>。对于那些不知道单子是什么的人:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/6ed56627370d0c13ae82b5dae7b64b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkED5v7PrPMzWA2uCWw1BA.png"/></div></div></figure><ul class=""><li id="2cb3" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv oa lc ld le bi translated"><strong class="ka ir">函子</strong>是一个容器。例如，List是最著名的函子。这里是延续<strong class="ka ir"> (U→ T) → T，我们可以把它看成是U. </strong>的容器</li><li id="67e0" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv oa lc ld le bi translated"><a class="ae lf" href="https://ncatlab.org/nlab/show/endofunctor" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">内函子</strong> </a>是从一个范畴到自身的<a class="ae lf" href="https://medium.com/@dimpapadim3/the-definite-guide-to-functors-in-js-6f5e82bd1dac" rel="noopener">函子</a>。在这种情况下，一个延续<strong class="ka ir"> (A→ T) → T </strong>可以转换成另一个延续<strong class="ka ir"> (B→ T) → T </strong>两者都属于同一类别的<strong class="ka ir">延续</strong>，因此这是一个结束函子。</li><li id="5ca4" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv oa lc ld le bi translated"><strong class="ka ir">幺半群</strong>是一个<a class="ae lf" href="https://en.wikipedia.org/wiki/Algebraic_structure" rel="noopener ugc nofollow" target="_blank">结构</a>，有一个<a class="ae lf" href="https://en.wikipedia.org/wiki/Binary_operation" rel="noopener ugc nofollow" target="_blank">二元运算</a> <strong class="ka ir"> ∘ </strong>和一个<a class="ae lf" href="https://en.wikipedia.org/wiki/Identity_element" rel="noopener ugc nofollow" target="_blank">单位元</a> <strong class="ka ir"> Id </strong>。从某种意义上说，弄清楚如何像<strong class="ka ir">((a→t)→t)<em class="ls">∘</em></strong><strong class="ka ir">((b→t)→t)</strong></li></ul><p id="a954" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你要记住的是单子有两个运算:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="f557" class="mc md iq ly b gy me mf l mg mh"><em class="ls">c → T(c)          //</em><strong class="ly ir"><em class="ls">Return</em></strong></span><span id="a77b" class="mc md iq ly b gy nx mf l mg mh">T(T(c))<em class="ls">→ T(c)     //</em><strong class="ly ir"><em class="ls">join </em></strong></span></pre><p id="8c58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1) </strong>在第一个操作中<em class="ls"> c → T(c) </em>我们可以从一个对象C开始，得到一个容器<em class="ls"> T(c)。</em></p><p id="46e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2) </strong>第二个T(T(c)) <em class="ls"> → T(c) </em>意思是我们可以把两个容器合/平为一体。</p><h2 id="f452" class="mc md iq bd mj nf ng dn mn nh ni dp mr kj nj nk mv kn nl nm mz kr nn no nd np bi translated">4)提取延续结构</h2><p id="8707" class="pw-post-body-paragraph jy jz iq ka b kb nq kd ke kf nr kh ki kj ns kl km kn nt kp kq kr nu kt ku kv ij bi translated">现在我们只需要从square函数中提取延续机制，这样我们就可以重用它了。所以我们可以有单子的第一部分，Return<strong class="ka ir"><em class="ls">c→T(c)</em></strong><em class="ls">，</em>这是用延续符对值的换行，就像这样:</p><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5b99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了最终得到延续单子，我们必须添加组成延续的<strong class="ka ir">绑定方法:</strong> T (A) → (A → T (B)) → T (B)。这是迄今为止最难理解的部分，如果你一次都不尝试自己去构建，你就无法真正理解它。</p><p id="3962" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们在这个中用<strong class="ka ir"> (A→ T) → T代替T，那就是单子</strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="58d5" class="mc md iq ly b gy me mf l mg mh"><strong class="ly ir">T (A) → (A → T (B)) → T (B)</strong></span></pre><p id="6282" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在字体形式中得到这样荒谬的东西</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="9824" class="mc md iq ly b gy me mf l mg mh"><strong class="ly ir">((A→ T) → T)→( A→((B→ T) → T))→ ((B→ T) → T)</strong></span></pre><p id="704c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里说:“如果你给我一个A的延拓[ <strong class="ka ir"> (A→ T) → T]和一个取A并给B一个延拓的函数[A→((B→T)→T]那么我可以给你一个B的延拓</strong>[<strong class="ka ir">(B→T)→T]”</strong></p><p id="7b13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你明白为什么下面的绑定方法像<a class="ae lf" href="https://simple.wikipedia.org/wiki/Hacker_koan" rel="noopener ugc nofollow" target="_blank"> js禅宗公案</a>一样工作时，你可以思考一下。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b493" class="mc md iq ly b gy me mf l mg mh">var bind = (cont1, func)=&gt;(callback=&gt;cont1(contResult=&gt;func(contResult)(callback)));</span></pre><p id="1046" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，让我试着解释一下。如果你到了这里，顺便恭喜你。</p><p id="2a5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的我们有一个cont1 <strong class="ka ir"> (A→ T) → T </strong>和一个func <strong class="ka ir"> A→((B→ T) → T) </strong>我们要返回<strong class="ka ir"> (B→ T) → T . </strong>所以我们先写<strong class="ka ir"> </strong> callback= &gt;也就是<strong class="ka ir"> (B→ T) </strong>，剩下的这个应该返回值T，我们要怎么得到这个值呢？我们可以从<strong class="ka ir"> cont1 =(A→ T) → T </strong>中得到它，只需传递一个函数，这个函数带有一个名为<strong class="ka ir"> contResult的参数A。好的，直到现在我们有了</strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="a867" class="mc md iq ly b gy me mf l mg mh">bind = (cont1, func)=&gt;(callback=&gt;cont1(contResult=&gt;</span></pre><p id="222a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…你能看到剩下的吗？？？</p><p id="4fbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将结束构造。看看下面这个js提琴的结果标签:</p><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="df5d" class="mi md iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">总而言之:</h1><ol class=""><li id="5219" class="kw kx iq ka b kb nq kf nr kj ob kn oc kr od kv lb lc ld le bi translated">从初始功能开始</li></ol><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="0cf0" class="mc md iq ly b gy me mf l mg mh">const f = x =&gt;  x * x ;<br/>console.log(f(4));     // prints 16</span></pre><p id="ef29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.使用回调并移除返回类型</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3910" class="mc md iq ly b gy me mf l mg mh">const f1 = <strong class="ly ir">(x,callback)=&gt;callback(x*x);</strong></span></pre><p id="bc96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.库里回电</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b29d" class="mc md iq ly b gy me mf l mg mh">const squareCont = <strong class="ly ir">(x)=&gt;callback=&gt;callback(x*x);</strong></span></pre><p id="bbda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">5.提取延续结构也称为单子的返回方法</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b24b" class="mc md iq ly b gy me mf l mg mh">const <strong class="ly ir">toCont=v=&gt;callback=&gt;callback(v);</strong></span><span id="9d90" class="mc md iq ly b gy nx mf l mg mh"><strong class="ly ir">toCont</strong>(x=&gt;x*x) <br/>        (y=&gt;<strong class="ly ir">toCont</strong>(y(4))<br/>          (t=&gt;console.log(t)));</span></pre><p id="3c9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">6.添加绑定单子方法，从而完成单子</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="28c2" class="mc md iq ly b gy me mf l mg mh">var bind = (cont1, func)=&gt;(callback =&gt;cont1(contResult=&gt;func(contResult)(callback)));</span></pre><p id="da70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有问题吗？就在下面留言评论吧。</p><p id="6af7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你想更进一步吗？阅读如何从承诺走向异步功能性错误处理</p><p id="b5d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">阅读更多信息:</p><div class="oe of gp gr og oh"><a href="https://medium.com/@dimpapadim3/the-definite-guide-to-functors-in-js-6f5e82bd1dac" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">Js中的函子指南</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">让我告诉你什么是面向对象编程的函子:它是一个容器。连同一张地图…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov jw oh"/></div></div></a></div><p id="82e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请随时在LinkedIn与我联系</p></div></div>    
</body>
</html>