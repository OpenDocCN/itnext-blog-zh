<html>
<head>
<title>Light-Arrow: composable and type safe asynchronous programming for Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Light-Arrow:用于Typescript的可组合且类型安全的异步编程</h1>
<blockquote>原文：<a href="https://itnext.io/light-arrow-composable-and-type-safe-asynchronous-programming-for-typescript-6d6b3380b8d0?source=collection_archive---------2-----------------------#2020-11-01">https://itnext.io/light-arrow-composable-and-type-safe-asynchronous-programming-for-typescript-6d6b3380b8d0?source=collection_archive---------2-----------------------#2020-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bd3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">欢迎</strong>阅读本系列的第1部分，使用typescript库Light Arrow在Typescript中进行函数式编程。在第1部分中，我们将介绍箭头数据类型。在第2部分中，我们将构建一个完全类型安全的http服务器。</p><p id="10f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">我是《光之箭》的作者，该项目仍处于早期阶段，如有任何反馈，请联系</em><a class="ae km" href="https://github.com/lauri3new" rel="noopener ugc nofollow" target="_blank"><em class="kl"/></a><em class="kl">，谢谢！</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/2730922ee321310cd0de761185066645.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*db8Jt0pwXFjQaPWTJ8IB6g.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">箭头数据类型</figcaption></figure><h2 id="8be3" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">箭头和承诺</strong></h2><p id="c312" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">箭头是<strong class="jp ir">描述</strong>异步操作的数据结构，异步操作可以成功，结果值为R或错误值为E，这取决于一些依赖关系d。实际上，我们编写的许多程序或程序的一部分都符合这种描述，并且经常使用承诺来实现这一目的。然而，承诺也有一些缺点。</p><p id="adb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先来看看承诺型签名。</p><p id="2bcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Promise &lt; A &gt; </em>代表一个异步操作，可以成功，值为A类型，但是失败怎么办？这在类型签名中没有表现出来，所以我们必须查看我们特定承诺的实现内部，并确定我们的catch错误处理程序需要处理什么类型。承诺也会被急切地评估，并且不透明，这在我们重构时会引起问题。引用透明意味着我们可以用表达式返回的值替换程序中的所有表达式，而不改变程序的行为。关于承诺潜在问题的更多信息，请查看这篇<a class="ae km" href="https://medium.com/@avaq/broken-promises-2ae92780f33" rel="noopener">文章</a>。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/eb42c64c8cc2d66e19d1aea19ee13372.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/0*wLHA2_YwkwxoV3o9"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">异步代码和副作用会变得复杂…我们都知道这种感觉</figcaption></figure><h2 id="2ef5" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">箭头</h2><p id="4ebc" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">与承诺相比，箭头有很多好处，包括引用透明性、类型错误和内置的依赖注入功能。下面将更详细地讨论其中的每一个。箭头有一个可发现的“流畅的”链式API，类似于本机承诺和数组。要查看Arrow的完整API列表，请查看<a class="ae km" href="https://lauri3new.github.io/light-arrow-docs/docs/Arrow" rel="noopener ugc nofollow" target="_blank">文档站点</a>。</p><p id="8818" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更普遍的是，不仅仅是异步操作，箭头可以用来模拟同步或异步副作用，并以一种类型安全的方式将它们组合在一起，而不实际执行任何副作用，因此，数据结构如箭头也被称为“功能效应”。对于那些熟悉函数式编程的人来说，箭头是一种阅读工具。</p><p id="5bc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">箭头本质上可以被看作是函数类型<br/> <code class="fe ly lz ma mb b">D =&gt; Promise&lt;Either&lt;E, R&gt;&gt;</code>的有用包装器，它使得使用这种类型更加方便，并且为可组合性和便利性提供了帮助方法。为了将现有的数据类型转换成箭头，提供了几个<code class="fe ly lz ma mb b">draw</code>函数来简化这个过程。我们也可以像使用<code class="fe ly lz ma mb b">new Promise</code>的承诺一样<code class="fe ly lz ma mb b">construct</code>箭头，也可以选择指定一个“整理”回调(例如，清除超时)，参见<a class="ae km" href="https://lauri3new.github.io/light-arrow-docs/docs/Arrow#arrows" rel="noopener ugc nofollow" target="_blank">这里的</a>示例。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/eeb17e463cd56c340edc66c228b910e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJhCKM_FQRflyKnHWqUnAA.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">示例功能“发送电子邮件”返回一个箭头，取决于基于承诺的电子邮件服务</figcaption></figure><p id="7416" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们通过例子来看看我提到的一些好处。在示例中，所有类型都是推断出来的，但只是出于演示的目的写出来的。</p><h2 id="1e92" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">错误处理</h2><p id="c3d4" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">箭头使用任一数据类型来启用集中式类型安全错误处理。通过跟踪错误类型，我们可以从类型签名中知道我们的程序可能如何失败，并涵盖我们传递给run方法的错误处理函数中的所有情况(类似于我们可能在承诺末尾添加的catch处理程序)。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mh"><img src="../Images/a79a3e84e5299b3fe350374b42906f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEfSNcTf0laDlcb_sPhNTQ.png"/></div></div></figure><h2 id="c026" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">对透明性有关的</h2><p id="1e35" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在run方法被调用之前，箭头实际上不会执行任何操作，这意味着箭头具有引用透明的良好属性。这意味着我们可以重构包含箭头的表达式，比如调用一个返回箭头的函数，用返回的值替换它们，而不改变程序的含义。事实证明，通过用箭头表示程序中的所有副作用，无论它们是异步的还是同步的，是可失败的还是不可失败的，我们可以在整个程序中保持引用透明性，使推理变得更容易。</p><p id="9fb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们的程序副作用现在由箭头表示，我们可以将它们组合在一起成为一个描述整个程序的箭头，等待通过run方法执行，在run方法中，我们提供依赖和成功、失败和异常处理程序。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mi"><img src="../Images/aa2c84edf4e1c590ffc66486d6fae749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZ43AnqRmRvWxvSvzQzf8Q.png"/></div></div></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/b7947b76e0b7499b16c589831c8d0de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*TplQcyUfMnA6RBPk-slaKw.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">使用模拟和生产依赖关系运行我们的程序</figcaption></figure><h2 id="9d22" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">依赖注入</h2><p id="b4ae" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">通过延迟执行直到run方法被调用，Arrows提供了一种方便的方式来执行依赖注入，因为我们可以将程序的所有依赖项分组到单个对象类型中，并根据我们的需要在run方法中提供这些依赖项的测试和生产实现。</p><h2 id="063d" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">可组合性</h2><p id="592f" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">通过不同的方法，箭头是高度可组合的(所有方法参见<a class="ae km" href="https://lauri3new.github.io/light-arrow-docs/docs/Arrow" rel="noopener ugc nofollow" target="_blank">文档</a>)。<code class="fe ly lz ma mb b">orElse</code>和<code class="fe ly lz ma mb b">andThen</code>方法也作为接受n个箭头的组合函数提供。<code class="fe ly lz ma mb b">orElse</code>可用于“横向”构图，如构建快递App的路线。<code class="fe ly lz ma mb b">andThen</code>可用于“垂直”组合，例如在授权中间件中更改请求的上下文，在授权中间件中，发出请求的用户的详细信息被添加到上下文中，供后续中间件使用。还包括熟悉的功能如<code class="fe ly lz ma mb b">all</code>和<code class="fe ly lz ma mb b">race</code>(箭头等同于<code class="fe ly lz ma mb b">Promise.all</code>和<code class="fe ly lz ma mb b">Promise.race</code>)以及更多的组合子如<code class="fe ly lz ma mb b">retry</code>和<code class="fe ly lz ma mb b">repeat</code>。</p><h2 id="9eba" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">表演</h2><p id="959c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">Arrows是堆栈安全的，在性能测试中的表现类似于本机承诺，但是具有本文中列出的所有优点。箭头还支持<a class="ae km" href="https://lauri3new.github.io/light-arrow-docs/docs/Arrow#cancellation" rel="noopener ugc nofollow" target="_blank">取消</a>和资源整理。</p><h2 id="6841" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">互用性</h2><p id="1119" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">有许多帮助函数可以将现有的类型转换成箭头，包括基本值、函数、异步函数。这些都列在<a class="ae km" href="https://lauri3new.github.io/light-arrow-docs/docs/Arrow" rel="noopener ugc nofollow" target="_blank">文档</a>中。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/feda8c998c0a1b7561dce842720d7a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*04NgJRiboqEAjatT"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">成为一名Arrow程序员，控制异步代码和副作用</figcaption></figure><p id="9bc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Light Arrow的目标是成为一个实用的库，拥有一个基于Arrow数据类型的小型API，这样那些使用它的人就可以获得函数式编程的许多好处，而理论上不会有太多的开销。要开始，请在此处查看文档<a class="ae km" href="https://lauri3new.github.io/light-arrow-docs/docs/Arrow" rel="noopener ugc nofollow" target="_blank">并安装</a><a class="ae km" href="https://www.npmjs.com/package/@light-arrow/arrow" rel="noopener ugc nofollow" target="_blank"> npm模块</a>。对于那些有兴趣学习更多关于函数式编程的人，我强烈推荐从优秀书籍<a class="ae km" href="https://www.oreilly.com/library/view/functional-programming-in/9781617290657/" rel="noopener ugc nofollow" target="_blank">Scala</a>中的函数式编程的前几章开始。</p><p id="1c8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第2部分中，我们将使用Arrows为路由、中间件和处理程序构建一个类型安全的express服务器。感谢阅读，希望下次再见！</p></div></div>    
</body>
</html>