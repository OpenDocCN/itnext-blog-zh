<html>
<head>
<title>Ray Tracer Challenge on the STM32F429I-Discovery board</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">STM32F429I-Discovery板上的光线跟踪器挑战</h1>
<blockquote>原文：<a href="https://itnext.io/ray-tracer-challenge-on-the-stm32f429i-discovery-board-9ca21d7bd49d?source=collection_archive---------3-----------------------#2020-06-14">https://itnext.io/ray-tracer-challenge-on-the-stm32f429i-discovery-board-9ca21d7bd49d?source=collection_archive---------3-----------------------#2020-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cb354b1064364bdd6511df65c9d6885f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ry6SngkybT1y_5plu9QuSw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">(基本完成的)光线跟踪器</figcaption></figure><p id="6b04" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很长时间以来，我一直想做一个射线追踪器，在浏览了Jamis Buck的<a class="ae la" href="https://pragprog.com/titles/jbtracer/" rel="noopener ugc nofollow" target="_blank">射线追踪器挑战</a>的前几页后，我被吸引住了！这本书概述了如何从零开始建立一个光线追踪器，只使用简单的线性代数。</p><p id="845b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你不想读我令人厌恶的文字，你可以直接跳到https://github.com/nhtranngoc/yart<a class="ae la" href="https://github.com/nhtranngoc/yart" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/d2837ae220249041e2bf54de3dd567a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67aDVpRbbtONZnD24XcX9A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">必读的一...</figcaption></figure><h1 id="3ab9" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">我为什么这么做</strong></h1><p id="d352" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">几周前，我从WPI毕业，目前正在寻找工作。随着我的大量时间被释放，以及我不断增长的计划项目从我的眼角瞪着我，我认为这是一个好主意，重温我的一些技能，也许学习新的技能。</p><p id="1319" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，Jamis Buck在他精彩的书中使用了测试驱动开发(TDD)方法，这也是我想写进简历的东西。嵌入式系统中的测试驱动开发对我来说很陌生，尽管我已经阅读了James Grenning的<a class="ae la" href="https://pragprog.com/titles/jgade/" rel="noopener ugc nofollow" target="_blank">Test Driven Development for Embedded C</a>，我很高兴尝试一下。</p><h1 id="3207" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">我正在使用什么技术</strong></h1><p id="a0cd" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">几个月前，我从意法半导体拿到了STM32F429-Discovery板，一直想找个借口用它做点什么。该板配有240x320 TFT LCD，STM32F429微控制器配有浮点单元(FPU)。这使它成为我的光线跟踪器的完美候选。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/dac45c490d2468911647901f8a6dd241.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*o_Vmtm787oTDUX6ooVxxgw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">STM32F429I-DISC板</figcaption></figure><p id="3679" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这本书是语言不可知的，这意味着读者可以自由地使用任何编程语言。我选择了C++。部分是因为我想磨练我勉强存在的C++技能，但主要是因为我以前从未用嵌入式C++编程。这将是一个有趣的实验。</p><p id="044c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于构建系统，我使用CMake。CMake是一个元构建系统，换句话说，CMake构建构建系统。我开始为我的另一个CHIP-8仿真器 (YACE)项目使用CMake，从那以后就爱上了它，因为它的优雅和易用。跨平台也是另一个优势，因为我运行的是Linux的Windows子系统(WSL)。(亵渎，我知道)。</p><p id="ec67" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于选择的STM32库，我使用的是<a class="ae la" href="https://github.com/libopencm3/libopencm3" rel="noopener ugc nofollow" target="_blank"> libopencm3 </a>。为什么？因为我听说过关于它的好消息——在使用了一段时间后，我不得不说它们确实是好东西。这个API比HAL/CMSIS优雅得多，尽管它确实需要一点学习。不利的一面是libopencm3仍然是一项正在进行中的工作，所以任何API/函数调用都有可能被改变。但总的来说，我喜欢STM32系列的开源、多平台固件的想法。</p><p id="3835" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后但同样重要的是，由于这是一个TDD项目，我们需要使用一个测试框架。我最开始用Google Tests，后来因为和ARM cross编译器不兼容而报废了。我选定的下一个框架是<a class="ae la" href="https://cpputest.github.io/" rel="noopener ugc nofollow" target="_blank">cputest</a>，它简单得令人抓狂，并且附带了CMake集成。</p><p id="76c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了这些，我们现在准备好建立我们的光线追踪器。</p><h1 id="4750" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">光线跟踪器</strong></h1><p id="9fda" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">光线跟踪器是一个可以在3D空间中渲染对象的程序，通过产生可以与对象相交并从对象反弹的光线。通过使用这些光线扫描显示器，然后计算得到的光线颜色，我们可以只使用矢量数学来进行照片级的渲染！</p><p id="05d7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">构建光线跟踪器的细节可以在书中找到，但我将概述我在STM32板上启动和运行我的项目时遇到的困难。</p><h1 id="99f7" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">libopencm3 &amp; CMake</h1><p id="af88" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">首先要做的是用CppUTest和libopencm3创建并运行CMake。为了让CMake同时为两个目标工作，其中一个是交叉编译的，我们将不得不拆分我们的代码库:</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="e748" class="mp lh iq ml b gy mq mr l ms mt">├── CMakeLists.txt<br/>├── README.md<br/>├── arm-none-eabi-toolchain.cmake<br/>├── build<br/>├── include<br/>│   ├── lcd<br/>│   ├── patterns<br/>│   ├── shapes<br/>├── install_cpputest.sh<br/>├── lib<br/>│   └── libopencm3<br/>├── src<br/>│   ├── CMakeLists.txt<br/>│   ├── lcd<br/>│   ├── patterns<br/>│   ├── shapes<br/>├── stm32f429i-discovery.ld<br/>├── tests<br/>└   └── CMakeLists.txt</span></pre><p id="0f71" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是我的程序结构。<code class="fe mu mv mw ml b">libopencm3</code>进入<code class="fe mu mv mw ml b">lib/</code>，头文件在<code class="fe mu mv mw ml b">include/</code>，代码在<code class="fe mu mv mw ml b">src/</code>，测试在<code class="fe mu mv mw ml b">tests</code>。这种分离使得选择我们想要编译的目标更加容易，并且将嵌入式逻辑和x86逻辑分开。</p><p id="baa9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">解决了这个问题，我们有了顶级制造商列表:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0f09" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在23行代码中，我们设置了准系统CMake，添加了公共标志——可用于STM32目标和测试目标，并添加了一个用于交叉编译的开关。</p><p id="6c95" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意，在第16行和第20行，我们告诉编译器使用单精度常量，并警告我们任何可能的双重提升和浮点转换。由于STM32F429只支持单精度浮点，我们必须小心，只允许使用类型<code class="fe mu mv mw ml b">float</code>。</p><p id="81a6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，要启用交叉编译，我们必须添加一个工具链文件。这是我对STM32F429I-DISC板的配置:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ffd6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们有我们目标的制造商名单。这样做的目的是为我们的目标添加任何特定于STM32的编译器选项，比如定义、链接器标志，并添加<code class="fe mu mv mw ml b">libopencm3</code>作为依赖项。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="19ec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第7行和第8行，我们设置了<code class="fe mu mv mw ml b">-mfloat-abi=hard</code>和<code class="fe mu mv mw ml b">-mfpu=fpv6-sp-d16</code>来启用板上FPU。没有这一点，微控制器将不得不求助于软件浮点指令，这将大大降低我们的光线跟踪器。</p><p id="6be0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们有用于测试的CMakeLists这相当简单，因为我们只需要在<code class="fe mu mv mw ml b">include_directories</code>中包含所有源文件，并添加CppUTest作为库:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6b56" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是我们启动射线追踪仪所需要的一切！花了一些时间来设置，但是一旦你设置好了，你就可以通过进入<code class="fe mu mv mw ml b">build</code>文件夹来调用不同的构建目标，并输入:</p><ul class=""><li id="ce26" class="mz na iq ke b kf kg kj kk kn nb kr nc kv nd kz ne nf ng nh bi translated"><code class="fe mu mv mw ml b">cmake ..</code>用于测试构建</li><li id="172f" class="mz na iq ke b kf ni kj nj kn nk kr nl kv nm kz ne nf ng nh bi translated"><code class="fe mu mv mw ml b">cmake -DCMAKE_TOOLCHAIN_FILE=path/to/toolchain ..</code>对于STM32版本</li></ul><h1 id="76b1" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">神秘的圆点</h1><p id="9d8b" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">在启动并运行我的光线跟踪器后，有时在构建过程中，我会注意到渲染中的神秘点:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/e0d7d56108f24d5f2e7045a3afaeffbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ITmwUABrU7RjhAQLKjHCbA.jpeg"/></div></div></figure><p id="4333" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为什么会有圆点？他们为什么在那里？为什么它们只出现在背景上？</p><p id="695b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在项目的这一点上，所有的对象都是球体——这使得只有圆点出现在背景对象上变得很奇怪。经过大量的代码搜索和一点自我反省，我找到了令人不快的代码行:</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="6bad" class="mp lh iq ml b gy mq mr l ms mt">@define EPSILON 0.0001 <br/>[...]<br/>comps.over_point = comps.point + (comps.normalv * EPSILON);</span></pre><p id="2697" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Epsilon是一个用于比较浮点数的小值——因为理想情况下，您会希望看到两个浮点数在误差范围内是否相等。我注意到这个bug出现在实现shadows之后，shadows计算投射阴影的对象的<code class="fe mu mv mw ml b">over_point</code>值，所以很明显这是问题的原因。通过将法向量乘以一个小值，我们得到一个更小的值，它可以被STM32浮点计算截断。这导致颜色呈现为黑色，我们可以在上面看到。</p><p id="1aed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过将EPSILON的值更改为<code class="fe mu mv mw ml b">0.01</code>，我们会损失一些精度，但鉴于我们的显示器分辨率仅为240x320，我不认为我们会损失太多。窃听器没了，作为回报。</p><h1 id="522b" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">特拉维斯积分</h1><p id="6ce0" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">这个太棒了。如果你看了我的提交历史，你会发现我花了相当多的时间来让Travis正常工作。剧透一下，还是没有。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a58b723fe4f0af40e23b09aaea8090d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*Cj1KvsXVv1Z-u6spUW0zFg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">是的，这一切都发生在同一天</figcaption></figure><p id="f424" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">显然当我使用C++11的特性时，比如<code class="fe mu mv mw ml b">std::shared_from_this()</code>，Travis的构建系统因为某些原因无法检测，导致链接错误。因为这个原因，我禁用了<code class="fe mu mv mw ml b">.travis.yml</code>，唯一的罪证是我的自述文件上肮脏的<code class="fe mu mv mw ml b">failing</code>建造徽章的存在。</p><h1 id="13a1" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">我学到了什么</h1><p id="461d" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">总的来说，这个项目花了我大约2周的时间，我学到了新的知识，改进了一些我已经知道的知识，复习了我的大学线性代数，并对嵌入式系统有了更好的理解。</p><p id="cebc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">具体来说，我了解到:</p><ul class=""><li id="bd53" class="mz na iq ke b kf kg kj kk kn nb kr nc kv nd kz ne nf ng nh bi translated">如何用CMake编译交叉目标？</li><li id="1668" class="mz na iq ke b kf ni kj nj kn nk kr nl kv nm kz ne nf ng nh bi translated">使用测试驱动开发技术，并将它们应用到项目中。</li><li id="8be0" class="mz na iq ke b kf ni kj nj kn nk kr nl kv nm kz ne nf ng nh bi translated">有用的C++技巧，比如模板，智能指针，<code class="fe mu mv mw ml b">auto</code>声明(我最喜欢的C++特性之一)，运算符重载。</li><li id="b335" class="mz na iq ke b kf ni kj nj kn nk kr nl kv nm kz ne nf ng nh bi translated">以清晰简洁的方式组织我的代码库。</li></ul><h1 id="13f5" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">接下来是什么</h1><p id="7c2f" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">现在，我决定停在第11章，反射和折射。也许我将来会重访——但是我的技能还有很多地方需要提高。</p><p id="bd69" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">路线图上的内容:</p><ul class=""><li id="16fa" class="mz na iq ke b kf kg kj kk kn nb kr nc kv nd kz ne nf ng nh bi translated">实现包围盒层次(BVH)。这可以通过对照边界框检查单个光线来大大减少渲染时间，如果它们错过了，就丢弃它们。这可以大大减少渲染时间。</li><li id="ee59" class="mz na iq ke b kf ni kj nj kn nk kr nl kv nm kz ne nf ng nh bi translated">针对STM32平台进行优化。许多代码是用更高级的软件工程技术编写的，没有考虑太多嵌入式主板。诸如<code class="fe mu mv mw ml b">sin</code>、<code class="fe mu mv mw ml b">cos</code>、<code class="fe mu mv mw ml b">tan</code>的数学计算可以用查找表代替。如果有时间，我想实现CMSIS的<code class="fe mu mv mw ml b">arm_math</code>库来减少处理时间。</li><li id="6878" class="mz na iq ke b kf ni kj nj kn nk kr nl kv nm kz ne nf ng nh bi translated">完成这本书。这本书非常吸引人，有几次我会连续看10个小时。不完成它将是一种耻辱。</li></ul></div></div>    
</body>
</html>