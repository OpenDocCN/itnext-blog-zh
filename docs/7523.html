<html>
<head>
<title>Awaiting any type in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">等待C#中的任何类型</h1>
<blockquote>原文：<a href="https://itnext.io/awaiting-any-type-in-c-44b021c38858?source=collection_archive---------0-----------------------#2022-10-22">https://itnext.io/awaiting-any-type-in-c-44b021c38858?source=collection_archive---------0-----------------------#2022-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/02111891598296485a1ec31ae6770623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvhGSnCX7wR87PfhJj54Yw.jpeg"/></div></div></figure><div class=""/><p id="caf3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你经常使用C#中的async/await特性(说实话，谁没有)，你可能对Task和Task <t>很熟悉。</t></p><p id="14dc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更有甚者，如果您使用的是C#版本≥ C# 8，您甚至可能以前使用过ValueTask。</p><p id="ac01" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些有什么共同点？非常简单，您可以等待他们来控制您的应用程序逻辑流。您可能倾向于认为这是编译器的魔力，但事实并非如此——毕竟，提到的类型和其他类型一样，只是它们似乎有一些特殊之处，允许它们被“等待”。</p><h1 id="b461" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">巧妙的表达</h1><p id="800b" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果我们看一下C#规范，有一个<a class="ae mc" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#11882-awaitable-expressions" rel="noopener ugc nofollow" target="_blank">段</a>专门用于一个合适的表达式。现在，让我们跳过等待动态类型的可能性。</p><p id="499b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，一个可盈利的类型需要什么呢？GetAwaiter的一个可访问的实例或扩展方法(这将在后面派上用场)没有任何参数，返回一个兼容的类型t。</p><p id="129f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">反过来，兼容的类型需要实现</p><ul class=""><li id="ead1" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">INotifyCompletion(通常是ICriticalNotifyCompletion)接口，它引入了OnCompleted方法。这个方法将被调用来传递给你的一个合适的类型它应该执行的延续。如果你想知道更多关于INotifyCompletion和ICriticalNotifyCompletion的区别，请查看<a class="ae mc" href="https://devblogs.microsoft.com/pfxteam/whats-new-for-parallelism-in-net-4-5-beta/" rel="noopener ugc nofollow" target="_blank">斯蒂芬·图布斯的博客</a>！</li><li id="748f" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">名为的属性已完成。这听起来有点奇怪，因为我们刚刚讨论了负责对延续进行排队的方法。那么，为什么我们需要显式控制呢？这很简单，如果异步状态机确定发生的工作单元<strong class="kd jf">还没有</strong>完成，它将只对一个延续进行排队。因此，我们需要这个属性来解决这个问题。</li><li id="c74e" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">一个GetResult方法，用于获取完成后的结果。这个方法的返回类型是可变的，它决定了结果的类型！</li></ul><p id="431a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，你可能从来没有处理过所有这些，你仍然一直使用async/await，那么在默认情况下谁来处理这些呢？</p><p id="87f5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您通常等待一个<strong class="kd jf">任务</strong>或<strong class="kd jf">任务&lt; T &gt; </strong>，因此首先要检查的是它如何满足公开一个具有所需功能的GetAwaiter方法的第一个要求。</p><p id="2b2c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mc" href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs,2443" rel="noopener ugc nofollow" target="_blank">看着source.dot.net，这里的</a>正是:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/93d2e75edf7be822f2d45482582be9c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*SFWSKTrg_y-VOfcUk4zzkA.png"/></div></figure><p id="c864" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，对于默认情况，似乎有一个默认的<a class="ae mc" href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/TaskAwaiter.cs,16e40fc537484d93" rel="noopener ugc nofollow" target="_blank"> TaskAwaiter </a>来为我们覆盖其余的需求。事实上，实现也是需要的。它接受任务并公开:</p><ul class=""><li id="1598" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">IsCompleted，指向任务本身的完成状态</li><li id="2107" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">OnCompleted，它在内部将延续排队到底层任务上(请随意深入研究——进一步的实现主要关注延续应该如何继续其流程，这可能会根据您的应用程序上下文如何处理同步上下文流程而有很大的不同)</li><li id="d19c" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">GetResult，用于评估底层任务。注意，在这里抛出也是完全合法的，以防工作单元失败。</li></ul><p id="8585" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，有了这些知识，我们可以尝试重建我们自己的“awaiter”。</p><p id="5cd8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个例子可能有点傻，但是让我们试着写一个自定义类，它在两秒钟的延迟后查询google.com，并且可以被等待。</p><p id="6e08" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从一个简单的类设置开始:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="87cd" class="nb la je mx b gy nc nd l ne nf">public class GoogleQuerier<br/>{ <br/> private async Task&lt;string&gt; GetDelayedGoogleResponse()<br/> {<br/>  var client = new HttpClient();<br/>  await Task.Delay(2000);<br/>  return await client.GetStringAsync("<a class="ae mc" href="https://google.com" rel="noopener ugc nofollow" target="_blank">https://google.com</a>");<br/> }<br/>}</span></pre><p id="56ae" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止很简单。现在我们需要勾掉可盈利模式的方框。首先，我们需要实现我们自己的目标:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8084" class="nb la je mx b gy nc nd l ne nf">public class GoogleQueryAwaiter : ICriticalNotifyCompletion<br/>{<br/> private readonly Task&lt;string&gt; _queryTask;<br/> <br/> public GoogleQueryAwaiter(Task&lt;string&gt; queryTask) =&gt; _queryTask = queryTask;<br/> <br/> public void OnCompleted(Action continuation) =&gt; _queryTask.ContinueWith(_ =&gt; continuation());</span><span id="8180" class="nb la je mx b gy ng nd l ne nf">public void UnsafeOnCompleted(Action continuation) =&gt; _queryTask.ContinueWith(_ =&gt; continuation());<br/> <br/> public bool IsCompleted =&gt; _queryTask.IsCompleted;</span><span id="36ce" class="nb la je mx b gy ng nd l ne nf">public string GetResult() =&gt; _queryTask.Result;<br/>}</span></pre><p id="1eec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这本质上非常类似于TaskAwaiter。我们实现ICriticalNotifyCompletion，这迫使我们实现OnCompleted和UnsafeOnCompleted。我们简单地通过任务本身的ContinueWith对continuation进行排队，并通过简单地将任务委托给其他两个方法。</p><p id="5fd3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们编写Main方法来设置整个调用:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="baf1" class="nb la je mx b gy nc nd l ne nf">async Task Main()<br/>{<br/> var sw = Stopwatch.StartNew();<br/> <br/> var googleQuerier = new GoogleQuerier();<br/> var queriedData = await googleQuerier;<br/> <br/> Console.WriteLine($"Done - Elapsed time: {sw.Elapsed}");<br/> Console.WriteLine($"Result length: {queriedData.Length}");<br/>}</span></pre><p id="7e7f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，到目前为止，我们仍然收到一个错误，因为还有一件事要做:我们需要将GetAwaiter()添加到GoogleQuerier类中！</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1fb0" class="nb la je mx b gy nc nd l ne nf">public class GoogleQuerier<br/>{<br/> public GoogleQueryAwaiter GetAwaiter()<br/> {<br/>  return new GoogleQueryAwaiter(GetDelayedGoogleResponse());<br/> }</span><span id="1262" class="nb la je mx b gy ng nd l ne nf"> ...<br/>}</span></pre><p id="e32b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在一切都编译好了，如果我们检查我们的输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="200e" class="nb la je mx b gy nc nd l ne nf">Done - Elapsed time: 00:00:02.3029731<br/>Result length: 13403</span></pre><p id="3fce" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太好了，一切都解决了！我们的GoogleQuerier现在是可运行的，工作正常(我们等待2秒钟，然后得到结果)</p><h1 id="c522" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">这对我有什么用？</h1><p id="379b" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">可以说，您可能永远都不需要编写自己的awaiter，但是我仍然想介绍这个概念。TaskAwaiter通常工作做得很好。</p><p id="1e5b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">整个概念更强大的地方在于，通过实现GetAwaiter方法，您可以使任何类型变得可应用。一旦你记住你不一定要让它成为一个实例方法，但是你也可以使用一个扩展方法，那么就没有限制了，你甚至可以扩展框架类！</p><p id="1708" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">先说一个简单的:如果你有一个懒惰的<task>&gt;，不停的写就有点烦了</task></p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2cf1" class="nb la je mx b gy nc nd l ne nf">await lazy.Value;</span></pre><p id="6a39" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，我们为什么不写一个小的扩展方法来使它变得更简单呢？</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="52e1" class="nb la je mx b gy nc nd l ne nf">async Task Main()<br/>{<br/> var lazy = new Lazy&lt;Task&lt;int&gt;&gt;(() =&gt; Task.FromResult(5));<br/> Console.WriteLine(await lazy);<br/>}</span><span id="9436" class="nb la je mx b gy ng nd l ne nf">public static class LazyExtensions<br/>{<br/> public static TaskAwaiter&lt;T&gt; GetAwaiter&lt;T&gt;(this Lazy&lt;Task&lt;T&gt;&gt; lazy)<br/> {<br/>  return lazy.Value.GetAwaiter();<br/> }<br/>}</span><span id="b6ba" class="nb la je mx b gy ng nd l ne nf">// 5</span></pre><p id="f32a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太棒了。</p><p id="33d8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最近我还处理了一个情况，其中一个方法收到了一个我想“等待”的cancel token，但是这是不可能的。那么，您会添加另一个参数CancellationToken取消时间吗？我们也可以简单地写一个扩展，让一个CancellationToken一直可用，直到用完为止！</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="904d" class="nb la je mx b gy nc nd l ne nf">async Task Main()<br/>{<br/> var cts = new CancellationTokenSource(3000);<br/> Console.WriteLine("Starting");<br/> var sw = Stopwatch.StartNew();<br/> await cts.Token;<br/> Console.WriteLine($"Done - Elapsed time: {sw.Elapsed}");<br/>}</span><span id="b51f" class="nb la je mx b gy ng nd l ne nf">public static class CancellationTokenExtensions<br/>{<br/> public static TaskAwaiter GetAwaiter(this CancellationToken ct)<br/> {<br/>  if (ct.IsCancellationRequested) <br/>  {<br/>   return Task.CompletedTask.GetAwaiter();<br/>  }<br/>  <br/>  var tcs = new TaskCompletionSource();<br/>  ct.Register(() =&gt; tcs.SetResult());<br/>  return tcs.Task.GetAwaiter();<br/> }<br/>}</span><span id="ba0a" class="nb la je mx b gy ng nd l ne nf">Done - Elapsed time: 00:00:03.0011042</span></pre><p id="b9e6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，我们也可以简单地在GetAwaiter中构建我们自己的任务，只要签名匹配，就返回我们喜欢的waiter。</p><p id="d356" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以做的其他顺利的事情是利用任务。更方便的时候。让我们实现一个合适的元组和列表！</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="39b5" class="nb la je mx b gy nc nd l ne nf">async Task Main()<br/>{<br/> var (t1, t2) = await (Task.FromResult(5), Task.FromResult(3));<br/> Console.WriteLine($"t1: {t1}, t2: {t2}");</span><span id="af39" class="nb la je mx b gy ng nd l ne nf">var results = await new List&lt;Task&lt;int&gt;&gt;() { Task.FromResult(5), Task.FromResult(3), Task.FromResult(1) };<br/> Console.WriteLine($"t1: {results[0]}, t2: {results[1]}, t3: {results[2]}");<br/>}</span><span id="bb53" class="nb la je mx b gy ng nd l ne nf">public static class WhenAllExtensions<br/>{<br/> public static TaskAwaiter&lt;(T1 First, T2 Second)&gt; GetAwaiter&lt;T1, T2&gt;(this (Task&lt;T1&gt; First, Task&lt;T2&gt; Second) tuple)<br/> {<br/>  var (t1Task, t2Task) = tuple;<br/>  return Task.WhenAll(t1Task, t2Task).ContinueWith(_ =&gt; (t1Task.Result, t2Task.Result)).GetAwaiter();<br/> }<br/> <br/> public static TaskAwaiter&lt;T[]&gt; GetAwaiter&lt;T&gt;(this List&lt;Task&lt;T&gt;&gt; list)<br/> {<br/>  return Task.WhenAll(list).GetAwaiter();<br/> }<br/>}</span><span id="1daa" class="nb la je mx b gy ng nd l ne nf">t1: 5, t2: 3<br/>t1: 5, t2: 3, t3: 1</span></pre><p id="97fb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">整洁！</p><p id="8744" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最终，我认为自定义awaitables真的很有趣。它们可能不是一个应该放在任何地方的特性，但是在某些情况下它会非常有用(tuple one实际上是我每天都在使用的一个特性！).这绝对是鸭子打字的特性之一，玩起来感觉很好。</p></div></div>    
</body>
</html>