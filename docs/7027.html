<html>
<head>
<title>Un-Opinionated vs Opinionated Within Frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">框架内不固执己见与固执己见</h1>
<blockquote>原文：<a href="https://itnext.io/un-opinionated-vs-opinionated-within-frameworks-f6ceb88a21a2?source=collection_archive---------1-----------------------#2022-05-20">https://itnext.io/un-opinionated-vs-opinionated-within-frameworks-f6ceb88a21a2?source=collection_archive---------1-----------------------#2022-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9bfaff2c2a47db23960e6ba6d1001936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpbzfn3saE_mV02T63Jl4w.jpeg"/></div></div></figure><div class=""/><p id="0870" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular或React之类的每个框架的第一个优点和缺点是它“固执己见”或“不固执己见”，这是使用该框架的一个重要原因，也是不使用另一个框架的一个重要原因。在很长一段时间里，项目文件结构在我看来似乎是框架固执己见的主要原因，但它还有更多。</p><p id="f170" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实用程序固执己见的本质也由它为开发人员提供的“瑞士军刀(SAF)”的丰富程度来定义。每个框架都将提供一些SAF，供我们开发人员以特定的方式编写代码。</p><p id="cfa8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例子:<br/> 1。反应——功能组件、挂钩、JSX/TSX <br/> 2。Angular — HttpClient，RouterModule，I18N，双向绑定</p><p id="a39c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢用这两个框架作为主要的例子，因为它们之间有着截然不同的差异。</p><blockquote class="kw kx ky"><p id="970e" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">一个公用事业越不固执己见，它就变得越多样化，但结果是它变得不那么结构化。</p></blockquote><p id="1b06" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以提供的一个最简单的例子是从路由中获取查询参数。</p><h1 id="74d7" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">差异</h1></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="fa3f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> Angular </strong></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="b5dc" class="mr le jb mn b gy ms mt l mu mv">import {ActivatedRoute} from '@angular/core'<br/>constructor(private <strong class="mn jc">route</strong>: ActivatedRoute) {</span><span id="422b" class="mr le jb mn b gy mw mt l mu mv">     const queryParams = <strong class="mn jc">route</strong>.snapshot.queryParams;</span><span id="4b26" class="mr le jb mn b gy mw mt l mu mv">     <strong class="mn jc">route</strong>.queryParams.subscribe(console.log)</span><span id="c48f" class="mr le jb mn b gy mw mt l mu mv">}</span></pre><p id="d535" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有两种不同的可选方式来呈现组件，每种方式都提供了一种略有不同的获取查询的方式。是的，这些模式之间有很多相似之处，也许在幕后他们使用相同的解决方案，但这种方式给了我们灵活性和高度的多样性，可以在我们的应用程序中做得更好。<br/>在给出的解决方案中，我们使用普通的JS或开源库</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4853" class="mr le jb mn b gy ms mt l mu mv">import {useSearchParams} from 'r<!-- -->eact-router-dom<!-- -->' </span><span id="84a1" class="mr le jb mn b gy mw mt l mu mv">export const Component = () =&gt; {<br/>  const [searchParams, setSearchParams] = useSearchParams();<br/>  const id = searchParams.get("id")</span><span id="1edf" class="mr le jb mn b gy mw mt l mu mv">   const search = window.location.search;<br/>   const params = new URLSearchParams(search);<br/>   const id2= params.get("id");</span><span id="d593" class="mr le jb mn b gy mw mt l mu mv">}</span><span id="ed72" class="mr le jb mn b gy mw mt l mu mv">export class ComponentClass {<br/>   constructor() {</span><span id="d0ff" class="mr le jb mn b gy mw mt l mu mv"> const search = this.props.location.search;      URLSearchParams(search).get("id");<!-- --> <br/>}</span><span id="5b5b" class="mr le jb mn b gy mw mt l mu mv">}</span></pre><p id="8773" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获取查询参数的例子很傻，也很小，但它向我们展示了一个简单的例子，说明了给出的瑞士刀子如何给我们带来好处或伤害。我不是说一个比另一个好，但我要说的是:<strong class="ka jc">注意你的瑞士军刀里的工具。</strong></p><p id="73c4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kz">知道自己有什么或者没有什么，可以提高自己的编码速度和工作质量。</em></p><p id="729b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">拥有一个固执己见或不固执己见的框架是一种从框架的方向出发的理想主义。例如，Angular是一个面向企业的框架，这意味着它将共享知识库和<strong class="ka jc">预测代码理想化。<br/> </strong>这个决策有它的收益，例如，捆绑销售规模和业绩，但是对于一个企业来说，这些收益也许是值得的。</p><h1 id="7b07" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak">预测码</strong></h1></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="3b1d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">预测代码是一种正确地或高精度地假设某事是如何编写和实现的能力。这是验证一个团队/小组和代码库有多统一的一种方式。<br/>预测代码可以分为几个主要区域:<br/> 1 .命名转换<br/> 2。社区范围的最佳实践<br/> 3。团队/小组同意的最佳实践<br/> 4。常用工具<br/> 5。林挺和静态代码分析<br/> 6。类型化(或者一些有助于IDE的解决方案，比如JsDocs)</p><p id="8536" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有6个标准都可以在任何框架中完成。尽管框架的自以为是程度将决定上面列出的项目中有多少是通过框架处理的，有多少是团队/小组必须自己处理的。</p><p id="9edd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">预测码的结果是:<br/> 1。新的团队/小组成员将很快适应现有团队的编码风格。<br/> 2。代码审查更简单，因为一致同意的标准使得接受或拒绝PRs更容易。<br/> 3。调试容易多了，因为我们可以预测错误的位置和易受攻击的点。<br/> 4。创建schematics(生成代码的代码)可以提高开发速度，并将一致同意的最佳实践“强加”给团队。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="da17" class="ld le jb bd lf lg mx li lj lk my lm ln lo mz lq lr ls na lu lv lw nb ly lz ma bi translated">摘要(TLDR)</h1><p id="2275" class="pw-post-body-paragraph jy jz jb ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">固执己见和不固执己见的框架可以改成“<em class="kz">多</em>固执己见和<em class="kz">少</em>固执己见”。框架意见的水平可以通过它提供并强加给用户的工具数量来衡量和感知。<br/>实用程序数量的结果决定了我们代码的预测性。<br/>由于处理代码库的框架和/或团队，任何代码库都可以并且应该变得结构化和“固执己见”。</p><p id="079b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">祝你的项目好运:)</p></div></div>    
</body>
</html>