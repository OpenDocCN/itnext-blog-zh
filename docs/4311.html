<html>
<head>
<title>Centralizing API error handling in React apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React应用中集中API错误处理</h1>
<blockquote>原文：<a href="https://itnext.io/centralizing-api-error-handling-in-react-apps-810b2be1d39d?source=collection_archive---------0-----------------------#2020-06-05">https://itnext.io/centralizing-api-error-handling-in-react-apps-810b2be1d39d?source=collection_archive---------0-----------------------#2020-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6830aec9130a5188b774a18894a5cd09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrElooE3nz0oaZIhaIbLKQ.jpeg"/></div></div></figure><p id="76ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将向您展示一种以集中且易于扩展的方式一次性处理API错误的方法，而不考虑状态管理库(Redux、Apollo等)。)您正在使用的。</p><p id="ae30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几乎每一个现代应用程序都与API交互以满足其数据需求；无论是RESTful API还是graph QL API，在web上触发请求是大多数应用程序的基本功能。大多数情况下，事情进展顺利，您的请求被成功返回，但也有事情进展不顺利的时候。我说的是API可以返回的那些可怕的404、403和500，它们反过来必须呈现给用户。由于这类响应的性质，在一个地方处理它们是最理想的。</p><p id="2ba5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，在React应用程序中管理这一点比它应该做的要难，每个应用程序都有完全不同的方法。在本文中，我将向您展示一种以集中且易于扩展的方式一次性处理API错误的方法，而不考虑状态管理库(Redux、Apollo等)。)您正在使用的。此外，我们将采用的方法可以在您的所有应用程序中重复使用，无论您是实现客户端还是服务器端渲染。所以事不宜迟，让我们直接开始吧。</p><h1 id="e7f8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设置场景</h1><p id="e45d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">出于本文的目的，我将假设存在一个带有常见HTTP错误状态代码的RESTful API，但是类似的概念也适用于GraphQL和任何其他API。我还假设使用了<code class="fe lz ma mb mc b">react-router</code>，但是完全相同的概念也适用于<code class="fe lz ma mb mc b">@reach/router</code>或任何其他React路由库。</p><p id="bcb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想写一个有2页的小应用程序。第一页将向我们展示一个狗品种的列表。当我们点击一个品种，我们将被重定向到这个品种的页面，这将显示该品种的狗的随机照片。该应用程序将如下所示(不要太担心代码或UI，因为这超出了本文的范围) :</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">简单的应用示例</figcaption></figure><p id="3d24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的应用程序可以工作，但我们还没有处理404案例。当用户访问一个不存在的页面时，我们希望向他们显示我们自己的404页面，并显示文本“Four:oh:four”。该页面应在以下两种情况下显示:</p><ul class=""><li id="5d5d" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">用户访问了一个无效的URL正则表达式(即<code class="fe lz ma mb mc b">/cats/husky/</code>)。</li><li id="046f" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">用户访问了一个有效的URL正则表达式，但使用了一个无效的品种(如果用户从地址栏手动调整URL，就会发生这种情况)。</li></ul><p id="d09c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一种情况很容易处理。像大多数教程推荐的那样，我们将添加一条“无所不包”的路线作为我们应用程序的<strong class="ka ir">最后一条路线</strong>，并且我们将使用react-router的<code class="fe lz ma mb mc b">&lt;Switch /&gt;</code>组件包装我们所有的路线。这看起来会像这样:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">包罗万象的路线</figcaption></figure><p id="30f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，每当用户输入一个除了<code class="fe lz ma mb mc b">/</code>和<code class="fe lz ma mb mc b">/dogs/&lt;BREED&gt;</code>之外的URL，他们就会被重定向到404页面。</p><p id="3fe2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二种情况有点难以处理，因为它依赖于我们的API。我们事先不知道用户作为URL参数输入的品种是否有效，因为我们不知道世界上存在的所有品种(或者至少假设我们不知道)。为了显示404页面，我们必须等待服务器对我们返回的状态做出响应和反应(没有双关语的意思)。修改<code class="fe lz ma mb mc b">&lt;DogPage /&gt;</code>组件，如下所示:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">检查API 404s</figcaption></figure><p id="de15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过存储响应代码，我们现在可以对其值做出反应，并呈现不同的组件。在上面的例子中，如果状态代码是404，我们简单地呈现404页面。这种方法可以工作，但是如果你以前用过，我可以保证你遇到过问题。给你总结一下:</p><ul class=""><li id="32af" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated"><strong class="ka ir">在嵌套组件<br/> </strong>中处理404从顶层组件渲染<code class="fe lz ma mb mc b">&lt;Page404 /&gt;</code>很容易，但是如果这个组件在组件树的“深处”会发生什么？然后<code class="fe lz ma mb mc b">&lt;Page404 /&gt;</code>将作为父组件的一部分呈现，这意味着不仅<em class="nb">而不是</em>是全屏的，而且它还将允许许多其他组件与它一起呈现它们的UI。</li><li id="a8bd" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><strong class="ka ir">重复代码&amp;逻辑<br/> </strong>目前，我们已经在一个组件中处理了404，但是我们应该为<strong class="ka ir">我们所有的</strong>有API调用的组件/页面都这样做。这意味着跨多个组件的大量重复代码。</li><li id="5982" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><strong class="ka ir">处理其他错误响应<br/> </strong> 404只是最常见的一个，但是我们应该可以对401、403、500等做同样的事情。这意味着我们应该添加<strong class="ka ir">甚至更多的</strong>代码&amp;逻辑来处理那些情况。</li><li id="45d8" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><strong class="ka ir">在组件<br/>外部进行API调用时，难以将状态作为属性传递</strong>这里，API调用在组件内部执行，但是在redux场景中，该API调用将发生在thunk、saga或observable内部。我们如何能够以一种干净、简单、一次性的非持久方式将它传递给我们的组件呢？</li></ul><h1 id="7037" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">“重定向”解决方案</h1><p id="6b89" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">人们做的最简单也是最常见的事情，就是简单地将用户重定向到一个呈现了<code class="fe lz ma mb mc b">&lt;Page404 /&gt;</code>的<code class="fe lz ma mb mc b">/404</code> url。这是可行的，但是用户会失去他们所处的环境。他们看到一个404页面，但是他们最初访问的URL已经改变，所以当他们看到404时，他们不知道“哪个东西没有找到”。我们想要的是一个解决方案，其中404页面可以显示，而他们访问的原始url保持原样。</p><h1 id="09b5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">“挂钩”解决方案</h1><p id="ae3c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们要采取的第一种方法是使用一个可重用的定制钩子，以避免必须将API状态代码的处理重写到每个组件中。这个钩子(在一个非常基本的实现中)看起来像这样:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">可重复使用的用户查询展示</figcaption></figure><p id="29b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样就可以很容易地在我们的<code class="fe lz ma mb mc b">&lt;DogPage /&gt;</code>组件中使用:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="ea60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这解决了我们处理状态代码时的重复逻辑，但对于根据状态代码呈现错误页面的重复逻辑没有太大帮助。这仍然需要在每个组件中单独实现。此外，钩子在基于类的组件中是不可用的，所以如果你有一个旧的代码库，这可能会带来一个问题。</p><h1 id="b903" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">“渲染道具”解决方案</h1><p id="5c0e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了与基于类的组件兼容并进一步减少重复代码的数量，render-props组件可能会有所帮助。因此，使用我们之前创建的<code class="fe lz ma mb mc b">useQuery</code>钩子，我们现在可以创建以下简化版本的渲染属性组件:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">可重用查询组件</figcaption></figure><p id="72f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以像这样在我们的<code class="fe lz ma mb mc b">&lt;DogPage /&gt;</code>组件中使用它:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="2b51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，这个解决方案允许我们删除任何重复的逻辑，处理任何HTTP错误代码，与基于类的组件兼容，并且总体上有干净的代码。然而，我们唯一没有解决的事情是，我们如何确保<code class="fe lz ma mb mc b">&lt;Page404 /&gt;</code>在<strong class="ka ir">隔离</strong>中渲染。概括地说，404页面是代替我们的DogPage组件呈现的，但是如果DogPage不是顶级组件，而是有许多其他祖先，会发生什么呢？那么404页面将作为整个UI的一部分，与其他组件一起呈现。</p><h1 id="9de2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">“顶级状态”解决方案</h1><p id="fcb6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了解决最后一个问题，我们唯一的选择是在任何其他页面有机会呈现之前呈现404页面。为此，我们需要某种状态管理库，它将允许组件树中较低的组件通知顶级组件它应该显示一个错误页面(404、403、500等。).为此，我们可以使用任何库，但是让我们使用内置的上下文API。</p><p id="021c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要的是一个组件，它将确保根据状态代码呈现正确的错误页面，并为任何组件提供一种方式来触发此行为(错误页面的显示)。为了实现它，我们将从创建一个高级组件开始，该组件将通过上下文公开所需的行为。看起来可能是这样的:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="8108" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个组件有点复杂，所以请确保阅读行内注释以获得更清晰的理解。</p><p id="68fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用这个组件，我们要用它包装我们的核心逻辑，如下所示:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4f14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们需要修改<code class="fe lz ma mb mc b">useQuery</code>钩子，以便在返回错误状态代码时自动“触发”错误页面显示。这将意味着我们当地的州不再需要<code class="fe lz ma mb mc b">statusCode</code>，因为它不是由<code class="fe lz ma mb mc b">ErrorHandler</code>管理的。我们需要做的就是触发一个动作来设置错误状态代码。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="2a32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，现在我们在<code class="fe lz ma mb mc b">ErrorHandler</code>组件中有了错误处理，我们不再需要对组件中的错误状态做出反应。因此，我们的<code class="fe lz ma mb mc b">&lt;DogPage /&gt;</code>组件可以通过去掉任何状态检查来实现它的最终形式:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5302" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你有了一种集中错误处理的方法，通过一种简单的(钩子)、自动化的(不需要在任何未来的组件中处理)和可伸缩的方式(因为你可以在<code class="fe lz ma mb mc b">ErrorHandler</code>中处理任何你需要的错误)。</p><h1 id="fc03" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">通用解决方案(最后一个，我保证)</h1><p id="7671" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">上面的解决方案工作得很好，但是它不能在所有的React项目中重用。事实是，当获取保持在React的边界内时，上面的方法工作得很好，但是当在redux世界中进行API调用时，它就变得乏味了。如何从redux thunk中触发<code class="fe lz ma mb mc b">setErrorStatus</code>？你就是不能。您需要做的是触发一个改变redux状态的动作，并让<code class="fe lz ma mb mc b">ErrorHandler</code>从redux状态中读取数据，但这将涉及大量样板代码。想象一下阿波罗也是如此。这将涉及到使用<code class="fe lz ma mb mc b">apollo-link-state</code>和调度一个突变，仅仅是为了这个奇怪的状态代码更新。</p><p id="82c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这一点，让我们后退一步，想一想我们到底想要实现什么。我们希望将URL与状态代码联系起来，并根据附加到它们上面的代码的值来决定呈现什么。事实证明，通过利用一个我们中没有多少人使用的浏览器原生功能，这是非常容易的。</p><p id="b5a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">当前位置的状态。</strong></p><p id="af11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在浏览器的本地历史API中，每个位置都有一个状态键，可以存储我们想要的任何东西。为什么不利用它来存储<code class="fe lz ma mb mc b">statusCode</code>而不是本地状态呢？这种方法的好处是:</p><ul class=""><li id="367a" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">不需要进行状态清理，因为当您离开时，位置会发生变化，因此新位置具有干净的状态。</li><li id="60f8" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">后退按钮会自动显示404页面，甚至不需要API请求(因为先前位置的状态存储在浏览器的历史堆栈中)。</li><li id="fd5d" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">正因为我们以强制的方式将状态分配给一个位置，所以我们可以很容易地将这种方法与任何状态管理库集成。</li><li id="dbce" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">可配置性和可伸缩性极强，因为我们可以存储和处理任何我们想要的键(不仅仅是状态码)。这意味着我们还可以存储将作为道具传递给错误页面组件的数据。</li></ul><p id="9a94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这一点，我们可以简化我们的<code class="fe lz ma mb mc b">ErrorHandler</code>:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="f811" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们系统中的任何模块(不管它是否存在于React中)都可以通过获取当前位置、向其添加状态并替换当前历史条目来将错误代码附加到页面上。为了展示这一点，我们将修改我们的<code class="fe lz ma mb mc b">useQuery</code>来做到这一点:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="bec5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个解决方案的好处是<code class="fe lz ma mb mc b">useQuery</code>钩子甚至不知道<code class="fe lz ma mb mc b">ErrorHandler</code>组件的存在。它所做的只是作为副作用修改位置，以便将某个状态添加到当前的历史条目中。这意味着<code class="fe lz ma mb mc b">ErrorHandler</code>和<code class="fe lz ma mb mc b">useQuery</code>并不相互依赖，所以你可以将它们中的任何一个切换出来而不会有任何问题。此外，您可以在<code class="fe lz ma mb mc b">ErrorHandler</code>中添加任何您想要的定制逻辑。例如，您可以添加一个您想要忽略其404错误的白名单查询列表，或者一个处理多个并发错误的策略。每个应用程序的需求都不同，因此这种特定的逻辑与您的业务紧密相关。</p><p id="22c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以你有它。仅仅使用<code class="fe lz ma mb mc b">ErrorHandler</code>和<code class="fe lz ma mb mc b">useQuery</code>钩子，你现在就有了一个集中式的API错误处理模块。应该提到的是，如果你正在使用一个状态管理库，你很可能<strong class="ka ir">不会</strong>使用<code class="fe lz ma mb mc b">useQuery</code>钩子。相反，作为HTTP获取逻辑的一部分，您必须手动触发<code class="fe lz ma mb mc b">history.replace</code>,这因库而异。让我们看看在一些最流行的例子中你会如何处理这个问题:</p><h1 id="3fb8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">对于Redux用户</h1><p id="8105" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要在redux中实现这个解决方案，您需要访问您的历史记录。有多种方法可以做到这一点，要么将历史记录作为参数传递给<code class="fe lz ma mb mc b">createStore</code>函数并创建一个中间件，要么简单地利用<a class="ae nc" href="https://github.com/supasate/connected-react-router" rel="noopener ugc nofollow" target="_blank"> connected-react-router </a>，它公开一个动作创建器来直接修改您的历史记录。只要用正确的参数启动这个动作，你就可以开始了！文档中已经详细介绍了如何做到这一点。</p><h1 id="b4ce" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">对于阿波罗用户</h1><p id="ffaf" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了在Apollo客户机中处理这个问题，您需要利用<a class="ae nc" href="https://github.com/apollographql/apollo-link/tree/master/packages/apollo-link-error" rel="noopener ugc nofollow" target="_blank"> apollo-link-error </a>并创建一个可以访问历史记录的错误链接，以便调用<code class="fe lz ma mb mc b">history.replace</code>。最简单的方法是创建一个历史实例(如果使用<code class="fe lz ma mb mc b">react-router</code>，则通过<code class="fe lz ma mb mc b">createBrowserHistory</code>)并在链接中直接使用它。同一个实例需要传递给<code class="fe lz ma mb mc b">&lt;Router&gt;</code>组件。如果您不想这样做，另一个选择是从<code class="fe lz ma mb mc b">useHistory</code>钩子中读取历史，将其作为参数传递给客户端(需要在react组件中创建)，然后将其转发给错误链接。只有当您希望依靠路由器来提供历史实例时，才应该考虑后者，这将允许您为生产和测试环境保持相同的Apollo客户机(由于依赖注入)。</p><h1 id="829e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结束语</h1><p id="ca18" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">尽管我们在本文中编写的许多代码在最后都没有使用，但是有必要展示我在那里看到的许多方法的问题。这篇文章的目标是给你一个很好的方法来一劳永逸地处理所有React应用程序中的API错误。你现在可以忘记上下文，状态，重新渲染，钩子和所有的事情。处理api错误所需要的只是一个顶级组件，它读取当前位置的状态并做出相应的反应，再加上任何一种可以修改历史记录的中央“API模块”。这个解决方案很好，不仅因为它没有强制组件耦合，还因为它非常抽象和通用，可以很容易地移植到任何框架中。到目前为止，这在我的大多数应用程序中运行良好，我真的很高兴，但我很想知道你的想法。最终解决方案的代码可以在<a class="ae nc" href="https://codesandbox.io/s/determined-shaw-6kmjc?autoresize=1&amp;fontsize=14&amp;moduleview=1" rel="noopener ugc nofollow" target="_blank">这里</a>找到:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="nd mi l"/></div></figure><p id="1617" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请随时询问任何问题或推荐更好的方法来解决这个问题；我很高兴听到他们的消息。</p><p id="6eb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常感谢你的阅读！</p><p id="8fe9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="nb"/></strong>👋<strong class="ka ir"> <em class="nb">嗨，我是</em></strong><a class="ae nc" href="https://aggelosarvanitakis.me/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nb">Aggelos</em></strong></a><strong class="ka ir"><em class="nb">！如果你喜欢这个，可以考虑在推特上关注我或者</em> </strong> <a class="ae nc" href="https://medium.com/@aggelosarvanitakis" rel="noopener"> <strong class="ka ir"> <em class="nb">中</em> </strong> </a> <strong class="ka ir"> <em class="nb"> </em>😀</strong></p></div></div>    
</body>
</html>