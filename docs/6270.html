<html>
<head>
<title>Building a React state management library with built in effects support</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建带有内置效果支持的React状态管理库</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-react-state-management-library-with-built-in-effects-support-36c5f5358dc2?source=collection_archive---------5-----------------------#2021-10-04">https://itnext.io/building-a-react-state-management-library-with-built-in-effects-support-36c5f5358dc2?source=collection_archive---------5-----------------------#2021-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ca95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在为react构建聊天业务逻辑库时，我意识到当前的状态管理解决方案很欠缺。聊天是一个实时的复杂应用程序，有许多听众——当我加入一个新的聊天室时，你必须确保有一个回拨，确保在每个房间收听新消息和阅读指示，确保在参与者更改他们的个人资料图片时收听。当人们谈论状态管理库时，他们总是谈论在其中处理fetch和其他基于Promise的异步操作是多么重要。但是处理基于事件的异步，以及事后清理以免留下任何内存泄漏，要困难得多。我们现在拥有的最好的解决方案是redux-observables，这是解决这些问题的一种非常优雅的方式，但我相信它可以用一种更简单的方式来实现。面对这个问题，我决定尝试构建自己的状态管理解决方案，从零开始，边走边解决问题。</p><p id="49a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到完工的图书馆—<a class="ae kl" href="https://www.npmjs.com/package/@plancky/state" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/@plancky/state</a>。</p><p id="c2a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我创建了一个存储数据的类，当数据发生变化时，它能够与视图层进行通信。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/204da464edd180375c210db43a7e60d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88PGvE1KQAOBNa7tdAdK7A.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">通知程序类</figcaption></figure><p id="9e76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，从它扩展而来的任何类都可以拥有内部数据和修改它的方法，并在视图层需要知道这些变化时调用<strong class="jp ir"> this.notify() </strong>。然后我们可以从视图层订阅它，并在调用<strong class="jp ir"> notify </strong>时重新渲染，就像这样。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/777a97b7b832c44509e32a2190f06272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3z9LK-pGlugmWulyEXp3Xw.png"/></div></div></figure><p id="be08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是notifier类的一个用法示例。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/8b915b80b4884b8e6de44e437d11f7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njckR8rSIqxYpepJIirJAQ.png"/></div></div></figure><p id="9fc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次发生变化时都要记住调用<strong class="jp ir"> this.notify() </strong>很麻烦，所以我决定用一种更习惯的方式来更新它——stateful notifier。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/a4bd84f5979591eaf030e2a08416a5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wK-bdu_Wur5tyq-tceVxoQ.png"/></div></div></figure><p id="e5bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个类不仅在数据发生变化时通知视图层，还实现了类似React的setState的setState函数，在内部调用<strong class="jp ir">notify()</strong>。现在我们可以从StatefulNotifier扩展，传递我们的初始状态，只使用setState，而不用担心每次更改都要调用notify。</p><p id="eba0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将StatefulNotifier的创建封装到一个函数<strong class="jp ir"> createStore() </strong>中，以便于使用。它将初始状态作为第一个参数，创建动作的函数作为第二个参数。我从国家管理图书馆得到了这个决定的灵感。此时，我们有了一个本质上类似于Zustand的api。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/5a0658372a3083f1675291d6e50d9a69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_SjyOqzhQeBgEtfuPqTaQ.png"/></div></div></figure><p id="09e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以创建一个简单的<strong class="jp ir"> useStore(store，selector) </strong>钩子，在react中使用它，避免不必要的重新呈现。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/555e9fa74468e62567a2d18ff8e0948d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yBOgrpUO17KTB_Ag57MGxw.png"/></div></div></figure><p id="2af1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以像这样创建一个商店:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/976faf867ed413354d51f3df0b12b782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vz_58B_BBsJo7ZOtJHJB5w.png"/></div></div></figure><p id="4916" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在我们的react层，我们可以简单地调用</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/a31204c7e59dbe6f2d1dde918745afa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tM9TlXwHwmpP90G8S8Ou3Q.png"/></div></div></figure><p id="7d41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当房间自动改变时，它会处理重新渲染。我们还可以使用视图层中的任何操作。</p><p id="6221" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们为React提供了一个成熟的状态管理解决方案。但是处理事件还是比较繁琐。假设我们想在每次调用actions.addRoom()时为新消息添加一个事件侦听器。当然，我们可以在actiona中启动效果，并让action返回一个<strong class="jp ir"> unsubscribe。</strong>但是如果我们需要移除那个房间，我们必须确保我们有一个取消订阅功能的引用。此外，当我们调用actions.removeRoom()时，我们还必须记住调用unsubscribe以避免内存泄漏。这不是被动的，错误肯定会出现。理想情况下——我们希望我们的州经理为我们处理这件事。我们希望它在<strong class="jp ir"> addRoom() </strong>中添加事件监听器，并在<strong class="jp ir"> removeRoom() </strong>中移除它。</p><blockquote class="lc ld le"><p id="2b84" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">Effect是一个启动某种进程(例如事件监听器)并返回清理结果的函数。React的useEffect钩子就是一个很好的例子。</p></blockquote><p id="d1f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">面对这个问题，我致力于实现对在商店中添加和删除id效果的支持。EffectiveStatefulNotifier的实现如下所示。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/ba51d8d139f328fcc45f002959e2cd59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4TJ2FWBNAXMr2iWhNk1RKg.png"/></div></div></figure><p id="dce0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以修改createStore函数来处理效果。我们只需要像这样修改Api类型。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/209fdc9c850f8ca2b2babe91568f9fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gj4hdewrIyITEPxrgaW8rw.png"/></div></div></figure><p id="cec3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其余保持不变，除了我们现在称<em class="lf">为【新的有效状态通知程序(状态)】而不是<em class="lf">新的状态通知程序(状态)。</em></em></p><p id="65a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的状态管理解决方案有了对效果的本地支持，我们可以像这样修改addRoom和removeRoom函数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/15e21db124b6cb4d1efec99701972a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiYCrMdGmpVYExocsqMO-g.png"/></div></div></figure><p id="cb89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在react层中，我们可以调用actions.addRoom('id ')，然后使用actions.removeRoom('id ')进行清理，而不用担心内存泄漏——存储会为我们处理这些:)</p></div></div>    
</body>
</html>