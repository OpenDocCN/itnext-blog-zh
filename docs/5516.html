<html>
<head>
<title>Simple tips for writing clean React components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写干净的React组件的简单技巧</h1>
<blockquote>原文：<a href="https://itnext.io/simple-tips-for-writing-clean-react-components-c3facbf6680e?source=collection_archive---------0-----------------------#2021-03-22">https://itnext.io/simple-tips-for-writing-clean-react-components-c3facbf6680e?source=collection_archive---------0-----------------------#2021-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0884dd6354e90060d17cd458a3934926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YBxxZGYN-x1yhpWb"/></div></div></figure><p id="fce3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，让我们回顾一些简单的技巧，它们将帮助你编写更干净的React组件，并更好地扩展你的项目。</p><h1 id="73df" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">避免用展开操作符传递道具</h1><p id="a9f0" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">首先，让我们从您应该避免的反模式开始。除非有特定的正当理由，否则应该避免使用spread操作符沿着组件树向下传递属性，就像这样:<code class="fe mc md me mf b">{...props}</code>。</p><p id="bbd3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以这种方式传递属性确实可以加快编写组件的速度。然而，这也使得确定代码中的错误变得非常困难。您对您的组件失去了信心，这使得重构它们变得更加困难，结果是，错误将很快开始蔓延。</p><h1 id="9050" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">将函数参数包装在一个对象中</h1><p id="613b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果您的函数接受多个参数，最好将它们包装在一个对象中。这里有一个例子:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="67f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以这种方式编写函数签名有几个显著的优点:</p><ol class=""><li id="6d76" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">你不再需要担心你传递论点的顺序。我犯过几次这样的错误，我会引入一个bug并以错误的顺序传递函数参数。</li><li id="c27a" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">对于配置了IntelliSense的编辑器(现在的大多数编辑器)，您将获得一个很好的函数参数自动完成特性。</li></ol><h1 id="5322" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">对于事件处理程序，使用返回处理程序函数的函数</h1><p id="bbdd" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果您熟悉函数式编程，这种技术类似于奉承，因为您提前预设了一些参数。</p><p id="f5ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看这个例子:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="125a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，通过以这种方式编写处理函数，您可以保持组件树更加清晰。</p><h1 id="64e6" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">在if/else上使用映射</h1><p id="71c0" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">当您需要根据定制逻辑呈现不同的元素时，我建议使用map而不是if/else语句。</p><p id="60cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个使用if/else的例子:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="f9a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个使用地图的例子:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="07eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用这个简单的策略，您的组件变得更具声明性，更容易理解。这也使得扩展逻辑和添加更多条目变得更加简单。</p><h1 id="5e52" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">挂钩组件</h1><p id="5a3d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我发现这个模式很有用，只要你不滥用它。</p><p id="73da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能会发现自己在应用程序中使用了一些组件。如果它们需要一个状态来运行，您可以用一个提供该状态的钩子来包装它们。这类组件的一些很好的例子是弹出窗口、toast通知或简单模态。例如，下面是一个简单确认模式的组件挂钩:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="11b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，您可以像这样使用组件挂钩:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d0db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以这种方式抽象组件可以让您不必编写大量的样板状态管理代码。如果你想了解更多有用的React钩子，在这里查看我的<a class="ae na" href="https://isamatov.com/useful-react-hooks/" rel="noopener ugc nofollow" target="_blank">帖子</a>。</p><h1 id="ce8a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">拆分组件</h1><p id="c8a5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">以下三个技巧是关于智能拆分组件的。根据我的经验，保持你的组件小是保持你的项目可管理的最好方法。</p><h1 id="b8da" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用包装</h1><p id="1471" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果你正在努力寻找一种方法来拆分你的大组件，看看你的组件的每个元素提供的功能。有些元素提供了独特的功能，比如拖放处理程序。</p><p id="674a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个使用<a class="ae na" href="https://github.com/atlassian/react-beautiful-dnd" rel="noopener ugc nofollow" target="_blank"> react-beautiful-dnd </a>实现拖放的组件示例:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="c862" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在我们将所有拖放逻辑移动到一个包装器组件之后，检查该组件:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d43b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是包装器的代码:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="69e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，很容易浏览组件，并从较高的层面理解它的功能。拖放的所有功能都存在于包装器中，更容易理解。</p><h1 id="5c76" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">关注点分离</h1><p id="a229" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这是我最喜欢的分割较大组件的方法。</p><p id="2d8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在React的上下文中，关注点的分离意味着分离组件中负责获取和变更数据的部分，以及纯粹负责显示元素树的部分。</p><p id="3613" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种关注点分离的方法是引入钩子模式的主要原因。您可以并且应该用一个自定义钩子包装所有管理API或全局状态连接的逻辑。</p><p id="303f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，让我们看看他的组件:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="2540" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，这里是它的重构版本，使用自定义挂钩进行代码拆分:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="4b87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是钩子本身:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="6027" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">每个组件的单独文件</h1><p id="e5f2" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">人们经常这样写代码:</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="8179" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然以这种方式编写React组件没有什么可怕的错误，但这不是一个好的实践。将<code class="fe mc md me mf b">ItemDisplay</code>移动到一个单独的文件没有坏处，好处是您的组件是松散耦合的，更容易扩展。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="c1f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">编写干净的代码在很大程度上可以归结为留心并花时间遵循好的模式和避免反模式。所以，如果你花时间遵循这些模式，它将帮助你的写清洁器反应组件。我发现这些模式在我的项目中非常有用，希望你也一样！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="32f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ni">原载于2021年3月22日https://isamatov.com</em><em class="ni">的</em> <a class="ae na" href="https://isamatov.com/simple-tips-for-writing-clean-react-components/" rel="noopener ugc nofollow" target="_blank"> <em class="ni">。</em></a></p></div></div>    
</body>
</html>