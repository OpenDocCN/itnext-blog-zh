<html>
<head>
<title>⚛️ Building React Virtual Scroll in 5 min — Alternative to Pagination and Infinite Scroll</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">⚛️建筑反应虚拟滚动在5分钟-替代分页和无限滚动</h1>
<blockquote>原文：<a href="https://itnext.io/%EF%B8%8F-building-reactvirtual-scroll-in-5-min-alternative-to-pagination-and-infinite-scroll-515e0e329e76?source=collection_archive---------0-----------------------#2022-11-30">https://itnext.io/%EF%B8%8F-building-reactvirtual-scroll-in-5-min-alternative-to-pagination-and-infinite-scroll-515e0e329e76?source=collection_archive---------0-----------------------#2022-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="945f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">结合分页和无限滚动的优点，增强用户体验和性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c035f929840042fcd9b27d2add0900ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uALMo4Ssd2H-6z5XzxMUTg.png"/></div></div></figure><h1 id="74da" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">内容</h1><ul class=""><li id="3262" class="lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><a class="ae mb" href="#83ba" rel="noopener ugc nofollow"> <strong class="ll ir">简介</strong> </a></li><li id="813b" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated"><a class="ae mb" href="#01b8" rel="noopener ugc nofollow"> <strong class="ll ir"> 3选项优化性能长列表</strong> </a></li><li id="c9d9" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated"><a class="ae mb" href="#d5dd" rel="noopener ugc nofollow"> <strong class="ll ir"> 1。</strong>分页</a></li><li id="f5af" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated"><a class="ae mb" href="#45a4" rel="noopener ugc nofollow"> <strong class="ll ir"> 2。无限卷轴</strong> </a></li><li id="00e0" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated"><a class="ae mb" href="#b05f" rel="noopener ugc nofollow"> <strong class="ll ir"> 3。虚拟卷轴</strong> </a></li><li id="ade8" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated"><a class="ae mb" href="#95d8" rel="noopener ugc nofollow"> <strong class="ll ir">建筑虚拟卷轴使用</strong> </a></li><li id="4962" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated"><a class="ae mb" href="#2a1c" rel="noopener ugc nofollow"> <strong class="ll ir"> GitHub链接</strong> </a></li><li id="4097" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated"><a class="ae mb" href="#0894" rel="noopener ugc nofollow"> <strong class="ll ir">结论</strong> </a></li><li id="0f45" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated"><a class="ae mb" href="#f9b1" rel="noopener ugc nofollow"> <strong class="ll ir">了解更多</strong> </a></li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="83ba" class="kr ks iq bd kt ku mo kw kx ky mp la lb jw mq jx ld jz mr ka lf kc ms kd lh li bi translated">介绍</h1><p id="43b6" class="pw-post-body-paragraph mt mu iq ll b lm ln jr mv lo lp ju mw lq mx my mz ls na nb nc lu nd ne nf lw ij bi translated">每个开发人员，尤其是前端人员，在编写代码时都必须考虑到性能。你不能纯粹使用普通的js来编写web应用程序，这可能太耗时了，所以你必须在流行的框架中做出选择。大多数框架，如React和Angular，已经考虑了开发过程中可能发生的性能问题。如果您有兴趣阅读更多关于React性能的内容，可以查看这篇文章:</p><div class="ng nh gp gr ni nj"><a rel="noopener  ugc nofollow" target="_blank" href="/️-top-7-tweaks-and-tricks-to-improve-react-performance-8957bab33266"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">⚛️提高React性能的7大调整和技巧</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">如果您还没有看到性能问题，并不意味着它们不存在😄</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">itnext.io</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kp nj"/></div></div></a></div><p id="1e3f" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">因此，我们也将讨论性能，但主要焦点是数据的<strong class="ll ir">渲染长列表</strong>。在数据驱动的web应用程序中，这是一个非常常见的用例。当后端产生太多数据，所以前端可能很难呈现。我们将通过不同的例子来说明如何优化列表的呈现性能。最后实现了<strong class="ll ir">虚拟滚动模型。它可能非常普通，但我们将在展示中使用React。</strong></p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="01b8" class="kr ks iq bd kt ku mo kw kx ky mp la lb jw mq jx ld jz mr ka lf kc ms kd lh li bi translated">优化长列表性能的3个选项</h1><p id="462d" class="pw-post-body-paragraph mt mu iq ll b lm ln jr mv lo lp ju mw lq mx my mz ls na nb nc lu nd ne nf lw ij bi translated">我们将比较最流行的列表渲染模型。每个模型都有自己的优点和CONS。并且由开发人员为特定的用例选择正确的。这将取决于要求和限制。因此，我们可以考虑以下选项:</p><ul class=""><li id="d44e" class="lj lk iq ll b lm ny lo nz lq od ls oe lu of lw lx ly lz ma bi translated"><strong class="ll ir">分页</strong> —经典分页，基于<em class="og">偏移</em>和<em class="og">限位</em>；</li><li id="9437" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated"><strong class="ll ir">无限卷轴</strong>——也是非常受欢迎的机型，最好的例子可能是<a class="ae mb" href="https://www.pinterest.com/" rel="noopener ugc nofollow" target="_blank">Pinterest</a>；</li><li id="4db9" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated">虚拟滚动是一个替代模型，它结合了分页和无限滚动用户体验的优点，我们将使用React实现这个模型</li></ul><p id="9cb0" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">所有的模型都是基于相同的原则，不要渲染客户端视图中没有的元素。说完这句话，我们开始吧。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="d5dd" class="kr ks iq bd kt ku mo kw kx ky mp la lb jw mq jx ld jz mr ka lf kc ms kd lh li bi translated">1.分页</h1><p id="0154" class="pw-post-body-paragraph mt mu iq ll b lm ln jr mv lo lp ju mw lq mx my mz ls na nb nc lu nd ne nf lw ij bi translated">嗯，这个渲染模型不需要太多解释。大多数开发人员在其职业生涯中至少遇到过一次。最常见的设计基于两个变量<strong class="ll ir">偏移</strong>和<strong class="ll ir">限制:</strong></p><ul class=""><li id="c461" class="lj lk iq ll b lm ny lo nz lq od ls oe lu of lw lx ly lz ma bi translated"><strong class="ll ir">限制</strong> —它与每页的项目数<strong class="ll ir">相同</strong>，即我们希望每个API调用请求多少个项目。</li><li id="7057" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated"><strong class="ll ir">偏移</strong> —光标的<strong class="ll ir">当前位置</strong>。例如，如果我们有100个索引从0到99的项目，并且限制为20个，那么第一个调用将看起来是<code class="fe oh oi oj ok b">limit=20&amp;offset=0</code>(它将给出索引从0到19的项目列表)，而下一个调用(下一页)将是<code class="fe oh oi oj ok b">limit=20&amp;offset=20</code>(范围是20到39)</li></ul><p id="4d0f" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">此外，该请求可以包含页面数据，页面数据可以包括:页数、总项目数以及下一页是否存在。页面数据输出可能因实现方式而异。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/641a9dd4b24465ff9bfc21c91b13ce9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuEUy6dLf3KKRcni9YM2kQ.png"/></div></div></figure><p id="6e08" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">让我们转到下一个模型。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="45a4" class="kr ks iq bd kt ku mo kw kx ky mp la lb jw mq jx ld jz mr ka lf kc ms kd lh li bi translated">2.无限卷轴</h1><p id="c57d" class="pw-post-body-paragraph mt mu iq ll b lm ln jr mv lo lp ju mw lq mx my mz ls na nb nc lu nd ne nf lw ij bi translated">无限卷轴使用了同样的<strong class="ll ir">偏移，限制</strong>的方法，不同的是视觉设计和用户体验。最初，我们只加载由<strong class="ll ir">限制</strong>定义的数据缓冲区。当我们向下滚动并到达(或接近)列表底部时，我们调用下一个数据块，并在等待时显示一些加载指示器。加载一个新的块后，我们把它添加到列表的尾部。以后我们可以继续滚动并重复同样的动作，这就是为什么这种方法被称为<strong class="ll ir">无限滚动</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/e6a987053d6a9823e21fc0bd7fc122d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*sEs2Wp9vFV7NiokDQuUAYw.gif"/></div></figure><p id="180d" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">这种模式有一个缺点。每次我们加载和追加新数据时，我们的<strong class="ll ir">列表将继续增长</strong>。我们滚动得越多，它就越大。这可能效率不高，因为我们必须将所有数据保存在内存中，并且在大多数实现中，还要将数据保存在DOM中。浏览器无法呈现如此大量的数据后，性能将会降低。另一个问题是追加列表<strong class="ll ir">不包括新数据</strong>，它缓存状态。与<strong class="ll ir">分页</strong>相反，其中<strong class="ll ir"> </strong>您可以浏览页面，如下一页和上一页，并获得刷新的数据。</p><p id="7607" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">无限滚动模式的用户体验更加自然，并且考虑到了移动优先(与<strong class="ll ir">分页</strong>相比)。这就是它被广泛应用于Instagram或脸书feeds等现代网络应用的原因。</p><p id="7c1b" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">但是有一种方法可以优化无限滚动，通过分页特性来增强它。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="b05f" class="kr ks iq bd kt ku mo kw kx ky mp la lb jw mq jx ld jz mr ka lf kc ms kd lh li bi translated">3.虚拟卷轴</h1><p id="e1a3" class="pw-post-body-paragraph mt mu iq ll b lm ln jr mv lo lp ju mw lq mx my mz ls na nb nc lu nd ne nf lw ij bi translated">无限滚动缺少分页使用的一项功能，即上一页和下一页导航以加载新数据。此外，我们不需要将所有新数据保存在内存中，我们可以只保存缓冲区，并在最近的API调用后更新它。但是，我们如何才能保持与Infinity scroll相同的用户体验呢？又来了一个模型——<strong class="ll ir">虚拟卷轴</strong>。该模型具有以下特征。</p><ul class=""><li id="6fe8" class="lj lk iq ll b lm ny lo nz lq od ls oe lu of lw lx ly lz ma bi translated">使用相同的偏移、限制模式；</li><li id="00d9" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated">我们保留缓冲区中的最大项数，等于<strong class="ll ir"> limit * 3 </strong>(例如:如果limit为20，则最大缓冲区为60)<strong class="ll ir">；</strong></li><li id="fe28" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated">只有<strong class="ll ir">有限</strong>数量的项目在视窗中可见(例如限制为20)；</li><li id="ac51" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated">这个概念类似于一个有3个记录的<strong class="ll ir">双向链表</strong>:上一个限制、当前限制和下一个限制。你也可以把它想象成一扇推拉窗；</li><li id="cdb3" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated">如果我们滚动到列表的底部，加载新的next并更新缓冲区:previous(丢弃)<strong class="ll ir"> - &gt; x </strong> current(新的上一个)<strong class="ll ir"> - &gt; </strong> next(新的当前)<strong class="ll ir"> - &gt; +- &gt;新的next；</strong></li><li id="1c45" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated">如果我们滚动到顶部，加载新的previous并更新缓冲区:<strong class="ll ir">新的previous</strong><strong class="ll ir">-&gt;+-&gt;</strong>previous(新的当前)<strong class="ll ir"> - &gt; </strong>当前(新的下一个)<strong class="ll ir"> - &gt; x </strong>下一个(丢弃)；</li><li id="03bb" class="lj lk iq ll b lm mc lo md lq me ls mf lu mg lw lx ly lz ma bi translated">当加载一个新的块时，我们需要显示一些加载指示器；</li></ul><p id="5a8d" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">如果到目前为止还没有意义，不要担心，我们将浏览示例并实现它，这样一切都变得更清楚了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/9c28e7305f441e970c30ea79ce34c7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KKeEEMlwDlrP2NZKEQuKtA.png"/></div></div></figure><p id="841f" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">听起来这可能很难实现，因为我们需要控制滚动并确保缓冲区被正确更新。</p><p id="ee5d" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">让我们挑战它，建立虚拟卷轴原型。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="95d8" class="kr ks iq bd kt ku mo kw kx ky mp la lb jw mq jx ld jz mr ka lf kc ms kd lh li bi translated">使用React构建虚拟滚动</h1><p id="623f" class="pw-post-body-paragraph mt mu iq ll b lm ln jr mv lo lp ju mw lq mx my mz ls na nb nc lu nd ne nf lw ij bi translated">此时，我们将尝试构建一个虚拟卷轴来演示这个概念。我们将在示例中使用React。</p><p id="02a3" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">首先，让我们使用create react命令和typescript选项生成一个React应用程序:</p><pre class="kg kh ki kj gt oo ok op oq aw or bi"><span id="a7f3" class="os ks iq ok b gy ot ou l ov ow">npx create-react-app react-virtual-scroll --template typescript</span></pre><p id="dc92" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">现在让我们打开<code class="fe oh oi oj ok b">App.tsx</code>文件并创建一个模拟API调用。它将只接收两个参数:<strong class="ll ir">偏移</strong>和<strong class="ll ir">限制。</strong></p><pre class="kg kh ki kj gt oo ok ox bn oy oz bi"><span id="a7b9" class="pa ks iq ok b be pb pc l pd ow">const callApi = (offset: number, limit: number) =&gt; {<br/>  return new Promise((resolve) =&gt; {<br/>    const items = [] as any<br/>    for (let index = offset; index &lt; offset + limit; index++) {<br/>      items.push('label ' + index)<br/>    }<br/><br/>    setTimeout(() =&gt; {<br/>      resolve(items)<br/>    }, 2000)<br/>  })<br/>}</span></pre><p id="0d71" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">它将向我们返回字符串数组<code class="fe oh oi oj ok b">label ${index}</code>，其中索引是当前光标位置。稍后，我们需要初始化<code class="fe oh oi oj ok b">App.tsx</code>中的常量和状态</p><pre class="kg kh ki kj gt oo ok ox bn oy oz bi"><span id="bd3a" class="pa ks iq ok b be pb pc l pd ow">function App() { <br/>  const limit = 100<br/>  // the number of items that we want to keep in memory - 300<br/>  const buffer = limit * 3<br/>  // the number of items that we want to cache when new chunk of data is loaded <br/>  const cache = buffer - limit<br/>  const [items, setItems] = useState([])<br/>  const [isLoading, setIsLoading] = useState(false)</span></pre><p id="caca" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">我们需要第一次调用API来初始化<code class="fe oh oi oj ok b">useEffect</code>中的数据</p><pre class="kg kh ki kj gt oo ok ox bn oy oz bi"><span id="d8ae" class="pa ks iq ok b be pb pc l pd ow">useEffect(() =&gt; {<br/>    setIsLoading(true)<br/>    callApi(0, buffer).then((res: any) =&gt; {<br/>      setItems(res)<br/>      setIsLoading(false)<br/>    })<br/>  }, [])</span></pre><p id="0d96" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">然后，我们将实现两个回调，一个是当滚动到达列表包装的顶部时，另一个是当滚动到达列表包装的底部时。让我们看看它是什么样子的:</p><pre class="kg kh ki kj gt oo ok ox bn oy oz bi"><span id="91d0" class="pa ks iq ok b be pb pc l pd ow"> const prevCallback = (newOffset: number) =&gt; {<br/>    setIsLoading(true)<br/><br/>    return callApi(newOffset, limit).then((res: any) =&gt; {<br/>      const newItems = [...res, ...items.slice(0, cache)] as any<br/>      setItems(newItems)<br/>      setIsLoading(false)<br/>      return true<br/>    })<br/>  }<br/><br/>  const nextCallback = (newOffset: number) =&gt; {<br/>    setIsLoading(true)<br/><br/>    return callApi(newOffset, limit).then((res: any) =&gt; {<br/>      const newItems = [...items.slice(-cache), ...res] as any<br/>      setItems(newItems)<br/>      setIsLoading(false)<br/>      return true<br/>    })<br/>  }</span></pre><blockquote class="pe pf pg"><p id="583d" class="mt mu og ll b lm ny jr mv lo nz ju mw ph oa my mz pi ob nb nc pj oc ne nf lw ij bi translated"><em class="iq">当我们到达顶部时，我们加载先前的块，将其添加到头部并丢弃尾部。否则，当我们到达底部时，我们附加到尾部并丢弃头部。</em></p></blockquote><p id="f610" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">现在，让我们渲染列表并将其包装到<code class="fe oh oi oj ok b">UiVirtualScroll</code>组件中，我们将在下一步实现它:</p><pre class="kg kh ki kj gt oo ok ox bn oy oz bi"><span id="c798" class="pa ks iq ok b be pb pc l pd ow">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;UiVirtualScroll<br/>        buffer={buffer}<br/>        rowHeight={39}<br/>        height="50vh"<br/>        limit={limit}<br/>        onPrevCallback={prevCallback}<br/>        onNextCallback={nextCallback}<br/>      &gt;<br/>        &lt;&gt;<br/>          {items.map((item: any, index: number) =&gt; (<br/>            &lt;div style={{ padding: '10px' }}&gt;<br/>              {isLoading ? &lt;&gt;Loading...&lt;/&gt; : item}<br/>            &lt;/div&gt;<br/>          ))}<br/>        &lt;/&gt;<br/>      &lt;/UiVirtualScroll&gt;<br/>    &lt;/div&gt;<br/>  )</span></pre><p id="8cbe" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">我们需要<code class="fe oh oi oj ok b">rowHeight</code>来计算列表更新时滚动的正确位置。和<code class="fe oh oi oj ok b">height</code>来应用<em class="og">覆盖层</em>。</p><p id="3bbf" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">现在，让我们继续前进，最终实现<code class="fe oh oi oj ok b">UiVirtualScroll</code>组件。</p><p id="ea7c" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">让我们初始化状态:</p><pre class="kg kh ki kj gt oo ok ox bn oy oz bi"><span id="df9e" class="pa ks iq ok b be pb pc l pd ow">const UiVirtualScroll: FunctionComponent&lt;UiVirtualScrollProps&gt; = ({<br/>  offset = 0,<br/>  buffer,<br/>  limit,<br/>  rowHeight,<br/>  height,<br/>  onPrevCallback,<br/>  onNextCallback,<br/>  children,<br/>}) =&gt; {<br/>  // create overlay reference to trigger the change scroll position<br/>  const overlayRef: any = useRef&lt;any&gt;(null)<br/><br/>  // create two cursors of lower and upper boundary of cached items indices<br/>  // initial upper boundary index is 0<br/>  const [upperBoundary, setUpperBoundary] = useState(offset)<br/>  // initial lower boundary index is 300-1 = 299<br/>  const [lowerBoundary, setLowerBoundary] = useState(buffer - 1)<br/>  const [isLoading, setIsLoading] = useState(false)<br/>  // current scroll position starting with 0<br/>  const [currentScrollTopPosition, setCurrentScrollTopPosition] = useState(0)</span></pre><p id="70fd" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">然后，呈现包装的列表项(我们将在下一步实现<code class="fe oh oi oj ok b">handleScroll</code>):</p><pre class="kg kh ki kj gt oo ok ox bn oy oz bi"><span id="c956" class="pa ks iq ok b be pb pc l pd ow">return (<br/>    &lt;div<br/>      ref={overlayRef}<br/>      style={{ height, overflow: 'scroll' }}<br/>      onScroll={(e: any) =&gt; handleScroll(e.target)}<br/>    &gt;<br/>      {children}<br/>    &lt;/div&gt;<br/>  )</span></pre><p id="e8fb" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">现在我们移到了最有趣的部分，我们需要处理滚动，触发上一个和下一个回调，更新边界并将滚动移动到新的位置。看起来是这样的:</p><pre class="kg kh ki kj gt oo ok ox bn oy oz bi"><span id="6e5d" class="pa ks iq ok b be pb pc l pd ow">const handleScroll = (target: any) =&gt; {<br/>    // ignore the scroll if data is loading<br/>    if (isLoading) {<br/>      return<br/>    }<br/><br/>    // get the current position of the scroll<br/>    const scrollTop = Math.round(target.scrollTop)<br/>    // extracting the client height and scroll height to calculate the top scroll maximum position<br/>    // where is highest scroll position is scrollHeight = clientHeight + scrollTop<br/>    const clientHeight = Math.round(target.clientHeight)<br/>    const scrollHeight = Math.round(target.scrollHeight)<br/><br/>    // defining if we currently scrolling up or down<br/>    const isUp = scrollTop &lt; currentScrollTopPosition<br/><br/>    if (isUp &amp;&amp; scrollTop === 0) {<br/>      setIsLoading(true)<br/><br/>      onPrevCallback(upperBoundary - limit).then(() =&gt; {<br/>        // update boundaries to move indices - limit<br/>        setUpperBoundary(upperBoundary - limit)<br/>        setLowerBoundary(lowerBoundary - limit)<br/><br/>        // move scroll position to 1 limit height<br/>        if (overlayRef !== null) {<br/>          const scrollPos = limit * rowHeight<br/>          overlayRef.current.scrollTo(0, scrollPos)<br/>        }<br/>        setIsLoading(false)<br/>      })<br/>    } else if (!isUp &amp;&amp; scrollTop + clientHeight &gt;= scrollHeight) {<br/>      setIsLoading(true)<br/><br/>      onNextCallback(lowerBoundary).then(() =&gt; {<br/>        // update boundaries to move indices + limit<br/>        setUpperBoundary(upperBoundary + limit)<br/>        setLowerBoundary(lowerBoundary + limit)<br/><br/>        if (overlayRef !== null) {<br/>          const scrollPos = limit * rowHeight<br/>          // move scroll position to 2 limits height<br/>          overlayRef.current.scrollTo(0, scrollPos * 2)<br/>        }<br/>        setIsLoading(false)<br/>      })<br/>    }<br/>    // update the current cursor position<br/>    setCurrentScrollTopPosition(scrollTop)<br/>  }</span></pre><p id="c101" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">这就是所有的实现，您可以通过浏览注释来跟踪每一行在做什么。</p><p id="49d8" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">这是最终的工作原理:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/a69763ec152ec32148a6cd6dce2af526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Q28D1YBI8Nm0e6JKdCnw7w.gif"/></div></figure><p id="ed62" class="pw-post-body-paragraph mt mu iq ll b lm ny jr mv lo nz ju mw lq oa my mz ls ob nb nc lu oc ne nf lw ij bi translated">您也可以通过下面的链接直接从GitHub克隆实现。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="2a1c" class="kr ks iq bd kt ku mo kw kx ky mp la lb jw mq jx ld jz mr ka lf kc ms kd lh li bi translated">GitHub链接</h1><div class="ng nh gp gr ni nj"><a href="https://github.com/Vitashev/react-virtual-scroll" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">GitHub-Vitashev/react-虚拟滚动</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="pk l nu nv nw ns nx kp nj"/></div></div></a></div></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="0894" class="kr ks iq bd kt ku mo kw kx ky mp la lb jw mq jx ld jz mr ka lf kc ms kd lh li bi translated">结论</h1><p id="e28f" class="pw-post-body-paragraph mt mu iq ll b lm ln jr mv lo lp ju mw lq mx my mz ls na nb nc lu nd ne nf lw ij bi translated">我们已经完成了虚拟滚动实现，以后可以扩展以满足您的需求。希望您现在已经清楚了分页和无限滚动之间的区别，并且已经了解了结合这两种模型优点的替代解决方案。选择越多越好，因为不同项目的需求会有很大的不同。<em class="og">命中👏如果你今天学到了新东西。还有别忘了</em> <strong class="ll ir"> <em class="og">关注</em> </strong> <em class="og">和</em> <strong class="ll ir"> <em class="og">订阅</em> </strong> <em class="og">不要错过新内容。</em></p><div class="ng nh gp gr ni nj"><a href="https://easy-web.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">easy-web.medium.com</p></div></div><div class="ns l"><div class="pl l nu nv nw ns nx kp nj"/></div></div></a></div></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="f9b1" class="kr ks iq bd kt ku mo kw kx ky mp la lb jw mq jx ld jz mr ka lf kc ms kd lh li bi translated">了解更多信息</h1><div class="ng nh gp gr ni nj"><a rel="noopener  ugc nofollow" target="_blank" href="/️-top-7-tweaks-and-tricks-to-improve-react-performance-8957bab33266"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">⚛️提高React性能的7大调整和技巧</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">如果您还没有看到性能问题，并不意味着它们不存在😄</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">itnext.io</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kp nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://levelup.gitconnected.com/top-3-react-tricks-pros-like-to-use-to-reduce-the-size-of-component-980900370505" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">🔥前3名React技巧专家😎喜欢用来减小组件的大小</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">不要让您的React组件成为一个科学怪人</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ns l"><div class="pm l nu nv nw ns nx kp nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://levelup.gitconnected.com/building-react-micro-frontends-monorepo-with-state-management-using-nx-in-2-min-b8b04f9afee0" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">🔥使用NX在2分钟内构建⚛反应微前端Monorepo和状态管理😅</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">甚至你的祖母也可以用NX构建react微前端</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ns l"><div class="pn l nu nv nw ns nx kp nj"/></div></div></a></div></div></div>    
</body>
</html>