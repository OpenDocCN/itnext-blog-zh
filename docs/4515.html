<html>
<head>
<title>Advanced NestJS techniques — Part 1 — Custom decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级NestJS技术—第1部分—定制装饰器</h1>
<blockquote>原文：<a href="https://itnext.io/advanced-nestjs-techniques-part-1-custom-decorators-aa6d7f85c5b6?source=collection_archive---------1-----------------------#2020-07-17">https://itnext.io/advanced-nestjs-techniques-part-1-custom-decorators-aa6d7f85c5b6?source=collection_archive---------1-----------------------#2020-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e6dd9e4aabd09f3d4d454f2d5d5b582f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0RUcAMHvyQ_RZNX0_-N-Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">“和猫在一起的时间从来不会浪费。”——西格蒙德·弗洛伊德。</figcaption></figure><p id="30c8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好的，首先，一个小小的免责声明:我称这些技术为“高级”,不是因为我认为它们真的很复杂或很聪明，而是因为它们没有在官方的NestJS文档中提出，并且这种需求可能出现在中型或大型NestJS项目中。</p><p id="7fbc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">免责声明2:我本来打算把这篇文章命名为“高级NestJS技术——第1部分——控制反转”，但是IoC是一个广泛的话题，对不同的人来说，它的含义略有不同。尽管如此，下面建议的技术对我来说感觉像IoC。不同意也没关系。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="6838" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里是这样的:假设我们有一个drinks模块和一个DrinkService，它们的工作是返回饮料列表。由于某种原因，饮料可能来自不同的供应商，每个供应商都有自己的模块。OOP原则告诉我们，解决这个问题的一个方法是:</p><ul class=""><li id="83af" class="lh li iq ke b kf kg kj kk kn lj kr lk kv ll kz lm ln lo lp bi translated">声明一个DrinkProvider接口，</li><li id="2ef6" class="lh li iq ke b kf lq kj lr kn ls kr lt kv lu kz lm ln lo lp bi translated">在DrinkService上声明一个DrinkProviders数组，并为任何人提供一个向列表中添加新提供者的方法，</li><li id="aef1" class="lh li iq ke b kf lq kj lr kn ls kr lt kv lu kz lm ln lo lp bi translated">遍历注册的提供者列表，从每个提供者获取饮料，生成最终的连接列表。</li></ul><h1 id="3860" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">首次实施</h1><p id="de56" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">下面是NestJS中第一个“幼稚”的实现:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b2c0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">类似于SpiritModule，我们想象我们也有一个BeerModule，一个SoftModule，等等。为简洁起见省略。</p><p id="0f99" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有几件事应该已经让人觉得尴尬了:</p><ul class=""><li id="1b9c" class="lh li iq ke b kf kg kj kk kn lj kr lk kv ll kz lm ln lo lp bi translated">我们必须将DrinkService注入到每个DrinkProvider中，这样他们就可以注册自己。</li><li id="8ed6" class="lh li iq ke b kf lq kj lr kn ls kr lt kv lu kz lm ln lo lp bi translated">我们必须向应用程序的其余部分公开(“导出”)DrinkService，即使我们的应用程序可能只使用DrinkModule中的DrinkService。</li></ul></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="dcf5" class="lv lw iq bd lx ly ne ma mb mc nf me mf mg ng mi mj mk nh mm mn mo ni mq mr ms bi translated">丰富</h1><p id="70c4" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">为了解决这个问题，我们将更好地利用NestJS提供的<strong class="ke ir">依赖注入</strong>机制:</p><ul class=""><li id="b9cc" class="lh li iq ke b kf kg kj kk kn lj kr lk kv ll kz lm ln lo lp bi translated">我们将创建一个<strong class="ke ir">定制的类型脚本装饰器</strong>，用一个特殊的元数据来注释我们的每个饮料提供者</li><li id="20e7" class="lh li iq ke b kf lq kj lr kn ls kr lt kv lu kz lm ln lo lp bi translated">在模块初始化期间，在所有的提供者被实例化之后，我们将尝试<strong class="ke ir">在我们的NestJS应用程序中现有的所有服务中检索带注释的提供者</strong>，并在一个地方进行注册</li><li id="6937" class="lh li iq ke b kf lq kj lr kn ls kr lt kv lu kz lm ln lo lp bi translated">然后，我们将思考代码如何变得像以前一样更加解耦，以及上面提到的笨拙的部分是如何消失的。</li></ul><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4e2c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，有趣的部分发生在DrinkModule的onModuleInit方法中:<strong class="ke ir">我们使用来自NestJS核心</strong>本身的DiscoveryService来浏览我们的应用程序的所有声明的提供者，并且在Typescript的反射特性的帮助下，我们找到我们的带注释的提供者。</p><p id="9ae0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意现在SpiritModule不再需要导入DrinkModule，因此DrinkService不再需要从DrinkModule导出。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="be29" class="lv lw iq bd lx ly ne ma mb mc nf me mf mg ng mi mj mk nh mm mn mo ni mq mr ms bi translated">结论</h1><p id="7b51" class="pw-post-body-paragraph kc kd iq ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz ij bi translated">总结一些警告:</p><p id="dfd3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">像我们一样浏览提供者<em class="nj">可能</em>并不是在所有情况下都有效(cf模块使用registerAsync，提供者提供字符串注入令牌而不是类注入令牌，等等。).幸运的是，这个NPM模块<a class="ae nk" href="https://github.com/golevelup/nestjs/tree/master/packages/discovery" rel="noopener ugc nofollow" target="_blank">https://github . com/golevelup/nestjs/tree/master/packages/discovery</a>公开了一个具有更加用户友好的API的替代DiscoveryService(例如参见“providersWithMetaAtKey”方法),并处理了所有的边缘情况。</p><p id="dbfa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在某些时候，我们不得不大胆假设我们声明的decorator只用于修饰实现DrinkProvider接口的类。否则，东西会坏掉。不是在注册期间，而是在检索饮料清单时，这可能发生在很久以后。当然，所有这些都可以通过广泛的测试套件和系统的代码审查来处理；-).</p><p id="5916" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">说到测试，我把饮料服务的测试留给你。这并不是一个可以独立于NestJS框架执行的单元测试，因为我们需要NestJS来完成它的工作，以便注册提供者，等等。这也不是E2E测试。但无论如何这是个测试。</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="09b1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在这里找到完整的代码:【https://github.com/paztek/nestjs-ioc-example<a class="ae nk" href="https://github.com/paztek/nestjs-ioc-example" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>