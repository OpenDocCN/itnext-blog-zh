<html>
<head>
<title>Golang Testing — Mocking Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang测试—模拟Redis</h1>
<blockquote>原文：<a href="https://itnext.io/golang-testing-mocking-redis-b48d09386c70?source=collection_archive---------1-----------------------#2020-05-07">https://itnext.io/golang-testing-mocking-redis-b48d09386c70?source=collection_archive---------1-----------------------#2020-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7658a11429eec598aee36958728e9828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYuNX0t6BY-Aw3DRHwe2bw.jpeg"/></div></div></figure><div class=""/><p id="b132" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当测试我们的应用程序时，我们经常有很多外部依赖，并且我们经常不在有空间启动Redis、MySQL等的环境中运行我们的测试。</p><p id="95d7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我试图解决我的一个应用程序需要Redis连接的问题，但我不想在运行测试时保持Redis服务器运行，我觉得这是不必要的。</p><p id="df74" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我偶然发现了一个优雅的解决方案:【https://github.com/alicebob/miniredis<a class="ae kw" href="https://github.com/alicebob/miniredis" rel="noopener ugc nofollow" target="_blank"/></p><p id="9564" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个库在您的应用程序中构建了一个Redis兼容的服务器，当您在任何环境中运行测试时，您都可以使用它而不依赖于它。这太完美了！</p><p id="d2ec" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设在您的应用程序中，您正在使用一个<code class="fe kx ky kz la b">redisClient</code>，它在您的包范围内是全局可用的:</p><p id="2dcf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lb">在这种情况下，我们使用</em> <code class="fe kx ky kz la b"><em class="lb">github.com/go-redis/redis</em></code> <em class="lb">作为我们选择的Redis库。</em></p><pre class="lc ld le lf gt lg la lh li aw lj bi"><span id="9772" class="lk ll jb la b gy lm ln l lo lp">package main<br/><br/>import (<br/>    "log"<br/>    "github.com/go-redis/redis"<br/>)<br/><br/>var redisClient *redis.Client<br/><br/>func main() {<br/>    redisClient = newRedisClient()<br/>    <br/>    doSomeRedisStuff()<br/>}<br/><br/>func doSomeRedisStuff() bool {<br/>    _, err = redisClient.Get("data").Result()<br/>    <br/>    return err != redis.Nil<br/>}<br/><br/>func newRedisClient() *redis.Client {<br/>    redisClient := redis.NewClient(&amp;redis.Options{<br/>        Addr:     "localhost:6579",<br/>        Password: "", // no password set<br/>        DB:       0,<br/>    })<br/>}</span></pre><p id="c07a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在我们的<code class="fe kx ky kz la b">main</code>中看到的，我们正在创建一个Redis客户端并连接到一个本地服务器。</p><p id="6273" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的测试中，我们不需要真正的联系。</p><p id="33cc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们可以在测试设置中使用<code class="fe kx ky kz la b">miniredis</code>来模拟它:</p><pre class="lc ld le lf gt lg la lh li aw lj bi"><span id="e989" class="lk ll jb la b gy lm ln l lo lp">package main<br/><br/>import (<br/>    "testing"<br/>    "time"<br/>    "github.com/alicebob/miniredis"<br/>    "github.com/stretchr/testify/assert"<br/>)<br/><br/>var redisServer *miniredis.Miniredis<br/><br/>func testDoRedisStuffDataExists(t *testing.T) {<br/>    setup()<br/>    defer teardown()<br/>    <br/>    redisClient.Set("data", "something here", time.Minute)<br/>  <br/>    result := doSomeRedisStuff()<br/>  <br/>    assert.True(t, result, "We expect the 'data' to be in Redis")<br/>}<br/><br/>func testDoRedisStuffDataDoesNotExist(t *testing.T) {<br/>    setup()<br/>    defer teardown()<br/>  <br/>    result := doSomeRedisStuff()<br/>  <br/>    assert.False(t, result, "We expect the 'data' to not be in Redis")<br/>}<br/><br/>func mockRedis() *miniredis.Miniredis {<br/>    s, err := miniredis.Run()<br/><br/>    if err != nil {<br/>	panic(err)<br/>    }<br/><br/>    return s<br/>}<br/><br/>func setup() {<br/>    redisServer = mockRedis()<br/>    redisClient = redis.NewClient(&amp;redis.Options{<br/>	Addr: redisServer.Addr(),<br/>    })<br/>}<br/><br/>func teardown() {<br/>    redisServer.Close()<br/>}</span></pre><p id="6733" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，在创建模拟的“miniredis”时，我们得到了一个服务器实例，它为我们提供了必要的信息，我们可以在创建redis客户机时将这些信息传递给新的客户机选项。然后，我们可以继续使用Redis客户机，就像使用真正的Redis连接一样。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="f8c7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lb">我希望这对你有所帮助！如果您发现上述示例有任何问题，请告诉我；我没有运行它们。它们更像是一个例子。</em></p></div></div>    
</body>
</html>