<html>
<head>
<title>Node.js: Heroes of Worker Threads ― C++ Addon</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js:工作线程的英雄――c++插件</h1>
<blockquote>原文：<a href="https://itnext.io/node-js-heroes-of-worker-threads-c-addon-76dd11f34c33?source=collection_archive---------3-----------------------#2021-11-15">https://itnext.io/node-js-heroes-of-worker-threads-c-addon-76dd11f34c33?source=collection_archive---------3-----------------------#2021-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/e41bf478d65c97efa4596421ccfdd6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TzCSVS8CZsJep2BK5KLWfw.png"/></div></div></figure><div class=""/><h1 id="9b33" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">碑文</h1><p id="990f" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">没有哪条龙能抗拒胡扯和浪费时间试图理解它的魅力。― <em class="lu"> </em> <strong class="ky jc"> <em class="lu"> J.R.R .托尔金</em> </strong></p><h1 id="25b6" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题</h1><p id="3136" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">今天我们将尝试揭示解决JavaScript最大的问题之一――CPU密集型任务的方法。我们将分两部分进行。在第一部分中，我们将讨论并尝试使用纯CPU任务。在第二部分中——我们将尝试更多——用于前端、CPU+I/O绑定任务等的模块。</p><h1 id="5571" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">我们有什么？</h1><p id="6f8f" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Node.js有几种方法可以执行以下任务:<br/> 1。只需通过阻塞事件循环在一个进程中运行一个CPU绑定的任务。有人会注意到这个选项根本不是一个选项，但是如果流程是专门为这个任务创建的，那为什么不呢。但并不是每个人都有一对额外的内核。<br/> 2。创建单独的流程(<a class="ae lv" href="https://nodejs.org/docs/latest/api/child_process.html" rel="noopener ugc nofollow" target="_blank">子流程</a>)，在它们之间划分任务。<br/> 3。创建一个<a class="ae lv" href="https://nodejs.org/docs/latest/api/cluster.html" rel="noopener ugc nofollow" target="_blank">集群</a>，强制进程，并使它们工作。<br/> 4。使用<a class="ae lv" href="https://nodejs.org/docs/latest/api/worker_threads.html" rel="noopener ugc nofollow" target="_blank">工作线程</a>并创建一些额外的线程。<br/> 5。请C++开发人员编写一个<a class="ae lv" href="https://nodejs.org/docs/latest/api/addons.html" rel="noopener ugc nofollow" target="_blank"> C++插件</a>，神秘地执行CPU绑定的任务。毕竟，我认为每个人都听过关于编译编程语言的古老传说，并且“本机”实现总是成功的(在这个短语中，世界上的某个地方应该喊React Native developer，看看他/她的应用程序的性能)。</p><p id="15ce" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在本文中，我们将不讨论这些方法的实现，因为这些方法已经在其他文章和报告中详细描述过了。</p><h1 id="db49" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">工具</h1><p id="0b18" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">作为CPU受限任务的一个例子，我们采用各种散列函数。这些工具将是一个特定模块的“本地”实现，并且是一个纯粹的js版本。配备8核英特尔酷睿i7–7700 HQ CPU(2.80 GHz)的硬件</p><h1 id="7352" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">会有好玩的吗？</h1><p id="dee9" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">后者提出了如何传达研究的想法、过程和结果的问题……<br/>为此，我选择了1999年最流行、最酷、最先进的游戏……<br/>——<strong class="ky jc">《英雄无敌III》</strong></p><h1 id="6714" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">现在，让我们深入了解这个传说</h1><p id="c9e4" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们的英雄是Node.js，和任何英雄一样，他有办法。我们的英雄是强大的，胜利的，已经战胜了许多邪恶，并决定是时候摆脱最糟糕的邪恶之一——CPU绑定的任务。</p><h1 id="6f5f" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Node.js团队</h1><p id="5e46" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们的英雄必须有一个团队。那么我们要和谁较量呢？集群–7条黑龙，7个子进程–7条红龙和1条红龙，名为JS，因为他总是只向敌人发射一股火焰。7条工人线程–7条年轻的绿龙。没有经历过，但是渴望战斗。<br/> 1个C++插件-1个大天使。一个经验丰富的战士，他不会透露自己力量的所有秘密，但在过去的战斗中表现得非常好。</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mb"><img src="../Images/58b6e2ef756ad1f656d3542ab7e22b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dqiG058WFOsDN90X-5hhEQ.png"/></div></div></figure><h1 id="c567" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">第一部分</h1><h2 id="7332" class="mg jz jb bd ka mh mi dn ke mj mk dp ki lh ml mm km ll mn mo kq lp mp mq ku mr bi translated">第一次战斗</h2><p id="b201" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在他的道路上的第一个恶魔是140万个字符串(骷髅步兵)，唯一能让我们打败他们的事情是尽快让他们通过<a class="ae lv" href="https://en.wikipedia.org/wiki/MurmurHash" rel="noopener ugc nofollow" target="_blank">mur hash</a>(一种适合一般基于哈希的查找的非加密哈希函数)。</p><p id="16c4" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">模块<a class="ae lv" href="https://www.npmjs.com/package/murmurhash3js" rel="noopener ugc nofollow" target="_blank"> murmurhash3js </a>将被用作纯js实现，而<a class="ae lv" href="https://www.npmjs.com/package/murmurhash-native" rel="noopener ugc nofollow" target="_blank"> murmurhash-native </a>将被用作“本地”实现。</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ms"><img src="../Images/3144d40b0f0298e06c559679497a5f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SWmHm4aRLl6yPzkgtQMyuQ.png"/></div></div></figure><p id="ab6c" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实现(JS 1进程)-没什么特别的，只是在一个循环中运行哈希函数，并计算前后的时间差:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="aa8d" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实现(子进程)–<a class="ae lv" href="https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options" rel="noopener ugc nofollow" target="_blank">产生</a>新进程，并等待所有计算完成(“关闭”事件):</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8d01" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实现(集群)–<a class="ae lv" href="https://nodejs.org/docs/latest/api/cluster.html#clusterforkenv" rel="noopener ugc nofollow" target="_blank">分支</a>几个(数量取决于CPU核心的数量)工作进程，并等待主进程收到来自它们的<a class="ae lv" href="https://nodejs.org/docs/latest/api/cluster.html#event-message" rel="noopener ugc nofollow" target="_blank">消息</a>(关于工作完成)。由于使用了流程的“消息”号:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e774" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实现(工作线程)——几乎与“集群”中的相同——我们创建几个<a class="ae lv" href="https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options" rel="noopener ugc nofollow" target="_blank">工作线程</a>，并在<a class="ae lv" href="https://nodejs.org/docs/latest/api/worker_threads.html#workerismainthread" rel="noopener ugc nofollow" target="_blank">主线程</a>中等待关于已完成作业的<a class="ae lv" href="https://nodejs.org/docs/latest/api/worker_threads.html#event-message" rel="noopener ugc nofollow" target="_blank">消息</a>:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e4a0" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实现(C++插件)-只需在主线程中使用C++插件(模块)(作为简单的JS实现):</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0a33" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">…和“开拍！”</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/6b92cd3ac7a4b6df8d4ff40d4c9e30c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xCAPkHv_0T_wuA1kXBsiLA.gif"/></div></div></figure><p id="7ec3" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">第一场战斗的结果:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/4728d44ab9ee0dfc4b3f432f1fe3bd3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6b9C9SQ0jojFDcEi2UGfOw.png"/></div></div></figure><p id="e196" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">正如我们所见，C++ Addon是这种情况下最快的实现。子进程/集群/工作线程显示几乎相同的结果。</p><p id="123c" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky jc">第二轮</strong></p><p id="d8b1" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">他道路上的下一个恶魔是140个字符串(骨骼龙)，我们只能用<a class="ae lv" href="https://en.wikipedia.org/wiki/Bcrypt" rel="noopener ugc nofollow" target="_blank"> Bcrypt </a>(目前是<strong class="ky jc">sync</strong>)——一个基于<a class="ae lv" href="https://en.wikipedia.org/wiki/Blowfish_(cipher)" rel="noopener ugc nofollow" target="_blank"> Blowfish </a>密码的密码散列函数来击败它们。这是OpenBSD的默认密码散列算法，也是一些Linux发行版的默认密码散列算法。</p><p id="4cba" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实现与Murmurhash完全相同，只是模块不同― <a class="ae lv" href="https://www.npmjs.com/package/bcryptjs" rel="noopener ugc nofollow" target="_blank"> bcryptjs </a>和<a class="ae lv" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank"> bcrypt </a>。</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mx"><img src="../Images/3ea0c501c3dc29aaf56c3b159ef2a819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UH2ISO-bRkZUQ90Y8-WP_Q.png"/></div></div></figure><p id="e257" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实施示例:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/e88ac099f0b9e800eb74dc523b0fa3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Cy4zREXa81FsJLaHQQaAeQ.gif"/></div></div></figure><p id="e984" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">第二轮结果:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/72030ff0c7f02185b455576ece6cfaef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ueneJW3DDQQLvHGz6eRGOA.png"/></div></div></figure><p id="d639" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在这种情况下,( sync)最佳选择是划分任务并并行执行，以便子进程/集群/工作线程尽最大努力。</p><p id="2378" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky jc">最后一战</strong></p><p id="bac4" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">下一个恶魔是140字符串(更强大的骨骼龙),我们可以打败他们，但这次只能用<strong class="ky jc"> async </strong> Bcrypt。实现和之前的战斗完全一样(模块也是)。</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mz"><img src="../Images/4f1ea3d1386a4cd8cbe3e319387208be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ndSxMuMilVmz2fA-Oqwag.png"/></div></div></figure><p id="fc1f" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实施示例:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/6c2334875af9631d78295dabd70fa814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ub7uUcKZrN9MCXChvqx0eA.gif"/></div></div></figure><p id="7b24" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">决赛结果:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/5b9f34ce14f6e44a83afb540705ab746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6NSFisc9fiJuGr1Ijd5xQ.png"/></div></div></figure><p id="14f6" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们没有阻止事件循环并使用UV线程池，所以在这种情况下<br/> C++插件再次出现。</p><p id="ac9c" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">…以及之前所有战斗的结果:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/7b866647a35203e8d56c4228e5323ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTNgBUbzND1Y6uBc6JPLew.png"/></div></div></figure><p id="45ba" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">需要提一下，我们的大天使有一个秘密武器。有了它的帮助，他可以更有效地战斗。它是UV线程池(<a class="ae lv" href="https://nodejs.org/api/cli.html#uv_threadpool_sizesize" rel="noopener ugc nofollow" target="_blank"> UV_TREADPOOL_SIZE=size </a>)中可以增加的线程数(缺省值为4)。在我们的例子中，bcrypt使用<a class="ae lv" href="https://nodejs.org/api/cli.html#cli_uv_threadpool_size_size" rel="noopener ugc nofollow" target="_blank"><strong class="ky jc">crypto . random bytes()</strong></a><strong class="ky jc"/>，因此这帮助我们将<strong class="ky jc"> bcrypt async </strong>的执行时间减少了近2倍(通过设置8)。</p><h1 id="9391" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">第二部分</h1><h2 id="40d3" class="mg jz jb bd ka mh mi dn ke mj mk dp ki lh ml mm km ll mn mo kq lp mp mq ku mr bi translated">氩2堡垒</h2><p id="0dce" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们史诗故事的第二部分从名为"<a class="ae lv" href="https://en.wikipedia.org/wiki/Argon2" rel="noopener ugc nofollow" target="_blank"> Argon 2 </a>"的城堡附近开始。它是由一个密钥派生函数命名的，该函数在2015年7月的密码哈希比赛中获胜，该比赛有3个版本:<br/> - Argon2d最大限度地抵抗GPU破解攻击。它以依赖密码的顺序访问存储器阵列，这降低了<a class="ae lv" href="https://en.wikipedia.org/wiki/Time%E2%80%93memory_trade-off" rel="noopener ugc nofollow" target="_blank">时间-存储器权衡</a> (TMTO)攻击的可能性，但是引入了可能的<a class="ae lv" href="https://en.wikipedia.org/wiki/Side-channel_attack" rel="noopener ugc nofollow" target="_blank">旁路攻击</a>。<br/> - Argon2i优化抗侧信道攻击。它以与密码无关的顺序访问存储器阵列。<br/> - Argon2id是混动版。它遵循Argon2i方法的第一个半遍内存和Argon2d方法的后续遍。</p><p id="6dfa" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">Node.js与团队需要使用<a class="ae lv" href="https://www.npmjs.com/package/argon2-browser" rel="noopener ugc nofollow" target="_blank"> argon2-browser </a> (js)和<a class="ae lv" href="https://www.npmjs.com/package/hash-wasm" rel="noopener ugc nofollow" target="_blank"> hash-wasm </a>(原生)模块拿下这个堡垒。</p><p id="fb7a" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实施示例:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/a54336185d58d8c2fceb95f41dbc89f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NllUfu5Gvjx3qzEoRm1W4Q.gif"/></div></div></figure><p id="5d58" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">战斗结果:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/dfeba6fb7c788b31fabea0fcc8520fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*4aYtkuHEZym8WNri4ltQrA.png"/></div></figure><p id="b537" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">C++ Addon再次处于领先地位，是纯CPU绑定任务的最佳选择。</p><p id="b45e" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky jc">重建城堡</strong></p><p id="194e" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">现在所有的战斗都结束了。我们需要重建这座城市，与当地居民交朋友。为此，我们将阅读所有的法律和传统。幸运的是，所有内容都是在7个文件中的<strong class="ky jc"> xlsx </strong>格式，每个文件有5000行(同样，js <a class="ae lv" href="https://www.npmjs.com/package/xlsx" rel="noopener ugc nofollow" target="_blank"> xlsx </a>和本机<a class="ae lv" href="https://www.npmjs.com/package/xlsx-util" rel="noopener ugc nofollow" target="_blank"> xlsx-util </a>模块将被用作“神奇阅读器”)。</p><p id="694c" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实现示例(读取并解析文件):</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/4a969ae8190533bca199642ff304b0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YU2V8VzA1VPmIibeqzj5hw.gif"/></div></div></figure><p id="2397" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">读取和解析的结果:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d9b79ded5944d3cc58136a8e2e85f3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*16O1QQk_EEWzwRi3tiT8Wg.png"/></div></figure><p id="d7f8" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在这种情况下，我们混合了I/O(读取文件)和CPU(解析)密集型任务。由于第二个任务的组件，C++插件使这个过程更快。</p><p id="2f5b" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky jc">变革的时间到了</strong></p><p id="d767" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">现在我们终于可以改变旧的坏法律，重建一个新的繁荣的社会。为此，我们将使用<a class="ae lv" href="https://jsonnet.org" rel="noopener ugc nofollow" target="_blank"> <strong class="ky jc"> jsonnet </strong> </a>模板语言。它帮助我们:<br/> -生成配置数据。<br/> -管理扩展配置。没有副作用。<br/> -组织、简化和统一我们的代码。</p><p id="5219" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">模块<a class="ae lv" href="https://www.npmjs.com/package/@rbicker/jsonnet" rel="noopener ugc nofollow" target="_blank"> @rbicker/jsonnet </a> (js)和<a class="ae lv" href="https://www.npmjs.com/package/@unboundedsystems/jsonnet" rel="noopener ugc nofollow" target="_blank">@ unboundsystems/jsonnet</a>(原生)。</p><p id="c5e2" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实施示例:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/6ea27e41c6df1523a8b5a5153f906e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NGYP2r0KBFh-O2JU5BsFMA.gif"/></div></div></figure><p id="4f00" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">有点奇怪的结果，但它主要取决于模块的内部实现。<strong class="ky jc"> <br/> </strong>所以无论如何我们都有最后的结果:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/388f18ea8b1a436358251b9262017cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*NK9VKAu-LlwXIoYg-mZIdA.png"/></div></figure><p id="d942" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">第二部分的最终结果:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/ebb1d609d36d2cc02c5c835243a175d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQB2kmxSnqoIsdJSWSv5eg.png"/></div></div></figure><h1 id="d810" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="513b" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">从我们的研究中，我们可以得出以下结论:</p><ol class=""><li id="37c5" class="ng nh jb ky b kz lw ld lx lh ni ll nj lp nk lt nl nm nn no bi translated">负责任地选择模块。阅读库的代码，并考虑您的应用程序将被部署的环境。模块受欢迎程度并不是最重要的标准。</li><li id="63ee" class="ng nh jb ky b kz np ld nq lh nr ll ns lp nt lt nl nm nn no bi translated">с根据具体任务选择解决方案。子进程、集群、工作线程——这些工具都有自己的特点和使用领域。</li><li id="2d1d" class="ng nh jb ky b kz np ld nq lh nr ll ns lp nt lt nl nm nn no bi translated">不要忘记其他可以帮助解决一些任务的编程语言(<a class="ae lv" href="https://nodejs.org/docs/latest/api/addons.html" rel="noopener ugc nofollow" target="_blank"> C++插件</a>、<a class="ae lv" href="https://nodejs.org/docs/latest/api/n-api.html" rel="noopener ugc nofollow" target="_blank"> Node-API </a>、<a class="ae lv" href="https://github.com/neon-bindings/neon" rel="noopener ugc nofollow" target="_blank"> Neon库</a>)。</li><li id="66d6" class="ng nh jb ky b kz np ld nq lh nr ll ns lp nt lt nl nm nn no bi translated">规划您的资源利用率(CPU或GPU核心的数量)。</li><li id="19ac" class="ng nh jb ky b kz np ld nq lh nr ll ns lp nt lt nl nm nn no bi translated">做出合理的架构决策(实现自己的线程池，在单独的微服务中运行CPU受限的任务等)。</li><li id="0ff5" class="ng nh jb ky b kz np ld nq lh nr ll ns lp nt lt nl nm nn no bi translated">找到可能的最佳组合(C/C++/Rust/Go可以不在主线程中使用，并且事件循环不会被阻塞),您将得到如下结果:</li></ol><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/d0b01c9188b83af4ac15854c8e3d3ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tg34JCXA5zRc-JePlMGU5w.png"/></div></div></figure><p id="5cd7" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">感谢阅读。<br/>希望你喜欢这个史诗般的故事，并感受到自己是传奇的一部分。<br/>请鼓掌跟我来，以免错过新文章。</p><p id="4cc2" class="pw-post-body-paragraph kw kx jb ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">要了解更多信息并有可能通过自己运行脚本来检查结果，请访问github repository。</p><div class="ip iq gp gr ir nv"><a href="https://github.com/novokhatskyioleksii/WorkerThreadsvsAddons" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jc gy z fp oa fr fs ob fu fw ja bi translated">novokhatskyioleksii/工人线程</h2></div><div class="oc l"><div class="od l oe of og oc oh ix nv"/></div></div></a></div></div></div>    
</body>
</html>