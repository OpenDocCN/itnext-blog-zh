<html>
<head>
<title>Golang Generics For Non-Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向非初学者的Golang泛型</h1>
<blockquote>原文：<a href="https://itnext.io/golang-generics-for-non-beginners-6ca7a4716aa9?source=collection_archive---------1-----------------------#2022-06-17">https://itnext.io/golang-generics-for-non-beginners-6ca7a4716aa9?source=collection_archive---------1-----------------------#2022-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ea5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">跟上Go中泛型的速度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20b55ee107268d2a10a2af8b8e93d97a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZpBKLmHGKa0Rad_WBMkew.jpeg"/></div></div></figure><p id="8652" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">在这个故事中，我不打算教你泛型，而是假设你已经了解泛型、参数化类型或基于模板的编程。</p><p id="b830" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这展示了Go泛型的基础。类型参数受接口约束。这意味着您可以要求您的类型参数<code class="fe lz ma mb mc b">T</code>实现某些方法或者属于某些类型。这里我们指定接口<code class="fe lz ma mb mc b">Number</code>匹配任何一个<code class="fe lz ma mb mc b">int</code>、<code class="fe lz ma mb mc b">int64</code>或<code class="fe lz ma mb mc b">float64</code>。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="513c" class="mh mi it mc b gy mj mk l ml mm">type Number interface {<br/>    int | int64 | float64<br/>}<br/><br/>func Sum[T Number](numbers []T) T {<br/>    var total T<br/>    for _, x := range numbers {<br/>        total += x<br/>    }<br/>    return total<br/>}</span></pre><p id="71eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在<a class="ae mn" href="https://go.dev/play/p/TSQh9jS1XNf" rel="noopener ugc nofollow" target="_blank"> Go游乐场</a>试试这个例子。</p><h2 id="4ed0" class="mh mi it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated">泛型类型</h2><p id="ff5f" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">需要注意的是，在定义参数化类型时，我们添加的方法不能引入新的类型参数。它们只能使用在类型定义中定义的类型。因此，你会注意到对于<code class="fe lz ma mb mc b">Push</code>和<code class="fe lz ma mb mc b">Pop</code>，我们没有指定对<code class="fe lz ma mb mc b">T</code>的约束。事实上，在方法定义中没有任何东西暗示<code class="fe lz ma mb mc b">T</code>是一个类型参数。相反，Go从类型定义中获取知识。这是一个值得注意的限制。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="4a8c" class="mh mi it mc b gy mj mk l ml mm">type Stack[T any] struct {<br/>	items []T<br/>}<br/><br/>func (stack *Stack[T]) Push(value T) {<br/>	stack.items = append(stack.items, value)<br/>}<br/><br/>func (stack *Stack[T]) Pop() {<br/>	n := len(stack.items)<br/>	if n &lt;= 0 {<br/>		panic("Cannot pop an empty stack!")<br/>	}<br/>	stack.items = stack.items[:n-1]<br/>}</span></pre><h2 id="3045" class="mh mi it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated">预先打包的约束</h2><p id="904f" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">在我们的第一个例子中，我们定义了自己的<code class="fe lz ma mb mc b">Number</code>接口，但是您不必这样做。golang.org/x/exp/constraints T21软件包提供了大量最有用的约束。以下是约束包中定义的一些接口:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="0424" class="mh mi it mc b gy mj mk l ml mm">type Signed interface {<br/>	~int | ~int8 | ~int16 | ~int32 | ~int64<br/>}<br/><br/>type Unsigned interface {<br/>	~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr<br/>}<br/><br/>type Integer interface {<br/>	Signed | Unsigned<br/>}<br/><br/>type Float interface {<br/>	~float32 | ~float64<br/>}<br/><br/>type Ordered interface {<br/>	Integer | Float | ~string<br/>}</span></pre><p id="1d2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意波浪号<code class="fe lz ma mb mc b">~</code>的用法。这是因为Go让你可以很容易地定义新类型，这些新类型是从原始类型派生出来的。例如，当编写代码来模拟火箭发射的物理过程时，我定义了千克和牛顿(力)的类型，如下所示:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="3a80" class="mh mi it mc b gy mj mk l ml mm">type Newton float64<br/>type Kg float64</span></pre><p id="9063" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您没有对<code class="fe lz ma mb mc b">Float</code>使用波浪符号<code class="fe lz ma mb mc b">~</code>，那么<code class="fe lz ma mb mc b">Newton</code>和<code class="fe lz ma mb mc b">Kg</code>将不会被视为<code class="fe lz ma mb mc b">Float</code>值，这是不切实际的。</p><p id="9f53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在二叉查找树中定义节点时，我使用了这个包中的约束。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="9a21" class="mh mi it mc b gy mj mk l ml mm">import (<br/>	"fmt"<br/>	"golang.org/x/exp/constraints"<br/>)<br/><br/>// A node in a binary tree which you can search by key<br/>type TreeNode[K constraints.Ordered, V any] struct {<br/>	Key         K<br/>	Value       V<br/>	left, right *TreeNode[K, V]<br/>}<br/><br/>// Give string representation of node in print statements<br/>func (n *TreeNode[K, V]) String() string {<br/>	return fmt.Sprintf("TreeNode(%v, %v)", n.Key, n.Value)<br/>}<br/><br/>// Insert node n into a leaf underneath parent node.<br/>// Position will be determined based on value of key<br/>func (parent *TreeNode[K, V]) Insert(n *TreeNode[K, V]) {<br/>	if n.Key &gt;= parent.Key {<br/>		if parent.right == nil {<br/>			parent.right = n<br/>		} else {<br/>			parent.right.Insert(n)<br/>		}<br/>	} else {<br/>		if parent.left == nil {<br/>			parent.left = n<br/>		} else {<br/>			parent.left.Insert(n)<br/>		}<br/>	}<br/>}</span></pre><h1 id="a759" class="nk mi it bd mo nl nm nn mr no np nq mu jz nr ka mx kc ns kd na kf nt kg nd nu bi translated">其他与Golang相关的故事</h1><p id="6847" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">如果你有兴趣阅读更多关于围棋的文章，我已经写了一些关于围棋的文章:</p><ul class=""><li id="8cb0" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated">面向Go程序员的1.18版本更新——阐明自Go获得模块以来Go中发生的变化，以及涵盖您在远离Go编程时经常忘记的内容。</li><li id="9bf9" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated"><a class="ae mn" href="https://erik-engheim.medium.com/is-go-a-systems-programming-language-c243c80eb6f9" rel="noopener">Go是系统编程语言吗？</a> —有了自动内存管理，就能成为真正的系统编程语言。是的，这篇文章解释了为什么。</li><li id="e825" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated"><a class="ae mn" rel="noopener ugc nofollow" target="_blank" href="/go-does-not-need-a-java-style-gc-ac99b8d26c60"> Go不需要Java风格的GC </a> — Go的垃圾收集方式与Java和C#截然不同。下面我们来看看为什么Go比Java拥有更简单的垃圾收集器。</li><li id="062d" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">Go比Java更面向对象</li><li id="d063" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">让Go变得简单——记录我在奥斯陆NDC会议上的一次演讲。</li></ul></div></div>    
</body>
</html>