<html>
<head>
<title>Announcing new and simple state manager “Exome”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">宣布新的和简单的状态管理器“Exome”</h1>
<blockquote>原文：<a href="https://itnext.io/announcing-new-and-simple-state-manager-exome-78b5874325c1?source=collection_archive---------3-----------------------#2021-04-17">https://itnext.io/announcing-new-and-simple-state-manager-exome-78b5874325c1?source=collection_archive---------3-----------------------#2021-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f27a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">TLDR:我创建了名为<a class="ae kf" href="https://github.com/Marcisbee/exome" rel="noopener ugc nofollow" target="_blank"> Exome </a>的新州立图书馆(与React一起工作，还有一个Vue的PR(对不起，听起来像口袋妖怪))。结束了。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/301531041f5a0d0b15ae3277fdd1f43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qk7CzsFxmycptyIDz8ktnQ.png"/></div></div></figure><h1 id="91b9" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">介绍</h1><p id="1747" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">让我先自我介绍一下。从我记事起，我就是一名前端开发人员。甚至在jQuery占主导地位之前。所以我见过很多，从简单的JS库到非常复杂的JS库，再到简单的JS库等等。当我一天之内开始学习Redux、NgRx和Vuex时，这是一座很高的山，一开始总是希望更容易一些。更容易，就像一个简单的对象更容易陈述。</p><p id="0a97" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">因此，几年前，我就开始尝试各种不同的想法，希望我理想中的国家管理人员看起来和感觉起来如何。我记得在随机的时间有随机的想法，然后把它们写在笔记里。我从来没有用它们做过任何事情，因为它们中没有一个真的感觉足够好。</p><p id="457b" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">直到现在，当我开始一个新项目时，使用深度嵌套的树结构是必须的。因为这是Redux(我可以说是整个flux架构)的核心问题之一，所以我使用了Pmndrs的库<code class="fe ml mm mn mo b"><a class="ae kf" href="https://github.com/pmndrs/valtio" rel="noopener ugc nofollow" target="_blank">valtio</a></code>。一开始很棒，但后来我开始看到代码中一片混乱，我编造的动作和选择器越来越没有意义。从状态中选择的内容和更新的内容之间的界限变得模糊起来。所以我知道我只有一个选择，最终找出我梦想中的州经理。</p><h1 id="8f61" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">从创意到图书馆</h1><p id="36a0" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">我为我想要的州经理设定了几个目标:</p><ol class=""><li id="0dd0" class="mp mq iq lm b ln mg lq mh lt mr lx ms mb mt mf mu mv mw mx bi translated">必须有动作(从某种意义上说，这是修改状态的唯一方法)；</li><li id="c33a" class="mp mq iq lm b ln my lq mz lt na lx nb mb nc mf mu mv mw mx bi translated">必须与Redux Devtools集成，并立即看到深度嵌套的对象，而不是通过点击树来找到确切的一个我正在寻找；</li><li id="a28e" class="mp mq iq lm b ln my lq mz lt na lx nb mb nc mf mu mv mw mx bi translated">必须通过TypeScript键入，我的意思是当处理数据时，必须有一些保护措施，当然还有那可爱的自动完成功能；</li><li id="8fa3" class="mp mq iq lm b ln my lq mz lt na lx nb mb nc mf mu mv mw mx bi translated">必须能够作为一个字符串保存和加载(因为在我的情况下，我需要一种方法来保存文件中的状态和恢复它)；</li><li id="8479" class="mp mq iq lm b ln my lq mz lt na lx nb mb nc mf mu mv mw mx bi translated">必须非常简单，这样任何初级开发人员都可以立即获得生产力；</li><li id="cf46" class="mp mq iq lm b ln my lq mz lt na lx nb mb nc mf mu mv mw mx bi translated">不得成为视图渲染器的瓶颈(必须是高性能的)。</li></ol><p id="2a87" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">所以这些是我最初的目标，在一个晚上我就想出了<code class="fe ml mm mn mo b"><a class="ae kf" href="https://github.com/Marcisbee/exome" rel="noopener ugc nofollow" target="_blank">Exome</a></code>并开发了一个原型。我非常喜欢它，所以我决定把它开源。它真的达到了我设定的所有目标，甚至更多。唯一的问题是<a class="ae kf" href="https://caniuse.com/proxy" rel="noopener ugc nofollow" target="_blank">不支持IE11 </a>，因为它使用代理。但对我来说，这无关紧要。</p><p id="5f16" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated"><strong class="lm ir">更新</strong>:现在<a class="ae kf" href="https://github.com/Marcisbee/exome#ie-support" rel="noopener ugc nofollow" target="_blank">支持IE11 </a>！🎉</p><h1 id="14ed" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">例子</h1><p id="6ca1" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">首先，这里有一个基本的计数器示例(单击number使其递增)。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="055c" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">就是这样，没有提供者，没有上下文，没有样板文件。Store只是一个类。属性是状态值，方法是动作。每当调用动作时，状态被更新，并且有线视图组件(通过<code class="fe ml mm mn mo b">useStore</code>)被呈现。它只更新那些在<code class="fe ml mm mn mo b">useStore</code>钩子中使用特定Exome实例的组件。就这么简单。</p><p id="6a7f" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">Ok大家可以做一个反例。我的目标中嵌套很深的树的部分呢？啊，好问题。为此，我举了一个简单的路由器例子。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0169" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">这是一个更复杂的问题。我想在这里演示一下，我们的商店可以有多个选项卡，这些选项卡也可以有多个项目。所以这是一棵嵌套的树。只要通过<code class="fe ml mm mn mo b">useStore</code>传递子Exome实例，子组件就会被连接起来。</p><h2 id="5f8d" class="nf kt iq bd ku ng nh dn ky ni nj dp lc lt nk nl le lx nm nn lg mb no np li nq bi translated">开发工具</h2><p id="7aaf" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">使用Redux Devtools检查Exome状态也很容易。没有必要深入挖掘状态树来找到你正在寻找的外显子组。但是，如果你想看到整个树，这也是可行的(所有Exome的孩子都可以在完整的树视图中查看)。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/91fdef3d70280589a4d34704693b0998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkoYissBpbKxGmiMwYb-eg.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">Redux Devtools中探索的Exome状态</figcaption></figure><p id="c031" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated"><em class="nw">注意:由于devtools有</em> <a class="ae kf" href="https://github.com/zalmoxisus/redux-devtools-extension/issues/737" rel="noopener ugc nofollow" target="_blank"> <em class="nw">怪异的bug</em></a><em class="nw">当使用</em> <code class="fe ml mm mn mo b"><em class="nw">serializedType</em></code> <em class="nw">时，每个Exome都会有</em> <code class="fe ml mm mn mo b"><em class="nw">$$exome_id</em></code> <em class="nw">直到那些bug被解决。</em></p><p id="517c" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">保存和加载状态在API文档(【https://github.com/Marcisbee/exome#savestate】T21)中有详细描述。</p><h2 id="ea5d" class="nf kt iq bd ku ng nh dn ky ni nj dp lc lt nk nl le lx nm nn lg mb no np li nq bi translated">表演</h2><p id="0bb1" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">太棒了！并且随着库的成熟会越来越优化。</p><p id="32ec" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">为了感受这个库的性能，我创建了一个<a class="ae kf" href="https://github.com/Marcisbee/exome/tree/main/benchmark#benchmarks" rel="noopener ugc nofollow" target="_blank">基准</a>(非常非常原始的基准)。结果相当不错，事实上Exome似乎是我测试过的最快的库(至少在我的机器上——Macbook Pro 2020 M1)。结果如下:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/ffe9fdc1f68068de56bb2599a0b30c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*e-Dyk7YEyiNuZwVFMo0wPg.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">渲染组件基准</figcaption></figure><p id="eeb5" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">这是React中的一个简单反例，在第一次基准测试中被渲染。在第二秒，一个计数增加，并通过视图更新呈现。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/97005570771bbcdb98bdb7ee13a9053c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*bCKOoKVCAnuYfBOZqA7R0w.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">增量行动基准</figcaption></figure><p id="2de4" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">请注意，这些基准测试并不是要让任何库看起来很糟糕(事实上它们都非常棒)。主要目的是了解Exome在性能方面的情况，以及在哪些方面以及如何改进它。我知道这些是非常原始的基准，但我真的不想花很多时间为每个商店创建真实世界的应用程序。也许将来吧。</p><h2 id="a1b3" class="nf kt iq bd ku ng nh dn ky ni nj dp lc lt nk nl le lx nm nn lg mb no np li nq bi translated">结论</h2><p id="f071" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">Exome还有更多我们没有探究的额外好处，但大多数都在<a class="ae kf" href="https://github.com/Marcisbee/exome#readme" rel="noopener ugc nofollow" target="_blank"> readme </a>中有解释。</p><p id="aa2b" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">最令人兴奋的是，微froontends之间可以共享单个状态。我创建了一个<a class="ae kf" href="https://codesandbox.io/s/vue-exome-lchcp?file=/src/App.vue" rel="noopener ugc nofollow" target="_blank">的小例子</a>，其中我创建了一个Exome store并将其传递给React和Vue。每当状态发生变化，它就会在所有使用Exome中间件的框架间同步。它只是工作。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ny"><img src="../Images/ae0c112d2aee42d79e5bd8c27590b547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AdwM144pGoIBwzdVMV8VnQ.gif"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">Vue计数器和React计数器共享计数器状态</figcaption></figure><p id="5b78" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">我真的对未来感到兴奋。现在我要去喂狗和测试这个库。回头见。</p><div class="nz oa gp gr ob oc"><a href="https://github.com/Marcisbee/exome" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">Marcisbee/exome</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">用于深度嵌套状态的基于代理的状态管理器😍简单:使用类作为状态🧬嵌套:轻松管理深度…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq kq oc"/></div></div></a></div></div></div>    
</body>
</html>