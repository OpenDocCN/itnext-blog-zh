<html>
<head>
<title>LINQ deferred execution explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LINQ延期执行解释道</h1>
<blockquote>原文：<a href="https://itnext.io/linq-deferred-execution-explained-2844838f83ef?source=collection_archive---------3-----------------------#2021-04-06">https://itnext.io/linq-deferred-execution-explained-2844838f83ef?source=collection_archive---------3-----------------------#2021-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/657c9cc06d547638143da89048047a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZMuZd3Bs_jPpWcMsQ7DaQ.png"/></div></div></figure><div class=""/><p id="4c74" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我看来，C#的一个——如果不是最好的——特性是LINQ，也称为“语言集成查询”。它使处理数据变得非常容易，感觉非常自然，并提供了很大的可扩展性。这是我在给定任务中切换到其他语言时经常错过的功能之一。</p><p id="0cae" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了可用性之外，Linq最大的优点之一就是出色的性能。即使是大型查询也能以相当快的速度执行。这就提出了一个问题:尽管看起来做了很多迭代，Linq怎么会这么快？</p><p id="b0ca" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这背后的秘密叫做“延期执行”。本质上，这意味着一个查询，不管有多大，只有在被明确告知要执行时才会被执行(或物化)。直到这个执行被触发的时间点，查询的枚举都没有完成，查询实际上只是一个查询。</p><p id="a58c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将解释这种延迟执行到底是如何执行的。我们走吧！</p><h1 id="8133" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">该查询</h1><p id="a891" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">解释某事的最好方法是用一个例子。让我们继续使用下面的。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="c980" class="ml la je mh b gy mm mn l mo mp">var fruitList = new List&lt;string&gt;(){ "Banana", "Apple", "Cherry", "Apricot"};</span><span id="490f" class="ml la je mh b gy mq mn l mo mp">var fruitsWithA = fruitList.Where(fruit =&gt; fruit.StartsWith('A'));</span><span id="51bc" class="ml la je mh b gy mq mn l mo mp">foreach (var fruit in fruitsWithA)<br/>{<br/>   Console.WriteLine(fruit);<br/>}</span><span id="9aae" class="ml la je mh b gy mq mn l mo mp">// Output: <br/>Apple<br/>Apricot</span></pre><p id="e54c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很简单，这里没有太多惊喜。我们已经成功地使用Linq按照给定的条件过滤了一个列表，在本例中，所有的水果都以‘A’开头。</p><p id="19f5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，在这个查询中有一个隐藏得很好的秘密。大多数人会认为，代码做了以下事情:</p><ol class=""><li id="e423" class="mr ms je kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">初始化列表</li><li id="116b" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">浏览列表，过滤所有的水果</li><li id="3f95" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">遍历过滤后的列表，打印所有的结果。</li></ol><p id="a9e5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这是一个错误的假设！相反，第二点和第三点实际上是紧密交织在一起的，而不是一个连续的事情。</p><p id="3395" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试着看看，如果我们改为运行以下经过修改的代码，会发生什么:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8212" class="ml la je mh b gy mm mn l mo mp">var fruitList = new List&lt;string&gt;(){ "Banana", "Apple", "Cherry", "Apricot"};</span><span id="dba8" class="ml la je mh b gy mq mn l mo mp">var fruitsWithA = fruitList.Where(fruit =&gt; {<br/>    Console.WriteLine("Filtering...");<br/>    return fruit.StartsWith('A');<br/>});</span><span id="58dd" class="ml la je mh b gy mq mn l mo mp">foreach (var fruit in fruitsWithA)<br/>{<br/>    Console.WriteLine(fruit);<br/>}</span><span id="ce2d" class="ml la je mh b gy mq mn l mo mp">// Output:<br/>Filtering...<br/>Filtering...<br/>Apple<br/>Filtering...<br/>Filtering...<br/>Apricot</span></pre><p id="f4c4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这很有趣，对吧？正如我提到的，过滤和迭代不是一个连续的过程，而是一起工作。这是怎么回事？</p><h1 id="ffa3" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">引擎盖下的LINQ</h1><p id="20ee" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们刚刚看到了LINQs出色性能的主要原因之一。秘密在于LINQ如何巧妙地使用<em class="nf">IEnumerator</em>&amp;<em class="nf">IEnumerable</em>组合来延迟(defer)实际执行。</p><p id="72a1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们解剖一下<em class="nf">。</em>法在哪里，看看怎么回事。的。Where方法是驻留在<em class="nf"> Where.cs </em>文件(<a class="ae ng" href="https://source.dot.net/#System.Linq/System/Linq/Where.cs,a75569430a96c893" rel="noopener ugc nofollow" target="_blank">https://source.dot.net/#System.)中的扩展方法Linq/System/Linq/Where.cs，a75569430a96c893 </a></p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/332435cb1e5123e0470a5a43968027e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_iKa2kexJW98CV2FRARsoQ.png"/></div></div></figure><p id="597a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以直接看到，LINQ对<em class="nf">IEnumerable&lt;t source&gt;</em>对象做了一些检查，然后，根据对象的类型，挑选一个合适的<em class="nf">迭代器</em>对象。</p><p id="dc5c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中，LINQ将选择<em class="nf">where list iterator&lt;t source&gt;</em>返回值。</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/b33c5221422e5bdf547f25de52d67cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0O2OdFFDAN2KzarVK4BOsA.png"/></div></div></figure><p id="6f68" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，<em class="nf">where list Iterator&lt;t source&gt;</em>实现了<em class="nf">Iterator&lt;t source&gt;</em>基类，这是许多LINQ迭代器的基类，并且实现了<em class="nf">IEnumerable&lt;t source&gt;</em>以及<em class="nf">IEnumerator&lt;t source&gt;</em>接口。如果你对这些接口的作用感到困惑，请随时查看我的上一篇帖子(<a class="ae ng" href="https://stefansch.medium.com/c-s-ienumerable-ienumerator-explained-79967f828586" rel="noopener">https://Stefan sch . medium . com/c-s-ienumerable-ienumerator-explained-79967 f 828586</a>)。</p><p id="ad80" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它还存储谓词和源，但还没有对其进行操作。这非常重要，因为这允许以延迟的方式执行。</p><p id="a5b1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然我们知道LINQ为我们提供了什么，现在关键是要认识到我们现在有一个<em class="nf">IEnumerable&lt;T&gt;T11】提供给我们，它基本上还没有做任何事情。在真正的LINQ方式中，以<em class="nf">where list iterator&lt;T&gt;</em>形式提供的<em class="nf"> IEnumerable &lt; T &gt; </em>现在可以用于进一步构建，例如通过添加<em class="nf">。Select() </em>子句，但是到目前为止，它仍然只是一个查询蓝图。</em></p><p id="3813" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到我们的查询:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="4871" class="ml la je mh b gy mm mn l mo mp">var fruitList = new List&lt;string&gt;(){ "Banana", "Apple", "Cherry", "Apricot"};</span><span id="8821" class="ml la je mh b gy mq mn l mo mp">var fruitsWithA = fruitList.Where(fruit =&gt; fruit.StartsWith('A'));</span></pre><p id="b768" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这基本上就是我们现在的处境。我们现在已经构建了一个查询蓝图，它还没有做任何事情。现在，只要我们物化查询，奇迹就会发生。</p><p id="e448" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">物化涉及到对<em class="nf"> IEnumerable &lt; T &gt; </em>的实际迭代。如果这让你困惑，我可以再一次指出我的上一篇文章。</p><p id="c2a2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于LINQ查询，物化通常伴随着类似<em class="nf">的方法。ToList()，。</em>ToArray()等。-基本上，当方法以“，”开始时。To”，它已经表明它将具体化您的查询。</p><p id="eac7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的示例中，我们使用了一个简单的foreach循环:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="efa0" class="ml la je mh b gy mm mn l mo mp">foreach (var fruit in fruitsWithA)<br/>{<br/>   Console.WriteLine(fruit);<br/>}</span></pre><p id="fb83" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将编译成:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e97d" class="ml la je mh b gy mm mn l mo mp">IEnumerator&lt;string&gt; enumerator = enumerable.GetEnumerator();<br/>try<br/>{<br/>    while (enumerator.MoveNext())<br/>    {<br/>        string current = enumerator.Current;<br/>        Console.WriteLine(current);<br/>    }<br/>}<br/>finally<br/>{<br/>    if (enumerator != null)<br/>    {<br/>        enumerator.Dispose();<br/>    }<br/>}</span></pre><p id="babd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以看到发生了什么:</p><ol class=""><li id="02b2" class="mr ms je kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">获取<em class="nf">where list iterator&lt;t source&gt;</em>的枚举器。这来自基类<em class="nf">迭代器&lt; T &gt;，</em>并取决于一些条件，如枚举状态或线程id，要么返回<em class="nf"> this，要么</em>返回迭代器<em class="nf">的克隆。</em></li><li id="9a3c" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated"><em class="nf"> MoveNext() </em>被调用。这将检索源枚举器。在我们的例子中，这将检索<em class="nf"> fruitList </em>变量的迭代器，但是对于复杂的Linq查询，这将检索链中前一个调用的枚举器。</li><li id="a1fc" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">现在，源集合被枚举。这可能是最重要的一步！对于每个源项，我们将运行谓词(就像我们在<em class="nf">中一样)。Where() </em>方法)，如果谓词匹配，设置<em class="nf"> foreach </em>生成的枚举选取的<em class="nf">当前</em>项并返回true。如果谓词不匹配，我们跳过该项。了解这里发生了什么是最重要的。请随意花几分钟来思考这个问题。把整个过程想象成一条小溪。源枚举返回一项，然后暂停。然后，我们的枚举处理该项，并将其返回给链中最顶层的调用者。一旦调用者完成了，我们将转移到下一个项目，实际上将这个调用一直传递到LINQ查询操作的源集合。理解这个“流”可以作用于许多层是很重要的。</li><li id="388c" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">对于每个匹配的条目，我们将匹配的字符串输出到控制台。</li></ol><p id="2201" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您还记得我上面的例子，现在应该很清楚为什么“Filtering…”输出与水果输出交织在一起，以及延迟执行是如何工作的——每个项目都被一个接一个地拖过执行链。</p><p id="b64e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我意识到这需要很长时间才能理解，我衷心建议您花一些时间阅读LINQ源代码，以便真正熟悉手头的整个过程，为了将重点放在最重要的事情上，我现在跳过了几行内容，您可能仍然对此感到疑惑。</p><h1 id="9d42" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="e6b4" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">了解LINQ在更大的链中是如何真正工作的，这是一项非常了不起的知识，对性能评估和优化有很大的帮助。</p><p id="915f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我必须从这篇文章中提到两件事:</p><ol class=""><li id="807d" class="mr ms je kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">想象LINQ像一个连续的溪流一样工作，而不是一个不断列举你的源序列的怪物。</li><li id="3b61" class="mr ms je kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">考虑何时何地实现你的LINQ查询。很多<em class="nf">。ToList() </em>调用会导致大量潜在的不必要的实体化。</li></ol><p id="6f4f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望我能给你们一些启发！</p></div></div>    
</body>
</html>