<html>
<head>
<title>Quick and dirty asset building with bash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用bash快速构建脏资产</h1>
<blockquote>原文：<a href="https://itnext.io/quick-and-dirty-asset-building-with-bash-d70e50bded62?source=collection_archive---------2-----------------------#2018-07-01">https://itnext.io/quick-and-dirty-asset-building-with-bash-d70e50bded62?source=collection_archive---------2-----------------------#2018-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="733b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时，您只想发布少量的JavaScript和CSS资产，这些资产是您编写的某些软件的附件(可能是用另一种语言编写的)。我所看到的JavaScript构建系统没有一个是特别简单或直观的——它们都有一个痛苦的学习曲线，和/或令人困惑的文档。其中一些要求你按照他们的<em class="kl">方式</em>工作，这可能不适合你的实践。</p><p id="2643" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章将带你经历一个快速而肮脏的方法，仅仅运送你的资产和它们所有的依赖关系。这将让你深入了解一个完整的构建系统是做什么的，同时让你可以马上开始你的项目，而不用去想那些东西。</p><p id="ec0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你真的想要一个构建系统，那么我推荐你看看这篇文章，虽然已经有几年的历史了，但是它会给你一些好的建议。</p><h1 id="f488" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">我们需要的东西</h1><p id="4b73" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们将在<a class="ae km" href="https://www.gnu.org/software/bash/" rel="noopener ugc nofollow" target="_blank"> bash </a>中这样做，如果你在一个类似unix的系统上，就可以使用它。如果你用的是Windows，我希望这些概念能被翻译，尽管你只能靠自己。</p><p id="126d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们将需要<a class="ae km" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>，它将允许我们在命令行上运行JavaScript文件。</p><p id="3a71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要一个小型的。我用的是<a class="ae km" href="http://requirejs.org/" rel="noopener ugc nofollow" target="_blank">中的<code class="fe lq lr ls lt b">r.js</code>要求</a>，但是如果你喜欢的话，你也可以用其他东西，比如<a class="ae km" href="https://github.com/mishoo/UglifyJS" rel="noopener ugc nofollow" target="_blank">丑陋的</a>。我使用<code class="fe lq lr ls lt b">r.js</code>是因为它将缩小JS和CSS(而且，它碰巧在内部使用了uglify)。</p><h1 id="659d" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">剧本</h1><p id="490e" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">让我们按照脚本的方式进行操作，并在操作过程中查看每一部分。</p><p id="6058" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，声明这是一个bash脚本，并设置指向Node和<code class="fe lq lr ls lt b">r.js</code>实例的变量:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="bbbd" class="mc ko iq lt b gy md me l mf mg">#!/usr/bin/env bash<br/><em class="kl"><br/></em>NODEJS="nodejs"<br/>R="/path/to/r.js"</span></pre><p id="6a45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来声明一些我们将在接下来的脚本中使用几次的便利变量。这让我们有机会思考什么是输入和输出:</p><ul class=""><li id="1d55" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">一个输出目录，所有已编译的资源都将在这里结束</li><li id="6e27" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">您的工作代码和CSS的源目录</li><li id="55cf" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">你自己的代码和CSS编译后的文件名</li><li id="a220" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">代码依赖项的JS和CSS包的文件名</li><li id="3d69" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">记录一些构建信息的文件(不是必需的，但是很好的做法)</li></ul><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="a2a0" class="mc ko iq lt b gy md me l mf mg">OUT="release"<br/>SRC="src"<br/>COMPILED_JS=$OUT/myapp.min.js<br/>DEPENDENCIES_JS=$OUT/myapp.dependencies.js<br/>COMPILED_CSS=$OUT/myapp.min.css<br/>DEPENDENCIES_CSS=$OUT/myapp.dependencies.css<br/>BUILD_INFO=$OUT/build.txt</span></pre><p id="98fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的构建将分两步进行:</p><ol class=""><li id="4b50" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mv mn mo mp bi translated">个人资产的缩减</li><li id="d373" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mv mn mo mp bi translated">所有资产的串联</li></ol><p id="ef16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这种两阶段方法，我们将需要两个中间暂存区，在连接之前存储精简的代码:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="7e1a" class="mc ko iq lt b gy md me l mf mg">MINIFIED_JS=$OUT/minified_js<br/>MINIFIED_CSS=$OUT/minified_css</span></pre><p id="e996" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要开始真正的工作，从清除任何旧的构建，并为新的构建重置我们的目录结构这一枯燥但必要的步骤开始:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="2224" class="mc ko iq lt b gy md me l mf mg">rm -r $OUT<br/>mkdir $OUT<br/>mkdir $MINIFIED_JS<br/>mkdir $MINIFIED_CSS</span></pre><h2 id="f68b" class="mc ko iq bd kp mw mx dn kt my mz dp kx jy na nb lb kc nc nd lf kg ne nf lj ng bi translated">构建项目JavaScript源代码</h2><p id="21e8" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">可能最有趣的一点是构建您编写的实际JS。首先，我们将整个JS树编译到上面创建的<code class="fe lq lr ls lt b">MINIFIED_JS</code>目录中:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="7622" class="mc ko iq lt b gy md me l mf mg">$NODEJS $R -o appDir=$SRC/js baseDir=. dir=$MINIFIED_JS</span></pre><p id="f8c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个命令需要一些解包。首先，变量<code class="fe lq lr ls lt b">$NODEJS</code>和<code class="fe lq lr ls lt b">$R</code>指向我们的节点可执行文件和我们的<code class="fe lq lr ls lt b">r.js</code>文件，它们只是要求节点执行那个脚本。<code class="fe lq lr ls lt b">r.js</code>然后取3个参数，前缀为<code class="fe lq lr ls lt b">-o</code>:</p><ul class=""><li id="9f57" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe lq lr ls lt b">appDir</code> —您的JavaScript的源目录</li><li id="edbe" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe lq lr ls lt b">baseDir</code> —指定源的基目录，应该用<code class="fe lq lr ls lt b">.</code>设置为当前目录。</li><li id="9e3a" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe lq lr ls lt b">dir</code> —精简代码的输出目录</li></ul><p id="889c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当这个命令运行时，整个树将被遍历，所有文件被单独缩小，并放入<code class="fe lq lr ls lt b">dir</code>中的一个相同的树结构中。</p><p id="4094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这个过程没有连接所有这些文件，我们需要自己做，这个过程冗长得令人讨厌。</p><p id="e206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将所有的源文件按照正确的顺序显式地<code class="fe lq lr ls lt b">cat</code>放入最终的<code class="fe lq lr ls lt b">COMPILED_JS</code>文件中，这是根据它们之间的相互依赖关系(依赖关系在列表中的位置高于依赖关系)，因此:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="79df" class="mc ko iq lt b gy md me l mf mg">cat $MINIFIED_JS/myapp.js <em class="kl">&lt;</em>(echo) \<br/>    $MINIFIED_JS/extension.js <em class="kl">&lt;</em>(echo) \<br/>    $MINIFIED_JS/custom.js <em class="kl">&lt;</em>(echo) \<br/>    <em class="kl">&gt; </em>$COMPILED_JS</span></pre><p id="11c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你已经有了你写的JS文件，并且保存在一个文件中。</p><h2 id="5b49" class="mc ko iq bd kp mw mx dn kt my mz dp kx jy na nb lb kc nc nd lf kg ne nf lj ng bi translated">组装JavaScript依赖项</h2><p id="89d8" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">您的项目可能依赖于一些外部依赖项。例如，如果你像我一样，你将使用<a class="ae km" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>，也许还有<a class="ae km" href="http://www.chartjs.org/" rel="noopener ugc nofollow" target="_blank"> ChartJS </a>，如果所有这些依赖项都可以在一个包中交付给用户，那将会很方便。我们可以使用<code class="fe lq lr ls lt b">cat</code>以与上面完全相同的方式来完成:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="7399" class="mc ko iq lt b gy md me l mf mg">cat /path/to/jquery-1.12.4.min.js <em class="kl">&lt;</em>(echo) \<br/>    /path/to/Chart.min.js <em class="kl">&lt;</em>(echo) \<br/>    <em class="kl">&gt; $</em>DEPENDENCIES_JS</span></pre><p id="08d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们并没有试图缩小这些资产——我们已经在使用那些缩小版本的项目了。</p><h2 id="7f8f" class="mc ko iq bd kp mw mx dn kt my mz dp kx jy na nb lb kc nc nd lf kg ne nf lj ng bi translated">构建项目CSS</h2><p id="c960" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">在<code class="fe lq lr ls lt b">r.js</code>中，CSS编译的工作方式与JS编译略有不同。例如，由于某种原因，你不能缩小整个树，你必须一个文件一个文件地缩小。我们处理每个文件的命令看起来像这样:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="3c55" class="mc ko iq lt b gy md me l mf mg">$NODEJS $R -o cssIn=$SRC/css/myapp.css out=$MINIFIED_CSS/myapp.css baseUrl=.</span></pre><p id="4fb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再次通过Node执行<code class="fe lq lr ls lt b">r.js</code>脚本，这次我们的参数是:</p><ul class=""><li id="6da9" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe lq lr ls lt b">cssIn</code> —要缩小的CSS文件</li><li id="65f6" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe lq lr ls lt b">out</code> —结果输出文件</li><li id="cc2e" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe lq lr ls lt b">baseUrl</code> —任何URL都将从其展开的基本URL。我们可以在这里使用<code class="fe lq lr ls lt b">.</code>。</li></ul><p id="034d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，和以前一样，只需<code class="fe lq lr ls lt b">cat</code>将所有生成的CSS文件放在一起:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="412a" class="mc ko iq lt b gy md me l mf mg">cat $MINIFIED_CSS/myapp.css <em class="kl">&lt;</em>(echo) \<br/>    $MINIFIED_CSS/theme.css &lt;(echo) \<br/>    <em class="kl">&gt; </em>$COMPILED_CSS</span></pre><h2 id="dd65" class="mc ko iq bd kp mw mx dn kt my mz dp kx jy na nb lb kc nc nd lf kg ne nf lj ng bi translated">组装CSS依赖项</h2><p id="2c5e" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">就像JS一样，您可能有CSS依赖项(比如<a class="ae km" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>)，并且您会希望像捆绑JS依赖项一样捆绑它们。同样，这只是<code class="fe lq lr ls lt b">cat</code>(确保您的文件处于正确的顺序):</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="0dc1" class="mc ko iq lt b gy md me l mf mg">cat /path/to/bootstrap.min.css <em class="kl">&lt;</em>(echo) \<br/>    /path/to/other.min.css &lt;(echo) \<br/>    &gt; $DEPENDENCIES_CSS</span></pre><h2 id="499d" class="mc ko iq bd kp mw mx dn kt my mz dp kx jy na nb lb kc nc nd lf kg ne nf lj ng bi translated">写一些构建信息</h2><p id="059c" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们已经完成了构建的实际重要部分，但是记住您最后一次运行您的构建总是一个好主意，特别是如果您正在为发布而构建。我们可以编写一个非常快速的构建信息文件，如下所示:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="4b06" class="mc ko iq lt b gy md me l mf mg">echo "Build $(date -u +"%Y-%m-%dT%H:%M:%SZ")" <em class="kl">&gt; </em>$BUILD_INFO</span></pre><p id="248c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将在包含构建时间戳的<code class="fe lq lr ls lt b">release</code>目录的根目录中输出我们的<code class="fe lq lr ls lt b">build.txt</code>文件。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="48b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本质上，JavaScript(和CSS)资产构建系统本质上是在做这个脚本所做的事情，尽管复杂程度更高。例如，一些工具将支持将您的JavaScript编译成ES的早期版本，这种方法不包括在内。其他工具将监视您的源目录，并在文件改变时自动构建。此外，还有客户端的缓存破坏功能，更不用说整个世界的依赖性管理和项目的构建时插件了。</p><p id="c141" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的脚本并不试图处理这些事情，尝试这样做是疯狂的。如果你没有时间或者没有意愿去实现一个完整的构建系统，从阅读这里可以清楚地看到，用例是一些文件的小型库。好好享受吧！</p><p id="568e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Richard是软件开发咨询公司</em><a class="ae km" href="https://cottagelabs.com" rel="noopener ugc nofollow" target="_blank"><em class="kl">Cottage Labs</em></a><em class="kl">的创始人和高级合伙人，专门研究数据生命周期的各个方面。他偶尔会在推特上发</em><a class="ae km" href="https://twitter.com/richard_d_jones" rel="noopener ugc nofollow" target="_blank"><em class="kl">@ Richard _ d _ Jones</em></a></p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="b16f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS。从这篇文章中把整个文件分成几个部分复制可能会很烦人，所以这里有一个模板脚本供你使用:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="bbd6" class="mc ko iq lt b gy md me l mf mg">#!/usr/bin/env bash<br/><br/><em class="kl"># set the paths to our executables<br/></em>NODEJS="nodejs"<br/>R="/path/to/r.js"<br/><br/><em class="kl"># define variables for the various paths we'll use later<br/></em>OUT="release"<br/>SRC="src"<br/>COMPILED_JS=$OUT/myapp.min.js<br/>DEPENDENCIES_JS=$OUT/myapp.dependencies.js<br/>COMPILED_CSS=$OUT/myapp.min.css<br/>DEPENDENCIES_CSS=$OUT/myapp.dependencies.css<br/>BUILD_INFO=$OUT/build.txt<br/><br/><em class="kl"># set our staging area directories<br/></em>MINIFIED_JS=$OUT/minified_js<br/>MINIFIED_CSS=$OUT/minified_css<br/><br/><em class="kl"># tear down and re-build the output directory<br/></em>rm -r $OUT<br/>mkdir $OUT<br/>mkdir $MINIFIED_JS<br/>mkdir $MINIFIED_CSS<br/><br/><em class="kl"># minify the entire js code tree<br/></em>$NODEJS $R -o appDir=$SRC/js baseDir=. dir=$MINIFIED_JS<br/><br/><em class="kl"># cat our code into the final compiled file<br/></em>cat $MINIFIED_JS/file1.js <em class="kl">&lt;</em>(echo) \<br/>    $MINIFIED_JS/file2.js <em class="kl">&lt;</em>(echo) \<br/>    <em class="kl">&gt; $COMPILED_JS<br/><br/># cat our dependencies into a single file<br/></em>cat vendor/dependency1.min.js <em class="kl">&lt;</em>(echo) \<br/>    vendor/dependency2.min.js <em class="kl">&lt;</em>(echo) \<br/>    <em class="kl">&gt; $DEPENDENCIES_JS<br/><br/># build our CSS files<br/></em>$NODEJS $R -o cssIn=$SRC/css/file1.css out=$MINIFIED_CSS/file1.css baseUrl=.<br/>$NODEJS $R -o cssIn=$SRC/css/file2.css out=$MINIFIED_CSS/file2.css baseUrl=.<br/><br/><em class="kl"># cat our CSS into a single file<br/></em>cat $MINIFIED_CSS/file1.css <em class="kl">&lt;</em>(echo) \<br/>    $MINIFIED_CSS/file2.css <em class="kl">&lt;</em>(echo) \<br/>    <em class="kl">&gt; $COMPILED_CSS<br/><br/># cat our CSS dependencies into a single file<br/></em>cat vendor/dependency1.min.css <em class="kl">&lt;</em>(echo) \<br/>    vendor/dependency2.min.css <em class="kl">&lt;</em>(echo) \<br/>    <em class="kl">&gt; $DEPENDENCIES_CSS<br/><br/></em>echo "Build $(date -u +"%Y-%m-%dT%H:%M:%SZ")" <em class="kl">&gt; $BUILD_INFO</em></span></pre></div></div>    
</body>
</html>