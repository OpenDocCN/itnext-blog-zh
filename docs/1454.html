<html>
<head>
<title>Entity Framework Core: Logging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体框架核心:日志记录</h1>
<blockquote>原文：<a href="https://itnext.io/entity-framework-core-logging-295493b08f9b?source=collection_archive---------2-----------------------#2018-10-21">https://itnext.io/entity-framework-core-logging-295493b08f9b?source=collection_archive---------2-----------------------#2018-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0de0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前几天，我不得不深入研究一些使用实体框架核心的流程的性能问题。作为流程的一部分，我需要查看由Entity Framework Core生成的查询，以确保它们不是问题的根源(它们不是)。如果你想知道我是从哪里开始的，我将使用我的<a class="ae kl" href="https://github.com/elanderson/ASP.NET-Core-Basics" rel="noopener ugc nofollow" target="_blank">ASP.NET核心基础回购</a>中的联系人项目进行这些更改。</p><p id="9aa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将讨论添加日志提供者。接下来，我将向你展示我想出的方法，然后我将向你展示微软文档建议的方法(我后来才发现)。</p><h2 id="3eea" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">日志记录提供程序</h2><p id="3961" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">首先，我们需要选择记录信息的方式。一个好的起点是使用微软提供的可以在NuGet上找到的软件。右键单击您想要添加日志的项目，然后单击<strong class="jp ir"> Manage NuGet Packages </strong>。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/a01c7f8c0c2d0e7d0965a5c8218e489b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/0*lY3SD4vXfoeLQX66.png"/></div></figure><p id="7761" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在搜索框中输入<strong class="jp ir">微软。Extensions.Logging </strong>获得一个好的日志选项列表。在这篇文章中，我们将使用微软提供的控制台记录器。选择<strong class="jp ir">微软。然后点击屏幕右上方的<strong class="jp ir">安装</strong>按钮。</strong></p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/3d500dc28d34e05564dcb6cb5fabd3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mTqJJO0sOYfLMWk3.png"/></div></div></figure><h2 id="e8fa" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">一下子</h2><p id="4d2a" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">对于我的第一次尝试，所有的改变都在<code class="fe lx ly lz ma b">Startup</code>类的<code class="fe lx ly lz ma b">ConfigureServices</code>函数中。下面是我在函数末尾添加的代码，它将把所有查询记录到控制台窗口(如果您使用IIS Express，请使用调试记录器)。</p><pre class="ll lm ln lo gt mb ma mc md aw me bi"><span id="ce1e" class="km kn iq ma b gy mf mg l mh mi">var scopeFactory = services.BuildServiceProvider()<br/>                           .GetRequiredService&lt;IServiceScopeFactory&gt;();<br/><br/>using (var scope = scopeFactory.CreateScope())<br/>{<br/>    using (var context = scope.ServiceProvider<br/>                              .GetRequiredService&lt;ContactsContext&gt;())<br/>    {<br/>        var loggerFactory = context.GetInfrastructure()<br/>                                   .GetService&lt;ILoggerFactory&gt;();<br/>        loggerFactory.AddProvider(new ConsoleLoggerProvider((_, __) =&gt; true, true));<br/>    }<br/>}</span></pre><p id="ed3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码创建了一个作用域来获取<code class="fe lx ly lz ma b">ContactsContext</code>的实例，然后使用上下文来获取它的相关记录器工厂，并向它添加一个控制台记录器。这并不是世界上最干净的，但可以完成工作，特别是如果这只是为了快速调试会话，而不是一些会留下来的东西。</p><h2 id="af8c" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">微软方式</h2><p id="9d40" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">虽然上面的工作我最终在实体框架核心文档中找到了一个<a class="ae kl" href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/logging" rel="noopener ugc nofollow" target="_blank">日志页面。撤销上面所做的更改后，打开<code class="fe lx ly lz ma b">ContactsContext</code>(或任何你的DBContext)并为logger工厂添加一个类级静态变量。该类级别变量将用于防止每次创建上下文时创建日志记录类的新实例所导致的内存和性能问题。</a></p><pre class="ll lm ln lo gt mb ma mc md aw me bi"><span id="4c1a" class="km kn iq ma b gy mf mg l mh mi">public static readonly LoggerFactory LoggerFactory = <br/>       new LoggerFactory(new[] {new ConsoleLoggerProvider((_, __) =&gt; true, true)});</span></pre><p id="674a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，添加/更新对<code class="fe lx ly lz ma b">OnConfiguring</code>的覆盖，以使用上面定义的记录器工厂。以下是我的例子中的全部功能。</p><pre class="ll lm ln lo gt mb ma mc md aw me bi"><span id="a8ed" class="km kn iq ma b gy mf mg l mh mi">protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)<br/>{<br/>    base.OnConfiguring(optionsBuilder);<br/><br/>    optionsBuilder.UseLoggerFactory(LoggerFactory);<br/>}</span></pre><h2 id="9432" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">输出</h2><p id="2a1c" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">无论哪种方式，下面是登录后的输出示例。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mj"><img src="../Images/02ff2d3f8f46302fe5280927c9541415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IJNBfNP8q46P-59P.png"/></div></div></figure><p id="9f69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该查询在上面的红框中突出显示。如你所见，有很多输出，但是有用于过滤的<a class="ae kl" href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/logging#filtering-what-is-logged" rel="noopener ugc nofollow" target="_blank">选项，在文档中有详细描述。</a></p><h2 id="4904" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">包扎</h2><p id="c4cb" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">Entity Framework Core做得很好，但是上面给了你一个检查它在做什么的选项。如果您使用的是SQL Server，也可以使用SQL Server Profiler获取查询。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="e06c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mr">原载于</em> <a class="ae kl" href="https://elanderson.net/2018/10/entity-framework-core-logging/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">安德森</em> </a> <em class="mr">。</em></p></div></div>    
</body>
</html>