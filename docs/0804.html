<html>
<head>
<title>Safe Property Accessors in Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript中的安全属性访问器</h1>
<blockquote>原文：<a href="https://itnext.io/safe-property-accessors-in-typescript-53fd384b83f3?source=collection_archive---------7-----------------------#2018-05-31">https://itnext.io/safe-property-accessors-in-typescript-53fd384b83f3?source=collection_archive---------7-----------------------#2018-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c2681d15e9a4ae9c434c2400c30c6a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*vvHDQM5gmHAigQBOIbaqlg.png"/></div></div></figure><p id="5ef1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">魔弦很碍眼。我尤其不喜欢在属性访问器的对象括号符号中看到它们，例如</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="4354" class="lf lg iq lb b gy lh li l lj lk">abstract class Main {<br/>  run() {<br/>    const myObject = { a: 2, b: 4 };<br/>    console.log(`Dot Notation (good): ${myObject.a}`);<br/>    console.log(`Bracket Notation (bad): ${myObject['a']}`);<br/>  }<br/>}</span><span id="bc26" class="lf lg iq lb b gy ll li l lj lk">Main.run();</span></pre><p id="11f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以证明使用对象括号符号的唯一用例是用于动态属性访问，但是我讨厌使用这样一个神奇的字符串来访问这样一个属性。没有办法保证你的属性会在源对象上。上面的代码块有两个主要问题:</p><ol class=""><li id="4e0f" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated">神奇的字符串在这里是不必要的，因为它使代码更难维护，并且不是自文档化的。</li><li id="8579" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">不能保证源对象上存在被访问的属性。</li></ol><p id="9215" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接着是<a class="ae ma" href="https://www.youtube.com/watch?v=fA7LGqwjhYs" rel="noopener ugc nofollow" target="_blank">“鲍勃呢？”接近</a>，让我们一步一步地开始重构神奇的字符串:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="0ff6" class="lf lg iq lb b gy lh li l lj lk">abstract class Constants {<br/>    readonly MyProperty: string = 'a';<br/>}</span><span id="0b1e" class="lf lg iq lb b gy ll li l lj lk">abstract class Main {<br/>  run() {<br/>    const myObject = { a: 2, b: 4 };<br/>    console.log(`Better: ${myObject[Constants.MyProperty]}`);<br/>  }<br/>}<br/>Main.run();</span></pre><p id="bc3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不再使用神奇的字符串，上面的例子是一个稍微好一点的选择。通过创建单一的事实来源，这是一个更易于维护的解决方案，并且有助于在自文档化代码的道路上走得更远。虽然我们解决了魔术字符串的眼中钉，但我们仍然没有解决我们的“担保财产”问题。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="2fa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这比婴儿步稍大一点，我们来分解一下:</p><p id="d1f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你应该很熟悉——简单的一个基本类。这其中的<code class="fe md me mf lb b">Constants</code>部分是我在大型web应用程序中更好地表示常量的方式。通过创建一个命名空间来封装所有常量，创建一些类来组织字符串，并将static + readonly字符串作为常量，您可以拥有一个三级组织模式。然而，请注意<code class="fe md me mf lb b">MyProperty</code>和<code class="fe md me mf lb b">MyUnsafeProperty</code>之间的一个细微差别。一个使用字符串类型，一个使用<code class="fe md me mf lb b">keyof</code>将其强类型化为<code class="fe md me mf lb b">MyClass</code>的一个键。</p><p id="bf65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe md me mf lb b">keyof</code>是一个Typescript类型的查询，它确保一个字符串作为该对象的属性存在(注意，这也适用于父子关系)。如果<code class="fe md me mf lb b">MyProperty</code>的值在<code class="fe md me mf lb b">MyClass</code>上不作为字段存在，Typescript会给你一个编译器错误，让你知道你的值在<code class="fe md me mf lb b">MyClass</code>上不作为字段存在。为了更加安全，我们将<code class="fe md me mf lb b">_safeNameOf</code>的第二个参数限制为<code class="fe md me mf lb b">T</code>类型的键。为了防止您已经设法抑制了这个Typescript编译错误，我们仍然在<code class="fe md me mf lb b">_safeNameOf</code>中添加了一个额外的检查，以确保这个键确实存在于源代码中。</p><p id="b4ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是使括号标记属性访问器类型安全的冗长方法，但在一些针对一般对象的旧Javascript变通办法中，这是确保类型安全的好方法。</p></div></div>    
</body>
</html>