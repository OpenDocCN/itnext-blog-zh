<html>
<head>
<title>Patterns of Kubernetes API Extensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes API扩展的模式</h1>
<blockquote>原文：<a href="https://itnext.io/comparing-kubernetes-api-extension-mechanisms-of-custom-resource-definition-and-aggregated-api-64f4ca6d0966?source=collection_archive---------1-----------------------#2018-06-21">https://itnext.io/comparing-kubernetes-api-extension-mechanisms-of-custom-resource-definition-and-aggregated-api-64f4ca6d0966?source=collection_archive---------1-----------------------#2018-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="826f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于Kubernetes的一个有趣的方面是，您可以扩展它的API，以利用Kubernetes的底层功能构建一个适用的平台。可用于实现API扩展的机制是自定义资源定义(CRD)和聚合API服务器(AA)。使用这些机制构建的API可以使用kubectl直接访问，不需要其他CLI来访问它们。</p><p id="3cb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们从扩展API中涉及的基本构造的角度来看API扩展。使用这个镜头，我们能够考虑各种各样的<em class="kl">模式</em>，通过将这些基本结构结合在一起，这些模式是可能的。然后，我们展示了哪些模式可以使用定制资源定义来实现，哪些模式可以使用聚合API服务器来实现。</p><p id="3fb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">扩展的Kubernetes API中的基本构造</em></p><p id="0f5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes扩展API包含三个基本构造。它们是:(a)自定义种类(b)自定义控制器(c)自定义子资源。</p><ol class=""><li id="d133" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">自定义种类:自定义种类是一种构造，它允许您以声明的格式定义特定于领域的需求。例如，Postgres自定义类型可以支持创建数据库和用户的声明性模型。自定义类型类似于现有的本地Kubernetes类型，如Pod、Service。它包括元数据部分、规范部分和状态部分。</li><li id="f11f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">定制控制器:定制控制器是一个Kubernetes控制器，它通过监视集群中Kubernetes种类的创建/更新/删除事件来协调集群的状态。这些可以是本地类型(部署、Pod、服务等。)或自定义种类(如Postgres)。</li><li id="7297" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">自定义子资源:Kubernetes种类(本地或自定义)上的自定义子资源允许您在它的种类上定义细粒度的操作。在缺少子资源的情况下，Kubernetes只允许任何类型的基本CRUD操作。自定义子资源的一个示例可以是在Pod上定义的http_requests_total，它将允许您找出该Pod收到的http请求的数量。</li></ol><p id="1acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不是每个扩展API都包含所有这些结构。事实上，我们在任何扩展API中都观察到了四种模式。它们如下:</p><ol class=""><li id="484e" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">自定义种类+自定义控制器:这是最流行的模式。在这个模式中，您使用一个自定义种类来声明性地建模您的域需求。定制控制器包括通过对对应于定制种类(主要)的不同事件做出反应来协调集群状态的逻辑。这种模式的通俗名称是<code class="fe la lb lc ld b">Operator Pattern.</code>。这种模式可以使用CRD和AA机制来实现。</li><li id="ec41" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">自定义种类+自定义控制器+自定义子资源:和上面一样，这个模式也是<code class="fe la lb lc ld b">Operator Pattern.</code>它也支持通过自定义子资源对您的自定义种类进行自定义操作(超越CRUD)。这种模式只能使用AA机制来实现。</li><li id="c990" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">自定义控制器+自定义子资源:该模式没有定义新的种类。定制控制器对与已经在集群中注册的种类相关的事件执行其协调逻辑。自定义子资源用于检索由自定义控制器收集的信息。一个这样的例子是<a class="ae le" href="https://medium.com/@cloudark/our-journey-in-building-a-kubernetes-aggregated-api-server-29a4f9c1de22" rel="noopener">控制器，它收集和维护关于各种Kubernetes对象的动态组合</a>的信息，定制子资源用于获取这些信息。这种模式只能使用AA机制来实现。</li><li id="3f44" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">定制子资源:在这个模式中，没有定制控制器。定制子资源通常被用来查找关于某个Kubernetes对象的一些信息。这方面的一个例子是一个<a class="ae le" href="https://github.com/kubernetes-incubator/custom-metrics-apiserver" rel="noopener ugc nofollow" target="_blank">度量服务器，它从Prometheus </a>获取信息，并通过自定义子资源如<code class="fe la lb lc ld b">http_requests.</code>使其可用。这种模式只能使用AA机制来实现。</li></ol><p id="8636" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的表格总结了这些模式、实现这些模式所支持的API扩展机制，以及指向示例的指针，在这些示例中，您可以看到用于开发阶段的模式和参考工具。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/a4b6bfcdade327c358a3990793cc5a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lY7ySTqMJ86N41ktSofShw.jpeg"/></div></div></figure><ol class=""><li id="2eef" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">自定义种类+自定义控制器:在实现这种模式时，您可以使用CRD或AA。使用CRD时，首先查看<a class="ae le" href="https://github.com/kubernetes/sample-controller" rel="noopener ugc nofollow" target="_blank">采样控制器</a>。这是一个如何编写、安装和使用CRD的好例子。你也可以看看<a class="ae le" href="https://github.com/cloud-ark/kubeplus/tree/master/postgres-crd-v2" rel="noopener ugc nofollow" target="_blank">我们的Postgres操作符</a>来看看一个以样本控制器为模型的CRD例子。查看<a class="ae le" href="https://github.com/kubernetes-sigs/kubebuilder" rel="noopener ugc nofollow" target="_blank"> kubebuilder </a>和<a class="ae le" href="https://github.com/operator-framework/operator-sdk" rel="noopener ugc nofollow" target="_blank"> Operator SDK </a>。这些工具减少了使用sample-controller从头开始开发CRD时需要编写的样板代码。为了更好地了解这些工具的内部工作原理，请查看我们对它们的分析<a class="ae le" href="https://medium.com/@cloudark/kubernetes-custom-controllers-b6c7d0668fdf" rel="noopener">这里</a>(样本控制器)<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/under-the-hood-of-kubebuilder-framework-ff6b38c10796">这里</a> (kubebuilder)，以及<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/under-the-hood-of-the-operator-sdk-eebc8fdeebbf">这里</a> (Operator SDK)。当使用聚合API服务器时，<a class="ae le" href="https://github.com/kubernetes/sample-apiserver" rel="noopener ugc nofollow" target="_blank"> sample-apiserver </a>是一个很好的起点。</li><li id="f90c" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">自定义种类+自定义控制器+自定义子资源:当使用这种模式时，<a class="ae le" href="https://github.com/kubernetes-incubator/apiserver-builder" rel="noopener ugc nofollow" target="_blank"> apiserver-builder </a>工具可以帮助为您的服务器创建启动代码。它将帮助您在自定义种类上创建自定义种类、自定义控制器和自定义子资源。</li><li id="75df" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">定制控制器+定制子资源:我们的<a class="ae le" href="https://github.com/cloud-ark/kubeprovenance" rel="noopener ugc nofollow" target="_blank"> kubediscovery API服务器</a>是这种情况的一个很好的例子。定制控制器定期轮询Kubernetes的主API，以构建各种Kubernetes对象的动态组合树。在控制器的下一个版本中，我们计划修改其架构，使用观察/反应模型代替轮询模型。我们定义的自定义子资源是“/compositions”。这可以用于任何Kubernetes类型，本地的或定制的，来找出Kubernetes对象的所有或特定实例的动态组合信息。</li><li id="f93e" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">定制子资源:<a class="ae le" href="https://github.com/kubernetes-incubator/custom-metrics-apiserver" rel="noopener ugc nofollow" target="_blank">定制度量apiserver </a>是这种模式的一个很好的例子。它定义了“pods/http_requests”子资源，可用于找出一个Pod收到的http请求的数量。在内部，它从集群中运行的Prometheus实例获取该信息。</li></ol><p id="b399" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前两种模式支持Kubernetes状态和解的<em class="kl">声明模型</em>。这些模式中可用的自定义种类用于定义所需的状态，自定义控制器用于定义协调逻辑。每当引入一种新的定制类型时，该模式也可以称为<code class="fe la lb lc ld b">Operator Pattern.</code></p><p id="fc85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后两种模式侧重于提供在Kubernetes对象上执行定制操作的能力。当前的例子——custom-metrics——API server、kube discovery——展示了如何执行从集群中检索定制状态信息的操作。没有自定义子资源，只有CRUD操作是可能的。</p><p id="17d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">结论:</em></p><p id="7632" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes的自定义资源定义和聚合API服务器的API扩展机制由三个基本结构组成——自定义种类、自定义控制器和自定义子资源。通过对现有例子的分析，我们已经确定了四种模式，这四种模式结合了今天看到的这些结构。通过从扩展模式的角度来看API扩展机制，我们希望您在开发扩展API时能够选择合适的机制、示例和工具。</p><p id="833d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" href="https://cloudark.io/" rel="noopener ugc nofollow" target="_blank"> www.cloudark.io </a></p></div></div>    
</body>
</html>