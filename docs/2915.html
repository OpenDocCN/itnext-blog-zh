<html>
<head>
<title>Mastering Codable in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中掌握编码</h1>
<blockquote>原文：<a href="https://itnext.io/mastering-codable-in-swift-part-1-81de0b824c51?source=collection_archive---------3-----------------------#2019-08-28">https://itnext.io/mastering-codable-in-swift-part-1-81de0b824c51?source=collection_archive---------3-----------------------#2019-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c8752065e11afc6b3bcc2f4c7e598e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NLbUTjjePWnGvS3jwt-c2g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://pixabay.com/illustrations/lego-building-game-toy-drawing-3388163/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/illustrations/Lego-building-game-toy-drawing-3388163/</a></figcaption></figure><p id="63f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Codable是Apple提供的一个漂亮的工具，它以(主要)声明的方式执行值的序列化和反序列化。</p><p id="370c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Codable，您可以</p><ul class=""><li id="d484" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">将JSON转换成某种类型的实例</li><li id="c998" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用某种类型的实例生成JSON</li></ul><p id="11cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇面向初学者的文章中，您将学习如何在5个简单的场景中使用Codable:</p><ol class=""><li id="d025" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld ls lk ll lm bi translated">解码简单的JSON</li><li id="5cdf" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ls lk ll lm bi translated">添加一个类型为<em class="lt"> Double </em>的字段</li><li id="0d78" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ls lk ll lm bi translated">将<em class="lt"> snake_case </em> JSON映射到<em class="lt"> camelCase </em> swift类型</li><li id="9410" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ls lk ll lm bi translated">解码元素列表</li><li id="82a6" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ls lk ll lm bi translated">可选值</li></ol><h1 id="be03" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">场景1:解码简单的JSON</h1><p id="6047" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">让我们从一个非常简单的场景开始，你有一个像这样的JSON</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="6dbd" class="ng lv it nc b gy nh ni l nj nk">let json = """<br/>{<br/>    "name": "Enterprise D",<br/>    "captain": "Jean Luc Picard"<br/>}<br/>"""</span></pre><p id="893e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你有一个这样的结构</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="2831" class="ng lv it nc b gy nh ni l nj nk">struct Ship: Codable {<br/>    let name: String<br/>    let captain: String<br/>}</span></pre><p id="59c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以简单地编写一个Ship实例</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="70d0" class="ng lv it nc b gy nh ni l nj nk">guard let data = json.data(using: String.Encoding.utf8) else { fatalError("☠️") }</span><span id="c571" class="ng lv it nc b gy nl ni l nj nk">do {<br/>    let ship = try JSONDecoder().decode(Ship.self, from: data)<br/>    print(ship)<br/>} catch {<br/>    print(error)<br/>}</span></pre><p id="0415" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果将会是</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="a2e7" class="ng lv it nc b gy nh ni l nj nk">Ship(name: “Enterprise D”, captain: “Jean Luc Picard”)</span></pre><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/3556fb74ad2817a7246f312ddd02f954.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*VUzQ5A1PmmD5LfSOq4pwhA.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/USS_Enterprise_(NCC-1701-D)#/media/File:Enterprise_Forward.jpg" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/USS _ Enterprise _(NCC-1701-D)#/media/File:Enterprise _ forward . jpg</a></figcaption></figure><p id="38c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是如何工作的？</p><p id="478a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自动解码机制起作用是因为:</p><ol class=""><li id="8941" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld ls lk ll lm bi translated"><strong class="ki iu">船</strong>符合<strong class="ki iu">编码</strong></li><li id="f85d" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ls lk ll lm bi translated">JSON <strong class="ki iu">键名</strong>和Ship struct <strong class="ki iu">属性名</strong>确实匹配</li><li id="cebf" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ls lk ll lm bi translated">JSON <strong class="ki iu">键类型</strong>和Ship struct <strong class="ki iu">属性匹配</strong>匹配</li></ol><p id="28f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是声明式编程的一个很好的例子，我们刚刚描述了<em class="lt"> Ship </em>类型是怎样的，剩下来的是对所有无聊的东西进行编码。</p><h1 id="cff7" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">场景2:添加Double类型的字段</h1><p id="5ce5" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">这很简单，现在让我们假设我们的JSON有另一个类型为<em class="lt"> Double </em>的属性</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="53d7" class="ng lv it nc b gy nh ni l nj nk">let json = """<br/>{<br/>    "name": "Enterprise D",<br/>    "captain": "Jean Luc Picard",<br/>    "max_warp_speed": 9.6<br/>}<br/>"""</span></pre><p id="ab41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们更新我们的结构</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="846b" class="ng lv it nc b gy nh ni l nj nk">struct Ship: Codable {<br/>    let name: String<br/>    let captain: String<br/>    let max_warp_speed: Double<br/>}</span></pre><p id="017c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并运行解码指令</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="18b1" class="ng lv it nc b gy nh ni l nj nk">guard let data = json.data(using: String.Encoding.utf8) else { fatalError("☠️") }</span><span id="7c5f" class="ng lv it nc b gy nl ni l nj nk">do {<br/>    let ship = try JSONDecoder().decode(Ship.self, from: data)<br/>    print(ship)<br/>} catch {<br/>    print(error)<br/>}</span></pre><p id="597f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们再次得到一个新的实例<em class="lt">船</em></p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="a615" class="ng lv it nc b gy nh ni l nj nk">Ship(name: “Enterprise D”, captain: “Jean Luc Picard”, max_warp_speed: 9.6)</span></pre><h1 id="55fe" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">场景3:将snake_case JSON映射到camelCase结构</h1><p id="8145" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">前面场景中使用的<em class="lt"> max_warp_speed </em>属性不是很“迅捷”对吧？我们应该使用<em class="lt">驼峰</em>符号</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="6621" class="ng lv it nc b gy nh ni l nj nk">struct Ship: Codable {<br/>    let name: String<br/>    let captain: String<br/>    let maxWarpSpeed: Double<br/>}</span></pre><p id="f151" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是现在属性maxWarpSpeed的名称不再匹配JSON max_warp_speed中的键。</p><p id="41a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好消息是，我们可以告诉Codable自动将名称从<em class="lt"> snake_case_notation </em>(在JSON中使用)转换为<em class="lt"> camelCase </em>(在Struct中使用)。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="2145" class="ng lv it nc b gy nh ni l nj nk">struct Ship: Codable {<br/>    let name: String<br/>    let captain: String<br/>    let maxWarpSpeed: Double<br/>}</span><span id="789c" class="ng lv it nc b gy nl ni l nj nk">guard let data = json.data(using: String.Encoding.utf8) else { fatalError("☠️") }</span><span id="2e35" class="ng lv it nc b gy nl ni l nj nk">do {<br/>    let decoder = JSONDecoder()<br/>    decoder.keyDecodingStrategy = .convertFromSnakeCase // 👈<br/>    let ship = try decoder.decode(Ship.self, from: data)<br/>    print(ship)<br/>} catch {<br/>    print(error)<br/>}</span></pre><h1 id="49b7" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">场景4:元素列表</h1><p id="5b06" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">现在让我们考虑一个带有元素列表的JSON</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="ecef" class="ng lv it nc b gy nh ni l nj nk">let json = """<br/>[<br/>    {<br/>        "name": "Enterprise D",<br/>        "captain": "Jean Luc Picard",<br/>        "max_warp_speed": 9.6<br/>    },<br/>    {<br/>        "name": "Defiant",<br/>        "captain": "Benjamin Sisko",<br/>        "max_warp_speed": 9.2<br/>    },<br/>    {<br/>        "name": "Voyager",<br/>        "captain": "Captain Kathryn Janeway",<br/>        "max_warp_speed": 9.975<br/>     }<br/>]<br/>"""</span></pre><p id="7f92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将这个JSON解码成一个由<em class="lt">Ship</em>组成的数组。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="346c" class="ng lv it nc b gy nh ni l nj nk">struct Ship: Codable {<br/>    let name: String<br/>    let captain: String<br/>    let maxWarpSpeed: Double<br/>}</span><span id="32b6" class="ng lv it nc b gy nl ni l nj nk">guard let data = json.data(using: String.Encoding.utf8) else { fatalError("☠️") }</span><span id="6702" class="ng lv it nc b gy nl ni l nj nk">do {<br/>    let decoder = JSONDecoder()<br/>    decoder.keyDecodingStrategy = .convertFromSnakeCase<br/>    let ships = try decoder.decode([Ship].self, from: data) // 👈<br/>    print(ships)<br/>} catch {<br/>    print(error)<br/>}</span></pre><p id="c16b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们替换了这条线</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="1ea4" class="ng lv it nc b gy nh ni l nj nk">let ship = try decoder.decode(Ship.self, from: data)</span></pre><p id="0763" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用这条线</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="b326" class="ng lv it nc b gy nh ni l nj nk">let ships = try decoder.decode([Ship].self, from: data)</span></pre><h1 id="46da" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">场景5:可选值</h1><p id="f445" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">现在我们想给我们的JSON添加一个<em class="lt">位置</em>键</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="00f6" class="ng lv it nc b gy nh ni l nj nk">let json = """<br/>[<br/>    {<br/>        "name": "Enterprise D",<br/>        "captain": "Jean Luc Picard",<br/>        "max_warp_speed": 9.6,<br/>        "position": "Alpha quadrant"<br/>    },<br/>    {<br/>        "name": "Defiant",<br/>        "captain": "Benjamin Sisko",<br/>        "max_warp_speed": 9.2,<br/>        "position": "Alpha quadrant"<br/>    },<br/>    {<br/>        "name": "Voyager",<br/>        "captain": "Captain Kathryn Janeway",<br/>        "max_warp_speed": 9.975,<br/>        "position": null<br/>    }<br/>]<br/>"""</span></pre><p id="b1bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，position属性仅填充了前两个元素(我们不知道Voyager的位置)。</p><p id="fe75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们更新我们的结构</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="d9dc" class="ng lv it nc b gy nh ni l nj nk">struct Ship: Codable {<br/>    let name: String<br/>    let captain: String<br/>    let maxWarpSpeed: Double<br/>    let position: String<br/>}</span></pre><p id="279b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们再次运行代码</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="98af" class="ng lv it nc b gy nh ni l nj nk">guard let data = json.data(using: String.Encoding.utf8) else { fatalError("☠️") }</span><span id="88d2" class="ng lv it nc b gy nl ni l nj nk">do {<br/>    let decoder = JSONDecoder()<br/>    decoder.keyDecodingStrategy = .convertFromSnakeCase<br/>    let ships = try decoder.decode([Ship].self, from: data)<br/>    print(ships)<br/>} catch {<br/>    print(error)<br/>}</span></pre><p id="8699" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果我们得到了这个错误</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="3b69" class="ng lv it nc b gy nh ni l nj nk">valueNotFound(Swift.String, Swift.DecodingError.Context(codingPath: [_JSONKey(stringValue: “Index 2”, intValue: 2), CodingKeys(stringValue: “position”, intValue: nil)], debugDescription: “Expected String value but found null instead.”, underlyingError: nil))</span></pre><p id="e9ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Codable告诉我们，position在我们的结构中被定义为强制的，但在JSON的第3个元素中没有找到。</p><p id="f3bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以修复它，使“位置”成为结构中的可选值</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="204f" class="ng lv it nc b gy nh ni l nj nk">struct Ship: Codable {<br/>    let name: String<br/>    let captain: String<br/>    let maxWarpSpeed: Double<br/>    let position: String? // 👈<br/>}</span></pre><p id="13aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们再试一次，现在问题已经解决了，因此，我们的<em class="lt">船</em>阵列已经被正确填充了。</p><h1 id="1ee2" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><p id="3284" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">在本文中，您了解了使用可编码协议可以完成的基本操作。然而，这个工具更强大，可以做更多的事情。我将在<a class="ae kf" href="https://medium.com/@lucaangeletti/mastering-codable-in-swift-part-2-876e646e0844" rel="noopener">未来的文章</a>中讨论这个问题。</p></div></div>    
</body>
</html>