<html>
<head>
<title>React Hooks — designing a simple forms API — part 5 — dynamic forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react Hooks——设计简单的表单API——第5部分——动态表单</h1>
<blockquote>原文：<a href="https://itnext.io/react-hooks-designing-a-simple-forms-api-part-5-dynamic-forms-b8ceea4a4ff?source=collection_archive---------5-----------------------#2019-04-12">https://itnext.io/react-hooks-designing-a-simple-forms-api-part-5-dynamic-forms-b8ceea4a4ff?source=collection_archive---------5-----------------------#2019-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="899e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将确保我们的React基于钩子的表单库能够支持动态表单，并在此过程中了解一些关于钩子状态和钩子测试的有趣事情。我们的库已经支持带有预定义输入集的表单，但是它不支持输入数量需要随着时间增加或减少的表单。</p><p id="177a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的第1部分<a class="ae ko" href="https://medium.com/@shanplourde/react-hooks-designing-a-simple-forms-api-part-1-307b04bc6007" rel="noopener">中，我们研究了如何使用React钩子来设计一个<code class="fe kp kq kr ks b">useForm</code> React表单库。第1部分介绍了这个库的动机和一些总体设计目标。</a></p><p id="b83f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列<a class="ae ko" href="https://medium.com/@shanplourde/react-hooks-designing-a-simple-forms-api-part-2-1fe5d12f23d9" rel="noopener">的第2部分</a>中，我们创建了一个<code class="fe kp kq kr ks b">useInput</code>钩子，将其集成到我们的<code class="fe kp kq kr ks b">useForm</code>钩子中，回顾了我们的解决方案的状态管理，合并了一些额外的测试，并更详细地回顾了测试策略。</p><p id="f5a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第3部分中，我们讨论了验证、异步验证和异步表单提交。它为我们提供了基于React hooks的表单API的关键元素。</p><p id="748b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/react-hooks-designing-a-simple-forms-api-part-4-scaling-to-other-input-types-e738db0a3fc3">在第4部分</a>中，我们扩展了我们的解决方案，以支持标准HTML输入类型和自定义输入。</p><h1 id="4f20" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">工作示例</h1><p id="6098" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">让我们来看看这一部分将包含的所有内容的演示。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">演示我们将从第5部分开发的动态表单</figcaption></figure><p id="38f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://github.com/shanplourde/react-hooks-form-util" rel="noopener ugc nofollow" target="_blank">完整的解决方案可以在我的GitHub </a>中找到。演示中有很多样板文件，但我希望在这一点上有非常明确的例子。请注意，由于CodeSandbox设计决定不支持从<code class="fe kp kq kr ks b">package.json</code>加载<code class="fe kp kq kr ks b">devDependencies</code>，测试在此时没有通过CodeSandbox。</p><h1 id="c0df" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">支持动态改变表单输入的动机</h1><p id="917e" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">我能想到许多添加或删除表单字段的功能有用的表单示例。例如:</p><ul class=""><li id="bf9b" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">捕获表格数据，并允许用户添加或删除行</li><li id="d451" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">你的工作或居住历史(我最近不得不填写这些表格中的一种，作为我即将开始的新工作的背景调查的一部分😃)</li><li id="23f6" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">基本上任何1:n的数据输入场景</li></ul><p id="de6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个特性肯定会增加价值，我认为确保<code class="fe kp kq kr ks b">useForm</code>设计支持它是值得的。</p><h1 id="77a4" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">设计支持动态表单的公共API</h1><p id="8217" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated"><code class="fe kp kq kr ks b">useForm</code>允许表单开发人员使用<code class="fe kp kq kr ks b">api.addInput</code>功能添加新的输入。但是表单开发人员不能删除输入，如果表单已经呈现，当前版本的<code class="fe kp kq kr ks b">api.addInput</code>就会中断。</p><h2 id="b1b8" class="mv ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">将api.removeInput添加到<code class="fe kp kq kr ks b">useForm</code> API</h2><p id="a25b" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated"><code class="fe kp kq kr ks b">api.removeInput</code>应该允许从现有表单中删除输入。当被调用时，它应该移除与被移除的输入相关联的所有状态，例如输入值、验证状态等。</p><h2 id="6a34" class="mv ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">修正了<code class="fe kp kq kr ks b">api.addInput</code>不允许新输入被添加到渲染表单的错误</h2><p id="3445" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">虽然<code class="fe kp kq kr ks b">api.addInput</code>是添加新输入的基础，但React钩子有一个关键要求——渲染的钩子数量必须等于上一个渲染周期。</p><p id="8c7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是问题的根本原因。点击这里查看我的相关文章。本质上，我的<code class="fe kp kq kr ks b">useInput</code>钩子不支持动态表单，因为React钩子在每个渲染周期都需要这种一致性。很高兴知道你是否打算用钩子来设计一个可以伸缩的结构。</p><h1 id="aa85" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实施细节</h1><p id="a814" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated"><code class="fe kp kq kr ks b">api.removeInput</code>是对<code class="fe kp kq kr ks b">useForm</code>的一个微不足道的补充。它只需要删除与被删除的输入相关联的所有状态:</p><pre class="lw lx ly lz gt nh ks ni nj aw nk bi"><span id="4f4c" class="mv ku it ks b gy nl nm l nn no">const removeInput = id =&gt; {<br/>    delete inputs[id];<br/>    delete inputUiState[id];<br/>    delete validators[id];<br/>    delete formValidity[id];<br/>    delete inputValues[id];<br/>    delete originalValues[id];</span><span id="e8c9" class="mv ku it ks b gy np nm l nn no">setInputUiState(inputUiState);<br/>  };</span></pre><p id="1273" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">useInput</code>是一个钩子，React不允许我们使用它来增加或减少输入，因为钩子的设计决策要求在渲染周期中调用的钩子数量保持一致。所以我们必须移除<code class="fe kp kq kr ks b">useInput</code>钩子，并将<code class="fe kp kq kr ks b">useInput</code>管理的所有状态移入<code class="fe kp kq kr ks b">useForm</code>。</p><h2 id="f191" class="mv ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">使用输入状态摘要</h2><p id="809b" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">useInput保持以下状态。所有这些状态都需要转移到<code class="fe kp kq kr ks b">useForm</code>:</p><ul class=""><li id="c18e" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated"><code class="fe kp kq kr ks b">inputValue</code></li><li id="da99" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated"><code class="fe kp kq kr ks b">originalValue</code> —用于跟踪原始状态</li><li id="1bfa" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated"><code class="fe kp kq kr ks b">visited</code> —当输入获得焦点时改变</li></ul><h2 id="122c" class="mv ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">使用表单状态摘要</h2><p id="6779" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated"><code class="fe kp kq kr ks b">useForm</code>已经跟踪所有输入值。所以<code class="fe kp kq kr ks b">useInput.inputValue</code>在某种程度上是多余的。useForm不需要做任何事情来支持<code class="fe kp kq kr ks b">useInput.inputValue</code>。</p><h2 id="1177" class="mv ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">使用输入⟹input.js</h2><p id="822f" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">由于<code class="fe kp kq kr ks b">useInput</code>不再是钩子，我决定改名为<code class="fe kp kq kr ks b">input.js</code>。<code class="fe kp kq kr ks b">createInput</code>是取代<code class="fe kp kq kr ks b">useInput</code>的新功能。<code class="fe kp kq kr ks b">createInput</code>没有国家。所有状态将由<code class="fe kp kq kr ks b">useForm</code>管理。因此，<code class="fe kp kq kr ks b">createInput</code>确保对于它处理的每个事件，它都将事件传递给传入的<code class="fe kp kq kr ks b">props</code>。</p><pre class="lw lx ly lz gt nh ks ni nj aw nk bi"><span id="76b0" class="mv ku it ks b gy nl nm l nn no">const getInputValue = ({ type, checked, value, options }) =&gt; {<br/>  if (type === "checkbox") return checked;<br/>  if (type === "select-multiple")<br/>    return [...options]<br/>      .map(option =&gt; ({<br/>        value: option.value,<br/>        selected: option.selected<br/>      }))<br/>      .filter(option =&gt; option.selected)<br/>      .map(option =&gt; option.value);<br/>  if (type === "radio") {<br/>    if (checked) return value;<br/>    return undefined;<br/>  }<br/>  return value;<br/>};</span><span id="dac2" class="mv ku it ks b gy np nm l nn no">export const createInput = ({ id, value, props = {} }) =&gt; {<br/>  const getSharedProps = () =&gt; ({<br/>    id,<br/>    ...props,<br/>    onChange: (event, inputValue) =&gt; {<br/>      const value = inputValue || getInputValue(event.target);<br/>      props.onChange &amp;&amp; props.onChange({ event, id, value });<br/>    },<br/>    onBlur: (event, inputValue) =&gt; {<br/>      const value = inputValue || getInputValue(event.target);<br/>      props.onBlur &amp;&amp; props.onBlur({ event, id, value });<br/>    },<br/>    onFocus: evt =&gt; {<br/>      props.onFocus &amp;&amp; props.onFocus({ evt, id, value });<br/>    }<br/>  });</span><span id="2fde" class="mv ku it ks b gy np nm l nn no">const getInputProps = inputProps =&gt; ({<br/>    ...getSharedProps(),<br/>    value: value,<br/>    ...(typeof inputProps === "function" ? inputProps(props) : inputProps)<br/>  });</span><span id="962c" class="mv ku it ks b gy np nm l nn no">const getCheckProps = inputProps =&gt; ({<br/>    ...getSharedProps(),<br/>    checked: value,<br/>    ...(typeof inputProps === "function" ? inputProps(props) : inputProps)<br/>  });</span><span id="bddd" class="mv ku it ks b gy np nm l nn no">return {<br/>    id,<br/>    value,<br/>    getInputProps,<br/>    getCheckProps<br/>  };<br/>};</span></pre><h2 id="9364" class="mv ku it bd kv mw mx dn kz my mz dp ld kb na nb lh kf nc nd ll kj ne nf lp ng bi translated">使用表单更改</h2><p id="af73" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">在这次<code class="fe kp kq kr ks b">useForm</code>的迭代中，最大的变化是迁移了所有由<code class="fe kp kq kr ks b">useInput</code> hook管理的状态。<code class="fe kp kq kr ks b"> api.removeInput</code>被添加。</p><p id="da7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">异步验证码发布和修复</strong></p><p id="f98d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我之前使用了一个<code class="fe kp kq kr ks b">useRef</code>钩子来试图通过异步验证保持最新的状态。我忘记了<code class="fe kp kq kr ks b">useState</code>和<code class="fe kp kq kr ks b">setState</code>几乎是一样的，所以如果你需要根据当前状态改变状态为一个值，你需要使用函数版本的useState。例如:</p><pre class="lw lx ly lz gt nh ks ni nj aw nk bi"><span id="c8c8" class="mv ku it ks b gy nl nm l nn no">const [formValidity, setFormValidity] = useState({});</span><span id="48c3" class="mv ku it ks b gy np nm l nn no">...</span><span id="a5e5" class="mv ku it ks b gy np nm l nn no">setFormValidity(current =&gt; ({<br/>        ...current,<br/>        [id]: { isValidating: true, value }<br/>      }));</span></pre><p id="cd12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">useForm.js的完整源代码如下:</p><pre class="lw lx ly lz gt nh ks ni nj aw nk bi"><span id="0f75" class="mv ku it ks b gy nl nm l nn no">import { useState, useRef } from "react";<br/>import { createInput } from "./input";<br/>import { runValidators, validateInputEvents } from "./validators";</span><span id="ca93" class="mv ku it ks b gy np nm l nn no">export const defaultFormProps = {<br/>  autoComplete: "on"<br/>};</span><span id="2ca1" class="mv ku it ks b gy np nm l nn no">export const useForm = ({ id, initialState = {} }) =&gt; {<br/>  const [inputValues] = useState({<br/>    ...initialState<br/>  });<br/>  const [formValidity, setFormValidity] = useState({});<br/>  const [validators] = useState({});<br/>  const [uiState, setUiState] = useState({<br/>    isValidating: false,<br/>    isValid: true,<br/>    isSubmitting: false<br/>  });<br/>  const [inputs] = useState({});<br/>  const [inputUiState, setInputUiState] = useState({});<br/>  const [originalValues] = useState({});</span><span id="ced2" class="mv ku it ks b gy np nm l nn no">const validationRuntimeMap = useRef(new Map());</span><span id="6665" class="mv ku it ks b gy np nm l nn no">const validateAll = async eventType =&gt; {<br/>    const promises = [];<br/>    let newUiState = { ...uiState };</span><span id="11a3" class="mv ku it ks b gy np nm l nn no">Object.keys(validators).forEach(async field =&gt; {<br/>      promises.push(<br/>        runValidators({<br/>          field,<br/>          validators: validators[field],<br/>          eventType,<br/>          value: inputs[field].value,<br/>          inputValues<br/>        })<br/>      );<br/>    });</span><span id="ccf5" class="mv ku it ks b gy np nm l nn no">newUiState = {<br/>      ...newUiState,<br/>      isValidating: true<br/>    };<br/>    setUiState(newUiState);</span><span id="4eba" class="mv ku it ks b gy np nm l nn no">const results = await Promise.all(promises).catch(() =&gt; {<br/>      // Do nothing, validation library handles errors.<br/>    });<br/>    results.forEach(result =&gt; {<br/>      formValidity[result.field] = result;<br/>    });</span><span id="fe7e" class="mv ku it ks b gy np nm l nn no">setUiState({ ...newUiState, isValidating: false });<br/>  };</span><span id="2187" class="mv ku it ks b gy np nm l nn no">const onSubmit = async (evt, props) =&gt; {<br/>    evt.preventDefault();<br/>    let newUiState = { ...uiState };<br/>    try {<br/>      await validateAll(validateInputEvents.onSubmit, evt.timeStamp);<br/>      const isFormValid = !Object.keys(formValidity).some(<br/>        field =&gt; !formValidity[field].valid<br/>      );</span><span id="6bdb" class="mv ku it ks b gy np nm l nn no">newUiState = {<br/>        ...newUiState,<br/>        isSubmitting: true,<br/>        isValid: isFormValid<br/>      };<br/>      setUiState(newUiState);<br/>      if (props.onSubmit) {<br/>        await props.onSubmit({ evt, inputValues });<br/>      }<br/>    } catch (e) {<br/>      setUiState({ ...newUiState, isSubmitting: false });<br/>    } finally {<br/>      setUiState({ ...newUiState, isSubmitting: false });<br/>    }<br/>  };</span><span id="3774" class="mv ku it ks b gy np nm l nn no">const getFormProps = (props = {}) =&gt; ({<br/>    ...defaultFormProps,<br/>    ...props,<br/>    onSubmit: evt =&gt; {<br/>      onSubmit(evt, props);<br/>    }<br/>  });</span><span id="79a8" class="mv ku it ks b gy np nm l nn no">const onInputChange = ({ event, id, value }) =&gt; {<br/>    inputValues[id] = value;<br/>    setInputUiState({<br/>      ...inputUiState,<br/>      [id]: { ...inputUiState[id], pristine: value === originalValues[id] }<br/>    });</span><span id="e863" class="mv ku it ks b gy np nm l nn no">runInputValidations({<br/>      id,<br/>      value,<br/>      eventType: validateInputEvents.onChange,<br/>      timeStamp: event.timeStamp<br/>    });<br/>  };</span><span id="1adf" class="mv ku it ks b gy np nm l nn no">const isValidatorAlreadyRunning = (id, value) =&gt;<br/>    formValidity[id] &amp;&amp;<br/>    formValidity[id].isValidating &amp;&amp;<br/>    formValidity[id].value === value;</span><span id="2bb2" class="mv ku it ks b gy np nm l nn no">// Discard oldest async validations on a given input<br/>  const isCurrentValidationRunLatest = (runtimeMap, id, timeStamp) =&gt;<br/>    runtimeMap.get(id) === undefined || runtimeMap.get(id) &lt;= timeStamp;</span><span id="8aeb" class="mv ku it ks b gy np nm l nn no">const runInputValidations = async ({ id, value, eventType, timeStamp }) =&gt; {<br/>    validationRuntimeMap.current.set(id, timeStamp);<br/>    const filteredValidators = validators[id].filter(validator =&gt; {<br/>      return validator.when.some(whenItem =&gt; whenItem === eventType);<br/>    });<br/>    if (filteredValidators.length === 0) return;</span><span id="3c03" class="mv ku it ks b gy np nm l nn no">if (validators[id]) {<br/>      const isCurrentRunLatest = () =&gt;<br/>        isCurrentValidationRunLatest(<br/>          validationRuntimeMap.current,<br/>          id,<br/>          timeStamp<br/>        );</span><span id="2124" class="mv ku it ks b gy np nm l nn no">if (isValidatorAlreadyRunning(id, value)) {<br/>        // No need to do anything at this point since validator is already running,<br/>        return;<br/>      }<br/>      if (!isCurrentRunLatest()) return;</span><span id="2478" class="mv ku it ks b gy np nm l nn no">setFormValidity(current =&gt; ({<br/>        ...current,<br/>        [id]: { isValidating: true, value }<br/>      }));</span><span id="a888" class="mv ku it ks b gy np nm l nn no">if (!isCurrentRunLatest()) return;</span><span id="c017" class="mv ku it ks b gy np nm l nn no">if (!isCurrentRunLatest()) return;</span><span id="472e" class="mv ku it ks b gy np nm l nn no">setFormValidity(current =&gt; ({<br/>        ...current,<br/>        [id]: { ...current[id], isValidating: true, value }<br/>      }));</span><span id="d1b5" class="mv ku it ks b gy np nm l nn no">if (!isCurrentRunLatest()) return;</span><span id="81da" class="mv ku it ks b gy np nm l nn no">try {<br/>        const validationResults = await runValidators({<br/>          field: id,<br/>          validators: validators[id],<br/>          eventType: eventType,<br/>          value,<br/>          runId: timeStamp,<br/>          inputValues<br/>        });</span><span id="fcb4" class="mv ku it ks b gy np nm l nn no">if (!isCurrentRunLatest()) return;</span><span id="8f4b" class="mv ku it ks b gy np nm l nn no">setFormValidity(current =&gt; ({ ...current, [id]: validationResults }));<br/>      } catch {<br/>        // Do nothing, validation library handles errors<br/>      }<br/>    }<br/>  };</span><span id="af0a" class="mv ku it ks b gy np nm l nn no">const onInputBlur = async ({ event, id, value }) =&gt; {<br/>    runInputValidations({<br/>      id,<br/>      value,<br/>      eventType: validateInputEvents.onBlur,<br/>      timeStamp: event.timeStamp<br/>    });<br/>  };</span><span id="0a76" class="mv ku it ks b gy np nm l nn no">const onInputFocus = ({ event, id }) =&gt; {<br/>    setInputUiState({<br/>      ...inputUiState,<br/>      [id]: { ...inputUiState[id], visited: true }<br/>    });<br/>  };</span><span id="dbdc" class="mv ku it ks b gy np nm l nn no">const isBlurWithinRadioGroup = (event, id) =&gt;<br/>    event.relatedTarget &amp;&amp; event.relatedTarget.getAttribute("name") === id;</span><span id="be8c" class="mv ku it ks b gy np nm l nn no">const onRadioGroupBlur = async ({ id, value, event }) =&gt; {<br/>    if (isBlurWithinRadioGroup(event, id)) return;</span><span id="37a8" class="mv ku it ks b gy np nm l nn no">runInputValidations({<br/>      id,<br/>      value,<br/>      eventType: validateInputEvents.onBlur,<br/>      timeStamp: event.timeStamp<br/>    });<br/>  };</span><span id="0109" class="mv ku it ks b gy np nm l nn no">const addInput = ({<br/>    id,<br/>    value,<br/>    validators: inputValidators = [],<br/>    inputProps = {<br/>      onChange: onInputChange,<br/>      onBlur: onInputBlur,<br/>      onFocus: onInputFocus<br/>    }<br/>  }) =&gt; {<br/>    originalValues[id] =<br/>      typeof originalValues[id] === "undefined" ? value : originalValues[id];<br/>    inputValues[id] =<br/>      typeof inputValues[id] === "undefined" ? value : inputValues[id];</span><span id="3e18" class="mv ku it ks b gy np nm l nn no">const input = createInput({<br/>      id,<br/>      value: inputValues[id],<br/>      props: inputProps<br/>    });<br/>    inputs[id] = input;<br/>    inputUiState[id] = inputUiState[id] || {<br/>      pristine: true,<br/>      visited: false<br/>    };<br/>    validators[id] = inputValidators;<br/>    return input;<br/>  };</span><span id="d177" class="mv ku it ks b gy np nm l nn no">const addRadioGroup = ({ id, value, validators = [], inputProps }) =&gt; {<br/>    const input = addInput({<br/>      id,<br/>      value,<br/>      validators,<br/>      inputProps: {<br/>        ...inputProps,<br/>        onChange: onInputChange,<br/>        onBlur: onRadioGroupBlur,<br/>        onFocus: onInputFocus<br/>      }<br/>    });<br/>    return input;<br/>  };</span><span id="b4d5" class="mv ku it ks b gy np nm l nn no">const removeInput = id =&gt; {<br/>    delete inputs[id];<br/>    delete inputUiState[id];<br/>    delete validators[id];<br/>    delete formValidity[id];<br/>    delete inputValues[id];<br/>    delete originalValues[id];</span><span id="1866" class="mv ku it ks b gy np nm l nn no">setInputUiState(inputUiState);<br/>  };</span><span id="f1c0" class="mv ku it ks b gy np nm l nn no">return {<br/>    id,<br/>    getFormProps,<br/>    formValidity,<br/>    uiState,<br/>    inputs,<br/>    inputValues,<br/>    inputUiState,<br/>    api: {<br/>      addInput,<br/>      addRadioGroup,<br/>      removeInput<br/>    }<br/>  };<br/>};</span></pre><h1 id="4fae" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">测试更新</h1><p id="d391" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">作为此次更新的一部分，对测试进行了许多更改。在我的测试中，我没有始终如一地使用<code class="fe kp kq kr ks b">act()</code>。我从threepointone的<a class="ae ko" href="https://github.com/threepointone/react-act-examples/blob/master/sync.md" rel="noopener ugc nofollow" target="_blank"> react-act-examples </a>中学到了一些好的技巧，帮助我提高了对<code class="fe kp kq kr ks b">act()</code>的使用。</p><p id="6535" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的钩子测试中，我在嘲笑计时器。在我的一些测试中，时间的流逝会更新状态。例如，模拟长时间运行验证的异步测试使用setTimeout，因此验证库将首先将<code class="fe kp kq kr ks b">useForm.uiState</code>验证状态设置为<code class="fe kp kq kr ks b">isValidating</code>，这是我想要测试的，然后一旦时间过去，<code class="fe kp kq kr ks b">uiState.isValidating</code>将被设置为<code class="fe kp kq kr ks b">false</code>，并且验证结果被设置。</p><p id="c323" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我对<code class="fe kp kq kr ks b">jest.runAllTimers</code>的调用修改了钩子的状态，任何时候钩子的状态被修改，你调用的函数应该被包装在一个动作中，即<code class="fe kp kq kr ks b">act(() =&gt; jest.runAllTimers());</code>。这可以减轻终端中的测试警告，如下图所示:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/6e106696e0382521d5cb332fe5cbdc38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XfcXGHlae2GGiC9O.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">由于jest.runAllTimers()修改挂钩状态但未在act()内调用，导致测试警告</figcaption></figure><pre class="lw lx ly lz gt nh ks ni nj aw nk bi"><span id="2e73" class="mv ku it ks b gy nl nm l nn no">it("should be able to add an input with valid asynchronous validation and get correct formValidity input state", async () =&gt; {<br/>    const customValidator = createValidator({<br/>      validateFn: async ({ value }) =&gt;<br/>        await new Promise(resolve =&gt; {<br/>          setTimeout(() =&gt; resolve(true), 1);<br/>        }),<br/>      error: "CUSTOM_ASYNC_ERROR"<br/>    });</span><span id="091a" class="mv ku it ks b gy np nm l nn no">const { result, waitForNextUpdate } = renderHook(() =&gt;<br/>      useForm({ id: "test" })<br/>    );</span><span id="27b3" class="mv ku it ks b gy np nm l nn no">act(() =&gt; {<br/>      result.current.api.addInput({<br/>        id: "test",<br/>        value: "",<br/>        validators: [{ ...customValidator, when: [validateInputEvents.onBlur] }]<br/>      });<br/>    });<br/>    act(<br/>      async () =&gt;<br/>        await result.current.inputs.test.getInputProps().onBlur({<br/>          preventDefault: noop,<br/>          target: {<br/>            value: ""<br/>          }<br/>        })<br/>    );<br/>    expect(result.current.formValidity).toEqual({<br/>      test: { isValidating: true, value: "" }<br/>    });</span><span id="5c97" class="mv ku it ks b gy np nm l nn no">act(() =&gt; jest.runAllTimers());<br/>    await waitForNextUpdate();</span><span id="1ddf" class="mv ku it ks b gy np nm l nn no">expect(result.current.formValidity).toEqual({<br/>      test: { field: "test", valid: true }<br/>    });<br/>  });</span></pre><h1 id="0c00" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">摘要</h1><p id="f5bb" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">在这篇文章中，我们重构了我们的解决方案以支持动态表单，并创建了一个动态表单示例。</p><p id="0f09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在后面的部分中，我们将讨论其他主题，比如减少样板文件、从JSON模式添加验证、承诺取消、去抖动、钩子性能考虑和其他设计优化。</p><p id="64df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，该库可能已经“足够好”可以用于生产了😃。在开始自己制作表单库之前，请记住制作一个“足够好”的表单库需要付出的努力和思考！</p><p id="2455" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除非您有一个不需要验证逻辑的极其简单的表单，是的，您可以用React拼凑一个表单，但是它会非常有限。一旦你需要越过简单的表单，使用表单库。否则，你可能没有充分利用你的时间。除非你是出于自己的学习目的，当然，我总是建议通过开发你感兴趣的东西来学习。</p><p id="a8b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有任何问题、反馈或建议，或者您希望我介绍本系列中的其他内容，请告诉我。</p></div></div>    
</body>
</html>