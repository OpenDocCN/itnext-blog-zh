<html>
<head>
<title>A Vue pattern for idiomatic, performant component registration you might not know about</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个您可能不知道的用于惯用的、高性能的组件注册的Vue模式</h1>
<blockquote>原文：<a href="https://itnext.io/vue-a-pattern-for-idiomatic-performant-component-registration-you-might-not-know-about-9f3c091846f5?source=collection_archive---------2-----------------------#2018-07-28">https://itnext.io/vue-a-pattern-for-idiomatic-performant-component-registration-you-might-not-know-about-9f3c091846f5?source=collection_archive---------2-----------------------#2018-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="779e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">…利用Vue和Webpack的酷功能！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/89440570d2371eee388d08674363f216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XH9l-6x9SUlmGxPlZFaoIA.jpeg"/></div></div></figure><p id="a65b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你玩过Vue <strong class="kt ir">单个文件组件</strong>一点，你可能知道如何从另一个组件“调用”一个组件:</p><ol class=""><li id="8b12" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><code class="fe lw lx ly lz b">import</code>子组件。</li><li id="b816" class="ln lo iq kt b ku ma kx mb la mc le md li me lm ls lt lu lv bi translated">在父组件的<code class="fe lw lx ly lz b">components</code>对象上注册它。</li><li id="a064" class="ln lo iq kt b ku ma kx mb la mc le md li me lm ls lt lu lv bi translated">将组件添加到模板/渲染函数中。</li></ol><pre class="kg kh ki kj gt mf lz mg mh aw mi bi"><span id="007b" class="mj mk iq lz b gy ml mm l mn mo">&lt;template&gt;<br/>  &lt;some-random-thing /&gt;<br/>&lt;/template&gt;</span><span id="da36" class="mj mk iq lz b gy mp mm l mn mo">&lt;script&gt;<br/>import <strong class="lz ir">SomeRandomThing</strong> from './components/SomeRandomThing'</span><span id="0bb3" class="mj mk iq lz b gy mp mm l mn mo">export default {<br/>  components: {<br/>    <strong class="lz ir">SomeRandomThing</strong>,<br/>  },<br/>}<br/>&lt;/script&gt;</span></pre><p id="4253" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一种常见的模式，最终可能会变得乏味。在这篇短文中，我们将学习一种(或两种)避免重复的模式。我们还将免费改进我们的应用程序性能。</p><p id="661a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始吧！</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="8722" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想象一个<code class="fe lw lx ly lz b">Header</code>组件，它为我们的应用程序头保存信息和布局。现在想象一下，这些信息可能是用户相关的，也可能是公司相关的，这取决于……我不知道，一个设定值。随便啦。</p><p id="1611" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在想象我们有一个<code class="fe lw lx ly lz b">UserInfo</code>和<code class="fe lw lx ly lz b">CompanyInfo</code>组件。我们希望根据之前已经配置的设置值显示一个或另一个。</p><h1 id="f0b6" class="mx mk iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">版本1:好的方式</h1><p id="9376" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">这是我们上面概述的方法。</p><p id="2e18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这大概是所有人都会想到的“<em class="nt">默认</em>”方式(包括我！):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9ee8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没什么特别的。我们导入两个组件，注册它们，然后根据某个属性值显示一个或另一个组件。</p><p id="782c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能到处都在使用这种“模式”。虽然它本身没有什么问题，但我们可以做得更好。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="d47a" class="mx mk iq bd my mz nw nb nc nd nx nf ng jw ny jx ni jz nz ka nk kc oa kd nm nn bi translated">版本2: <component/>来援救了</h1><p id="1b52" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">Vue中有一个内置组件叫做<a class="ae ob" href="https://vuejs.org/v2/guide/components.html#Dynamic-Components" rel="noopener ugc nofollow" target="_blank">组件</a>。是的，试着在谷歌上搜索一下。</p><p id="f45b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个组件<code class="fe lw lx ly lz b">&lt;component /&gt;</code>充当另一个组件的占位符，并接受一个特殊的<code class="fe lw lx ly lz b">:is</code>道具，该道具带有它应该呈现的组件的名称。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="75ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，现在我们如何用所需组件的名称创建一个计算值，从而移除模板中的<code class="fe lw lx ly lz b">v-if/v-else</code>逻辑，支持全能的<code class="fe lw lx ly lz b">&lt;component /&gt;</code>。我们甚至可以像往常一样传递一些道具。</p><p id="4917" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是不是很酷？</p><p id="e60f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，确实是。但是那里仍然有一个<strong class="kt ir">的主要痛点。</strong></p><p id="70b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们必须导入并注册<code class="fe lw lx ly lz b">:is</code>属性的所有有效值。我们必须导入并注册<code class="fe lw lx ly lz b">UserInfo</code>和<code class="fe lw lx ly lz b">CompanyInfo</code>。</p><p id="572f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除非有人允许我们动态地导入所有这些组件，这样我们就不必导入和注册它们了…</p><p id="3ad4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…哦，等等！</p><p id="4455" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你是说“<em class="nt">动态导入</em>”吗？</p><p id="81d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们抓住你了。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="539c" class="mx mk iq bd my mz nw nb nc nd nx nf ng jw ny jx ni jz nz ka nk kc oa kd nm nn bi translated">版本3:动态导入+ <code class="fe lw lx ly lz b">&lt;component /&gt;</code>(还有免费的代码拆分！)</h1><p id="c5ba" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">让我们看看<a class="ae ob" href="https://webpack.js.org/guides/code-splitting/#dynamic-imports" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">动态导入</strong> </a>和<code class="fe lw lx ly lz b">&lt;component /&gt;</code>如何一起玩:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="aa95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用上面的解决方案，<strong class="kt ir"> import </strong>变成了一个返回承诺的函数。如果承诺解决了(也就是说，没有任何东西被破坏和拒绝)，它将在<strong class="kt ir">运行时</strong>加载期望的模块。</p><p id="c92d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，这里发生了什么？我们仍然使用我们的新朋友<code class="fe lw lx ly lz b">&lt;component/&gt;</code>，但是这次我们提供的不是一个简单的字符串，而是一个完整的组件对象。什么？</p><p id="ac35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如文档中所述，<code class="fe lw lx ly lz b">:is</code>道具可以包含:</p><ul class=""><li id="30ab" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm oc lt lu lv bi translated">注册组件的名称，或</li><li id="6573" class="ln lo iq kt b ku ma kx mb la mc le md li me lm oc lt lu lv bi translated"><strong class="kt ir">组件的选项对象</strong></li></ul><p id="f2ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">砰！一个“组件的选项对象”。这正是我们需要的！</p><p id="17ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意我们是如何避免导入和注册组件的，因为我们的动态<code class="fe lw lx ly lz b">import</code>是在运行时❤这样做的。</p><p id="9b69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">官方文档中有更多关于Vue和动态导入<a class="ae ob" href="https://vuejs.org/v2/guide/components-dynamic-async.html" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h2 id="bc54" class="mj mk iq bd my od oe dn nc of og dp ng la oh oi ni le oj ok nk li ol om nm on bi translated">抓到你了</h2><p id="7df6" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">注意，我们在动态导入语句的之外访问我们的属性<code class="fe lw lx ly lz b">this.isCompany</code> <strong class="kt ir">。</strong></p><p id="0212" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是强制性的，因为否则Vue不能发挥它的反应魔法，也不能在道具改变时更新我们的计算值。试试看，你会明白我的意思。</p><p id="8c25" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过在动态导入之外访问我们的属性(通过创建一个简单的<code class="fe lw lx ly lz b">name</code>变量), Vue知道我们的<code class="fe lw lx ly lz b">componentInstance</code>计算属性“依赖于”<code class="fe lw lx ly lz b">this.isCompany</code>,所以当我们的属性改变时，它将有效地触发重新评估。</p><h2 id="316a" class="mj mk iq bd my od oe dn nc of og dp ng la oh oi ni le oj ok nk li ol om nm on bi translated">提醒一句<em class="oo">(8月4日更新)</em></h2><p id="6326" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">当使用动态导入时，Webpack将(在构建时)<strong class="kt ir">为每个匹配导入函数</strong>中表达式的文件创建一个块文件。</p><p id="7317" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的例子有点做作，但是想象一下我的<code class="fe lw lx ly lz b">/components</code>文件夹包含800个组件。那么Webpack将创建800个块。</p><p id="0c98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为这不是我们要找的(呵)，确保你<a class="ae ob" href="https://twitter.com/TheLarkInn/status/1025918613557981184" rel="noopener ugc nofollow" target="_blank">写更严格的表达式和/或遵循文件夹惯例</a>。例如，我倾向于将我想要拆分的组件分组到一个名为<code class="fe lw lx ly lz b">/components/chunks</code>或<code class="fe lw lx ly lz b">/components/bundles</code>的文件夹中，所以我知道哪些组件是Webpack拆分。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="b20b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了这个<em class="nt">gotches</em>，我们实现了一个<strong class="kt ir">惯用的</strong>，<strong class="kt ir">更简洁的</strong>模式。它有一个奇妙的副作用，使它真正发光:</p><h2 id="483e" class="mj mk iq bd my od oe dn nc of og dp ng la oh oi ni le oj ok nk li ol om nm on bi translated">我们的“条件”组件现在是代码分离的！</h2><p id="49d5" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">如果你像这样<code class="fe lw lx ly lz b">npm run build</code>一个组件，你会注意到Webpack会为<code class="fe lw lx ly lz b">UserInfo.vue</code>创建一个特定的包文件，为<code class="fe lw lx ly lz b">CompanyInfo.vue</code>创建另一个包文件。默认情况下，Webpack <a class="ae ob" href="https://webpack.js.org/guides/code-splitting/#dynamic-imports" rel="noopener ugc nofollow" target="_blank">会这样做</a>。网络包是纯爱❤.</p><p id="0e94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很棒，因为我们的用户直到我们的应用程序请求它们的时候才会加载这些包，因此减少了我们最初的包大小，提高了我们应用程序的性能。</p><p id="4ace" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ob" href="https://webpack.js.org/guides/code-splitting/" rel="noopener ugc nofollow" target="_blank">代码拆分</a>dope。确保你熟悉它，因为如果你还没有使用它，你可以大大改善你的应用程序。去吧！</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="0351" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，拿着这个代码沙箱，你可以随意使用这三种解决方案:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op nv l"/></div></figure></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="7b7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">顺便说一下，您甚至可以使用magic comments为动态导入定制包名和加载策略。</p><p id="b183" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想了解更多关于代码分割、动态导入以及为什么你应该关心的信息，请听听来自Webpack核心团队的唤醒者<a class="oq or ep" href="https://medium.com/u/393110b0b9e4?source=post_page-----9f3c091846f5--------------------------------" rel="noopener" target="_blank"> Sean T. Larkin </a>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os nv l"/></div></figure><p id="d3ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望有帮助！</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="8cc5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nt">本帖刊登在</em><a class="ae ob" href="https://www.getrevue.co/profile/vuenewsletter/issues/105-vue-js-sprint-sneak-peek-get-the-vuevixens-scholarship-for-vue-js-london-125646" rel="noopener ugc nofollow" target="_blank"><em class="nt">【105期】官方Vue.js简讯</em> </a> <em class="nt"> </em>💃</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="4d96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我刚刚创办了自己的时事通讯！随意 <a class="ae ob" href="https://buttondown.email/afontcu" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">订阅这里</strong> </a> <strong class="kt ir">。</strong></p></div></div>    
</body>
</html>