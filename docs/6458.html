<html>
<head>
<title>Native-image with Micronaut</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Micronaut的原生图像</h1>
<blockquote>原文：<a href="https://itnext.io/native-image-micronaut-58800097cb4f?source=collection_archive---------7-----------------------#2021-11-21">https://itnext.io/native-image-micronaut-58800097cb4f?source=collection_archive---------7-----------------------#2021-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/774298bbb8fc679614a7ef9c491b63fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urGaBO1_4SVQPFp2PRSPRA.jpeg"/></div></div></figure><p id="68c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上周，我写了一个使用Spring Boot 查询漫威API <a class="ae kw" href="https://blog.franke.ch/native/spring-boot/" rel="noopener ugc nofollow" target="_blank">的本地web应用。本周，我想用Micronaut框架做同样的事情。</a></p><h1 id="e98d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建新项目</h1><p id="52b2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Micronaut提供了两个选项来创建新项目:</p><ol class=""><li id="5329" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">一个<a class="ae kw" href="https://micronaut.io/launch" rel="noopener ugc nofollow" target="_blank">网络用户界面</a>:</li></ol><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/f5461382ea1c493d2d568bc63cfa7bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VsDWaQ_JXeR702ttJaj8g.jpeg"/></div></div></figure><p id="2208" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至于Spring Initializr，它提供了几个特性:</p><ul class=""><li id="f7af" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mo mg mh mi bi translated">在下载之前预览项目</li><li id="265c" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mo mg mh mi bi translated">共享配置</li><li id="59e9" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mo mg mh mi bi translated">一个API</li></ul><p id="d7bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢你能检查增加的特性对POM的影响。</p><p id="661d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.一个<a class="ae kw" href="https://docs.micronaut.io/1.3.3/guide/index.html#buildCLI" rel="noopener ugc nofollow" target="_blank">命令行界面</a>:</p><p id="cd3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与webapp并行，您可以在不同的系统上安装CLI。然后你可以使用<code class="fe mu mv mw mx b">mn</code>命令来创建新的项目。</p><p id="50d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这两个选项中，您可以配置以下参数:</p><ul class=""><li id="e989" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mo mg mh mi bi translated">使用Kotlin DSL的构建工具Maven、Gradle或Gradle</li><li id="f6c7" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mo mg mh mi bi translated">语言，Java、Kotlin或Groovy</li><li id="872b" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mo mg mh mi bi translated">Micronaut的版本</li><li id="daf2" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mo mg mh mi bi translated">一些元数据</li><li id="bd89" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mo mg mh mi bi translated">属国</li></ul><p id="32b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序的代码在<a class="ae kw" href="https://github.com/micronaut-projects/micronaut-starter" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。你可以克隆和改编它，但据我所知，它在设计时并没有考虑扩展(还没有？).</p><h1 id="f00f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Bean配置</h1><p id="dd6a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Micronaut的bean配置依赖于<a class="ae kw" href="http://javax-inject.github.io/javax-inject/" rel="noopener ugc nofollow" target="_blank"> JSR 330 </a>。JSR在<code class="fe mu mv mw mx b">jakarta.inject</code>包中定义了几个注解<em class="my">，例如</em>、<code class="fe mu mv mw mx b">@Singleton</code>和<code class="fe mu mv mw mx b">@Inject</code>。开发人员使用它们，服务提供商实现规范。</p><p id="110a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mu mv mw mx b">@Singleton</code>和它的兄弟<code class="fe mu mv mw mx b">@ApplicationScoped</code>应该用在我们的代码上。我们的示例应用程序需要创建一个<code class="fe mu mv mw mx b">java.security.MessageDigest</code>的实例，它不能被注释。为了解决这个问题，JSR 330提供了<code class="fe mu mv mw mx b">@Factory</code>注释:</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="e37f" class="nd ky iq mx b gy ne nf l ng nh">@Factory                                                  // 1<br/>class BeanFactory {<br/><br/>  @Singleton                                              // 2<br/>  fun messageDigest() = MessageDigest.getInstance("MD5")  // 3<br/>}</span></pre><ol class=""><li id="afef" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">生成Bean的类</li><li id="e3b7" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">常规范围注释</li><li id="e755" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">生成消息摘要单例</li></ol><p id="8f86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Micronaut还提供了自动发现机制。可惜在科特林行不通。您需要指向Micronaut应该明确扫描的包:</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="0f16" class="nd ky iq mx b gy ne nf l ng nh">fun main(args: Array&lt;String&gt;) {<br/>    Micronaut.build().args(*args)<br/>             .packages("ch.frankel.blog")<br/>             .start()<br/>}</span></pre><h1 id="e9cf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">控制器配置</h1><p id="3cd2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Micronaut从Spring复制了<code class="fe mu mv mw mx b">@Controller</code>注释。你可以用同样的方法使用它。同样，用相关的HTTP方法注释来注释函数。</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="4cef" class="nd ky iq mx b gy ne nf l ng nh">@Controller<br/>class MarvelController() {<br/><br/>    @Get<br/>    fun characters() = HttpResponse.accepted&lt;Unit&gt;()<br/>}</span></pre><h1 id="3e53" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">非阻塞HTTP客户端</h1><p id="d515" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Micronaut提供了两个HTTP客户端:一个声明式客户端和一个低级客户端。两个都是不堵的。</p><p id="6464" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">声明式客户端用于简单的用例，而低级客户端用于更复杂的用例。传递参数属于复杂的范畴，所以我选择了底层的。以下是它的API示例:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/07ae6957c2bcbbaed1e126bdc6ec100a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JX_dJMqJZ6322AEbQDnMrg.png"/></div></div></figure><p id="3aa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用法很简单:</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="5a43" class="nd ky iq mx b gy ne nf l ng nh">val request = HttpRequest.GET&lt;Unit&gt;("https://gateway.marvel.com:443/v1/public/characters")<br/>client.retrieve(request, String::class.java)</span></pre><p id="737e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，我们应该从对应用程序的请求中获取参数，并将它们传播到我们对漫威API的请求中。Micronaut可以使用第一部分的<code class="fe mu mv mw mx b">@QueryValue</code>注释自动将这样的查询参数绑定到方法参数。</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="4c77" class="nd ky iq mx b gy ne nf l ng nh">@Get<br/>fun characters(<br/>    @QueryValue limit: String?,<br/>    @QueryValue offset: String?,<br/>    @QueryValue orderBy: String?<br/>)</span></pre><p id="67ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不可能使用Kotlin的字符串插值，因为这些参数是可选的。幸运的是，Micronaut提供了一个<code class="fe mu mv mw mx b">UriBuilder</code>抽象，它遵循构建器模式原则。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/7a949970d4155ab5489511b023b77cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*He-hbSBamzzyN3agQhSn7A.png"/></div></div></figure><p id="f6bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以这样使用它:</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="0ca5" class="nd ky iq mx b gy ne nf l ng nh">val uri = UriBuilder<br/>            .of("${properties.serverUrl}/v1/public/characters")<br/>            .queryParamsWith(<br/>                mapOf(<br/>                    "limit" to limit,<br/>                    "offset" to offset,<br/>                    "orderBy" to orderBy<br/>                )<br/>            ).build()<br/><br/>fun UriBuilder.queryParamsWith(params: Map&lt;String, String?&gt;) = apply {<br/>    params.entries<br/>        .filter { it.value != null }<br/>        .forEach { queryParam(it.key, it.value) }<br/>}</span></pre><h1 id="8b1f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">参数化</h1><p id="cbbf" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">像Spring一样，Micronaut可以将应用程序属性绑定到Kotlin数据类。在Micronaut中，该文件被命名为<code class="fe mu mv mw mx b">application.yml</code>。文件已经存在并且包含<code class="fe mu mv mw mx b">micronaut.application.name</code>键。我们只需要添加额外的数据。我选择将它放在同一个父键下，但是没有这样的约束。</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="0ab5" class="nd ky iq mx b gy ne nf l ng nh">micronaut:<br/>  application:<br/>    name: nativeMicronaut<br/>    marvel:<br/>      serverUrl: https://gateway.marvel.com:443</span></pre><p id="c300" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了绑定，我们需要两个注释的帮助:</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="413e" class="nd ky iq mx b gy ne nf l ng nh">@ConfigurationProperties("micronaut.application.marvel")   //1<br/>data class MarvelProperties<br/>                       @ConfigurationInject constructor(   //2<br/>    val serverUrl: String,<br/>    val apiKey: String,<br/>    val privateKey: String<br/>)</span></pre><ol class=""><li id="1a88" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">将属性类绑定到属性文件前缀</li><li id="525e" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">允许使用数据类。需要在构造函数上设置<code class="fe mu mv mw mx b">@ConfigurationInject</code>:这表明团队可以在Micronaut中改进Kotlin的集成。</li></ol><h1 id="20e7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试</h1><p id="85a7" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Micronaut测试基于<code class="fe mu mv mw mx b">@MicronautTest</code>注释。</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="5f4c" class="nd ky iq mx b gy ne nf l ng nh">@MicronautTest<br/>class MicronautNativeApplicationTest</span></pre><p id="6fb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将上述数据类的属性定义为不可空的字符串。因此，我们需要在测试开始时传递这个值。为此，Micronaut提供了<code class="fe mu mv mw mx b">TestPropertyProvider</code>接口:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/14ced2a3559a6c17e03621b3886c4d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*lwL9S9cMTqenj5DK1i_cMA.png"/></div></figure><p id="0850" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以利用它来传递属性值:</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="e9a0" class="nd ky iq mx b gy ne nf l ng nh">@MicronautTest<br/>class MicronautNativeApplicationTest : TestPropertyProvider {<br/><br/>    override fun getProperties() = mapOf(<br/>        "micronaut.application.marvel.apiKey" to "dummy",<br/>        "micronaut.application.marvel.privateKey" to "dummy",<br/>        "micronaut.application.marvel.serverUrl" to "defined-later"<br/>    )<br/>}</span></pre><p id="2e33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是设置Testcontainers。为流行的容器提供了现成的集成，<em class="my">，例如</em>、Postgres，但是没有提供与模拟服务器的集成。我们必须编写代码来处理它。</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="403f" class="nd ky iq mx b gy ne nf l ng nh">@MicronautTest<br/>@Testcontainers<br/>@TestInstance(TestInstance.Lifecycle.PER_CLASS)             // 1<br/>class MicronautNativeApplicationTest {<br/><br/>    companion object {<br/><br/>        @Container<br/>        val mockServer = MockServerContainer(<br/>            DockerImageName.parse("mockserver/mockserver")<br/>        ).apply { start() }                                 // 2<br/>    }<br/>}</span></pre><ol class=""><li id="7c7c" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">默认情况下，为每个测试方法创建一个服务器。我们希望每个测试班都有一个。</li><li id="d03c" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">不要忘记显式启动它！</li></ol><p id="8142" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们可以注入客户端和嵌入式服务器:</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="ba10" class="nd ky iq mx b gy ne nf l ng nh">@MicronautTest<br/>@Testcontainers<br/>@TestInstance(TestInstance.Lifecycle.PER_CLASS)<br/>class MicronautNativeApplicationTest : TestPropertyProvider {<br/><br/>    @Inject<br/>    private lateinit var client: HttpClient                     // 1<br/><br/>    @Inject<br/>    private lateinit var server: EmbeddedServer                 // 2<br/><br/>    companion object {<br/><br/>        @Container<br/>        val mockServer = MockServerContainer(<br/>            DockerImageName.parse("mockserver/mockserver")<br/>        ).apply { start() }<br/>    }<br/><br/>    override fun getProperties() = mapOf(<br/>        "micronaut.application.marvel.apiKey" to "dummy",<br/>        "micronaut.application.marvel.privateKey" to "dummy",<br/>        "micronaut.application.marvel.serverUrl" to<br/>            "http://${mockServer.containerIpAddress}:${mockServer.serverPort}" // 3<br/>    )<br/><br/>    @Test<br/>    fun `should deserialize JSON payload from server and serialize it back again`() {<br/>        val mockServerClient = MockServerClient(<br/>            mockServer.containerIpAddress,                      // 3<br/>            mockServer.serverPort                               // 3<br/>        )<br/>        val sample = this::class.java.classLoader.getResource("sample.json")<br/>                                                 ?.readText()  // 4<br/><br/>        mockServerClient.`when`(<br/>            HttpRequest.request()<br/>                .withMethod("GET")<br/>                .withPath("/v1/public/characters")<br/>        ).respond(<br/>            HttpResponse()<br/>                .withStatusCode(200)<br/>                .withHeader("Content-Type", "application/json")<br/>                .withBody(sample)<br/>        )<br/><br/>        // With `retrieve` get the body and assert on it<br/>        val body = client.toBlocking().retrieve(                // 5<br/>            server.url.toExternalForm(),<br/>            Model::class.java                                   // 6<br/>        )<br/>        assertEquals(1, body.data.count)<br/>        assertEquals("Anita Blake", body.data.results.first().name)<br/>    }<br/>}</span></pre><ol class=""><li id="bc85" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">注入<em class="my">反应式</em>客户端</li><li id="e126" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">注入嵌入式服务器，<em class="my">，即</em>，应用程序</li><li id="8e34" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">从模拟服务器检索IP和端口</li><li id="b74a" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">使用Kotlin读取样本文件——没有像Spring中那样提供抽象</li><li id="d172" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">我们需要阻止，因为客户是被动的</li><li id="1fc6" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">没有JSON断言API。最简单的方法是在一个<code class="fe mu mv mw mx b">Model</code>类中反序列化，然后断言对象的状态。</li></ol><h1 id="3c8e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Docker和GraalVM集成</h1><p id="5677" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">和Spring一样，Micronaut提供了两种创建原生映像的方法:</p><ol class=""><li id="6f26" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">在本地机器上。<br/>它需要本地GraalVM安装<strong class="ka ir">和</strong> <code class="fe mu mv mw mx b">native-image</code>。<br/> <code class="fe mu mv mw mx b">mvn package -Dpackaging=native-image</code></li><li id="4fe3" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">在码头。它需要本地Docker安装。<br/> <code class="fe mu mv mw mx b">mvn package -Dpackaging=docker-native<br/></code>注意，如果您不使用GraalVM JDK，您需要激活GraalVM概要文件。<br/>T3】</li></ol><p id="e156" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用第二种方法，结果如下:</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="7bdd" class="nd ky iq mx b gy ne nf l ng nh">REPOSITORY        TAG       IMAGE ID         CREATED          SIZE<br/>native-micronaut  latest    898f73fb44b0     33 seconds ago   85.3MB</span></pre><p id="0eee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些层如下:</p><pre class="mk ml mm mn gt mz mx na nb aw nc bi"><span id="2415" class="nd ky iq mx b gy ne nf l ng nh">┃ ● Layers ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br/>Cmp   Size  Command<br/>    5.6 MB  FROM e6b8cc5e282829d                                  #1<br/>     12 MB  RUN /bin/sh -c ALPINE_GLIBC_BASE_URL="https://github. #2<br/>    3.5 MB  |1 EXTRA_CMD=apk update &amp;&amp; apk add libstdc++ /bin/sh  #3<br/>     64 MB  #(nop) COPY file:106f24caede12d6d28c6c90d9a3ae33f7848  #4</span></pre><ol class=""><li id="fbed" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">父图像</li><li id="18f3" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">阿尔卑斯山glibc</li><li id="01c6" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">附加包</li><li id="286a" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mf mg mh mi bi translated">我们的本地二进制</li></ol><h1 id="ed30" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">其他评论</h1><p id="3653" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我对Spring Boot很熟悉，对麦克诺特就更不熟悉了。<br/>下面是几个杂七杂八的评论。</p><ul class=""><li id="4769" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mo mg mh mi bi translated">Maven包装器:<br/>当创建一个新的Maven项目时，Micronaut还会配置<a class="ae kw" href="https://github.com/takari/maven-wrapper" rel="noopener ugc nofollow" target="_blank"> Maven包装器</a>。</li><li id="b602" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mo mg mh mi bi translated">文档矩阵:<br/> Micronaut指南各提供一个配置矩阵。您选择了语言和构建工具，您将会以完全想要的方式阅读指南。</li></ul><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/d8d36cef9998c8eae5204a8ce9161d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dKcGHvf1kshPRjDoGOKvyw.jpeg"/></div></div></figure><p id="de48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望更多的多语言多平台框架文档能够提供这样的特性。</p><ul class=""><li id="6d09" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mo mg mh mi bi translated">可配置的打包:<br/> Micronaut将Maven的POM <code class="fe mu mv mw mx b">packaging</code>参数化，这样您就可以覆盖它，就像上面的原生映像生成一样。真是<em class="my">非常</em>聪明！这是我第一次碰到这种方法。当我创建这个项目时，我感到非常惊讶，所以(一开始)我删除了它。留着吧。</li><li id="2de2" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mo mg mh mi bi translated">代码生成:<br/>最后但同样重要的是，Micronaut在运行时绕过了传统的反射。为此，它会在编译时生成额外的代码。代价是较慢的构建时间和较快的运行时间。对于Kotlin，我发现了另一个问题。Micronaut使用<code class="fe mu mv mw mx b">kapt</code>生成附加代码。不幸的是，<code class="fe mu mv mw mx b">kapt</code>已经被推至<a class="ae kw" href="https://kotlinlang.org/docs/kapt.html" rel="noopener ugc nofollow" target="_blank">维护模式</a>。事实上，如果你使用的JDK版本高于8，你会在编译时看到警告。<br/>与IntelliJ的<code class="fe mu mv mw mx b">kapt</code>集成很差。虽然所有指南都提到如何配置它，<em class="my">，即</em>，启用注释处理，但它对我不起作用。我不得不使用命令行重新构建应用程序，以便能够查看更改。这使得开发生命周期变得更加缓慢。该团队正在努力争取KSP的支持，但这是一项长期的工作。</li></ul><h1 id="667f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="5f50" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Micronaut取得了与Spring Boot相同的结果。Docker图像的大小缩小了约20%。它也更简单，层次更少，并且基于Linux Alpine。</p><p id="5a9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kotlin与Micronaut合作，但感觉并不“自然”。如果你看重科特林的整体效益，你最好选择Spring Boot。否则，保持Micronaut，但支持Java，以避免挫折。</p><p id="b672" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常感谢Ivan Lopez对这篇文章的评论。</p><p id="ab52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的完整源代码可以在<a class="ae kw" href="https://github.com/ajavageek/micronaut-native" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上以Maven格式找到。</p><p id="541c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="f70e" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mo mg mh mi bi translated"><a class="ae kw" href="https://micronaut.io/launch" rel="noopener ugc nofollow" target="_blank">微机器人发射</a></li><li id="5b51" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mo mg mh mi bi translated"><a class="ae kw" href="https://docs.micronaut.io/3.1.3/guide/#beans" rel="noopener ugc nofollow" target="_blank">定义bean</a></li><li id="a107" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mo mg mh mi bi translated"><a class="ae kw" href="https://guides.micronaut.io/latest/micronaut-http-client-maven-kotlin.html" rel="noopener ugc nofollow" target="_blank"> Micronaut HTTP客户端</a></li><li id="e55d" class="ma mb iq ka b kb mp kf mq kj mr kn ms kr mt kv mo mg mh mi bi translated"><a class="ae kw" href="https://guides.micronaut.io/latest/micronaut-creating-first-graal-app-maven-kotlin.html" rel="noopener ugc nofollow" target="_blank">创建您的第一个微型应用程序</a></li></ul></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="7d41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="my">原载于</em> <a class="ae kw" href="https://blog.frankel.ch/native/micronaut/" rel="noopener ugc nofollow" target="_blank"> <em class="my">一个Java极客</em></a><em class="my">2021年11月21日</em></p></div></div>    
</body>
</html>