<html>
<head>
<title>Creating a Java Spring REST Service from an OpenAPI 3.0 Definition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从OpenAPI 3.0定义创建Java Spring REST服务</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-java-spring-rest-service-from-an-openapi-3-0-definition-94fbd5b8aa9e?source=collection_archive---------0-----------------------#2019-10-01">https://itnext.io/creating-a-java-spring-rest-service-from-an-openapi-3-0-definition-94fbd5b8aa9e?source=collection_archive---------0-----------------------#2019-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4e9f81611c1f10c95a3607408e9ad936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q26sLMa0AWRgAAYFKDoq_w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由来自<a class="ae kf" href="https://freeimages.com/" rel="noopener ugc nofollow" target="_blank"> FreeImages </a>的Krzysztof(Kriss)Szkurlatowski拍摄</figcaption></figure><p id="7cfa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OpenAPI 3.0规范已经存在一段时间了，但是到目前为止，我仍然使用它的前身Swagger 2.0定义。对于一个新项目，我决定使用OpenAPI 3.0定义来定义REST API，并将其提供给Swagger提供的一些优秀工具，以生成一个基于Spring的Java项目来帮助kickstart实现。</p><h1 id="f2fb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Swagger 2.0 vs OpenAPI 3.0</h1><p id="30f2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对于那些熟悉Swagger 2.0的人来说，好消息是，对<a class="ae kf" href="https://swagger.io/blog/news/whats-new-in-openapi-3-0/" rel="noopener ugc nofollow" target="_blank"> OpenAPI 3.0 </a>所做的更改在功能上是向后兼容的，尽管你的JSON或YAML文件将需要更新，因为格式已经发生了一点变化(像<a class="ae kf" href="https://openapi-converter.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> Mermade Swagger 2.0到OpenAPI 3.0.0转换器</a>这样的工具可以为你做到这一点)。</p><p id="eac6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OpenAPI 3.0中我最喜欢的一些增强包括:</p><ul class=""><li id="1d23" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">支持多个根URL——这意味着当您的API定义显示在Swagger UI中时，读者可以选择在发送请求时使用哪个服务器。当有单独的开发、测试和生产环境时非常方便。</li></ul><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/97189a726185ffc317811200f22cf7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*Op-68qlVl_EjsImZrarZNg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">多个根URL允许在Swagger UI中选择不同的服务器</figcaption></figure><ul class=""><li id="143c" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">支持<code class="fe mv mw mx my b">oneOf</code>、<code class="fe mv mw mx my b">anyOf</code>、<code class="fe mv mw mx my b">allOf</code>和其他<a class="ae kf" href="https://swagger.io/docs/specification/data-models/keywords/" rel="noopener ugc nofollow" target="_blank"> JSON模式关键字</a>，当JSON响应或请求开始变得复杂时，这些关键字允许更好地描述它们。</li><li id="609b" class="mh mi it ki b kj mz kn na kr nb kv nc kz nd ld mm mn mo mp bi translated">直接支持基于承载令牌的认证方案。</li></ul><h1 id="0618" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Pi天气休息API</h1><p id="d807" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我目前正在探索的项目是关于构建和实现一个基于Raspberry Pi的传感器小网格，以收集不同位置的天气测量结果，并提供一个显示数据的仪表板。作为该系统的一部分，将有一个REST API来读取和写入测量值。每个收集天气测量数据的Raspberry Pi都将调用write API。运行仪表板应用程序的Raspberry Pi将调用read API。</p><p id="5344" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的OpenAPI 3.0 JSON文件描述了这个简单的REST API:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Pi Weather REST API的OpenAPI 3.0</figcaption></figure><h1 id="a568" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">生成Spring项目</h1><p id="c4b5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们已经定义了REST API，我们可以使用<a class="ae kf" href="https://swagger.io/tools/swagger-codegen/" rel="noopener ugc nofollow" target="_blank"> Swagger Codegen </a>工具创建一个基于Spring的Java项目来实现它。根据您的操作系统，有不同的安装方式，从自制软件，到从Maven下载最新的稳定JAR，再到克隆repo并自己构建。</p><p id="a64a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我要给出的唯一警告是确保您使用的是该工具的3.x版本，因为这是支持OpenAPI 3.0和更高版本所必需的。该工具的2.x版本仅支持Swagger 2.0，如果针对OpenAPI 3.0文件运行，则会给出误导性错误。</p><p id="2d90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦所有东西都安装好了，我们只需要创建一个选项文件，允许我们指定Java包名，然后我们就可以开始了。运行工具本身需要几个选项:</p><ul class=""><li id="aae7" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><code class="fe mv mw mx my b">-i</code>从中读取REST API定义的输入文件。</li><li id="f6f5" class="mh mi it ki b kj mz kn na kr nb kv nc kz nd ld mm mn mo mp bi translated"><code class="fe mv mw mx my b">-l</code>生成代码的语言。这里有很多选择，但是对于我的项目，我使用<code class="fe mv mw mx my b">spring</code>在基于Java的Spring框架中生成一个实现。</li><li id="2944" class="mh mi it ki b kj mz kn na kr nb kv nc kz nd ld mm mn mo mp bi translated"><code class="fe mv mw mx my b">-o</code>将生成的代码写入的目录(如果不存在将被创建)。</li><li id="5cde" class="mh mi it ki b kj mz kn na kr nb kv nc kz nd ld mm mn mo mp bi translated"><code class="fe mv mw mx my b">-c</code>从中读取任何语言特定选项的文件。对于我们的Spring项目，我们将通过一个包含以下内容的选项文件来指定要使用的包名:</li></ul><pre class="mr ms mt mu gt ng my nh ni aw nj bi"><span id="6e1c" class="nk lf it my b gy nl nm l nn no">{<br/>    "basePackage":"org.piweather.app",<br/>    "configPackage":"org.piweather.app.config"<br/>}</span></pre><ul class=""><li id="3a55" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><code class="fe mv mw mx my b">-DhideGenerationTimestamp=true</code>将防止生成的代码包含文件创建时的时间戳，使得后续重新生成的代码的差异更加简单。</li></ul><p id="bf0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经将这些选项放在一个小脚本中(参见我的GIT repo<a class="ae kf" href="https://github.com/arronharden/pi-weather-api-swagger30" rel="noopener ugc nofollow" target="_blank">https://github.com/arronharden/pi-weather-api-swagger30</a>)，该脚本将从Maven下载Swagger Codegen JAR并根据我的OpenAPI 3.0定义运行它:</p><pre class="mr ms mt mu gt ng my nh ni aw nj bi"><span id="4734" class="nk lf it my b gy nl nm l nn no">#!/bin/sh</span><span id="d345" class="nk lf it my b gy np nm l nn no">CODEGEN_DIR="$(dirname "$0")/."</span><span id="e02b" class="nk lf it my b gy np nm l nn no">CODEGEN_JAR=${CODEGEN_DIR}/swagger-codegen-cli.jar<br/>CODEGEN_SWAGGER=${CODEGEN_DIR}/../swagger.json<br/>CODEGEN_CONFIG=${CODEGEN_DIR}/swagger-codegen-spring-options.json<br/>CODEGEN_OUT_DIR=${CODEGEN_DIR}/../../pi-weather-app-spring</span><span id="3c38" class="nk lf it my b gy np nm l nn no">rm -f ${CODEGEN_JAR}<br/>wget <a class="ae kf" href="http://central.maven.org/maven2/io/swagger/codegen/v3/swagger-codegen-cli/3.0.11/swagger-codegen-cli-3.0.11.jar" rel="noopener ugc nofollow" target="_blank">http://central.maven.org/maven2/io/swagger/codegen/v3/swagger-codegen-cli/3.0.11/swagger-codegen-cli-3.0.11.jar</a> -O ${CODEGEN_JAR}</span><span id="0c16" class="nk lf it my b gy np nm l nn no">java -jar ${CODEGEN_JAR} generate \<br/>    -i ${CODEGEN_SWAGGER} \<br/>    -l spring \<br/>    -o ${CODEGEN_OUT_DIR} \<br/>    -c ${CODEGEN_CONFIG} \<br/>    -DhideGenerationTimestamp=true</span></pre><h1 id="186d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">生成的Java Spring项目</h1><p id="63fd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们已经生成了框架项目，我们可以将它导入到我们最喜欢的IDE中，并开始实现每个API的逻辑。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">生成的Spring应用程序</figcaption></figure><p id="ebce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Spring代码生成器的一个优点是，它创建的框架代码将返回我们在OpenAPI 3.0定义中提供的任何示例JSON内容以及501状态，这意味着我们可以快速运行它并尝试一些GET APIs。这里有一个针对新生成的项目运行<a class="ae kf" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>的例子。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/71b51d3a0f90d33032740c24db3a911f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRA-yJ34qBHy3UkZtgrPVg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Postman调用骨架项目上的REST API</figcaption></figure><h1 id="8987" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">摘要</h1><p id="5407" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们已经看到了OpenAPI 3.0中的一些变化，以及新的REST API定义是什么样子的。使用Swagger Codegen工具，我们还生成了一个基于Spring的Java项目框架，为REST API端点创建了真正的实现。</p></div></div>    
</body>
</html>