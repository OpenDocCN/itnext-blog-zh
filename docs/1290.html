<html>
<head>
<title>Maximize observability of your DevOps pipeline with GitOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用GitOps最大限度地提高DevOps管道的可观察性</h1>
<blockquote>原文：<a href="https://itnext.io/simplified-gitops-with-travis-ci-479bff1d3848?source=collection_archive---------4-----------------------#2018-08-29">https://itnext.io/simplified-gitops-with-travis-ci-479bff1d3848?source=collection_archive---------4-----------------------#2018-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4cef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">GitOps with Travis-CI如何加快生产部署</strong></h2></div><h1 id="7d16" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">背景</h1><p id="9622" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我非常兴奋地宣布，我最近加入了一个新的孵化器项目。孵化器的启动带来了新的挑战和机遇，以探索在行业中获得牵引力的新技术和方法。如果说我从过去的孵化器中学到了什么，那就是在扩大开发团队之前，围绕DevOps建立强大的文化和一套定义良好的基础构建模块是多么重要。为了直接解决这个问题，我想把重点放在开发人员工具链上，以及我们如何简化我们的开发过程，以真正推动尽早提交和经常提交的理念。我还想超越仅仅提交代码，没有任何方法来衡量我们的进展。我想要构建、测试和部署的代码提交，以便我们的利益相关者可以在完全自动化的过程中测量进度并提供进度反馈。</p><h1 id="57bb" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">什么是GitOps，为什么它引起了我的兴趣</h1><p id="35aa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然我在一家非常大的技术公司工作，但我花了大量时间研究云公司如何解决具有挑战性的技术问题。在我之前的角色中，我们的组织负责Kubernetes的软件交付，我们将Kubernetes平台与我们自己的管理平台打包在一起。像许多采用Kubernetes的组织一样，如何管理应用程序和部署工件(例如yaml文件)的挑战是真实的。当我去奥斯丁的KubeCon 2017时，我看到了我的第一个来自<a class="ae lt" href="https://www.weave.works/" rel="noopener ugc nofollow" target="_blank">weaver works</a>的GitOps演示。这个概念很简单，但结果却非常有力，尤其是当它与Kubernetes联系在一起的时候。我在Weaveworks <a class="ae lt" href="https://www.weave.works/technologies/gitops/" rel="noopener ugc nofollow" target="_blank">网站</a>上找到了这个。</p><blockquote class="lu lv lw"><p id="03b9" class="kx ky lx kz b la ly jr lc ld lz ju lf ma mb li lj mc md lm ln me mf lq lr ls ij bi translated">什么是GitOps？</p><p id="dcb9" class="kx ky lx kz b la ly jr lc ld lz ju lf ma mb li lj mc md lm ln me mf lq lr ls ij bi translated">GitOps是一种持续交付的方式。它通过使用Git作为声明性基础设施和应用程序的单一事实来源来工作。</p></blockquote><p id="d11a" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">由于我接触的大多数开发团队已经使用Github进行开发，而且我已经是另一种叫做<a class="ae lt" href="https://www.weave.works/docs/scope/latest/introducing/" rel="noopener ugc nofollow" target="_blank"> Weave Scope </a>的Weaveworks技术的狂热粉丝，这似乎是我们需要探索的东西。不幸的是，当时我没有足够的带宽来设计一个可以应用到我们开发实践中的原型解决方案。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/8d24aaa814618829e4303f7630cbe539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*q3x0pv-CyVwzWNOb.jpg"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><a class="ae lt" href="https://cdn.thenewstack.io/media/2018/02/eee8cef2-weave.jpg" rel="noopener ugc nofollow" target="_blank">https://cdn.thenewstack.io/media/2018/02/eee8cef2-weave.jpg</a></figcaption></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="bf5b" class="kf kg iq bd kh ki mz kk kl km na ko kp jw nb jx kr jz nc ka kt kc nd kd kv kw bi translated">从简单的应用程序开始</h1><p id="2cc7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我试图学习一个新概念时，我的一个常见抱怨是，你通常会花更多的时间试图在整个解决方案的范围内理解技术。在本文中，我将重点介绍一个非常小的应用程序，它很好地阐述了解决方案，并且可以扩展以满足您以后的需求。这也和我了解到的GitOps的情况一致。Weaveworks为GitOps记录的内容在Weaveworks中运行良好，但可能与您的情况不完全匹配。因此，请将此作为学习工具，并按照您认为合适的方式进行修改。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c89e" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">我将在本文中使用的应用程序是一个简单的Node.js应用程序，上面的yml文件是travis构建脚本。构建是一组make任务，将克隆repo，安装各种依赖项，并运行一组测试。如果测试通过，将创建一个docker映像，并将其推送到组织的Docker注册中心。该应用程序最终将被部署到Kubernetes集群上，但是Git项目并不知道这个事实。构建过程有一个最终目标。最终目标是构建一个可部署的工件(docker映像)。这种抽象允许我们灵活地进行部署以及部署到哪里。这将在下一节中讨论。</p><h1 id="abda" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">构建与部署的分离</h1><p id="9c2d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">GitOps的一个基本原则是不仅要对应用程序代码进行版本控制，还要对基础设施代码进行版本控制。Kubernetes只是许多现代云原生工具中的一个例子，这些工具是“声明性的”，可以被视为代码。声明性意味着配置由一组事实而不是一组指令来保证。在我们的原型中，我们将创建一个单独的<code class="fe ng nh ni nj b">deployer</code>项目，该项目将托管Kubernetes部署描述符，该描述符将管理前面提到的应用程序到我们现有的Kubernetes集群之一的部署。</p><h1 id="8f18" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">GitOps自动执行部署过程</h1><p id="abe1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们现在正处于将两个项目结合在一起的阶段。通常，这将更加复杂，并且包含多个应用程序。我也可能使用Kubernetes包管理器<a class="ae lt" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">掌舵</a>来协调部署。然而，为了在将来保持简单和可扩展，我将把重点放在通过GitOps管理的单个部署工件上。</p><p id="5351" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">在下面的脚本中，我利用了Github的Octokit包，该包公开了一组API，可以通过编程对Github项目执行这些API。暂时后退一步，我想引用上面构建脚本中的一个步骤，我故意跳过了这个步骤，因为我想在这里介绍它。在构建脚本yaml的底部，有一个部分在每次构建成功时触发一个轻量级webhook。这个端点的目标是我下面的Node.js应用程序。这种松散耦合确实允许未来的集成，因为Travis Webhook提供了关于构建过程的元数据，包括repo名称和触发构建的提交散列。这将非常有用，因为GitOps流程已扩展到支持多个应用程序，我利用Helm对应用程序进行增量部署，以便只部署应用程序中已更改的组件。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="37b3" class="pw-post-body-paragraph kx ky iq kz b la ly jr lc ld lz ju lf lg mb li lj lk md lm ln lo mf lq lr ls ij bi translated">上面的脚本依赖于一个名为<a class="ae lt" href="https://help.github.com/articles/about-pull-requests/" rel="noopener ugc nofollow" target="_blank"> Pull的GitHub特性，请求</a>用之前构建的映像的最新版本更新源代码库。首先，我们在最新的主分支上创建一个分支。为了避免竞争情况，我们使用git commit ref作为分支名称的一部分。然后，我们对{IMAGE_VERSION}的占位符进行字符串替换，以更新到我们想要部署的最新映像。一旦完成，我们将更新的部署yaml提交到分支。代码现在可以合并了。在这篇文章中，我们以编程方式合并分支，然后删除分支。如果您的组织中有更严格的控制，您可以将这些作为需要批准的有效PRs，但我们希望简化这种方法，以便我们自动接受PRs。</p><h1 id="deef" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">通过Travis-CI推动管道</h1><p id="ce82" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我的GitOps POC的初始版本中，我继续利用PR过程，不仅更新Kubernetes部署工件，而且还使用提交到主分支的结果来触发部署。这种推模型对于目标集群不能通过网络访问源代码系统的环境非常有用。这在许多使用公共云资源的企业部署中很常见。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="056a" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">用Kubediff拉管道</h1><p id="14fe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">理想情况下，我想改变我的部署模式。我上面提到的模型在当今的许多开发商店中非常常见，在这些商店中，构建脚本利用Kubernetes CLI来驱动对各种集群的部署。但是，为了实现云规模并确保我的集群不会漂移，我想更多地使用拉模型。这就是库贝迪夫发挥作用的地方。在Weaveworks使用的GitOps模型中，他们描述了<a class="ae lt" href="https://www.weave.works/technologies/gitops/#pull-pipeline" rel="noopener ugc nofollow" target="_blank"> pull pipeline </a>，他们的工具Kubediff是跟踪集群部署的绝佳选择，并在环境偏离Github中提交的资源时进行标记。有了这个模型，我就可以部署一个Kubernetes操作器来对我的Github repo进行修改，并直接从集群启动部署。这实现了一个更具可伸缩性的模型，其中CI/CD系统可以进一步从Kubernetes集群环境中分离出来。</p><h1 id="818a" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">整条管道的可观察性</h1><p id="192b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe ng nh ni nj b">Observability</code>在云本地世界获得了巨大的吸引力。深入了解您的环境并拥有代表集群状态的审计线索，有助于大规模管理集群。通过迁移到GitOps模型，我扩展了我的团队的DevOps文化，以推动对管道的更多可见性，Git现在可以准确地跟踪应用程序提交的内容，以及部署到每个环境的基础架构和版本。正如您在下面看到的，我们的GitOps审计跟踪跟踪我们的部署，并可以将部署映射回触发部署的git提交散列。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/c5f370dc696e8f1e472a0d39bc7ad225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYc5bP4xWl4ICRmVJGxANw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">GitOps流程的Git提交历史</figcaption></figure><h1 id="4825" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">结论</h1><p id="cb03" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这篇文章中，我介绍了一种新颖的方法，使用GitOps定义工作流来提高DevOps管道的可见性和可观察性，从而简化您的Kubernetes部署过程。</p></div></div>    
</body>
</html>