<html>
<head>
<title>Declarative DevOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">声明性DevOps</h1>
<blockquote>原文：<a href="https://itnext.io/declarative-devops-30788ddd43cd?source=collection_archive---------3-----------------------#2019-06-16">https://itnext.io/declarative-devops-30788ddd43cd?source=collection_archive---------3-----------------------#2019-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e291" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解DevOps的最大趋势</h2></div><p id="f7cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"> <a class="ae lf" href="https://medium.com/@cjkuech/declarative-devops-microframeworks-9908c8d05332" rel="noopener"> <em class="le">的第二部分<em class="le">声明性DevOps微框架</em> </em></a></p><p id="7874" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">声明式编程并不是一个新概念——但它在描述DevOps工具方面的使用最近出现了爆炸式增长。这可能看起来只是另一个时髦的术语，但是声明式编程对于DevOps来说有一些独特的好处，这确保了它的存在。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/8bbf202ab0404ec370c75cb7d7a8254a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SDFA4sS4_uJDTR8D0r8_OA.jpeg"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">随着开发人员试图破坏越来越多的远程资源，声明式开发运维的流行程度随着云的发展而增长</figcaption></figure><h1 id="a8f4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">什么是声明式编程？</h1><p id="2288" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">声明式编程经常与函数式编程混为一谈，但有些不同。理解声明性范例最简单的方法是将其与“普通的”命令式代码进行对比。</p><h2 id="d1c7" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">什么是命令式编程？</h2><p id="13fa" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">如果你在问这个问题，命令式代码的一个很好的例子就是你当前的代码库。命令式代码将逻辑定义为一系列步骤。每一步都要等待上一步完成后再继续，并且每一步都要修改系统的状态。“状态”是保存动态值的任何东西，例如:</p><ul class=""><li id="254d" class="nf ng it kk b kl km ko kp kr nh kv ni kz nj ld nk nl nm nn bi translated">内存中的一个变量</li><li id="1bba" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">磁盘上的一些资源，如文件或注册表设置</li><li id="9ce8" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">一些外部资源，比如云中的虚拟机</li></ul><h2 id="d64e" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">命令式编程有什么不好？</h2><p id="fde0" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">状态很难调试。如果您将状态存储在变量中，您可能需要一个调试器来检查程序的状态。如果您将状态存储在磁盘或云中，您可能需要运行一个脚本或打开一个浏览器来查看状态。更糟糕的是，状态是副作用的同义词，比“<a class="ae lf" href="https://en.wikipedia.org/wiki/Function_(mathematics)" rel="noopener ugc nofollow" target="_blank">纯函数</a>”更难进行单元测试。纯函数——保证没有副作用的函数——只需要对其输入和输出进行单元测试，而有副作用的函数也需要测试是否存在副作用。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nt"><img src="../Images/9d9de796599abb16e189580a67829da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eCABmqI2l5yz2rqpAN_qSA.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">哇，这么多要调试的！</figcaption></figure><h2 id="0025" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">一定有更好的方法！</h2><p id="aadb" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">命令式编程的替代方法是声明式编程。声明式编程是您“声明”您的数据结构并“查询”它们的状态的地方。例如，SQL是一种纯粹的声明性语言，因为您“声明”您的数据结构(数据库、表及其相互关系)，然后“查询”结果值。同样的论点也适用于其他纯声明性语言，如Haskell，在Haskell中，您将数据结构“声明”为树，并在这些数据结构上进行“查询”替换。</p><blockquote class="nu nv nw"><p id="d547" class="ki kj le kk b kl km ju kn ko kp jx kq nx ks kt ku ny kw kx ky nz la lb lc ld im bi translated">声明式编程是您“声明”您的数据结构并“查询”它们的状态的地方。</p></blockquote><p id="1d9b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你对抽象语言感到困惑，不要担心——直觉地理解纯声明性语言是如何工作的可能需要几周时间。您需要记住的是，声明性代码避免了程序中的状态突变，从而避免了副作用，因此是自动幂等的，并且更容易调试。</p><h2 id="ff2e" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">编写声明性代码</h2><p id="7121" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">您并没有为您的应用程序和脚本使用纯粹的声明性语言，但是您仍然可以将声明性概念应用到您的代码中。这些准则将使您的代码更具声明性:</p><ul class=""><li id="1ccc" class="nf ng it kk b kl km ko kp kr nh kv ni kz nj ld nk nl nm nn bi translated">“查询”您的数据，将尽可能多的逻辑放入引用您先前定义的常数的表达式中</li><li id="cbe0" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">通过将这些查询表达式绑定到一个不可变的变量来“声明”您的数据</li></ul><p id="cd3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个用于聚合服务器请求日志的示例PowerShell片段演示了这些准则，从不改变状态并最大限度地使用表达式。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi oa"><img src="../Images/8d136c1b375ab51b94b471d58f230fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QoxooV3lsM0Lgc8aJs2-bg.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">应用我们的声明性编码指南的PowerShell脚本示例</figcaption></figure><p id="74dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们是“查询”而不是“执行一系列步骤”，我们的计算本质上是无状态的，没有副作用，所以我们可以将问题分解成越来越小的单元测试组件，而不必运行调试器。</p><h1 id="359e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">声明性DevOps</h1><p id="ed98" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">声明性DevOps是声明性编程的一个特例。使用声明性DevOps，我们定义我们配置的<strong class="kk iu">期望状态</strong>，然后让平台<strong class="kk iu">设置</strong>期望状态，或者“使其如此”。</p><blockquote class="nu nv nw"><p id="6b0f" class="ki kj le kk b kl km ju kn ko kp jx kq nx ks kt ku ny kw kx ky nz la lb lc ld im bi translated">声明性DevOps是您“声明”您的配置的期望状态，然后让平台“使它如此”。</p></blockquote><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/9b2dbfe93d73eabe5faf7ff4011e89f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*JB_08D1cZf39WYuc3Ue_tg.jpeg"/></div></figure><h2 id="cc7d" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">跳过中间状态</h2><p id="daf5" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">虽然大多数脚本必须考虑任意数量的初始和中间状态，但是对于声明性配置，我们只定义最终的“期望”状态。由于我们不必考虑程序中的这些其他状态，我们需要调试的代码就少了很多。</p><p id="f671" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们不必担心中间状态，我们可以保证我们的代码将是<strong class="kk iu">幂等的</strong>:如果你多次运行它，它不会有不同的结果(比如抛出一个错误)。使用声明性DevOps，如果您的部署脚本中途失败，您将再也不必手动重建您的配置——您只需重新运行您的声明性脚本。由于我们不需要自己实现幂等性，我们的代码也会更干净，因为我们不会在整个代码中使用<a class="ae lf" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> WET </a> <code class="fe oc od oe of b">if</code>语句，或者使用<code class="fe oc od oe of b">-Force</code>和<code class="fe oc od oe of b">-ErrorAction Ignore</code>来隐藏所有错误，即使一些错误可能(即使在极少数情况下)是可操作的。</p><h2 id="2391" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">声明您的抽象数据类型</h2><p id="75fc" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">声明性DevOps程序将序列化的<a class="ae lf" href="https://en.wikipedia.org/wiki/List_of_data_structures#Abstract_data_types" rel="noopener ugc nofollow" target="_blank">抽象数据类型</a>作为输入——通常是定义系统的一组“资源”——我们称之为“配置”。因为它们是抽象的，它们是高度可扩展的，并且因为它们是模式化的数据类型，所以它们可以通过根据模式验证配置来进行静态验证，这对于防御DevOps代码至关重要。</p><p id="a8b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当试图创建声明性程序时，一个常见的错误是使用<a class="ae lf" href="https://en.wikipedia.org/wiki/List_of_data_structures#Composite_types_or_non-primitive_type" rel="noopener ugc nofollow" target="_blank">复合数据类型</a>作为输入，而不是使用<a class="ae lf" href="https://en.wikipedia.org/wiki/List_of_data_structures#Abstract_data_types" rel="noopener ugc nofollow" target="_blank">抽象数据类型</a>。复合类型实际上只是命名空间的全局常量，而不是真正可扩展的数据结构。虽然复合数据类型配置对于编译的程序是有益的，因此您可以在不重新编译程序的情况下更改输入，但是这些配置实际上会给DevOps脚本添加不必要的抽象(在代码更改后不需要重新编译)，并且进行小的代码修改需要多次代码更改。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi og"><img src="../Images/93c3270ab9c2b4283f96e3ee82d716d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rxjFMes4sCF_0CWXh7CYQQ.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">这些是用于描述环境的配置。如果数据发生变化，左侧需要进行许多代码更改，但是右侧(虽然更长)更好地利用了抽象数据类型来最小化代码更改。</figcaption></figure><p id="9140" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的比较中可以看出，右边的抽象数据类型配置严格使用了列表和映射，而左边的配置则不那么通用。</p><h2 id="9c2d" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">流行的声明性DevOps系统</h2><p id="28b2" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这些是一些最受欢迎的DevOps工具，用于定义基础架构和平台的理想状态。</p><ul class=""><li id="f189" class="nf ng it kk b kl km ko kp kr nh kv ni kz nj ld nk nl nm nn bi translated"><strong class="kk iu"> Kubernetes/Helm图表</strong> — Helm图表让您定义Kubernetes资源的期望状态:Pod、服务帐户、容器等。</li><li id="de70" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><a class="ae lf" href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authoring-templates" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> ARM </strong> </a> <strong class="kk iu">和</strong><a class="ae lf" href="https://aws.amazon.com/cloudformation/aws-cloudformation-templates/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">CloudFormation</strong></a><strong class="kk iu">模板</strong> —面向Azure的ARM模板和面向AWS的Cloud formation模板让您定义所需的云资源状态:虚拟机、存储帐户、负载平衡器等。</li><li id="3a03" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><a class="ae lf" href="https://docs.microsoft.com/en-us/powershell/dsc/overview/overview" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> PowerShell期望状态配置</strong> </a> — DSCs允许您定义计算上下文(物理服务器、虚拟机或Docker容器)中资源的期望状态:文件、注册表设置、访问控制列表等。</li></ul><h1 id="6362" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">后续步骤</h1><p id="ceba" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">开始使用一个声明性的DevOps系统，并将配置签入到<code class="fe oc od oe of b">git</code>，这样您就可以实现代码为的<a class="ae lf" href="https://en.wikipedia.org/wiki/Infrastructure_as_code" rel="noopener ugc nofollow" target="_blank">基础设施。</a></p><h2 id="0836" class="mt lx it bd ly mu mv dn mc mw mx dp mg kr my mz mi kv na nb mk kz nc nd mm ne bi translated">了解有关扩展PowerShell的更多信息</h2><p id="ef6a" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">本文是关于大规模管理PowerShell代码库的<a class="ae lf" href="https://medium.com/@cjkuech/declarative-devops-microframeworks-9908c8d05332" rel="noopener">声明性DevOps微框架</a>系列文章的一部分。阅读本系列的<a class="ae lf" href="https://medium.com/@cjkuech/declarative-devops-microframeworks-9908c8d05332" rel="noopener">部分，了解更多关于为大型DevOps代码库设计和编写更少代码的信息。</a></p></div></div>    
</body>
</html>