<html>
<head>
<title>React’s Component Lifecycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React的组件生命周期</h1>
<blockquote>原文：<a href="https://itnext.io/reacts-component-lifecycle-6c13e09d10ad?source=collection_archive---------5-----------------------#2018-03-05">https://itnext.io/reacts-component-lifecycle-6c13e09d10ad?source=collection_archive---------5-----------------------#2018-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ee9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我在公司面试全栈和前端开发角色时，我不断被问到React的组件生命周期是什么。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/67f4531efc2790df0a91184c5dd31067.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/1*rEUNoulV-X-c_b1PXks9_w.gif"/></div></figure><p id="7672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说，组件生命周期有三个阶段。初始化/安装、状态/属性更新以及销毁/卸载。这些事件中的每一个都有与之相关的React方法，并且其中的一些事件会发生不止一次。理解这三个事件可以帮助您决定在给定的情况下使用什么逻辑。例如，我们可能希望在组件呈现后向DOM添加一些内容，然后在组件被销毁前移除它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi kt"><img src="../Images/6e4109b5f3c42328a54c6df632c9c7ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LxPAWHURzKye3Fq2iBzcQg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">这让您很好地了解了什么是组件生命周期以及与每个阶段相关的方法。</figcaption></figure><p id="5115" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有前缀为<code class="fe lc ld le lf b">will</code>的方法都在动作之前被调用，所有前缀为<code class="fe lc ld le lf b">did</code>的方法都在动作之后被调用。</p><p id="f524" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">render()</code></p><p id="3ac7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以说是最重要的方法。创建的每个组件都需要此方法。<code class="fe lc ld le lf b">render</code>方法应该考虑到<code class="fe lc ld le lf b">this.props</code>和<code class="fe lc ld le lf b">this.state</code>，并返回一个react元素(即一个JSX形式的DOM组件或一个用户创建的<code class="fe lc ld le lf b">&lt;MyComponent /&gt;</code>形式的组件)、一个字符串或数字(在DOM中创建为文本节点)、<code class="fe lc ld le lf b">null</code>或布尔值。<code class="fe lc ld le lf b">render()</code>不应该修改组件的状态，它应该以可预测的方式呈现。如果<code class="fe lc ld le lf b">shouldComponentUpdate()</code>返回<code class="fe lc ld le lf b">false</code>，则<code class="fe lc ld le lf b">render()</code>不会被调用。</p><h2 id="2045" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated"><strong class="ak">初始化/安装</strong></h2><p id="f977" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">React组件生命周期的第一阶段是初始化/安装。这是组件第一次被创建并插入DOM的地方。与此阶段相关的方法如上所示。下面我就来讨论两个。</p><p id="7e38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">componentWillMount()</code></p><p id="d021" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该方法在组件安装之前调用，因此在<code class="fe lc ld le lf b">render()</code>方法之前。如果您最初设置状态，建议您改为在<code class="fe lc ld le lf b">constructor()</code>方法中设置。如果你需要在这个方法中调用<code class="fe lc ld le lf b">setState()</code>，它不会触发任何额外的渲染，因为组件还没有被渲染。</p><p id="863f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">componentDidMount()</code></p><p id="0fde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组件安装一发生，此方法就调用。任何需要DOM上存在特定节点的东西都应该放在这里。如果有需要从API请求的数据，这是放置请求的好地方。如果<code class="fe lc ld le lf b">setState()</code>在这里被调用，它将触发一个重新渲染，因为初始渲染已经发生。</p><h2 id="60cb" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">状态/属性更新</h2><p id="10e8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">每当状态或属性发生变化时，默认情况下会重新呈现一个组件，并且在这个重新呈现器上还会调用其他方法，下面将对其中一些方法进行探讨。</p><p id="0143" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">shouldComponentUpdate()</code></p><p id="fefe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当让一个组件知道它是否应该根据状态或属性的改变而更新时，使用这个方法。这是与状态/属性更改相关联的方法链中调用的第一个方法。</p><p id="ed87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">componentWillUpdate()</code></p><p id="02a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当状态或属性发生变化时，在呈现发生之前调用此方法。这是在更新之前可以做的准备工作。您不应该在此方法中对状态或属性进行任何更改，因为它假定对状态或属性的更改已经发生。</p><p id="7197" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">componentDidUpdate()</code></p><p id="45dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新一发生就调用此方法，而不是在第一次渲染时调用。这是一个提出请求并根据你的状态和道具进行检查的好地方。</p><h2 id="dfba" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">卸载/销毁</h2><p id="39c9" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这个类别中只有一个方法，当一个组件从DOM中被删除时，这个方法被调用。</p><p id="4f7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">componentWillUnmount()</code></p><p id="a5ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个方法在卸载之前被调用。这是进行任何清理的地方，例如删除任何计时器、事件侦听器以及停止和网络请求。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi me"><img src="../Images/0b796652b770e60b0120285337c320b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*V33kq484lKxkHxHA28CXIQ.gif"/></div></figure><h1 id="75e4" class="mf lh iq bd li mg mh mi ll mj mk ml lo mm mn mo lr mp mq mr lu ms mt mu lx mv bi translated"><strong class="ak">信号源</strong></h1><div class="mw mx gp gr my mz"><a href="https://www.codementor.io/blog/5-essential-reactjs-interview-questions-du1084ym1" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">5个必不可少的React.js面试问答| Codementor博客</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">在2017年的开发者调查中，Stack Overflow指出React仍然是最受欢迎的JavaScript库之一…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">www.codementor.io</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kr mz"/></div></div></a></div><div class="mw mx gp gr my mz"><a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">做出反应。成分-反应</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">用于构建用户界面的JavaScript库</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">reactjs.org</p></div></div><div class="ni l"><div class="no l nk nl nm ni nn kr mz"/></div></div></a></div></div></div>    
</body>
</html>