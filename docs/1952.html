<html>
<head>
<title>How to use Streams in Dart (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Dart中使用流(第1部分)</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-streams-in-dart-part-1-4503fec0cdd7?source=collection_archive---------1-----------------------#2019-03-01">https://itnext.io/how-to-use-streams-in-dart-part-1-4503fec0cdd7?source=collection_archive---------1-----------------------#2019-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5ab2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用Dart类处理流数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9c9993fe7391b7838eb070ef44a5e400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHgtxBeymrrAFf0mnxuxRg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="kv">照片由</em> <a class="ae kw" href="https://unsplash.com/photos/U_m-mPOZzMI?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="kv">杰罗姆Prax </em> </a> <em class="kv">上</em><a class="ae kw" href="https://unsplash.com/search/photos/stream?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="kv">Unsplash</em></a></figcaption></figure><p id="fa9c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于大多数钻研Dart ( <em class="lt">或任何其他语言)的程序员来说，流的概念已经被证明是一个很难理解的话题，部分原因是它需要通过几次尝试和例子来掌握。在本文中，我将试图揭开Dart中流的使用的神秘面纱，同时用我们在本系列中进一步学到的知识构建一些有形的东西。</em></p><h1 id="b47d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">什么是流？</h1><p id="0912" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">查看Dart文档，其定义为:</p><blockquote class="mr ms mt"><p id="06f7" class="kx ky lt kz b la lb jr lc ld le ju lf mu lh li lj mv ll lm ln mw lp lq lr ls ij bi translated">异步数据事件的来源。流提供了一种接收事件序列的方式。每个事件要么是一个数据事件，也称为流的一个元素，要么是一个错误事件，这是一个通知，表明某些事情已经失败。当一个流发出它的所有事件时，一个单独的“done”事件将通知侦听器已经到达结尾。</p><p id="9cc6" class="kx ky lt kz b la lb jr lc ld le ju lf mu lh li lj mv ll lm ln mw lp lq lr ls ij bi translated"><strong class="kz ir">api.dartlang.org</strong></p></blockquote><p id="fba7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">作为一个概念，流指的是<em class="lt">通道</em>，数据通过该通道从A点流向b点。在该通道中，我们能够对到达b点之前“读入”的数据执行各种转换。当以<em class="lt">块</em>的形式传输数据而不是一次传输全部数据时，该<em class="lt">通道</em>非常有用。</p><p id="6fb1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在Dart中使用流的方式是通过SDK提供的一组助手类。这些助手类提供了实用方法，将数据推送到流中，并通知流的侦听器捕获任何添加的数据。</p><p id="5597" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">代表流的最通用的类叫做<code class="fe mx my mz na b">Stream&lt;T&gt;</code>。通常我们不直接使用这个类，因为它被Dart库中的其他类暴露了。将此视为与数据流经的<em class="lt">通道</em>交互的接口。</p><h1 id="be2e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">流控制器的基本示例<t/></h1><p id="9f57" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">一个<code class="fe mx my mz na b">StreamController&lt;T&gt;</code>包含一个流，它允许消费者向它发送数据、完成和错误事件。我们将通过执行<code class="fe mx my mz na b">streamController.stream</code>来访问这个流，允许我们调用在它的<a class="ae kw" href="https://api.dartlang.org/stable/2.1.1/dart-async/Stream-class.html" rel="noopener ugc nofollow" target="_blank">文档</a>中定义的任何方法。</p><p id="8e8b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里有一个关于<code class="fe mx my mz na b">StreamController&lt;T&gt;</code>类的例子:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="e088" class="nf lv iq na b gy ng nh l ni nj">var streamController = <strong class="na ir">StreamController</strong>();</span><span id="bbd5" class="nf lv iq na b gy nk nh l ni nj">// Accessing the stream and listening for data event<br/>streamController.<strong class="na ir">stream</strong>.<strong class="na ir">listen</strong>((<strong class="na ir">data</strong>) {<br/>  print('Got eem! $<strong class="na ir">data</strong>');<br/>});</span></pre><p id="bfc5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上面的代码片段允许我们观察流<em class="lt">通道</em>中传入的数据块。然后，我们通过将数据打印到控制台来响应这些数据。</p><p id="370e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">所以我猜接下来的<strong class="kz ir">问题</strong>是:<em class="lt">我们如何触发数据监听器事件？</em> <strong class="kz ir">答案:</strong> <em class="lt">通过给流喂数据！这是通过另一个名为<code class="fe mx my mz na b">EventSink&lt;T&gt;</code>的类实现的。这个对象包含一个<code class="fe mx my mz na b">add()</code>方法，用于向流提供数据:</em></p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="7544" class="nf lv iq na b gy ng nh l ni nj">streamController.<strong class="na ir">sink</strong>.<strong class="na ir">add</strong>('Added this string');</span><span id="8e78" class="nf lv iq na b gy nk nh l ni nj">// Result<br/>// Got eem! Added this string</span></pre><p id="4fbb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">流上的<code class="fe mx my mz na b">listen()</code>方法也可以捕捉错误消息。这是因为每当您侦听流时，都会生成一个<code class="fe mx my mz na b">StreamSubscription&lt;T&gt;</code>对象。这个对象是<strong class="kz ir">能够处理各种事件</strong>的原因，例如数据、错误和完成(当在流上调用close()方法时<em class="lt">)。</em></p><p id="d2d0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下面是<code class="fe mx my mz na b">listen()</code>方法的完整定义:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="d1e0" class="nf lv iq na b gy ng nh l ni nj"><strong class="na ir">StreamSubscription&lt;T&gt;</strong> listen (<br/>  void <strong class="na ir">onData</strong>(<strong class="na ir">T</strong> event), <br/>  {<br/>    Function <strong class="na ir">onError</strong>,<br/>    void <strong class="na ir">onDone</strong>(), // Invoked when the stream is closed<br/>    bool <strong class="na ir">cancelOnError</strong> // Kills the stream when an error occurs<br/>  });</span></pre><p id="ecb7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下面是我们如何调用“错误”和“完成”事件:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="675a" class="nf lv iq na b gy ng nh l ni nj">streamController.<strong class="na ir">sink</strong>.<strong class="na ir">addError</strong>('Houston, we have a problem!'); // Got an error! Houston, we have a problem!</span><span id="9020" class="nf lv iq na b gy nk nh l ni nj">streamController.<strong class="na ir">sink</strong>.<strong class="na ir">close</strong>(); // Mission complete!</span></pre><p id="a591" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">→ <a class="ae kw" href="https://dartpad.dartlang.org/3baf3a9c229dcfa962878905e478a1a7" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">在镖靶上试试这个</strong> </a></p><h1 id="d965" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">通过库公开的流</h1><p id="29ce" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">虽然<code class="fe mx my mz na b">StreamController&lt;T&gt;</code>允许我们对自己实例化的流进行细粒度的控制，但是有内置的dart库在幕后使用流。例如，看看这个设置服务器的代码片段:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="6609" class="nf lv iq na b gy ng nh l ni nj">import 'dart:io';</span><span id="4509" class="nf lv iq na b gy nk nh l ni nj">void main() async {<br/>  var <strong class="na ir">server</strong> = await <strong class="na ir">HttpServer.bind</strong>('localhost', 8080);</span><span id="72ec" class="nf lv iq na b gy nk nh l ni nj">  // HttpServer exposes a Stream&lt;T&gt; interface<br/>  <strong class="na ir">server</strong>.<strong class="na ir">listen</strong>((HttpRequest <strong class="na ir">request</strong>) {<br/>    request.response.write('Hello, World!');<br/>    request.response.close();<br/>  });<br/>}</span></pre><p id="6bb4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上面的代码片段实例化了一个用于创建web服务器的<code class="fe mx my mz na b">HttpServer</code>。这个类公开了一个<code class="fe mx my mz na b">Stream&lt;T&gt;</code>接口，这意味着我们现在可以监听这个流，它将包含当用户访问我们的服务器时产生的请求对象。</p><p id="2ef4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下面是web浏览器中显示的另一个流示例:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="ed84" class="nf lv iq na b gy ng nh l ni nj">import 'dart:html';</span><span id="77fd" class="nf lv iq na b gy nk nh l ni nj">void main() {<br/>  var <strong class="na ir">button</strong> = querySelector('button');<br/>  <br/>  // `onClick` is a Stream&lt;T&gt; instance that receives user click data events<br/>  button.<strong class="na ir">onClick</strong>.<strong class="na ir">listen</strong>((_) =&gt; print('Button clicked!'));<br/>}</span></pre><p id="ac7e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在浏览器中发生的用户交互，如<em class="lt">点击</em>、<em class="lt">滚动</em>、<em class="lt">输入</em>等，被作为流中捕获的“数据”事件发出。换句话说，HTML元素也公开了一个<code class="fe mx my mz na b">Stream&lt;T&gt;</code>接口，用于处理页面上的用户交互。</p><p id="d99e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">还有很多使用流的类，这里的要点是，通常你不会直接实例化<code class="fe mx my mz na b">Stream&lt;T&gt;</code>对象，而是通过SDK中的各种库类为你实例化。</p><h1 id="23a2" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论</h1><p id="c44b" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">流提供了一种处理大块数据的强大方式。因为这是以异步方式运行的，所以我们获得了以非阻塞方式运行代码的好处。我建议通读文档，特别是包含异步编程类的<strong class="kz ir"> dart:async </strong>库，比如Streams和Futures。</p><p id="dae3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本系列的下一部分中，我们将研究如何在流上执行转换，以及演示一个以使用流🧱为中心的通用设计模式</p><h1 id="b32f" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">继续阅读</h1><p id="7a2e" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">→ <a class="ae kw" href="https://creativebracket.com/how-to-use-streams-in-dart-2/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">如何在Dart中使用Streams(第二部)</strong> </a></p><h1 id="52ed" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">进一步阅读</h1><ul class=""><li id="2b72" class="nl nm iq kz b la mm ld mn lg nn lk no lo np ls nq nr ns nt bi translated"><a class="ae kw" href="https://api.dartlang.org/stable/2.1.1/dart-async/dart-async-library.html" rel="noopener ugc nofollow" target="_blank"> dart:异步库文档</a></li><li id="ac52" class="nl nm iq kz b la nu ld nv lg nw lk nx lo ny ls nq nr ns nt bi translated"><a class="ae kw" href="https://egghead.io/instructors/jermaine-oppong" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir">egghead . io上免费飞镖课</strong> </a></li></ul></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="8795" class="lu lv iq bd lw lx og lz ma mb oh md me jw oi jx mg jz oj ka mi kc ok kd mk ml bi translated">分享是关怀🤗</h1><p id="c788" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">如果你喜欢读这篇文章，请通过各种社交渠道分享。此外，检查并<a class="ae kw" href="https://youtube.com/c/CreativeBracket" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">订阅我的YouTube频道</strong> </a> ( <em class="lt">也点击铃铛图标</em>)观看Dart上的视频。</p><p id="cb1a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><a class="ae kw" href="http://eepurl.com/gipQBX" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">订阅我的电子邮件简讯</strong> </a>下载我的免费<strong class="kz ir">Dart入门电子书</strong>并在新内容发布时得到通知。</p><p id="b329" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">喜欢，分享一下</strong> <a class="ae kw" href="https://twitter.com/creativ_bracket" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">跟着我</strong> </a>😍有关Dart的更多内容。</p></div></div>    
</body>
</html>