<html>
<head>
<title>React, Express, Node Js, and MongoDB (MERN Stack) microservices-based application deployment on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes上基于React、Express、Node Js和MongoDB (MERN堆栈)微服务的应用部署</h1>
<blockquote>原文：<a href="https://itnext.io/react-express-node-js-and-mongodb-mern-stack-microservices-based-application-deployment-on-ec4607cec74d?source=collection_archive---------0-----------------------#2019-10-04">https://itnext.io/react-express-node-js-and-mongodb-mern-stack-microservices-based-application-deployment-on-ec4607cec74d?source=collection_archive---------0-----------------------#2019-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bdb07ff5a123485d2e497bee997d87bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1XJj7H00paHSB5QJshvtwA.png"/></div></div></figure><p id="2912" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">ubernetes是最近的热门话题，许多大公司要么已经将其基础设施转移到Kubernetes，要么计划很快这样做。Kubernetes已经成为最强大的开源容器编排工具，作为任何云的操作系统，它都变得越来越重要。本文将一步一步地帮助我们如何将一个具有<strong class="ka ir">前端→后端→数据库层</strong>的基本的基于微服务的应用作为独立的实体部署到Kubernetes集群，并使它们可伸缩。</p><p id="6e10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我创建了一个简单的待办事项应用程序，包括以下内容</p><ul class=""><li id="2cef" class="lf lg iq ka b kb kc kf kg kj lh kn li kr lj kv lk ll lm ln bi translated">使用React构建的前端应用程序。</li><li id="35fb" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated">后端服务器是使用Node Js、Express和mongoose构建的。</li><li id="163f" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated">数据库层将使用NoSQL数据库，即MongoDB。</li></ul><p id="10d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为此ToDo应用程序的简要概述，当用户从浏览器访问前端应用程序时，将出现一个带有注册选项的登录屏幕。用户必须首先注册注册，然后在注册成功后，可以使用注册的电子邮件和密码登录到应用程序。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lt"><img src="../Images/bf723327600be950b8ae7d0d2fac6b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOs2opMO3QWT6xUSgFJk9g.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">登录界面</strong></figcaption></figure><p id="6cec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">成功登录后出现的下一个屏幕，将用于添加新的待办事项任务和已添加到待办事项的列表。用户还可以通过点击星号将任何特定的待办事项标记为重要，将它们标记为已完成，并在需要时删除任何特定的待办事项。用户还可以使用ToDo搜索选项，并根据序列号、标题或描述对分页列表进行排序。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/51396878609556170bc6902f80ed3c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTHVFf4NY6yXOepLGTf1sg.png"/></div></div></figure><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/5c96d1c7a717ac80e3cf934f40382872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7AqQetwsrqb58cFdVz0UUw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">登录后的待办事宜</strong></figcaption></figure><p id="d29d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上是应用概述。一个简单的小MERN堆栈应用程序！。现在让我们进入部署阶段。</p><p id="8f10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在进入部署阶段的Kubernetes部分之前，很明显，我们将需要所有的应用程序及其在容器映像中的依赖项。Kubernetes稍后将使用这些图像来创建包装在Kubernetes Pod资源中的容器实例。毕竟，Kubernetes是一个编排工具，可以帮助我们部署、扩展和管理容器化的应用程序。</p><p id="081f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将为我们自己的前端应用程序和后端应用程序创建一个自定义映像，我们将使用MongoDB官方映像作为我们的数据库层。</p><p id="7107" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于部署，我将使用Minikube，它为Kubernetes环境提供了一个单节点集群设置，对于开发人员来说，在开发过程中拥有一个真正相似的Kubernetes环境是一件幸事。</p><p id="a0e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要在本地获取ToDo项目，您可以从以下GitHub链接克隆它:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="ba46" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">git clone</strong> <a class="ae mq" href="https://github.com/aamirpinger/todo-app-client-server-kubernetes.git" rel="noopener ugc nofollow" target="_blank">https://github.com/aamirpinger/todo-app-client-server-kubernetes.git</a></span></pre><p id="6302" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">克隆后，转到应用程序的文件夹:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="fbd9" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">cd </strong>todo-app-client-server-kubernetes</span></pre><p id="7a8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将有两个目录:</p><ol class=""><li id="0018" class="lf lg iq ka b kb kc kf kg kj lh kn li kr lj kv mr ll lm ln bi translated">客户端(用于前端应用程序)</li><li id="1e6a" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv mr ll lm ln bi translated">服务器(用于后端应用程序)</li></ol><p id="e8ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这些目录中，它分别包含前端和后端应用程序的ToDo应用程序源代码，两个文件夹都有用于应用程序容器化的Dokcerfile和用于在Kubernetes上部署的YAML文件。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/42f9abde15ac578ff70e597b41e12bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDuwAzeY3hIKXyCJXx4WFw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">应用数据流</strong></figcaption></figure><p id="cc4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上图显示了数据的流向。从左边开始，用户将从使用React构建的浏览器访问前端应用程序(所有源代码都在“客户端”文件夹中)。然后，前端应用程序将使用使用Express和Node JS构建的REST APIs与后端应用程序连接。最后但并非最不重要的后端应用程序将保存和检索NoSQL MongoDB数据库中的数据。</p><p id="c381" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我们将在整个应用程序部署过程中创建的资源的小图表。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/25e92953ff3c09fc4ccc6baee76bcfe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Bx7JzuXmQqdfBvGOn9e5w.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">所需资源图表</strong></figcaption></figure><p id="a48a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将首先转到“client”文件夹，从现有的docker文件创建一个映像</p><p id="dc31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要更改目录:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="0837" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">cd</strong> client</span></pre><p id="21db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该文件夹包含前端应用程序的所有源代码。这里我们有两个选择，一个是在容器内安装node和npm，使用这个源代码文件夹，然后像我们在开发阶段一样，使用<em class="mu"> npm start </em>命令运行应用程序，所有这些都在容器内完成。</p><p id="2ff1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在本文中遵循的第二个也是首选选项是，在任何web服务器(如Nginx)的容器中只使用一个生产就绪的构建文件夹。我之所以说这是首选方式，是因为当我们对代码进行生产就绪构建时，在浏览器上速度会快一点，因为构建是代码的编译形式，并且总是推荐用于生产环境。</p><p id="afb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个文件夹中，您会找到一个docker文件:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="0976" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">FROM</strong> node:alpine as todo-app-build</span><span id="22e4" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">WORKDIR</strong> /client</span><span id="9409" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">COPY</strong> package.json yarn.lock ./</span><span id="182f" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">RUN</strong> yarn</span><span id="9a08" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">COPY</strong> ./public ./public</span><span id="53d4" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">COPY</strong> ./src ./src</span><span id="7b08" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">ENV</strong> REACT_APP_baseAPIURL=<strong class="mg ir">&lt;backend-app-service-ip&gt;:&lt;port&gt;</strong></span><span id="59f8" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">RUN</strong> yarn build</span><span id="a4aa" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">FROM</strong> nginx:latest</span><span id="80bf" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">LABEL</strong> maintainer=Aamir-Pinger</span><span id="64b8" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">COPY</strong> - from=todo-app-build /client/build/ /usr/share/nginx/html</span><span id="d5bd" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">EXPOSE</strong> 80</span><span id="820b" class="mk ml iq mg b gy mv mn l mo mp">____________________________________________________________________<br/>                    <strong class="mg ir">Dockerfile (client folder)</strong></span></pre><p id="c160" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在构建任何图像之前，让我们首先理解“客户端”文件夹的docker文件中所写的步骤。</p><p id="9ed8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从第一行的<strong class="ka ir">开始，它说从官方<strong class="ka ir">节点的起点开始构建这个图像:alpine </strong>图像，我选择了<strong class="ka ir"> :alpine </strong>只是为了保持图像较小以便快速下载。<strong class="ka ir"> "as" </strong>部分只是一个引用/标记名，在我们的示例中是<strong class="ka ir"> "todo-app-build" </strong>，我们将在后面的docker文件中使用它来引用映像构建的这一部分。</strong></p><p id="7074" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一行是<strong class="ka ir"> WORKDIR </strong>，它只是将<strong class="ka ir"> <em class="mu"> "/client" </em> </strong>作为这个容器映像中的当前工作目录(PWD)。然后是<strong class="ka ir">复制</strong>指令，它将上述文件复制到映像内的PWD中。</p><p id="3f31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> RUN <em class="mu"> yarn </em> </strong>指令将安装<em class="mu"> package.json </em>文件中列出的所有依赖项，这将最终在映像中创建一个<em class="mu"> node_modules </em>文件夹。接下来的两行，<strong class="ka ir">临摹。/public。/public和COPY。/src。/src </strong>正在将public和src文件夹从我们的系统复制到镜像中。<strong class="ka ir"> ENV </strong>创建一个名为<strong class="ka ir"> REACT_APP_baseAPIURL </strong>的环境变量，我们将添加该变量的值来替换<strong class="ka ir">&lt;back end-APP-service-IP&gt;:&lt;port&gt;</strong>。这里之所以需要它，是因为当稍后在Dockerfile中进行构建时，创建生产就绪代码时的构建过程会将前端应用程序的React代码中Axios base-URL中使用的env变量替换为字符串值。字符串值就是我们将在这个env变量中添加的内容。Axios是我们用于从前端应用程序到后端服务器的所有API调用的工具，用于登录、验证、添加新的待办任务等。<strong class="ka ir">运行纱线</strong>构建将创建生产就绪构建。</p><p id="0aab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里Dockerfile的第一部分完成了。</p><p id="2e02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二部分是从标签再次以<strong class="ka ir">开始。在docker文件中，当来自标签的<em class="mu">再次出现时，docker将启动一个全新的映像构建过程，丢弃之前映像构建阶段的所有内容。没错，之前的所有步骤都被丢弃了。你一定在想，如果所有的东西都被丢弃了，那我们为什么要做那些步骤。你一定听说过一句名言，<em class="mu">在这个世界上没有什么是无用的，一切都是为了某种目的而制造的</em>。Docker允许从第二个FROM标记开始的下一个构建阶段，如果需要的话，从前面的阶段复制任何文件，这就是我们现在如何将我们新创建的构建文件夹从前面的阶段复制到这个新的阶段，以便可以通过浏览器使用任何web服务器(如Nginx)访问这个构建文件夹中的文件。</em></strong></p><p id="b80b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在Dockerfile中的映像构建的单个阶段中完成所有这些，即使用来自标签的一个<em class="mu">，就像我们可能已经在前一阶段安装了<em class="mu"> Nginx </em> web服务器，并使用它的构建文件夹，但这将不必要地增加映像大小，因为要进行构建，我们需要<em class="mu">节点</em>映像，并且在构建创建后，我们将不再需要<em class="mu">节点</em>映像用于任何其他用途，而是我们将使用<em class="mu"> Nginx </em> web服务器映像。<em class="mu">节点</em>图像的大小大于<em class="mu"> Nginx </em>图像，当我在另一个docker文件中单独尝试第一阶段以确认这一点时，图像的大小约为480MB，当您完成制作这个完整的图像时，我确信图像大小不会超过140MB。永远记住，图像必须是轻量级的。</em></p><p id="b0ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二阶段的第一行说使用标签为<em class="mu">“最新”的<em class="mu"> Nginx </em>官方<strong class="ka ir">图像</strong>。</em>第二行是设置一个<strong class="ka ir">标签</strong>，其只是为了标注。以<strong class="ka ir"> COPY </strong>开头的第三行是将前一阶段的任何<strong class="ka ir"><em class="mu">/client/build</em></strong>复制到当前阶段的文件夹<strong class="ka ir">/usr/share/Nginx/html</strong>中，我们已经为其指定了标签名<strong class="ka ir"><em class="mu">todo-app-build</em></strong>(您可以向上查看Dockerfile的第一行)，该文件夹是Nginx web服务器的默认文件夹如果我在一行中重复这一点，我们已经将我们的构建文件夹复制到Nginx默认文件夹，这样用户就可以从浏览器访问它。Nginx默认监听端口80，因此，以<strong class="ka ir"> EXPOSE </strong>开头的docker文件的最后一行通知docker这个应用程序正在监听端口80。</p><p id="2863" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在我们从上述Dockerfile实际构建映像之前，我们需要将上述Dockerfile中的<strong class="ka ir">&lt;back end-app-service-ip&gt;:&lt;port&gt;</strong>替换为我们后端服务器端口号的URL或IP地址。在Kubernetes中，如果我们为后端应用程序创建一个LoadBalancer类型的服务资源，我们就可以获得这个IP和端口号。为什么说是服务资源的负载平衡器类型，因为当我们到达部署步骤时，我们将使用多个副本来扩展我们的后端应用程序，因此此负载平衡器类型服务将管理所有副本之间的负载，以实现更好的扩展。为了获得这个IP和端口，我们必须在为我们的前端应用程序构建映像之前首先为后端应用程序创建一个服务资源，并且为了创建一个后端应用程序服务资源，我们需要暂时将目录从<em class="mu">客户端</em>文件夹更改为<em class="mu">服务器</em>文件夹<em class="mu">。</em></p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="e2c8" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">cd</strong> ../server</span></pre><p id="4c77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此文件夹中，您会找到server-app-service.yaml:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="18de" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">apiVersion</strong>: v1</span><span id="1c22" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">kind</strong>: Service</span><span id="2894" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">metadata</strong>:</span><span id="cddc" class="mk ml iq mg b gy mv mn l mo mp">  <strong class="mg ir">name</strong>: todo-backend-service</span><span id="84b5" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">spec:</strong></span><span id="0ee8" class="mk ml iq mg b gy mv mn l mo mp">  <strong class="mg ir">ports</strong>:</span><span id="1bd6" class="mk ml iq mg b gy mv mn l mo mp">  - <strong class="mg ir">port</strong>: 5000</span><span id="15d4" class="mk ml iq mg b gy mv mn l mo mp">    <strong class="mg ir">targetPort</strong>: 5000</span><span id="1058" class="mk ml iq mg b gy mv mn l mo mp">  <strong class="mg ir">selector:</strong></span><span id="fe17" class="mk ml iq mg b gy mv mn l mo mp">    <strong class="mg ir">app:</strong> todo-server-app</span><span id="df52" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">type</strong>: LoadBalancer</span><span id="e920" class="mk ml iq mg b gy mv mn l mo mp">____________________________________________________________________<br/>    <strong class="mg ir">                  server-app-service.yaml</strong></span></pre><p id="d43d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面是一个简单的YAML文件，用于创建一个负载平衡器类型的服务资源，它与容器的端口5000进行对话。我们为端口分配了5000，因为我们的基于节点js的后端应用程序将在端口5000监听连接请求。</p><p id="b082" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建此服务:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="dbaf" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> create -f server-app-service.yaml</span></pre><p id="bd29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要列出服务资源:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="329f" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> get service</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/922629bcd9dd9f28aec73f0c932380e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RkDF-B7WBvvjRPjz_E09LA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">服务资源列表</strong></figcaption></figure><p id="3048" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您部署在任何云提供商的Kubernetes服务器上，那么在一段时间内，外部IP状态<strong class="ka ir">&lt;&gt;</strong>将被一个IP自动更改，该IP随后可以使用上述端口号从外部世界访问该服务。在Minikube设置中，我们将使用Minikube IP和上面的端口号，在我的情况下是<strong class="ka ir"> 30414 </strong>(您可能会有不同，所以使用您的)</p><p id="109f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要获取Minikube ip，您可以键入以下命令:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="102b" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">minikube</strong> ip</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/c21d349da8b51a425df0259fa4de4344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CoATwNba8j2LuRD-wi3QaQ.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">命令输出</strong></figcaption></figure><p id="dd47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在前端app Dockerfile中使用<strong class="ka ir"><em class="mu">192 . 168 . 99 . 100:30414</em></strong>替换<strong class="ka ir"> &lt;后端-app-service-ip &gt; : &lt;端口&gt; </strong>。你可能会得到不同的IP，你会用在你的身边，而不是这个以上的IP。</p><p id="a4c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要返回到<em class="mu">客户端</em>文件夹，继续更改Dockerfile中的值，并开始构建一个供将来使用的映像。</p><p id="ae7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要返回到<em class="mu">客户端</em>文件夹:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="cdb4" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">cd</strong> ../client</span></pre><p id="d960" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将把<strong class="ka ir">&lt;back end-app-service-ip&gt;:&lt;port&gt;</strong>替换为<a class="ae mq" href="http://192.168.99.100:30414" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">http://192 . 168 . 99 . 100:30414</strong></a>(检查您的IP和端口号)，然后再继续。</p><p id="837b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是构建此映像的时候了，为此，我们将运行以下命令(完成此映像构建过程可能需要一点时间):</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="9b94" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">docker</strong> image build -t todo-client-kubernetes-app .</span></pre><p id="c981" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">映像构建完成后，您可以使用以下命令再次确认映像创建成功:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="628e" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">docker</strong> image ls</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/b45782980e6003204bc4215418ba29d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNiqbn9C5dGo7PGrisPsMA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">图像列表</strong></figcaption></figure><p id="c8c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看我告诉你，它甚至不是140兆。这就是前端应用程序映像构建，现在我们将进入下一步，创建前端应用程序的Kubernetes资源，其中包括一个负载平衡器类型的服务资源和一个包含3个副本的部署资源。</p><p id="c8f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前端应用程序部署资源的YAML文件:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="7266" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">apiVersion</strong>: apps/v1</span><span id="25bc" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">kind</strong>: Deployment</span><span id="eeb1" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">metadata</strong>:</span><span id="b458" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  name</strong>: todo-client-app-deploy</span><span id="31bc" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">spec:</strong></span><span id="7699" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  replicas</strong>: 3</span><span id="7895" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  selector</strong>:</span><span id="ad82" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    matchLabels</strong>:</span><span id="07e9" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">      app</strong>: todo-client-app</span><span id="98f5" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  template:</strong></span><span id="46c9" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    metadata:</strong></span><span id="1412" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">      labels:</strong></span><span id="5363" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">        app</strong>: todo-client-app</span><span id="559c" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    spec</strong>:</span><span id="5ee7" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">      containers</strong>:</span><span id="d1a0" class="mk ml iq mg b gy mv mn l mo mp">      - <strong class="mg ir">image</strong>: todo-client-kubernetes-app:latest</span><span id="568a" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">        name</strong>: container1</span><span id="098a" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">        imagePullPolicy</strong>: IfNotPresent</span><span id="16f8" class="mk ml iq mg b gy mv mn l mo mp">____________________________________________________________________<br/><strong class="mg ir">                      client-app-deploy.yaml</strong></span></pre><p id="2773" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的YAML文件包含Kubernetes创建部署资源的基本指令，并将<strong class="ka ir"> todo-client-app-deploy </strong>指定为其名称，将<strong class="ka ir"> 3个pod作为副本</strong>并匹配选择器中设置的<strong class="ka ir">标签app: todo-client-app </strong>以跟踪资源组。选择器指令之后是pod模板，它将被用作配置，通过Kubernetes在部署资源下创建的replicaSet来创建任何Pod。这些豆荚将与标签为<strong class="ka ir">的</strong><strong class="ka ir">app:todo-client-app</strong>分组，要使用的<strong class="ka ir">图像</strong>是<strong class="ka ir">todo-client-kubernetes-app:latest</strong>和last instruction告诉先在本地查看图像，如果没有找到，则只查看docker hub进行下载。我选择这个<strong class="ka ir">映像拉取策略</strong>来避免推送和下载我们的前端和后端应用程序映像。您可以根据需要选择映像拉取策略。</p><p id="0509" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您使用Minikube，默认情况下，它运行在虚拟机VM内，而我们用来构建映像的docker运行在本地系统上，即Minikube VM之外。这就是为什么docker在我们的本地机器上创建的新创建的映像将无法从Minikube VM访问，并且这将导致通过部署资源使用上述YAML文件创建的pod的ImagePullError。为了解决这个问题，我们首先有两个选择，要么将这个映像推送到我们的docker hub帐户，并在上面的YAML中使用<em class="mu">&lt;docker _ hub _ username&gt;/todo-client-kubernetes-app:latest</em>，要么第二个选择是运行以下命令，将这个映像的副本从我们本地系统的文件系统保存到Minikube的VM环境中。如果您在任何云的Kubernetes服务器上部署，则不需要下面的命令。</p><p id="7d51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要将副本保存到Minikube虚拟机，我们将执行以下命令:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="a2e6" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">docker</strong> save todo-client-kubernetes-app | (eval $(minikube docker-env) &amp;&amp; docker load)</span></pre><p id="1d74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要最终创建部署资源，请运行以下命令:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="4750" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> create -f client-app-deploy.yaml</span></pre><p id="3d8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要列出新创建的部署、复制集和Pod资源，请键入以下内容:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="1b68" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> get deploy,rs,pod</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/ad2d099c045002fe3b4bccf383eb6d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SM7ulNvp8SRvvQNjTcNBmg.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">部署、复制器和容器的列表</strong></figcaption></figure><p id="9b60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将创建一个负载平衡器类型的服务资源，以便我们可以向外界公开我们的前端应用程序。</p><p id="b06e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前端应用服务资源的YAML文件:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="ebce" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">apiVersion</strong>: v1</span><span id="090e" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">kind</strong>: Service</span><span id="d13f" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">metadata</strong>:</span><span id="884f" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  name</strong>: todo-client-service</span><span id="992a" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">spec</strong>:</span><span id="b269" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  selector</strong>:</span><span id="179b" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    app</strong>: todo-client-app</span><span id="5364" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  ports:</strong></span><span id="ee55" class="mk ml iq mg b gy mv mn l mo mp">  - <strong class="mg ir">port</strong>: 80</span><span id="4fdc" class="mk ml iq mg b gy mv mn l mo mp">    <strong class="mg ir">targetPort</strong>: 80</span><span id="ac0f" class="mk ml iq mg b gy mv mn l mo mp">  <strong class="mg ir">type</strong>: LoadBalancer</span><span id="6b4a" class="mk ml iq mg b gy mv mn l mo mp">____________________________________________________________________<br/><strong class="mg ir">                      client-app-service.yaml</strong></span></pre><p id="43f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面是一个简单的负载平衡类型服务资源的YAML文件，它将与容器的端口80对话。</p><p id="eadb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建此服务资源，请执行以下操作:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="cad0" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> create -f client-app-service.yaml</span></pre><p id="9b48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要获取服务资源列表:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="34aa" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> get service</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/855b72bdbb3dc0ef1e614efbc485da06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UI4ksbJTG6tHaxtrkXOitw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">服务资源列表</strong></figcaption></figure><p id="c330" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经成功创建了负载平衡器类型的服务，现在是时候在浏览器上检查我们的应用程序是否真的成功部署并工作了。要从浏览器访问此服务，我们需要一个外部IP和上面服务资源列表中端口号的右边部分，但正如您在上面看到的，外部IP显示的是<strong class="ka ir"><em class="mu">&lt;&gt;</em></strong>，它应该在一段时间后更改为某个IP，但在我们的情况下，它稍后也不会在这里显示任何IP。这样做的原因是因为我们使用Minikube并在浏览器上访问任何服务。当使用Minikube时，我们不使用外部IP，因为它不像任何云提供商那样提供任何IP，但我们使用Minikube自己的IP在浏览器上访问此服务。当您在任何云提供商部署您的应用时，这个问题不会出现，因为他们会为我们创建的每个负载平衡器类型的服务分配一些外部IP。</p><p id="561e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要获取Minikube ip，您可以键入以下命令:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="4cd9" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">minikube</strong> ip</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/c21d349da8b51a425df0259fa4de4344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CoATwNba8j2LuRD-wi3QaQ.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">命令输出</strong></figcaption></figure><p id="4ab5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在这里获得了一个IP，您可能会获得一些不同的IP，对于我来说，我在浏览器中使用192.168.99.100:31687来访问我们刚刚部署的前端应用程序。另外，请记住，当您创建服务时，我得到的端口号也可能与您的不同，所以请使用您的端口号。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/15e514defb560f125817e1194d0c2954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0t9Yuh10SAYXKRoUQEzILw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">前端应用屏幕</strong></figcaption></figure><p id="7999" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你做得很好！！您的前端应用程序已启动并正在运行。不要试图兴奋地登录，因为我们的后端服务器还没有启动和运行，所以它不会进一步发展。</p><p id="5349" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是前端应用程序部署的全部内容，现在我们将把目录从<em class="mu">客户端</em>切换到<em class="mu">服务器</em>以进行后端应用程序部署。</p><p id="2d57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要更改目录:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="1609" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">cd </strong>../server</span></pre><p id="c6ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在我们创建后端应用程序资源之前，我们必须安装MongoDB，这样当我们的后端应用程序被创建并在任何阶段寻找MongoDB数据库时，它都能找到它。</p><p id="d72f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建MongoDB，我们将创建持久卷和持久卷声明，以便我们的MongoDB实例可以使用这些集群级存储来保存我们的数据库文件。这很重要，因为我们不希望在pod/container重建时丢失数据。</p><p id="a878" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">永久卷的YAML文件:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="33c7" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">apiVersion</strong>: v1</span><span id="2300" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">kind</strong>: PersistentVolume</span><span id="a6d8" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">metadata</strong>:</span><span id="ecbc" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  name</strong>: todo-app-pv</span><span id="a221" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">spec</strong>:</span><span id="f5ff" class="mk ml iq mg b gy mv mn l mo mp">  <strong class="mg ir">accessModes</strong>:</span><span id="be0c" class="mk ml iq mg b gy mv mn l mo mp">  - ReadWriteMany</span><span id="8c57" class="mk ml iq mg b gy mv mn l mo mp">  <strong class="mg ir">capacity</strong>:</span><span id="6721" class="mk ml iq mg b gy mv mn l mo mp">    <strong class="mg ir">storage</strong>: 1G</span><span id="fb5a" class="mk ml iq mg b gy mv mn l mo mp">  <strong class="mg ir">hostPath</strong>:</span><span id="e7fb" class="mk ml iq mg b gy mv mn l mo mp">    <strong class="mg ir">path</strong>: /tmp/todo-pv<br/></span><span id="38d8" class="mk ml iq mg b gy mv mn l mo mp">____________________________________________________________________<br/><strong class="mg ir">                     persistent-vol-server-app.yaml</strong></span></pre><p id="8713" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为对上述YAML文件的解释，它创建了一个访问模式为<em class="mu"> ReadWriteMany </em>的持久卷资源，根据定义，读写可以由多个节点完成。容量设置为<em class="mu"> 1gb </em>，主机路径设置为<em class="mu"> /tmp/todo-pv </em>，如果需要，可以设置为任何其他目录。</p><p id="08bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建永久卷资源，请执行以下操作:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="8510" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> create -f persistent-vol-server-app.yaml</span></pre><p id="9a13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是YAML永久卷索赔文件:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="e505" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">apiVersion</strong>: v1</span><span id="94ba" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">kind</strong>: PersistentVolumeClaim</span><span id="b245" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">metadata</strong>:</span><span id="2f99" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  name</strong>: todo-pvc</span><span id="3e03" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">spec</strong>:</span><span id="aa5a" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  accessModes</strong>:</span><span id="3c67" class="mk ml iq mg b gy mv mn l mo mp">  - ReadWriteMany</span><span id="bcab" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  resources</strong>:</span><span id="e6cf" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    requests</strong>:</span><span id="205f" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">      storage</strong>: 1G</span><span id="ca58" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  storageClassName</strong>: “”</span><span id="e5cd" class="mk ml iq mg b gy mv mn l mo mp">____________________________________________________________________<br/><strong class="mg ir">                persistent-vol-claim-server-app.yaml</strong></span></pre><p id="e736" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的YAML文件将创建一个持久卷声明资源，该资源将查找访问模式为<em class="mu"> ReadWriteMany </em>(与我们最近创建的PV相匹配)的持久卷，请求存储容量为<em class="mu"> 1gb </em>，由于我们在创建持久卷时没有添加任何存储类，因此为了匹配，我们将在这里使用<em class="mu"> storageClassName </em>到<em class="mu"> "" </em>，这表示查找没有存储类的PV。</p><p id="d8b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建永久卷声明资源，请执行以下操作:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="a62a" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> create -f persistent-vol-claim-server-app.yaml</span></pre><p id="2c1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以为MongoDB创建一个pod资源作为独立的容器实例，为此，我们将使用以下YAML文件:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="b883" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">apiVersion</strong>: v1</span><span id="4fae" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">kind</strong>: Pod</span><span id="2ea1" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">metadata</strong>:</span><span id="2e16" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  name</strong>: mongodb</span><span id="ad24" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  labels</strong>:</span><span id="f2b6" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    app</strong>: todo-mongodb</span><span id="ffa8" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">spec</strong>:</span><span id="c9d5" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  volumes</strong>:</span><span id="9d3c" class="mk ml iq mg b gy mv mn l mo mp">  - <strong class="mg ir">name</strong>: todo-mongo-vol</span><span id="2563" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    persistentVolumeClaim</strong>:</span><span id="4452" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">      claimName</strong>: todo-pvc</span><span id="c7f7" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  containers</strong>:</span><span id="37f1" class="mk ml iq mg b gy mv mn l mo mp">  - <strong class="mg ir">image</strong>: mongo</span><span id="547e" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    name</strong>: container1</span><span id="10f4" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    command</strong>:</span><span id="52bb" class="mk ml iq mg b gy mv mn l mo mp">    - mongod</span><span id="ddae" class="mk ml iq mg b gy mv mn l mo mp">    - “ — bind_ip”</span><span id="ea76" class="mk ml iq mg b gy mv mn l mo mp">    - “0.0.0.0”</span><span id="4c72" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    ports</strong>:</span><span id="bde3" class="mk ml iq mg b gy mv mn l mo mp">    - <strong class="mg ir">containerPort</strong>: 27017</span><span id="3987" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    volumeMounts</strong>:</span><span id="c994" class="mk ml iq mg b gy mv mn l mo mp">    - <strong class="mg ir">name</strong>: todo-mongo-vol</span><span id="214d" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">      mountPath</strong>: /data/db</span><span id="10c2" class="mk ml iq mg b gy mv mn l mo mp">____________________________________________________________________<br/><strong class="mg ir">                           mongodb-pod.yaml</strong></span></pre><p id="5f3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的YAML文件将创建一个<strong class="ka ir">名为<strong class="ka ir"> <em class="mu"> monogodb-pod </em> </strong>的pod。<strong class="ka ir">标签</strong>被设置为<strong class="ka ir"><em class="mu">app:todo-MongoDB</em></strong>，当我们为这个pod创建一个服务时，将需要这个标签。<strong class="ka ir">卷</strong>与<strong class="ka ir"> <em class="mu"> todo-pvc </em> </strong>创建持久卷声明，以便它可以由Mongodb容器挂载，这样做的目的只是使数据库文件在集群级别持久化。容器使用的是MongoDB在docker hub上的官方图像。<strong class="ka ir">命令</strong></strong></p><p id="a1ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建MongoDB pod:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="b18c" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> create -f mongodb-pod.yaml</span></pre><p id="6999" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将为上述pod创建一个服务，以便其他资源可以访问我们的MongoDB实例</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="21cd" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">apiVersion</strong>: v1</span><span id="6b60" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">kind</strong>: Service</span><span id="947d" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">metadata</strong>:</span><span id="db45" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  labels</strong>:</span><span id="0aea" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    app</strong>: todo-mongodb</span><span id="83f6" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  name</strong>: todo-mongo-service</span><span id="eed4" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">spec</strong>:</span><span id="9188" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  ports</strong>:</span><span id="6947" class="mk ml iq mg b gy mv mn l mo mp">  - <strong class="mg ir">port</strong>: 27017</span><span id="0c45" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    targetPort</strong>: 27017</span><span id="fb82" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  selector</strong>:</span><span id="2293" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    app</strong>: todo-mongodb</span><span id="5b23" class="mk ml iq mg b gy mv mn l mo mp">____________________________________________________________________<br/><strong class="mg ir">                        mongodb-service.yaml</strong></span></pre><p id="799c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面的YAML文件为MongoDB Pod创建服务资源:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="2583" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> create -f mongodb-service.yaml</span></pre><p id="da8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的YAML文件将为我们的MongoDB Pod创建ClusterIP类型的服务。为什么我选择ClusterIP类型而不是任何其他类型的服务，是因为这个实例将只在集群内部调用，我们不希望有人从外部访问它。</p><p id="5690" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们确认一下我们创建的上述所有资源是否已经启动并运行</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="0650" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> get pv,pvc,pod,svc</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/d912503af331024da75f0c29e74f3d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYT0V_ktuRSmV7i9jugvYg.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc"> PV、PVC、pod和服务资源列表</strong></figcaption></figure><p id="4c8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">PV、PVC、MongoDB pod、通过部署创建的客户端应用pod以及所有服务资源都已启动并运行。</p><p id="0b9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将为后端应用程序部署所有剩余的所需资源。从这个文件夹开始获取应用程序Dockerfile:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="ebb1" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">FROM</strong> node:alpine</span><span id="3198" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">WORKDIR</strong> /server</span><span id="bf5d" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">COPY</strong> package*.json yarn.lock ./</span><span id="0de9" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">RUN</strong> yarn</span><span id="7ec8" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">COPY</strong> ./src ./src</span><span id="1b76" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">EXPOSE</strong> 5000</span><span id="2945" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">CMD</strong> [ “yarn”, “start” ]</span><span id="f455" class="mk ml iq mg b gy mv mn l mo mp">____________________________________________________________________<br/><strong class="mg ir">                      Dockerfile (server folder)</strong></span></pre><p id="bde9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在为前端应用程序构建docker映像时，已经讨论过Dockerfile every instruction的用途。我不会对这个后端应用程序Dockerfile进行更多的细节描述，但正如演练一样，这个Dockerfile从<strong class="ka ir">节点开始:alpine </strong>映像，使<strong class="ka ir"> /server </strong>成为PWD，然后复制<strong class="ka ir">包*。json和yarn.lock </strong>文件到映像(这些文件包含运行该应用程序所需的要安装的依赖项列表)，下一步是使用<strong class="ka ir"> yarn </strong>命令安装所有依赖项。安装完所有依赖项后，下一个指令是<strong class="ka ir">将所有文件从我们系统的src文件夹复制到映像中的src文件夹。<strong class="ka ir"> Expose </strong>标签通知docker这个app正在监听端口<strong class="ka ir"> 5000 </strong>。以<strong class="ka ir"> CMD </strong>开头的Dockerfile的最后一行保存了docker将在创建该映像的任何容器实例时执行的命令，这是我们通常用来在本地系统上运行任何node js应用程序的命令。</strong></p><p id="0b92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要构建图像:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="77a3" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">docker</strong> image build -t todo-server-kubernetes-app .</span></pre><p id="7d6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用以下命令重新确认成功的映像创建:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="173e" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">docker</strong> image ls</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/a4d765c369cbcfbaa90da2aff4149268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJbdfLvUJ0DTZeG-wDSnrQ.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mc">图像列表</strong></figcaption></figure><p id="cf38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要像我们对前端应用程序映像所做的那样在Minikube VM中复制此映像，以便当我们创建部署资源时，它可以从那里找到它，我们将使用以下命令:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="223e" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">docker</strong> save todo-server-kubernetes-app | (eval $(minikube docker-env) &amp;&amp; docker load)</span></pre><p id="2ccc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将在几个YAML文件的帮助下部署我们的后端服务器，就像我们在上面为客户端应用程序所做的那样。</p><p id="f973" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端应用配置资源的YAML文件:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="a836" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">apiVersion</strong>: v1</span><span id="7979" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">kind</strong>: ConfigMap</span><span id="8545" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">metadata</strong>:</span><span id="ad30" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  name</strong>: server-side-configs</span><span id="c4b1" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">data</strong>:</span><span id="2a78" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  PORT</strong>: “5000”</span><span id="cf09" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  CLIENT</strong>: <strong class="mg ir"><em class="mu">&lt;front-end-app-service-ip&gt;:&lt;port&gt;</em></strong></span><span id="7430" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  MONGODB_URL</strong>: todo-mongo-service.default</span><span id="b961" class="mk ml iq mg b gy mv mn l mo mp">____________________________________________________________________<br/><strong class="mg ir">                        server-app-configs.yaml</strong></span></pre><p id="d545" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请将<strong class="ka ir"> &lt;前端应用服务ip &gt; : &lt;端口&gt; </strong>替换为前端应用服务资源的外部IP/Minikube和端口号。在我的例子中，我将把它替换为<a class="ae mq" href="http://192.168.99.100:31687." rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">。</strong> </a></p><p id="fb3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建配置映射资源:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="ac7d" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> create -f server-app-configs.yaml</span></pre><p id="06cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经创建了一个configMap资源来保存我们的变量值作为键/值对，我们需要在后端应用程序容器中使用它作为环境变量。在上面，三个键/值对第一个是<strong class="ka ir">端口</strong>，它将使我们的应用程序监听端口5000。第二个密钥是<strong class="ka ir">客户端</strong>，它保存前端应用程序的IP和端口号，我们也使用它从浏览器访问它，在我们的例子中，它是minikube IP和客户端应用程序服务端口号。这是必需的，因为我们的后端应用程序将只接受来自我们将在此定义的路径的传入API请求。这是因为我们后端应用中的跨源资源共享(CORS)限制，所以从逻辑上讲，我们通过提供前端应用的完整URL来正确地做到了这一点。第三个键是<strong class="ka ir"> MONGODB_URL </strong>，它拥有我们的MONGODB服务资源的完全合格的域名(FQDN)。这样，当我们的后端应用程序调用MongoDB时，Kubernetes内部DNS服务器会将该请求转移到MongoDB pod，它是我们为MongoDB实例创建的clusterIP类型服务的后台。</p><p id="fbf4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将创建一个秘密资源来保存JSON Web Token (JWT)的秘密字符串，我们将在后端应用程序中使用它来生成auth token。我们可以像上面为configMap所做的那样，通过创建一个YAML文件来做到这一点，但我更喜欢从命令行创建一个秘密资源，因为我不想将我的秘密写在YAML文件中，并在某个阶段错误地将其推送到GitHub，即使我在GitHub的回购是私有的。</p><p id="8d2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建秘密资源，请执行以下操作:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="fa50" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> create secret generic server-side-secrets — from-literal=JWT_SECRET=thisIsMySecretKeyForJWT*@.[123</span></pre><p id="a680" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，您可以通过选择string来更改上述键的值。</p><p id="e082" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建完以上内容后，我们就可以用最近创建的configMap和secret resource中的环境变量为我们的后端应用程序创建部署资源了。</p><p id="3893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端应用程序部署资源的YAML文件:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="0396" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">apiVersion</strong>: apps/v1</span><span id="e64e" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">kind</strong>: Deployment</span><span id="64f8" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">metadata</strong>:</span><span id="f738" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  name</strong>: todo-server-app-deploy</span><span id="879b" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">spec</strong>:</span><span id="d973" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  replicas</strong>: 3</span><span id="0565" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  selector</strong>:</span><span id="a308" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    matchLabels</strong>:</span><span id="1a80" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">      app</strong>: todo-server-app</span><span id="e283" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">  template</strong>:</span><span id="eabf" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    metadata</strong>:</span><span id="3fc5" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">      labels</strong>:</span><span id="4a54" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">        app:</strong> todo-server-app</span><span id="fa47" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">    spec</strong>:</span><span id="8ea6" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">      containers</strong>:</span><span id="b902" class="mk ml iq mg b gy mv mn l mo mp">      - <strong class="mg ir">image</strong>: todo-server-kubernetes-app:latest</span><span id="ff85" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">        name</strong>: container1</span><span id="799e" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">        ports</strong>:</span><span id="9628" class="mk ml iq mg b gy mv mn l mo mp">        - <strong class="mg ir">containerPort</strong>: 5000</span><span id="8d40" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">        imagePullPolicy</strong>: IfNotPresent</span><span id="5a7e" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">        envFrom</strong>:</span><span id="9548" class="mk ml iq mg b gy mv mn l mo mp">        - <strong class="mg ir">configMapRef</strong>:</span><span id="13f3" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">            name:</strong> server-side-configs</span><span id="e640" class="mk ml iq mg b gy mv mn l mo mp">        - <strong class="mg ir">secretRef</strong>:</span><span id="258e" class="mk ml iq mg b gy mv mn l mo mp"><strong class="mg ir">            name</strong>: server-side-secrets</span><span id="3a2f" class="mk ml iq mg b gy mv mn l mo mp">____________________________________________________________________<br/><strong class="mg ir">                        server-app-deploy.yaml</strong></span></pre><p id="f56c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你没有在上面的YAML文件中找到任何法语，因为除了<em class="mu"> envFrom </em>之外的每个标签都与我们在前端应用部署YAML文件中的标签相似。<strong class="ka ir"> <em class="mu"> envFrom </em> </strong>是用于从我们最近创建的configMap和secret resource添加环境变量的标签。这不是很简单吗？</p><p id="7dd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要从上述YAML文件创建部署资源，请执行以下操作:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="b621" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> create -f server-app-deploy.yaml</span></pre><p id="c476" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行完上述命令后，我们在Kubernetes集群上成功部署了一个完整的基于MERN堆栈微服务的应用程序，该应用程序也是可扩展的，因为我们为前端和后端应用程序创建了3个副本，如果这还不够，我们可以通过以下一条命令增加副本数量，使其更具可扩展性或减少副本数量，以节省成本:</p><p id="473a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要放大或缩小前端应用程序:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="e6bb" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> scale deploy <strong class="mg ir">todo-client-app-deploy</strong> --replicas=<strong class="mg ir">&lt;count&gt;</strong></span></pre><p id="6bcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要扩展或缩减后端应用程序:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="8178" class="mk ml iq mg b gy mm mn l mo mp"><strong class="mg ir">kubectl</strong> scale deploy <strong class="mg ir">todo-server-app-deploy</strong> --replicas=<strong class="mg ir">&lt;count&gt;</strong></span></pre><p id="179d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> &lt;计数&gt; </strong>将被替换为您当前希望运行的副本数量。</p><p id="0674" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经完成了我们完整的MERN堆栈应用程序的基本部署所需的所有步骤，现在是时候通过<strong class="ka ir"> &lt; minikube_IP &gt; : &lt;前端_服务_端口&gt; </strong>在浏览器中使用它的完整功能了。不要忘记在登录前先注册，因为最初数据库中没有用户。</p><h1 id="d523" class="nc ml iq bd mc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">夏天似的</h1><p id="5ea5" class="pw-post-body-paragraph jy jz iq ka b kb ny kd ke kf nz kh ki kj oa kl km kn ob kp kq kr oc kt ku kv ij bi translated">这篇文章是关于如何在一个最著名和最强大的容器化应用编排工具Kubernetes上部署一个完整的基于MERN堆栈微服务的应用。本文帮助您一步步地将微服务容器化，部署它们，扩展它们，并公开它们，使它们相互之间以及与外部世界进行通信。</p><p id="42ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们自己制作了两个docker映像，一个用于前端，另一个用于后端应用程序，我们还使用了一个MongoDB的官方映像来制作MongoDB数据库实例，作为Kubernetes集群上的独立微服务。我们还使用了持久卷和持久卷声明资源，这是Kubernetes提供的一个救命特性，使我们的数据库在集群级别上持久化，这样即使我们的MongoDB Pod/Container被破坏或重启，我们也不会丢失数据。</p><p id="77d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在前端微服务容器化过程中，我们首先构建了一个基于React的前端应用程序，然后将该构建与Nginx web服务器一起使用，以获得更好的性能，并保持我们的映像在大小方面是轻量级的。然后，我们部署了它，为了使它可扩展，我们制作了它的3个副本，并使用负载平衡类型的服务资源将其暴露给外部世界。</p><p id="024c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端服务器是使用Express和Node JS框架构建的。我们部署了后端应用程序，用3个副本将其封装起来，使其具有可扩展性。我们还公开了一个负载平衡器类型的Kubernetes服务资源，以便Kubernetes可以自动执行适当的负载管理。</p><p id="5200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们还讨论了如何扩展或缩减任何微服务，以实现经济高效和更好的性能。</p><p id="2a09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望现在您可以在Kubernetes集群上部署具有任意数量微服务的任何应用程序，并且您现在很清楚如何使它们相互通信，以及如何通过拥有多个副本和负载平衡器类型的服务来使它们可扩展。</p><p id="577a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇文章能帮助您理解基于微服务的部署。一定要在评论中写下反馈或建议改正。请随意分享，这样每个人都会从中受益。</p></div></div>    
</body>
</html>