<html>
<head>
<title>Semigroups &amp; Monoids</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">半群和幺半群</h1>
<blockquote>原文：<a href="https://itnext.io/semigroups-faf7a70da96a?source=collection_archive---------3-----------------------#2019-02-10">https://itnext.io/semigroups-faf7a70da96a?source=collection_archive---------3-----------------------#2019-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bf11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">半群是一个简单的函数概念，它本质上允许我们获取许多对象并返回单个对象。在那方面和<code class="fe kl km kn ko b">reduce</code>很像。</p><p id="1fba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">半群最基本的实现是:<code class="fe kl km kn ko b">(A, A) -&gt; A</code>。你可能会看着这个并想，这对于像<code class="fe kl km kn ko b">+</code>这样的中缀操作符来说是完美的。你可能是正确的，在<code class="fe kl km kn ko b">Haskell</code>中，操作符是<code class="fe kl km kn ko b">&lt;&gt;</code>，以便不与现有的<code class="fe kl km kn ko b">+</code>功能冲突，因为实现可能不同。</p><p id="e8ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Swift中，我们可以实现这样一个半群:</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="d515" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">infix</strong> <strong class="ko ir">operator</strong> &lt;&gt;: AdditionPrecedence</span><span id="9928" class="kx ky iq ko b gy ld la l lb lc"><strong class="ko ir">public</strong> <strong class="ko ir">protocol</strong> Semigroup { <br/>    <strong class="ko ir">func</strong> combine(with other: Self) -&gt; Self<br/>    <strong class="ko ir">static</strong> <strong class="ko ir">func</strong> &lt;&gt; (lhs: Self, rhs: Self) -&gt; Self<br/>}</span><span id="0e1f" class="kx ky iq ko b gy ld la l lb lc"><strong class="ko ir">extension</strong> Semigroup {<br/>    <strong class="ko ir">public</strong> <strong class="ko ir">static</strong> <strong class="ko ir">func</strong> &lt;&gt; (lhs: Self, rhs: Self) -&gt; Self {<br/>        <strong class="ko ir">return</strong> lhs.combine(with: rhs)<br/>    }<br/>}</span></pre><p id="7c1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多Swift类型已经在使用半群逻辑，包括<em class="le">数字</em>、<em class="le">字符串</em>和<em class="le">数组</em>。它们都与<code class="fe kl km kn ko b">+</code>操作符相关联。因此，我们可以扩展这些类型，也使用<code class="fe kl km kn ko b">&lt;&gt;</code>操作符。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="0a0c" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">extension</strong> Numeric <strong class="ko ir">where</strong> Self: Semigroup {<br/>    <strong class="ko ir">public</strong> <strong class="ko ir">func</strong> combine(with other: Self) -&gt; Self {<br/>        <strong class="ko ir">return</strong> <strong class="ko ir">self</strong> + other<br/>    }<br/>}</span><span id="11be" class="kx ky iq ko b gy ld la l lb lc"><strong class="ko ir">extension</strong> Int: Semigroup { }</span><span id="01e9" class="kx ky iq ko b gy ld la l lb lc"><strong class="ko ir">extension</strong> Array: Semigroup {<br/>    <strong class="ko ir">public</strong> <strong class="ko ir">func</strong> combine(with other: Array) -&gt; Array {<br/>        <strong class="ko ir">return</strong> <strong class="ko ir">self</strong> + other<br/>    }<br/>}</span><span id="a9d4" class="kx ky iq ko b gy ld la l lb lc"><strong class="ko ir">extension</strong> String: Semigroup {<br/>    <strong class="ko ir">public</strong> <strong class="ko ir">func</strong> combine(with other: String) -&gt; String {<br/>        <strong class="ko ir">return</strong> <strong class="ko ir">self</strong> + other<br/>    }<br/>}</span><span id="2d58" class="kx ky iq ko b gy ld la l lb lc"><strong class="ko ir">extension</strong> Bool: Semigroup {<br/>    <strong class="ko ir">public</strong> <strong class="ko ir">func</strong> combine(with other: Bool) -&gt; Bool {<br/>        <strong class="ko ir">return</strong> <strong class="ko ir">self</strong> &amp;&amp; other<br/>    }<br/>}</span></pre><p id="f315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以写一个简单的函数来连接任何类型的半群:</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="6637" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">public</strong> <strong class="ko ir">func</strong> concat&lt;S: Semigroup&gt;(<strong class="ko ir">_</strong> values: [S], initial: S) -&gt; S {<br/>    <strong class="ko ir">return</strong> values.reduce(initial, &lt;&gt;)<br/>}</span></pre><p id="0417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数只是减少了我们代码中的<code class="fe kl km kn ko b">&lt;&gt;</code>符号的数量，也会对编译器有所帮助。</p><p id="5355" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以像这样组合一组值:</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="57d1" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">let</strong> a = <strong class="ko ir">true<br/>let</strong> b = <strong class="ko ir">true<br/>let</strong> c = <strong class="ko ir">false</strong></span><span id="06c8" class="kx ky iq ko b gy ld la l lb lc">concat([a, b, c], initial: <strong class="ko ir">true</strong>) <em class="le">// false</em></span></pre><p id="371e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以使用此功能组合阵列:</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="e4a9" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">let</strong> spicy = ["Pepper", "Chilli"]<br/><strong class="ko ir">let</strong> sweet = ["Mango", "Pineapple"]<br/><strong class="ko ir">let</strong> sour = ["Lemon", "Sauerkraut"]</span><span id="b0b9" class="kx ky iq ko b gy ld la l lb lc"><strong class="ko ir">let</strong> dish = concat([spicy, sweet, sour], initial: [])</span><span id="ea30" class="kx ky iq ko b gy ld la l lb lc"><em class="le">// ["Pepper", "Chilli", "Mango", "Pineapple", "Lemon", "Sauerkraut"]</em></span></pre><p id="afce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了这个操作符，我们也可以将它用于我们自己的类型。我们所要定义的只是一种结合它们的方式。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="b9a1" class="lm ky iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">一个实际的例子:造型</h1><p id="b9ee" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我讨厌到处都是布局代码。</p><p id="0f39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将创建一个很好的构建<code class="fe kl km kn ko b">Styles</code>的可组合方式，我们可以将它应用于我们的<code class="fe kl km kn ko b">Views</code>。</p><p id="c0c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们定义我们的<code class="fe kl km kn ko b">Style</code>结构，这样我们就有了一个要组合的类型。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="8ad5" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">public</strong> <strong class="ko ir">struct</strong> Style&lt;T&gt; {<br/>    <strong class="ko ir">private</strong> <strong class="ko ir">let</strong> callback: (T) -&gt; Void<br/>    <strong class="ko ir">public</strong> <strong class="ko ir">init</strong>(<strong class="ko ir">_</strong> callback: <strong class="ko ir">@escaping</strong> (T) -&gt; Void) {<br/>        <strong class="ko ir">self</strong>.callback = callback<br/>    }</span><span id="3a27" class="kx ky iq ko b gy ld la l lb lc"><strong class="ko ir">    public</strong> <strong class="ko ir">func</strong> apply(to candidate: T) {<br/>        callback(candidate)<br/>    }<br/>}</span></pre><p id="622e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常简单的概念，我们传入一个回调函数，稍后我们可以应用它。它本质上是一个<code class="fe kl km kn ko b">defer</code>但是有回调。</p><p id="f8b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到<code class="fe kl km kn ko b">combine</code>，我们只需要向两边<code class="fe kl km kn ko b">apply</code>。<code class="fe kl km kn ko b">combine</code>函数如下所示:</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="e75e" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">extension</strong> Style: Semigroup {<br/>    <strong class="ko ir">public</strong> <strong class="ko ir">func</strong> combine(with other: Style) -&gt; Style {<br/>        <strong class="ko ir">return</strong> Style {<br/>            <strong class="ko ir">self</strong>.callback($0)<br/>            other.callback($0)<br/>        }<br/>    }<br/>}</span></pre><p id="4087" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，现在我们有必要的基础来开始组合它们，就像乐高积木一样。再为<code class="fe kl km kn ko b">CALayer</code>补充一些吧。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="bf32" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">func</strong> border(width: CGFloat) -&gt; Style&lt;CALayer&gt; {<br/>    <strong class="ko ir">return</strong> .init { $0.borderWidth = width }<br/>}</span><span id="e84e" class="kx ky iq ko b gy ld la l lb lc"><strong class="ko ir">func</strong> border(color: UIColor) -&gt; Style&lt;CALayer&gt; {<br/>    <strong class="ko ir">return</strong> .init { $0.borderColor = color.cgColor }<br/>}</span><span id="00a2" class="kx ky iq ko b gy ld la l lb lc"><strong class="ko ir">func</strong> corner(radius: CGFloat) -&gt; Style&lt;CALayer&gt; {<br/>    <strong class="ko ir">return</strong> .init { $0.cornerRadius = radius }<br/>}</span></pre><p id="0363" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我建议将这个<em class="le">可重用的</em>代码存储在你的<em class="le"> App </em>项目之外的地方，比如一个<em class="le">框架/目标</em>。</p><p id="97de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在您的应用程序项目中，您可以像这样开始定义样式:</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="ce8b" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">let</strong> rounded = border(width: 0.5) &lt;&gt; border(color: .black) &lt;&gt; corner(radius: 4)</span><span id="96f8" class="kx ky iq ko b gy ld la l lb lc"><em class="le">// It can be applied like so:<br/></em>rounded.apply(to: view.layer)</span></pre><p id="e1dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能想知道为什么我们没有使用<code class="fe kl km kn ko b">concat</code>方法，这是因为我们还没有为我们的<code class="fe kl km kn ko b">Style</code>定义一个<code class="fe kl km kn ko b">empty</code>(或初始)状态。为此，我们需要创建一个<em class="le">幺半群</em>。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="0259" class="lm ky iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">幺半群</h1><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="8977" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">public</strong> <strong class="ko ir">protocol</strong> Monoid: Semigroup {<br/>    <strong class="ko ir">static</strong> <strong class="ko ir">var</strong> empty: Self { <strong class="ko ir">get</strong> }<br/>}</span></pre><p id="63d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">酷，现在让我们为我们的<code class="fe kl km kn ko b">Style</code>定义一个<code class="fe kl km kn ko b">empty</code>值…</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="a254" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">extension</strong> Style: Monoid {<br/>    <strong class="ko ir">public</strong> <strong class="ko ir">static</strong> <strong class="ko ir">var</strong> empty: Style&lt;T&gt; {<br/>        <strong class="ko ir">return</strong> .init { <strong class="ko ir">_</strong> <strong class="ko ir">in</strong> }<br/>    }<br/>}</span></pre><p id="6812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以使用我们之前定义的<code class="fe kl km kn ko b">concat</code>方法，或者……我们也可以创建一个新方法，它接受一个<em class="le">幺半群</em>并为我们设置初始值。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="3f0a" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">public</strong> <strong class="ko ir">func</strong> concat&lt;M: Monoid&gt;(<strong class="ko ir">_</strong> values: [M]) -&gt; M {<br/>    <strong class="ko ir">return</strong> values.reduce(M.empty, &lt;&gt;)<br/>}</span></pre><p id="5893" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这允许我们像这样定义样式:</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="3876" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">let</strong> rounded = concat([border(width: 0.5), border(color: .black), corner(radius: 4)])</span></pre><p id="74d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以翻转操作符，并在扩展中幺半群序列上定义concat来删除一些括号。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="d9cf" class="kx ky iq ko b gy kz la l lb lc"><strong class="ko ir">extension</strong> Sequence <strong class="ko ir">where</strong> Element: Monoid {<br/>    <strong class="ko ir">func</strong> joined() -&gt; Element {<br/>        <strong class="ko ir">return</strong> concat(Array(<strong class="ko ir">self</strong>))<br/>    }<br/>}</span><span id="7fd1" class="kx ky iq ko b gy ld la l lb lc"><strong class="ko ir">let</strong> rounded = [border(width: 0.5), border(color: .black), corner(radius: 4)].joined()</span></pre><p id="f9e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，上面的代码小而简洁，没有向初级开发人员暴露任何可怕的操作符。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="f30a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个简单的概念来说，用例是无穷无尽的，并且可以减少代码中的循环次数，因为您总是将代码展平到一个组合中，而不是传递数组。</p><p id="bf40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这应该是开始将它包含在您自己的代码中的足够好的入门。尽情享受吧！</p><p id="f150" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">半群:<a class="ae mo" href="https://gist.github.com/cjnevin/9e9ef3f4f9a2f223c723ace9b0a959bf" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/CJ nevin/9e 9 ef 3 F4 F9 a2 f 223 c 723 ace 9 B0 a 959 BF</a></p><p id="a933" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">mono id:<a class="ae mo" href="https://gist.github.com/cjnevin/f683619e2841e71543c5e8fa0405c969" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/CJ nevin/f 683619 e 2841 e 71543 C5 E8 fa 0405 c 969</a></p></div></div>    
</body>
</html>