<html>
<head>
<title>TypeScript 3.0 — what has come?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 3.0 —带来了什么？</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-3-0-what-has-come-19f81d1fac60?source=collection_archive---------1-----------------------#2018-07-31">https://itnext.io/typescript-3-0-what-has-come-19f81d1fac60?source=collection_archive---------1-----------------------#2018-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1710" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TypeScript 2.0发布近两年、最新版本2.9发布两个月后，微软发布了最新版本的TypeScript。让我们看看发生了哪些变化，以及这些变化对我们的日常工作有何影响。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ff4ffb2c3e1b676c21351ab7df84ce7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lzf8w-N-QK7iq8pwv4UPBw.jpeg"/></div></div></figure><p id="8ea9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TypeScript 3.0中，我们可以识别出影响语言使用方式的五个变化。其中只有一个被标记为重大变更。不过介绍够了，来看看有什么新的吧！</p><h1 id="80e1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">更丰富的元组类型</h1><p id="d132" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">TypeScript中的元组实际上是具有恒定长度的JavaScript强类型数组(在单个元素级别)。至少，过去是这样的，您可以在清单1中看到一个例子。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">在TypeScript中列出1个元组</figcaption></figure><p id="5688" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从TypeScript 3.0开始，我们可以用未定义的最大元素数定义元组，只需要最小元素数。清单2给出了一个例子。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">清单2中的元组具有未定义的最大元素数</figcaption></figure><p id="6e42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个元素有一个string类型，这是强制的，但是其余的只是数字，可以省略。更有甚者，我们甚至可以定义没有下限的元组(其实只是一个数组)或者空元组。请参见清单3。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">清单3空元组和没有下限的元组</figcaption></figure><p id="649a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样的元组有实际用途。例如，我们可以强制一个数组在类型级别上至少有一个元素。本文的下一部分将展示在更复杂的环境中的另一种用法。</p><h1 id="0292" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用元组类型提取和传播函数参数</h1><p id="a2ad" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如你所知，在JavaScript中，我们可以通过使用<em class="mg"> arguments </em>变量来使用提供给函数的参数，即使我们在代码中没有命名任何参数。当然，这在TypeScript(默认配置)中是不允许的，在这里我们必须告诉编译器一切。区别如清单4所示。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">清单4使用未在函数定义中定义的参数的例子</figcaption></figure><p id="c675" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对编译器来说没问题，但是当我们使用TypeScript时，我们不想使用<em class="mg">任何</em>类型。假设我们希望只提供字符串和数字。然后，我们当然可以将<em class="mg">的任意</em>改为<em class="mg">(字符串|数字)</em>。但是，这样我们就告诉编译器“我想要一个包含字符串或数字的数组”。我们不限制哪个元素是字符串，哪个是数字，应该有多少个。假设我们知道第一个参数是一个字符串，后面两个是数字，剩下的是字符串。在TypeScript 3.0中，我们可以使用清单5所示的元组类型来定义它。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">清单5隐式定义了arguments数组中每个参数的类型</figcaption></figure><p id="7faf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个不同的用例怎么样？让我们看看清单6。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">清单6组合两个给定函数的函数及其用法</figcaption></figure><p id="fa03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript 3.0允许我们做一个泛型类型<em class="mg"> T1扩展any[] </em>，这实际上创建了一个元组类型。这里我们告诉编译器<em class="mg"> T1 </em>是第一个函数的所有参数的类型。它可以是任何东西，但是我们将它强类型化。正如您在清单6的最后一行中看到的，严格的类型检查起作用，并告诉我们，我们不能用字符串代替数字。这个例子表明，我们将能够在函数式编程中使用这种类型。也许将来我们会为像Ramda这样的图书馆做更好的打字？</p><h1 id="92d4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">"未知"</h1><p id="3165" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如你所知，TypeScript有一个<em class="mg"> any </em>类型，可以处理几乎所有的事情——它恢复了JavaScript对特定变量的弱类型。过度使用它是一种不好的做法，但是由于JavaScript的本性，有时我们需要它。一种情况是，当我们不知道类型时，我们想使用<em class="mg"> any </em>，但是我们会检查它是什么，然后使用强类型。有了<em class="mg"> any </em>，我们甚至不需要检查类型——我们可以像那样使用一个变量，而不会出现编译错误。在TypeScript 3.0中，我们可以使用未知的类型。它告诉编译器“我们不知道这里有什么，所以在我们知道它是什么之前，我们不能使用它”。区别如清单7所示。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">清单7任意和未知之间的区别</figcaption></figure><p id="a7b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，这是一个突破性的改变，因为从3.0版本开始<em class="mg"> unknown </em>变成了一个语言的关键字，所以不能再作为名字使用了。</p><h1 id="23e5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">支持defaultProps</h1><p id="bc7c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">TypeScript 3.0的另一个新颖之处是对React的<em class="mg"> defaultProps </em>的语言级支持。没听说过<em class="mg"> defaultProps </em>的，我简单描述一下。通常，在JavaScript (ECMAScript 6)中，如果我们想要提供默认的React组件的参数，我们将使用静态对象<em class="mg"> defaultProps </em>来完成，如清单8所示。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">清单8在JavaScript中使用defaultProps</figcaption></figure><p id="7491" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，由于defaultProps的使用，我们不需要对title执行空检查，因为我们确信它总是有一些值。在过去，TypeScript不能理解这一点，我们必须进行空检查。在清单9和清单10中，我展示了我们如何在TypeScript 2.x中处理这个问题，以及我们现在可以如何做。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">清单9 TypeScript 2.x使用defaultProps的方式</figcaption></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">清单10 TypeScript 3.0使用defaultProps的方式</figcaption></figure><p id="c621" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，来自最新TypeScript版本的代码不需要null检查，因为编译器可以看到在<em class="mg"> defaultProps </em>中定义的参数值。</p><h1 id="d353" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">项目参考</h1><p id="4a8d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">可能是TypeScript 3.0最大的新特性。从现在开始，我们将能够定义跨项目引用。由于这一变化，我们将能够使用一些新的项目架构场景，如:</p><p id="3324" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为客户端和服务器项目使用共享代码。编译后的输出也将共享代码，而不是拥有每个共享代码文件的单独副本。</p><p id="417e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不包含主项目文件副本的单元测试。</p><p id="5e06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Monorepos(许多项目相互依赖)，以及使用经过战斗考验的解决方案，如Lerna和Yarn Workspaces</p><p id="d19c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这都要归功于tsconfig中的新条目:编译器选项的<em class="mg">复合</em>标志和<em class="mg">引用</em>。此外，我们为tsc (TypeScript的编译器)提供了一个新参数:build，它可以根据给定的tsconfig构建整个TypeScript项目。</p><p id="b6c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，让我们考虑以下项目结构:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/fd43ac83f8abfb33486d7ac00bc62b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:218/format:webp/1*V2spFhyFUpiNkN_TiPf8gg.png"/></div></figure><p id="512a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">清单11提供了客户的项目<em class="mg"> tsconfig.json </em>。可以使用命令:<em class="mg"> tsc -b composite/client </em>来构建它。要使用一个共享项目，我们只需从其中导入我们需要的东西，而无需在代码中添加任何额外的结构。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">清单11带有复合标志的tsconfig.json和对共享项目的引用</figcaption></figure><p id="000c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译客户端和服务器后，我们得到以下结构:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/e5874a91c18ddbb73fa2fa41f36155f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/format:webp/1*4nYCrOE_btwQZU2Ce2CKpg.png"/></div></figure><p id="0418" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，“共享”目录实际上是在客户机和服务器之间共享的。在旧版本中，我们将“共享”目录复制到客户机和服务器，从而创建不同于源结构的输出结构。</p><p id="48a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于如何在Lerna中使用项目引用的信息，我推荐这个GitHub资源库:<a class="ae mj" href="https://github.com/RyanCavanaugh/learn-a" rel="noopener ugc nofollow" target="_blank">https://github.com/RyanCavanaugh/learn-a</a>。</p><h1 id="bae8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结束…</h1><p id="e602" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">正如我们所看到的，没有太多的变化。他们主要关注的是为更多的JavaScript情况提供静态类型的类型系统。最大的变化当然是项目引用。然而，就目前而言，我们无法判断它的应用范围有多广。我渴望看到它将为我的新项目和现有项目提供多少价值，以及它将如何影响其他项目。</p><p id="96dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">帖子也发表在<a class="ae mj" href="http://www.synergycodes.com/blog/typescript-3-what-has-come" rel="noopener ugc nofollow" target="_blank"> Synergy Codes的博客</a>上。</p><p id="05bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您对创建数据可视化应用程序感兴趣吗？<a class="ae mj" href="https://synergycodes.com/gojs-ebook/" rel="noopener ugc nofollow" target="_blank">点击这里了解GoJS库</a>！</p></div></div>    
</body>
</html>