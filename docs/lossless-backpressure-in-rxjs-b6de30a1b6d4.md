# RxJS 中的无损背压

> 原文：<https://itnext.io/lossless-backpressure-in-rxjs-b6de30a1b6d4?source=collection_archive---------1----------------------->

![](img/26317545ebe3f1a2f3a60e5869b890cd.png)

由 [Kees Streefkerk](https://unsplash.com/@kees_streefkerk?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

## 将 Node.js 流转换为 RxJS 管道

**TL；dr** 我想出了一个无损的方法，用 RxJS 处理异步迭代器、生成器和 Node.js 流中的反压力。

*这篇文章是我帮助那些无法利用一套技能应对各种情况(如 RxJS 和背压)的人的方式。RxJS 是一个非常棒的流库，您不应该在它的基础上学习迭代器、生成器和 Node.js 流，特别是如果您已经精通了最伟大的流库之一。我的目标是让 RxJS 开发人员最终将这个功能添加到 RxJS 中，就像他们添加 WebSocketSubject 一样。*

# 什么是背压？

当你的消费者比你的生产者慢时，反压力就产生了。

背压的几个例子是鼠标移动事件、窗口大小调整事件和解析文件。所有这些都可能导致发生比您的用户能够处理的事件更多的事件，或者在读取文件的情况下，对您的机器来说有太多的内存来处理。

要处理这些问题，您可以使用有损或无损方法。有损方法包括采样、节流和去抖动。而无损方法包括缓冲和暂停。

无损背压在读取文件时非常重要；例如，因为您不希望在处理文件时丢失文件的某些部分。另一方面，像鼠标移动这样的事件可能会有损失，因为您的监视器一秒钟只能更新这么多次，而鼠标移动事件发出的频率要高得多。

# IxJS 与 RxJS

RxJS 是一个推送库，生产者向消费者抛出数据。在同一伞下还有另一个名为 IxJS 的库。很长一段时间，我都不明白为什么有两个独立的库做着本质上相同的事情，直到我意识到 IxJS 是一个拉库，旨在支持同步和异步迭代器。尽管 RxJS 支持通过`from` observable 的迭代器，但它并没有赋予您处理背压的能力。

理解拉数据和推数据之间的区别很重要，因为这会改变您处理背压的方式。

从管道的角度来看，迭代器和观察器本质上是一样的，但是当你开始考虑为什么你需要其中一个的时候，你对库的选择就开始起作用了。

我认为你不需要 IxJS，但是两者都有它们的位置。虽然拥有一个类似于 RxJS 的完整迭代器库对于特定的工作流来说是非常好的，但是在 RxJS 中拥有控制迭代器的能力可能会更好。我创建了许多 web 应用程序，我发现只引入 RxJS(正常用例)比同时引入 RxJS 和 IxJS 更能节省库空间。在单个库上训练一个开发团队也比在一堆不同的库中容易得多。

# 问题是

迭代器要求您在准备处理下一组数据时通过请求获取数据来获取数据。这样做的好处是可以显著减少内存占用，因为在处理完上一个值之后，您只需要获取下一个值。如果您通过`pipe`方法而不是使用事件处理程序来创建转换，那么您也可以访问 Node.js 流中的类似机制。

因此，迭代器和 Node.js 流有能力处理无损背压，但是 RxJS 没有(不像 IxJS ),而且最重要的是，RxJS 不能开箱即用地处理 Node.js 流。

事实上，可测量和可观察之间有很多相似之处。例如，iterables 实现迭代器，而 observables 实现观察者。两者都是生产者，但是迭代器等待消费者请求下一个值，而观察者一旦得到下一个值就给消费者。它们是一样的，但是颠倒了。

因为可观察对象是单向数据流，所以没有办法回调可观察对象并告诉它像可迭代对象那样处理更多数据。如果我们能够利用观察器，那么我们就能够使用两次推送来模拟 IxJS 拉库。已经有一个专门为此目的设计的工具:subject。

就像生成器是可迭代对象的更高级版本一样，主体是更高级的可观察对象。生成器允许你控制迭代器，而主语允许你控制观察者。正如主体既是观察者又是可观察对象，生成器既是迭代器又是可迭代的。这是我们向 RxJS 添加拉取功能的关键。

# RxJS 中的迭代器支持被破坏

RxJS 本身支持迭代器，但是实现被破坏了，因为它没有考虑背压:

在这个例子中，我在生成器的管道中放置了 1 秒钟的延迟。我们可以假设这个延迟是一个 AJAX 调用。

由于 RxJS 处理迭代器的方式，我们看到一堆传入的值被循环遍历并推入流中，即使流的速度跟不上。如果我们有一个非常大的集合，当我们的管道努力处理所有的值时，它将全部被加载到内存中。

让我们假设这是一个高级生成器，它需要 AJAX 调用的返回值，然后才能继续下一个产出。如果是这种情况，就没有办法把一个值返回给生成器；相信我，我试过了。

# 这个想法

真正让 RxJS 与生成器一起工作的唯一方法是使用 subjects。这是最接近的转换。这给了你传入参数的能力，当你准备好接受另一个值时告诉它。

我们需要的是一种利用迭代器等待获取下一个值的能力的方法，直到你提出请求。

我为生成器创建了一个包装函数，将它们转换成主题。下面是一个更简单的例子:

关键是等待，直到我们在我们的订户中点击`next`。此时，我们可以向迭代器请求另一个值。所以我们不会遇到内存泄漏，迭代器有一个`done`属性，表示我们应该`complete`我们的可观察对象。

这个例子不是灵丹妙药。它没有解决将值传递回生成器的问题，但这是一个快速解决方法。因为生成器上的第一个`next`调用不能传递值，所以我们可以在不传递值的情况下调用它。这个例子也有问题，因为它没有处理生成器可以输出单个值并立即结束的情况。

# 迭代器背压的正确处理

根据最初的想法，我们可以把它推广到一个函数中:

当您在`iterator$`上调用我们的自定义`push`方法时，它会将该值传递给生成器，生成器会返回一个新值。然后，新值通过流传递。如果你使用过`WebSocketSubject`，这是相同类型的实现，除了我没有重载`next`方法。

一次将数据放入生成器，另一次将值放入流。这就是为什么一个拉力可以通过两个推力来满足，让一个主体可以模仿一个发电机，但是有更多的功能。

让我们对照我们最初的可观察管道来试试`createIteratorSubject`:

现在我们可以处理背压。迭代器只在我们需要时计算下一个值。除了使用`subscribe`方法，还可以使用`tap`获得相同的结果。

# Node.js 流转换

Node.js 有自己的流处理器，RxJS 不支持。有几个库可以增加兼容性，但我认为它们没有抓住要点。它们也不能处理背压的情况，这也是我使用 Node.js 流的原因。

让我们看看如何创建一个简单的转换流，它将小说中的每个字母都大写，然后输出到一个新文件中:

如果您曾经做过大量的 Node.js 开发，那么您会遇到很多这种类型的代码。每个`pipe`函数只能接受一个流。最常见的是转换流，如果您曾经使用过 Gulp，那么有一大堆转换流可以满足您的任何需求。

不过，我非常了解 RxJS，但是我不知道我是如何开始做我在 Node.js 转换流中习惯的许多疯狂的事情的。老实说，我花了令人尴尬的长时间才弄清楚如何编写一个定制的转换流，甚至首先弄清楚 Node.js 流是如何工作的。我记得就在 3 年前我还在使用 Gulp，即使在那时，做任何定制的东西都不是直觉。

我创建了自己的 RxJS 实现，类似于迭代器示例，而不是必须学习一种完全不同的流方法——无论如何，我都必须学习这种方法来撰写本文。

# RxJS 控制 Node.js 流

在向您展示实现之前，我想先看一下用法，因为它有一些不同之处:

我们像以前一样将`transformStream$.next`传递给订户的`next`道具。这使得我们只有在处理完这个块之后才能得到另一个块，但是在处理转换流时还有更多。

如果我们想将该值传递给下一个 Node.js 流(我们的写流),我们还需要调用`transformStream$.push`。在这种情况下，任何时候我们想向文件中写入一段文本，我们都会调用`transformStream$.push`，然后使用`transformStream$.next`来请求下一个值，因为我们已经完成了处理。

有很多原因使您希望将这些分成两种不同的方法，但这超出了本文的范围。

这里的目标是，当我们处理完最后一个块时，我们只接受一个传入的块，这就是我们所看到的。很漂亮吧？我们所有的转换流现在可以合并到一个单一的 RxJS 可观察管道中，而不是一堆非常复杂的`pipe`方法。

你需要在你的管道末端有一个写流，这样它才能完成处理，所以我试着在`transformStream$`中调用`writeStream.write(value)`和`writeStream.end()`，但是我不能让它工作，因为它实际上会写超过几兆字节的数据，也不会结束流。正因为如此，我在`transformStream$.stream`上公开了原始的 Node.js 流。您可以创建自己的写流，但是对于这个例子，我将写回另一个文件，因为这是一个正常的用例。

现在让我们看一下实现:

每次在我们的`transformStream`对象中调用`transform`时，它给我们调用`callback`函数的能力，该函数要求另一个值。使用`chunk$`，我们能够控制调用`callback`函数。注意`take(1)`的使用。呼叫回拨后，需要立即取消订阅此即时订阅；否则，您将会以内存泄漏而告终。

我们还订阅了`push$`，它允许我们在调用`transformStream$.push`时将值推入 Node.js 流。这就是大写值被传递到写流的方式。

另一个重要部分是倾听触发所有 3 个科目完成的`finish`事件。这是另一种情况，如果没有正确关闭，您可能会发现内存泄漏。

# 结论

在能够编写这些背压助手之前，我花了很多时间做研究，开发出一个干净的 API，并找到了大量的在线示例。我知道*我将*在未来使用这些实现，而不是弄清楚如何弄乱生成器或试图记住关于 Node.js 流的一切，当我可能需要再次使用它们的时候。

对我来说，真正学好一件事意味着更容易继续使用这件事，即使它不是每个用例的最佳解决方案。虽然我坚信在工作中使用正确的工具，但我相信我已经展示了 RxJS 可以是管理背压时的正确工具。当我每天都在使用它时，它更容易使用，也更容易记住。

# 更多阅读

如果你对更多与 RxJS 相关的话题感兴趣，你应该看看我的其他文章:

*   [RxJS 和可观察的 Flic 按钮](https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407)
*   [Redux-Observable 可以解决你的状态问题](https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7)
*   [处理缓存和 AJAX 竞争条件](/handling-cache-and-ajax-race-conditions-4cb152db8764)
*   [把暴风雨的云变成晴朗的云](/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3)