<html>
<head>
<title>Decoding Nested JSON Objects in ReasonML with bs-json</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用bs-json解码ReasonML中的嵌套JSON对象</h1>
<blockquote>原文：<a href="https://itnext.io/decoding-nested-json-objects-in-reasonml-with-bs-json-4cab75fbe308?source=collection_archive---------5-----------------------#2018-11-19">https://itnext.io/decoding-nested-json-objects-in-reasonml-with-bs-json-4cab75fbe308?source=collection_archive---------5-----------------------#2018-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/f1bfa9f766e97d2103c4c56db5ce58d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*XwBzMn9kPYijdDk3mgEtxw.jpeg"/></div></figure><p id="f1ee" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在JavaScript的狂野西部，解析JSON数据是微不足道的。如果我们有下面的JSON:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4a61" class="le lf it la b gy lg lh l li lj">const myJson = {<br/>  "page": 1,<br/>  "pageCount": 12,<br/>  "pageSize": 25,<br/>  "items": [<br/>    {<br/>      "id": 12,<br/>      "active": true,<br/>      "title": "The Trials and Tribulations of Tristram Shandy.",<br/>      "date": {<br/>         "start": "2004-09-16T23:59:58.75",<br/>         "end": "2004-09-16T23:59:58.79"<br/>      },<br/>      "code": "12345"<br/>    },<br/>    {<br/>      "id": 10,<br/>      "active": true,<br/>      "title": "The Life and Letters of Leonard Lego.",<br/>      "date": {<br/>         "start": "2004-09-16T23:59:58.75",<br/>         "end": "2004-09-16T23:59:58.79"<br/>      }<br/>    }<br/>  ]<br/>};</span></pre><p id="62ff" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面的代码将解析它:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="c61c" class="le lf it la b gy lg lh l li lj">JSON.parse(myJson);</span></pre><p id="4f3a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在强类型的推理世界中完成同样的任务可能需要更多的代码。一般来说，原因是显而易见的。在这种情况下，这意味着您需要声明您的数据类型和您的解码器。</p><p id="166e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在本文中，我们将回顾如何解码嵌套的JSON，就像上面的例子一样，使用最常见的原因之一JSON编码/解码库<code class="fe lk ll lm la b">bs-json</code>。</p><p id="94d8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe lk ll lm la b">bs-json</code>是一个用于BuckleScript的复合JSON编码/解码库。它提供了一组解码器功能，您可以将它们组合成更复杂的解码器。BuckleScript将OCaml/ReasonML文件转换为JavaScript。关于<code class="fe lk ll lm la b">bs-json</code>的深入细节，请访问他们的文档:(<a class="ae ln" href="https://github.com/glennsl/bs-json" rel="noopener ugc nofollow" target="_blank">https://github.com/glennsl/bs-json</a>)。</p><p id="0e14" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">文档很好地描述了如何设置<code class="fe lk ll lm la b">bs-json</code>，并做了基本的JSON解析。他们没有详细说明的是如何解码复杂的JSON对象。</p><p id="3952" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你曾经用C#或Java之类的语言做过JSON解码，那么用ReasonML解码和编码JSON将会是一个非常熟悉的体验。然而，如果你只做过JavaScript，那么ReasonML中的JSON解码可能会有点令人生畏。如果那是你，希望这篇文章能帮到你。</p><p id="61a2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">示例应用程序</strong></p><p id="9aa3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">假设我们正在处理一个列出待售书籍的应用程序。主页上显示了出售书籍的清单。我们查询一个API，它返回一个包含所有书籍的JSON对象。</p><p id="a5cc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">解码过程</strong></p><p id="62bd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我将假设你已经按照https://github.com/glennsl/bs-json<a class="ae ln" href="https://github.com/glennsl/bs-json" rel="noopener ugc nofollow" target="_blank">网站上的步骤安装了你的应用程序(如果没有，这里还有链接:</a>)。</p><p id="e1ae" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">解码JSON的第一步是编写一个JSON解码器。编写解码器包括三个步骤:</p><ol class=""><li id="9f40" class="lo lp it jz b ka kb ke kf ki lq km lr kq ls ku lt lu lv lw bi translated">编写类型来定义您的数据(如果您还没有)</li><li id="8862" class="lo lp it jz b ka lx ke ly ki lz km ma kq mb ku lt lu lv lw bi translated">为每种类型编写一个解码器</li><li id="e134" class="lo lp it jz b ka lx ke ly ki lz km ma kq mb ku lt lu lv lw bi translated">打电话给解码器</li></ol><p id="bd65" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">写入类型</strong></p><p id="f39e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们使用上面定义的JSON数据。为了方便起见，这里又是:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="ec43" class="le lf it la b gy lg lh l li lj">const myJson = {<br/>  "page": 1,<br/>  "pageCount": 12,<br/>  "pageSize": 25,<br/>  "items": [<br/>    {<br/>      "id": 12,<br/>      "active": true,<br/>      "title": "The Trials and Tribulations of Tristram Shandy.",<br/>      "date": {<br/>         "start": "2004-09-16T23:59:58.75",<br/>         "end": "2004-09-16T23:59:58.79"<br/>      },<br/>      "code": "12345"<br/>    },<br/>    {<br/>      "id": 10,<br/>      "active": true,<br/>      "title": "The Life and Letters of Leonard Lego.",<br/>      "date": {<br/>         "start": "2004-09-16T23:59:58.75",<br/>         "end": "2004-09-16T23:59:58.79"<br/>      }<br/>    }<br/>  ]<br/>};</span></pre><p id="aa13" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">看数据，我们至少有三种类型。一种类型应该定义项目集。另一种类型应该定义单个项目。最后一个类型应该定义日期。在这个例子中，我们只是为每个对象定义一个类型。在您的代码中，您也可以为单个属性定义类型。</p><p id="e9a6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是上述JSON的定义类型。这些类型并不完美。然而，它们很简单，它们将用来说明我们需要做什么。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="302e" class="le lf it la b gy lg lh l li lj">type bookDate = {<br/>  start: string,<br/>  end: string<br/>}</span><span id="cb4f" class="le lf it la b gy mc lh l li lj">type book = {<br/>  id: int,<br/>  active: bool,<br/>  title: string,<br/>  date: bookDate,<br/>  code: option(string),<br/>};</span><span id="6d7e" class="le lf it la b gy mc lh l li lj">type bookOffers = {<br/>  page: int,<br/>  pageCount: int,<br/>  pageSize: int,<br/>  itemCount: int,<br/>  items: array(book),<br/>};</span></pre><p id="787c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于每种类型，我们创建一个解码器:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="618d" class="le lf it la b gy lg lh l li lj">let decodeBookDate= json =&gt;<br/>  Json.Decode.{<br/>    start: json |&gt; field("start", string),<br/>    end: json |&gt; field("end", string)<br/>  };</span><span id="a5a3" class="le lf it la b gy mc lh l li lj">let decodeBook= json =&gt;<br/>  Json.Decode.{<br/>    id: json |&gt; field("id", int),<br/>    active: json |&gt; field("active", bool),<br/>    title: json |&gt; field("title", string),<br/>    date: json |&gt; field("date", decodeBookDate),<br/>    code: json |&gt; optional(field("code", string))<br/>  };</span><span id="b7b2" class="le lf it la b gy mc lh l li lj">let decodeBookOffers = json =&gt;<br/>  Json.Decode.{<br/>    page: json |&gt; field("page", int),<br/>    pageCount: json |&gt; field("pageCount", int),<br/>    pageSize: json |&gt; field("pageSize", int),<br/>    itemCount: json |&gt; field("itemCount", int),<br/>    items: json |&gt; field("items", array(decodeBook)),<br/>  };</span></pre><p id="2b62" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意解码器是如何相互作用的。例如，<code class="fe lk ll lm la b">decodeBookOffers</code>解码器的<code class="fe lk ll lm la b">items</code>属性的解码器指向<code class="fe lk ll lm la b">decodeBook</code>解码器。同样，<code class="fe lk ll lm la b">decodeBook</code>解码器的<code class="fe lk ll lm la b">date</code>属性指向<code class="fe lk ll lm la b">decodeBookDate</code>解码器。</p><p id="bd12" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来，也是最后一件事，就是使用你的解码器。这部分很简单:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="2b70" class="le lf it la b gy lg lh l li lj">Js.Promise.(<br/>    Fetch.fetch("http://my.api.com/bookOffers?page=1&amp;pageSize=10")<br/>    |&gt; then_(Fetch.Response.json)<br/>    |&gt; then_(json =&gt;<br/>         json |&gt; BookDecoder.decodeBookOffers<br/>              |&gt; (offers =&gt; send(OffersFetched(offers))) <br/>              |&gt; resolve<br/>       )<br/>    |&gt; catch(_err =&gt; {<br/>         Js.log(_err);<br/>         Js.Promise.resolve(send(OffersFailedToFetch));<br/>       })<br/>    |&gt; ignore<br/>  );</span></pre><p id="9468" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是使用<code class="fe lk ll lm la b">bs-json</code>解码嵌套对象的方法。尽情享受吧！</p></div></div>    
</body>
</html>