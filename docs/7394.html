<html>
<head>
<title>Journey Of A Microservice Application In The Kubernetes World</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes世界的微服务应用之旅</h1>
<blockquote>原文：<a href="https://itnext.io/journey-of-a-microservice-application-in-the-kubernetes-world-3c2a9e701e9f?source=collection_archive---------0-----------------------#2022-09-10">https://itnext.io/journey-of-a-microservice-application-in-the-kubernetes-world-3c2a9e701e9f?source=collection_archive---------0-----------------------#2022-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="afe4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在k3s上本地运行应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/83297337d3ad1384b3134d946630b11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-n_t7UPM0iy9tNOtFPViw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">普里西拉·杜·普里兹在<a class="ae ky" href="https://unsplash.com/s/photos/local?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="8872" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="95a2" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-bdfe795532ef">的上一篇文章</a>(本系列的第一篇)中，我们介绍了<a class="ae ky" href="https://webhooks.app" rel="noopener ugc nofollow" target="_blank"> webhooks </a>应用程序，并了解了如何使用Docker Compose在本地运行它。我们现在将在本地Kubernetes集群上部署相同的应用程序。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="d05b" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">本系列文章</h2><ul class=""><li id="f0ce" class="mv mw it lx b ly lz mb mc li mx lm my lq mz mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-bdfe795532ef">web hooks . app的展示</a></li><li id="b775" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">使用Helm在Kubernetes上运行应用程序(当前文章)</li><li id="3c63" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-e800579f0be3">在Civo Kubernetes集群上运行应用</a></li><li id="4dff" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-d9493b19edff">使用GitOps和ArgoCD进行连续部署</a></li><li id="cf28" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-876f72ce1681">使用Loki堆栈的可观察性</a></li><li id="4a4d" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-e2f6475ddde1">使用Acorn定义应用</a></li><li id="2244" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-6abd625c60fe">安全注意事项:安全相关工具</a></li><li id="7bea" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-eb0fb52e1bf0">安全考虑:修复错误配置</a></li><li id="3c61" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/journey-of-a-microservice-application-in-the-kubernetes-world-f760cba7600f">安全考虑:策略实施</a></li><li id="24c3" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">安全考虑:漏洞扫描(即将推出)</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="ea33" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在这篇文章中</h2><p id="ef39" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">既然我们对应用程序有了基本的了解，并且知道如何使用Docker Compose在本地运行它，那么是时候更进一步，在Kubernetes上运行它了。在本文中，我们将完成以下任务:</p><ul class=""><li id="c239" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated">基于k3s创建本地Kubernetes集群</li><li id="ced5" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">解释如何将应用程序打包成一个舵图，并将其部署在集群上</li><li id="fd95" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">添加一个入口控制器来暴露应用程序，以便我们可以从浏览器访问它</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="3541" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建本地k3s集群</h2><p id="9ea0" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们将首先使用<a class="ae ky" href="https://multipass.run" rel="noopener ugc nofollow" target="_blank"> Multipass </a>创建一个Ubuntu VM，并在其中安装<a class="ae ky" href="https://k3s.io" rel="noopener ugc nofollow" target="_blank">k3s</a>(Rancher的一个轻量级Kubernetes发行版)。</p><p id="e2ea" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注:运行一个本地Kubernetes集群有很多解决方案(<a class="ae ky" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>，<a class="ae ky" href="https://microk8s.io/" rel="noopener ugc nofollow" target="_blank"> microk8s </a>，<a class="ae ky" href="https://k0sproject.io/" rel="noopener ugc nofollow" target="_blank"> k0s </a>，…)，<a class="ae ky" href="https://multipass.run" rel="noopener ugc nofollow" target="_blank">Multipass</a>+<a class="ae ky" href="https://k3s.io" rel="noopener ugc nofollow" target="_blank">k3s</a>是我的最爱之一。</p><ol class=""><li id="22c2" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn nr nb nc nd bi translated"><strong class="lx iu">配置本地虚拟机</strong></li></ol><p id="e451" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">一旦在本地机器上安装了Multipass，我们就创建一个名为kube的VM。虚拟机启动并运行只需几十秒钟:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="0d0e" class="kz la it nt b gy nx ny l nz oa">$ multipass launch --name kube --cpus 4 --mem 4G --disk 10G</span></pre><p id="842d" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注意:默认情况下，Multipass创建一个具有1个cpu、1G RAM和5G HD的虚拟机。在上面的命令中，我们使用专用标志给了VM更多的资源。</p><p id="58e6" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">我们检索该虚拟机的外部IP地址，因为我们稍后会用到它:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="78e4" class="kz la it nt b gy nx ny l nz oa"><strong class="nt iu">$ multipass info kube</strong><br/>Name:           kube<br/>State:          Running<br/>IPv4:           <strong class="nt iu">192.168.205.22  &lt;- we will use in the test step</strong><br/>                10.42.0.0<br/>                10.42.0.1<br/>Release:        Ubuntu 20.04.4 LTS<br/>Image hash:     a12805170d70 (Ubuntu 20.04 LTS)<br/>Load:           1.18 1.18 1.12<br/>Disk usage:     3.8G out of 9.5G<br/>Memory usage:   1.2G out of 3.8G<br/>Mounts:         --</span></pre><p id="43ed" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated"><strong class="lx iu"> 2。安装k3s </strong></p><p id="13e4" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">首先，我们在虚拟机上运行一个shell</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="968a" class="kz la it nt b gy nx ny l nz oa">$ multipass shell kube</span></pre><p id="1406" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">接下来我们安装k3s:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="ac5d" class="kz la it nt b gy nx ny l nz oa">~$ curl -sfL <a class="ae ky" href="https://get.k3s.io" rel="noopener ugc nofollow" target="_blank">https://get.k3s.io</a> | sh -s - —-no-deploy=traefik</span></pre><p id="f01e" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注意:标志<em class="ob"> - no-deploy=traefik </em>用于防止traefik入口控制器的默认安装。我们将在下一步使用特定的参数安装它</p><p id="43a3" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">再一次，k3s应该只需要几十秒就可以启动并运行了(很漂亮，对吧？:) ).我们可以使用以下命令来验证这一点，该命令使用k3s中嵌入的kubectl客户端:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="5954" class="kz la it nt b gy nx ny l nz oa">ubuntu@kube:~$ sudo k3s kubectl get no<br/>NAME   STATUS   ROLES                  AGE   VERSION<br/>k3s    Ready    control-plane,master   34s   v1.24.4+k3s1</span></pre><p id="58a8" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated"><strong class="lx iu"> 3。从您的本地机器</strong>访问集群</p><p id="9386" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">在上一步中，我们从虚拟机内部运行kubectl命令，但是在现实世界中，集群是从节点外部访问的。</p><p id="3b53" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">一旦我们在本地机器上安装了<a class="ae ky" href="https://kubernetes.io/docs/tasks/tools/#kubectl" rel="noopener ugc nofollow" target="_blank"> <em class="ob"> kubectl </em> </a>二进制文件，我们就会获得在集群创建期间创建的kubeconfig文件，并将其保存在本地:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="8228" class="kz la it nt b gy nx ny l nz oa">$ multipass exec kube -- sudo cat /etc/rancher/k3s/k3s.yaml &gt; config</span></pre><p id="83f1" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">接下来，我们将本地IP替换为虚拟机的IP地址:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="457c" class="kz la it nt b gy nx ny l nz oa">IP=$(multipass info kube | grep IP | awk '{print $2}')<br/>sed -i.bak "s/127.0.0.1/$IP/" config</span></pre><p id="5b7d" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">然后我们通过设置KUBECONFIG环境变量来配置我们的本地kubectl:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="4a1c" class="kz la it nt b gy nx ny l nz oa">export KUBECONFIG=$PWD/config</span></pre><p id="2c71" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">我们现在可以列出本地机器上的节点(这里只有一个):</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="ff4f" class="kz la it nt b gy nx ny l nz oa">$ kubectl get no<br/>NAME   STATUS   ROLES                  AGE     VERSION<br/>k3s    Ready    control-plane,master   3m51s   v1.24.4+k3s1</span></pre><p id="ab69" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">我们的集群已经准备好了，我们可以从本地机器与它通信，现在让我们看看如何准备应用程序，以便它可以在Kubernetes中运行。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="9e30" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关于容器图像</h2><p id="cba9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在上一篇文章中，我们使用Docker Compose来运行应用程序。第一次运行<em class="ob"> docker compose up </em>命令时，构建容器映像，然后启动容器。</p><p id="8b5f" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">为了在Kubernetes中运行应用程序，需要预先创建容器映像并将其托管在容器注册表中，这样Kubernetes就可以将它们下载到集群的节点上，并在其中运行容器。</p><p id="0bb6" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">正如我们之前看到的，每个GitLab存储库(包括<strong class="lx iu"> api </strong>、<strong class="lx iu"> ws </strong>、<strong class="lx iu"> www </strong>)都有自己的容器注册中心。每次将代码更改推送到微服务存储库的主分支时，CI都会触发构建容器映像并将其推送到注册中心。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/d2f4db6d5ccb23fdd4d8c655a9df04ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9YigfjPACxNnvWYnaclnPQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">已经为api微服务构建的容器映像的历史</figcaption></figure><p id="638a" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">通向api微服务映像的途径是<em class="ob">registry.gitlab.com/web-hook/api:TAG, w</em>e将在我们下一步创建的Kubernetes部署规范中引用这些映像。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="25ac" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">从Docker Compose到Kubernetes规范</h2><p id="f320" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Kubernetes不知道如何运行Docker Compose应用程序(至少现在不知道)，所以我们需要将现有的<em class="ob"> docker-compose.yml </em>文件转换成Kubernetes理解的yaml规范。一个docker-compose.yml文件可以转换成许多yaml文件，这些文件定义了如何运行应用程序的容器以及如何公开这些容器。</p><p id="7561" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">让我们快速回顾一下我们可以用来运行应用程序的一些主要Kubernetes资源:</p><p id="4b61" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">Pod是Kubernetes中最小的工作负载单元(读:运行容器的单元)，Pod通常由更高级别的对象创建和管理。以下模式显示了可用于创建Pod的Kubernetes资源</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/442b23d686a3945cdc3470c8c1dcdd4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*Dss4v1Dxyi6WRcp4CFrArQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">可以使用多种资源来管理pod</figcaption></figure><p id="9a84" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">每种资源通常用于特定的用例:</p><ul class=""><li id="a0ac" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated"><strong class="lx iu">部署</strong> : web服务器，api</li><li id="5031" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><strong class="lx iu"> DaemonSet </strong>:在集群的每个节点上运行的代理</li><li id="e734" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><strong class="lx iu"> StatefulSet </strong>:管理有状态应用程序(例如:MySQL集群)</li><li id="1a37" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><strong class="lx iu">作业</strong> / <strong class="lx iu"> CronJob </strong>:批量作业(例如:ML模型训练)</li></ul><p id="e114" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">在上述资源之上，一旦应用程序被部署在Pod中，就需要一个服务来公开应用程序。基本上，服务允许向应用程序单元发送请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/33e811cf58b003b9f2bb99543882838e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*2ui1uLE8eTEJOVM6b-Ll9w.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">默认情况下，pod是不公开的，为此需要创建一个服务对象</figcaption></figure><p id="4279" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">简而言之，对于在<em class="ob"> docker-compose.yml </em>文件中定义的每个微服务，我们需要创建:</p><ul class=""><li id="2270" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated">一个<strong class="lx iu">部署</strong>资源，负责管理运行微服务的容器映像的pod</li><li id="4ff1" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">一个<strong class="lx iu">服务</strong>资源，负责向应用程序的其他微服务公开Pod的容器</li></ul><p id="3e1b" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">有一个名为<a class="ae ky" href="https://kompose.io" rel="noopener ugc nofollow" target="_blank"> kompose </a>的便捷工具可以(在一定程度上)将<em class="ob"> docker-compose.yml </em>文件翻译成Kubernetes yaml规范。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/fefe14d8f40102e7d40d856034ff92be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9WzzGhJjSiDo74zz4x0Xw.png"/></div></div></figure><p id="4f92" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">一旦安装了<em class="ob"> kompose </em>二进制文件，我们运行下面的命令来获取一些Kubernetes规范，它为组成我们的应用程序的每个微服务生成一个<strong class="lx iu">部署</strong>和一个<strong class="lx iu">服务</strong>。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="ad3b" class="kz la it nt b gy nx ny l nz oa">$ kompose convert -f docker-compose.yaml<br/>...<br/>INFO Kubernetes file "manifests/api-service.yaml" created<br/>INFO Kubernetes file "manifests/mongo-service.yaml" created<br/>INFO Kubernetes file "manifests/nats-service.yaml" created<br/>INFO Kubernetes file "manifests/ws-service.yaml" created<br/>INFO Kubernetes file "manifests/www-service.yaml" created<br/>INFO Kubernetes file "manifests/api-deployment.yaml" created<br/>INFO Kubernetes file "manifests/mongo-deployment.yaml" created<br/>INFO Kubernetes file "manifests/nats-deployment.yaml" created<br/>INFO Kubernetes file "manifests/ws-deployment.yaml" created<br/>INFO Kubernetes file "manifests/www-deployment.yaml" created</span></pre><p id="2b96" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注意:Kompose也生成了与存储相关的规范，但是为了清楚起见，我将它们隐藏起来，因为我们将在本系列的后续文章中回到存储。</p><p id="2c97" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">Kompose生成的规范通常不能按原样使用，在它准确地代表我们的应用程序之前，需要对它们进行一些清理(有时是相当多的清理)。然而，它们可以成为更熟悉Kubernetes规范的良好起点。</p><p id="7867" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">如果我们不想使用Kompose(除了演示目的，我很少这样做),我们可以使用IDE的Kubernetes扩展，它可以生成简单的规范模板，所以我们只需要填写空白字段，指定资源的名称，必须使用的图像等</p><div class="kj kk kl km gt ab cb"><figure class="og kn oh oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/4344784b1b26c0b27d743e7152d79e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*WbXvNQG0E3thVek_o4llWQ.png"/></div></figure><figure class="og kn oh oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/9cca1d0094773fc3c383ca92bdde89e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*4jYBD_701WOvjTJENHjBaQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk om di on oo translated">Lens允许创建一个资源模板(在这个例子中是一个部署)，所以我们只需要根据我们的需要对它进行修改</figcaption></figure></div><p id="ee25" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">在webhooks.app应用程序的上下文中，我们需要为每个微服务部署和服务，下面的示例显示了api的部署和服务规范:</p><ul class=""><li id="4118" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated">api的部署规范(稍后将对其进行增强):</li></ul><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="30e4" class="kz la it nt b gy nx ny l nz oa"># deploy-api.yaml<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: api<br/>  name: api<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: api<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: api<br/>    spec:<br/>      containers:<br/>      - image: registry.gitlab.com/web-hook/api:<strong class="nt iu">v1.0.33<br/>        </strong>name: api</span></pre><ul class=""><li id="aae1" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated">用于公开api工作负载的服务规范示例:</li></ul><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="167b" class="kz la it nt b gy nx ny l nz oa"># service-api.yaml<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    app: api<br/>  name: api<br/>spec:<br/>  ports:<br/>  - port: 80<br/>    targetPort: 5000<br/>  selector:<br/>    app: api<br/>  type: ClusterIP</span></pre><p id="9992" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">一旦我们为每个微服务创建了部署和服务规范，我们就可以运行<em class="ob"> kubectl apply </em>并在集群中创建所有相应的Pods。</p><p id="2a69" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">当新版本的微服务可用时，我们只需更改部署中的映像标签(例如在上面的示例中用1.0.34版替换1.0.33版)并再次运行相同的<em class="ob"> kubectl apply </em>命令。这将终止基于映像<em class="ob">registry.gitlab.com/web-hook/api:</em><strong class="lx iu"><em class="ob">v 1 . 0 . 33</em></strong>运行容器的Pod，并运行基于<strong class="lx iu"/><em class="ob">registry.gitlab.com/web-hook/api:</em><strong class="lx iu"><em class="ob">v 1 . 0 . 34</em>的新Pod。这种方法可行，但不是很有活力。</strong></p><p id="2daa" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">下面我们将使用Kubernetes的包管理器<a class="ae ky" href="https://helm.sh" rel="noopener ugc nofollow" target="_blank"> Helm </a>，将yaml规范组织在一个预定义的文件夹结构中，并在其中添加部分模板语言。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="3281" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">将应用程序打包成舵图</h2><p id="3215" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Helm 是Kubernetes的产品包经理。它是一个需要下载并在PATH中可用的二进制文件，也是一个定义应用程序的文件夹结构。</p><p id="6d0b" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">Helm的主要特性之一是可以在yaml规范中使用模板语言，从而使规范更加动态。Helm使用这些模板以及其他一些包含配置值的文件作为输入。从这些输入中，<em class="ob"> helm </em>生成“真正的”yaml规范，并将它们发送给API服务器。以下模式概述了整个过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/080a103e1fd73da72426e7ed19cbf9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WrbcscLQeJZHxcrYF6NQkA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Helm接受几个用于生成Kubernetes规范的输入文件</figcaption></figure><p id="2a83" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">首先我们将创建一个空的Helm图表(用Helm打包的应用程序称为图表)。我们将使用它作为打包webhooks.app应用程序的起点:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="196c" class="kz la it nt b gy nx ny l nz oa">helm create webhooks</span></pre><p id="3854" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">这个命令生成一个名为webhooks的文件夹，它定义了一个基于nginx的示例应用程序:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="574a" class="kz la it nt b gy nx ny l nz oa">webhooks $ tree .<br/>.<br/>├── Chart.yaml<br/>├── charts<br/>├── templates<br/>│   ├── NOTES.txt<br/>│   ├── _helpers.tpl<br/>│   ├── deployment.yaml<br/>│   ├── hpa.yaml<br/>│   ├── ingress.yaml<br/>│   ├── service.yaml<br/>│   ├── serviceaccount.yaml<br/>│   └── tests<br/>│       └── test-connection.yaml<br/>└── values.yaml</span></pre><p id="9d70" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">让我们仔细看看这个文件夹的内容:</p><ul class=""><li id="644d" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated"><em class="ob"> Chart.yaml </em>包含应用元数据，如其名称、应用版本</li><li id="48fe" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><em class="ob">图表</em>是一个我们可以用来定义依赖关系的文件夹</li><li id="202a" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><em class="ob">模板</em>文件夹包含相应应用程序使用的所有yaml规范。我们很快就会看到，这些规范可以嵌入模板语言的某些部分</li><li id="2adf" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">在<em class="ob">模板</em>文件夹中有一个名为<em class="ob"> _helpers.tpl </em>的特殊文件，它允许定义一些可以在yaml模板中使用的函数</li><li id="5d19" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated"><em class="ob"> values.yaml </em>包含一些用于配置应用程序的值</li></ul><p id="8cae" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">由于这个结构目前包含一个示例应用程序(基于nginx)，我们可以去掉模板，复制我们自己应用程序的模板。同时，我们可以清空<em class="ob"> values.yaml </em>(稍后我们将在其中添加值)，并使用我们的应用程序名称对<em class="ob"> Chart.yaml </em>进行一点点定制。</p><p id="6089" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">完成后，<em class="ob"> webhooks </em>文件夹的内容将如下所示:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="3861" class="kz la it nt b gy nx ny l nz oa">webhooks $tree .<br/>.<br/>├── Chart.yaml<br/>├── charts<br/>├── templates<br/>│   ├── _helpers.tpl<br/>│   ├── deploy-api.yaml<br/>│   ├── deploy-mongo.yaml<br/>│   ├── deploy-nats.yaml<br/>│   ├── deploy-ws.yaml<br/>│   ├── deploy-<a class="ae ky" href="http://www.yaml" rel="noopener ugc nofollow" target="_blank">www.yaml</a><br/>│   ├── secret-mongo.yaml<br/>│   ├── service-api.yaml<br/>│   ├── service-mongo.yaml<br/>│   ├── service-nats.yaml<br/>│   ├── service-ws.yaml<br/>│   └── service-<a class="ae ky" href="http://www.yaml" rel="noopener ugc nofollow" target="_blank">www.yaml</a><br/>└── values.yaml</span></pre><p id="1d20" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">然后，我们可以在yaml文件中使用一些简单的模板指令。例如，我们可以用从<em class="ob"> values.yaml </em>文件中检索到的值(或者定义一个默认值，如果没有提供的话)替换原始值，使副本数量和容器图像更加动态。下面是对api的部署规范所做的更改:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="13c2" class="kz la it nt b gy nx ny l nz oa"># deploy-api.yaml<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: api<br/>  name: api<br/>spec:<br/>  replicas: <strong class="nt iu">{{ .Values.api.replicas | default 1 }}</strong><br/>  selector:<br/>    matchLabels:<br/>      app: api<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: api<br/>    spec:<br/>      containers:<br/>      - image: registry.gitlab.com/web-hook/api:<strong class="nt iu">{{.Values.api.tag}}</strong><br/>        name: api</span></pre><p id="2a70" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注意:其他微服务也应该做同样的更改(<strong class="lx iu"> ws </strong>、<strong class="lx iu"> www </strong>以及<strong class="lx iu"> nats </strong>和<strong class="lx iu"> mongo </strong>)</p><p id="1520" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">接下来，我们更改<em class="ob"> values.yaml </em>文件，为每个微服务的标签定义值。我们现在不定义副本，它将默认为1。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="ef05" class="kz la it nt b gy nx ny l nz oa"># values.yaml<br/>api:<br/>  tag: <strong class="nt iu">v1.0.33</strong><br/>mongo:<br/>  tag: 4.4<br/>nats:<br/>  tag: 2.8.4-alpine3.15<br/>ws:<br/>  tag: v1.0.7<br/>www:<br/>  tag: v1.0.33</span></pre><p id="d286" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">然后，我们运行下面的命令，让helm从模板和<em class="ob">值中生成真正的规范(读取Kubernetes API服务器可以理解的规范)。</em></p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="b6d5" class="kz la it nt b gy nx ny l nz oa"><strong class="nt iu">$ helm upgrade --install webhooks . -n webhooks -f values.yaml</strong><br/>Release "webhooks" does not exist. Installing it now.<br/>NAME: webhooks<br/>LAST DEPLOYED: Thu Sep  8 21:54:33 2022<br/>NAMESPACE: webhooks<br/>STATUS: deployed<br/>REVISION: 1<br/>TEST SUITE: None</span></pre><p id="abea" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">经以下命令确认，应用程序已成功创建:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="1217" class="kz la it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubectl get deploy,po,svc -n webhooks</strong><br/>NAME                      READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/mongo     1/1     1            1           41s<br/>deployment.apps/www       1/1     1            1           41s<br/>deployment.apps/nats      1/1     1            1           41s<br/>deployment.apps/api       2/2     2            2           41s<br/>deployment.apps/ws        1/1     1            1           41s</span><span id="024c" class="kz la it nt b gy oq ny l nz oa">NAME                           READY   STATUS    RESTARTS      AGE<br/>pod/mongo-74b9ccc56b-22w42     1/1     Running   0             41s<br/>pod/api-84c8f6f46d-24qb2       1/1     Running   0             41s<br/>pod/www-7d689fbb8c-hvcq4       1/1     Running   0             41s<br/>pod/nats-779c5b6646-bj57f      1/1     Running   0             41s<br/>pod/ws-676fbdb677-wl8mp        1/1     Running   0             41s</span><span id="df70" class="kz la it nt b gy oq ny l nz oa">NAME          TYPE       CLUSTER-IP     EXTERNAL-IP  PORT(S)     AGE<br/>service/ws    ClusterIP  10.43.92.163   &lt;none&gt;       80/TCP      41s<br/>service/www   ClusterIP  10.43.187.24   &lt;none&gt;       80/TCP      41s<br/>service/mongo ClusterIP  10.43.192.253  &lt;none&gt;       27017/TCP   41s<br/>service/api   ClusterIP  10.43.194.143  &lt;none&gt;       80/TCP      41s<br/>service/nats  ClusterIP  10.43.80.188   &lt;none&gt;       4222/TCP    41s</span></pre><p id="7f4b" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">如果注册表中有api的新容器映像，我们只需更新<em class="ob"> values.yaml </em>文件，并再次运行<em class="ob"> helm upgrade </em>命令，而无需更改规范模板。</p><p id="6745" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">更进一步，我们可以使用<a class="ae ky" href="https://github.com/helmfile/helmfile" rel="noopener ugc nofollow" target="_blank"> Helmfile </a>在图表文件夹的根目录下添加一个<em class="ob"> helmfile.yaml </em>文件，以更具声明性的方式指定我们的掌舵图表。该文件如下所示:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="421c" class="kz la it nt b gy nx ny l nz oa"># helmfile.yaml<br/>releases:<br/>- name: webhooks<br/>  namespace: webhooks<br/>  labels:<br/>    app: webhooks<br/>  chart: .<br/>  values:<br/>  - values.yaml</span></pre><p id="85f1" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注意:这个例子非常简单，helmfile提供了很多配置选项，我们可以从<a class="ae ky" href="https://helmfile.readthedocs.io/en/latest/#configuration" rel="noopener ugc nofollow" target="_blank"> Helmfile文档</a>中看到</p><p id="4d78" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">使用Helmfile，我们可以运行以下命令，以便在每次图表文件夹中的内容发生变化时部署和更新您的图表:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="e032" class="kz la it nt b gy nx ny l nz oa">helmfile apply</span></pre></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="09fa" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">添加反向代理</h2><p id="b0dc" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">该应用程序现在正在本地k3s集群中运行。下一步是部署入口控制器，这样我们就可以从外部访问应用程序。</p><p id="ecff" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">为此，我经常使用<a class="ae ky" href="https://traefik.io/traefik/" rel="noopener ugc nofollow" target="_blank"> Traefik </a>(还有许多其他的入口控制器，例如<a class="ae ky" href="https://github.com/kubernetes/ingress-nginx" rel="noopener ugc nofollow" target="_blank"> Nginx </a>、<a class="ae ky" href="https://projectcontour.io/" rel="noopener ugc nofollow" target="_blank"> Contour </a>、<a class="ae ky" href="https://haproxy-ingress.github.io/" rel="noopener ugc nofollow" target="_blank"> HA Proxy </a>等等)。Traefik可作为<a class="ae ky" href="https://artifacthub.io/packages/helm/traefik/traefik" rel="noopener ugc nofollow" target="_blank">舵轮图</a>使用，并可通过简单的<em class="ob">舵轮文件应用</em>命令使用以下<em class="ob">舵轮文件</em>轻松安装:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="9c8f" class="kz la it nt b gy nx ny l nz oa">repositories:<br/>- name: traefik<br/>  url: <a class="ae ky" href="https://helm.traefik.io/traefik" rel="noopener ugc nofollow" target="_blank">https://helm.traefik.io/traefik</a></span><span id="4045" class="kz la it nt b gy oq ny l nz oa">releases:<br/>- name: traefik<br/>  namespace: traefik<br/>  labels:<br/>    app: traefik<br/>  chart: traefik/traefik<br/>  version: ~10.24.2</span></pre><p id="44fb" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">一旦我们的入口控制器安装完毕，我们就可以用Traefik提供的入口路由CRD对其进行配置。让我们将以下规范复制到webhook应用程序的templates文件夹中:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="ff5a" class="kz la it nt b gy nx ny l nz oa">apiVersion: traefik.containo.us/v1alpha1<br/>kind: IngressRoute<br/>metadata:<br/>  name: webhook<br/>spec:<br/>  entryPoints:<br/>  - web<br/>  routes:<br/>  # Api calls<br/>  - match: Host(`{{.Values.domain}}`) &amp;&amp; (PathPrefix(`/wh`) ||   PathPrefix(`/data`) || PathPrefix(`/stats`))<br/>    kind: Rule<br/>    services:<br/>    - name: api<br/>      port: 80<br/>  # Websocket server<br/>  - match: Host(`{{.Values.domain}}`) &amp;&amp; PathPrefix(`/ws`)<br/>    kind: Rule<br/>    services:<br/>    - name: ws<br/>      port: 80<br/>  # Web site<br/>  - match: Host(`{{.Values.domain}}`)<br/>    kind: Rule<br/>    services:<br/>    - name: www<br/>      port: 80</span></pre><p id="d743" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">我们基本上定义了几个规则，以确保到达代理的请求被转发到<strong class="lx iu"> www </strong>、<strong class="lx iu"> api </strong>和<strong class="lx iu"> ws </strong>中正确的微服务。</p><p id="172c" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">当我们在这个模板中将域设为变量时，我们也更新了<em class="ob"> values.yaml </em>文件，在<em class="ob">域</em>属性中添加了运行k3s集群的虚拟机的本地IP地址:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="07d6" class="kz la it nt b gy nx ny l nz oa">domain: 192.168.205.22<br/>api:<br/>  tag: v1.0.33<br/>mongo:<br/>  tag: 4.4<br/>nats:<br/>  tag: 2.8.4-alpine3.15<br/>ws:<br/>  tag: v1.0.7<br/>www:<br/>  tag: v1.0.33</span></pre><p id="cf96" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注意:我们还可以在domain属性中指定一个域名，并确保更新我们的local <em class="ob"> /etc/hosts </em>，这样它就可以用VM的IP进行解析。</p><p id="7f04" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">在<em class="ob"> webhooks </em>文件夹中，我们现在可以使用最初创建应用程序时使用的相同命令来更新应用程序:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="fc7e" class="kz la it nt b gy nx ny l nz oa">helmfile apply</span></pre><p id="c2ec" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">这将创建IngressRoute资源的yaml规范(用在<em class="ob"> values.yaml </em>文件中指定的值替换<em class="ob"> .Values.domain </em>属性)，并将它发送到API服务器。入口控制器(Traefik)现在配置为服务于该应用。让我们确保一切按预期进行。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="606a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试整个事情</h2><p id="e9eb" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">使用运行k3s单节点集群的虚拟机的IP地址，我们可以访问应用程序，请求专用的webhook，并从仪表板使用示例curl命令确保实时接收有效负载。</p><div class="kj kk kl km gt ab cb"><figure class="og kn oh oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/3f3f0d6f3580f22e86480448dd1d9375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*sNyHo1Gq58mldIoaRQwU8w.png"/></div></figure><figure class="og kn oh oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/24bda232fbb7d8e8dee9e60459efc84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Txv03BvluV8ojFberB2zNA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk om di on oo translated">测试现在部署在Kubernetes集群上的应用程序</figcaption></figure></div><p id="fa12" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">一切按预期运行。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="6d65" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关键要点</h2><p id="5e47" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们已经做了很多事情，让我们快速回顾一下:</p><ul class=""><li id="6491" class="mv mw it lx b ly nj mb nk li nl lm nm lq nn mn na nb nc nd bi translated">我们创建了一个虚拟机，并在其中安装了k3s Kubernetes发行版</li><li id="ba98" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">我们将webooks应用程序打包成一个舵图</li><li id="2fc8" class="mv mw it lx b ly ne mb nf li ng lm nh lq ni mn na nb nc nd bi translated">我们安装并配置了一个入口控制器来访问应用程序</li></ul><p id="aa47" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">你可以在GitLab中应用程序项目的配置库中找到舵图的定义。您将会注意到，在这个存储库中添加了一些额外的项目。使用Traefik自动请求和更新的Let's Encrypt证书，通过TLS公开应用程序需要它们。</p><p id="61ce" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">注意:这个配置存储库是我保存需要在集群中部署的应用程序的规范的地方。可以使用完整的Helm charts (webhooks)或Helmfile (Traefik，…)来指定应用程序。在下一篇专门讨论CI/CD管道中的GitOps方法的文章中，我们将回到这个存储库。</p><p id="cf0c" class="pw-post-body-paragraph lv lw it lx b ly nj ju ma mb nk jx md li no mf mg lm np mi mj lq nq ml mm mn im bi translated">在本系列的下一篇文章中，我们将解释如何创建一个托管生产Kubernetes集群并在其上部署应用程序。</p></div></div>    
</body>
</html>