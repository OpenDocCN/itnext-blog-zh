<html>
<head>
<title>Detect Data Consistency Issues in RAFT Implementation with Jepsen</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jepsen检测RAFT实现中的数据一致性问题</h1>
<blockquote>原文：<a href="https://itnext.io/detect-data-consistency-issues-in-raft-implementation-d86431182965?source=collection_archive---------4-----------------------#2022-08-08">https://itnext.io/detect-data-consistency-issues-in-raft-implementation-d86431182965?source=collection_archive---------4-----------------------#2022-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/050a8428a4925bb2bc7640f3de99d962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-fGdlULBk3HBLFxK.png"/></div></div></figure><p id="31ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据一致性是所有分布式系统的全球性问题。NebulaGraph作为分布式图形数据库也不例外。</p><p id="76fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于查询层和存储层的分离，NebulaGraph只在存储层公开简单的kv接口。使用RocksDB作为后端kv库，NebulaGraph <a class="ae kw" href="https://nebula-graph.io/posts/nebula-graph-storage-engine-overview/" rel="noopener ugc nofollow" target="_blank">通过Raft协议确保多个副本之间的强大数据一致性</a>。</p><p id="84ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管raft应该比Paxos更容易理解，但在分布式系统中实现它是很棘手的。</p><p id="7cb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个具有挑战性的问题是如何测试基于Raft的分布式系统。目前，NebulaGraph用Jepsen验证数据一致性。在我们之前的帖子<a class="ae kw" href="https://nebula-graph.io/posts/practice-jepsen-test-framework-in-nebula-graph/" rel="noopener ugc nofollow" target="_blank">nebula graph</a>中练习Jepsen测试框架，我们已经详细介绍了Jepsen测试框架是如何工作的，你可以看看它来获得对Jepsen的一些基本了解。</p><p id="5ac8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本帖中，我们将解释如何验证分布式NebulaGraph kv存储的数据一致性。</p><h1 id="a868" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解释了强大的数据一致性</h1><p id="29d9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们从强数据一致性的定义开始。引用《设计数据密集型应用 》一书:</p><blockquote class="mb mc md"><p id="5633" class="jy jz ma ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">在可线性化的系统中，一旦一个客户端成功完成写入，所有从数据库读取的客户端必须能够看到刚刚写入的值。</p></blockquote><p id="ef4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">强数据一致性或线性化的基本思想是使分布式系统看起来好像只有一个数据副本，并且其上的所有操作都是原子的。来自任何客户端的任何读取请求都会将最新数据写入系统。</p><h1 id="df22" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用Jepsen验证线性化</h1><p id="6690" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">以Jepsen时间轴测试为例。在这个测试中，我们使用了<strong class="ka ir">单寄存器</strong>模型。客户端只能对寄存器执行读或写操作。所有的操作都是原子的，没有中间状态。</p><p id="4655" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设有四个客户端同时向系统发送请求。图中的每个条形表示客户端发出的请求，其中条形的顶部是发送请求的时间，条形的底部是客户端收到响应的时间。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/3895ad5208e51ed4db64680541cc4aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SsZQ82PqMUK7v-gh.png"/></div></figure><p id="72e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从客户端的角度来看，在发送请求和收到响应之间的任何时间都会处理任何请求。从上图可以看出，客户端1写1(即1: write1)、客户端3写4(即3: write4)、客户端4读1(即4: read1)这三个操作在处理时间上是重叠的。然而，我们通过不同客户端收到的响应知道系统处理请求的真正顺序。</p><p id="bd02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">方法如下:</p><p id="a51b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">初始值为空，但客户端4为其读取请求获得1，这指示客户端4的读取操作必须在客户端1的写入1操作之后开始，并且客户端3的写入4必须在写入1之前发生，否则将为客户端4的读取请求返回较旧的值4。因此，这三个操作的顺序是写入4 -&gt;写入1 -&gt;读取1。</p><p id="8e2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然从上图可以看出，首先发送请求read 1，但它是最后一个处理的。后面的操作在时间上不重叠，也就是说，它们是顺序发送的。客户端2的读取请求返回最后的写入值4。</p><p id="5059" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个过程没有违反强数据一致性的规则，所以验证通过。</p><p id="a751" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果客户端3的读取请求返回较旧的值4，则系统不是强一致的。根据前面的分析，最后一次成功写入的值为1。如果客户端3获得旧值4，则系统的线性化被破坏。</p><p id="17cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，Jepsen用类似的算法验证了分布式系统的强数据一致性。</p><h1 id="3525" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Jepsen测试发现数据一致性问题</h1><p id="6eb8" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了更好地理解数据一致性，下面给出了一个在NebulaGraph的Raft组(三个副本)中如何处理请求的例子。</p><p id="51a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">读取请求处理相对简单，因为只有选出的领导者服务器可以与客户端交互。领导者在检查它仍然是领导者之后，从状态机获取相应的结果并发送回客户端。</p><p id="7210" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">写请求处理稍微复杂一些。这些步骤如下图所示:</p><ol class=""><li id="b5c3" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">领导者(绿色圆圈)接收客户端发送的请求，并将其写入WAL(预写日志)。</li><li id="dc20" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">领导者将WAL中相应的日志条目发送给其追随者，并进入等待阶段。</li><li id="2478" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">follower接收日志条目并将其写入自己的WAL，然后返回success。</li><li id="c77e" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">当至少有一个跟随者返回成功时，领导者更新状态机并向客户端发送响应。</li></ol><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/2be06bcb7b888bc6d154d13089a2d5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aMQqA7ukxrajgJsG.png"/></div></div></figure><p id="b9cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将通过下面的例子向你展示一些在Jepsen测试中发现的Nebula Graph Raft实现问题。</p><h2 id="99b0" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kj ng nh ll kn ni nj lp kr nk nl lt nm bi translated">数据一致性示例1:读取请求返回的旧值</h2><p id="903c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如上图所示，A、B、C组成三复筏组。圆圈是状态机(为了简单起见，我们假设它们是单个寄存器)，盒子存储相应的日志条目。</p><ul class=""><li id="0e46" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv nn ms mt mu bi translated">在初始状态，三个副本中的所有状态机都是1，领导者是A，术语是1。</li><li id="8877" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv nn ms mt mu bi translated">在客户端发送请求write 2之后，leader根据之前描述的过程对其进行处理，通知客户端写入成功，然后被终止。</li><li id="d7e0" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv nn ms mt mu bi translated">那么C被选为第二任期的领导人。但是，由于C已经将write 2的日志条目应用到了状态机(此时值仍然是1)，如果C接收到来自客户端的请求，将返回1。这绝对违反了强数据一致性的定义，因为2已经被成功写入，而一个陈旧的值被返回。</li></ul><p id="9cc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样的问题发生在C当选为第二任期的领导人之后。有必要发送heartbeat以确保前一项的日志条目被群集的仲裁接受。心跳成功前不允许读取。否则，可能会返回过时的数据。如果您想了解更多细节，请参考本<a class="ae kw" href="https://raft.github.io/raft.pdf" rel="noopener ugc nofollow" target="_blank"> Raft论文</a>中的图8和第5.4.2节。</p><h2 id="2c77" class="nb ky iq bd kz nc nd dn ld ne nf dp lh kj ng nh ll kn ni nj lp kr nk nl lt nm bi translated">数据一致性示例2:领导者确保自己是领导者</h2><p id="3f5d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们通过Jepsen测试发现的另一个问题是:领导者如何确保自己仍然是领导者？这样的问题发生在网络划分上。当领导者由于网络故障而无法连接到仲裁时，如果仍然允许读取，则很可能会返回一个过时的值。</p><p id="62c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了避免这种情况，我们引入了leader lease概念。</p><p id="4901" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个节点被选为领导者时，它需要定期向其他节点发送心跳信号。如果心跳被大多数节点成功接收，则获得一段时间的租约，并且在该期限内将不会有任何新的领导者。因此，在节点上保证了数据的新近性，并且在此期间正常处理读取请求。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/deb97c4e9eb15aab04b9aff44fe2cbb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8rLRcyEZvcfZ3GIJ.png"/></div></div></figure><p id="0f09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与TiKV的进程不同，NebulaGraph并不考虑<em class="ma">心跳间隔*某个系数</em>作为租借时间，因为不同节点的时钟偏差存在漂移。</p><p id="8b96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，我们存储1) T1 =心跳间隔和2) T2 =上一次成功心跳或appendLog的时间成本，并通过<em class="ma">(T1-T2)</em>获得租用持续时间。</p><p id="137d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当网络被分区时，尽管隔离，旧的领导者仍然在租用时间期间处理读请求(写请求由于隔离而失败)。租约到期时，读取和写入请求都将失败。当追随者节点在等待来自引导者节点的心跳时超时，则发生引导者选举。</p><h1 id="930f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="2263" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">你需要长期的压力测试和故障模拟来发现分布式系统中的问题。Jespen在各种故障下验证分布式系统的能力，是一个很好的帮手。</p><p id="a1ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">未来，我们将引入其他混沌工程工具来验证NebulaGraph中的数据一致性。这样，我们可以不断提高性能，同时确保高数据可靠性。</p><h1 id="6c8e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">你可能也会喜欢</h1><ul class=""><li id="2d19" class="mm mn iq ka b kb lv kf lw kj np kn nq kr nr kv nn ms mt mu bi translated"><a class="ae kw" href="https://nebula-graph.io/posts/practice-jepsen-test-framework-in-nebula-graph/" rel="noopener ugc nofollow" target="_blank">在NebulaGraph中练习Jepsen测试框架</a></li><li id="5afe" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv nn ms mt mu bi translated"><a class="ae kw" href="https://nebula-graph.io/posts/nebula-graph-storage-engine-overview/" rel="noopener ugc nofollow" target="_blank">nebula graph存储引擎介绍</a></li></ul></div></div>    
</body>
</html>