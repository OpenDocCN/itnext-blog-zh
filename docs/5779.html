<html>
<head>
<title>Symfony SSO using Keycloak IDP with SAML protocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keycloak IDP和SAML协议的Symfony SSO</h1>
<blockquote>原文：<a href="https://itnext.io/symfony-keycloak-sso-saml-262e249d7160?source=collection_archive---------4-----------------------#2021-05-23">https://itnext.io/symfony-keycloak-sso-saml-262e249d7160?source=collection_archive---------4-----------------------#2021-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8999" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Symfony —带SAML协议的Keycloak SSO权威指南</h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/c8d32cd4a4a07ab3910378a68329680d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5IgX2sg0sZW-J38jfLTKQ.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">欢迎来到Symfony — Keycloak SSO</figcaption></figure><p id="bbb6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di">答</span>在网上做了大量研究后，我努力寻找合适的全面的文档来解释通过正确使用SAML协议用Symfony和Keycloak实现SSO。所以我决定写一个。</p><p id="69fc" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，在开始描述所有的配置过程和必要的设置之前，我想说我们将使用一个<strong class="kq jd"> docker-compose </strong>设置来提供以下服务:<br/>* Symfony 4<br/>* MySQL 5.7<br/>* PHP 7 . 4 . 16<br/>* NGINX<br/>* key cloak</p><blockquote class="lv lw lx"><p id="85fe" class="ko kp ly kq b kr ks kt ku kv kw kx ky lz la lb lc ma le lf lg mb li lj lk ll im bi translated">完整的设置和配置可以在这个git repo<a class="ae mc" href="https://github.com/abame/symfony-keycloak-sso" rel="noopener ugc nofollow" target="_blank">https://github.com/abame/symfony-keycloak-sso</a>中找到。</p></blockquote><p id="a31f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">只需运行<code class="fe md me mf mg b">docker-compose up -d</code>,您就可以立即启动环境并运行所有必要的配置。</p><p id="6f4e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以通过访问<a class="ae mc" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080</a><br/>并使用用户名<code class="fe md me mf mg b"><strong class="kq jd">root</strong></code>和密码<code class="fe md me mf mg b"><strong class="kq jd">root</strong></code>登录来访问我们的Keycloak管理。</p><h2 id="59ab" class="mh mi it bd mj mk ml dn mm mn mo dp mp kz mq mr ms ld mt mu mv lh mw mx my iz bi translated">自动布线</h2><p id="b8da" class="pw-post-body-paragraph ko kp it kq b kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">由于我们将在Symfony中为大多数服务进行用户自动连接，我们将在这里描述的服务不需要服务定义。</p><p id="2806" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要完全使用自动连线，我们需要在<code class="fe md me mf mg b">config/services.yml</code>下添加以下内容，并将<code class="fe md me mf mg b">$samlEntityId</code>绑定到客户端id，我们将在下面的<code class="fe md me mf mg b"><a class="ae mc" href="http://127.0.0.1/saml/login_check" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1/saml/login_check</a></code>步骤中配置客户端id。</p><pre class="ne nf ng nh gt ni mg nj nk aw nl bi"><span id="f64a" class="mh mi it mg b gy nm nn l no np">LightSaml\Build\Container\BuildContainerInterface: '@lightsaml.container.build'<br/>LightSaml\Binding\BindingFactoryInterface: '@lightsaml.service.binding_factory'<br/>LightSaml\Provider\TimeProvider\TimeProviderInterface: '@lightsaml.system.time_provider'<br/>App\Store\IdStoreInterface: '@App\Store\IdStore'</span></pre></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="0545" class="nx mi it bd mj ny nz oa mm ob oc od mp oe of og ms oh oi oj mv ok ol om my on bi translated">1.创建一个领域</h1><p id="a5a9" class="pw-post-body-paragraph ko kp it kq b kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">使用docker启动并运行环境后，我们需要做的第一件事是在我们的Keycloak IDP中创建一个领域。</p><p id="963a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">a.将鼠标悬停在左上角的侧边栏菜单上，点击<strong class="kq jd">添加领域</strong>，可以创建一个领域。</p><p id="6dc3" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">根据需要输入领域名称，并确保<strong class="kq jd">启用</strong>打开<strong class="kq jd">。</strong>然后点击<strong class="kq jd">创建按钮</strong>。我将它命名为Test_realm，如下所示。或者，您可以将一个领域作为JSON文件导入。我不会在这里上传任何JSON配置，这样我们就可以完成这些步骤，但是在docker-compose设置中，当环境启动并运行时，会导入一个JSON配置。这个JSON文件可以在名为<code class="fe md me mf mg b">realm-export.json</code>的项目根目录下找到。</p><figure class="ne nf ng nh gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oo"><img src="../Images/62f367ce375de8fe33014af22ccbfc83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnZPMMUowtu_CqhKM9gGSQ.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">添加领域</figcaption></figure><p id="ee7e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">b.之后，在<strong class="kq jd">领域设置</strong>页面上，我们必须如下图所示配置登录部分，然后单击保存。</p><figure class="ne nf ng nh gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oo"><img src="../Images/4725850711038be392bee3592b2288c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTow_b2tVpbDipQ_ZAqsJw.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">登录配置</figcaption></figure><p id="7a37" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">其他的<strong class="kq jd">领域设置</strong>我们可以保持原样，因为它们与本文的范围无关。你可能想改变的唯一一件事是<strong class="kq jd">主题</strong>，但这也是可选的，而且非常简单。我们需要做的另一件事是将<strong class="kq jd"> General </strong>下的<code class="fe md me mf mg b">SAML 2.0 Identity Provider Metadata</code> XML复制到一个<code class="fe md me mf mg b">saml-idp.xml</code>文件中，因为我们稍后会用到它。</p><p id="5b2c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="ly"> Ps。如果你使用</em> <code class="fe md me mf mg b"><em class="ly">docker-compose up -d</em></code> <em class="ly">命令，你也必须下载</em> <code class="fe md me mf mg b"><em class="ly">SAML 2.0 Identity Provider Metadata</em></code> <em class="ly">，因为这将是第一次运行这个设置和元数据，是时间敏感的。第一次之后，配置存储在MySQL数据库中，您不需要再次下载它，因为它不会改变。</em></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="6056" class="nx mi it bd mj ny nz oa mm ob oc od mp oe of og ms oh oi oj mv ok ol om my on bi translated">2.添加客户端</h1><p id="5624" class="pw-post-body-paragraph ko kp it kq b kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">在成功地创建了包含所有配置的领域之后，我们需要向我们的领域添加一个客户机来满足我们的需求。一旦我们进入左侧的<strong class="kq jd">客户</strong>菜单，我们会看到一些现有客户。这些客户端是在创建领域时添加的，并且是领域正常运行所必需的。</p><figure class="ne nf ng nh gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oo"><img src="../Images/61145566ad0ef34dc89068af1a8ef43f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-hxIJkGL7Pfrrxs7LqEwA.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">客户列表</figcaption></figure><p id="61a5" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在上图中，我们在客户列表的右上角有一个“创建”按钮。当我们点击该按钮时，我们会看到下面的界面。</p><figure class="ne nf ng nh gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oo"><img src="../Images/0dabdc4ecdf89b636f9555971f8c3755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJ2LZaLQ0UtD1f2fnDGD2w.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">创建客户端</figcaption></figure><p id="9e35" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里我们提供了客户端id，在我们的例子中是<a class="ae mc" href="http://127.0.0.1/saml/login_check" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1/SAML/log in _ check</a>，我们选择<code class="fe md me mf mg b">saml</code>作为协议，然后保存客户端。保存后，我们将面对一个新的界面来完全配置客户端。</p><figure class="ne nf ng nh gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oo"><img src="../Images/94927f34587040ff299b45438893c974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cp7V8iqunuN31v9QMX8crA.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">客户端设置</figcaption></figure><p id="5a7f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在此界面中，我们希望启用以下选项:<br/> a .包含AuthnStatement <br/> b .签署文档<br/> c .签署声明<br/> d .需要客户端签名<br/> e .强制POST绑定<br/> f .前通道注销</p><p id="236b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们还需要选择主题，不是强制性的，但很好拥有，给<code class="fe md me mf mg b">Assertion Customer Service POST Binding URL</code>的值<a class="ae mc" href="http://127.0.0.1/saml/login_check" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1/SAML/log in _ check</a>和<code class="fe md me mf mg b">Logout Service POST Binding URL</code>的值<a class="ae mc" href="http://127.0.0.1" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1 </a>。另外两个URL是可选的。</p><p id="0811" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">##SAML密钥<br/>当客户尝试登录和注册时，这两个密钥是签署请求和断言所必需的。我们需要将这两个键存储在它们各自的<code class="fe md me mf mg b">.crt</code>和<code class="fe md me mf mg b">.key</code>文件中。</p><p id="3d12" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们需要的另一个配置是<strong class="kq jd">地图绘制器</strong>，其余的都是可选的，我会让你去探索它们。点击表格右上角的<code class="fe md me mf mg b">Add Builtin</code>按钮后,“地图绘制者”部分有一些默认的地图绘制者，如下图所示。</p><figure class="ne nf ng nh gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oo"><img src="../Images/455d230de15a9b43c28bcf495fa3196e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R64Sj6u97q98Rx63ZBSKtg.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">映射者列表</figcaption></figure><p id="89df" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">添加了默认的映射器后，我们需要添加一个自定义的映射器来显示Keycloak用户id。为此，我们点击<code class="fe md me mf mg b">Create</code>按钮，出现以下界面:</p><figure class="ne nf ng nh gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi op"><img src="../Images/1f4c6304280fc16a46d781cf124ce48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3b560Vsf0zHf-ESKpj86g.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">创建自定义映射器</figcaption></figure><p id="0472" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我们在这个部分作为<strong class="kq jd">映射器类型</strong>时，我们必须选择<strong class="kq jd">用户属性</strong>。添加名称为<code class="fe md me mf mg b">X500 ID</code>，并用值<code class="fe md me mf mg b">id</code>填充<code class="fe md me mf mg b">Property</code>和<code class="fe md me mf mg b">Friendly Name</code>。在<code class="fe md me mf mg b">SAML Attribute name</code>上，我们添加<code class="fe md me mf mg b">urn:oid:1.2.840.113549.1.9.1</code>并保存配置。</p><p id="3044" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">至此，我们完成了客户端的配置。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="e2aa" class="nx mi it bd mj ny nz oa mm ob oc od mp oe of og ms oh oi oj mv ok ol om my on bi translated">3.在Symfony中设置SAML配置</h1><p id="df9b" class="pw-post-body-paragraph ko kp it kq b kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">要在Symfony中配置SAML，我们首先必须通过运行<code class="fe md me mf mg b">composer require lightsaml/sp-bundle</code>来安装一个外部依赖项。该包将自动注册，在<code class="fe md me mf mg b">config/routes.yml</code>下，我们必须通过添加以下代码来加载SAML路由:</p><pre class="ne nf ng nh gt ni mg nj nk aw nl bi"><span id="b14c" class="mh mi it mg b gy nm nn l no np">lightsaml_sp:<br/>    resource: "@LightSamlSpBundle/Resources/config/routing.yml"<br/>    prefix: saml<br/><br/>logout:<br/>    path: /logout</span></pre><p id="a80a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后我们必须添加可以在<code class="fe md me mf mg b">src/Entity/*</code>下找到的<code class="fe md me mf mg b">User</code>和<code class="fe md me mf mg b">IdEntry</code>实体。在<code class="fe md me mf mg b">User</code>实体中，密码必须是<code class="fe md me mf mg b">null</code>，因为登录将由IDP处理，但是<code class="fe md me mf mg b">UserInterface</code>实现需要该属性。</p><p id="caeb" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe md me mf mg b">IdEntry</code>的目的是存储给定客户端的会话id和到期时间。从LightSAML文档中，</p><blockquote class="oq"><p id="7dc8" class="or os it bd ot ou ov ow ox oy oz ll dk translated">虽然包中没有明确要求，但是强烈建议您跟踪收到的消息id，以防止消息重复。出于这些目的，您需要一个实体来持久化这些id。</p></blockquote><p id="e622" class="pw-post-body-paragraph ko kp it kq b kr pa kt ku kv pb kx ky kz pc lb lc ld pd lf lg lh pe lj lk ll im bi translated">在我们有了实体之后，我们需要运行<code class="fe md me mf mg b">docker-compose exec php bin/console doctrine:schema:update <strong class="kq jd">--force</strong></code></p><h2 id="9666" class="mh mi it bd mj mk ml dn mm mn mo dp mp kz mq mr ms ld mt mu mv lh mw mx my iz bi translated">创建ID存储服务</h2><p id="6fc6" class="pw-post-body-paragraph ko kp it kq b kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">ID存储用于通过使用<code class="fe md me mf mg b">set</code>和<code class="fe md me mf mg b">has</code>方法来创建/检查身份记录，其中<code class="fe md me mf mg b">set</code>创建/更新和<code class="fe md me mf mg b">IdEntry</code>记录，而<code class="fe md me mf mg b">has</code>方法检查条目是否存在并且仍然有效且没有过期。该服务可在<code class="fe md me mf mg b">src/Store/IdStore.php</code>下找到</p><h2 id="cb00" class="mh mi it bd mj mk ml dn mm mn mo dp mp kz mq mr ms ld mt mu mv lh mw mx my iz bi translated">配置SAML桥</h2><p id="79d8" class="pw-post-body-paragraph ko kp it kq b kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">在<code class="fe md me mf mg b">config/packages/light_saml_symfony_bridge.yml</code>下，我们添加以下配置:</p><pre class="ne nf ng nh gt ni mg nj nk aw nl bi"><span id="d21c" class="mh mi it mg b gy nm nn l no np">light_saml_symfony_bridge:<br/>    own:<br/>        entity_id: "http://127.0.0.1/saml/login_check"<br/>        credentials:<br/>            -<br/>                certificate: "%kernel.root_dir%/../config/saml/saml.crt"<br/>                key:         "%kernel.root_dir%/../config/saml/saml.key"<br/>                password:    ~<br/>    party:<br/>        idp:<br/>            files:<br/>                - "%kernel.root_dir%/../config/saml/saml-idp.xml"<br/>    store:<br/>        id_state: App\Store\IdStoreInterface</span></pre><p id="4598" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">其中<code class="fe md me mf mg b">saml.crt</code>、<code class="fe md me mf mg b">saml.key</code>和<code class="fe md me mf mg b">saml-idp.xml</code>是我们从领域和客户端配置中检索的文件。</p><h2 id="4009" class="mh mi it bd mj mk ml dn mm mn mo dp mp kz mq mr ms ld mt mu mv lh mw mx my iz bi translated">用户创建者服务</h2><p id="21e4" class="pw-post-body-paragraph ko kp it kq b kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">当用户从Keycloak IDP登录，而Symfony数据库中不存在该用户时，需要使用此服务<code class="fe md me mf mg b">\App\Security\User\UserCreator</code>在Symfony数据库中创建用户。该服务用于从<code class="fe md me mf mg b">\LightSaml\SpBundle\Security\Authentication\Provider\LightsSamlSpAuthenticationProvider</code>检查我们在IDP中是否有登录用户。如果我们有，我们在Symfony应用程序中验证用户，否则我们在用户登录IDP后从响应中验证。authenticate from响应然后检查是否可以从Symfony应用程序数据库加载用户，或者我们是否需要创建用户。</p><h2 id="3d0a" class="mh mi it bd mj mk ml dn mm mn mo dp mp kz mq mr ms ld mt mu mv lh mw mx my iz bi translated">配置安全性</h2><p id="97a4" class="pw-post-body-paragraph ko kp it kq b kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">配置<code class="fe md me mf mg b">config/packages/security.yml</code>、<code class="fe md me mf mg b">firewalls</code>部分，在<code class="fe md me mf mg b">main</code>下，我们需要添加以下配置。</p><pre class="ne nf ng nh gt ni mg nj nk aw nl bi"><span id="d256" class="mh mi it mg b gy nm nn l no np">light_saml_sp:<br/>    provider: app_user_provider<br/>    user_creator: App\Security\User\UserCreator<br/>    login_path: /saml/login<br/>    check_path: /saml/login_check<br/>    default_target_path: /<br/>    require_previous_session: true</span><span id="407a" class="mh mi it mg b gy pf nn l no np">logout:<br/>    path: 'lightsaml_sp.logout'<br/>    target: default<br/>    invalidate_session: false<br/>    success_handler: App\Services\SamlLogoutHandler</span></pre><h2 id="838f" class="mh mi it bd mj mk ml dn mm mn mo dp mp kz mq mr ms ld mt mu mv lh mw mx my iz bi translated">注销处理程序服务</h2><p id="43bb" class="pw-post-body-paragraph ko kp it kq b kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh nd lj lk ll im bi translated">此服务<code class="fe md me mf mg b">\App\Services\SamlLogoutHandler</code>的目的是正确处理Symfony应用程序与IDP之间的注销过程。我们检查是否有一个<code class="fe md me mf mg b">LogoutRequest</code>,我们将它委托给IDP，以便我们可以在IDP中注销用户，一旦用户在IDP中注销，请求将被重定向回我们的应用程序，我们将得到一个<code class="fe md me mf mg b">LogoutResponse</code>,我们将使我们的应用程序中的会话无效，以便在Symfony应用程序中完全登录用户。</p><figure class="ne nf ng nh gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi pg"><img src="../Images/6d3c94595900328c4b634d00625fba72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dPYXLnvYYpHEsWt3"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">由<a class="ae mc" href="https://unsplash.com/@alx_andru?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alex </a>在<a class="ae mc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure></div></div>    
</body>
</html>