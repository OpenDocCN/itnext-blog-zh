<html>
<head>
<title>React Patterns: The Container pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应模式:容器模式</h1>
<blockquote>原文：<a href="https://itnext.io/react-patterns-the-container-pattern-4d8b5b6f0127?source=collection_archive---------2-----------------------#2022-03-28">https://itnext.io/react-patterns-the-container-pattern-4d8b5b6f0127?source=collection_archive---------2-----------------------#2022-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1386aafd180b21f9ecf801d6de2955c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LfE8uCdLc7zxvpiFgl1yLA.png"/></div></div></figure><p id="1a3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">容器模式是React中最有用的模式之一。您可以使用它实现一种声明性的方式来重用自定义功能，如获取数据、身份验证、布局等。</p><p id="c84f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看它是如何工作的！</p><h1 id="eb66" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">容器模式是什么？</h1><p id="5476" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">该模式背后的思想很简单:您有一个容器组件，它提供自定义功能，并使用<code class="fe mc md me mf b">children</code> prop呈现您输入的任何React节点。</p><p id="2866" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该模式的一些用例是:</p><ul class=""><li id="d095" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">Loader——当某个条件为真时，容器将显示一个loader，否则，它将呈现内容。</li><li id="b82f" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">身份验证门—如果用户未经身份验证，容器将不会呈现其子级。</li><li id="8d5b" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">布局和样式——容器充当提供一致样式的包装器。假设您有多个具有不同内容的仪表板页面，并且您希望它们具有相同的仪表板处理方式。</li></ul><p id="f6a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经了解了容器模式，让我们来看一个简单的实现。</p><h1 id="0628" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">动作中的容器模式</h1><p id="b079" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们构建一个简单的门控容器，它将在呈现内容之前检查以确保用户已经过身份验证。</p><p id="581c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们的容器组件的样子:</p><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="adc4" class="nc la it mf b gy nd ne l nf ng">import React from "react";<br/>import { useGetUserSession } from "./useGetUserSession";</span><span id="7488" class="nc la it mf b gy nh ne l nf ng">const GateComponent = ({ children }) =&gt; {<br/>  const { isAuthenticated } = useGetUserSession();</span><span id="ac5b" class="nc la it mf b gy nh ne l nf ng">if (!isAuthenticated) return null;</span><span id="6573" class="nc la it mf b gy nh ne l nf ng">return &lt;&gt;{children}&lt;/&gt;;<br/>};</span><span id="a77e" class="nc la it mf b gy nh ne l nf ng">export default GateComponent;</span></pre><p id="1a7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，这非常简单:我们使用一个React钩子从我们的应用程序状态中获取<code class="fe mc md me mf b">isAuthenticated</code>布尔值。如果是福尔西，我们简单地返回<code class="fe mc md me mf b">null</code>。如果<code class="fe mc md me mf b">isAuthenticated</code>是真实的，我们渲染<code class="fe mc md me mf b">children</code>道具。</p><p id="743e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您可以使用简单的声明性代码将UI页面置于身份验证层之后:</p><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="7252" class="nc la it mf b gy nd ne l nf ng">const PrivateComponent = () =&gt; {<br/>  return (<br/>    &lt;GateComponent&gt;<br/>      &lt;p&gt;Secret data here, shhhh!&lt;/p&gt;<br/>    &lt;/GateComponent&gt;<br/>  );<br/>};</span></pre><p id="0f71" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方法的另一个好处是很容易向身份验证添加更复杂的逻辑，而无需更改客户端代码。</p><p id="90ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想了解更多关于为React应用程序构建一个健壮的权限系统的知识，请查看我的另一篇关于在React中处理角色和权限的干净方法的帖子。</p><h1 id="d45b" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">具有多个子容器的容器</h1><p id="05f7" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在某些情况下，您可能需要创建带有两个内容占位符的容器。例如，您可能有一个允许提供自定义侧栏和主要内容的仪表板。</p><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="0a43" class="nc la it mf b gy nd ne l nf ng">const Dashboard = ({ SidebarComponent, ContentComponent }) =&gt; {<br/>  return (<br/>    &lt;div className="dashboard"&gt;<br/>      &lt;div className="sidebar"&gt;<br/>        &lt;SidebarComponent /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="content"&gt;<br/>        &lt;ContentComponent /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="9b4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码非常简单:我们的<code class="fe mc md me mf b">Dashboard</code>容器接受侧栏和仪表板主体的自定义React节点。</p><p id="4f01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意:将组件属性名大写很重要。</strong>这就是React如何确定<code class="fe mc md me mf b">Dashboard</code>收到的道具实际上是否是function的一个组件。</p><h1 id="3a78" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="6aa1" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">React容器模式是从UI代码中抽象复杂逻辑的一种便捷方式。它允许您以声明的方式重用应用程序的公共逻辑。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="83fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">原载于2022年3月28日</em><a class="ae nq" href="https://isamatov.com/react-patterns-container/" rel="noopener ugc nofollow" target="_blank"><em class="np">【https://isamatov.com】</em></a><em class="np">。</em></p></div></div>    
</body>
</html>