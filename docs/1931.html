<html>
<head>
<title>I USED REACT IN 2007!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在2007年用过REACT！</h1>
<blockquote>原文：<a href="https://itnext.io/i-used-react-in-2007-46e4723e7c03?source=collection_archive---------6-----------------------#2019-02-25">https://itnext.io/i-used-react-in-2007-46e4723e7c03?source=collection_archive---------6-----------------------#2019-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f2a6cab4c127b4ab9481fbf2a7e5aa43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZmuEG4aqxyw1_59R"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@mafonso?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克尔·阿丰索</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="957d" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">什么？？？？</h2></div><p id="d208" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与我在2006年维护的WordPress网站不同，这将是一次有趣的回顾，回顾我的第一个真正的编码项目，它使用了一个非常类似于React、Redux和Redux-Observable的系统。我在文章的每一部分都加入了一个Lua to JavaScript Rosetta Stone，让我的大多数追随者更容易理解。</p><h1 id="6f82" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">历史</h1><p id="3357" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">你们中的一些人可能知道，我开始写代码是因为我进行了一生中最昂贵、最耗时的探险:开发独立游戏。游戏名字叫<a class="ae jd" href="https://pulsengame.com/game" rel="noopener ugc nofollow" target="_blank"> Pulsen </a>，今天可以在<a class="ae jd" href="https://store.steampowered.com/app/340960/Pulsen/" rel="noopener ugc nofollow" target="_blank"> Steam </a>上找到。</p><p id="864a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Pulsen是基于一个名为<a class="ae jd" href="https://www.stepmania.com/" rel="noopener ugc nofollow" target="_blank"> StepMania </a>的现有舞蹈游戏引擎构建的。该引擎创建于1998年，并随着时间的推移经历了相当多的重大修改；最初允许通过INI文件修改主题，然后一个街机游戏的分支允许通过XML文件修改，后来，另一个分支——最终成为主线StepMania——将许多UI逻辑从C++核心中分离出来，放在Lua中。</p><p id="8838" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我在2007-2008年的某个时候加入了XML版本的修改现场，后来在2009年当我想到用StepMania引擎构建Pulsen时，我转向了Lua版本。</p><p id="d087" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章的标题有点误导。它说明了我在2007年是如何使用React的，但我真正使用的是一个以类似React的方式编写的XML或Lua格式的自定义图形渲染器。在经历了多年的各种web技术之后，看到这个古老的项目与我们今天看到的React和Redux非常接近，仍然令人着迷。</p><h1 id="deda" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">演员是组件</h1><p id="71a8" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">作为Lua to JS Rosetta Stone的一部分，我将描述每个部分是如何关联的，以及它们是如何不同的。StepMania有一个<code class="fe mp mq mr ms b">Actor</code>的概念，它本质上是一个包含生命周期方法的React组件和一个为您预先编写的<code class="fe mp mq mr ms b">render</code>函数。</p><p id="3812" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通常你会在React中自己编写<code class="fe mp mq mr ms b">render</code>,因为HTML元素的组合，但是这个游戏引擎只支持有限数量的元素类型，所以每种类型都有自己的C++内部<code class="fe mp mq mr ms b">render</code>函数。</p><h2 id="0857" class="mt lt jg bd lu mu mv dn ly mw mx dp mc le my mz me li na nb mg lm nc nd mi ne bi translated">行动框架</h2><p id="f73b" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">例如，有一个相当于HTML <code class="fe mp mq mr ms b">div</code>的<code class="fe mp mq mr ms b">ActorFrame</code>，或者更具体地说，是一个反应<code class="fe mp mq mr ms b">Fragment</code>。它所做的只是把其他演员圈起来，并允许你把他们作为一个团体来定位。</p><p id="23a8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是<code class="fe mp mq mr ms b">ActorFrame</code>的<code class="fe mp mq mr ms b">render</code>在React中的样子:</p><pre class="nf ng nh ni gt nj ms nk nl aw nm bi"><span id="2133" class="mt lt jg ms b gy nn no l np nq">render() {<br/>  return this.props.children<br/>}</span></pre><p id="505f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很简单。</p><p id="ac40" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与<code class="fe mp mq mr ms b">div</code>不同，它不会出现在UI中，所以它没有宽度、高度或深度。这就是为什么我把它和React <code class="fe mp mq mr ms b">Fragment</code>联系起来，但是它可能有一个X，Y和Z值，只要你设置了其中的任何一个。</p><h2 id="6b7f" class="mt lt jg bd lu mu mv dn ly mw mx dp mc le my mz me li na nb mg lm nc nd mi ne bi translated">其他演员</h2><p id="0fd4" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">像众多的HTML元素一样，总共有43个参与者，例如:</p><ul class=""><li id="19a2" class="nr ns jg kx b ky kz lb lc le nt li nu lm nv lq nw nx ny nz bi translated">不使用图像而显示文本的唯一方法。HTML中没有对等的东西，因为浏览器处理任何元素中的文本呈现。</li><li id="0263" class="nr ns jg kx b ky oa lb ob le oc li od lm oe lq nw nx ny nz bi translated"><code class="fe mp mq mr ms b">Model</code>:用于加载3D模型。类似于<code class="fe mp mq mr ms b">canvas</code>。</li><li id="3bee" class="nr ns jg kx b ky oa lb ob le oc li od lm oe lq nw nx ny nz bi translated"><code class="fe mp mq mr ms b">Quad</code>:一个很像<code class="fe mp mq mr ms b">div</code>的长方形。</li><li id="7e17" class="nr ns jg kx b ky oa lb ob le oc li od lm oe lq nw nx ny nz bi translated"><code class="fe mp mq mr ms b">Sound</code>:像HTML中的<code class="fe mp mq mr ms b">audio</code>一样管理音频文件的播放。</li><li id="5b5d" class="nr ns jg kx b ky oa lb ob le oc li od lm oe lq nw nx ny nz bi translated"><code class="fe mp mq mr ms b">Sprite</code>:常用类似HTML的<code class="fe mp mq mr ms b">img</code>通过<code class="fe mp mq mr ms b">LoadActor</code>函数，但也可以用于sprite动画或拉出类似CSS sprites的静态图片。</li></ul><h2 id="48a5" class="mt lt jg bd lu mu mv dn ly mw mx dp mc le my mz me li na nb mg lm nc nd mi ne bi translated">每个文件一个演员</h2><p id="e4ec" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">就像React中通常只有一个组件导出(特别是默认导出)一样，StepMania只允许每个文件有一个actor。就像你必须在React中使用<code class="fe mp mq mr ms b">Fragment</code>一样，你可以在StepMania中使用<code class="fe mp mq mr ms b">ActorFrame</code>来解决这个问题。</p><h1 id="c58e" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">反应，但是在2007年？</h1><p id="41a8" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">有了这些工具，你可以把一个类似的组件架构放在一起反应；事实上，它看起来更像React最初在v0.13中所做的，而不是你今天在JSX上看到的:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="85d1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Lua对象函数有一个类似于JavaScript的概念<code class="fe mp mq mr ms b">this</code>，叫做<code class="fe mp mq mr ms b">self</code>，但是由于C++后端的原因，它必须被传递到这些特定的函数中。</p><p id="9b49" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我继续将相同的代码翻译成您在React中看到的内容:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="02fb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当传递消息时，我认为这些与传递Redux动作是一样的，但是在这个翻译中，我将其屏蔽为渲染道具组件:<code class="fe mp mq mr ms b">PlayerScore</code>。</p><p id="7dd2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一件有趣的事情是，由于游戏使用位图文本，所以很容易对字体应用渐变，尽管这在CSS中很难解决。</p><p id="408b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这还不是最疯狂的事。旧的XML方法甚至更像JSX:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6a1b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一定会喜欢那份意大利面的。</p><p id="149c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我第一次开始使用这个引擎时，这是我编写组件的风格。时间太久了，我不得不翻遍所有的旧文件，弄清楚我是如何完成这一半工作的。我很难记起任何一件事。</p><p id="8ba1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">XML有点不可靠，像AngularJS和Knockout一样，它在字符串中有Lua函数:/。不管怎样，即使是这种格式，你也可以做很多很酷的事情，令人惊讶的是，这与React如此相似。</p><h1 id="e742" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">生命周期方法</h1><p id="5db4" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">StepMania提供了与React相同的生命周期方法。</p><p id="b20b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有两种类型的生命周期方法可用，命令和消息命令，后者是整个应用程序的全局侦听器，而前者是特定于一个组件，有时是屏幕类型本身。</p><p id="1727" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是一些常见的问题:</p><ul class=""><li id="e27a" class="nr ns jg kx b ky kz lb lc le nt li nu lm nv lq nw nx ny nz bi translated"><code class="fe mp mq mr ms b">InitCommand</code> : <code class="fe mp mq mr ms b">constructor</code></li><li id="f032" class="nr ns jg kx b ky oa lb ob le oc li od lm oe lq nw nx ny nz bi translated"><code class="fe mp mq mr ms b">BeginCommand</code> : <code class="fe mp mq mr ms b">componentWillMount</code></li><li id="08cd" class="nr ns jg kx b ky oa lb ob le oc li od lm oe lq nw nx ny nz bi translated"><code class="fe mp mq mr ms b">OnCommand</code> : <code class="fe mp mq mr ms b">componentDidMount</code></li><li id="116d" class="nr ns jg kx b ky oa lb ob le oc li od lm oe lq nw nx ny nz bi translated"><code class="fe mp mq mr ms b">OffCommand</code> : <code class="fe mp mq mr ms b">componentWillUnmount</code></li></ul><p id="cced" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">令人惊讶的是，没有对应的<code class="fe mp mq mr ms b">render</code>。就像HTML元素如何从浏览器中呈现一样，actors也是以同样的方式呈现的。</p><p id="0d50" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，就像JS类一样，您可以在Lua对象上调用方法。如果我在我的对象上放一个<code class="fe mp mq mr ms b">AnimateCommand</code>，我可以在我的生命周期方法中使用<code class="fe mp mq mr ms b">self:queuecommand('Animate')</code>调用它。从那时起，您可以通过一遍又一遍地调用命令本身来循环它，直到调用了<code class="fe mp mq mr ms b">OffCommand</code>。</p><p id="936c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">消息命令是很酷的命令。您不仅可以像调用其他命令一样调用它们，还可以广播一条消息，以相同的名称触发所有消息命令。</p><p id="0f62" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="bc7d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我能够广播一条调用所有<code class="fe mp mq mr ms b">DifficultyLevelsChangedMessageCommand</code>函数的消息。如果那些道具看起来很可笑，它们不是；虽然，他们会受益于更好的命名。</p><p id="7691" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我创建了一个主演员，它会听屏幕上的各种变化，然后通知所有其他演员他们是否应该停止补间或消失，等等。想象一下Context API在React中是如何工作的，在React中有一个生产者，然后一群消费者监听来自生产者的状态更新。</p><p id="0f8d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我如何能够实现改变困难和歌曲的流畅性，同时在匹配时在玩家之间同步它们；尽管如此，代码的复杂性还是很高。</p><p id="b88b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它类似于普通的JS事件和Redux动作。在JS事件中，它们可以在<code class="fe mp mq mr ms b">window</code>上全局发生，也可以在单个DOM元素上发生:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0bf7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您甚至可以将此视为Redux操作:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="5dde" class="mt lt jg bd lu mu mv dn ly mw mx dp mc le my mz me li na nb mg lm nc nd mi ne bi translated">动画演员vs组件</h2><p id="8024" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我在Pulsen中处理动画的方式是，我会渲染额外的演员，并根据广播消息中可用的内容用补间动画隐藏或显示他们。</p><p id="f1b9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在React中有几种隐藏组件的方法。您可以不使用JS条件呈现它们，或者使用CSS隐藏它们。根据我使用Pulsen和React的经验，CSS方法几乎总是更优越，因为它是动画HTML元素的唯一真正的方法。</p><p id="568f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除非在内存中保存数百个额外的DOM元素存在性能问题，否则我建议使用CSS方法，而不是有条件地呈现React组件。通过CSS隐藏和显示要比创建和删除新的DOM元素快得多。</p><h1 id="61b5" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">2009年响应式游戏设计</h1><p id="bac5" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><strong class="kx jh"> Pulsen反应灵敏</strong>。在响应式网页设计出现之前，我记得看到人们在使用StepMania时将游戏窗口最大化，引擎会将所有东西都拉长。</p><p id="bbf5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我为此创建了一个解决方案，增加了一个名为<code class="fe mp mq mr ms b">ScreenResolutionChangedMessageCommand</code>的生命周期函数，它会在游戏窗口调整大小时触发。</p><p id="fe07" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您通常会看到这样的情况:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b462" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我执行了来自<code class="fe mp mq mr ms b">InitCommand</code>的<code class="fe mp mq mr ms b">ScreenResolutionChangedMessageCommand</code>,所以它会以那种方式初始化，然后对任何分辨率变化做出反应。通常，这个功能只会修改演员在屏幕上的位置，但有时它也会改变缩放级别，因为早在2009年，上网本和非高清显示器是一件事，我希望游戏在所有显示器上都好看。</p><p id="93d0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在JavaScript世界里，你会知道这是<code class="fe mp mq mr ms b">window</code>上的resize事件:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="09c6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想想在每个组件上都做这样的事情！如果你有一个<code class="fe mp mq mr ms b">componentDidResize</code>生命周期方法，允许你相应地更新你的CSS-in-JS，那就简单多了，这也是我可以利用的。</p><p id="1ed9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">StepMania中没有CSS，所以你必须自己管理演员的所有信息；非常类似于CSS-in-JS和其他helper组件。在我创建的一个响应式组件库中，我监听(并抑制)<code class="fe mp mq mr ms b">window</code> resize事件，这样当它改变时我可以发出Redux动作，这样每个组件可以计算自己的大小并相应地改变其内部内容。</p><p id="c2ec" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了响应式CSS和<code class="fe mp mq mr ms b">@media</code>查询，我不得不手动做的许多事情变得自动化了；尽管早在2009年，直到2011年，大多数浏览器才开始支持这些功能。一些浏览器，如Firefox和Safari，早在2009年就开始支持<code class="fe mp mq mr ms b">@media</code>，但它们直到2012年才被广泛使用，因为浏览器自动更新在当时还相对较新。</p><h1 id="775c" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">鼠标点击很难</h1><p id="3d73" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为了判断鼠标是否单击了HTML元素，浏览器知道每个元素的宽度，并且父元素通常是所有子元素的宽度之和。它还知道它们的高度，然后通过作为该组件的父组件的所有组件使点击事件冒泡。</p><p id="da05" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React受益于浏览器对鼠标点击和键盘控制的处理，与React不同，我不得不在处理它们的每一个角色中亲自完成这项工作。</p><p id="5b6d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">任何对鼠标点击有反应的演员都必须倾听<code class="fe mp mq mr ms b">LeftClickMessageCommand</code>。然后它必须检查鼠标点击的X和Y位置与它在屏幕上的当前位置。知道一个演员是否被点击的唯一方法是获取它的X和Y坐标(和Z，但我们不在这里谈论3D)，计算出宽度和高度，然后查看鼠标点击是否在范围内。</p><p id="78ef" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上，给定的X和Y是相对于演员框架的，这使得事情变得更加复杂。获得真正的X和Y坐标的唯一方法是沿着演员帧链向上，同时获取父X和Y值。另一个复杂的问题是宽度和高度可能会受到缩放级别和父缩放级别的影响。</p><p id="de22" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不需要太复杂，这是一个典型的例子，说明我如何判断一个<code class="fe mp mq mr ms b">Quad</code>是否被点击:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0a9a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我使用<code class="fe mp mq mr ms b">self:GetZoomX() / 2</code>作为<code class="fe mp mq mr ms b">ItemXOffset</code>，因为<code class="fe mp mq mr ms b">GetX</code>和<code class="fe mp mq mr ms b">GetY</code>从演员的中心返回坐标，如果我有一个80px宽的演员，我需要从那个X值看到+40px和-40px。</p><p id="0970" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了节省代码，我在这个类上创建了一个函数，既可以在左键点击时运行，也可以在右键点击时运行，就像你为一个<code class="fe mp mq mr ms b">onClick</code>向基于类的React组件添加一个函数一样。</p><h1 id="abd7" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">让文本流动</h1><p id="656c" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在这个特殊的引擎中，文本并不像浏览器那样流动，而是在一个sprite中的一组光栅图像，它们彼此相邻。当文本超过特定的行长度时，我必须编写一些代码来处理换行。因为所有字符的大小不同，所以我通过获取当前元素和所有父元素的累积宽度来计算这些值。HTML为你做的事情太多了。</p><p id="3a4d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，当我不得不做如何播放屏幕时，这是一件痛苦的事情，从来没有真正正确地工作过，但后来我找到了一种在引擎中做这件事的方法，前提是我有正确的计算:</p><pre class="nf ng nh ni gt nj ms nk nl aw nm bi"><span id="3084" class="mt lt jg ms b gy nn no l np nq">self:wrapwidthpixels(<br/>  (Item.ZoomX / Item.FontSizeBody)<br/>  - (Item.XYPadding * 2)<br/>)</span></pre><p id="fc5c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是啊，很难看，但很有效。当你在使用HTML时，很难体会到它有多好。人们经常抱怨HTML和CSS的文本流以及它可以有多复杂，但老实说？和StepMania比起来超级容易。</p><p id="2113" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想象一切都是<code class="fe mp mq mr ms b">position: absolute</code>。你现在必须找出一种方法，使文本在到达边界时流动，找出如何放置所有内容，使其适合在一起，并确保所有内容都像flexbox或CSS Grid一样灵活。祝你好运！</p><h1 id="85d5" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">使用库(不是一个选项)</h1><p id="e86d" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你在想“可能已经有一个库来做这件事了，你为什么要自己做呢？”，你错了。没有助手库。这个引擎几乎拥有这个社区的所有东西，而且是一个14-26岁的小众社区。当时，GitHub和BitBucket是存在的，但并不是真正的东西。那时我运行我自己的私人Git服务器。</p><p id="d127" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我写的所有疯狂的代码都是别人在引擎中没有做过的。想想2015年之前的反应。没有多余的，所以你必须想出你自己的国家管理计划。和Node.js，于2009年5月27日发布。我记得在一家初创公司尝试设置它来代替PHP，但Express.js甚至不是一个东西！我不得不自己从头开始组装网络服务器。</p><p id="46c5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我就是这个意思。在这个庞大开发人员社区接管之前，您必须自己解决所有问题。我们决定采用React这种流行的、有据可查的方式来处理状态，这真是太棒了，但是多年前对我来说简直就是地狱，尤其是因为这是我的第一个代码项目。即使在今天，我也不像了解JavaScript那样真正了解Lua、C++或PHP。JavaScript成为我的首选有点疯狂，但我认为这是因为社区中的大量开发人员对事情应该如何发展有不同的想法。</p><h1 id="c042" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">结论</h1><p id="4988" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">自从我开始研究Pulsen以来，大约有10年了，我感觉我已经围绕React、Redux和Redux-Observable完成了一个完整的循环。令人惊讶的是，这些完全不同的技术如此相似，最终都用组件模型解决了相同的问题。</p><h1 id="b4cc" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">更多阅读</h1><p id="a87f" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你对我的Lua之旅感兴趣，请查看:</p><p id="f71e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/pointlessly-writing-redux-in-lua-b64894e8ede5">为什么我在Lua里写Redux</a></p><p id="5aba" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还对React、Redux和Redux-Observable有很多其他独特的看法:</p><ul class=""><li id="93aa" class="nr ns jg kx b ky kz lb lc le nt li nu lm nv lq nw nx ny nz bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/async-react-using-react-router-suspense-a86ade1176dc?source=your_stories_page---------------------------">使用React路由器的异步React&amp;悬念</a></li><li id="09a5" class="nr ns jg kx b ky oa lb ob le oc li od lm oe lq nw nx ny nz bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/using-redux-reducers-in-react-components-4e92985dd9cb">在React组件中使用Redux还原剂</a></li><li id="be22" class="nr ns jg kx b ky oa lb ob le oc li od lm oe lq nw nx ny nz bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/redux-observable-without-redux-ff4a2b5a4b39">无冗余可观察</a></li><li id="04d6" class="nr ns jg kx b ky oa lb ob le oc li od lm oe lq nw nx ny nz bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li></ul></div></div>    
</body>
</html>