<html>
<head>
<title>Vue.js App Performance Optimization: part 2— Lazy loading routes and vendor bundle anti-pattern.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js应用性能优化:第2部分——惰性加载路径和供应商捆绑反模式。</h1>
<blockquote>原文：<a href="https://itnext.io/vue-js-app-performance-optimization-part-2-lazy-loading-routes-and-vendor-bundle-anti-pattern-4a62236e09f9?source=collection_archive---------1-----------------------#2019-02-09">https://itnext.io/vue-js-app-performance-optimization-part-2-lazy-loading-routes-and-vendor-bundle-anti-pattern-4a62236e09f9?source=collection_archive---------1-----------------------#2019-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7dd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在</strong> <a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/vue-js-app-performance-optimization-part-1-introduction-to-performance-optimization-and-lazy-29e4ff101019"> <strong class="jp ir">上一篇文章</strong> </a> <strong class="jp ir">中，我们学习了什么是代码拆分，它如何与Webpack一起工作，以及如何在Vue应用程序中通过延迟加载来使用它。现在，我们将更深入地挖掘代码，学习对代码分割Vue.js应用程序最有用的模式。</strong></p><p id="2823" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该系列基于从<a class="ae kl" href="https://github.com/DivanteLtd/vue-storefront" rel="noopener ugc nofollow" target="_blank"> Vue店面</a>性能优化流程中获得的经验。通过使用下面的技术，我们能够将初始包的大小减少70%,并在一眨眼的时间内完成加载。</p><p id="f7ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://vueschool.io/articles/vuejs-tutorials/lazy-loading-and-code-splitting-in-vue-js/" rel="noopener ugc nofollow" target="_blank">第1部分—性能优化和延迟加载简介。</a></p><p id="c5c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://vueschool.io/articles/vuejs-tutorials/vue-js-router-performance/" rel="noopener ugc nofollow" target="_blank">第2部分—惰性加载路线和供应商捆绑反模式。</a></p><p id="7135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/vue-js-app-performance-optimization-part-3-lazy-loading-vuex-modules-ed67cf555976">第3部分—惰性加载Vuex模块</a></p><p id="5b8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第4部分——提供良好的等待体验和延迟加载单个组件——很快</p><p id="637c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第5部分—延迟加载库并寻找更小的等价库—很快</p><p id="f664" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第6部分——UI库的性能友好使用</p><p id="39f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第7部分—利用服务工作者缓存—很快</p><p id="543e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第8部分—预取</p><h1 id="db9b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">文章已移动</h1><p id="6277" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">嘿，这篇文章已经更新了更多的见解，并转移到VueSchool博客<a class="ae kl" href="https://vueschool.io/articles/vuejs-tutorials/vue-js-router-performance/" rel="noopener ugc nofollow" target="_blank">这里</a>！</p></div></div>    
</body>
</html>