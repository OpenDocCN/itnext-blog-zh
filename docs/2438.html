<html>
<head>
<title>Code generation for backend and frontend. When, why and how?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后端和前端的代码生成。何时、为何和如何？</h1>
<blockquote>原文：<a href="https://itnext.io/code-generation-for-backend-and-frontend-when-why-and-how-a14d1cbbc47b?source=collection_archive---------6-----------------------#2019-05-23">https://itnext.io/code-generation-for-backend-and-frontend-when-why-and-how-a14d1cbbc47b?source=collection_archive---------6-----------------------#2019-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/cb0adf76a302b11011b6c9f16c511dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hgBiaphL2elBLdn8m1D1Fw.jpeg"/></div></div></figure><div class=""/><p id="be50" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想在这篇文章中展示我们公司如何生成后端(和一点前端)代码，为什么我们需要代码生成，以及我们使用的一些代码生成技术。</p><p id="bcfb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们到底产生了什么？这一点都不重要。<br/> <em class="kz">我们如何做到这一点</em>——人们可能会对在他们的项目中使用Gradle以及做类似事情的方式感兴趣。代码生成的动机和生成的来源是什么——这些都是值得讨论的有趣话题..</p><p id="2ee6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在这里描述3种对象，它们是前端-后端交互的所有代码生成项目的源，有时是完整的后端实现。</p><p id="dee7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">1.消息——以序列化为JSON的形式参与前端/后端交互的对象。</p><p id="5a3e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.端点—由前端调用的URI，带有对其HTTP方法、查询参数、主体类型和responserequest的描述</p><p id="c26a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.实体——持久存在于后端并需要生成DAO层的消息，以及用于创建/更新/列出/删除的标准端点</p><p id="8204" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不是前端专家，但有些事情我知道:</p><p id="3dfb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">1.在我们公司，frontend是用Typescript编写的，所以我也想为消息生成Typescript类</p><p id="9a47" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.对后端的许多需求(至少在控制器层)来自前端人员。</p><h1 id="2b98" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">后端代码要求</h1><p id="9537" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面是前端的后端要求:</p><ol class=""><li id="86b3" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">类似REST的后端API</li><li id="143e" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">统一响应— JSON，有效载荷在<em class="kz">“数据”</em>字段中</li></ol><p id="156a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.统一错误响应— JSON，消息在<em class="kz">“error”</em>字段，在开发环境堆栈跟踪中在<em class="kz">“stack trace”</em>字段</p><p id="904f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">4.<em class="kz">【正确】</em> HTTP代码—如果找不到实体，则为404，如果json无效，则为400，等等。</p><p id="c49f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我这边的后端要求:</p><p id="0006" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">1.在一个地方处理错误</p><p id="2fd5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.可以在任何地方中断业务逻辑流，并告诉前端我想发送什么HTTP代码和消息</p><p id="960f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.有些业务逻辑我想用阻塞方式编写(例如，如果我使用阻塞库)，有些—用异步方式。但是这两者在我的异步框架中都应该工作得很好。</p><p id="3bc0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">4.后端开发者不要去想请求和响应，HTTP代码，控制器(如果我用Spring)或者Vertx路由(如果我用Vertx)，关于事件总线等等。他们应该写一个商业逻辑。</p><p id="18b7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还想为Typescript和Kotlin生成并行类，这样我将确保前端发送给后端的正是后端期望接收的对象。没有“未知属性”错误。</p><h1 id="dbf1" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">下面是我们将生成的内容。</h1><p id="5ee3" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们将以一些假设的web应用程序为例，它可以保存和编辑书籍。一种图书馆。</p><p id="7ec7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">后端技术— Kotlin、Vert.x、coroutines。类似于我在文章<a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/three-paradigms-of-asynchronous-programming-in-vertx-b01ab24d0927">“vert . x中异步编程的三个范例”</a>中展示的东西</p><p id="49f8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了更有趣，我们将使用Spring JPA创建DAO层。</p><p id="eba0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不是说把Spring和Vert.x混在一起是个好主意(虽然我这么做！)，我只是拿Spring来展示实体的代码生成。</p><h1 id="7906" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">项目结构。</h1><p id="cbab" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在我们将为这一代人创建一个项目。</p><p id="422d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它将由4个模块组成。现在我将在同一个git存储库中创建它们，但在现实生活中，每个模块都将被放在自己的git repo中，因为它们会在不同的时间发生变化，并且会有不同的版本。</p><p id="28e8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，第一个项目包含我们的端点、消息等的注释。</p><p id="691f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将称之为<em class="kz">【元信息】</em>。</p><p id="d51b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另外两个项目——<em class="kz">codegen</em>和<em class="kz"> api </em>依赖于<em class="kz"> metainfo </em>项目。</p><p id="9ec1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> api </em>包含端点和消息的描述——参与前端/后端交互的类</p><p id="b9ee" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> codegen </em>是代码生成项目(但不是生成代码的项目！)—它包含从<em class="kz"> api </em>项目类和代码生成器收集信息的代码。</p><p id="3ed0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">生成器将通过命令行参数接收所有细节——哪个包采用端点，将生成的文件写入硬盘上的哪个目录，什么是<em class="kz"> Velocity </em>模板文件名等等。</p><p id="d267" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以<em class="kz"> metainfo </em>和<em class="kz"> codegen </em>是通用项目——你可以在不同的应用程序中使用它们，而<em class="kz"> api </em>是特定于特定的web应用程序的。</p><p id="2e61" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们生成代码的两个项目:</p><p id="7b87" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="kz">前端生成的</em>中，我们生成了Typescript类，它对应于Kotlin消息和实体类</p><p id="7c09" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以及<em class="kz">后端</em>——我们的Vert.x应用</p><p id="6468" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了使一个项目(gradle模块)类对另一个可见，我们将使用一个gradle插件在本地Maven库中发布工件。</p><h2 id="c18f" class="ms lb je bd lc mt mu dn lg mv mw dp lk km mx my lo kq mz na ls ku nb nc lw nd bi translated">Metainfo项目:</h2><p id="6cb8" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">标记生成源的注释—端点、消息、实体:</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="108e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于Typescript类，我们将定义注释，这些注释将标记消息字段，并将被添加到生成的Typescript类中:</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b16f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是metainfo项目的一个<a class="ae mr" href="https://gitlab.com/bernshtam-articles/kotlin-codegen-part-1/tree/master/metainfo" rel="noopener ugc nofollow" target="_blank">源代码。</a></p><h2 id="6d33" class="ms lb je bd lc mt mu dn lg mv mw dp lk km mx my lo kq mz na ls ku nb nc lw nd bi translated">项目api:</h2><p id="b2aa" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">注意<em class="kz"> build.gradle </em>中的<em class="kz"> noArg </em>和<em class="kz"> jpa </em>插件，用于生成无参构造函数。</p><p id="e721" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于缺乏想象力，我们会对端点和实体进行一些疯狂的描述:</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ce1b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个api项目的<a class="ae mr" href="https://gitlab.com/bernshtam-articles/kotlin-codegen-part-1/tree/master/api" rel="noopener ugc nofollow" target="_blank">源代码。</a></p><h2 id="1219" class="ms lb je bd lc mt mu dn lg mv mw dp lk km mx my lo kq mz na ls ku nb nc lw nd bi translated">Codegen项目:</h2><p id="3a5e" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">首先，我们将定义“<em class="kz">描述符</em>”—类，我们将通过从对“<em class="kz"> api </em>”项目类的反映中接收到的信息来填充这些类:</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ae6e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是收集信息的代码:</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="75a0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，这个项目包含“主”类、实用程序类等等。你可以在库中看到所有的<a class="ae mr" href="https://gitlab.com/bernshtam-articles/kotlin-codegen-part-1/tree/master/codegen" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="422e" class="ms lb je bd lc mt mu dn lg mv mw dp lk km mx my lo kq mz na ls ku nb nc lw nd bi translated">在项目<em class="nk">前端生成的</em>和<em class="nk">后端</em>中，我们做类似的事情:</h2><p id="668f" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">1.编译阶段对<em class="kz"> api </em>项目的依赖。</p><p id="3f29" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.构建过程对<em class="kz"> codegen </em>项目的依赖性。</p><p id="a00c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.生成模板在buildSrc目录中，该目录在<em class="kz"> gradle </em>中用于类和资源，用于构建过程，但不用于编译或运行时。也就是说，我们可以在不重新编译<em class="kz"> codegen </em>项目的情况下更改生成模板</p><p id="52a8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">4.前端生成的编译生成的类型脚本，并将其发布到npm包存储库。</p><p id="de96" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">5.在<em class="kz">后端</em>项目中，我们生成<em class="kz">路由器</em>，它们继承自非生成的抽象<em class="kz">路由器</em>，后者知道如何处理各种请求。此外，我们生成抽象的<em class="kz">verticals</em>，您应该通过业务逻辑实现继承它。此外，我们会生成许多样板代码——编解码器注册、事件总线中的地址常量等等——所有这些细节，程序员都不应该考虑。</p><p id="07c0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是<a class="ae mr" href="https://gitlab.com/bernshtam-articles/kotlin-codegen-part-1/tree/master/frontend-generated" rel="noopener ugc nofollow" target="_blank"> <em class="kz">前端生成</em> </a>和<a class="ae mr" href="https://gitlab.com/bernshtam-articles/kotlin-codegen-part-1/tree/master/backend" rel="noopener ugc nofollow" target="_blank"> <em class="kz">后端</em> </a>的源代码。</p><p id="18da" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="kz">前端生成的</em>中，注意将生成和编译的源代码发布到npm repo的插件。为了让它工作，把你的库的IP放到<em class="kz"> build.gradle </em>中，把你的认证令牌放到<em class="kz">中。npmrc </em>文件</p><p id="dac9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是生成的typescript类的样子:</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5089" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意类验证器注释。</p><p id="a149" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在后端项目中，我们还为Spring数据JPA生成了存储库。我们可以看出verticle中的消息处理方法是阻塞的(将使用Vertx.executeBlocking执行)还是异步的(使用协程)。</p><p id="29a1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以知道为一个实体生成的verticle将是抽象的，我们将覆盖hooks，它在生成方法之前和之后被调用。</p><p id="da5b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们自动部署所有的垂直——只需获得所有类型为<em class="kz">垂直</em>的beans。</p><p id="9ba8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个框架很容易扩展——例如，我们可以在一个端点上放置一个用户角色列表，并生成一个代码，检查登录的用户是否具有允许的角色之一。</p><p id="5399" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，通过改变模板，我们可以生成akka-http，而不是Vertx和Spring(甚至是Visual Basic:)</p><p id="bf81" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个方向——生成更多的前端代码，或者swagger或WSDL或任何你想要的东西。</p><p id="ebb9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那些项目的所有源代码都是<a class="ae mr" href="https://gitlab.com/bernshtam-articles/kotlin-codegen-part-1" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="2b30" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">感谢前端团队伊尔达的帮助。</em></p></div></div>    
</body>
</html>