<html>
<head>
<title>Stop using Bootstrap — create a practical CSS Grid template for your component based UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止使用Bootstrap——为基于组件的UI创建一个实用的CSS网格模板</h1>
<blockquote>原文：<a href="https://itnext.io/stop-using-bootstrap-create-a-practical-css-grid-template-for-your-component-based-ui-da784d974cc7?source=collection_archive---------2-----------------------#2019-06-17">https://itnext.io/stop-using-bootstrap-create-a-practical-css-grid-template-for-your-component-based-ui-da784d974cc7?source=collection_archive---------2-----------------------#2019-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2d87395d00bcbfa3596332a6c69c6ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EbgTbtDc1c9luq61fqhZ5A.png"/></div></div></figure><p id="ce55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论您是CSS Grid的新手，还是想要更上一层楼，您都很难在网上找到深入实际用例的好资源，或者演示如何为当前的前端项目利用Grid的最佳特性。</p><p id="8073" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将带你为基于组件的ui创建一个Bootstrap风格的、响应性强的12列网格模板——只使用CSS Grid、简单的语义HTML和SASS。最后，我们将通过用它重新创建reactjs.org首页来测试我们的模板！</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="ef64" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">我们的线框</h1><p id="6680" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">首先，让我们把目光放在目标上。我们将构建的模板是移动优先的，但我在这里展示桌面线框，因为它有助于更好地概述:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/950d2a89e7b621d42efcb4332a66a182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUTFToRFqdE_vlb3grJxAQ.png"/></div></div></figure><p id="d24c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，我们的模板分为3个非常常见的区域——页眉、主页面和页脚(红色、蓝色和绿色区域)。我们的页眉和页脚各由14列组成——2列在侧边用于间距，12列用于内容。我们的主区域(蓝色)可以包含任意数量的组件，每个组件也使用14列。白色条纹表示我们的列之间的间距。</p><p id="8dc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，虽然看起来好像整个事情是一个大网格，线框中的每个“行”实际上是实现自己的网格！因此，例如，组件2(卡片)不必遵循我们的14列惯例，每端都有一个液体间隔列。它可以很容易地被制作成在2行上具有6列等宽并且具有完全不同的装订线间距。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="412a" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">HTML</h1><p id="1a39" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">下面是我们需要的所有标记。花一分钟来惊叹它是如此的干净和美丽。</p><p id="cd11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还会注意到，出于演示目的，我们在这里对字幕、卡片、代码和CTA标记进行了硬编码。大概，这就是你让框架的组件迭代器呈现任意数量的不同组件的地方。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/fa3d7201d70682fbd3dba49309921ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCvOHyK9fF4hxE-hy-hS7w.png"/></div></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="516e" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">将主要区域——Flexbox和Grid设计在一起？</h1><p id="b1a3" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我们现在要对主要区域(见上面的Header，main，Footer)以及组件所在的Main内部进行样式化。</p><p id="1498" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是你需要得到的头，主和页脚栈，然后我们的组件在主栈:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/dcc1f10dd96eaf28f6cd5725fa64b7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XMkXIHOfo1hEfbI5DM7JXA.png"/></div></div></figure><p id="6fef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时我几乎能听到你从包里拿出西红柿的声音。拿着你的技术果实。我知道我在这里使用Flexbox，这是因为CSS Grid不是一个万能的。<strong class="ka ir"> Flexbox对于一维扩展更快更简单</strong>(元素连续排列在一列或一行上)<strong class="ka ir">而CSS Grid对于更复杂的2d布局来说是合适的工具</strong>。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="b727" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">网格化我们的标题部分</h1><p id="8660" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我们现在将样式化模板的顶层，我们的标题，我们将开始把它变成一个网格，然后给它一些样式。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/e2bef079198a060b69196c0b279769e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ursXlIb2jXPGv6SHHFbU_Q.png"/></div></div></figure><p id="533a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是细目分类:</p><ul class=""><li id="ea6f" class="mo mp iq ka b kb kc kf kg kj mq kn mr kr ms kv mt mu mv mw bi translated">第2、6和10行— <strong class="ka ir"> grid-area </strong>将我们的Header元素(logo，header__nav &amp; search)的子元素分配给它们的父元素的命名区域。我们将进一步了解这意味着什么。</li><li id="bcd1" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">第11行——CSS Grid附带了一些很酷的属性，用于将项目与网格的单元格对齐。这里我们使用<strong class="ka ir"> align-self: center </strong>将这个项目垂直对齐到单元格的中心，但是还有justify-self、place-self(两者的组合),然后分别用于父项目:align-items、justify-items和place-items。</li><li id="f23c" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">第15行——这是一切的开始。<strong class="ka ir">显示:grid </strong>将我们的Header元素转换成CSS网格容器</li><li id="cdab" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">第17行——使用<strong class="ka ir">网格-列-间隙</strong>我们正在设置我们的列之间的间距(间距)的期望宽度</li><li id="47dc" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">第18行—必填。我们使用<strong class="ka ir">grid-template-columns</strong><em class="nc"/>来定义表头内的列数和大小。第一个值是15px，这意味着第一列的宽度固定为15px。接下来是<strong class="ka ir"> repeat(12，1fr) </strong>，这是一个本地CSS函数，将第二个参数(1fr)重复第一个参数的次数(12)。1fr是一个相对较新的单位，基本上翻译为“可用空间的1分之一”。所以我们在这里做的是定义12个等宽的列。最后，最后一个值是15px，所以最后一列的宽度固定为15px(就像第一列一样)。</li><li id="1aed" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">第19行—我们在这里使用媒体查询断点，以便我们可以为宽屏设备定义不同的装订线宽度和列大小。</li><li id="fabe" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">第21行—这里的<strong class="ka ir">网格-模板-列</strong>的第一个值是<strong class="ka ir">自动</strong>，意味着我们希望第一列是流体。接下来是<strong class="ka ir"> repeat(12，minmax(0px，65px)) </strong>，这意味着接下来的12列的最小宽度应为0px，最大宽度应为65px。在那之后，我们为第14列准备了一辆<strong class="ka ir">汽车</strong>。</li><li id="e1be" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">第24行——在第2、6和10行中，我们定义了网格区域名称；现在使用<strong class="ka ir"> grid-template-areas </strong>我们将指定这些区域在Header父元素中的大小和位置。<strong class="ka ir"> </strong> Grid-template-areas以空格分隔的列表形式接受一个字符串，其中列表中的每个单词代表一列。例如，我们命名为“logo”的区域将从第2列开始，延伸到第4列。带句点的列(。)没有被分配任何区域名称(因此第一列和最后一列是无名的，因此将是空白的)</li></ul></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="0a26" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">添加一些SASS魔法，使一切干燥和可重复使用</h1><p id="c435" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">到目前为止，你已经意识到，如果我们要像上面的标题一样“网格化”每个区域和组件，我们最终会得到很多重复的CSS。所以是时候把萨斯拉出来，让它发光了。</p><h2 id="2ebb" class="nd le iq bd lf ne nf dn lj ng nh dp ln kj ni nj lr kn nk nl lv kr nm nn lz no bi translated">下面是我们将如何重构我们的CSS:</h2><ol class=""><li id="7121" class="mo mp iq ka b kb mb kf mc kj np kn nq kr nr kv ns mu mv mw bi translated">我们将从标题中删除网格本身(上面代码片段中的第17–22行),并将其包装在一个可重用的SASS占位符中！</li></ol><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/096d47697e54a3ce1187e40a17a00530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ZA4vxxVyOY8SqldgF1Jxg.png"/></div></div></figure><p id="016b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以通过简单地在它们的主类中添加<strong class="ka ir"> @extend %grid </strong>来网格化任何区域或组件。</p><p id="bc4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.根据我们使用的列和行的数量，<strong class="ka ir">网格模板区域</strong>属性可以有一个相当长的&amp;重复值。让我们创建一个自定义的SASS函数，使它更加漂亮:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/16a14a4b0f7d15ab36c964266735d397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11s9tAFkZh6rTNOy6TAIrQ.png"/></div></div></figure><p id="137c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使用这个函数并创建一个网格模板行，我们所要做的就是在grid-template-area属性中调用它，如下所示:</p><pre class="mh mi mj mk gt nv nw nx ny aw nz bi"><span id="1ac9" class="nd le iq nw b gy oa ob l oc od">grid-template-areas: <strong class="nw ir">templateRow((x, "col1", y, "col2", ...));</strong></span></pre><p id="0fec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中x和y分别是重复“列1”和“列2”的次数。</p><p id="7786" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用上述两种SASS技术以及一些基本的嵌套，我们得到了这个看起来超级光滑的头代码:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/28803cc35bea0b22fa2f43b425ac6d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T8zlz5yy8280QDHQwoAP0Q.png"/></div></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="23b9" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">完成模板的剩余部分</h1><p id="c20d" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">从现在开始，我们工作的所有其他部分和组件看起来应该与Header的代码片段(如上)几乎完全一样——这确实是它的美妙之处。</p><p id="5c39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使是我们的线框中最难的组件(组件2-卡)也非常容易理解，与标题代码的不同之处仅在于它有更多断点，并且其中一些断点(手机和平板电脑)的模板有不止一行:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/e9693b8532d4fabdf6c104d0eee7c8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAWsWSDvvc1o7M9nnVlaOA.png"/></div></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="3c65" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结束语</h1><p id="7015" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">CSS网格非常棒。我在这里展示了许多可能的体系结构方法中的一种，可以用来替代传统的网格系统。我也鼓励你看看幕后编译的CSS——你会惊讶于它是多么的小和干净。</p><p id="6aec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们来看看这篇文章的标题。我认为像这样的解决方案会让你想要彻底放弃吗？看情况。Bootstrap做了很多非常好的事情，但是它也带来了很多开销，并且会导致一些非常复杂的标记和样式——特别是如果你使用的是基于组件的框架。</p><p id="0068" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我确实认为这是一个非常令人兴奋的选择，浏览器对CSS Grid的支持可能比您想象的要好。CSS Grid在IE 10+上工作得很好(比如Bootstrap 4 ),虽然一些很酷的特性比如grid-template-areas不起作用，但是你可以很容易地使用Grid属性来代替它。你也可以使用像<a class="ae og" href="https://github.com/postcss/autoprefixer#does-autoprefixer-polyfill-grid-layout-for-ie" rel="noopener ugc nofollow" target="_blank"> Autoprefixer </a>这样的聚合灌装机来自动完成这项工作。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="7db4" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">现场演示</h1><p id="e27d" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">这是乡亲们。使用我们刚刚创建的美味CSS网格模板重建的<a class="ae og" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank">reactjs.org</a>首页:<a class="ae og" href="https://codepen.io/mythaphel/pen/bPVjrp" rel="noopener ugc nofollow" target="_blank">https://codepen.io/mythaphel/pen/bPVjrp</a></p><p id="541d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">*注意:您会注意到代码笔中一些javascript。我向您保证，它的唯一目的是从reactjs.org页面(我已经缓存在Github存储库中)提取内容片段，并根据您将在标记中看到的“data-src”属性将它们注入HTML。</p><p id="5231" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一句，我喜欢称这个模板为<strong class="ka ir">高层</strong>,因为堆叠的网格行类似于地板，里面有不同大小的房间。</p><p id="5897" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你从中得到什么，就按那个按钮。非常感谢！</p></div></div>    
</body>
</html>