<html>
<head>
<title>Creating a Linkerd Controller in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中创建Linkerd控制器</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-linkerd-controller-in-golang-e588ad1c821a?source=collection_archive---------6-----------------------#2022-01-04">https://itnext.io/creating-a-linkerd-controller-in-golang-e588ad1c821a?source=collection_archive---------6-----------------------#2022-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2fba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用您自己的Kubernetes控制器在您的集群中维护您的Linkerd部署的期望状态。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/26387e17d96d5fe47889f46bdc6f8cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*27SZtQnxVZIisfQjASJwpA.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">图片来自<a class="ae kx" href="https://octetz.com/docs/2019/2019-10-13-controllers-and-operators/" rel="noopener ugc nofollow" target="_blank">https://octez . com/docs/2019/2019-10-13-controllers-and-operators/</a></figcaption></figure><h1 id="38ac" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">项目架构和核心组件</h1><p id="33d4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在Kubernetes中，控制器是控制循环，它监视您的<a class="ae kx" href="https://kubernetes.io/docs/reference/glossary/?all=true#term-cluster" rel="noopener ugc nofollow" target="_blank">集群</a>中的进程状态，然后在需要的地方做出或请求改变。每个控制器都试图将当前的群集状态移至更接近所需的状态。</p><p id="8217" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的团队需要在生产集群中部署<a class="ae kx" href="https://linkerd.io/" rel="noopener ugc nofollow" target="_blank"> Linkerd </a>，并为长期集群处理证书和密钥的轮换。此外，我们希望对默认的Linkerd安装进行更改。为此，我们创建了一个Linkerd控制器来管理Linkerd对象的生命周期。</p><h2 id="dad2" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated"><a class="ae kx" href="https://linkerd.io/" rel="noopener ugc nofollow" target="_blank"> Linkerd </a></h2><p id="e189" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Linkerd是一个服务网格，为网格应用程序提供相互传输层安全(mTLS)通信以及可观察性指标。当使用默认的<code class="fe mn mo mp mq b">linkerd install</code>命令安装时，Linkerd会自动生成一个有效期为一年的信任锚。为了维持mTLS通信，必须在到期之前轮换该信任锚。</p><p id="69ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于生产目的，我们希望提供自己的信任锚、发行者证书和密钥。为了处理自动轮换，我们决定使用cert-manager。</p><h2 id="5009" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated"><a class="ae kx" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank">证书管理器</a></h2><p id="0569" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Cert-manager在Kubernetes集群中创建证书和证书颁发者作为资源类型。这简化了获取、更新和使用Linkerd所需证书的过程。</p><h2 id="5cc1" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">附加功能</h2><p id="5e87" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">除了自动颁发者和密钥轮换之外，我们还对Linkerd的安装提出了额外的要求，例如设置高可用性的选项，这对于生产工作负载是推荐的，我们还建议将授权策略设置为T1，而不是默认的T2。</p><p id="04cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于这些原因，我们决定实现Linkerd和Cert-manager控制器来维护我们的Linkerd服务网格。</p><p id="f627" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图展示了我们控制器的流程:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/56bafca6d239e80090ba6f81cd65e1d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrajDhWLrXk70sMFYKM5mw.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">我们的Linkerd控制器的序列图</figcaption></figure><h1 id="7f16" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Linkerd安装</h1><p id="0064" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">为了使用我们自己的信任锚，我们安装了带有舵图的Linkerd，而不是默认的<code class="fe mn mo mp mq b">linkerd install</code>选项。这样，我们可以为控制器提供我们自己的信任锚。鉴于我们希望在生产中使用Linkerd，我们决定在这里复制一份Linkerd的Github repo <a class="ae kx" href="https://github.com/linkerd/linkerd2/tree/5e6a1b550872751149552a043f8ff5dda875c40d/charts" rel="noopener ugc nofollow" target="_blank">中的舵图，并将它们添加到我们的代码库中。这样，我们就有了一个稳定的副本，可以在本地使用，并在新版本出现时通过justfile进行更新。</a></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">用于安装Linkerd舵图的just文件</figcaption></figure><p id="6209" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们的项目需要对Linkerd默认安装进行特定的配置更改，所以我们创建了自己的Linkerd对象，该对象允许我们轻松地实现我们的定制配置。例如，考虑到一些安装需要高可用性，我们创建了一个可以根据需要启用的高可用性配置选项。此外，我们希望实现各种状态，以便我们可以轻松地看到我们的Linkerd对象的状态。</p><p id="1aec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是Linkerd对象规范:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">Linkerd对象规范</figcaption></figure><h1 id="ce5f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Linkerd控制器</h1><p id="fa26" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">安装完成后，我们现在可以创建一个控制器来处理Linkerd对象的生命周期。该控制器允许我们按照Linkerd文档中提到的步骤自动旋转控制平面TLS凭证，在此处<a class="ae kx" href="https://linkerd.io/2.11/tasks/automatically-rotating-control-plane-tls-credentials/#save-the-signing-key-pair-as-a-secret" rel="noopener ugc nofollow" target="_blank">找到</a>。</p><h2 id="51ed" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">设置控制器</h2><p id="c9ed" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">下面是我们控制器的入口点，<code class="fe mn mo mp mq b">Run()</code>。在这里，我们创建我们的管理器和记录器，然后启动管理器。传入的是运行之前需要的任何选项，比如设置显式k8s客户机rest配置、启用leader选举和设置特定的绑定地址。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fc84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的创建函数由<code class="fe mn mo mp mq b">Run()</code>调用。在设置了记录器和管理器之后，我们设置了Linkerd协调器。这个结构包含我们的客户机、记录器、Linkerd清单和控制器的名称。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="379e" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">Linkerd调解器</h2><p id="aed2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">下面是我们的Linkerd协调器结构，<code class="fe mn mo mp mq b">l5dReconciler</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">L5d调解器</figcaption></figure><h2 id="674b" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">设置管理器</h2><p id="b92a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在<code class="fe mn mo mp mq b">create()</code>中调用的<code class="fe mn mo mp mq b">SetupWithManager()</code>配置Linkerd控制器来管理我们的Linkerd对象以及它需要监视的其他资源，比如cert-manager证书和Issuer资源。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="f4d3" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">和解</h2><p id="dccc" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们的Linkerd协调器使用我们的<code class="fe mn mo mp mq b">Reconcile()</code>函数来获取我们的Linkerd对象，并设置或重置我们的Linkerd对象的初始状态。通过创建状态，我们可以很容易地看到Linkerd安装的进度，如果出现错误，对象的状态将相应地更新，这样用户就可以清楚地看到对象的状态，而不必参考错误日志。</p><p id="2327" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个项目，我们决定使用与fluxcd相同的状态条件，在这里找到<a class="ae kx" href="https://github.com/fluxcd/pkg/blob/24666ee7787ac10b8dabadaf49d33f8d8c9e7f7e/apis/meta/conditions.go" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="107e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果出现错误，我们会尝试对对象重新排队，以尝试将实际的Linkerd对象与所需的Linkerd对象进行协调。默认情况下，我们每30分钟协调一次，以避免实际对象和期望对象之间的任何意外偏差。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="052d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的私有<code class="fe mn mo mp mq b">reconcile()</code>函数处理我们的大部分安装。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">私有reconcile()函数</figcaption></figure><p id="13ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码处理我们的安装和协调的三个主要部分:</p><p id="780e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们检查信任锚秘密是否存在。这通过<code class="fe mn mo mp mq b">r.reconcileTrustAnchorSecret(ctx, l5d)</code>来检查，它检查信任锚秘密是否存在。如果它不存在，我们创建自己的证书并将证书返回给我们的Linkerd协调器。因为证书管理器需要信任锚，所以必须首先检查它。</p><p id="4a69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，我们调用<code class="fe mn mo mp mq b">r.reconcileCertManager(ctx, l5d)</code>来验证我们的CertManager发行者和证书是否已创建。如果没有找到对象，则创建它们。</p><p id="4e65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们调用<code class="fe mn mo mp mq b">r.reconcileL5dInstall(ctx, l5d, trustAnchorCert)</code>来根据Linkerd对象的规范从官方Helm图表中呈现Linkerd清单。</p><p id="1257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦呈现了Linkerd清单，我们<strong class="jp ir"> </strong>就能够安装Linkerd了！</p><h2 id="7a8a" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">创建信任锚机密</h2><p id="0e59" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">下面是用于检查信任锚秘密是否存在的函数，在<code class="fe mn mo mp mq b">reconcile()</code>中调用。如果秘密已经存在，我们返回现有的证书。如果没有，则创建一个。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">协调信任锚机密</figcaption></figure><p id="e9c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是<code class="fe mn mo mp mq b">createTrustAnchorSecret()</code>功能:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">生成我们的TLS密钥和CA</figcaption></figure><p id="0bd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关创建根证书颁发机构或对私钥进行编码的特定函数的更多细节，请查看Linkerd存储库<a class="ae kx" href="https://github.com/linkerd/linkerd2/tree/main/pkg/tls" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><p id="47df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们在<code class="fe mn mo mp mq b">buildTrustAnchorSecret()</code>中创建K8s秘密:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">构建信任锚K8s秘密</figcaption></figure><h2 id="af4c" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">创建我们的证书管理器资源</h2><p id="5004" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">下面是我们在<code class="fe mn mo mp mq b">reconcile()</code>中调用的cert-manager资源的协调。这里，我们检查cert manager发行者和证书是否存在。如果没有，则创建它们。在整个过程中，如果创建资源时出现任何错误或者资源没有准备好，它们将被收集到一个错误和原因的数组中，然后可以将这些错误和原因报告给Linkerd资源，以将对象的状态更新为<code class="fe mn mo mp mq b">Not Ready</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">证书管理器资源的协调</figcaption></figure><h2 id="0c70" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">呈现我们的Linkerd对象</h2><p id="95c5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">一旦创建了信任锚机密和cert-manager资源，我们就可以最终呈现Linkerd清单了。因为我们总是提供我们自己的信任锚证书，这是作为一个渲染选项自动添加的。接下来，我们检查我们的Linkerd对象是否启用了高可用性。如果是这样，我们用<code class="fe mn mo mp mq b">HighAvailability: true</code>渲染对象。一旦添加了所有的渲染选项，我们就创建了一个非结构化对象的数组，这样我们就可以通过服务器端的应用客户端来应用我们的资源。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">协调Linkerd安装</figcaption></figure><p id="d59a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在准备运行我们的Linkerd控制器的本地实例！</p><h1 id="ed9e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">运行本地实例</h1><p id="f0d6" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们可以使用main.go文件中的<code class="fe mn mo mp mq b">Run()</code>函数来启动控制器:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">main.go</figcaption></figure><p id="842b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦启动并运行，我们应该看到记录器记录我们的Linkerd控制器的设置。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">Linkerd控制器的日志</figcaption></figure><p id="c8be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们可以使用<code class="fe mn mo mp mq b">kubectl apply -f linkerd.yaml</code>应用一个Linkerd对象。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">启用了高可用性的Linkerd对象</figcaption></figure><p id="af1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们可以使用<code class="fe mn mo mp mq b">kubectl get linkerd</code>检查状态:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">获取Linkerd对象的状态</figcaption></figure><p id="acd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们看到Linkerd对象已经准备好，状态显示安装成功。</p><p id="8ebb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，当我们运行<code class="fe mn mo mp mq b">kubectl get pods -n linkerd</code>来查看Linkerd pods时，我们看到三个Linkerd pods，destination、identity和proxy-injector都已启动并运行。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">获取Linkerd窗格</figcaption></figure><p id="2f45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里开始，您可以像往常一样用Linkerd注入您的服务来创建您的服务网格！</p><h1 id="be6d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">关于作者</h1><p id="ddef" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">摩根·戈麦斯是NCR公司的一名软件工程师。她于2021年毕业于佐治亚理工学院，获得了计算媒体学士学位。</p><p id="918f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kevin O'Brien是NCR公司负责零售创新的软件工程师。他于2021年毕业于佐治亚理工学院，获得了计算机科学学士学位。</p><p id="ee35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Alex Weidner是NCR公司的一名软件工程师，专门修理和修理他弄坏的东西。</p></div></div>    
</body>
</html>