<html>
<head>
<title>Build FFmpeg WebAssembly version (= ffmpeg.wasm): Part.6 a Deep Dive into File System (OUTDATED)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建FFmpeg WebAssembly版本(= ffmpeg.wasm):第6部分深入研究文件系统(已过时)</h1>
<blockquote>原文：<a href="https://itnext.io/build-ffmpeg-webassembly-version-ffmpeg-js-part-6-a-deep-dive-into-file-system-56eba10067ca?source=collection_archive---------4-----------------------#2019-12-03">https://itnext.io/build-ffmpeg-webassembly-version-ffmpeg-js-part-6-a-deep-dive-into-file-system-56eba10067ca?source=collection_archive---------4-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/8c0c378d4f8e771bf56ebf20e4685f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*bJYwDAe6Hj59mpHZr46olQ.png"/></div></figure><blockquote class="jx jy jz"><p id="b9ca" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2020/1/14:从ffmpeg.wasm v0.6.0开始，我放弃了IDBFS和NODEFS，并在postMessage中使用Transferable来解决这个问题。IDBFS的主要问题是IDBFS的大小限制太小(大约200 MB)，但是您仍然可以查看这个故事作为使用这两个文件系统的示例。</p></blockquote><p id="47f9" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">上一篇:<a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/build-ffmpeg-webassembly-version-ffmpeg-js-part-5-ffmpeg-js-v0-3-pre-js-and-live-streaming-c1498939a74c">构建FFmpeg WebAssembly版本(= FFmpeg . wasm):part . 5 FFmpeg . wasm v 0.3—前js和直播</a></p><p id="c255" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">在这一部分，您将学习:</p><ol class=""><li id="2e19" class="ld le it kd b ke kf ki kj kz lf la lg lb lh ky li lj lk ll bi translated">MEMFS、IDBFS和NODEFS之间的区别</li><li id="75d2" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated">如何挂载IDBFS和NODEFS</li><li id="1d7b" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated">解决一个现实世界的问题:ffmepg.js文件大小限制</li></ol></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f3b3" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">MEMFS、IDBFS和NODEFS之间的区别</h1><p id="f667" class="pw-post-body-paragraph ka kb it kd b ke mw kg kh ki mx kk kl kz my ko kp la mz ks kt lb na kw kx ky im bi translated">默认情况下，当您使用Emscripten通过文件系统操作传输任何C/C++库时，Emscripten使用一个名为MEMFS的模拟文件系统来确保库在browser和node.js环境下工作。</p><p id="fa86" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">使用MEMFS既方便又快捷，但也有一些缺点:</p><ol class=""><li id="87d9" class="ld le it kd b ke kf ki kj kz lf la lg lb lh ky li lj lk ll bi translated">由于Emscripten最多只能使用2 GB内存，因此MEMFS更容易耗尽内存</li><li id="ba62" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated">在您的主进程和Emscripten之间将有一个数据“传递”行为(参见“解决一个现实世界的问题:ffmepg.js文件大小限制”)</li></ol><p id="3af3" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">要解决这些问题，一种方法是使用IDBFS和NODEFS作为应用程序的真正文件系统。</p><p id="a8b6" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">IDBFS，用在浏览器(和web worker)环境中是使用IndexedDB作为文件系统来存储你的文件</p><blockquote class="jx jy jz"><p id="f911" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于IndexedDB有一些同步问题，您需要在写入文件后使用FS.syncfs()</p></blockquote><p id="eca2" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">NODEFS，用在Node.js环境中就是用Node.js中的fs API来模拟一个文件系统。</p><blockquote class="jx jy jz"><p id="0eae" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更多详情:<a class="ae lc" href="https://emscripten.org/docs/api_reference/Filesystem-API.html" rel="noopener ugc nofollow" target="_blank">https://EMS cripten . org/docs/API _ reference/file system-API . html</a></p></blockquote><h1 id="ef1d" class="ly lz it bd ma mb nb md me mf nc mh mi mj nd ml mm mn ne mp mq mr nf mt mu mv bi translated">如何挂载IDBFS和NODEFS</h1><p id="6bac" class="pw-post-body-paragraph ka kb it kd b ke mw kg kh ki mx kk kl kz my ko kp la mz ks kt lb na kw kx ky im bi translated">挂载IDBFS和NODEFS需要使用第5部分介绍的<code class="fe ng nh ni nj b">--pre-js</code>，这次我们需要覆盖一个名为<code class="fe ng nh ni nj b">preRun</code>的函数(详情<a class="ae lc" href="https://emscripten.org/docs/api_reference/module.html#Module.preRun" rel="noopener ugc nofollow" target="_blank">此处</a>)。</p><p id="6508" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">下面是一个用法示例:</p><figure class="nk nl nm nn gt ju"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b512" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">根据您的应用程序，使用其他函数如<code class="fe ng nh ni nj b">preInit</code>应该没问题，但是这里我们使用<code class="fe ng nh ni nj b">preRun</code>来完成任务。</p><h1 id="f4aa" class="ly lz it bd ma mb nb md me mf nc mh mi mj nd ml mm mn ne mp mq mr nf mt mu mv bi translated">解决一个现实世界的问题:ffmepg.js文件大小限制</h1><p id="c61c" class="pw-post-body-paragraph ka kb it kd b ke mw kg kh ki mx kk kl kz my ko kp la mz ks kt lb na kw kx ky im bi translated">有一天有一个<a class="ae lc" href="https://github.com/ffmpegjs/ffmpeg.js/issues/8" rel="noopener ugc nofollow" target="_blank">问题</a>报告说ffmpeg.wasm不能处理大文件。为了解决这个问题，我们首先重新审视我们的设计:</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/d604d1a97ac29a0f8b42e8e7fb83248b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdaTyo-qSzmL9epngObitw.png"/></div></div></figure><p id="ab5f" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">当媒体文件不是很大时，看起来还可以，但是当媒体文件大到100 MB时，通过postMessage()或send()传递这样大的媒体文件看起来不合理，因此会导致ffmpeg.wasm崩溃。</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/e75cde5f80b327bf0697467c61db09b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zox-D_UAmN2DFafBIsspKw.png"/></div></div></figure><p id="3320" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">这里的瓶颈是由于Web Worker / Child进程作为一个传递组件来发送和接收媒体文件，为了解决这个问题，我们需要使用一个Worker和Web Worker / Child进程都可以访问的文件系统，因此我们进行了重新设计，这是优化的设计。</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nv"><img src="../Images/c9eabbc3ecee63d040fa890480cadaae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qo1wcwvKcqdAkjyqg98FQ.png"/></div></div></figure><p id="9e99" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">这里的想法是让Worker和Web Worker /子进程都能够从IDBFS / NODEFS中读写，这释放了我们在初始设计中看到的瓶颈。</p><p id="c02c" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">虽然它看起来更复杂，但它解决了ffmpeg.wasm中处理大文件的问题。现在你可以在下面的CodePen中尝试一下。(您可以<a class="ae lc" href="https://drive.google.com/file/d/1uIv_RTzXyS1gf7_erQmOJ_vNRCbAfvgd/view" rel="noopener ugc nofollow" target="_blank">下载</a>一个90 MB的视频文件)</p><figure class="nk nl nm nn gt ju"><div class="bz fp l di"><div class="nw np l"/></div></figure><blockquote class="jx jy jz"><p id="2fb4" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方式的一个主要副作用是，它将海量数据存储在用户的IndexedDB(浏览器)和文件系统(Node.js)中。记住尽可能进行清理和吹扫。</p></blockquote></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="5575" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">这是第6部分，感谢您的时间，期待在下一部分看到你。😃</p><p id="7e87" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">存储库:</p><ul class=""><li id="3552" class="ld le it kd b ke kf ki kj kz lf la lg lb lh ky nx lj lk ll bi translated">ffmpeg-core . js:【https://github.com/ffmpegwasm/FFmpeg T2】</li><li id="6561" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky nx lj lk ll bi translated">ffmpeg . wasm:【https://github.com/ffmpegwasm/ffmpeg.wasm T4】</li></ul></div></div>    
</body>
</html>