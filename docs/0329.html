<html>
<head>
<title>Cross-origin Image fabric JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跨原点图像结构JS</h1>
<blockquote>原文：<a href="https://itnext.io/cross-origin-resource-sharing-cors-fabric-js-95d44b727373?source=collection_archive---------1-----------------------#2018-02-20">https://itnext.io/cross-origin-resource-sharing-cors-fabric-js-95d44b727373?source=collection_archive---------1-----------------------#2018-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3624795067bc473bd1ac66343e1c9efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WoKGgQb1Orh010CJXCFxJA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">【www.rockwellcollins.com T2】号</figcaption></figure><blockquote class="kd ke kf"><p id="9971" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">一种机制，允许从提供第一个资源的域之外的另一个域请求网页上的受限资源(例如字体)。</p></blockquote><p id="f564" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><a class="ae kc" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fross-origin-resource-sharing-cors-fabric-js-95d44b727373" rel="noopener ugc nofollow" target="_blank"> <em class="ki">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="9581" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">当图像有交叉原点时，在chrome上访问图像上下文数据会抛出这个错误。无法从画布获取图像数据，因为画布已被跨原点数据污染。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/6ab9e15fbce3f1b2274c5180dd3bf154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7lDSgydForrt812I2VIAw.png"/></div></div></figure><p id="c677" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">为了使用fabric js解决这个问题，我在这里主要分享三种方法。</p><h1 id="434e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">将crossOrigin设置为匿名</h1><p id="aeca" class="pw-post-body-paragraph kg kh iq kj b kk ml km kn ko mm kq kr lf mn ku kv lg mo ky kz lh mp lc ld le ij bi translated">您必须在fabric中设置一个标志<a class="ae kc" href="http://fabricjs.com/docs/fabric.Image.html#crossOrigin" rel="noopener ugc nofollow" target="_blank"> CrossOrigin </a>，告诉它允许来自未知来源的图像。设置这个很容易。</p><pre class="lj lk ll lm gt mq mr ms mt aw mu bi"><span id="4f0d" class="mv lo iq mr b gy mw mx l my mz">fabric.Image.fromURL( URL, <br/>   <strong class="mr ir">function</strong> (img) {<br/>      canvas.add(img);<br/>      canvas.renderAll();<br/>   },{ crossOrigin: 'anonymous', ... }<br/>);</span></pre><h1 id="0964" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用fabric.util.loadImage</h1><p id="8d06" class="pw-post-body-paragraph kg kh iq kj b kk ml km kn ko mm kq kr lf mn ku kv lg mo ky kz lh mp lc ld le ij bi translated">你不需要设置crossOrigin，当使用<a class="ae kc" href="http://fabricjs.com/docs/fabric.util.html#.loadImage" rel="noopener ugc nofollow" target="_blank"> loadImage </a>时，这个方法隐式处理CORS。</p><pre class="lj lk ll lm gt mq mr ms mt aw mu bi"><span id="9a85" class="mv lo iq mr b gy mw mx l my mz">fabric.util.loadImage(URL, <br/>    <strong class="mr ir">function </strong>(img) {<br/>       <strong class="mr ir">var </strong>fab_image = <strong class="mr ir">new </strong>fabric.Image(img);<br/>       canvas.add(fab_image);<br/>       canvas.renderAll();<br/>    },{left:0, top:0, ... });<br/>});</span></pre><h1 id="710c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用代理图像加载</h1><p id="71c8" class="pw-post-body-paragraph kg kh iq kj b kk ml km kn ko mm kq kr lf mn ku kv lg mo ky kz lh mp lc ld le ij bi translated">这意味着总是从你所在的同一个域渲染图像。</p><p id="f58c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">为此，我创建了一个Django视图，它将从跨域读取图像，将其写入一个临时文件，并用图像数据进行响应。</p><blockquote class="kd ke kf"><p id="0727" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">你可以对rails、php、java采用同样的方法..也是。</p></blockquote><pre class="lj lk ll lm gt mq mr ms mt aw mu bi"><span id="8f39" class="mv lo iq mr b gy mw mx l my mz">import requests<br/>import tempfile<br/>from django.http.response import HttpResponse</span><span id="1738" class="mv lo iq mr b gy na mx l my mz">def proxy_image(request):<br/>    image = requests.get(request.GET['url'], stream=True)<br/><br/>    # Was the request OK?<br/>    if image.status_code != requests.codes.ok:<br/>        return ""<br/><br/>    # Create a temporary file<br/>    lf = tempfile.NamedTemporaryFile()<br/><br/>    # Read the streamed image in sections<br/>    for block in image.iter_content(1024 * 8):<br/>        # If no more file then stop<br/>        if not block:<br/>            break<br/><br/>        # Write image block to temporary file<br/>        lf.write(block)<br/>    lf.seek(0)<br/>    image_data = lf.read()<br/>    lf.close()<br/>    <br/>    return HttpResponse(image_data, content_type="image/jpg")</span></pre><p id="4fa2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在图像URL看起来会像这样</p><blockquote class="kd ke kf"><p id="ac61" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kj ir">获取:</strong>http://yourdomain.com/proxy_image?url=&lt;跨域图片网址&gt;</p></blockquote><pre class="lj lk ll lm gt mq mr ms mt aw mu bi"><span id="02b3" class="mv lo iq mr b gy mw mx l my mz"><strong class="mr ir">var</strong> URL = 'http://yourdomain.com/proxy_image?url=http://crossdomain.com/image.jpg';</span><span id="46c6" class="mv lo iq mr b gy na mx l my mz">fabric.Image.fromURL( URL, <br/>   <strong class="mr ir">function</strong> (img) {<br/>      canvas.add(img);<br/>      canvas.renderAll();<br/>   },{}<br/>);</span></pre><p id="96ee" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">所以每当你需要渲染跨域图像时，只需用查询参数<code class="fe nb nc nd mr b">url</code>向<code class="fe nb nc nd mr b">proxy_image</code>发出GET请求</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="b84a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果您使用AWS s3存储桶来存储您的媒体文件，请参考<a class="ae kc" href="https://zyst.io/how-to-fix-aws-s3-chrome-and-safari-cors-on-images" rel="noopener ugc nofollow" target="_blank"> <em class="ki">如何修复AWS S3 Chrome和Safari CORS在图像上的错误</em> </a> <em class="ki"> </em>进行故障排除。</p><p id="ed4b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">(通过给别人</em>帮助别人找到我在Medium上的文章)👏🏽<em class="ki">下图。)</em></p></div></div>    
</body>
</html>