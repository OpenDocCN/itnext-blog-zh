<html>
<head>
<title>Secrets injection at runtime from external Vault into Kubernetes — POC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在运行时将秘密从外部库注入到Kubernetes-POC</h1>
<blockquote>原文：<a href="https://itnext.io/secrets-injection-from-external-vault-into-kubernetes-poc-83a52c8cf5cb?source=collection_archive---------4-----------------------#2020-12-17">https://itnext.io/secrets-injection-from-external-vault-into-kubernetes-poc-83a52c8cf5cb?source=collection_archive---------4-----------------------#2020-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/faca3aa0f7ba9a5a8a68f6055109443f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*t5jCH5ZXckv7EU9D2_h8uw.png"/></div></figure><p id="1fc8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当您在多云环境中工作时，您不能总是使用AWS secrets manager来存储您的所有秘密。Hashicorp Vault是存储和管理秘密的绝佳解决方案。在这个概念验证中，我将展示如何通过<a class="ae ks" href="https://github.com/hashicorp/vault-k8s" rel="noopener ugc nofollow" target="_blank">https://github.com/hashicorp/vault-k8s</a>轻松直接地将秘密注入到你的豆荚中。许多教程演示了如何在集群中运行vault时使用它，但这里我们将使用外部运行vault。</p><h1 id="8a71" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">理解数据流</h1><p id="2754" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在深入研究代码之前，最重要的事情是理解vault集成是如何与Kubernetes完成的，组件是做什么的，以及它们是如何一起工作的。</p><h2 id="3556" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">库伯内特一侧</h2><p id="8b4a" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">流动始于你想要注入秘密的容器。此pod使用服务帐户运行(例如:sa-awesome-app)。这个SA登录到默认服务器，并请求承担一个角色(awesome-app)。如果角色被允许读取机密，它将被返回给k8s，并作为一个文件注入到pod中挂载的卷中。</p><h2 id="a012" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">拱顶侧</h2><p id="6099" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">最初，Vault从sa-awesome-app接收JWT。为了验证此JWT是否正确，Vault要求k8s验证令牌。Vault配置为将k8s服务帐户与角色绑定。这个角色有一个策略，授予它读取秘密路径(secret/my-awesome-app/config)的权限。</p><p id="d725" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了让k8s能够验证令牌，我们需要另一个ClusterRole类型的服务帐户(sa-vault-auth)来委托身份验证。</p><h1 id="5305" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">亲自动手</h1><p id="df65" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在我们对vault如何集成到kubernetes有了更好的了解，让我们来构建我们的组件。github上有这个POC:<a class="ae ks" href="https://github.com/sylwit/vault_injection_k8s_poc" rel="noopener ugc nofollow" target="_blank">https://github.com/sylwit/vault_injection_k8s_poc</a>。</p><p id="0c8e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">如果不想再等了，就克隆repo，打开Makefile，按顺序运行每个目标。</strong></p><h2 id="5218" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">先决条件</h2><ul class=""><li id="9263" class="mi mj iq jw b jx lr kb ls kf mk kj ml kn mm kr mn mo mp mq bi translated">库伯内特星团。这里我将使用minikube和docker驱动程序。</li><li id="9fe9" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">库贝特尔</li><li id="ee26" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">舵</li><li id="b252" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">Docker(我真的需要详细说明吗)</li><li id="5c1f" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">docker-撰写</li></ul><h2 id="e90b" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">准备我们的k8s环境</h2><p id="0fd4" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">TL；博士:<code class="fe mw mx my mz b">make k8s</code></p><p id="32d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">启动我们的集群，创建一个名称空间“demo”来部署我们的awesome应用程序，将其设置为默认名称空间。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="0cd0" class="lw ku iq mz b gy ni nj l nk nl">kubectl create namespace demo<br/>kubectl config set-context --current --namespace=demo</span></pre><p id="3ed9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用其密码创建服务帐户sa-vault-auth，并将其绑定到cluster role system:auth-delegator。保管库将使用此SA来验证JWT令牌。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="1775" class="lw ku iq mz b gy ni nj l nk nl">kubectl apply -f k8s.yaml</span></pre><p id="140e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过官方舵图安装哈希公司金库。我们需要将injector.externalVaultAddr设置为vault服务器，并且必须可以从您的集群访问该URL。我正在获取makefile中的IP</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b4a3" class="lw ku iq mz b gy ni nj l nk nl">GATEWAY_IP=$(shell minikube ssh "grep host.minikube.internal /etc/hosts" | awk '{print $$1}')</span><span id="0499" class="lw ku iq mz b gy nm nj l nk nl">helm repo add hashicorp https://helm.releases.hashicorp.com<br/>helm install vault hashicorp/vault \<br/>  --set "injector.externalVaultAddr=http://${GATEWAY_IP}:8200"</span></pre><h2 id="5ea4" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">准备我们的金库</h2><p id="f7bb" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">TL；博士:<code class="fe mw mx my mz b">make vault</code></p><p id="ced6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Vault将使用docker-compose启动，需要一个. env文件。(<code class="fe mw mx my mz b">make .env</code>)</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="c290" class="lw ku iq mz b gy ni nj l nk nl">echo "TOKEN_REVIEW_JWT=`kubectl get secret vault-auth -o go-template='{{ .data.token }}' | base64 --decode)}`" &gt; .env<br/>echo "KUBE_CA_CERT_B64=`kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}'`" &gt;&gt; .env<br/>echo "KUBE_HOST=https://`minikube ip`:8443" &gt;&gt; .env<br/>docker-compose run -d vault</span></pre><p id="dbb1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果想访问Vault UI，导航到<a class="ae ks" href="http://localhost:8200" rel="noopener ugc nofollow" target="_blank"> http://localhost:8200 </a>，令牌为:root。它是在docker-compose中硬编码的，否则您可以从<code class="fe mw mx my mz b">docker-compose logs vault</code>开始读取它</p><p id="1001" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">vault运行后，我们创建一个密码，然后启用和配置kubernetes身份验证。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b2f8" class="lw ku iq mz b gy ni nj l nk nl">vault login root<br/>vault kv put secret/my-awesone-app/config username='my_user' password='my_pwd'<br/>vault auth enable kubernetes</span><span id="bf8b" class="lw ku iq mz b gy nm nj l nk nl">echo $KUBE_CA_CERT_B64 &gt; .cert.pem<br/>base64 -d .cert.pem &gt; cert.pem<br/>rm .cert.pem<br/><br/>vault write auth/kubernetes/config \<br/>        token_reviewer_jwt="$TOKEN_REVIEW_JWT" \<br/>        kubernetes_host="$KUBE_HOST" \<br/>        kubernetes_ca_cert=@cert.pem</span></pre><p id="865a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在编写策略，允许读取这个秘密，并将其绑定到SA sa-awesome-app。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="2708" class="lw ku iq mz b gy ni nj l nk nl">vault policy write my-awesome-app - &lt;&lt;<strong class="mz ir">EOF<br/></strong>path "secret/data/my-awesome-app/config" {<br/>  capabilities = ["read"]<br/>}<br/><strong class="mz ir">EOF<br/><br/></strong>vault write auth/kubernetes/role/awesome-app \<br/>        bound_service_account_names=sa-awesome-app \<br/>        bound_service_account_namespaces=demo \<br/>        policies=my-awesome-app \<br/>        ttl=24h</span></pre><p id="74ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我将所有这些设置打包在一个vault-init.sh脚本中，并在运行的vault容器上执行它</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="4ab4" class="lw ku iq mz b gy ni nj l nk nl">VAULT_INIT=`cat ./vault-init.sh`<br/>docker-compose exec vault sh -c "${VAULT_INIT}"</span></pre><h2 id="e08a" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">部署我们的应用</h2><p id="4848" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">TL；博士:<code class="fe mw mx my mz b">make app</code></p><p id="070d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该应用程序是一个简单的HTTP服务器，它读取文件并提供其内容。回购可在此:【https://github.com/sylwit/http_filereader】T4</p><p id="3aa3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还通过在端口30100上运行的服务来公开我们的优秀应用程序。</p><p id="b67c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该文件中提供了完整的代码:<a class="ae ks" href="https://github.com/sylwit/vault_injection_k8s_poc/blob/main/app.yaml" rel="noopener ugc nofollow" target="_blank">https://github . com/syl wit/vault _ injection _ k8s _ POC/blob/main/app . YAML</a></p><p id="1476" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">神奇的事情发生在这些注释中</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="e23b" class="lw ku iq mz b gy ni nj l nk nl">annotations:<br/>  vault.hashicorp.com/agent-inject: "true"<br/>  vault.hashicorp.com/role: "awesome-app"<br/>  vault.hashicorp.com/agent-inject-secret-credentials.txt: "secret/my-awesome-app/config"<br/>  vault.hashicorp.com/agent-inject-template-credentials.txt: |<br/>    {{- with secret "secret/my-awesome-app/config" -}}<br/>    username: {{ .Data.data.username }}<br/>    password: {{ .Data.data.password }}<br/>    {{ end -}}</span></pre><ul class=""><li id="eea4" class="mi mj iq jw b jx jy kb kc kf nn kj no kn np kr mn mo mp mq bi translated">角色定义了我们在vault中承担的角色</li><li id="d94d" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">agent-inject-secret-credentials . txt定义了“secret/my-awesome-app/config”的内容将被写入的文件名。vault-k8s将在/vault/secrets处挂载一个卷，这样就可以在/vault/secrets/credentials.txt处访问最终文件</li><li id="4edb" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">agent-inject-template-credentials . txt格式化文件的内容</li><li id="53af" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">我们将FILEREADER_CHROOT环境变量设置为/vault/secrets作为我们的基本文件夹</li></ul><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="4e15" class="lw ku iq mz b gy ni nj l nk nl">kubectl apply -f app.yaml</span></pre><p id="e622" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">等待几分钟，然后导航到<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/`minikube ip`:30100?file=credentials.txt"> http://`minikube ip`:30100？file=credentials.txt </a>瞧。</p><h1 id="254b" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">初始容器和副容器</h1><p id="f2c0" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">k8s-vault集成可以通过init和side容器来完成。</p><p id="f785" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在应用程序启动之前，init容器将获取这个秘密，并把它注入到前面提到的/vault/secrets卷中。</p><p id="130b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该卷安装在应用程序容器中，因此可以立即访问。</p><p id="a510" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个侧容器也开始了，每5分钟，它检查是否秘密已经改变，如果需要，为我们更新卷。</p><h1 id="f546" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="f631" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我真的很喜欢这样一个事实:当秘密改变时，侧面容器避免了新的发布。一开始配置所有的资源看起来有点乏味，但是一旦完成并编写脚本，就变得非常容易和可重用了。</p></div></div>    
</body>
</html>