<html>
<head>
<title>Understanding RxJS Subjects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解RxJS主题</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-rxjs-subjects-386605ad2bdb?source=collection_archive---------2-----------------------#2019-02-15">https://itnext.io/understanding-rxjs-subjects-386605ad2bdb?source=collection_archive---------2-----------------------#2019-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a051" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘿伙计们。今天我在这里讲的是<a class="ae kl" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>科目。我希望在这篇文章结束时，你会更清楚主要的区别。😊</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/2366e62fa417cf454ae74bc18e0c4f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-E9BaHyyLjwo4K2V51EzRA.png"/></div></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="58ac" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">介绍</h1><p id="36f8" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">如你所知，RxJS为我们的角度应用带来了许多出色的功能，我真正喜欢的一点是它对主题的支持。我们将关注四种主要类型的主题，第一种是普通的<strong class="jp ir">主题</strong>，我们将讨论它的作用和用途。然后我们再来说说<strong class="jp ir">行为主体</strong>、<strong class="jp ir">回放主体</strong>和<strong class="jp ir">异步主体</strong>。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="39c1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">科目</h1><p id="f19f" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">提供一种向侦听器发送一个或多个数据值的方法。现在，<strong class="jp ir">主题</strong>与我们将要讨论的其他主题的不同之处在于，如果另一个组件订阅了，但后来他们不会获得之前发送的所有数据。让我给你看一个例子:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mi"><img src="../Images/1e0c737df2f40519b61970ccde08cdf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nX4Fw-mKUqDDGEUiwz55vQ.png"/></div></div></figure><p id="841b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有右边的这个组件，它订阅了。<strong class="jp ir">主题</strong>然后向下发送一些数据，例如数字1。与此同时，左边的组件没有订阅，所以它当然没有得到数字1。现在让我们假设它确实订阅了，而现在2是从主题<strong class="jp ir">发出的。因为他们都被订阅了。因此，使用<strong class="jp ir">主题</strong>，你只有在订阅后才能获得数据。你不会得到任何以前的数据，这将是主题<strong class="jp ir">与其他主题</strong>的区别之一。</strong></p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="8546" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">行为主体</h1><p id="2e06" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">与<strong class="jp ir">主题</strong>非常相似，除了它有一个<strong class="jp ir">主题</strong>没有的大特点。稍后进入流程的订阅者仍然可以获得一些先前的数据。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mj"><img src="../Images/00092c0fc5abed6f07c66e0c5dee6853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y2tAZqNMmPXD-5aILrD3sw.png"/></div></div></figure><p id="a319" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看前面的图片，假设右边的组件订阅了，我们得到了数字1。如果左边的组件要订阅，他们不会得到数字1或2，因为它已经被传递了，左边的组件没有信息。这里的要点是，最后发出的值仍然可以被稍后订阅该流的人检索到。例如，我们已经讨论过1和2已经被发送到右边的组件，但是如果左边的组件现在订阅，它们将获得最后发出的值。所以，那就是数字2。然后他们会得到任何未来的值，正如你在之前的图像中看到的。<strong class="jp ir">主题</strong>和<strong class="jp ir">行为主题</strong>的最大区别在于，使用<strong class="jp ir">主题</strong>时，你只能在订阅后获得数据，而不能获得之前的任何数据。使用<strong class="jp ir"> BehaviorSubject </strong>你可以获得最后发送的值，即使你在10分钟后订阅。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="02b0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">重播主题</h1><p id="22ac" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">作为<strong class="jp ir">行为主体</strong>，<strong class="jp ir">重放主体</strong>也可以重放发送给任何新订户的最后一个值。不同的是，如果你愿意，它还可以重放所有以前的值。您可以将此视为缓存任何已发送的数据，以便订阅的任何其他组件仍然可以获得该数据。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mk"><img src="../Images/fc510fef5761716ff35be7812086455e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gm4yiFnklbsuyIyEThBJZg.png"/></div></div></figure><p id="4682" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下，我们订阅，我们得到数字1作为数据，数字2也是。然后，左边的组件现在订阅。现在，如果是一个<strong class="jp ir">主题</strong>，我们知道他们不会得到任何东西。如果是一个<strong class="jp ir">行为主题</strong>他们会得到最后一个，但是有了<strong class="jp ir"> ReplaySubject </strong>我们可以向这个新订阅者重播所有以前的项目。因此，在这个例子中，1和2已经被发送到正确的组件，被重放。现在，数字3是一个新的数据，因为他们都订阅了，所以他们都会得到它。如果您想向流程中的后期订阅者重放一个数据序列，这将是非常强大的。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="9310" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">async主语</h1><p id="7561" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">这和其他的很不一样。使用<strong class="jp ir"> AsyncSubject </strong>，您只需要主题完成时的最后一个值。假设我们有一堆可以发送出去的值，但是你只对最新的值感兴趣。看看我们之前的例子，假设我们订阅了，1被传递出去了。我们不会得到那个价值。然后2出来，同样的行为发生。假设3是最后一个值，然后<strong class="jp ir"> AsyncSubject </strong>完成。它允许我们的组件获取最后一段数据，忽略所有其他数据。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ml"><img src="../Images/7b039369985c913b229bd3864f805d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYT492SKsqAai_z18wPU-g.png"/></div></div></figure><p id="fc83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这用于我们的组件或已订阅的组件需要最后最相关的数据的任何情况。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="6390" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="91dc" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">一篇小评论😊。</p><ul class=""><li id="ad76" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">通过<strong class="jp ir">主题</strong>，我们向订阅的观察者发送数据，但任何之前发出的数据都不会像您稍后订阅的那样发送。你只能获得订阅后的数据。</li><li id="ec09" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><strong class="jp ir"> BehaviorSubject </strong>允许你将最后一段数据发送给任何新的观察者，任何新的订阅者。这样，他们仍然可以保持同步。他们不会有所有以前的值，但至少他们有最新的值。</li><li id="1ee7" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">使用<strong class="jp ir"> ReplaySubject </strong>我们可以回放之前发送的所有内容。</li><li id="d49c" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">最后，<strong class="jp ir"> AsyncSubject </strong>向订阅者发出最后一个值，并且当发出的数据序列实际完成时，只发出最后一个值。</li></ul><p id="d9dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不管你需要什么，这是你需要了解的四大类主题。</p><p id="fc6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">提示:</strong>你可以这样配置你的<strong class="jp ir"> ReplaySubject </strong>，例如:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/0ade13b14490e03767a537fac8b3b230.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*cqLB_N18pf6k6gwRAjgNag.png"/></div></figure><p id="a462" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将为您提供发出的最后两个值。当你不需要所有的值时，这很酷，但是<strong class="jp ir">行为主体</strong>也不能满足你的需要。</p></div></div>    
</body>
</html>