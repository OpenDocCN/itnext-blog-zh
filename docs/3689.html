<html>
<head>
<title>Building an In-Memory Index with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript构建内存索引</h1>
<blockquote>原文：<a href="https://itnext.io/building-an-in-memory-index-with-javascript-7f712ff525d8?source=collection_archive---------2-----------------------#2020-02-03">https://itnext.io/building-an-in-memory-index-with-javascript-7f712ff525d8?source=collection_archive---------2-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/87b8bf8dd8d282f43e441d263a11601c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5R9j5BXRCxFTJ16S"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Maksym Kaharlytskyi 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="22cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为程序员，数组是我们日常生活的一部分。假设您正在构建一个电子商务应用程序，并且在某个时候您有一个如下所示的数组:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c787" class="ln lo it lj b gy lp lq l lr ls">const skus = [<br/>  {<br/>    "productId": 1,<br/>    "colorId": 1,<br/>    "sku": "11-M"<br/>  },<br/>  {<br/>    "productId": 1,<br/>    "colorId": 1,<br/>    "sku": "11-L"<br/>  },<br/>  {<br/>    "productId": 1,<br/>    "colorId": 2,<br/>    "sku": "12-M"<br/>  },<br/>  {<br/>    "productId": 1,<br/>    "colorId": 2,<br/>    "sku": "12-L"<br/>  },<br/>  {<br/>    "productId": 2,<br/>    "colorId": 1,<br/>    "sku": "21-M"<br/>  },<br/>  {<br/>    "productId": 2,<br/>    "colorId": 1,<br/>    "sku": "21-L"<br/>  }<br/>];</span></pre><p id="b0d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">给定这个数组，你的新任务将是获得某个<code class="fe lt lu lv lj b">productId</code>的所有<a class="ae kf" href="https://es.wikipedia.org/wiki/Stock-keeping_unit" rel="noopener ugc nofollow" target="_blank"> SKU </a>。你首先想到的是使用<code class="fe lt lu lv lj b">skus.find(s =&gt; productId === s.productId)</code>,对于某些场景来说，这可能是一个好的解决方案。但是，当您的应用程序处理大量数据时，这可能会导致性能问题。</p><p id="9df0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这种情况，更好的方法是将这个数组转换成一个索引，以便直接访问SKU，而不是遍历数组。</p><p id="a82c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以使用<code class="fe lt lu lv lj b">reduce</code>:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="def9" class="ln lo it lj b gy lp lq l lr ls">const productIndex = indexByField(skus, “productId”);</span></pre><p id="9783" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的指数是:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c8a8" class="ln lo it lj b gy lp lq l lr ls">{<br/>  "1": [<br/>    {<br/>      "productId": 1,<br/>      "colorId": 1,<br/>      "sku": "11-M"<br/>    },<br/>    {<br/>      "productId": 1,<br/>      "colorId": 1,<br/>      "sku": "11-L"<br/>    },<br/>    {<br/>      "productId": 1,<br/>      "colorId": 2,<br/>      "sku": "12-M"<br/>    },<br/>    {<br/>      "productId": 1,<br/>      "colorId": 2,<br/>      "sku": "12-L"<br/>    }<br/>  ],<br/>  "2": [<br/>    {<br/>      "productId": 2,<br/>      "colorId": 1,<br/>      "sku": "21-M"<br/>    },<br/>    {<br/>      "productId": 2,<br/>      "colorId": 1,<br/>      "sku": "21-L"<br/>    }<br/>  ]<br/>}</span></pre><p id="c592" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您可以获得特定产品的所有SKU！</p><h1 id="947b" class="ly lo it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">等等…我如何获得特定颜色的SKU？🤔</h1><p id="8823" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">您可能注意到了，我们只通过<code class="fe lt lu lv lj b">productId</code>索引了我们的数组。让我们也用<code class="fe lt lu lv lj b">colorId</code>来索引我们的数组。</p><p id="ce97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑到我们当前的索引状态，应该使用我们的<code class="fe lt lu lv lj b">indexByField</code>函数索引它的值。是的，在这种情况下这是可行的，但是如果我们有许多层次的指数化呢？…</p><p id="0747" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="na">递归救援！</em>T24】</strong></p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4486" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我们来详细解释一下这个<code class="fe lt lu lv lj b">mapObjectValues</code>:</p><ul class=""><li id="c8c8" class="nb nc it ki b kj kk kn ko kr nd kv ne kz nf ld ng nh ni nj bi translated"><code class="fe lt lu lv lj b">value</code>将是我们第一次调用中的数组和下一次递归调用中的索引。</li><li id="332b" class="nb nc it ki b kj nk kn nl kr nm kv nn kz no ld ng nh ni nj bi translated"><code class="fe lt lu lv lj b">shouldMap</code>将决定何时停止进行递归调用。在我们的例子中，它将是<code class="fe lt lu lv lj b">Array.isArray</code>。</li><li id="54e5" class="nb nc it ki b kj nk kn nl kr nm kv nn kz no ld ng nh ni nj bi translated"><code class="fe lt lu lv lj b">mapFn</code>将转换我们的索引值，就像<code class="fe lt lu lv lj b">Array.prototype.map</code>对数组项所做的那样。在我们的例子中，它将是我们的<code class="fe lt lu lv lj b">indexByField</code>函数。</li></ul><h1 id="a78e" class="ly lo it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">把所有的放在一起🧩</h1><p id="3bcb" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">我们准备定义一个函数，通过多个字段索引一个数组。此外，我们扩展了<code class="fe lt lu lv lj b">Array.prototype</code>,这样我们可以直接从实例中调用它:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="82e9" class="ln lo it lj b gy lp lq l lr ls">const productColorIndex = skus.indexBy(“productId”, "colorId");</span></pre><p id="065f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的值将是:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8fb0" class="ln lo it lj b gy lp lq l lr ls">{<br/>  "1": {<br/>    "1": [<br/>      {<br/>        "productId": 1,<br/>        "colorId": 1,<br/>        "sku": "11-M"<br/>      },<br/>      {<br/>        "productId": 1,<br/>        "colorId": 1,<br/>        "sku": "11-L"<br/>      }<br/>    ],<br/>    "2": [<br/>      {<br/>        "productId": 1,<br/>        "colorId": 2,<br/>        "sku": "12-M"<br/>      },<br/>      {<br/>        "productId": 1,<br/>        "colorId": 2,<br/>        "sku": "12-L"<br/>      }<br/>    ]<br/>  },<br/>  "2": {<br/>    "1": [<br/>      {<br/>        "productId": 2,<br/>        "colorId": 1,<br/>        "sku": "21-M"<br/>      },<br/>      {<br/>        "productId": 2,<br/>        "colorId": 1,<br/>        "sku": "21-L"<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="9441" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们只需查阅我们的索引就可以获得SKU:</p><p id="60b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lt lu lv lj b">productColorIndex["1"]["2"];</code></p><h1 id="a7dc" class="ly lo it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">综上📝</h1><p id="d07f" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">在时间复杂度方面，使用索引而不是数组对于优化应用程序中的许多用例非常有用，尤其是在处理大量数据的情况下。</p><p id="4c73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这种收益是有代价的，创建一个索引并将其保存在内存中在某些情况下是非常昂贵的。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="41eb" class="ly lo it bd lz ma nw mc md me nx mg mh mi ny mk ml mm nz mo mp mq oa ms mt mu bi translated">资源</h1><ul class=""><li id="593b" class="nb nc it ki b kj mv kn mw kr ob kv oc kz od ld ng nh ni nj bi translated"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/reference ia/Objetos _ global es/Array/reduce</a></li><li id="c1fa" class="nb nc it ki b kj nk kn nl kr nm kv nn kz no ld ng nh ni nj bi translated">https://en.wikipedia.org/wiki/Stock-keeping_unit<a class="ae kf" href="https://es.wikipedia.org/wiki/Stock-keeping_unit" rel="noopener ugc nofollow" target="_blank"/></li></ul><div class="oe of gp gr og oh"><a href="https://medium.com/better-programming/javascript-iteration-v-s-recursion-and-behind-the-scene-e12fe1756343" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">JavaScript中的迭代与递归</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">幕后的差异，以及如何做出使用哪个的正确决定</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov jz oh"/></div></div></a></div></div></div>    
</body>
</html>