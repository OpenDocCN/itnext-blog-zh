<html>
<head>
<title>Using Let’s Encrypt certs with Oracle Cloud Load Balancer — including auto renew feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Oracle云负载平衡器加密证书—包括自动续订功能</h1>
<blockquote>原文：<a href="https://itnext.io/using-lets-encrypt-certs-with-oracle-cloud-load-balancer-including-auto-renew-feature-7ae87e6d207b?source=collection_archive---------1-----------------------#2020-10-15">https://itnext.io/using-lets-encrypt-certs-with-oracle-cloud-load-balancer-including-auto-renew-feature-7ae87e6d207b?source=collection_archive---------1-----------------------#2020-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a8ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Oracle Cloud free tier包括一个高达10 Mpbs带宽的负载平衡器，足以用于许多项目，本文展示了如何使用使用<a class="ae kl" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">加密的SSL流量让我们来加密</a>免费证书。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/12fa6c77f15d604f856610ebcd363700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g1-KRtwu9-Xr3vuk"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae kl" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="88d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续我的文章<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/my-own-dev-test-cloud-environment-using-oracle-always-free-instances-598695cc3a10">我自己的开发/测试云环境使用Oracle Always Free instances </a>我将扩展它以使用让我们用自动更新特性加密证书，因为这些证书的有效期为3个月，我想自动更新它们。下图描述了部署图:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/52ca99609c763befdad389694923cd78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*axR3FZ2T_-69jHS60hCoMg.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">集群部署图</figcaption></figure><p id="f57f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与我之前的例子不同，现在我没有使用<strong class="jp ir"> <em class="ld"> NGINX </em> </strong>作为我的应用程序的反向代理，而是使用<a class="ae kl" href="https://doc.traefik.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="ld">trae fik</em></strong></a>，因为它允许使用群标签即时发布。</p><p id="0a08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ld"> Traefik </em> </strong>包含了注册<a class="ae kl" href="https://doc.traefik.io/traefik/https/acme/" rel="noopener ugc nofollow" target="_blank"> LetsEncrypt证书</a>的功能，但是由于<a class="ae kl" href="https://certbot.eff.org/docs/using.html#pre-and-post-validation-hooks" rel="noopener ugc nofollow" target="_blank">让我们加密CertBot包含了</a>，所以使用包含<a class="ae kl" href="https://www.nginx.com/blog/using-free-ssltls-certificates-from-lets-encrypt-with-nginx/" rel="noopener ugc nofollow" target="_blank"> NGNIX和CertBot </a>的新Docker容器就足够了。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="4a46" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">配置Traefik反向代理</h1><p id="3009" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">让我们首先配置Traefik反向代理，使用这个堆栈定义<a class="ae kl" href="https://gist.githubusercontent.com/marcelo-ochoa/d86ccd025f97370888eb399534dd304b/raw/5c373f51596a9bfc279fb361983e8798e2dcbac4/docker-compose-traefik.yml" rel="noopener ugc nofollow" target="_blank">docker-compose-traefik . yml</a>首先创建一个外部网络，用于通信反向代理和trae fik公开的内部服务，然后部署de stack。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="ef62" class="mv lm iq mr b gy mw mx l my mz">$ docker network create -d overlay lb_network<br/>$ docker stack deploy -c docker-compose-traefik.yml traefik</span></pre><blockquote class="na nb nc"><p id="ad36" class="jn jo ld jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">我们在这个堆栈中包含了一个whoami服务，用于配置Oracle云负载平衡器后端集更新健康检查(网络-&gt;负载平衡器-&gt;负载平衡器详细信息-&gt;后端集-&gt;后端集详细信息)。</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ng"><img src="../Images/42b45c554aab70ccd72f08d44be7c6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gAsT9WcoerkJg-Ye"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">后端运行状况检查设置</figcaption></figure><p id="d15f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们配置了负载平衡器，并且后端集将流量转发到Traefik实例(复制的),我们就需要一个与负载平衡器关联的公共DNS条目，例如，使用NoIP免费服务，我们可以将A条目定义为:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nh"><img src="../Images/ec8c1f74864d37d2ff5a4092cc11d5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Id0sXk5vC3r3wdcwDrj1wQ.png"/></div></div></figure><p id="3e55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经准备好创建并注册一个与Oracle云负载平衡器相关联的加密证书。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="dc14" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用CertBot、NGINX和OCI客户端的Docker映像</h1><p id="16a2" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">创建Let's Encrypt证书并将其与Oracle云负载平衡器关联的步骤是使用Docker容器实现的，该容器运行在我们的两个节点群集群之一中。这里是一个建立我们Docker形象的项目结构:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/22e5f6525e5c602788b03302bd625af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/0*XWcCpHvYvVt7P9-_"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">Docker图像项目结构</figcaption></figure><p id="b283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<a class="ae kl" href="https://gist.githubusercontent.com/marcelo-ochoa/27c3cb2c5bf3ea30eb0a350137191eff/raw/b2e3ea25c2cd1183e189e8a37b65143c0e203747/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>为我们的映像将包括NGINX，让我们加密CertBot和Oracle OCI工具，见下文:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="cfbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目录<strong class="jp ir"> <em class="ld"> oci/ </em> </strong>具有<strong class="jp ir"> <em class="ld"> Oracle CLI oci </em> </strong>凭证，包括<strong class="jp ir"> <em class="ld">配置</em> </strong>、<strong class="jp ir"> oci_api_key.pem </strong>和<em class="ld">OCI _ API _ key _ public . PEM</em>文件，如文章<a class="ae kl" href="http://www.aorcl.work/2020/01/19/administering-oci-from-wsl/" rel="noopener ugc nofollow" target="_blank">从WSL </a>管理OCI中所述，仅遵循从将CLI连接到您的租赁部分开始的步骤，因为所有</p><p id="82d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们准备好docker映像并上传到我们的Docker注册中心，一个<a class="ae kl" href="https://gist.githubusercontent.com/marcelo-ochoa/b68f77bd9baefb09adc9a7bcec93a485/raw/a0bd2baafb45b03bb7c05d003e792b8c1eb4873e/docker-compose-letsencrypt.yml" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml </a>文件将用于部署一个让我们加密CertBot堆栈:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><blockquote class="na nb nc"><p id="21a1" class="jn jo ld jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">我们定义了两个服务，曾经用于手动启动名为<strong class="jp ir"> nginx </strong>，<strong class="jp ir"> command的证书生成或调试目的:sleep 1d </strong>让我们的容器运行一天，我们可以使用docker exec命令附加它们。另一个名为<strong class="jp ir"> renew </strong>的服务将用于使用Unix crontab的每月触发更新流程。</p></blockquote><p id="1fc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两种服务都会拦截类似<a class="ae kl" href="http://*/.well-known/acme-challenge/" rel="noopener ugc nofollow" target="_blank"> http://*/这样的网址。众所周知的/acme-challenge/ </a>,让我们加密使用它们来验证我们的DNS/IP所有权。</p><p id="721a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">环境变量<strong class="jp ir"><em class="ld">【OCID】</em></strong>和<strong class="jp ir"> <em class="ld"> RENEWED_DOMAINS </em> </strong>用于定制我们的证书生成。<strong class="jp ir"> <em class="ld"> OCID </em> </strong>值可在网络- &gt;负载平衡器- &gt;负载平衡器详细信息(OCID复制链接)中获得</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nj"><img src="../Images/4921ccede275ea05363626feb604c2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_h8rXPPggQYLQtPq"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">负载平衡器详细信息</figcaption></figure><p id="91f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Docker文件中定义的脚本有，<a class="ae kl" href="https://gist.githubusercontent.com/marcelo-ochoa/ba12cc123d48664cbab4e95f4ea9e26b/raw/938625c7f21efc007b9172bc11e50069bb620cf2/renew-certs.sh" rel="noopener ugc nofollow" target="_blank"> renew-certs.sh </a>调用Let's Encrypt CertBot:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="15e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CertBot挂钩调用<a class="ae kl" href="https://gist.githubusercontent.com/marcelo-ochoa/68ef2ddc248428e6cd372897ae47f2ac/raw/5222b74344395f9f709c6362e730b5731e9a803c/create-lb-certs.sh" rel="noopener ugc nofollow" target="_blank"> create-lb-certs.sh </a>，这将在Oracle云负载平衡器上注册我们的新证书</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="fcae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">负载平衡器证书是使用域名和序列号以唯一名称<a class="ae kl" href="https://docs.cloud.oracle.com/en-us/iaas/tools/oci-cli/2.7.0/oci_cli_docs/cmdref/lb/certificate/create.html" rel="noopener ugc nofollow" target="_blank">创建的</a>，我们不能替换或更新现有的证书定义，如果我们第一次使用nginx服务触发证书创建，控制台输出将如下所示:</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="9bc9" class="mv lm iq mr b gy mw mx l my mz">[opc@node2 ~]$ docker exec -ti <strong class="mr ir"><em class="ld">letsencrypt_nginx.1.xz8ifbsorfkn35fsob4nuk022</em></strong> bash</span><span id="2deb" class="mv lm iq mr b gy nk mx l my mz">root@ffb330d973fb:/opt/letsencrypt# /renew-certs.sh<br/>Saving debug log to /var/log/letsencrypt/letsencrypt.log<br/>Plugins selected: Authenticator webroot, Installer None<br/>Renewing an existing certificate<br/>Running post-hook command: <strong class="mr ir"><em class="ld">/create-lb-certs.sh</em></strong><br/>Output from post-hook command create-lb-certs.sh:<br/>dev-oci.servehttp.com-0002<br/>{<br/>"opc-work-request-id": "ocid1.loadbalancerworkrequest.oc1.iad......."<br/>}<br/>{<br/>"opc-work-request-id": "ocid1.loadbalancerworkrequest.oc1.iad......."<br/>}<br/>IMPORTANT NOTES:<br/>- Congratulations! Your certificate and chain have been saved at:<br/>/etc/letsencrypt/live/dev-oci.servehttp.com/fullchain.pem<br/>Your key file has been saved at:<br/>/etc/letsencrypt/live/dev-oci.servehttp.com/privkey.pem<br/>Your cert will expire on 2021-01-12. To obtain a new or tweaked version of this certificate in the future, simply run letsencrypt-auto again. To non-interactively renew *all* of your certificates, run "letsencrypt-auto renew"<br/>- If you like Certbot, please consider supporting our work by:<br/>Donating to ISRG / Let's Encrypt:   <a class="ae kl" href="https://letsencrypt.org/donate" rel="noopener ugc nofollow" target="_blank">https://letsencrypt.org/donate</a><br/>Donating to EFF:                    <a class="ae kl" href="https://eff.org/donate-le" rel="noopener ugc nofollow" target="_blank">https://eff.org/donate-le</a></span></pre><p id="c3a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦注册了新证书，第二步是更新侦听器定义。我们可以通过访问网络-&gt;负载平衡器-&gt;负载平衡器详细信息-&gt;证书控制台来检查这些步骤:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nl"><img src="../Images/67f4350d44dbb36b4fe8cbc448e43768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jvTzLZDxHrcffHax"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">证书列表</figcaption></figure><p id="44ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，Oracle云负载平衡器已准备好使用有效的LetsEncrypt证书接受SSL流量，我们可以通过点击挂锁图标来测试使用Traefik公开另一个堆栈，例如VS-Code web版本</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c1bdd62c01f3a12ab6d6a28f023b487d.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/0*L7fdECRMPxvhPYfM"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">微软VS-Code Web运行在始终免费的实例中，使用加密证书进行加密</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a9df0f23ad81f41cfed6a5a59f9bd636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/0*p5pE1axMidYjJyfB"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">让我们加密有效证书的详细信息</figcaption></figure><p id="5bf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们的主Swarn节点上的一个<strong class="jp ir"> <em class="ld"> crontab </em> </strong> Unix作业将每月触发一次更新过程，例如:</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="5828" class="mv lm iq mr b gy mw mx l my mz">[root@node1 yml]# crontab -l<br/>52 2 1 * * root docker service scale <strong class="mr ir"><em class="ld">letsencrypt_renew=0</em></strong> &amp;&amp; sleep 60 &amp;&amp; docker service scale <strong class="mr ir"><em class="ld">letsencrypt_renew=1</em></strong></span></pre><p id="31a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个月的第一天凌晨2:52。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="72c6" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">2020年12月更新！！！</h1><p id="e3b0" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">上述Docker文件将于今年12月停止工作，因为GitHub repo的LetsEncrypt certbot克隆将不再在几个Linux发行版上运行，他们建议使用官方的LetsEncrypt Docker映像<a class="ae kl" href="https://hub.docker.com/r/certbot/certbot" rel="noopener ugc nofollow" target="_blank"> certbot/certbot </a>，该Docker映像基于Alpine Linux，然后使用Oracle OCI客户端获得一个扩展映像，我根据这篇博文“<a class="ae kl" href="https://blogs.oracle.com/developers/get-going-quickly-with-command-line-interface-for-oracle-cloud-infrastructure-using-docker-container" rel="noopener ugc nofollow" target="_blank">的想法创建了一个新的Oracle云基础架构命令行界面，使用Docker容器</a>，快速入门<a class="ae kl" href="https://blogs.oracle.com/author/lucas-jellema" rel="noopener ugc nofollow" target="_blank"> Lucas Jellema </a>。更新后的<a class="ae kl" href="https://gist.github.com/marcelo-ochoa/fcfc8dfdc2d920019936cb7974e64509" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>看起来像:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="16e0" class="mv lm iq mr b gy mw mx l my mz">$ cat certbot/requirements.txt <br/>oci<br/>oci-cli<br/>$ docker build --build-arg VERSION=v1.10.1 -t "certbot-oci:v1.10.1" ./certbot</span></pre><p id="8e08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://gist.github.com/marcelo-ochoa/f126232e46c075c6ecbc4ea5ee34f060" rel="noopener ugc nofollow" target="_blank"> create-lb-cert.sh </a>类似:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="43ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是<a class="ae kl" href="https://gist.github.com/marcelo-ochoa/06c0cfb57681977296b2f4fc8ec7c47d" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml </a>通过使用宏和新的CertBot功能变得更加紧凑:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="fcac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些评论:</p><ul class=""><li id="5658" class="no np iq jp b jq jr ju jv jy nq kc nr kg ns kk nt nu nv nw bi translated">certbot服务仅定义用于调试目的或首次手动创建我们的证书。</li><li id="c4f7" class="no np iq jp b jq nx ju ny jy nz kc oa kg ob kk nt nu nv nw bi translated">如上所述，每月将使用crontab调用续订服务</li><li id="4e00" class="no np iq jp b jq nx ju ny jy nz kc oa kg ob kk nt nu nv nw bi translated">certbot可以为多个域创建一个证书，在这个例子中，我使用dev-oci.mydomain.com作为主域，registry.mydomain.com作为备用域，bot DNS条目必须指向我们的负载平衡器公共IP。</li><li id="02be" class="no np iq jp b jq nx ju ny jy nz kc oa kg ob kk nt nu nv nw bi translated">使用<a class="ae kl" href="https://hub.docker.com/repository/docker/mochoa/s3fs-volume-plugin" rel="noopener ugc nofollow" target="_blank"> S3卷驱动程序插件</a>将证书存储在Oracle云对象存储中</li></ul><p id="dbba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们要测试上述证书，使用Traefik作为入站流量控制器的示例注册表堆栈如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d61b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，registry.mydomain.com只映射路径前缀/v2/。</p><p id="9bd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注册表UI前端看起来像:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oc"><img src="../Images/f586a340a801a50132ff4fdbbf80ecf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KbYa0mqkx9gcyy0ew-XeSA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">注册表前端接口</figcaption></figure><p id="7261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试Docker注册表+ Traefik</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="6c71" class="mv lm iq mr b gy mw mx l my mz">[root@node2 letsencrypt]# docker pull hello-world:latest<br/>Trying to pull repository docker.io/library/hello-world ... <br/>latest: Pulling from docker.io/library/hello-world<br/>0e03bdcc26d7: Pull complete <br/>Digest: sha256:1a523af650137b8accdaed439c17d684df61ee4d74feac151b5b337bd29e7eec<br/>Status: Downloaded newer image for hello-world:latest<br/>hello-world:latest<br/>[root@node2 letsencrypt]# docker tag hello-world:latest <strong class="mr ir"><em class="ld">registry.mydomain.com/hello-world:latest</em></strong><br/>[root@node2 letsencrypt]# docker push <strong class="mr ir"><em class="ld">registry.mydomain.com/hello-world:latest</em></strong><br/>The push refers to repository [<strong class="mr ir"><em class="ld">registry.mydomain.com/hello-world</em></strong>]<br/>......<br/>[root@node2 letsencrypt]# <strong class="mr ir"><em class="ld">docker rmi registry.mydomain.com/hello-world:latest hello-world:latest</em></strong><br/>Untagged: registry.mydomain.com/hello-world:latest<br/>....<br/>Deleted: sha256:9c27e219663c25e0f28493790cc0b88bc973ba3b1686355f221c38a36978ac63<br/>[root@node2 letsencrypt]# docker run --rm <strong class="mr ir"><em class="ld">registry.mydomain.com/hello-world:latest</em></strong><br/>Unable to find image '<strong class="mr ir"><em class="ld">registry.mydomain.com/hello-world:latest</em></strong>' locally<br/>Trying to pull repository <strong class="mr ir"><em class="ld">registry.mydomain.com/hello-world</em></strong> ... <br/>latest: Pulling from <strong class="mr ir"><em class="ld">registry.mydomain.com/hello-world</em></strong><br/>0e03bdcc26d7: Pull complete <br/>Digest: sha256:90659bf80b44ce6be8234e6ff90a1ac34acbeb826903b02cfa0da11c82cbc042<br/>Status: Downloaded newer image for <strong class="mr ir"><em class="ld">registry.mydomain.com/hello-world:latest</em></strong></span><span id="d3ee" class="mv lm iq mr b gy nk mx l my mz">Hello from Docker!<br/>This message shows that your installation appears to be working correctly.</span><span id="a4ce" class="mv lm iq mr b gy nk mx l my mz">To generate this message, Docker took the following steps:<br/> 1. The Docker client contacted the Docker daemon.<br/> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.<br/>    (amd64)<br/> 3. The Docker daemon created a new container from that image which runs the<br/>    executable that produces the output you are currently reading.<br/> 4. The Docker daemon streamed that output to the Docker client, which sent it<br/>    to your terminal.</span><span id="2a8a" class="mv lm iq mr b gy nk mx l my mz">To try something more ambitious, you can run an Ubuntu container with:<br/> $ docker run -it ubuntu bash</span><span id="1404" class="mv lm iq mr b gy nk mx l my mz">Share images, automate workflows, and more with a free Docker ID:<br/> <a class="ae kl" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/</a></span><span id="d9b8" class="mv lm iq mr b gy nk mx l my mz">For more examples and ideas, visit:<br/> <a class="ae kl" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/get-started/</a></span></pre><p id="d64a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切又正常了！！！</p></div></div>    
</body>
</html>