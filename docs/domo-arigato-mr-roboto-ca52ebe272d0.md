# 你好，机器人先生

> 原文：<https://itnext.io/domo-arigato-mr-roboto-ca52ebe272d0?source=collection_archive---------7----------------------->

## 或者当物体变成自动机器时

*(本博客由 https://creativecommons.org/licenses/by/4.0/*[授权，](https://creativecommons.org/licenses/by/4.0/)*所有代码由 https://www.apache.org/licenses/LICENSE-2.0*[](https://www.apache.org/licenses/LICENSE-2.0)**授权)**

> *在基于[类的](https://en.wikipedia.org/wiki/Class-based_programming)和面向[对象的](https://en.wikipedia.org/wiki/Object-oriented_programming)编程[范例](https://en.wikipedia.org/wiki/Programming_paradigm)中，*对象*指的是[类](https://en.wikipedia.org/wiki/Class_(computer_science))的一个特定[实例](https://en.wikipedia.org/wiki/Instance_(computer_science))，这里的对象可以是变量、函数和数据结构的组合— [维基百科](https://en.wikipedia.org/wiki/Object_(computer_science))*

*如果你和我一样，从第一次上计算机科学课或工作开始，你就接受了“面向对象”编程的理想，这是无可非议的，是革新软件工程的新方法。此外，如果你已经做了足够长的时间，你可能已经开始怀疑这是否是真的，以及所有这些抽象类和多态结构是否真的实现了它们的承诺。*

*像迷你图灵机一样，这些“对象”读取源源不断的“方法调用”,操纵分段的内部状态。一个使用面向对象设计的程序变成了无数小机器的组合，原则上也实现了一个大机器来解决给定的问题。像侏儒的论点一样，这种设计试图通过将问题投射到初始结构的无数复制品中来避免状态和可计算性的问题。不幸的是，这并没有神奇地解决可计算性问题，一旦引入线程和高规模，往往会导致灾难。*

## *线程对象的问题是*

## *该系统*

*抛开可计算性的问题(我不是艾伦·图灵)，让我们假设我们有一个可计算的问题。为了便于讨论，我们假设对通过各种传感器获得的不断变化的天气条件做出反应。我也不是气象学家，考虑到它们是不同的，它们提供的具体硬件和数据在规模和内容上有很大不同。*

*   *传感器 A:呈现以 1/ms 的速率变化的连续变化的数据原子，它是单个浮点数。不会发生缓冲，任何丢失的数据都将永远丢失。*
*   *传感器 B:当发出请求时，编译并返回一个大的(~MB)数据结构(想象一幅图片),并在运行时由传感器自己确定的可变时间量后返回数据(想象压缩/etc 根据数据本身变化很大)*
*   *传感器 C:根据条件产生可变的数据流，其中包含未被缓冲的小数据包。“读取”条件是由 1 位“信号”寄存器确定的中断，软件有一个设定的时间量来“读取”数据(约 1us)。未读数据将永远丢失。*

*该系统旨在提供由这三种传感器类型的数据组成的多种分析。对于给定的安装，每个传感器可以有任意有限的数量。因为传感器独立运行，并且数据只是以各种方式“读取”，所以没有理由说这不是一个可计算的问题(当然，这是读者的一个练习，但是没有反馈，所以不应该存在停顿问题)。*

## *初始设计*

*精明的软件工程师会立即发现设计这样一个系统的问题。为了适应这种使用情形，还有一些额外的要求:*

*   *传感器 A 和 C 不存储旧数据，所以这是程序的责任。如果数据丢失，呈现给用户的分析可能会有缺陷。*
*   *传感器 B 仅在被请求时提供条件的“快照”。这些快照的最佳频率要么由软件本身决定，要么由用户决定(最好是前者)。*
*   *传感器 C 的可变/中断驱动特性使得传感器 A 和 B 的调度变得困难。即使使用单调速率的实时调度程序，也可能出现传感器 A 或传感器 C 数据丢失的情况(尤其是当许多传感器 C 独立触发时)。*

*我们所面临的是一个理论上简单但实际上相当困难的问题。尽管如此，必须支付抵押贷款，所以我们试图解决它。*

*我们提出以下对象结构:*

*   *一个*用户交互* (UI)对象，向用户提供某种 API/接口来请求分析。*
*   *一个*配置*对象，管理所有传感器的设置和用户可配置的信息。*
*   **传感器*抽象对象，公开了传感器的通用接口(配置、读取等)和“传感器”的 3 个实现。*
*   *一个 *persistence* 抽象对象，提供了一种从某种持久存储(磁盘、数据库等)中存储/检索信息的方法，以及这个抽象类的实现。*
*   *一个 *analytics* 抽象对象，允许用户通过 *UI* 和一组实现(可能随着产品的成熟而增长)来确定长期运行的数据处理。*

*不用画 UML，你可以想象所有这些对象之间有关系。每个对象至少从*持久性*中读取， *UI* 主要与*配置*交互，*传感器*必须由*配置*管理(可能通过**另一个**对象独立管理)。如果不利用线程，至少，这个系统在高传感器或用户负载下运行的希望很小。*

## *同步蓝调*

*我们已经推测出单线程的执行是行不通的，所以我们开始将问题分解成线程。 *UI* 有助于配置必须通过重新配置传感器来响应 *UI* ,因此它在一个线程中并表现为单例。持久化必须管理一个 IO 资源，所以它是由一个线程管理的，就像一个单体一样。*传感器*每一个都在不同的时间表上运行，并且也必须是线程，有些像传感器 B 线程可能会消耗大量有限的系统资源，如内存。*配置*，本质上也是一个单例，将需要被 *UI* 访问，但也直接与*传感器*和*持久性*交互。最后， *UI* 最多会创建短暂的*分析*对象，这些对象会给*持久性*带来负载。*

*我们没有写一行代码就实现了意大利面条式的代码。*

*   *3 单例必须同步。*
*   *无数个*传感器*线程不断地与至少一个单线态(*持久性*)交互，同时依赖于另一个(*配置*)，后者本身也与*持久性*交互。(我们有了第一个周期)。*
*   *用户可以在任何时候通过启动*分析*来中断*传感器*的稳定状态行为，这些分析竞争同一个*持久*资源(以及整个系统资源),导致在持久暂时数据中错过最后期限。*

## *神秘的婴儿*

*那么，当架构师/CTO 必须实现这样的系统时，他们应该做些什么呢？客户认为问题相对简单，可以解决，投资者也是如此(理所当然)。所以我们做好程序员在学校被告知要做的事情:我们分而治之。OO 似乎是专门为在 1 个月内孕育婴儿的方法而制造的:*

> *“如果一个女人需要 9 个月来孕育一个孩子，那么如果我们有 9 个女人来解决这个问题，我们可以在 1 个月内完成”——每个项目经理都这样说*

*虽然软件工程领域没有足够的女性确实是一个大问题，但这不是这里的问题。即使加入了近 50%的人类未开发的天才，这种将系统分成许多部分的方法在实践中也行不通。虽然许多工程师可以独立工作，但在某种程度上，项目中增加的工程师越多，就必须保持更多的沟通渠道。就像设计本身一样，在系统中引入这些人会产生交互和关键通信的组合爆炸。我们的面向对象设计工具开始走下坡路。*

## *抽象类的问题是*

*虽然有许多问题需要探讨，但让我们把重点放在传感器上。架构师已经决定了传感器的抽象定义，并将其发布给了同时负责 *UI* 和*配置*的团队。这些团队已经根据这个设计工作了几个星期。*

*同时，这三种传感器差异很大，因此围绕理解和实现这三种特定的传感器类别成立了三个较小的团队。随着开发的开始，传感器 C 组出现了一个问题:传感器的接口不包含对行为的“写”侧进行优先排序的方法。测试传感器一直以惊人的速度产生中断，而软件已经跟不上了。该团队已经确定等待*持久性*的备份是罪魁祸首，他们需要一种方法来与系统的其他实时性较低的部分进行通信，以避免使用*持久性*(例如*配置*管理)。抽象的“传感器”接口不包括这一点，它必须被增强。*

*该团队与架构师、持久性和配置管理团队合作，并扩展接口。现在，架构师必须与传感器 A 和传感器 B 团队沟通，至少实现新功能的存根版本，以便他们的代码可以编译。本质上只有一个团队关注的事情已经膨胀成跨团队的努力，并且扰乱了整个开发。*

*随着项目在管理和“人”方面的进展，这种类型的同步瓶颈会不断出现，但是随着产品的成熟，这个问题也会在程序本身的运行时出现。与单例的每个同步交互导致与托管 IO 资源有关系的每个组件都与同样交互的组件相关。*

*故事的结尾:这个项目变成了一个难以理解的烂摊子，几乎无法出门。手工测试人员不断地敲打它，内部问题的解决方法发表在知识库(KB)文章中。少数客户变得依赖该产品，但增长速度下降，不断增加的工作量被规模不断缩小、濒临枯竭的工程团队所利用。*鳍**

## *这个问题需要更多的机器人*

> *[自动机:一种机器或控制机制，设计用于自动遵循预定的操作顺序或响应编码指令](https://www.merriam-webster.com/dictionary/automaton)*

*为了组合事物，让我们扩展“对象”的定义，以包括一个新的标准:*

***在这个新的范例中，“自动机”是一个*独立运行*的类的实例，其中自动机可以是变量、*信号*和数据结构的组合。***

*基本上，这是一个对象，它以某种方式“生活”在程序的主执行之外，但不是通过函数(但它们可以抽象为**看起来**像函数)而是通过信号进行交互。自动机可以接收信号，也可以将信号发送给其他自动机或发送回执行的主线程。*

*“面向自动机”设计的最简单的例子(这里我发明了一些术语——事实上许多“事件驱动架构”都有这些特性)是使用 Actor 模式。这是一长串博客文章中的一篇，所以希望你现在至少已经阅读了其中的一些(TBD 的链接，一旦它们被发布就链接到 EEK，legal)。按照经典的定义，演员不是物体，而是机器人。它们在启动时接收变量，拥有本质上线程安全的私有数据结构(堆或栈)，并且它们都通过线程安全队列(golang、ZMQ、可伸缩协议等中的通道)发送和接收信号。用 AO 设计重新设计我们的气象站，我们得到以下结果:*

*   *一个*配置的*自动机由执行的*主*线程启动。它接收配置信息，并启动/停止/向许多“*传感器*”自动机发送信号。*
*   *向用户呈现 API/界面的 *UI* 自动机，并向*配置*和*分析*自动机发送信号。*
*   *由*配置*自动机根据配置值启动的传感器*自动机*的集合，它们接收来自配置的信号并将包含传感器数据的信号发送到*持续*自动机。同样，它们的“寿命”由*配置*管理，它可以根据需要取消和重建传感器自动机(通过谋杀进行简单的重新配置)。*
*   *一组*持久化*自动机，它们与由*配置*自动机启动的各种 IO(数据库、文件等)进行交互，并接收信号以持久化和检索数据。*
*   *一组*分析*自动机，这些自动机从 persistence 请求数据，并通过信号将分析后的数据返回给 *UI。**

*最初的面向对象结构被保留下来，但是运行时和项目管理结构从根本上是不同的。*

## *AO 和 OO 之间的运行时差异*

*您将看到的 AO 代码的第一个区别是，关注“线程”的代码和关注“行为”的代码是分开的。无论是使用内存屏障(如互斥体)来共享内存，还是使用通道来在线程间发送数据，特定实现的“工作”都不包括对同步的任何引用。*

*传感器必须简单地知道从传感器读取什么是必要的。无论是传感器 A 的有节奏的轮询循环(在计时器上获取数据并将数据发送到持久性)，还是传感器 C 的更复杂的中断服务例程，有关数据同步如何发生的细节都可能是其他代码所关心的。*

*关于如何最好地优先化数据并将数据传输到持久层的细节可以一般地编写，并且独立于各个传感器例程。为了进行测试，实现持久性通信的团队可以构建各种“模拟”传感器，其行为封装了所有传感器的“最坏情况”行为。同时，随着新传感器被添加到产品中，同步问题不再是加速实现的开发过程的一部分。各个实现的关注点是分离的，因此这些自动机之间的通信线路受到极大的限制。*

## *AO 和 OO 的项目管理差异*

*正如线程之间的通信通过在多个实现之间调整和更改功能接口的过程而得到简化一样，团队交互也得到了简化。协商仅仅以消息的内容为中心，而不是必须协商和设计系统中每个抽象组件的接口。消息可以被设计成向后兼容的(例如，使用诸如 protobuffers 之类的技术),并且当一个组件需要发送或接收附加信息时，该对象的其他消费者不需要改变。*

*在这个简单的 3 个传感器的例子中，这似乎不是一个大问题，但是想象一下一个有 1000 个不同传感器的系统？还是 100 万？当然，作为一个项目经理或首席技术官，你希望你的简单气象站程序取得完全的市场优势，对吗？有了一个适当架构的系统，您的公司应该能够实现自动机来管理新的传感器，甚至新的分析，就像它们被想象出来一样快。用这种方法设计软件开启了这种可能性。*

# *结论*

*虽然这个例子中没有代码，但是前 3 篇文章概述了通过 Actor 模式在软件系统中利用最简单的自动机的方法。随着系统变得越来越复杂，参与者可以演变成路由器(接受和路由不同的数据类型，执行转换并传输回运行时确定的任何数量的其他自动机)，或者他们可以简化为转换器(本身不包含状态但执行纯数据转换的参与者，如 AWS Lambda 函数)。遵循面向自动机的设计确保了这些抽象保持了逻辑分离的属性，因此在运行时和开发时都是可伸缩的。*