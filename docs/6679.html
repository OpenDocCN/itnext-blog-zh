<html>
<head>
<title>React Context and Hooks: An excellent way to pass data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React上下文和钩子:传递数据的好方法</h1>
<blockquote>原文：<a href="https://itnext.io/react-context-and-hooks-an-excellent-way-to-pass-data-26c3f48b9bf5?source=collection_archive---------0-----------------------#2022-01-26">https://itnext.io/react-context-and-hooks-an-excellent-way-to-pass-data-26c3f48b9bf5?source=collection_archive---------0-----------------------#2022-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d8c9d49b7dcf48a272dc2518dd1e8312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wSa3Up0rzS7XLSlp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">劳塔罗·安德烈亚尼</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="b842" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是语境？</h1><p id="c5db" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">上下文基本上是一个JavaScript对象，可以有效地从一个父组件传递到几个子组件。Props也可以向组件传递值。但是，如果需要将一个值传递给组件树深处的子组件，使用props意味着该值也会传递给不需要它的组件。或者，如果一个值是几个组件所需要的，那么props会使它变得困难。</p><p id="53e5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这是一个很好的上下文用例。道具需要从一个组件传递到另一个组件。有了上下文，父组件提供值，需要它的子组件可以访问它。</p><h1 id="9688" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">用上下文和钩子传递值</h1><p id="4944" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们举一个常见的例子来说明上下文——主题。考虑以下用户界面:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/3d61c69b374d451b61bd7a987fc0cb53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18v3guVWDCgIz6mO2AFWgg.png"/></div></div></figure><p id="f4fd" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在这里，带有红色边框的是主要的<code class="fe mj mk ml mm b">App.js</code>组件。绿色边框的是一个叫做<code class="fe mj mk ml mm b">ThemeButton.js</code>的组件，蓝色边框的是<code class="fe mj mk ml mm b">ThemeWindow.js</code>组件。<code class="fe mj mk ml mm b">App</code>组件将另外两个作为它的子组件。点击<code class="fe mj mk ml mm b">ThemeButton</code>中的按钮将会在亮暗之间切换主题。主题的结果会在<code class="fe mj mk ml mm b">ThemeWindow</code>中体现出来。</p><p id="ea1b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们需要首先创建一个上下文，然后让<code class="fe mj mk ml mm b">App</code>组件<em class="mn">为其子组件</em>提供一个值。子组件将<em class="mn">使用</em>这个提供的值。我们来设置一下。</p><h1 id="8cd0" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">1.创建上下文</h1><p id="8809" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">可以在一个单独的文件中或者在<code class="fe mj mk ml mm b">App</code>组件本身中创建一个上下文，但是为它创建一个单独的文件通常更好。因为取决于你的应用程序，你可能需要不同特性的多个上下文。因此，拥有单独的文件是很有用的。</p><p id="e007" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">创建一个新文件来保存上下文并将其导出:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/e7e3ba27366f5a6490d11244bf0a8378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEVAQ4Za-YhVCXy4ZbAZzQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建上下文和主题对象</figcaption></figure><p id="31c3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在这个文件中，我们导出两样东西——一个包含主题值的对象和我们的上下文。<code class="fe mj mk ml mm b">createContext()</code>函数返回一个上下文对象。它接受一个类似于<code class="fe mj mk ml mm b">useState</code>钩子的初始值参数。在这种情况下，灯光主题对象是<code class="fe mj mk ml mm b">ThemeContext</code>的默认值。</p><h1 id="63ad" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">2.用提供者组件传递值</h1><p id="0dce" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">既然已经创建了上下文，那么让我们将其添加到<code class="fe mj mk ml mm b">App.js</code>中。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/15e5a0ba6b180dcad59595f8c7da8f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJJFPYXUl14sOhe6sM_ung.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">提供者组件是React在创建上下文对象时提供的东西</figcaption></figure><p id="21b2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">每个上下文对象(用<code class="fe mj mk ml mm b">React.createContext()</code>创建)都有一个<strong class="ld ir">提供者</strong>组件。这个提供者组件应该被包装在所有将要访问<code class="fe mj mk ml mm b">ThemeContext</code>的子组件周围。反过来，也有<strong class="ld ir">消费者</strong>的成分。如果你没有使用基于类的组件，你也可以使用<code class="fe mj mk ml mm b">useContext</code>钩子。</p><p id="26c4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">您一定想知道为什么<strong class="ld ir">亮</strong>对象被用作默认值，但是提供者组件已经传递了<strong class="ld ir">暗</strong>对象。首先，Provider组件中使用的<code class="fe mj mk ml mm b">value</code>属性是React可以识别的属性，因此您不能对该属性使用不同的名称。</p><p id="adb2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">通过<code class="fe mj mk ml mm b">value</code>道具传递的东西就是子组件消耗的东西。如果一个组件试图访问<code class="fe mj mk ml mm b">ThemeContext</code>，但是在上面的树中没有<strong class="ld ir">提供者</strong>组件，它将使用上下文对象的默认值(light主题)。</p><p id="bca9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">举个简单的例子，假设有第三个组件叫做<code class="fe mj mk ml mm b">ThemeFont.js</code>。但是第三个组件没有包含在提供者组件中</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/0671f0ab88113546a896d30f72043ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdUN3YOVsIBiMcoE2N-94g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ThemeFont组件不在Provider组件的范围内</figcaption></figure><p id="6fe4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">因为<code class="fe mj mk ml mm b">ThemeFont</code>没有被提供者组件包装，所以它不会接收新值。虽然它仍然可以访问<code class="fe mj mk ml mm b">ThemeContext</code>，但是它将接收默认值，也就是我们传递给<code class="fe mj mk ml mm b">createContext</code>的值light themes对象。</p><blockquote class="mq mr ms"><p id="f6c2" class="lb lc mn ld b le lz lg lh li ma lk ll mt mb lo lp mu mc ls lt mv md lw lx ly ij bi translated"><em class="iq">不将需要访问上下文的组件包装在提供者组件中，仍然可以访问上下文的默认值。</em></p></blockquote><p id="7e5a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">不过，你可能不会经常遇到这种情况。一个组件需要来自上下文的值，但是不能被包装在提供者组件中——这种情况很少见。</p><h1 id="f5da" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">3.在子组件中使用上下文</h1><p id="ada1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们使用React钩子来消费所提供的上下文值。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/4bec715a2984c6349dd352ffdd35258c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5z-grBfGCZ-QWlht75p7w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">与提供者组件类似，在创建上下文对象后，还有一个消费者组件可用。它可以用来代替useContext</figcaption></figure><p id="06b1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">运行此应用程序，您会得到以下结果:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a2d5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe mj mk ml mm b">ThemeWindow</code>当然有一个黑暗的主题。但是，切换主题的按钮不起作用。下一篇文章将演示如何更新通过上下文传递的值。</p><h1 id="d4ba" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">一些资源链接</h1><ul class=""><li id="8668" class="my mz iq ld b le lf li lj lm na lq nb lu nc ly nd ne nf ng bi translated"><a class="ae kc" href="https://kentcdodds.com/blog/how-to-use-react-context-effectively" rel="noopener ugc nofollow" target="_blank">如何有效使用React语境</a>作者<a class="ae kc" href="https://twitter.com/kentcdodds" rel="noopener ugc nofollow" target="_blank">肯特·c·多兹</a></li><li id="fb46" class="my mz iq ld b le nh li ni lm nj lq nk lu nl ly nd ne nf ng bi translated"><a class="ae kc" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">反应上下文公文</a></li></ul></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="1251" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mn">原载于2022年1月14日</em> <a class="ae kc" href="https://niharraoteblog.netlify.app/intro-to-context" rel="noopener ugc nofollow" target="_blank"> <em class="mn">我的博客</em> </a> <em class="mn">。</em></p></div></div>    
</body>
</html>