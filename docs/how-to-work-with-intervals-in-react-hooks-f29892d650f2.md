# 如何在 React 挂钩中使用音程

> 原文：<https://itnext.io/how-to-work-with-intervals-in-react-hooks-f29892d650f2?source=collection_archive---------0----------------------->

![](img/b2cb35e64033ab57736f2bedda3ff558.png)

虽然大多数范例并不要求 React 开发人员了解太多关于底层发生的事情，但是使用区间会变得有点棘手。本文的目标是向您介绍在 react 中使用区间和状态的所有方法。

## 使用音程有什么复杂的？

React 中让区间变得有点棘手的是，传递给区间的回调函数将不可避免地关闭([还记得闭包吗？](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures))覆盖组件的当前状态。您的间隔将看到“旧”的状态，而不是你想要的方式工作。这经常让新的 React 开发人员感到困惑。

让我们看看一个计数器的简单实现，它使用`setInterval`每秒递增一个数字:

**此代码不起作用。**

```
export default function App() { const [count, setCount] = useState(0); useEffect(() => { setInterval(() => { setCount(count + 1); }, 1000)
    }, []); return ( <div className="App"> <h1>The current count is:</h1> <h2>{count}</h2> </div> );}
```

要理解为什么这段代码不起作用，您必须理解 React 如何处理状态。丹·阿布拉莫夫写了一篇很棒的(也很长的)指南来解释这一点。简而言之，每个渲染只访问自己的状态。让我们仔细看看在组件的前两次呈现期间发生了什么，以理解为什么这段代码不起作用:

**组件第一次渲染:**

1.  计数变量被设置为 0(初始状态)
2.  组件渲染绘制完成后，React 会执行`useEffect`钩子。`useEffect`挂钩将记录音程。注册的时间间隔可以访问计数(计数为 0)变量。
3.  1 秒钟后将调用回调。它会叫`setCount(0 + 1)`。这不会改变计数常数。相反，它将触发一个新的组件呈现，状态为`count=1`(这是一个全新的变量和组件实例)。

**组件第二次渲染:**

1.  计数变量设置为 1(由间隔触发)
2.  组件被渲染，浏览器为`count=1`绘制 UI
3.  该效果不会运行，因为空的依赖数组定义了钩子应该只在第一次渲染时运行
4.  1 秒钟后，回调(这段代码仍然存在于第一次渲染中)被再次调用，但是回调并没有神奇地移动到新的状态为`count=1`的渲染中。相反，回调只访问定义它的作用域的`count`值(React 只是 JavaScript，必须遵守所有的作用域规则)。回调还是会看到`count=0`，会再次调用`setCount(0 + 1)`。一个新的渲染将被触发，值为`count=1`。

> 使用 React 时，拥有正确的心理模型非常重要。你应该把每一个渲染看作一个有自己变量的盒子。如果你渲染一个组件两次，你会得到两个盒子。代码绝对有可能永远不会离开第一个盒子，一直运行到时间结束(这里的间隔就是这样)。

**计数器的值永远不会超过** `**count=1**` **。间隔回调将存在于第一次渲染中，并且只在增加到** `**setCount(0 + 1)**` **之前看到过** `**count=0**` **。**

# 解决国家问题

意识到这一点后，你可能会发现自己不知道该如何处理这类问题。通常，这个问题可以通过四种方式解决。所有四个解决方案都有有效的用例。一般来说，我觉得方案 4 最有用，其次是方案 3。

## 解决方案 1:描述状态变化

直接访问状态可能没有您想象的那么重要。`setCount()`接受一个回调函数，您可以在其中访问当前(未来)状态。你可以简单地描述你希望如何修改它。

**缺点**

*   仅适用于非常简单的用例

## 解决方案 2:携带 ref

引用是一种摆脱状态封装的方法。您可以使用引用来访问未来状态。通过改变`.current`你可以访问更新后的状态。下面是一个工作示例:

**缺点:**

*   你必须记住在每次渲染时更新引用，这样才能工作
*   不遵循 React 设计模式

## 解决方案 3:在每次渲染时重建效果

通过从`useEffect`返回一个函数，你注册了一个清理函数。清理功能在效果运行后运行。第二次渲染后，react 会清除第一次渲染的效果(以此类推……)。

在清理功能的帮助下，您可以在每次渲染时拆除并重建间隔。虽然这听起来很复杂，但实际上这是解决这个问题最常见的方法。使用清理功能意味着坚持 React 设计模式，通常被认为是良好的实践。

**优点:**

*   遵循 React 设计模式

**缺点:**

*   如果您的应用程序的多个部分调用`setCount`，它们将各自重新开始间隔。

## 解决方案 4:使用`dispatch`功能

另一种欺骗自己摆脱 React 处理状态的方法是使用`useReducer`钩子。调度函数的默认行为是访问组件的最新状态。调度将让您访问“未来”状态。

**优点:**

*   非常灵活的解决方案
*   遵循 React 设计模式

## 结论🤙🏽

我希望这篇文章能帮助你在 React 中使用间隔和超时时获得信心。如果这篇文章对你有帮助，请留下评论或鼓掌，让我知道。

*如果你有兴趣增加你在所有社交渠道的有机接触，请查看*[***https://gosquad . cc***](https://gosquad.cc)