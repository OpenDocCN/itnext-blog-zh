<html>
<head>
<title>NGRX — from the beginning, part II, Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NGRX —从头开始，第二部分，Redux</h1>
<blockquote>原文：<a href="https://itnext.io/ngrx-from-the-beginning-part-ii-redux-6305b481c55?source=collection_archive---------6-----------------------#2019-04-03">https://itnext.io/ngrx-from-the-beginning-part-ii-redux-6305b481c55?source=collection_archive---------6-----------------------#2019-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/69c244b0797325a33436a7592a9ead84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*acwMWOnSdMUqD8e7.jpg"/></div></div></figure><p id="e404" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://twitter.com/chris_noring" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，很乐意接受您对主题或改进的建议/Chris</p><blockquote class="kx ky kz"><p id="4066" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq"> Redux是一个发布-订阅实现，但是通过添加一些新的概念，比如不变性和只有某些工件能够改变状态的思想，给模式添加了一些新的工件</em></p></blockquote><p id="1f0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是系列文章的一部分:</p><ul class=""><li id="ab69" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/ngrx-from-the-beginning-part-i-a76c3c690ac7"> NGRX —从头开始</a>，第一部分，发布订阅，</li><li id="cb6f" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">NGRX —从头开始，第二部分，<strong class="ka ir">我们到了</strong></li><li id="e542" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae kw" href="https://medium.com/@noringc/ngrx-from-the-beginning-part-iii-ngrx-store-d094ac72e1fa" rel="noopener"> NGRX —从头开始，第三部分</a>，NGRX商店，第一部分覆盖商店</li><li id="ee76" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">NGRX —从头开始，第四部分，NGRX存储，<em class="la">进行中</em></li><li id="c5f7" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">NGRX —从头开始，第四部分，NGRX效果，<em class="la">进行中</em></li><li id="04d0" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">NGRX —从头开始，第五部分，NGRX实体，<em class="la">进行中</em></li></ul><p id="94de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，我们在上一部分已经学习了发布-订阅模式，因此我们已经了解了它的底层模式以及何时使用它。我们甚至查看了一个实现。现在我们来看一个名为Redux的发布-订阅模式的具体版本</p><p id="570c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将涵盖以下内容:</p><ul class=""><li id="c387" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir">基本概念</strong>，Redux由一些基本概念组成，让我们列出它们是什么以及它们的职责</li><li id="70f2" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">动作</strong>，让我们深入了解什么是动作，何时使用以及如何创建动作</li><li id="f4b2" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">还原物，还原物是保护和改变状态的功能，它们也导致相同状态的改变，但以有序和纯粹的方式</li><li id="5805" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">当我们想知道状态是什么或者想改变它时，商店是我们主要的互动对象</li><li id="4729" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">幼稚的实现</strong>，让我们看看如何实现Redux，这样我们才能真正理解发生了什么</li></ul><h1 id="3727" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">为什么Redux</h1><p id="79f2" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在第一部分中，我们研究了发布-订阅模式。我们希望理解，如果您需要更改数据并向许多听众传播这种更改，这是一种非常好的模式。所以为什么是Redux，为什么我们需要这个特定版本的Pub-Sub。嗯，Redux在一些事情上固执己见:</p><ul class=""><li id="4460" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">真理应该只有一个来源，一个你所有状态都存在的地方，而不是很多</li><li id="c76e" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">变化应该以不可变的方式进行，这被认为是更安全和可预测的</li><li id="2a3c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">改变只能在减速器的帮助下进行</li></ul><p id="063d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以Redux增加的是一系列问题的答案。你会问，这些是什么问题？</p><p id="44ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下内容:</p><ul class=""><li id="0097" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir">对当前状态的分歧</strong>，当你的应用程序增长时，它开始出现管理应用程序状态的问题。许多组件想要相同的状态，而突然一个或多个组件改变了状态，并且由于某种原因，一个或多个组件没有完全意识到已经发生了改变，因此它们在状态应该是什么上存在分歧</li><li id="9e93" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">谁做了什么</strong>，您不仅遇到了组件不同意状态应该是什么的问题，而且您已经忘记了谁做了什么，是什么导致了特定状态以那种方式结束？您遇到这个问题的原因很可能是因为您让任何组件直接改变状态，没有安全措施以有序的方式执行状态，确保更新相关方</li></ul><h1 id="bbc0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">基本概念</h1><p id="d7e0" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好了，所以有一些概念我们需要了解，才能正确掌握Redux。我们已经在前一节提到了它们，但让我们再讨论一下:</p><ul class=""><li id="2bb5" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir">动作</strong>，所以这个动作是我们发出的一个信息，它是一个意图，我们想要的东西，比如把一个产品添加到列表中。一个动作有一个类型，它是一个代表我们意图的动词，它可以选择有一个有效载荷，我们需要携带一个变化或用于查询的数据</li><li id="c8f7" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">减速器</strong>，一个减速器是一个功能。缩减器的目的是获取一个现有状态，并对该现有状态应用一个动作。Reducers以不可变的方式实现这一点，这意味着我们不会改变状态，而是基于旧的状态和动作计算新的状态</li><li id="776e" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">商店</strong>，商店就像一个盛状态的容器。该存储就像Redux的API，当您想要读取状态、更改状态或者订阅状态更改时，您可以与之交流</li></ul><p id="6a59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在我们对核心概念和它们的作用有了更多的了解。让我们通过代码示例更详细地了解每个概念，因为如果我们看到一些代码，我们会更好地理解，对吗？；)</p><h1 id="2785" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">行动</h1><p id="2e43" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">行动是我们表达我们想做什么的方式。一个动作有一个强制属性<code class="fe mv mw mx my b">type</code>和一个可选属性<code class="fe mv mw mx my b">payload</code>。动作是一个对象，因此动作示例如下所示:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="0bc5" class="nh lt iq my b gy ni nj l nk nl">const action = { type: 'INCREMENT' };</span></pre><p id="ab77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面是一个更简单的动作，没有有效载荷，因为不需要，意图或类型清楚地说明了需要做什么，加1。然而，如果你想用这样的动作把它增加2，你需要用一个<code class="fe mv mw mx my b">payload</code>来描述，就像这样:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="4318" class="nh lt iq my b gy ni nj l nk nl">const action = { type: 'INCREMENT', payload: 2 };</span></pre><p id="23f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个更常见的带有有效负载的操作是添加一个产品，它看起来像这样:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="a8f6" class="nh lt iq my b gy ni nj l nk nl">const action = { <br/>  type: '[Product] add', <br/>  payload: { id: 1, name: 'movie' } <br/>};</span></pre><p id="5490" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们对动作有了更好的理解，但是我们如何将它们应用到现有的状态呢？为此，我们需要讨论减速器。</p><h1 id="146a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">还原剂</h1><p id="2ff7" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">Reducers是以不可变的方式执行更改的简单函数。他们不是改变状态，而是计算状态。好吧，听起来很奇怪，让我们先看一个变异的例子，并解释为什么这是不好的:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="2e18" class="nh lt iq my b gy ni nj l nk nl">let value = 0; </span><span id="d710" class="nh lt iq my b gy nm nj l nk nl">function add(val, val2) { <br/>  value += val + val2; <br/>} </span><span id="de94" class="nh lt iq my b gy nm nj l nk nl">add(1,2); <br/>add(1,2);</span></pre><p id="5571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面我们可以看到，当我们用相同的输入参数运行两次<code class="fe mv mw mx my b">add()</code>函数时，我们得到了不同的结果。在这样一个包含的小例子中，我们很容易看出为什么，我们声明了变量<code class="fe mv mw mx my b">value</code>，我们还可以看到<code class="fe mv mw mx my b">add()</code>函数的实现使用值作为其计算的一部分。在更现实的场景中，这可能不太容易检测到，因为函数可能有很多很多行长，并且包含很多复杂的内容。这很糟糕，因为它是不可预测的，我们的意思是我们不容易看到函数的结果会是什么，在不知道变量<code class="fe mv mw mx my b">value</code>的值的情况下给出两个参数。<code class="fe mv mw mx my b">add()</code>方法的一个更可预测的版本是:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="9ff4" class="nh lt iq my b gy ni nj l nk nl">function add(lhs, rhs) { <br/>  return lhs + rhs; <br/>} </span><span id="b791" class="nh lt iq my b gy nm nj l nk nl">add(1,2); <br/>add(1,2);</span></pre><p id="bd2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面的代码执行中我们可以看到，给定相同的输入参数值，我们会得到相同的结果，这是可以预测的。</p><p id="68b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在记住这个原则，让我们把它应用到一个工作是处理链表操作的reducer上。让我们看一些代码:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="ca35" class="nh lt iq my b gy ni nj l nk nl">function reducer(state = [], action) { <br/>  switch(action.type) { <br/>    case '[Product] add': <br/>      return [...state, action.payload] <br/>    default: <br/>      return state; <br/>  } <br/>}</span></pre><p id="532a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看上面的代码，我们看到我们没有调用list上的<code class="fe mv mw mx my b">push()</code>方法，而是使用了一个spread操作符，并基于我们现有的list <code class="fe mv mw mx my b">state</code>和存储在<code class="fe mv mw mx my b">action.payload</code>上的新条目构建了一个全新的list。让我们调用这个<code class="fe mv mw mx my b">reducer()</code>函数:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="a2a3" class="nh lt iq my b gy ni nj l nk nl">let state = reducer( [], { <br/>  type: '[Product] add', <br/>  payload: { name: 'movie'} <br/>}); </span><span id="6c2f" class="nh lt iq my b gy nm nj l nk nl">state = reducer( state, { <br/>  type: '[Product] add', <br/>  payload: { name: 'book'} <br/>});</span></pre><p id="4103" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面的调用中我们可以看到，如果我们将<code class="fe mv mw mx my b">reducer()</code>函数调用的结果赋给变量<code class="fe mv mw mx my b">state</code>，我们就能够继续向列表中添加条目。此外，我们还注意到<code class="fe mv mw mx my b">reducer()</code>如何通过计算向列表添加任何内容:</p><blockquote class="kx ky kz"><p id="d0fd" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">旧状态+动作=新状态</em></p></blockquote><p id="cb21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们如何改变事物的React和不可变函数中的一个重要原则，所以记住上面的陈述。</p><h1 id="4155" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">商店</h1><p id="4a4a" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好了，到目前为止我们已经理解了，动作是当我们想要读取数据或改变数据时，在状态下发送的消息。那么我们的国家在哪里？它存放在一家商店里。好吧，那我们怎么和商店沟通？我们通过使用方法<code class="fe mv mw mx my b">dispatch()</code>向它发送消息来实现这一点。让我们试着开始描绘一个商店实施方案:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="2ac2" class="nh lt iq my b gy ni nj l nk nl">class Store { <br/>  dispatch(action) {} <br/>}</span></pre><p id="1d49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，这不算多，让我们看看我们是否可以改善这一点。我们知道些什么？我们知道，任何状态变化都应该发生，因为我们向<code class="fe mv mw mx my b">dispatch()</code>方法发送了一个动作，但是我们也知道，只有当我们让动作通过一个缩减器时，才允许发生任何状态变化。这意味着<code class="fe mv mw mx my b">dispatch()</code>应该调用一个reducer并传递动作。鉴于我们在上一节中如何使用减速器，我们现在对如何做到这一点有了更多的想法。让我们使用我们已经创建的reducer函数:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="d312" class="nh lt iq my b gy ni nj l nk nl"><strong class="my ir">function reducer(state = [], action) { <br/>  switch(action.type) { <br/>    case '[Product] add': <br/>      return [...state, action.payload] <br/>    default: <br/>      return state; <br/>  } <br/>}</strong> </span><span id="be2c" class="nh lt iq my b gy nm nj l nk nl">class Store { <br/>  constructor() { <br/>    this.state = []; <br/>  } </span><span id="5fa1" class="nh lt iq my b gy nm nj l nk nl">  <strong class="my ir">dispatch(action) { <br/>    this.state = reducer(this.state, action); <br/>  } </strong><br/>}</span></pre><p id="cb89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，从上面的代码中我们可以看到我们在构造函数中实例化了我们的<code class="fe mv mw mx my b">state</code>，我们还可以看到我们在<code class="fe mv mw mx my b">dispatch()</code>方法中调用了<code class="fe mv mw mx my b">reducer()</code>函数，我们这样做是为了计算一个新的状态。好吧，让我们来看看这个:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="12ea" class="nh lt iq my b gy ni nj l nk nl">const store = new Store();<br/> <br/>store.dispatch({ type: '[Product] add', { name: 'movie' } }); <br/>// store.state = [{ name: 'movie' }]</span></pre><h1 id="ae72" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">支持更多的消息类型</h1><p id="0f1a" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好吧，这很好，但是如果我们希望我们的国家支持比列表更多的东西呢？让我们思考一下，我们希望我们的状态在应用程序中是什么样子的？我们很可能希望它包含一堆不同的属性，每个属性都有自己的值，所以将所有这些属性放在一个对象中是有意义的，就像这样:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="e01f" class="nh lt iq my b gy ni nj l nk nl">{ <br/>  products: [], <br/>  language: 'en' <br/>}</span></pre><p id="e354" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们目前的<code class="fe mv mw mx my b">Store</code>实现显然不支持这个，所以我们需要稍微修改一下，让我们改成这样:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="e913" class="nh lt iq my b gy ni nj l nk nl">function reducer(state = [], action) { <br/>  switch(action.type) { <br/>    case '[Product] add': <br/>      return [...state, action.payload] <br/>    default: <br/>      return state; <br/>  } <br/>} </span><span id="578b" class="nh lt iq my b gy nm nj l nk nl">class Store { <br/>  constructor() { <br/>    <strong class="my ir">this.state = { <br/>      products: [] <br/>    };</strong> <br/>  } </span><span id="3a96" class="nh lt iq my b gy nm nj l nk nl">  <strong class="my ir">dispatch(action) { <br/>    this.state = { <br/>      products : reducer(this.state.products, action) <br/>    }; <br/>  } </strong><br/>}</span></pre><p id="ec1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">意识到我们希望将状态存储为对象，我们在构造函数中做了必要的修改:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="b236" class="nh lt iq my b gy ni nj l nk nl">this.state = { <br/>  products: [] <br/>}</span></pre><p id="3522" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也意味着我们的<code class="fe mv mw mx my b">dispatch()</code>方法需要改为:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="b14f" class="nh lt iq my b gy ni nj l nk nl">dispatch(action) { <br/>  this.state = { <br/>    products : reducer(this.state.products, action) <br/>  }; <br/>}</span></pre><p id="2e9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得我们的减速器只能应用于部分状态，即<code class="fe mv mw mx my b">this.state.products</code>。</p><h1 id="9f02" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">再添加一个状态属性</h1><p id="d361" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在这一点上，我们意识到我们需要支持添加属性<code class="fe mv mw mx my b">language</code>，所以我们将语言添加到构造函数的初始状态，如下所示:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="1be7" class="nh lt iq my b gy ni nj l nk nl">this.state = { <br/>  products: [], <br/>  <strong class="my ir">language</strong>: '' <br/>};</span></pre><p id="42dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，那么我们对<code class="fe mv mw mx my b">reducer()</code>函数做些什么呢？在这一点上，我们意识到我们缺少一个应该专注于设置语言的缩减器，所以让我们开始画草图:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="89d0" class="nh lt iq my b gy ni nj l nk nl">function languageReducer(state = '', action) { <br/>  switch(action.type) { <br/>    case '[Language] load': <br/>      return action.payload; <br/>    default: <br/>      return state; <br/>  } <br/>}</span><span id="e433" class="nh lt iq my b gy nm nj l nk nl">let state = languageReducer({ <br/>  type: '[Language] load', <br/>  payload: 'en' <br/>});</span></pre><p id="7f84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了一个可以设置语言的缩减器。让我们回到我们的商店实现，对<code class="fe mv mw mx my b">dispatch()</code>方法进行必要的修改:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="8f5a" class="nh lt iq my b gy ni nj l nk nl">dispatch(action) { <br/>  this.state = { <br/>    products : reducer(this.state.products, action), <br/>    <strong class="my ir">language: languageReducer(this.state.language, action) </strong><br/>  }; <br/>}</span></pre><p id="3a7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们也将<code class="fe mv mw mx my b">reducer()</code>重命名为<code class="fe mv mw mx my b">productsReducer()</code>，我们的完整实现应该是这样的:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="5807" class="nh lt iq my b gy ni nj l nk nl">function productsReducer(state = [], action) { <br/>  switch(action.type) { <br/>    case '[Product] add': <br/>      return [...state, action.payload] <br/>    default: <br/>      return state; <br/>  } <br/>} </span><span id="171a" class="nh lt iq my b gy nm nj l nk nl">function languageReducer(state = '', action) { <br/>  switch(action.type) { <br/>    case '[Language] load': <br/>      return action.payload; <br/>    default: <br/>      return state; <br/>  } <br/>} </span><span id="21bc" class="nh lt iq my b gy nm nj l nk nl">class Store { <br/>  constructor() { <br/>    this.state = { <br/>      products: [] <br/>    }; <br/>   } </span><span id="209a" class="nh lt iq my b gy nm nj l nk nl">   dispatch(action) { <br/>     return { <br/>       products : productsReducer(this.state.products, action),<br/>       language: languageReducer(this.state.language, action) <br/>     }; <br/>   } <br/>}</span></pre><p id="57b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的实现完成之前，我们还有一个重要的方面。我们需要支持的主要内容是，能够传达变化:</p><ol class=""><li id="f6cb" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv nn lk ll lm bi translated"><strong class="ka ir">发送</strong>消息，使状态改变</li><li id="992a" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv nn lk ll lm bi translated"><strong class="ka ir">建立/撤销</strong>订阅</li><li id="d80e" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv nn lk ll lm bi translated">向听众传达一个变化</li></ol><p id="7618" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经完成了第一个，所以让我们支持第二个。让我们实现一个<code class="fe mv mw mx my b">subscribe()</code>和<code class="fe mv mw mx my b">unsubscribe</code>方法:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="76d7" class="nh lt iq my b gy ni nj l nk nl">subscribe(listener) { <br/>  this.listeners.push(listener); <br/>} </span><span id="ab8d" class="nh lt iq my b gy nm nj l nk nl">unsubscribe(listener) { <br/>  this.listeners = this.listeners.filter(l =&gt; l !== listener); <br/>}</span></pre><p id="0700" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2)和3)非常紧密地联系在一起，所以让我们重温一下我们的<code class="fe mv mw mx my b">dispatch()</code>方法，让我们对它做一个改变，使它现在看起来像这样:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="1968" class="nh lt iq my b gy ni nj l nk nl">dispatch(action) { <br/>  this.state = { <br/>    products : reducer(this.state.products, action), <br/>    language: languageReducer(this.state.language, action) <br/>  }; <br/>  this.listeners.forEach(l =&gt; l()); <br/>}</span></pre><h1 id="d655" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">状态切片</h1><p id="4979" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">这不是必须的，但肯定是好的。目前，我们的状态由整个对象组成，但是让我们考虑一下如何使用它。使用它的组件很可能只对状态的一部分感兴趣，那么我们该怎么做呢？解决这个问题的一个方法是添加一个<code class="fe mv mw mx my b">select()</code>方法，它能够选择它想要的状态部分。它可能看起来像这样:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="48d6" class="nh lt iq my b gy ni nj l nk nl">select(fn) { <br/>  return fn(this.state); <br/>}</span></pre><p id="595e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这看起来没什么，但实际上有效吗？让我们来看一个使用案例:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="730b" class="nh lt iq my b gy ni nj l nk nl">select(state =&gt; state.products) select(state =&gt; state.language)</span></pre><h1 id="7e07" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">全面实施</h1><p id="d107" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好了，我们的完整代码现在是:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="ba59" class="nh lt iq my b gy ni nj l nk nl">function productsReducer(state = [], action) { <br/>  switch (action.type) { <br/>    case '[Product] add': <br/>      return [...state, action.payload] <br/>    default: <br/>      return state; <br/>  } <br/>} </span><span id="3d18" class="nh lt iq my b gy nm nj l nk nl">function languageReducer(state = '', action) { <br/>  switch (action.type) { <br/>    case '[Language] load': <br/>      return action.payload; <br/>    default: <br/>      return state; <br/>  } <br/>} </span><span id="7f4f" class="nh lt iq my b gy nm nj l nk nl">class Store { <br/>  constructor() { <br/>    this.listeners = []; <br/>    this.state = { <br/>      products: [] <br/>    }; <br/>  } </span><span id="2fbe" class="nh lt iq my b gy nm nj l nk nl">  dispatch(action) { <br/>    this.state = { <br/>      products: productsReducer(this.state.products, action),<br/>      language: languageReducer(this.state.language, action) <br/>    }; <br/>    this.listeners.forEach(l =&gt; l()); <br/>  } </span><span id="6e53" class="nh lt iq my b gy nm nj l nk nl">  subscribe(listener) { <br/>    this.listeners.push(listener); <br/>  } </span><span id="b2f5" class="nh lt iq my b gy nm nj l nk nl">  unsubscribe(listener) { <br/>    this.listeners = this.listeners.filter(l =&gt; l !== listener); <br/>  } </span><span id="e3d1" class="nh lt iq my b gy nm nj l nk nl"><strong class="my ir">  select(fn) { <br/>    return fn(this.state); <br/>  } </strong><br/>} </span><span id="cabc" class="nh lt iq my b gy nm nj l nk nl">const store = new Store(); <br/>module.exports = store;</span></pre><h1 id="6d25" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用我们的实现</h1><p id="f947" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好的，我们认为我们有一个可以使用的实现，所以让我们将它应用到一些组件:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="0483" class="nh lt iq my b gy ni nj l nk nl">const store = require('./store'); </span><span id="b6e0" class="nh lt iq my b gy nm nj l nk nl">class LanguageComponent { <br/>  constructor() { <br/>    store.subscribe(this.onChange.bind(this)); <br/>    this.language = store.select(state =&gt; state.language); <br/>  } </span><span id="e6fe" class="nh lt iq my b gy nm nj l nk nl">  onChange() { <br/>    this.language = store.select(state =&gt; state.language); <br/>  } <br/>} </span><span id="d4ed" class="nh lt iq my b gy nm nj l nk nl">class Component { <br/>   changeLanguage(newLanguage) { <br/>     store.dispatch({ type: '[Language] load', payload: 'en' }); <br/>   } <br/>} </span><span id="7fe3" class="nh lt iq my b gy nm nj l nk nl">class ProductsComponent { <br/>  constructor() { <br/>    store.subscribe(this.onChange.bind(this)); <br/>    this.products = store.select(state =&gt; state.products); <br/>  } </span><span id="a005" class="nh lt iq my b gy nm nj l nk nl">  add(product) { <br/>    store.dispatch({ <br/>      type: '[Product] add', <br/>      payload: product }); <br/>    } </span><span id="c6db" class="nh lt iq my b gy nm nj l nk nl">  onChange() { <br/>    this.products = store.select(state =&gt; state.products); <br/>  } <br/>} </span><span id="6069" class="nh lt iq my b gy nm nj l nk nl">module.exports = { <br/>  LanguageComponent, <br/>  Component, <br/>  ProductsComponent <br/>}</span></pre><p id="9b12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面我们可以看到我们声明了三个组件:</p><ul class=""><li id="688b" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir">组件</strong>，这个组件的目的是成为用户请求的接收者。这个想法是，如果用户选择一个下拉列表，其中包含一个可供选择的语言列表，它应该调用<code class="fe mv mw mx my b">Component</code>上的方法<code class="fe mv mw mx my b">changeLanguage()</code></li><li id="6f36" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir"> LanguageComponent </strong>，这个组件对显示当前语言感兴趣。为了知道当前的语言是什么，它从状态中读取语言，并订阅存储中的任何更改事件</li><li id="7fce" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir"> ProductsComponent </strong>，该组件支持两件事，能够显示产品列表，也能够通过<code class="fe mv mw mx my b">add()</code>方法向产品列表添加项目</li></ul><p id="5012" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们只需要创建一个文件<code class="fe mv mw mx my b">app.js</code>，在这里我们可以实例化我们的组件，并尝试调用一些方法来确保我们的Redux实现正在工作。</p><p id="89f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，让我们试着调用上面的:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="c88d" class="nh lt iq my b gy ni nj l nk nl">const { <br/>  LanguageComponent, <br/>  ProductsComponent, <br/>  Component <br/>} = require('./components'); </span><span id="5f80" class="nh lt iq my b gy nm nj l nk nl">const store = require('./store'); <br/>const component = new Component(); <br/>const languageComponent = new LanguageComponent(); <br/>const productsComponent = new ProductsComponent(); </span><span id="5e32" class="nh lt iq my b gy nm nj l nk nl">component.changeLanguage('en'); <br/>console.log('lang comp', languageComponent.language); </span><span id="18a7" class="nh lt iq my b gy nm nj l nk nl">productsComponent.add({ name: 'movie' }); </span><span id="0508" class="nh lt iq my b gy nm nj l nk nl">console.log('products comp', productsComponent.products); console.log('store products', store.state.products);</span></pre><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/c53388627abe4bea7832c8197703fc7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i8JM9EtoAt5ksyWN.png"/></div></div></figure><h1 id="65a7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">摘要</h1><p id="72db" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好了，我们设法解释了所有的核心概念，甚至设法创建了Redux的一个普通实现，甚至展示了我们如何将它与组件一起使用。您可以将该解决方案用于任何框架或库。希望大家都明白Redux是public-Sub，但这种状态是我们非常关心的，我们关心的是状态以一种有序和纯粹的方式改变。</p><p id="e2a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一部分中，我们将研究NGRx本身以及如何使用商店库。</p></div></div>    
</body>
</html>