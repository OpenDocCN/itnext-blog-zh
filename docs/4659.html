<html>
<head>
<title>Understanding Basic Kubernetes Concepts V — Daemon Sets and Jobs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Kubernetes的基本概念V —守护进程集和作业</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-basic-kubernetes-concepts-v-daemon-sets-and-jobs-da83eca7e3f7?source=collection_archive---------1-----------------------#2020-08-17">https://itnext.io/understanding-basic-kubernetes-concepts-v-daemon-sets-and-jobs-da83eca7e3f7?source=collection_archive---------1-----------------------#2020-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><a href="http://www.giantswarm.io"><div class="gh gi jn"><img src="../Images/f7f44a8d6f4793dadaea36b2d20f838e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHZbB3OskZHii5_CgzrDQg.jpeg"/></div></a></figure><p id="0b37" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这篇文章是一系列关于Kubernetes基本概念的博客文章中的第五篇。在第一篇中，我 <a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-i-introduction-to-pods-labels-replicas/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">解释了pod、标签和副本集</em> </a> <em class="ks">的概念。在第二篇</em> <a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-using-deployments-manage-services-declaratively/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">中我们谈到了部署</em> </a> <em class="ks">。第三篇文章</em> <a class="ae kt" href="https://blog.giantswarm.io/basic-kubernetes-concepts-iii-services-give-abstraction/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">解释了服务概念</em> </a> <em class="ks">，在第四篇文章中我们看了一下</em> <a class="ae kt" href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-iv-secrets-and-configmaps/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">的秘密和配置图</em> </a> <em class="ks">。在这最后一篇文章中，我们将讨论守护进程集和任务。</em></p><p id="29b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在之前的文章中，我们讨论了如何在Kubernetes中以pods的形式运行我们的应用程序。还有两种方式来运行更加专业化的pod。一个是<em class="ks">守护进程Set </em>，另一个叫做<em class="ks"> Jobs </em>。</p><h1 id="e69e" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">守护进程集</h1><p id="f464" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">守护程序集确保特定pod的实例在集群中的所有(或一部分)节点上运行。它在每个添加的节点上创建pod，并在从集群中删除节点时收集pod。</p><p id="c09f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">顾名思义，您可以使用守护进程集来运行需要在集群的所有节点上运行的守护进程(和其他工具)。这些可以是集群存储守护进程(例如Quobyte、glusterd、ceph等。)、日志收集器(例如fluentd或logstash)或监视守护程序(例如Prometheus Node Exporter、collectd、New Relic agent等)。)</p><p id="6462" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最简单的用例是在所有节点上部署一个守护进程。但是，您可能希望将其拆分为多个守护进程集，例如，如果您有一个包含不同硬件节点的集群，这可能需要对守护进程的内存和/或cpu请求进行调整。</p><p id="1cbe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在其他情况下，您可能希望在集群的不同节点上使用不同的日志记录、监控或存储解决方案。在这些情况下，您希望只将守护程序部署到一组特定的节点，而不是所有节点，您可以使用<a class="ae kt" href="https://github.com/kubernetes/kubernetes.github.io/tree/release-1.3/docs/user-guide/node-selection" rel="noopener ugc nofollow" target="_blank">节点选择器</a>为守护程序集指定一个节点子集。请注意，要做到这一点，您需要相应地标记您的节点。</p><p id="e419" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有四种方法可以与您的守护程序通信:</p><ul class=""><li id="84d4" class="lx ly iq jw b jx jy kb kc kf lz kj ma kn mb kr mc md me mf bi translated">push:pod被配置为将数据推送到服务，因此它们没有需要找到它们的客户机。</li><li id="1ac2" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">NodeIP和已知端口:pods使用一个<code class="fe ml mm mn mo b">hostPort</code>，客户端可以通过每个NodeIP上的这个端口访问它们(在它们被部署到的节点范围内)。</li><li id="a197" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">DNS:通过使用<code class="fe ml mm mn mo b">endpoints</code>资源或从DNS获取多个A记录，可以通过<a class="ae kt" href="http://kubernetes.io/docs/user-guide/services/#headless-services" rel="noopener ugc nofollow" target="_blank">无头服务</a>到达pod。</li><li id="2282" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">服务:可以通过一个标准服务来访问这些pod。客户端可以使用该服务访问随机节点上的守护程序。请注意，该选项不提供到达特定节点的方法。</li></ul><p id="5936" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">目前，您无法更新守护程序集。半自动更新pod的唯一方法是删除用<code class="fe ml mm mn mo b">--cascade=false</code>选项设置的守护进程，这样pod将留在节点上。然后创建一个新的守护进程集，使用相同的pod选择器，但是使用更新的模板。新的守护进程集将识别旧的pod，但不会自动更新它们。您将需要通过从节点中手动删除旧的pod来强制创建具有新模板的pod。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><a href="https://www.giantswarm.io/guide-cloud-native-stack?utm_campaign=Blog%20CTA%20Conversion&amp;utm_source=Cloud%20native%20stack%20guide_Blog&amp;utm_medium=Blog%20CTA&amp;utm_term=cloud%20native%20stack%20guide"><div class="gh gi mp"><img src="../Images/e949e8566cc54e8788e96955293d0178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B0lxE1R1abmYddVZ.jpg"/></div></a></figure><h1 id="0b95" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">乔布斯</h1><p id="4392" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">与用于长期运行流程的典型pod不同，作业允许您管理应该终止而不是重新启动的pod。一个作业创建一个或多个pod，并确保指定数量的pod成功终止。</p><p id="411b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以将作业用于典型的批处理作业(例如数据库备份)，也可以用于需要处理特定队列的工作人员(例如图像或视频转换器)。</p><p id="a9b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有三种工作:</p><ul class=""><li id="cdd3" class="lx ly iq jw b jx jy kb kc kf lz kj ma kn mb kr mc md me mf bi translated">非平行作业</li><li id="d939" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">具有固定完成数量的并行任务</li><li id="44ca" class="lx ly iq jw b jx mg kb mh kf mi kj mj kn mk kr mc md me mf bi translated">带有工作队列的并行作业</li></ul><p id="2da6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于非并行作业，通常只有一个pod开始，一旦pod成功终止，作业就被视为完成。如果这个分离舱失败了，另一个会代替它启动。</p><p id="bc98" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于具有固定完成计数的并行任务，当1和指定完成数之间的每个值都有一个成功的pod时，任务完成。</p><p id="9863" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于带有工作队列的并行作业，您需要注意，除非工作队列为空，否则pod不会成功终止。也就是说，即使工作者完成了它的工作，它也应该只在它知道它的所有同行也完成时才成功终止。一旦一个pod成功退出，那么所有其他pod也应该退出或正在退出。</p><p id="f72a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于并行作业，您可以定义请求的并行度。默认情况下，它设置为1(任何时候只有一个pod)。如果并行度设置为0，作业基本上会暂停，直到它增加。</p><p id="02b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请记住，并行作业不是为了支持需要紧密通信的并行进程的用例而设计的，例如在科学计算中，而是为了处理特定数量的可以并行化的工作。</p><h1 id="5c36" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结局？</h1><p id="a0ca" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ij bi translated">这是Kubernetes基础系列的最后一篇文章。然而，这并不意味着读完所有五篇博文就可以成为Kubernetes大师。</p><p id="cf68" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，引入的原语虽然可能不限于最基本的，但并没有涵盖Kubernetes中可用的所有原语。</p><p id="cc19" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第二，新版本中有新的原语，比如最近在Kubernetes 1.3中作为alpha资源引入的Pet Sets。</p><p id="0727" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以一旦我觉得需要比现有的更多或更简单的解释，我很可能会写更多的原语。</p><p id="a023" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，仅仅阅读这些博客文章或者浏览一下Kubernetes文档就能给你一个良好的基础。然而，您需要实际去尝试它，并找到使用这些原语来运行和管理实际应用程序的方法，以便精通它们的用法。没有理由说您手头没有集群，只需在本地环境中进行试验。</p><p id="1fc3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由<a class="ae kt" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank">Puja Abbas si</a>:<strong class="jw ir">T5】开发者拥护者@ <a class="ae kt" href="https://twitter.com/giantswarm" rel="noopener ugc nofollow" target="_blank">巨型虫群</a></strong></p></div></div>    
</body>
</html>