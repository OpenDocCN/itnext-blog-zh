<html>
<head>
<title>Eating my advice: Efficiently Improving on understanding and using Nuxt + Vuex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">采纳我的建议:有效地理解和使用Nuxt + Vuex</h1>
<blockquote>原文：<a href="https://itnext.io/eating-my-advice-efficiently-improving-on-understanding-and-using-nuxt-vuex-6d00769014a2?source=collection_archive---------1-----------------------#2019-09-12">https://itnext.io/eating-my-advice-efficiently-improving-on-understanding-and-using-nuxt-vuex-6d00769014a2?source=collection_archive---------1-----------------------#2019-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/954275becb3d206cfa00257f5d5db276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROtQY0XW1itY-76_ufVHww.png"/></div></div></figure><div class=""/><p id="3354" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一年前写的这篇文章的第一部分<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/efficiently-understanding-and-using-nuxt-vuex-7905eb8858d6">中，我开始谈论修改设计。我想承认这个堆栈有很多了不起的地方，并邀请人们讨论他们的方法。</a></p><p id="2d7b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多都来自于栈中的日常工作，关注Github和其他地方关于它的喋喋不休，感觉是时候把事情安排好了。没有特定的流程，只是一些概念或注释的集合。</p><h2 id="f490" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">UI真的很慢</h2><p id="d700" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">查看<a class="ae kw" href="https://nuxt-community.github.io/nuxt-i18n/seo.html#improving-performance" rel="noopener ugc nofollow" target="_blank">https://nuxt-community . github . io/nuxt-i18n/SEO . html #改善性能</a>。我花了几天时间调试它，直到我发现nuxt-i18n是它的来源。</p><h2 id="bfae" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">样式指南(棉绒外面)</h2><p id="a49e" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我把代码放在我的组件文件夹中。所有带有. vue文件扩展名的东西都需要有一个<code class="fe lv lw lx ly b">name</code>键。页面名称基本上是<code class="fe lv lw lx ly b">PathPage</code>遵循一点<a class="ae kw" href="http://bradfrost.com/blog/post/atomic-web-design/" rel="noopener ugc nofollow" target="_blank">原子设计</a>模式。</p><h1 id="dfd0" class="lz ky jb bd kz ma mb mc lc md me mf lf mg mh mi li mj mk ml ll mm mn mo lo mp bi translated">干燥Nuxt应用程序</h1><p id="2680" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我非常诚实地使用单文件组件的混合，并且通常围绕它们的用例和/或它们管理的实体来组织我的项目。</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="3c3d" class="kx ky jb ly b gy my mz l na nb">orders (molecules)/<br/>  mixins/<br/>    validations.js<br/>    operations.js<br/>    getters.js<br/>  OrdersSelectMenu.vue<br/>  OrderForm.vue<br/>  etc...</span><span id="3be5" class="kx ky jb ly b gy nc mz l na nb">core (atoms)/<br/> buttons/<br/> alerts/<br/> progress/<br/> etc..</span><span id="c525" class="kx ky jb ly b gy nc mz l na nb">mixins (particles)/<br/>  formatters/<br/>    dates/<br/>      format.js<br/>      fromNow.js<br/>    strings/<br/>    etc...</span><span id="54b8" class="kx ky jb ly b gy nc mz l na nb">  apis/external/<br/>    operations.js</span><span id="2e73" class="kx ky jb ly b gy nc mz l na nb">pages/<br/>  orders/<br/>    index.vue<br/>  orders.vue</span></pre><h2 id="4b2a" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">用Vue的合成api！</h2><p id="714d" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我想在一个不同的话题中讨论这个问题，因为它非常大。不过<a class="ae kw" href="https://vue-composition-api-rfc.netlify.com/#logic-reuse-code-organization" rel="noopener ugc nofollow" target="_blank">https://vue-composition-API-RFC . net lify . com/# logic-reuse-code-organization</a>出于好奇。这是一个我需要了解的话题，因为据我所知，很多事情都在进行中。在内部，我认为组合api可以用来构建模块化的<a class="ae kw" href="https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/" rel="noopener ugc nofollow" target="_blank">关注点</a>，然后呈现层可以是非常快速的<a class="ae kw" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener ugc nofollow" target="_blank"> mvvvm模式</a>。</p><h2 id="8c9e" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">使用mixins！</h2><p id="8a6f" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">比如我有一个<code class="fe lv lw lx ly b">components/orders/DataTable.vue</code>组件。在这个模式中，我设置了一个期望，这里有一个对<code class="fe lv lw lx ly b">orders</code>的Vuex模块依赖。这个文件夹可以有自己的一组mixins，我将其视为私有。我也有一个全局mixins文件夹，我试着用它来存放一些实用程序之类的东西。大多数时候，某个东西在一个地方开始是mixin，然后被向上或向下重构为public/private状态。Mixins真的很容易推理和维护。</p><p id="bcbc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个mixin，我用它对来自查询参数的数据表进行过滤、排序和分页:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="ad1e" class="kx ky jb ly b gy my mz l na nb">export default {<br/>  watchQuery: true,<br/>  watch: {<br/>    // Allows for this mixin to be extended using object notation<br/>    sortable(newval) {<br/>      this.$router.push({<br/>        path: this.$route.path,<br/>        query: { ...this.$route.query, ...newval }<br/>      })<br/>    }<br/>  }<br/>}</span></pre><p id="017a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在我的<code class="fe lv lw lx ly b">pages/orders/index.vue</code>里我只是导入这个:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="1e31" class="kx ky jb ly b gy my mz l na nb">mixins: [watchQuery],<br/>data() { return { sortable: {} } },</span></pre><p id="8ee8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您的页面可以通过使用sortable对象中的值，从查询参数中设置组件的起始值。常见的键有page，rows，sortBy，desc，你懂的。这还会更新查询参数并触发路由器事件。</p><p id="14a4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这个，应用程序可以切换到使用<code class="fe lv lw lx ly b">b-table-simple</code>甚至<code class="fe lv lw lx ly b">-lite</code>，因为UI不再需要全功能的<code class="fe lv lw lx ly b">b-table</code>组件来处理给定项目的排序/过滤/分页。在大多数情况下，数据的完全服务器端呈现是有利的。</p><p id="4560" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我也真的厌倦了在这么多地方看到<code class="fe lv lw lx ly b">import { mapActions } from 'vuex'</code>。</p><p id="f604" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以又是mixins来救援了！</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="9fe6" class="kx ky jb ly b gy my mz l na nb">// operations.js<br/>import { <strong class="ly jc"><em class="nd">mapActions </em></strong>} from 'vuex'<br/><br/>export default {<br/>  methods: {<br/>    ...<strong class="ly jc"><em class="nd">mapActions</em></strong>({<br/>      create: 'items/create',<br/>      update: 'item/update',<br/>      destroy: 'item/destroy'<br/>    })<br/>  }<br/>}</span></pre><p id="6366" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终，它成长为自己的类，用于我的商店和组件中的所有操作。它给了我一个跨组件/页面推理API的简单方法，只需要导入它。因此，现在组件文件夹可能看起来像这样:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="8a02" class="kx ky jb ly b gy my mz l na nb">components/<br/>  cars/<br/>    DataTable.vue<br/>    CarForm.vue<br/>    DetailsCard.vue<br/>    operations.js<br/>    computed.js<br/>    getters.js</span></pre><p id="e523" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<code class="fe lv lw lx ly b">operations</code>为汽车提供调用vuex存储动作的方法，<code class="fe lv lw lx ly b">computed</code>为我的汽车列表提供获取/设置状态的映射，<code class="fe lv lw lx ly b">getters</code>为我的UI用于格式化信息的任何格式化或其他操作提供映射。</p><h2 id="0f5a" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">Webstorm的Vue和Typescript支持非常出色</h2><p id="55c4" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">Webstorm的Vue插件的一个优秀特性是突出显示一大块模板代码。然后重构-&gt;提取-&gt; Vue组件。它让您直接命名组件，然后在同一个目录中创建一个新组件。Webstorm还跟踪导入语句，并在组件移动时更改路径。</p><p id="39cb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我相信VSCode和其他人也可以做到这一点，但是我对特别有用的工具感兴趣。另外，我没有因为推荐Jetbrain的工具而得到任何东西。</p><h1 id="5660" class="lz ky jb bd kz ma mb mc lc md me mf lf mg mh mi li mj mk ml ll mm mn mo lo mp bi translated">我喜欢Vuex，但是…</h1><p id="0971" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">假设您的任务是构建一些个性化的仪表板。所以API需要在很多地方被调用，对于所有这些实体，都有一个地方来填充响应数据。好极了，一切都很好，然后应用程序开始感觉不那么快了。它使用48gb内存，因为vuex在数组中存储了1000个项目...</p><p id="f508" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你的应用程序必须管理许多实体，而你想要一个类似AREL的语法来管理所有这些，那么就去看看<a class="ae kw" href="https://vuex-orm.github.io/vuex-orm/" rel="noopener ugc nofollow" target="_blank"> vuex-orm </a>。它非常容易设置，并且有助于简化实体之间的复杂关系。它还有一个很棒的插件系统。也很好地记录和一个积极友好的松弛渠道。</p><p id="afb8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你在看vuex-orm，并认为“太复杂了”，那么看看https://github.com/davestewart/vuex-pathify的<a class="ae kw" href="https://github.com/davestewart/vuex-pathify" rel="noopener ugc nofollow" target="_blank">。我没有用过它，但我经常看到它获得好评。</a></p><p id="5ef0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">否则，在编写组件时，尽量使它们无状态。理想情况下，组件接收道具并发出事件。这些事件可以触发父组件的突变，然后更新道具的值。使用destroy钩子清除状态来节省内存，使用Nuxt的页面中的<code class="fe lv lw lx ly b">fetch</code>来恢复状态。vuex缓存有很棒的插件，但是依赖后端API缓存头要好得多。</p><h1 id="23cf" class="lz ky jb bd kz ma mb mc lc md me mf lf mg mh mi li mj mk ml ll mm mn mo lo mp bi translated">重置状态</h1><p id="c602" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在我所有的vuex模块中，我写了一个将状态设置回默认状态的动作。然后在<code class="fe lv lw lx ly b">store/index.js</code>中，我有一个重置函数，它调用我想要清除的模块中的每个重置动作。</p><h2 id="ff5a" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">默认状态</h2><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="d681" class="kx ky jb ly b gy my mz l na nb">const defaultState = {<br/>  list: [],<br/>  page: 1,<br/>  total: 0,<br/>  per: null<br/>}<br/><br/>export const state = () =&gt; <strong class="ly jc"><em class="nd">JSON</em></strong>.parse(<strong class="ly jc"><em class="nd">JSON</em></strong>.stringify(defaultState))</span></pre><p id="3b83" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样你就能确定这个状态是从一个没有原型污染的新鲜物体开始的。也许太激进了。</p><h2 id="8d02" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">关于服务对象</h2><p id="8d7c" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">服务对象就是这样；它是一个对象(通常是一个类),带有特定行为的通用操作，例如验证输入。</p><p id="de43" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我见过很多这样的代码；甚至说这是最佳实践:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="3d80" class="kx ky jb ly b gy my mz l na nb">services/<br/>  orders.js</span><span id="1976" class="kx ky jb ly b gy nc mz l na nb">class Orders<br/>...<br/>getBySomething() { this.$axios.get('/orders/something')...<br/><br/>getByPaychecks() { this.$axios.get('/orders/weird')...<br/><br/>getByGetinBy() { this.$axios.get('/orders/flex')...</span></pre><p id="41df" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过采用这种封装服务调用的模式，它将Vuex动作排除在外，而Vuex动作通常是模块中最大的部分。很好，对吗？较小的模块更容易推理和测试。</p><p id="7c84" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我沿着这条路走了一段时间，在Nuxt/Vuex中实现了一个反模式。原因如下:</p><ol class=""><li id="3d23" class="ne nf jb ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">不使用操作会中断反应流</li><li id="b1e7" class="ne nf jb ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">Javascript绝对不会让开发人员创建动作模块，并像mixins一样在任何地方导入它们。</li><li id="8e27" class="ne nf jb ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">Nuxt有一个服务对象必须遵守的SSR请求生命周期，否则会导致难以调试的奇怪加载错误。</li></ol><p id="84f9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务对象的一个用途是将axios调用的配置从逻辑中分离出来，验证参数，并检查授权。例如:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="cb3b" class="kx ky jb ly b gy my mz l na nb">./store/orders.js <br/>async getAllOrders({commit}, params) {<br/>  await this.$axios.get(Orders.ordersPath, Orders.params(params))<br/>}<br/>...</span><span id="f4f5" class="kx ky jb ly b gy nc mz l na nb">class Orders</span><span id="9064" class="kx ky jb ly b gy nc mz l na nb">const ordersPath = '/orders'</span><span id="bea9" class="kx ky jb ly b gy nc mz l na nb">function params(params) {</span><span id="a407" class="kx ky jb ly b gy nc mz l na nb">  orderParams = validate(params)<br/>  if(orderParams.valid) {<br/>    return orderParams<br/>  }<br/>}<br/>...</span></pre><p id="a461" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务对象可以防止无效和过多的API调用，但我不认为它们可以替代Vuex动作。服务对象与动作并不相互排斥；它们可以一起使用。</p><p id="ce05" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，我发现很容易保持应用程序的设计依赖于Nuxt的<code class="fe lv lw lx ly b">/page</code>级别来编排对服务器的调用，然后尽量避免在我的组件中直接导入<code class="fe lv lw lx ly b">operations.js</code>。</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="b95f" class="kx ky jb ly b gy my mz l na nb">/pages/orders.vue:<br/>import operations from '@/components/Orders/operations.js'</span><span id="cc1e" class="kx ky jb ly b gy nc mz l na nb">export default {<br/>  name: 'OrdersPage',<br/>  mixins: [operations]<br/>}</span></pre><h1 id="6c7a" class="lz ky jb bd kz ma mb mc lc md me mf lf mg mh mi li mj mk ml ll mm mn mo lo mp bi translated">捆绑大小</h1><h2 id="423c" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">不要把所有的东西捆在一起。</h2><p id="3a8e" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">你不必<code class="fe lv lw lx ly b">yarn install</code>每一个前端依赖项，尤其是如果你想使用moment.js的话，我建议在<code class="fe lv lw lx ly b">nuxt.config</code>或者布局的<code class="fe lv lw lx ly b">head</code>键中使用CDN urls。您可以通过将<code class="fe lv lw lx ly b">nuxt.config.js</code>设置为<code class="fe lv lw lx ly b">analyze: true</code>来生成您的包的webpack分析。参见关于分析的文档<a class="ae kw" href="https://nuxtjs.org/api/configuration-build" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="6bad" class="lz ky jb bd kz ma mb mc lc md me mf lf mg mh mi li mj mk ml ll mm mn mo lo mp bi translated">有用的片段</h1><p id="8501" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">说到moment.js，如果你碰巧切换到了<a class="ae kw" href="https://date-fns.org/" rel="noopener ugc nofollow" target="_blank"> date-fns </a>这里有一个有趣的小片段:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="d4de" class="kx ky jb ly b gy my mz l na nb">// plugins/datefns.js<br/>import Vue from 'vue'<br/>import { distanceInWordsToNow, format } from 'date-fns'<br/>import FormatTime from '@/components/FormatTime'<br/>import FromNow from '@/components/FromNow'<br/><br/>Vue.filter('fromNow', function(timestamp = new <strong class="ly jc"><em class="nd">Date</em></strong>()) {<br/>  return distanceInWordsToNow(timestamp) + ' ago'<br/>})<br/><br/>Vue.filter('formatTime', function(<br/>  date = new <strong class="ly jc"><em class="nd">Date</em></strong>(),<br/>  how = 'h:mmA MMM Do YYYY'<br/>) {<br/>  return format(date, how)<br/>})<br/><br/>Vue.component('format-time', FormatTime)<br/>Vue.component('from-now', FromNow)</span></pre><p id="16bb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和components/FormatTime.vue</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="310e" class="kx ky jb ly b gy my mz l na nb">&lt;template&gt;<br/>  &lt;span&gt;{{ time | formatTime }}&lt;/span&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>export default {<br/>  name: 'FormatTime',<br/>  props: {<br/>    time: {<br/>      type: <strong class="ly jc"><em class="nd">String</em></strong>,<br/>      default: () =&gt; new <strong class="ly jc"><em class="nd">Date</em></strong>().toDateString()<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="b569" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和组件/FromNow.vue</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="4a08" class="kx ky jb ly b gy my mz l na nb">&lt;template&gt;<br/>  &lt;span&gt;{{ time | fromNow }}&lt;/span&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>export default {<br/>  name: 'FromNow',<br/>  props: {<br/>    time: {<br/>      type: <strong class="ly jc"><em class="nd">String</em></strong>,<br/>      default: () =&gt; new <strong class="ly jc"><em class="nd">Date</em></strong>()<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="0937" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你仍然需要更多，https://www.npmjs.com/package/vue-date-fns已经做得很好了。</p><h2 id="3adb" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">处理器械组</h2><p id="0042" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">众所周知，Bootstrap的难点在于成排的卡组。我写了一个mixin来把我的数组分成任意大小的数组。</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="8550" class="kx ky jb ly b gy my mz l na nb">export default {<br/>  computed: {<br/>    chunkSize() {<br/>      if (process.client) {<br/>        return <strong class="ly jc"><em class="nd">window</em></strong>.innerWidth &gt; 768 ? 3 : 2<br/>      }<br/>    }<br/>  },<br/>  methods: {<br/>    foldm(r, j) {<br/>      return r.reduce(<br/>        (a, b, i, g) =&gt; (!(i % j) ? a.concat([g.slice(i, i + j)]) : a),<br/>        []<br/>      )<br/>    }<br/>  }<br/>}</span></pre><p id="7ff6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用它，只需调用foldm:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="b0dd" class="kx ky jb ly b gy my mz l na nb">&lt;b-card-group v-for="(<strong class="ly jc"><em class="nd">chunk</em></strong>, <strong class="ly jc"><em class="nd">i</em></strong>) in foldm(items, chunkSize)" :key="<strong class="ly jc"><em class="nd">i</em></strong>" deck&gt;<br/>  &lt;item-summary-card<br/>    v-for="<strong class="ly jc"><em class="nd">item </em></strong>in <strong class="ly jc"><em class="nd">chunk</em></strong>"</span></pre><h2 id="4aeb" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">结论</h2><p id="4201" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我希望你觉得这些比特有用！我希望这些信息会随着我将来的添加和编辑而扩展。请随意在这里发表你的意见！</p></div></div>    
</body>
</html>