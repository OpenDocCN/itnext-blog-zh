<html>
<head>
<title>Simple Multi-tenancy with Django Running on OpenShift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django在OpenShift上运行的简单多租户</h1>
<blockquote>原文：<a href="https://itnext.io/simple-multi-tenancy-with-django-running-on-openshift-b5859a94dd52?source=collection_archive---------1-----------------------#2019-01-12">https://itnext.io/simple-multi-tenancy-with-django-running-on-openshift-b5859a94dd52?source=collection_archive---------1-----------------------#2019-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f0168263fc03301da3df09a7451a7524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XpaXRT84EEwBO90U"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">塞缪尔·泽勒在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b4bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对多租户应用的需求并不新鲜，但是随着<a class="ae kc" href="https://financesonline.com/2018-saas-industry-market-report-key-global-trends-growth-forecasts/" rel="noopener ugc nofollow" target="_blank">软件即服务(SaaS)产品</a>的日益流行，如果你不认为这是一个核心需求，那你就错了。<a class="ae kc" href="https://en.wikipedia.org/wiki/Multitenancy" rel="noopener ugc nofollow" target="_blank"> <em class="lb">多</em> - <em class="lb">租用</em> </a>在软件架构中，一个应用的单个实例服务于多个客户(每个客户称为一个<em class="lb">租户)</em>。客户可以是整个公司，或者是一个业务部门，或者是开发商Todd。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/87c6257b6d648ab056143b628ea48464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iIVpcfMFPCtiDjP3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@rawpixel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> rawpixel </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6567" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有许多方法可以解决这个问题。最常见的关注点是为租户存储的数据。方法包括从每个客户一个数据库到带有指定客户的列的共享表。利用数据库或表命名约定(即客户前缀等)允许开发人员继续以单个客户为中心进行思考，并在一定程度上将数据与其他客户数据隔离开来。基于客户列的方法基本上就是在所有内容中添加一个WHERE子句。每种都有自己的缺点；数据库创建可能需要很长时间，命名约定可能会增加代码的复杂性，并且基于列的方法可能会很快遇到性能问题，因为所有的客户数据都被强制放在一起。</p><h1 id="a10c" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">多租户和后迁移SQL</h1><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/fe625b04f83bdcd317e8e6b5eb0ad034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5_TZ-3_wIESvZ2I5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马修·斯皮特里在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="71f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PostgreSQL是<a class="ae kc" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>应用程序最常用的数据库。<em class="lb"> Postgres </em>有一个特性，<a class="ae kc" href="https://www.postgresql.org/docs/current/ddl-schemas.html" rel="noopener ugc nofollow" target="_blank"> schemas </a>，它利用了数据库/表驱动方法的优点，同时解决了一些复杂性和性能问题。模式提供了数据库的行为，但是创建起来更快。使用模式，每个租户的表可以是相同的，这降低了复杂性，但也可以与租户无关的共享数据一起驻留在同一个数据库中。这种数据分离还允许您避免基于列的方法的缺点，这种方法可能会遇到性能问题，并且还会带来一个问题，即只有少量数据的租户的查询速度会受到所有其他租户数据的影响。虽然模式是一个很好的特性，但它仍然不能让多租户变得简单。</p><p id="eeb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，开源社区已经帮助贡献了一些库，这些库确实使得使用<em class="lb">PostgreSQL</em>模式进行开发变得简单了。现在有各种各样的<a class="ae kc" href="http://books.agiliq.com/projects/django-multi-tenant/en/latest/third-party-apps.html" rel="noopener ugc nofollow" target="_blank">库</a>可用；我们的团队使用了<a class="ae kc" href="https://github.com/bernardopires/django-tenant-schemas" rel="noopener ugc nofollow" target="_blank"> django-tenant-schemas </a>来帮助解决这个问题。<em class="lb"> django-tenant-schemas </em>很好地融入了<em class="lb"> Django </em>的生命周期。模式创建触发迁移运行，并允许您维护正常的<em class="lb"> Django </em>开发过程。该模块还提供了一个<a class="ae kc" href="http://book.pythontips.com/en/latest/context_managers.html" rel="noopener ugc nofollow" target="_blank">上下文管理器</a>，使得选择想要与之交互的模式变得简单。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/6f80d2e3eb6399e3151d47feb0b0f006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FcZ0Xb_WawxfYr9MyMkdOA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用于访问租户数据的上下文管理器</figcaption></figure><p id="2fe3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，您可以通过指定配置来区分共享数据和租户数据。</p><h1 id="f88e" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Django租户模式的应用</h1><p id="9b02" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">虽然<a class="ae kc" href="https://django-tenant-schemas.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">django-tenant-schemas的文档</a>相当不错，但我们并没有使用他们现成的标准实现。默认实现使用基于域URL创建租户架构的概念；例如，假设每个租户都有自己的子域来访问数据(即{tenant}.myapp.io)，并从该模式中导出模式名。虽然子域是一个很好的模式，但它可能不适合您的需要；它不符合我们的要求。</p><p id="8ca8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，租赁可以由提供帐户信息的标题中的数据来确定。幸运的是，这是一个足够常见的模式，我们还找到了<a class="ae kc" href="https://django-tenant-schemas.readthedocs.io/en/latest/advanced_usage.html#example-determine-tenant-from-http-header" rel="noopener ugc nofollow" target="_blank">示例文档</a>来处理这个流程。虽然例子很多，但看到一个<a class="ae kc" href="https://github.com/project-koku/koku" rel="noopener ugc nofollow" target="_blank">工作应用</a>稍微复杂一点，我们有<a class="ae kc" href="https://github.com/project-koku/koku/blob/master/koku/koku/settings.py#L89" rel="noopener ugc nofollow" target="_blank">多个共享应用和租户应用</a>可能会有帮助。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/326b9b495bc58d526d18264f2fff1c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*-Bym5XvTwLeWD3B39XissQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">共享和特定于租户的模式配置</figcaption></figure><p id="ce99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以深入我们的<a class="ae kc" href="https://github.com/project-koku/koku/blob/master/koku/koku/settings.py#L115" rel="noopener ugc nofollow" target="_blank">租户中间件</a>来查看我们的流程，不仅是<a class="ae kc" href="https://github.com/project-koku/koku/blob/master/koku/koku/middleware.py#L56" rel="noopener ugc nofollow" target="_blank">基于标题信息</a>创建租户，而且<a class="ae kc" href="https://github.com/project-koku/koku/blob/master/koku/koku/middleware.py#L91" rel="noopener ugc nofollow" target="_blank">创建与请求相关联的客户和用户对象</a>。</p><h1 id="b883" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">在OpenShift上部署源到映像(S2I)</h1><p id="ea62" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">既然我们已经探索了多租户Django应用程序的构建模块，我们必须考虑在为项目实施新的方面/功能时对持续部署和数据迁移的影响。如果你是一个经验丰富的Django开发者，你应该熟悉迁移流程。如前所述，<em class="lb"> django-tenant-schemas </em>适合于<em class="lb"> Django </em>的生命周期，例如提供它自己的命令<a class="ae kc" href="https://django-tenant-schemas.readthedocs.io/en/latest/use.html#migrate-schemas" rel="noopener ugc nofollow" target="_blank"> migrate-schemas </a>，以跨模式应用迁移。有了这些组件，如何最好地将它们融入您的持续部署策略？</p><div class="mn mo gp gr mp mq"><a href="https://blog.openshift.com/create-s2i-builder-image/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">如何创建一个S2I建设者形象-红帽OpenShift博客</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">源到图像(S2I)是一个独立的工具，在创建生成器图像时非常有用。S2I也碰巧…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">blog.openshift.com</p></div></div></div></a></div><p id="5111" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.openshift.com/" rel="noopener ugc nofollow" target="_blank"> OpenShift </a>提供了一个名为<a class="ae kc" href="https://github.com/openshift/source-to-image" rel="noopener ugc nofollow" target="_blank">源到映像(s2i) </a>的构建/部署机制，用于将基础映像与来自源代码控制的代码结合起来(就像<a class="ae kc" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)。源代码到映像支持执行由基础映像在代码源代码下载后触发的<a class="ae kc" href="https://github.com/project-koku/koku/blob/master/openshift/s2i/bin/assemble" rel="noopener ugc nofollow" target="_blank">汇编</a>和<a class="ae kc" href="https://github.com/project-koku/koku/blob/master/openshift/s2i/bin/run" rel="noopener ugc nofollow" target="_blank">运行</a>脚本的标准流程。如果深入研究这些脚本，您可以看到它是如何根据提供的源代码准备容器的。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/090a29df8438224ff0f6ee62216c40b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ny3fwyHpA6z2q0eQfnqWlw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用s2i进行模式迁移</figcaption></figure><p id="6934" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的脚本显示了使用<strong class="kf ir"><em class="lb">migrate _ schemas</em></strong>命令对<em class="lb"> run </em>脚本进行修改以支持租户迁移的阶段。有了这些，您就可以迁移数据库结构，并在连续部署设置中的共享模式和租户模式中添加新表。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/d8f64658d05ecdf8f4f7f6ffa269ab24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zm-2XOo1WLhaKR54w-Z3Kw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">租户模式运行示例</figcaption></figure><h1 id="9cb8" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">摘要</h1><p id="e69d" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">在这个故事中，我们强调了在软件设计中考虑多租户的必要性，以及一些常见的实现模式。在<em class="lb"> Django </em>开发世界中，我们发现<em class="lb">PostgreSQL</em>提供了模式，这允许在常见模式及其缺点的上下文中采用平衡的方法。更重要的是，开源社区通过Django T21让模式的使用变得简单了。最后，我们考虑了s2i对Openshift的迁移和持续部署的影响，并探讨了必要的更新。</p></div></div>    
</body>
</html>