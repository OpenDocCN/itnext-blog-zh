<html>
<head>
<title>From stuff.kt to Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从stuff.kt到建筑</h1>
<blockquote>原文：<a href="https://itnext.io/from-stuff-kt-to-architecture-905426799dae?source=collection_archive---------5-----------------------#2019-08-14">https://itnext.io/from-stuff-kt-to-architecture-905426799dae?source=collection_archive---------5-----------------------#2019-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="33c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何重写你的全功能原型，增加20个文件的数量，停止担心。</p><p id="77d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是关于我的书籍渲染ar实验的第三篇文章，我简要记录了一些架构决策并展示了项目进展。</p><ol class=""><li id="81ce" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><a class="ae kx" href="https://medium.com/@intmainreturn00/goodreads-api-from-android-with-kotlin-fd8c2c7338d8" rel="noopener">使用Kotlin从Android读取API</a></li><li id="26f0" class="ko kp it js b jt ky jx kz kb la kf lb kj lc kn kt ku kv kw bi translated"><a class="ae kx" href="https://medium.com/@intmainreturn00/all-my-books-in-ar-c4d740a3ecbb" rel="noopener">我所有的书都在AR </a></li><li id="a9ec" class="ko kp it js b jt ky jx kz kb la kf lb kj lc kn kt ku kv kw bi translated">从stuff.kt到建筑【你来了！]</li></ol><p id="a47a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">android应用程序架构的话题极具争议性，争论激烈。最近，在谷歌发布架构组件后，新一轮的讨论已经到来。经过10年的代码编写，我们收到了指南，当然，这引发了新一轮的讨论。</p><p id="fa38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下所有内容都应被视为我个人8年经验的浅见，无意让任何人难过或生气。</p><h1 id="13e5" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">原型</h1><p id="5b8e" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我从上一篇文章离开的地方开始(<a class="ae kx" href="https://github.com/intmainreturn00/Bookar/tree/tutorial" rel="noopener ugc nofollow" target="_blank">教程分支</a>)。我们在AR中制作了一个原型，它具有以下结构:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/d37845964bd7f587b1a6c7b3208ea30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*r3rbN5WaCWpiN2NM8IKOCA.png"/></div></figure><p id="66d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">许多可能是由于明显缺少干净的图层，甚至是MVVM和视图模型而触发的。但这是我在大多数原型中有意识的意图——当你对你的应用一无所知时，不要构建一个架构。这是探索这个想法的阶段:ARCore是否会允许渲染这样的书，或者它会很慢而且有问题？这是学习AR和尝试AR的阶段，学习应该是有趣和专注的。我可以很容易地改变这个例子中的任何东西，因为它还没有结构。它没有一个结构，因为我还不知道它应该做什么。</p><blockquote class="mo mp mq"><p id="2180" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">🧘‍♀️:让原型尽可能简单，你就能获得大部分乐趣。不要被干净激怒——你正在开发你的原型，而不是最好的通用架构。</p></blockquote><h1 id="e45e" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">我们到底需要多少尖叫？</h1><p id="5829" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我的<a class="ae kx" href="https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html" rel="noopener ugc nofollow" target="_blank">架构尖叫</a>是为了什么？从上面的方案来看，似乎我的应用程序正在某个地方登录，并在AR中做一些事情。而这正是正在发生的事情！如果我有类似于<a class="ae kx" href="https://github.com/android10/Android-CleanArchitecture" rel="noopener ugc nofollow" target="_blank">和</a>的东西，会不会更好？</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/9a011e9a268786c7524ee9602a6bced9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wCFPXmaepDqUtwMSuInlA.png"/></div></div></figure><p id="e5ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这尖叫够了吗？这个示例显示了用户和用户的详细信息，但是它包含了足够控制一次小型导弹发射的体系结构储备。我在原型阶段需要它吗？我想不会。如果我需要花几分钟遍历文件夹来找出那个东西是做什么的——它不会尖叫。但是让我们看看，当项目开始发展时会发生什么。</p><blockquote class="mo mp mq"><p id="38ae" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">🧘‍♀️太多的建筑噪音会让你头疼。</p></blockquote><h1 id="9df9" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">用户界面和导航组件</h1><p id="294d" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">再来加点UI吧！</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi na"><img src="../Images/da1fd6ac4d3abca914077bb79bd5bf5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwXoxzAmuP_eyxHfkKGFiQ.png"/></div></div></figure><p id="a9df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">移动应用的用户界面通常会宣布你开始使用用例的阶段。Simon关于Clean有一个很好的观点——像web或mobile <a class="ae kx" href="http://www.codingthearchitecture.com/2011/11/06/the_delivery_mechanism_is_an_annoying_detail.html" rel="noopener ugc nofollow" target="_blank">这样的“烦人的交付机制”可能会非常大</a>。我非常同意。</p><p id="6bc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你第一次打开某个不知名的app，你想抓住那个东西是做什么的时候，你会怎么做？一开始你真的关注实体吗(比如用户数据类或者DefaultObserverInterface)？我看着屏幕。因为这通常比任何其他部分都更能体现用例。自从<a class="ae kx" href="https://developer.android.com/guide/navigation/navigation-getting-started" rel="noopener ugc nofollow" target="_blank">导航组件</a>以来，我们有了一个很好的工具</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nb"><img src="../Images/62f92dc0b5533bdf8e23353106a18503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTTCTrDU2MkAyyI7KuBWmw.png"/></div></div></figure><blockquote class="mo mp mq"><p id="63e3" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">🧘‍♀️导航图给你很大的应用地图。</p></blockquote><p id="5848" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这仍然是一个早期版本，它有一些深层链接的问题，但优势太诱人，不容忽视。</p><h1 id="9fdb" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">添加一些逻辑</h1><p id="f5c2" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">为了在架构上做更多的工作，让我们添加一个新的特性—一个新的图书放置(分配)。我的灵感来自著名的玛格丽特·哈米尔顿照片:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nc"><img src="../Images/4106fd73ec7ea7d898c5fe07ffae58da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEsGzJDTByoIRfoxtuhLHA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">您可以在google play制作自己的照片=)</figcaption></figure><p id="17d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以现在我们开始了解我们的应用程序是关于什么的。从这里我们可以更好地想象未来我们可以添加什么。现在是时候添加一些架构了。</p><blockquote class="mo mp mq"><p id="8e96" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">🧘‍♀️只有当你做了一些逻辑工作，并且可以预测你的应用程序在几次迭代后会是什么样子的时候，你才可以开始绘制实体和层。</p></blockquote><h1 id="f9f5" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">清洁和MVVM</h1><p id="0f6f" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">让我们来看看谷歌<a class="ae kx" href="https://developer.android.com/jetpack/docs/guide" rel="noopener ugc nofollow" target="_blank">建筑指南</a>和并排清理:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nh"><img src="../Images/cd63730dc72985b6766f9d9ef11cb58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqzzNpCUd6h8kK5EDHdGNQ.png"/></div></div></figure><p id="c0f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并尽力将这两个指南合并，看看我们会得到什么。在我的例子中，我将以这个结尾:</p><div class="mh mi mj mk gt ab cb"><figure class="ni ml nj nk nl nm nn paragraph-image"><img src="../Images/a8ef35f676182cf4d982188045891452.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*L8sDS18Dy9PEIKPXS4vajQ.png"/></figure><figure class="ni ml no nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><img src="../Images/c88fdbe0f82a6d4bc1e8b08a41d3d5d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*5h9QyCItMAFMeV8lzWozUw.png"/></div></figure></div><blockquote class="mo mp mq"><p id="131f" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">🧘‍♀️·谷歌的指南关注最外层的干净层，它把实体和用例留给了开发者。</p></blockquote><p id="a9ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您和我一样，对您的“企业业务规则”(定义实体的简明建议)感到困惑，您可以尝试使用以下规则:</p><blockquote class="mo mp mq"><p id="6dc0" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">🧘‍♀️良好的实体和用例层应该允许在跨平台解决方案中重用它。您应该能够在iOS应用程序中重用这些代码(例如，使用Kotlin Native)。</p></blockquote><p id="4965" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这比鲍勃叔叔的定义稍微具体一些，但我发现它很有用。我留下了单词<em class="mr"> _some_ </em>，因为大多数项目永远不需要跨平台，这没关系。它可能会也可能不会自动实现，但理想情况下，您应该能够实现它，并且您的架构设计将从中受益。</p><p id="0aaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们简单地列出通常会妨碍你的是什么？</p><h1 id="d888" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">语境</h1><p id="6f22" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">android中最明显的上下文类。你总是需要上下文来做事情。我的BookFactory需要colors.xml中的颜色常量。这里有一个简单传递上下文的诱惑，但是有一个更好的解决方案—资源提供者:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dc6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SingletoneHolder您可以在这里获取—<a class="ae kx" href="https://medium.com/@BladeCoder/kotlin-singletons-with-argument-194ef06edd9e" rel="noopener">Kotlin singletons with argument</a>(像双重检查锁定这样的行为最好实现一次，然后重用)。现在我的clean class BookFactory依赖于这样的ResourceProvider，而不是Android上下文本身。在跨平台中，将有两种不同的实现(您将提供一个公共的共享接口)。</p><p id="395c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个常见的例子是图像加载，这种方法也很有效:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="eb65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们的BookFactory终于干净了(没有android导入)，但继续使用图像加载并从资源文件中获取颜色:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="np nq l"/></div></figure><blockquote class="mo mp mq"><p id="1bec" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">当你不记得你正在编程什么操作系统的时候，🧘‍♀️可以随意停止提供者。如果您还有时间，请随意将接口从实现中分离出来(您将获得输入/输出端口)</p></blockquote><h1 id="db1f" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">模型/实体</h1><p id="4a3d" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">clean attendant有时声明我们应该在每一层有多个不同的模型，并有一堆接口适配器来转换/映射它们。在移动项目中，我经常违反这样的规则:即使是REST模型也经常针对UI进行设计。如果您的UI显示了实体中的每个(或几乎每个)字段，这似乎没问题。更多关于这个的讨论你可以在这里找到<a class="ae kx" href="https://softwareengineering.stackexchange.com/questions/303478/uncle-bobs-clean-architecture-an-entity-model-class-for-each-layer/303480#303480" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="ed1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae kx" href="https://play.google.com/store/apps/details?id=com.intmainreturn00.bookar" rel="noopener ugc nofollow" target="_blank"> Bookar </a>中，我使用了两套模型:一套是从<a class="ae kx" href="https://github.com/intmainreturn00/grapi" rel="noopener ugc nofollow" target="_blank"> grapi </a>库(网络层)获得的，另一套是从它转换成实体/模型，然后用于房间、UI和用例。是的，我不能像跨平台那样重用它(因为房间的实体规范)，但另一方面，我有一个Book类用于整个应用程序，而不是许多。但Room在这里只是Android依赖。例如，我对原语使用了接口适配器，可以从Sceneform导入:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="np nq l"/></div></figure><blockquote class="mo mp mq"><p id="de03" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">🧘‍♀️:如果你有时不区分UI模型和实体模型，不要难过。它发生了。如果你的UI使用你的实体而没有不需要的映射，这并不违反依赖规则。</p></blockquote><h1 id="0220" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">深层链接</h1><p id="71fd" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">简单的OAuth登录流程包括将用户发送到浏览器并捕获深层链接重定向。对于浏览器意图，你需要上下文。为了捕捉深层链接，您需要活动(因为清单中的<a class="ae kx" href="https://developer.android.com/training/app-links/deep-linking" rel="noopener ugc nofollow" target="_blank"> intent-filter声明</a>可能只与活动相关)。所以很难完全在UI层之外实现登录用例。</p><blockquote class="mo mp mq"><p id="de47" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">🧘‍♀️Deep链接导致疼痛。与早期导航控制器的深度链接导致更多的痛苦。</p></blockquote><h1 id="2abe" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">实时数据、预处理和嵌套回收视图</h1><p id="233b" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">另一个伟大的架构组件是<a class="ae kx" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank"> LiveData </a>。这里讨论的<a class="ae kx" href="https://medium.com/androiddevelopers/viewmodels-and-livedata-patterns-antipatterns-21efaef74a54" rel="noopener">基地使用模式</a>。这里的<a class="ae kx" href="https://medium.com/androiddevelopers/coroutines-on-android-part-iii-real-work-2ba8a2ec2f45" rel="noopener">详细描述了常见用例(“一次性请求”)。有些出版物特别强调</a><a class="ae kx" href="https://medium.com/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150" rel="noopener">流播事件</a>的恶行，而不是国家。但是在我的具体例子中，我嵌套了回收器视图。而且我还需要在展示它们之前，对每本书逐一进行预处理。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/16b22d98c349949173f16d576635c160.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*f2UG1wygpF3UowQ6rMSJXA.png"/></div></figure><p id="3dd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，<a class="ae kx" href="https://medium.com/@iammert/using-diffutil-in-android-recyclerview-bdca8e4fbb00" rel="noopener">流状态+使用Maers算法</a> (DiffUtils)进行RecyclerView的常见模式在这里不起作用。由于预处理可能会花费很多时间，并且用户希望看到进度更新，所以我最终流式处理事件:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bb73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，如果用户在应用程序之间切换，progress可能会丢失几本书。是的，流式事件不好。但是使用DiffUtils对多个嵌套列表进行顺序更新更糟糕。您可以通过在处理结束时更新数据库来恢复最终状态，在事务内<a class="ae kx" href="https://github.com/intmainreturn00/Bookar/blob/master/app/src/main/java/com/intmainreturn00/bookar/data/BooksRepository.kt" rel="noopener ugc nofollow" target="_blank">——这样您将在结束时同步状态。</a></p><blockquote class="mo mp mq"><p id="9142" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">🧘‍♀ ️Sometimes通过LiveData直播部分赛事是最佳方式。不要忘记通过事务更新从数据库同步最终状态。</p></blockquote><h1 id="f27c" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">包名</h1><p id="50b3" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">对于组织包装结构，切哈斯的方案(<a class="ae kx" href="https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" rel="noopener ugc nofollow" target="_blank">android architecture——the clean way</a>)显然成为Android世界的默认方式。在该方案中，清洁圈被组织成这样的子层:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b4ad7be66e3853a83ffebf0e19af0f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/0*O7A8QRBBXXhOXcbC.png"/></div></figure><h1 id="5153" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结果</h1><p id="0e8c" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">长话短说——我添加了一些功能，重写了这个非常好用的应用程序，并记录了一些关于android应用程序架构的想法。最终的解决方案似乎具有更好的灵活性和结构。是的，它仍然有效。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nt"><img src="../Images/eb50a73cbd32081304dd7d81a495716a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYXxPrVOevwdaB6uNMj1eg.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">谁是好孩子？</figcaption></figure><blockquote class="mo mp mq"><p id="e70a" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">在<a class="ae kx" href="https://play.google.com/store/apps/details?id=com.intmainreturn00.bookar" rel="noopener ugc nofollow" target="_blank">Google play</a>🧘‍♀checkout应用，在<a class="ae kx" href="https://github.com/intmainreturn00/Bookar" rel="noopener ugc nofollow" target="_blank"> GitHub </a>查看完整源代码。</p><p id="6b17" class="jq jr mr js b jt ju jv jw jx jy jz ka ms kc kd ke mt kg kh ki mu kk kl km kn im bi translated">欢迎拉要求和评论！</p></blockquote><h1 id="68ae" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">链接</h1><ol class=""><li id="4ded" class="ko kp it js b jt mb jx mc kb nu kf nv kj nw kn kt ku kv kw bi translated"><a class="ae kx" href="https://blog.cleancoder.com/uncle-bob/2011/11/22/Clean-Architecture.html" rel="noopener ugc nofollow" target="_blank">干净的建筑</a></li><li id="747b" class="ko kp it js b jt ky jx kz kb la kf lb kj lc kn kt ku kv kw bi translated"><a class="ae kx" href="http://www.codingthearchitecture.com/2011/11/06/the_delivery_mechanism_is_an_annoying_detail.html" rel="noopener ugc nofollow" target="_blank">交付机制是一个恼人的细节...</a></li><li id="512e" class="ko kp it js b jt ky jx kz kb la kf lb kj lc kn kt ku kv kw bi translated"><a class="ae kx" href="https://developer.android.com/jetpack/docs/guide" rel="noopener ugc nofollow" target="_blank">应用架构指南</a></li><li id="fe10" class="ko kp it js b jt ky jx kz kb la kf lb kj lc kn kt ku kv kw bi translated">заблуждения清洁建筑</li><li id="a496" class="ko kp it js b jt ky jx kz kb la kf lb kj lc kn kt ku kv kw bi translated"><a class="ae kx" href="https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" rel="noopener ugc nofollow" target="_blank">构建Android……干净的方式？</a></li></ol></div></div>    
</body>
</html>