<html>
<head>
<title>Simplify your GraphQL API Strategy using Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用接口简化您的GraphQL API策略</h1>
<blockquote>原文：<a href="https://itnext.io/leveraging-graphql-schema-and-interfaces-4bfa9b72d6b2?source=collection_archive---------3-----------------------#2019-02-26">https://itnext.io/leveraging-graphql-schema-and-interfaces-4bfa9b72d6b2?source=collection_archive---------3-----------------------#2019-02-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0aee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最近的一篇文章<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/exploring-tokens-with-stellar-291172208639">探索带有Stellar </a>的令牌中，我顺便提到了我们在创建GraphQL模式时是如何用额外的<code class="fe km kn ko kp b">context</code>来增强一些<a class="ae kl" href="https://www.stellar.org/" rel="noopener ugc nofollow" target="_blank"> Stellar </a>数据对象的。这种方法在定义我们的数据模型时提供了很大的灵活性。在本文中，我将展示一种利用GraphQL接口来简化这些修饰数据对象的客户端编程模型体验的方法。</p><p id="c858" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">作者注:</strong>由于对这个话题的强烈兴趣，我们于2019年3月14日在GitHub上发布了组织<a class="ae kl" href="https://github.com/token-factory" rel="noopener ugc nofollow" target="_blank"> token-factory </a>下的源代码。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/34a5d485facb099ef321b633c37f0572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jsmn0syiDtI839lw43HDw.png"/></div></div></figure><h1 id="c24f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">接口作为GraphQL返回类型</h1><p id="2d59" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我发现使用具体的例子通常有助于传达我试图理解的整体概念。因为我最近的焦点主要在Stellar上，所以我将使用Stellar的一个名为<code class="fe km kn ko kp b">Asset</code>的核心数据类型。为了创建资产，我们定义了一个负责资产创建的<code class="fe km kn ko kp b">mutation</code>。</p><pre class="kr ks kt ku gt mf kp mg mh aw mi bi"><span id="777b" class="mj ld iq kp b gy mk ml l mm mn">"Create a new asset owned by an existing Account"<br/>    createAsset(<br/>      "Alphanumeric code that uniquely identifies the asset"<br/>      asset_code: String!<br/>      "Public key of the asset issuer (creator)"<br/>      asset_issuer: String!<br/>      "The description of the asset"<br/>      description: String<br/>    ): Asset</span></pre><p id="7c86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们利用Stellar SDK来创建资产。有效载荷的输入包括核心恒星数据对象，如asset_code，但也包含附加元数据，这些元数据存储在我们自己的本地数据库中，供我们在系统中使用。为了在后一个版本中实现最大的灵活性，我们定义了一个名为<code class="fe km kn ko kp b">Asset</code>的<code class="fe km kn ko kp b">interface</code>，它将允许我们根据正在使用的API返回<code class="fe km kn ko kp b">Asset</code>的变体，同时也为我们的前端开发人员提供一些提示，以指示正在返回哪个<code class="fe km kn ko kp b">implementation</code>接口。</p><h1 id="1e07" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">资产实现</h1><p id="21ea" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">移动到<code class="fe km kn ko kp b">interfaces</code>的决定并不是从一开始就做好的。在我们API策略的早期版本中，我们为每个API创建了定制的数据对象，很少重用模式对象。当我们开始简化编程模型时，我们觉得接口是最好的方法。这背后的基本原理实际上是关于我们如何返回<code class="fe km kn ko kp b">Asset</code>信息。资产是核心数据对象，包含在Stellar的许多API中，包括支付、报价和历史查询。对于这些API，返回我们完全修饰的名为<code class="fe km kn ko kp b">TF_Asset</code>的<code class="fe km kn ko kp b">Asset</code>实现是有益的，而对于更昂贵的查询，我们认为只返回直接映射到Stellar的轻量级<code class="fe km kn ko kp b">Core_Asset</code>就足够了。</p><p id="7822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是<code class="fe km kn ko kp b">Asset</code>的两个实现，用于比较。</p><pre class="kr ks kt ku gt mf kp mg mh aw mi bi"><span id="3e47" class="mj ld iq kp b gy mk ml l mm mn">type Core_Asset implements Asset {<br/>    "Public key of the asset issuer (creator)"<br/>    asset_issuer: String<br/>    "Alphanumeric class that identifies the asset type"<br/>    asset_type: String!<br/>    "Alphanumeric code that uniquely identifies the asset"<br/>    asset_code: String<br/>  }</span><span id="ed8a" class="mj ld iq kp b gy mo ml l mm mn">type TF_Asset implements Asset {<br/>    "Public key of the asset issuer (creator)"<br/>    asset_issuer: String<br/>    "Alphanumeric class that identifies the asset type"<br/>    asset_type: String!<br/>    "Alphanumeric code that uniquely identifies the asset"<br/>    asset_code: String<br/>    "The description of the asset"<br/>    description: String<br/>    "Email address for user.  Will be used as display name"<br/>    email: String!<br/>    "Tenant id that the user is a member of"<br/>    tenantId: String!<br/>    "Creation date of the asset"<br/>    createdAt: Date!<br/>    "Last modified date of the asset"<br/>    updatedAt: Date!<br/>  }</span></pre><h1 id="00de" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在模式中表示资产类型</h1><p id="080a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">由于存在两种可能的实现，包含资产的API的消费者需要提示来知道返回的是什么类型的资产。在我们的简单模型中，很容易根据<code class="fe km kn ko kp b">Asset</code>的一个必需字段进行识别，该字段只有在类型为<code class="fe km kn ko kp b">TF_Asset</code>时才会存在。GraphQL支持通过定义解析器来表示类型的能力。在我们的解析器中，我们创建了一个基本的if/else检查来处理这个问题。</p><pre class="kr ks kt ku gt mf kp mg mh aw mi bi"><span id="ef95" class="mj ld iq kp b gy mk ml l mm mn">Asset: {<br/>        __resolveType(obj, context, info){<br/>            if(obj.tenantId){<br/>                return 'TF_Asset';<br/>            }<br/>            return 'Core_Asset';<br/>        },<br/>    },</span></pre><p id="bb2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然超出了本文的范围，但让我展示一个更高级的解析器版本。对于我们的<code class="fe km kn ko kp b">History</code> API，我们返回一组<code class="fe km kn ko kp b">History</code>对象，其中的每个记录都可以是<code class="fe km kn ko kp b">interface</code>的不同<code class="fe km kn ko kp b">implementation</code>的一个。对于那个<code class="fe km kn ko kp b">interface</code>，解算器变得更高级一点，但遵循相同的模型。</p><pre class="kr ks kt ku gt mf kp mg mh aw mi bi"><span id="f671" class="mj ld iq kp b gy mk ml l mm mn">History: {<br/>        __resolveType(obj, context, info){<br/>            if(obj.type === 'create_account'){<br/>                return 'Create_Account';<br/>            }<br/>            if(obj.type === 'change_trust'){<br/>                return 'Change_Trust';<br/>            }<br/>            if(obj.type === 'allow_trust'){<br/>                return 'Allow_Trust';<br/>            }<br/>            if(obj.type === 'payment'){<br/>                return 'Payment';<br/>            }<br/>            if(obj.type === 'manage_offer'){<br/>                return 'Manage_Offer';<br/>            }<br/>            if(obj.type === 'set_options'){<br/>                if(obj.signer_key || obj.signer_weight){<br/>                    return 'Set_Signers';<br/>                }else if(obj.clear_flags || obj.set_flags){<br/>                    return 'Account_Flags';<br/>                }else{<br/>                    return 'Set_Threshold';<br/>                }<br/>            }<br/>            return null;<br/>        },<br/>    },</span></pre><h1 id="9c6c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">客户端编程模型</h1><p id="4a6a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">当执行处理<code class="fe km kn ko kp b">interfaces</code>的GraphQL查询时，在如何访问实现特定的数据字段方面有一个小的修改。下面是获取已创建资产的查询，其中我们不仅包括核心<code class="fe km kn ko kp b">Asset</code>数据，还包括来自<code class="fe km kn ko kp b">TF_Asset</code>的一些附加数据</p><pre class="kr ks kt ku gt mf kp mg mh aw mi bi"><span id="7346" class="mj ld iq kp b gy mk ml l mm mn">export const GET_ASSETS = gql`<br/>  query getAssets {<br/>    getAssets {<br/>      asset_code<br/>      asset_issuer<br/>      ... on TF_Asset {<br/>        description<br/>        tenantId<br/>        email<br/>        createdAt<br/>        updatedAt<br/>      }<br/>    }<br/>  }<br/>`;</span></pre><p id="98f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意TF_Asset周围的语法，以…开头，这向<a class="ae kl" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> GraphQL Apollo Client </a>表示这些字段只存在于类型为<code class="fe km kn ko kp b">TF_Asset</code>的数据对象中。如果记录不是类型<code class="fe km kn ko kp b">TF_Asset</code>，那么这些字段将不会被请求。这为数据模型提供了一些灵活性，我们可以将描述、tenantId和email等字段表示为<code class="fe km kn ko kp b">TF_Asset</code>所必需的，而不是其他<code class="fe km kn ko kp b">Asset</code>类型所必需的。</p><h1 id="3a4b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="f5bf" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在GraphQL中，接口是一个非常强大的构造，尤其是在试图构建一个包含许多数据类型的复杂GraphQL数据模式时。上面的文章展示了一组快速简单的例子，围绕创建一个<code class="fe km kn ko kp b">interface</code>很好地映射到恒星。我发现<code class="fe km kn ko kp b">interfaces</code>极大地改进了我们API的整体设计，并且可以在一本书中写下一章来介绍我们所有的接口用法，但是这已经超出了本文的范围。</p></div></div>    
</body>
</html>