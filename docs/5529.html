<html>
<head>
<title>Building Git in Elixir — Part 4 (Store Nested Trees as Merkle Tree)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Elixir中构建Git第4部分(将嵌套树存储为Merkle树)</h1>
<blockquote>原文：<a href="https://itnext.io/building-git-in-elixir-part-4-store-nested-trees-as-merkle-tree-1a236882215a?source=collection_archive---------2-----------------------#2021-03-25">https://itnext.io/building-git-in-elixir-part-4-store-nested-trees-as-merkle-tree-1a236882215a?source=collection_archive---------2-----------------------#2021-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="977e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/building-git-in-elixir-part-3-make-history-store-executables-e7dbb39e8e47">上一篇文章</a>中，我关注于创建历史并将可执行文件存储在存储库中。在本文中，我将通过将嵌套树构建为Merkle树来关注在存储库中存储嵌套目录[5]。</p><h1 id="0281" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">一点理论</h1><p id="d8f5" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">Git将嵌套目录存储为嵌套树，每棵树都是Merkle树。来自维基百科对Merkle树的定义—</p><blockquote class="ls"><p id="5abb" class="lt lu it bd lv lw lx ly lz ma mb kn dk translated"><em class="mc">是一棵</em> <strong class="ak"> <em class="mc">哈希树</em> </strong> <em class="mc">或</em> <strong class="ak"> <em class="mc"> Merkle树</em> </strong> <em class="mc">是一棵</em> <a class="ae ko" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank"> <em class="mc">树</em> </a> <em class="mc">其中每一个</em> <a class="ae ko" href="https://en.wikipedia.org/wiki/Leaf_node" rel="noopener ugc nofollow" target="_blank"> <em class="mc">叶节点</em> </a> <em class="mc">都标有一个数据块的</em> <a class="ae ko" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" rel="noopener ugc nofollow" target="_blank"> <em class="mc">密码哈希</em> </a> <em class="mc">，并且散列树允许对大型</em> <a class="ae ko" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank"> <em class="mc">数据结构</em> </a>的内容进行高效且安全的验证</p></blockquote><p id="c866" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">从Git的角度来看，这意味着—当我们比较两个提交的两棵树时，如果两个树条目具有相同的散列ID，我们知道它们的内容完全相同，我们可以完全跳过它们。这是一个巨大的性能胜利，而且减少了冗余数据在网络上的传输。同样的数据结构也是在<strong class="js iu">Bitcon</strong>【6】中使用的分布式共识协议的基础。</p><p id="22c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于本文，我们将考虑如下的目录结构—</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/6673289cfb4d7ee32ec24e03f19ad3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7t-tbstofWFii_UPsoeUJA.png"/></div></div></figure><p id="9c38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们在Git中提交它，并使用<code class="fe mu mv mw mx b">git cat-file -p</code>命令检查提交和树，我们可以看到嵌套的树以模式<strong class="js iu"> 040000 — </strong>存储</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi my"><img src="../Images/117de95210a4616df0814e73c47ddd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cnkr3m0Y9spmVUujWnc_1g.png"/></div></div></figure><p id="1f15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里<strong class="js iu"> e.txt </strong>文件存储在<strong class="js iu"> a/b/c/d </strong>路径中，正如我们所看到的，这些目录中的每一个都被存储为一个有权限的树<strong class="js iu"> 040000 </strong>。</p><h1 id="17de" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">本文的重点</h1><p id="7e03" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在本文中，重点是复制这种行为，以便<strong class="js iu"> egit commit </strong>可以—</p><ul class=""><li id="5a02" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated">将嵌套目录存储为嵌套树</li><li id="253b" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">每棵树都存储为Merkle树</li></ul><h1 id="b440" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">仙丹代码演练</h1><p id="d8c4" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">本文的最终代码可以在这里获得—<a class="ae ko" href="https://github.com/imeraj/elixir_git" rel="noopener ugc nofollow" target="_blank">https://github.com/imeraj/elixir_git</a></p><p id="5f1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">存储库中的<strong class="js iu"> README </strong>文件包含构建<strong class="js iu"> egit </strong>的指令，以及如何使用<strong class="js iu"> git init </strong>和更新的<strong class="js iu"> git commit </strong>命令。</p><h2 id="3187" class="nn kq it bd kr no np dn kv nq nr dp kz kb ns nt ld kf nu nv lh kj nw nx ll ny bi translated"><strong class="ak">存储嵌套树</strong></h2><p id="06c0" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">为了支持构建嵌套树，我在<strong class="js iu">条目</strong>类型中添加了一些助手方法，如下所示</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="248d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="974b" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated"><strong class="js iu">第14–17行— </strong>实现<strong class="js iu"> parent_dirs() </strong>函数，给定一个条目返回所有父目录。因此，如果<strong class="js iu"> entry.name </strong>包含“a/b/c/d/e.txt”，输出将类似于—</li></ul><blockquote class="ob oc od"><p id="ef87" class="jq jr oe js b jt ju jv jw jx jy jz ka of kc kd ke og kg kh ki oh kk kl km kn im bi translated">iex(3)&gt; entry . parent _ dirs(entry)<br/><strong class="js iu">[" a "、" a/b "、" a/b/c "、" a/b/c/d"] </strong></p></blockquote><ul class=""><li id="bec2" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated"><strong class="js iu">第40–55行— </strong>实现了<strong class="js iu"> descend() </strong>函数，其工作原理类似于Ruby的<a class="ae ko" href="https://apidock.com/ruby/Pathname/descend" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> descend() </strong> </a>方法。注意:我在Elixir的标准库中找不到它的实现，所以我必须创建一个。</li><li id="01d2" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated"><strong class="js iu">第10行— </strong>添加新的目录模式</li></ul><p id="56b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">新增的<strong class="js iu">布局</strong>类型负责构建嵌套树和条目的布局—</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2e4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="a638" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated"><strong class="js iu">第23–29行— </strong>实现了<strong class="js iu"> build() </strong>函数，该函数构建了树和条目的完整布局。它首先按名称对作为参数给出的顶级条目进行排序，然后使用<strong class="js iu"> Enum.reduce </strong>从空树开始构建布局。</li><li id="b3d2" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated"><strong class="js iu">第8–21行— </strong>为<strong class="js iu"> add_entry() </strong>函数实现了两个子句，一个是当parent为空[]时，另一个是当有parent时(对于嵌套目录)。在我们的示例目录结构中，一个示例调用将是—</li></ul><blockquote class="ob oc od"><p id="cf9e" class="jq jr oe js b jt ju jv jw jx jy jz ka of kc kd ke og kg kh ki oh kk kl km kn im bi translated">add_entry(["bin"]，Entry(name="bin/egit "))</p><p id="a175" class="jq jr oe js b jt ju jv jw jx jy jz ka of kc kd ke og kg kh ki oh kk kl km kn im bi translated">add_entry([]，Entry(name="hello.txt "))</p><p id="96b0" class="jq jr oe js b jt ju jv jw jx jy jz ka of kc kd ke og kg kh ki oh kk kl km kn im bi translated">add_entry([]，Entry(name="world.txt "))</p><p id="99aa" class="jq jr oe js b jt ju jv jw jx jy jz ka of kc kd ke og kg kh ki oh kk kl km kn im bi">…</p></blockquote><p id="919a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对<strong class="js iu"> Layout.build() </strong>调用的整个输出结果是—</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="55a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="oe">注</em> </strong> <em class="oe">:我可以只存储每个条目的模式，而不是整个统计信息，以节省内存，因为我们只需要这些。可能是将来要重构的东西。</em></p><p id="bc41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从现在开始，我将每个条目存储为一个散列值(<strong class="js iu"> "a" = &gt; %Egit)。Types.Tree </strong>，我不得不更新<strong class="js iu"> Tree.to_s() </strong>函数来解决这个问题。此外，由于现在我需要根据条目是属于类型<strong class="js iu">条目</strong>还是<strong class="js iu">树</strong>来返回正确的模式，<strong class="js iu"> Tree.to_s() </strong>已经更新，以解决如下问题—</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oi"><img src="../Images/df61469b3c0140f78a5deafcf31d955f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zf_QHfrhqGXBOhTxEuHUKA.png"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated">Tree.to_s()</figcaption></figure><p id="2bfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> commit.ex </strong>已更新为—</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi on"><img src="../Images/4944419cdaa4707fadb77af8f49cb6df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWeh1yWvnhzDwf9Y08XzoQ.png"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated"><a class="ae ko" href="https://github.com/imeraj/elixir_git/blob/main/lib/commit.ex" rel="noopener ugc nofollow" target="_blank">https://github . com/imeraj/elixir _ git/blob/main/lib/commit . ex</a></figcaption></figure><p id="0082" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它现在构建布局(第31行)并调用<strong class="js iu"> traverse() </strong>函数递归地遍历构建的布局。在每个步骤中，它计算每个父节点的内容和oid，并将树存储在数据库中。<strong class="js iu"> traverse() </strong>函数有两个子句，如下所示</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oo"><img src="../Images/24ba40b4428b85a8ecd79c2456d2e4ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qO4QZ4gAOsvFLSFtvOsWeg.png"/></div></div></figure><p id="fccd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="9002" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated"><strong class="js iu">第49–63行— </strong>在处理<strong class="js iu">树</strong>时实现了第一个子句。它遍历根之前的所有叶子，并通过对它们调用<strong class="js iu"> Tree.build_content() </strong>函数来更新父树。在每个步骤中，在构建内容之后，它还使用<strong class="js iu"> Database.store() </strong>函数将树保存在数据库中。</li><li id="fdf6" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated"><strong class="js iu">第65行— </strong>实现为<strong class="js iu">条目</strong>执行的第二个子句，并返回该条目</li></ul><p id="343e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Tree.build_content() </strong>现在看起来如下(在以前的文章中它曾经被称为build_tree()并驻留在commit.ex中)—</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi op"><img src="../Images/21eb1cb89e200ae35a362efea81986fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBSeUB_yZsEojdTLupAOuQ.png"/></div></div></figure><h1 id="0d9f" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">带着埃吉特去兜风</h1><p id="cb37" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在这个阶段，<strong class="js iu"> commit </strong>命令能够存储嵌套的树。如果我提交示例目录并检查存储的树，我们可以看到—</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/0ef4f79e1c2d7d0020b3c9efad8fd6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6BMqyjWowYZ-H2Ns5mRAKQ.png"/></div></div></figure><p id="b80e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">来自<strong class="js iu"> git的输出显示</strong></p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oq"><img src="../Images/c745ba9847e267943ab62705b81c5e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxIFG5VJZDpMCtJ3hKYkqA.png"/></div></div></figure><h1 id="df42" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="c86c" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在本系列文章的第4部分中，我更新了<strong class="js iu"> egit commit </strong>命令，将嵌套子目录存储为嵌套树，其中每棵树本质上都是一棵Merkle树。在下一篇文章中，我将重点介绍构建索引和实现基本版本的<strong class="js iu"> Git add </strong>命令。</p><p id="29c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="oe">更多详细和深入的未来技术帖子，请关注我这里或上</em><a class="ae ko" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"><em class="oe">Twitter</em></a><em class="oe">。</em></p><h1 id="839d" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">参考</h1><ol class=""><li id="1fd2" class="mz na it js b jt ln jx lo kb or kf os kj ot kn ou nf ng nh bi translated"><a class="ae ko" href="https://elixir-lang.org/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank">https://elixir-lang.org/getting-started/introduction.html</a></li><li id="9aa0" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ou nf ng nh bi translated"><a class="ae ko" href="https://elixir-lang.org/docs.html" rel="noopener ugc nofollow" target="_blank">https://elixir-lang.org/docs.html</a></li><li id="9de7" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ou nf ng nh bi translated"><a class="ae ko" href="https://git-scm.com/docs" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs</a></li><li id="49b4" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ou nf ng nh bi translated">【https://github.com/imeraj/elixir_git T42】</li><li id="4855" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ou nf ng nh bi translated"><a class="ae ko" href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Merkle_tree</a></li><li id="b97a" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ou nf ng nh bi translated"><a class="ae ko" href="https://en.wikipedia.org/wiki/Bitcoin" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Bitcoin</a></li></ol></div></div>    
</body>
</html>