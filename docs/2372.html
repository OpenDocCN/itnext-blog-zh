<html>
<head>
<title>Theming with CSS Custom Properties (variables) and calc()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CSS自定义属性(变量)和calc()进行主题化</h1>
<blockquote>原文：<a href="https://itnext.io/theming-with-css-custom-properties-variables-and-calc-a89b37ad0013?source=collection_archive---------5-----------------------#2019-05-13">https://itnext.io/theming-with-css-custom-properties-variables-and-calc-a89b37ad0013?source=collection_archive---------5-----------------------#2019-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4af6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">样式的主题化有很多用例。组件系统、定制、白色标签、暗模式/亮模式、应用程序内的差异(路线、主题、子应用程序)、可访问性。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/0f94d29d8a89a7cc990c17239154432b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRFeomkpe9Om4wQ6Esa-EQ.png"/></div></div></figure><p id="a8a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个好的主题化系统需要处理<em class="la"> DRY </em>(不要重复自己)<em class="la"> SOC </em>(关注点分离)<em class="la">系统各部分之间的松散耦合</em>(如果我在这里改变了一些东西，我需要在那里改变吗？)，我在这里称之为<em class="la">共变</em>(需要一起改变的属性-值对，比如按钮背景和按钮边框颜色)。如果这些问题得不到很好的解决，随着时间的推移，质量问题会越来越多。</p><p id="e9da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不会在这里讨论足球。本文的一个前提是，就样式而言，CSS是SOC的更好方式。我要讨论的是干燥，耦合，但主要是协变。最后是有趣的部分，我展示了普通CSS如何使用自定义属性和calc()来处理共变。</p><h1 id="b448" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第一步，简单的级联主题化</h1><p id="d2a9" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">首先，让我们考虑一下主题化的简单版本:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="de1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主题是使用级联创建的。但这是有问题的，原因有二。如果你需要更新颜色，你将不得不在CSS中所有使用主题颜色的地方改变它。当CSS增长时，这不仅仅是“查找和替换”的问题。如果相同是巧合呢？(是的，会发生这种情况。)或者RGB和HSL是否混合使用？</p><p id="eb09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一件事是，如果添加了主题，您可能还需要更新单个组件的CSS，这在系统中引入了硬耦合。</p><h1 id="a547" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">步骤2，用自定义属性进行简单的主题化</h1><p id="0b1c" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">因此，首先，您可以使用自定义属性来确保在应该使用的地方使用相同的值，并且可以从某个中心位置进行更改:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="6a92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里你至少可以确保你可以安全地更新颜色和干燥。但是你仍然需要处理耦合。为此，您可以避免使用以属性值命名的属性，例如，使用命名的配色方案作为系统的一部分。配色方案可以是类似于<em class="la">原色</em>和<em class="la">次色</em>或者<em class="la">主题色</em>和<em class="la">品牌色</em>之类的东西。这取决于你。</p><h1 id="4594" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第三步，用自定义属性进行主题化就不那么幼稚了</h1><p id="cb66" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">因此，组件不是引用特定颜色的自定义属性，而是引用配色方案中已命名的自定义属性，这也可以在不影响组件的情况下从某个中心位置进行更改。添加主题将轻而易举:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="102f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，组件引用属性<code class="fe mg mh mi mj b">--themecolor</code>，该属性的值是由主题类设置和限定的。额外的好处是可读性，因为您现在传达了属性的意图或角色。此外，您仍然可以对命名值使用自定义属性。这可能是一个好的实践，因为它降低了在添加和更改内容时意外破坏主题的风险。您只需将命名的value-property分配给schemed-property:</p><pre class="kp kq kr ks gt mk mj ml mm aw mn bi"><span id="d1de" class="mo lc it mj b gy mp mq l mr ms">--themecolor: var(--purple);</span></pre><h1 id="8892" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第4步，与calc()的共变</h1><p id="5fb6" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">到目前为止一切顺利，但是协变呢？问题是定制属性可以和calc()一起使用。一个用例可以是顶部和侧边空白，需要有一定的比例:</p><pre class="kp kq kr ks gt mk mj ml mm aw mn bi"><span id="3c3e" class="mo lc it mj b gy mp mq l mr ms">--marginSides: 30px;<br/>--marginTopBottom: calc(var(--marginSides) * .7)</span></pre><p id="73d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您更改<code class="fe mg mh mi mj b">--marginSides</code>，marginTopBottom将随之改变。因此，通过使用calc()，您可以在系统中进行协变，而无需像LESS和SASS这样的预处理器。</p><p id="f7f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也适用于颜色。我最喜欢的LESS color函数是darken()，那么，我们能在普通的CSS中做类似的事情吗？是的，当然，其中的秘密是使用HSL而不是RGB。HSL很棒，因为它将颜色分成比RGB更容易操作的属性，并且每种颜色都可以用自定义属性来表示:</p><pre class="kp kq kr ks gt mk mj ml mm aw mn bi"><span id="976e" class="mo lc it mj b gy mp mq l mr ms">--hue: 255;<br/>--saturation: 100%;<br/>--lumnosity: 87%;<br/>--themecolor: hsla(var(--hue), var(--saturation), var(--lumnosity),1);</span></pre><p id="f5d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以用于主题化和颜色值之间的共同变化，比如一些背景颜色的稍微暗一点的边框:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="91ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">颜色的变暗可以通过使用calc()改变饱和度和亮度来实现，这样系统就可以处理色调的共同变化。你需要50个色度？没问题！</p><p id="6c81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您在这支笔中看到的，一个很好的地方是，您还可以使用自定义属性来简化属性，这大大降低了意外引入系统可变性的风险:</p><pre class="kp kq kr ks gt mk mj ml mm aw mn bi"><span id="91ae" class="mo lc it mj b gy mp mq l mr ms">--themeBorder: var(--borderSize) solid var(--darkThemecolor);</span><span id="2f49" class="mo lc it mj b gy mt mq l mr ms">border: var(--themeBorder);</span></pre><p id="4804" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果需要，您仍然可以覆盖组件中的特定属性:</p><pre class="kp kq kr ks gt mk mj ml mm aw mn bi"><span id="ab49" class="mo lc it mj b gy mp mq l mr ms">.cracyButton {<br/>    border: var(--themeBorder);<br/>    border-left: 15px dotted var(--cracyColor);<br/>}</span></pre><h1 id="5162" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第五步，确保规则是按照它们应该的方式计算的</h1><blockquote class="mu"><p id="9749" class="mv mw it bd mx my mz na nb nc nd kn dk translated">自定义属性的范围是声明它们的元素，并参与级联:这种自定义属性的值来自级联算法决定的声明。【https://developer.mozilla.org/en-US/docs/Web/CSS/-*】【T2 T3】</p></blockquote><p id="e7b4" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">使用自定义属性和calc()进行主题化的技巧是，如果属性发生变化，CSS规则不会自动更新，因此如果calc()中使用的属性发生变化，您必须确保重新计算规则。</p><p id="a0c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以类似这样的事情不会起作用，因为在DOM树中向下改变属性不会自动影响。主题规则更高:</p><pre class="kp kq kr ks gt mk mj ml mm aw mn bi"><span id="deff" class="mo lc it mj b gy mp mq l mr ms">//Does not work</span><span id="6cf0" class="mo lc it mj b gy mt mq l mr ms">.themed {<br/>    --hue: var(--basichue);<br/>    --themecolor: hsla(calc(var(--hue), ...);<br/>}</span><span id="02e9" class="mo lc it mj b gy mt mq l mr ms">.procolTheme {<br/>    --hue: var(--aWhiterShadeOfPale);<br/>}</span><span id="4336" class="mo lc it mj b gy mt mq l mr ms">.hendrixTheme {<br/>    --hue: var(--purpleHaze);<br/>}</span><span id="46c5" class="mo lc it mj b gy mt mq l mr ms">&lt;main class="themed"&gt;<br/>    &lt;section class="procolTheme"&gt;...&lt;/section&gt;<br/>    &lt;section class="hendrixTheme"&gt;...&lt;/section&gt;<br/>&lt;/main&gt;</span></pre><p id="3b7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">改变顺序，或者将它们放在同一个节点上，如在笔中，将会有所帮助。</p><p id="b5b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，还有强制重新计算计算规则的可能策略。基本原则是做一些在范围内更新属性的事情。您可以稍后在流程中添加一个部分更新规则的规则。如果用例是每条路线的主题，您可以有一个带有基本主题的共享CSS，以及一个只使用所需属性覆盖规则的每条路线CSS。或者，如果路由是由框架处理的，或者如果您出于其他原因只需要在应用程序中处理不同的主题，则覆盖的CSS可以在组件中。也可以通过JavaScript添加覆盖规则。</p><p id="477d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果用例是黑暗/光明模式，并且此时浏览器都支持媒体查询<code class="fe mg mh mi mj b">prefers-color-scheme</code>，您可以在媒体查询中触发重新计算:</p><pre class="kp kq kr ks gt mk mj ml mm aw mn bi"><span id="f994" class="mo lc it mj b gy mp mq l mr ms">@media (prefers-color-scheme: dark) {<br/>    .themed {<br/>        --hue: var(--backInBlack);<br/>    }<br/>}</span></pre><p id="e05d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="la">顺便说一句:自定义属性和媒体查询对于在主题化系统中处理响应式设计非常有用，因为你真的可以最小化查询中所需的代码！</em></p><h1 id="26e2" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第六步，越过顶部</h1><p id="83ca" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">最后一个是实验性的，而不是实践性的，但是它表明您可以将基于色轮的配色方案实现为共变。但是你的设计师可能不会为此感谢你，因为它错过了让他们的一天变得美好的微调。</p><p id="b7ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这支笔所用的方案，被称为<em class="la">互补分裂</em>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/275b5c810b0b93fb41a93a8e4d46baeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/0*nIJN_gQwAUes6p7h.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">免费赠送:<a class="ae ne" href="http://www.paletton.com/wiki/index.php?title=Split_complementary_color_scheme" rel="noopener ugc nofollow" target="_blank">http://www.paletton.com/wiki/index.php?title = Split _ complementary _ color _ scheme</a></figcaption></figure><p id="9446" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于色调可以被视为色轮中的一个角度(0-360度)，因此可以很容易地导出方案中的其他颜色，就像您可以操纵饱和度和亮度一样:</p><pre class="kp kq kr ks gt mk mj ml mm aw mn bi"><span id="3760" class="mo lc it mj b gy mp mq l mr ms">--primaryHue: var(--hueBasic);<br/>--secondaryHue: calc(var(--primaryHue) + 150);<br/>--complementaryHue: calc(var(--primaryHue) + 210);</span></pre><p id="c58b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你得到的值大于360，不要担心，它只是开始另一轮。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="55a6" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="ae86" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">所以总结一下。CSS自定义属性和calc()可以帮助你处理主题化系统中的<em class="la">相同</em>、<em class="la">耦合</em>和<em class="la">共变</em>。</p><p id="510f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相同，因为自定义属性可以定义在整个系统中需要相同的值。耦合，因为自定义属性可以通过它们的角色来定义，而不仅仅是它们的值的简写。因为calc()可以使用自定义属性作为参数，所以可以通过自定义属性和calc()的组合来将值绑定在一起。</p></div></div>    
</body>
</html>