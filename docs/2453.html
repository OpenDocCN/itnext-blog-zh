<html>
<head>
<title>PHP: Setters and Getters have died</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP:setter和Getters已经死亡</h1>
<blockquote>原文：<a href="https://itnext.io/php-7-4-setters-and-getters-have-died-2cefa996d26?source=collection_archive---------3-----------------------#2019-05-27">https://itnext.io/php-7-4-setters-and-getters-have-died-2cefa996d26?source=collection_archive---------3-----------------------#2019-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="354a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">暗示的属性在这里停留</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1c8e6b4fbe8119306064e3d61b9567be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K-pfUGPDg4iXn4Zf"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">塞缪尔·泽勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="21ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PHP非常灵活，但有时开发人员为了正确使用他们的软件，不想让他们的库有太多的灵活性。不是因为他们想完全控制如何使用它，而是为了保护其他开发人员不会搞砸Github上的一个好问题并指责作者。</p><p id="02b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Getters和Setters是控件的一部分。它们的目的非常明确:只允许在类中设置某种类型的变量，并检索开发人员(安全地)期望的东西。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="df0c" class="lx ly iq lt b gy lz ma l mb mc">&lt;?php</span><span id="8af8" class="lx ly iq lt b gy md ma l mb mc">class Car<br/>{<br/>    /**<br/>     * Car Engine<br/>     *<br/>     * @var CarEngine<br/>     */<br/>    protected $engine</span><span id="bdf6" class="lx ly iq lt b gy md ma l mb mc">    /**<br/>     * Returns the Engine instance<br/>     *<br/>     * @return CarEngine<br/>     */<br/>    public function getEngine() : CarEngine<br/>    {<br/>        return $this-&gt;engine;<br/>    }</span><span id="03e5" class="lx ly iq lt b gy md ma l mb mc">    /**<br/>     * Sets a Car Engine<br/>     *<br/>     * @param CarEngine $engine<br/>     * @return void<br/>     */<br/>    public function setEngine(CarEngine $engine)<br/>    {<br/>        $this-&gt;engine = $engine;<br/>    }</span><span id="c9f7" class="lx ly iq lt b gy md ma l mb mc">}</span></pre><p id="bb81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在他们已经死了。</p><h1 id="ac36" class="me ly iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">他们是怎么死的？你在说什么？</h1><p id="cff1" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">PHP 7.4，<a class="ae kv" href="https://wiki.php.net/todo/php74" rel="noopener ugc nofollow" target="_blank">定于今年</a>11月21日发布，<a class="ae kv" href="https://wiki.php.net/rfc/typed_properties_v2" rel="noopener ugc nofollow" target="_blank">引入了类型化属性</a>。简而言之，类型化属性只允许在Class属性中设置某种类型的变量。</p><p id="9235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设我们希望<code class="fe na nb nc lt b">Car</code>类允许任何实现<code class="fe na nb nc lt b">CarEngine</code>接口的类，比如<code class="fe na nb nc lt b">GasEngine</code>或<code class="fe na nb nc lt b">ElectricEngine</code>。到目前为止，我们需要为每个属性设置一个getter和setter，以迫使开发人员只使用这些类型，正如您在上面的例子中看到的。</p><p id="54e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免直接干预这些属性，我们使用了<code class="fe na nb nc lt b">protected</code>关键字。这意味着，只能从类方法或扩展它的其他类中访问这些属性，而不能从外部访问。</p><p id="9444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果我们使用类型化的属性，那么类将只允许将该类型设置为属性，从而扼杀了getter和setter的用途。我们不需要用它作为<code class="fe na nb nc lt b">protected</code>属性，只需设置为<code class="fe na nb nc lt b">public</code>即可。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5b4f" class="lx ly iq lt b gy lz ma l mb mc">&lt;?php</span><span id="81c2" class="lx ly iq lt b gy md ma l mb mc">class Car<br/>{<br/>    /**<br/>     * Car Engine<br/>     *<br/>     * @var CarEngine $engine<br/>     */<br/>    public CarEngine $engine;</span><span id="75f7" class="lx ly iq lt b gy md ma l mb mc">    // ...</span><span id="64bf" class="lx ly iq lt b gy md ma l mb mc">}</span></pre><p id="4177" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且我们不限于阶级。你也可以把它用于最常用的字符串、数组或浮点类型的变量。</p><p id="27c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这有两个好处:</p><ul class=""><li id="5f6b" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">将类精简到最基本的功能方法。</li><li id="c1d0" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">开发人员可以直接访问属性，而不是浪费时间来检索和设置它。</li><li id="16b4" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">绕过使用getter或setter可能导致的任何方法开销。</li></ul><p id="45e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们使用我们的类。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e67d" class="lx ly iq lt b gy lz ma l mb mc">&lt;?php</span><span id="c8ca" class="lx ly iq lt b gy md ma l mb mc">$car = new SportsCar(new GasEngine, new Wheels);</span><span id="3857" class="lx ly iq lt b gy md ma l mb mc">$car-&gt;wheels-&gt;color = 'red';<br/>$car-&gt;spoiler = null; // Comes with a default but we don't need it</span><span id="ee51" class="lx ly iq lt b gy md ma l mb mc">if ($car-&gt;engine-&gt;start()) {<br/>    $car-&gt;lights-&gt;on = true;<br/>}</span></pre><p id="d15a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用老方法来比较一下:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="c801" class="lx ly iq lt b gy lz ma l mb mc">&lt;?php</span><span id="2d1d" class="lx ly iq lt b gy md ma l mb mc">$car = new SportsCar(new GasEngine, new Wheels);</span><span id="25d2" class="lx ly iq lt b gy md ma l mb mc">$car-&gt;getWheels()-&gt;setColor('red');<br/>$car-&gt;setSpoiler(null); // Comes with a default but we don't need it</span><span id="1c92" class="lx ly iq lt b gy md ma l mb mc">if ($car-&gt;getEngine()-&gt;start()) {<br/>    $car-&gt;getLights()-&gt;setOn(true);<br/>}</span></pre><p id="15b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在那个例子中，我们只使用了一个方法调用，而不是七个。我们基本上<strong class="ky ir">降低了86%的开销</strong>。</p><p id="bdd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序和框架需要一段时间来理解这一点，因为这意味着在正确地<em class="nr">键入</em>属性的同时公开一些属性，并删除类中的getters和setters。由于这是一个突破性的改变，预计一些包只兼容PHP 7.4及以后的版本。</p><h1 id="5ad3" class="me ly iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">界面困境</h1><p id="0c2e" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">还有另一个问题，或者说是两难的问题，需要更好的措辞。我们在没有接口的情况下使用了后面的例子，但是一些类必须使用它们，因为它们<em class="nr">需要</em>它们。</p><p id="4ad3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常一些接口实现getters和setters，以注意它应该有一个对象可用于设置和检索。我不认为这是一个好的实践，因为这些只是接口不打算<em class="nr">解决</em>的问题。接口是行为的契约，而不是形状，但是，嘿，这是PHP，你可以自由地做你想做的。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="9c80" class="lx ly iq lt b gy lz ma l mb mc">&lt;?php</span><span id="9ba8" class="lx ly iq lt b gy md ma l mb mc">interface Car {<br/>    public function getEngine();<br/>    public function setEngine(CarEngine $engine);</span><span id="d3dd" class="lx ly iq lt b gy md ma l mb mc">    public function startEngine();<br/>}</span></pre><p id="9a39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，为什么不在接口中使用公共属性呢？猜猜看:<strong class="ky ir">接口没有属性</strong>。如果实现一个接口的类可以为它自己的类型化属性释放setter和getter，那么用这个类替换同一个接口的另一个类将是不可靠的，因为不能保证另一个类声明了相同的属性名。在这些情况下，您必须使用getter和setter。</p><p id="fbde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如，<code class="fe na nb nc lt b">SportsCar</code>用<code class="fe na nb nc lt b">$engine</code>做引擎，而<code class="fe na nb nc lt b">ElectricCar</code>用两个引擎，分别保存在<code class="fe na nb nc lt b">$frontEngine</code>和<code class="fe na nb nc lt b">$backEngine</code>里。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5c79" class="lx ly iq lt b gy lz ma l mb mc">&lt;?php</span><span id="9ac2" class="lx ly iq lt b gy md ma l mb mc">$sportsCar = new SportsCar;<br/>$sportsCar-&gt;engine-&gt;start(); // true</span><span id="4fe9" class="lx ly iq lt b gy md ma l mb mc">$electricCar = new ElectriCar;<br/>$electricCar-&gt;engine-&gt;start(); // ERROR, the property doesn't exists</span></pre><p id="6f0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，我们应该这样做:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="063f" class="lx ly iq lt b gy lz ma l mb mc">&lt;?php</span><span id="24f1" class="lx ly iq lt b gy md ma l mb mc">interface Car<br/>{<br/>    public function startEngine();<br/>}</span><span id="42d5" class="lx ly iq lt b gy md ma l mb mc">class ElectricCar implements Car<br/>{<br/>    protected Engine $frontEngine;<br/>    protected Engine $backEngine;</span><span id="6d8c" class="lx ly iq lt b gy md ma l mb mc">    public function __construct(ElectricEngine $engine)<br/>    {<br/>        $this-&gt;frontEngine = $engine;<br/>        $this-&gt;backEngine = clone($engine);<br/>    }</span><span id="ca8c" class="lx ly iq lt b gy md ma l mb mc">    public function startEngine()<br/>    {<br/>        $this-&gt;frontEngine-&gt;start();<br/>        $this-&gt;backEngine-&gt;start();<br/>    }<br/>}</span><span id="9d8d" class="lx ly iq lt b gy md ma l mb mc">$car = new ElectricCar(new ElectricEngine);</span><span id="1fdf" class="lx ly iq lt b gy md ma l mb mc">$car-&gt;startEngine();</span></pre><p id="5b33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，接口应该更关心它的公共行为，而不是属性的getters和setters，这很好，但这意味着如果你想让开发人员处理它们，你不能(也不应该)依赖于直接访问对象属性。</p><blockquote class="ns"><p id="22c0" class="nt nu iq bd nv nw nx ny nz oa ob lr dk translated">就个人而言，我会避免访问实现某些东西的类的类型化属性。如果我把这个类换成另一个类，并且直接访问新类没有的属性，代码可能会出错，因为接口的全部意义就是使用它的方法来处理这个类应该提供的功能。</p></blockquote><p id="2521" class="pw-post-body-paragraph kw kx iq ky b kz oc jr lb lc od ju le lf oe lh li lj of ll lm ln og lp lq lr ij bi translated">随着类型提示属性开放季节的到来，开发人员肯定会对此进行一些讨论，因为为了精简代码，它强制PHP 7.4或更高版本。但是如果你为你自己的类使用类型化属性，你应该是安全的。</p></div></div>    
</body>
</html>