<html>
<head>
<title>Graph Data Modeling and ETL with dbt in NebulaGraph Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于dbt的星云图数据库图形数据建模和ETL</h1>
<blockquote>原文：<a href="https://itnext.io/graph-data-modeling-and-etl-with-dbt-in-nebulagraph-database-f1f1b0cd6766?source=collection_archive---------5-----------------------#2022-12-05">https://itnext.io/graph-data-modeling-and-etl-with-dbt-in-nebulagraph-database-f1f1b0cd6766?source=collection_archive---------5-----------------------#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="cefd" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">我们如何在表格数据源中建模数据，并将其ETL到NebulaGraph？本文向我们展示了一个使用dbt实现这一点的端到端示例。</em></p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/29f19a8d91b424ab9ce839792dfea71c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rjhUgoIvCjMHZxGD5V6pw.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">特写图片致谢:<a class="ae lf" href="https://unsplash.com/photos/Bu4lHKIHr-E" rel="noopener ugc nofollow" target="_blank">克劳迪奥</a></figcaption></figure><h1 id="b66a" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">工作</h1><p id="a1b3" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">想象一下，我们正在用NebulaGraph为内容提供商web服务构建一个知识图，从而利用它来支持知识库QA系统、推荐系统和推理系统。</p><p id="56ae" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">知识信息保存在不同的数据源中，这些数据源来自一些服务API、数据库、数据仓库，甚至是S3中的一些文件。</p><p id="ae7f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">我们需要:</p><ul class=""><li id="c0f4" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated">分析数据以提取所需的知识</li><li id="20e1" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">根据我们关心的关系对图表建模</li><li id="00bd" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">提取关系，并将其输入到NebulaGraph</li></ul><h1 id="ce41" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">数据分析</h1><p id="fa76" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">假设我们从<a class="ae lf" href="https://www.omdb.org/en/us/content/Help:DataDownload" rel="noopener ugc nofollow" target="_blank"> OMDB </a>和<a class="ae lf" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank">移动镜头</a>获取数据。</p><p id="f6cd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">OMDB是一个开放的电影数据库，我们现在认为它是我们的服务之一，我们可以获得以下信息。</p><ul class=""><li id="34ae" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated">电影</li><li id="bac4" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">电影的分类</li><li id="f57a" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">电影中的剧组(导演、动作导演、演员、后期制作等。)</li><li id="27cf" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">电影封面、宣传片等。</li></ul><p id="0a27" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">MovieLens是一个开放的数据集，我们将它视为我们服务的用户数据，我们可以获得的信息是:</p><ul class=""><li id="1775" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated">用户</li><li id="a2e1" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">电影</li><li id="21df" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">用户对电影分级的交互</li></ul><h1 id="2950" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">图形建模</h1><p id="eb59" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">我们为推荐系统构建了这个图表，并在这篇文章中讨论了一些基本方法:</p><p id="b464" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">在基于内容的过滤方法(CBF)中，涉及用户-&gt;电影、电影-&gt;类别、电影-&gt;演员和电影-&gt;导演的关系。</p><p id="1875" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">而协同过滤方法关注的是用户-&gt;电影的关系。</p><p id="3e2e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">推荐推理服务与上述所有关系有关。</p><p id="8343" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">总而言之，我们需要以下优势:</p><ul class=""><li id="dfc2" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated">观看(速率(双倍))</li><li id="231e" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">带_流派</li><li id="e105" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">导演_由</li><li id="544a" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">代理人</li></ul><p id="1399" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">相应地，对于顶点类型将是:</p><ul class=""><li id="bee7" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated">用户(用户标识)</li><li id="2c99" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">电影(名称)</li><li id="4951" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">人员(姓名，出生日期)</li><li id="51ba" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">流派(名称)</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi na"><img src="../Images/bb2c13785b96a198058df826510535cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G2_qhECKroEZsh6h.jpg"/></div></div></figure><h1 id="18d2" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">数据转换</h1><p id="4804" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">确定了源日期后，让我们看看如何将它们映射并转换成图表。</p><h1 id="7538" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">来自OMDB</h1><p id="5a94" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">首先是OMDB的数据，它由许多表组成，比如表<code class="fe nb nc nd ne b">all_movies</code>，其中存储了所有电影及其不同语言的名称。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nf"><img src="../Images/2b5ca7f7af2d6da7201183a3049d7f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pN1vshG0Tv00TtaXTlEfmQ.png"/></div></div></figure><p id="e7f0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">而<code class="fe nb nc nd ne b">all_casts</code>桌容纳了电影行业的所有角色。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/737b91c9db7d4ee658d9d9b39db7fbea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*fuasVJP7Ep6F4cBJAbHnVA.png"/></div></figure><p id="65dd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">但是这里每个人的名字和其他信息，以及他/她在影片中担任的职位，都在单独的表格中。</p><ul class=""><li id="d481" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated"><code class="fe nb nc nd ne b">job_names</code></li></ul><p id="3d73" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">例如，1代表编剧，2代表制片人。有趣的是，像电影id和名称一样，job_id到名称是一对多的关系，因为OMDB的数据是多语言的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/a28a70e930080ba5da00c477ad2d9c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*avJX8Yq1HSA8ftkq-nNepg.png"/></div></figure><ul class=""><li id="17f4" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated"><code class="fe nb nc nd ne b">all_people</code></li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/5dcac168dd8cae2c15bba18d75a77162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*W-tD0n-Nlb0VdB30Kupwig.png"/></div></figure><p id="42f5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">这是RDBMS中的一个典型情况，数据源是一个表结构，所以对于关系<code class="fe nb nc nd ne b">movie &lt;-[directed_by]-(person)</code>，涉及四个表<code class="fe nb nc nd ne b">all_movies</code>、<code class="fe nb nc nd ne b">all_casts</code>、<code class="fe nb nc nd ne b">all_people</code>、<code class="fe nb nc nd ne b">job_names</code>:</p><ul class=""><li id="bcc1" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated"><strong class="jt ir">导演_导演</strong></li><li id="c81a" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">在所有_casts中从person_id开始</li><li id="3a0e" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">到所有演员表中的电影id</li><li id="afaa" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">其中，职务id是职务名称中的“主管”</li><li id="a90b" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated"><strong class="jt ir">电影</strong></li><li id="7cc8" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">所有_casts中的person_id</li><li id="da3d" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">按id从所有_电影中命名，语言为“en”</li><li id="2e70" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated"><strong class="jt ir">人</strong></li><li id="af14" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">所有演员表中的电影id</li><li id="e04b" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">所有人的姓名、生日</li></ul><p id="ee1d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">到目前为止，我们在OMDB关心的所有桌子是:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nj"><img src="../Images/8c1de091fa4603f9567dc00e25ca1ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Et8LaK704Z4CqL33.jpg"/></div></div></figure><h1 id="d6a5" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">来自MovieLens数据集</h1><p id="0e6d" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">虽然以上只是一个数据源，但在实际场景中，我们还需要从其他来源收集数据并汇总它们。例如，现在还需要从MovieLens数据集中提取知识。</p><p id="344f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">这里，我们利用的唯一关系是:用户-&gt;电影。</p><ul class=""><li id="c88e" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated"><code class="fe nb nc nd ne b">movies.csv</code></li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f8f7253549a339c2951e4674fd1c5c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*IkSwG-FWoLa9dP7WoceVIQ.png"/></div></figure><ul class=""><li id="e607" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated"><code class="fe nb nc nd ne b">ratings.csv</code></li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3bc9e09674e98ce4774b4f5fbccaf95f.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*pLLL-BrOShfIN9foZu2VuA.png"/></div></figure><p id="3058" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">从两个表中的数据预览，自然地，我们需要一种类型的关系:<code class="fe nb nc nd ne b">watched</code>和顶点:<code class="fe nb nc nd ne b">user</code>:</p><ul class=""><li id="a388" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated"><strong class="jt ir">眼看着</strong></li><li id="b920" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">从<code class="fe nb nc nd ne b">ratings.csv</code>中的用户标识开始</li><li id="0443" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">到<code class="fe nb nc nd ne b">ratings.csv</code>中的movieId</li><li id="bd7d" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">根据<code class="fe nb nc nd ne b">ratings.csv</code>中的评级进行评级</li><li id="62a4" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated"><strong class="jt ir">用户</strong></li><li id="ba12" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">使用来自<code class="fe nb nc nd ne b">ratings.csv</code>的用户Id</li></ul><p id="29dc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">但是，你一定注意到了，MovieLens数据集中的movieId和OMDB的电影Id是两个不同的系统，如果我们需要将它们关联起来，就需要将MovieLens中的movie id转换成OMDB的电影id，它们之间的关联条件是电影标题。</p><p id="8acf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">然而，通过观察，我们知道:</p><ol class=""><li id="0cc1" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko nm ms mt mu bi translated">OMDB电影的片名是多语言的</li><li id="fb11" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko nm ms mt mu bi translated">电影镜头中的片头在片尾有类似<code class="fe nb nc nd ne b">(1995)</code>的年份信息</li></ol><p id="3a68" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">所以我们最后的结论是</p><ul class=""><li id="abfb" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated"><strong class="jt ir">眼看着</strong></li><li id="eb88" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">从<code class="fe nb nc nd ne b">ratings.csv</code>中的用户标识开始</li><li id="3b2d" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">到<code class="fe nb nc nd ne b">ratings.csv</code>中的movieId</li><li id="1a1e" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">从<code class="fe nb nc nd ne b">movies.csv</code>获取带有movieId的电影标题，并从OMDB找到它的movie _ id——我们应该在语言:英语中匹配标题，去掉年份后缀</li><li id="3073" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">根据<code class="fe nb nc nd ne b">ratings.csv</code>中的评级进行评级</li><li id="6711" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated"><strong class="jt ir">用户</strong></li><li id="17ae" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">使用来自<code class="fe nb nc nd ne b">ratings.csv</code>的用户Id</li></ul><p id="be27" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">现在，建模将两个表放在一起，如下图所示:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nj"><img src="../Images/78e39f349fe5ab58dd27e499efb94259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vkFfvcm_1Lzmq2Q-.jpg"/></div></div></figure><h1 id="f934" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">图形建模(属性图)</h1><p id="dd5e" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">总而言之，我们需要聚合来自多个数据源的不同表格(或表格形式的CSV文件)，这样对应关系如图所示:其中蓝色虚线表示图中顶点的数据信息来源，粉色虚线表示边信息来源。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nn"><img src="../Images/5518f181769c00eb528ce6d648403223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_JeiYRYZ_CuMCf1o.jpg"/></div></div></figure><p id="46bd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">然后，我们必须格式化不同表中个人的id，例如user_id，这是一个自递增的数字，我们希望将其转换为全局唯一的vertex_id。一种方便的方法是给现有的id添加一个字符串前缀，比如<code class="fe nb nc nd ne b">u_</code>。</p><p id="2e79" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">最后，对于关系<code class="fe nb nc nd ne b">user -[watched]-&gt; movie</code>，我们可以如下处理表结构数据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi no"><img src="../Images/2af19d674ea80425108949911364217c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*u4goFDzFFUFNEq3HBFycnA.png"/></div></figure><p id="9fb0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">其中，在每一行中，存在三个变量来构建图形结构:</p><ul class=""><li id="d449" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated"><code class="fe nb nc nd ne b">user</code>顶点id</li><li id="2b7c" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated"><code class="fe nb nc nd ne b">movie</code>顶点id</li><li id="67e8" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">作为<code class="fe nb nc nd ne b">watched</code>边沿属性的额定值</li></ul><h1 id="4fc9" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">工具作业</h1><p id="765d" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">至此，我们已经完成了数据分析和图形建模设计；在我们开始“提取相关性，导入图形数据库”之前，让我们介绍一下我们将使用的工具。</p><p id="6843" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">“提取关系”可以简单地认为是ETL中的提取和转换，本质上是数据映射和转换的工程，市面上有很多不同的工具和开源项目。这里我们使用我个人最喜欢的工具之一:dbt。</p><h1 id="7e91" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">dbt</h1><p id="17e7" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">dbt是一个开源的数据转换工具，拥有非常成熟的社区和生态，可以在大多数主流数据仓库中执行高效、可控、高质量的数据转换工作，无论是对于临时任务还是复杂的编排，dbt都可以非常胜任。</p><p id="fe19" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">dbt的一个特点是使用类似SQL的语言来描述数据转换的规则。使用GitOps，在大型数据团队中协作和维护复杂的数据处理操作是非常优雅的。内置的数据测试功能使您能够控制数据的质量，并使其具有可重复性和可控性。</p><p id="f9b3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">dbt不仅有许多集成的子项目，而且可以与许多其他优秀的开源项目(meltano、AirFlow、Amundsen、Superset等)结合。)要形成一套现代数据基础设施系统，请随意查看我以前的文章:数据沿袭和元数据治理参考架构<a class="ae lf" href="https://siwei.io/en/data-lineage-oss-ref-solution," rel="noopener ugc nofollow" target="_blank">https://siwei.io/en/data-lineage-oss-ref-solution,</a>整个解决方案看起来像这样:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi np"><img src="../Images/ab4c173db5cade237b6b4370437041df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*fkSBmXepFoOTjGOeKW4uQA.png"/></div></figure><p id="0a44" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">简而言之，dbt是一个用python编写的命令行工具，我们可以创建一个项目文件夹，其中包含一个YAML格式的配置文件，指定数据转换的源信息在哪里，目标在哪里(处理后的数据存储在哪里，可能是Postgres、Big Query、Spark等。).在数据源中，我们使用YAML文件和<code class="fe nb nc nd ne b">.SQL</code>文件来描述关于“从哪里获取数据，如何进行转换，以及输出什么”的信息。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nq"><img src="../Images/65c80e97289f438fd9b530769feaf528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONDD1SpOCcFcLJUdMh3w1g.jpeg"/></div></div></figure><p id="1a42" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">您可以看到，模型/示例中的信息是核心数据转换规则，所有其他数据都是与此转换相关的元数据。数据操作。</p><blockquote class="jn jo jp"><p id="4796" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">注意事项。</em></p><p id="48dc" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">可以参考dbt文档，亲自了解一下:</em><a class="ae lf" href="https://docs.getdbt.com/docs/get-started/getting-started-dbt-core" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://docs . get dbt . com/docs/get-started/getting-started-dbt-core</em></a></p></blockquote><h1 id="2142" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">星云图数据摄取</h1><p id="0ec0" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">通过dbt处理数据后，我们可以得到直接映射到其属性的不同类型的顶点、边和表结构的中间数据，可以是CSV文件、DWs中的表，甚至是Spark中的数据帧的形式，并且有不同的选项可以将它们导入到NebulaGraph中，其中NebulaGraph Exchange、Nebula-Importer和Nebula-Spark-Connector可以用于导入数据。</p><blockquote class="jn jo jp"><p id="caa2" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">注释。</em></p><p id="bb2f" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">你可以在</em><a class="ae lf" href="https://siwei.io/en/sketches/nebula-data-import-options" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://siwei.io/en/sketches/nebula-data-import-options</em></a><em class="iq">了解更多关于导入星云图数据的不同工具，知道如何选择其中一个c. </em></p></blockquote><p id="7be9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">这里我就用最简单的一个，Nebula-Importer来举例。</p><p id="41a3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">Nebula-Importer是一个用Golang编写的开源工具，可以编译成一个二进制文件，它可以从一个给定的CSV文件中获取顶点和边的对应关系，并通过预先配置的YAML格式文件读取和导入。</p><blockquote class="jn jo jp"><p id="f8ef" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">注意事项。</em></p><p id="3048" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">【星云-进口商】代号:<a class="ae lf" href="https://github.com/vesoft-inc/nebula-importer/" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://github.com/vesoft-inc/nebula-importer/</em></a></p><p id="f406" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">星云-导入器文档:</em><a class="ae lf" href="https://docs.nebula-graph.io/master/nebula-importer/use-importer/" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://docs . Nebula-graph . io/master/Nebula-Importer/use-Importer/</em></a></p></blockquote><h1 id="2320" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">dbt +星云-进口商在</h1><p id="c325" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">现在让我们使用dbt + Nebula-Importer来端到端演示如何提取、转换和导入多个数据源到NebulaGraph中，整个项目代码已经开源，资源库在<a class="ae lf" href="https://github.com/wey-gu/movie-recommendation-dataset," rel="noopener ugc nofollow" target="_blank">https://github.com/wey-gu/movie-recommendation-dataset,</a>随时查看那里的详细信息。</p><p id="14a0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">整个过程如下。</p><ul class=""><li id="3e91" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated">预处理原始数据并将其导入数据仓库(EL)</li><li id="6f0f" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">使用dbt转换数据(transform)，并将其导出到CSV文件</li><li id="931f" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">使用Nebula Importer (L)将CSV导入NebulaGraph</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nj"><img src="../Images/a64846bf95a1720252765c5fe1d55c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zSgFiEJXSbFnngEA.jpg"/></div></div></figure><h1 id="4a84" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">准备dbt环境</h1><p id="6bca" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">dbt是一个python项目，我们在一个虚拟的python3环境中安装dbt和dbt-postgres。</p><h1 id="756e" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">用dbt设置环境</h1><p id="8081" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">dbt是用python编写的，我们可以将它与dbt-postgres一起安装在python虚拟env中，因为我们将在这个示例项目中使用postgres作为DW。</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="d0ab" class="nv lh iq ne b be nw nx l ny nz">python3 -m venv .venv<br/>source .venv/bin/activate<br/>pip install dbt-postgres</span></pre><p id="e8a2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">创建dbt项目:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="a30c" class="nv lh iq ne b be nw nx l ny nz">dbt init dbt_project<br/>cd dbt_project</span></pre><p id="9c75" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">让我们看看这个项目中的文件:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="76e6" class="nv lh iq ne b be nw nx l ny nz">$ tree .<br/>.<br/>|-- README.md                      # README of the project<br/>|-- analyses<br/>|-- dbt_project.yml                # dbt project conf<br/>|-- macros<br/>|-- models                         # transforms<br/>|   \-- example<br/>|       |-- my_first_dbt_model.sql # meta data to describe transform rules from the source data with SELECT<br/>|       |-- my_second_dbt_model.sql<br/>|       \-- schema.yml             # the meta data of the rules<br/>|-- seeds                          # for CSV-file data sources<br/>|-- snapshots<br/>\-- tests</span></pre><pre class="oa nr ne ob oc aw od bi"><span id="25b9" class="oe lh iq ne b gy of og l oh nz">7 directories, 5 files</span></pre><p id="e7cb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">最后，让我们启动一个Postgress作为DW，如果你已经有一个，你可以跳过这一步，请确保配置和dbt插件是一致的，如果你选择使用自己的DW。</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="7b06" class="nv lh iq ne b be nw nx l ny nz">docker run --rm --name postgres \<br/>    -e POSTGRES_PASSWORD=nebula \<br/>    -e POSTGRES_USER=nebula \<br/>    -e POSTGRES_DB=warehouse -d \<br/>    -p 5432:5432 postgres</span></pre><h1 id="1817" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">数据下载和预处理</h1><p id="efcc" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">让我们创建一个名为<code class="fe nb nc nd ne b">raw_data</code>的文件夹，并将目录更改为它。</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="ed37" class="nv lh iq ne b be nw nx l ny nz">mkdir -p raw_data<br/>cd raw_data</span></pre><p id="ab62" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">我们估计这是在我们的dbt项目下:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="6ffd" class="nv lh iq ne b be nw nx l ny nz">tree ..<br/>..<br/>|-- README.md<br/>|-- analyses<br/>|-- dbt_project.yml<br/>|-- macros<br/>|-- models<br/>|   \-- example<br/>|       |-- my_first_dbt_model.sql<br/>|       |-- my_second_dbt_model.sql<br/>|       \-- schema.yml<br/>|-- raw_data                       # &lt;--- newly created data<br/>|-- seeds<br/>|-- snapshots<br/>\-- tests</span></pre><pre class="oa nr ne ob oc aw od bi"><span id="d3d6" class="oe lh iq ne b gy of og l oh nz">8 directories, 5 files</span></pre><p id="8ab6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">下载并解压缩omdb数据:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="df85" class="nv lh iq ne b be nw nx l ny nz">wget www.omdb.org/data/all_people.csv.bz2<br/>wget www.omdb.org/data/all_people_aliases.csv.bz2<br/>wget www.omdb.org/data/people_links.csv.bz2<br/>wget www.omdb.org/data/all_casts.csv.bz2<br/>wget www.omdb.org/data/job_names.csv.bz2<br/>wget www.omdb.org/data/all_characters.csv.bz2<br/>wget www.omdb.org/data/movie_categories.csv.bz2<br/>wget www.omdb.org/data/movie_keywords.csv.bz2<br/>wget www.omdb.org/data/category_names.csv.bz2<br/>wget www.omdb.org/data/all_categories.csv.bz2<br/>wget www.omdb.org/data/all_movie_aliases_iso.csv.bz2<br/>bunzip2 *.bz2</span></pre><p id="bc28" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">对于then MovieLens数据集:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="c1db" class="nv lh iq ne b be nw nx l ny nz">wget https://files.grouplens.org/datasets/movielens/ml-latest-small.zip<br/>unzip ml-latest-small.zip<br/>rm *.zip</span></pre><p id="2697" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">在使用dbt进行转换之前，我们做了一些简单的预处理，然后将它们放在<code class="fe nb nc nd ne b">seeds</code>下:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="243b" class="nv lh iq ne b be nw nx l ny nz">grep -v '\\"' raw_data/all_movie_aliases_iso.csv &gt; seeds/all_movie_aliases_iso.csv<br/>grep -v '\\"' raw_data/all_casts.csv &gt; seeds/all_casts.csv<br/>grep -v '\\"' raw_data/all_characters.csv &gt; seeds/all_characters.csv<br/>grep -v '\\"' raw_data/all_people.csv &gt; seeds/all_people.csv<br/>grep -v '\\"' raw_data/category_names.csv &gt; seeds/category_names.csv<br/>grep -v '\\"' raw_data/job_names.csv &gt; seeds/job_names.csv<br/>cp raw_data/movie_categories.csv seeds/movie_categories.csv<br/>cp raw_data/movie_keywords.csv seeds/movie_keywords.csv<br/>cp raw_data/all_categories.csv seeds/all_categories.csv<br/>cp raw_data/ml-latest-small/ratings.csv seeds/movielens_ratings.csv<br/>cp raw_data/ml-latest-small/movies.csv seeds/movielens_movies.csv</span></pre><p id="c599" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">放置好上述文件后，我们可以用一个命令将它们加载到DW中:</p><blockquote class="jn jo jp"><p id="a1f3" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">参考dbt</em><code class="fe nb nc nd ne b"><em class="iq">seeds</em></code><em class="iq"/><a class="ae lf" href="https://docs.getdbt.com/docs/build/seeds" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://docs.getdbt.com/docs/build/seeds</em></a>的文件</p></blockquote><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="9d4a" class="nv lh iq ne b be nw nx l ny nz">dbt seed</span></pre><p id="5934" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">如果你像我一样使用本地postgres，可能需要一段时间，在生产级别的情况下(即从云存储中的文件加载到大查询)，应该会更快，应该是这样的:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="fdf7" class="nv lh iq ne b be nw nx l ny nz">$ dbt seed<br/>05:58:27  Running with dbt=1.3.0<br/>05:58:27  Found 2 models, 4 tests, 0 snapshots, 0 analyses, 289 macros, 0 operations, 11 seed files, 0 sources, 0 exposures, 0 metrics<br/>05:58:28  <br/>05:58:28  Concurrency: 8 threads (target='dev')<br/>05:58:28  <br/>05:58:28  1 of 11 START seed file public.all_casts ....................................... [RUN]<br/>...<br/>07:10:11  1 of 11 OK loaded seed file public.all_casts ................................... [INSERT 1082228 in 4303.78s]<br/>07:10:11  <br/>07:10:11  Finished running 11 seeds in 1 hours 11 minutes and 43.93 seconds (4303.93s).<br/>07:10:11  <br/>07:10:11  Completed successfully<br/>07:10:11  <br/>07:10:11  Done. PASS=11 WARN=0 ERROR=0 SKIP=0 TOTAL=11</span></pre><h2 id="f121" class="oe lh iq bd li oi oj dn lm ok ol dp lq mg om on lu mi oo op ly mk oq or mc os bi translated">构建转换模型</h2><p id="5ce7" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">我们在<code class="fe nb nc nd ne b">models</code>下创建转换:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="b072" class="nv lh iq ne b be nw nx l ny nz">mkdir models/movie_recommedation<br/>touch models/movie_recommedation/user_watched_movies.sql<br/>touch models/movie_recommedation/schema.yml</span></pre><p id="872a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">这些文件如下:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="4dae" class="nv lh iq ne b be nw nx l ny nz">$ tree models<br/>models<br/>\-- movie_recommedation<br/>    |-- user_watched_movies.sql<br/>    \-- schema.yml</span></pre><p id="f391" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">现在这个模型下只有一个变换规则:处理<code class="fe nb nc nd ne b">user_watched_movies.sql</code>中<code class="fe nb nc nd ne b">user_watched_movies</code>的边缘</p><p id="33bd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">由于我们计划输出三列:user_id、movie_id、rating，因此<code class="fe nb nc nd ne b">schema.yml</code>类似于:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="a180" class="nv lh iq ne b be nw nx l ny nz">version: 2</span></pre><pre class="oa nr ne ob oc aw od bi"><span id="bf3b" class="oe lh iq ne b gy of og l oh nz">models:<br/>  - name: user_watched_movies<br/>    description: "The edges between users and movies they have watched"<br/>    columns:<br/>      - name: user_id<br/>        description: "user id"<br/>        tests:<br/>          - not_null<br/>      - name: movie_id<br/>        description: "movie id"<br/>        tests:<br/>          - not_null<br/>      - name: rating<br/>        description: "rating given by user to movie"<br/>        tests:<br/>          - not_null</span></pre><p id="d5d0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">请注意<code class="fe nb nc nd ne b">tests</code>是关于数据的验证和约束，有了它，我们可以很容易地控制数据质量。这里的<code class="fe nb nc nd ne b">not_null</code>确保测试执行时没有空值。</p><p id="1b2a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">然后，我们来作曲<code class="fe nb nc nd ne b">user_watched_movies.sql</code>:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="afed" class="nv lh iq ne b be nw nx l ny nz">{{ config(materialized='table') }}</span></pre><pre class="oa nr ne ob oc aw od bi"><span id="ecd3" class="oe lh iq ne b gy of og l oh nz">/*<br/> JOIN the movieielens_ratings table with the movieielens_movies table, and removing the movie title tailing the year of release<br/> */<br/>WITH user_watched_movies AS(<br/>    SELECT moveielens_ratings."userId",<br/>        moveielens_ratings."movieId",<br/>        moveielens_ratings.rating,<br/>        REGEXP_REPLACE(moveielens_movies.title, ' \(\d{4}\)$', '') AS title,<br/>        moveielens_movies.genres AS movielens_genres<br/>    FROM moveielens_ratings<br/>        JOIN moveielens_movies ON moveielens_movies."movieId" = moveielens_ratings."movieId"<br/>)<br/>/* <br/> JOIN user_watched_movies table with all_movie_aliase_iso table where language is English<br/> the join condition is the movie title<br/> */<br/>SELECT concat('u_',user_watched_movies."userId") AS user_id,<br/>    user_watched_movies.rating,<br/>    user_watched_movies.title,<br/>    all_movie_aliases_iso."movie_id" AS OMDB_movie_id,<br/>    user_watched_movies.movielens_genres<br/>FROM user_watched_movies<br/>    JOIN all_movie_aliases_iso ON user_watched_movies.title LIKE CONCAT(all_movie_aliases_iso.name, '%')<br/>    AND all_movie_aliases_iso.language_iso_639_1 = 'en'</span></pre><p id="7dce" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">这条SQL做的是绿色圆圈标记的部分:</p><ul class=""><li id="c716" class="mm mn iq jt b ju jv jy jz mg mo mi mp mk mq ko mr ms mt mu bi translated">从<code class="fe nb nc nd ne b">moveielens_ratings</code>中选择用户id、电影id、分级、电影名称(去掉年份部分)并保存为<code class="fe nb nc nd ne b">user_watched_movies</code>的中间表</li><li id="c441" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">电影片名是从<code class="fe nb nc nd ne b">moveielens_movies</code>编辑而来的<code class="fe nb nc nd ne b">JOIN</code>，与<code class="fe nb nc nd ne b">movie_id</code>的匹配条件相同</li><li id="03c9" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">从<code class="fe nb nc nd ne b">user_watched_movies</code>中选择用户id(前缀<code class="fe nb nc nd ne b">u_</code>)、分级、标题、OMDB _电影_id</li><li id="19cf" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">OMDB _电影_id是由<code class="fe nb nc nd ne b">all_movie_aliases_iso</code>演变而来的<code class="fe nb nc nd ne b">JOIN</code>，由相似电影名匹配OMDB电影的中英文片名得到</li><li id="be4b" class="mm mn iq jt b ju mv jy mw mg mx mi my mk mz ko mr ms mt mu bi translated">输出最终字段</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ot"><img src="../Images/a3bbd382d714f6d75adf7a6cad6b16d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2uUp119YdgxPvvjB.jpg"/></div></div></figure><blockquote class="jn jo jp"><p id="3857" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">提示:我们可以添加</em> <code class="fe nb nc nd ne b"><em class="iq">LIMIT</em></code> <em class="iq">来从Postgres控制台快速调试SQL查询</em></p></blockquote><p id="c8a0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">然后我们可以从dbt运行它来转换和测试规则:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="8568" class="nv lh iq ne b be nw nx l ny nz">dbt run -m user_watched_movies</span></pre><p id="de2b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">之后，我们应该能够在Postgres (DW)中看到转换后的表格。</p><p id="32e2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">类似地，对转换规则的所有其他部分遵循相同的方法，我们可以有其他模型:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="6a74" class="nv lh iq ne b be nw nx l ny nz">$ tree models<br/>models<br/>\-- movie_recommedation<br/>    |-- acted_by.sql<br/>    |-- directed_by.sql<br/>    |-- genres.sql<br/>    |-- movies.sql<br/>    |-- people.sql<br/>    |-- schema.yml<br/>    |-- user_watched_movies.sql<br/>    \-- with_genre.sql</span></pre><p id="2732" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">然后全部运行:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="ab6f" class="nv lh iq ne b be nw nx l ny nz">dbt run -m acted_by<br/>dbt run -m directed_by<br/>dbt run -m with_genre<br/>dbt run -m people<br/>dbt run -m genres<br/>dbt run -m movies</span></pre><h2 id="2dc5" class="oe lh iq bd li oi oj dn lm ok ol dp lq mg om on lu mi oo op ly mk oq or mc os bi translated">将数据导出到CSV</h2><p id="f6de" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">其实NebulaGraph Exchange本身支持直接导入很多数据源(Postgres、Clickhouse、MySQL、Hive等。)到NebulaGraph中，但是在这个例子中，我们处理的数据量对于NebulaGraph来说非常小，所以我们只使用最轻量级的一个:Nebula-Importer。Nebula-Importer只能导入CSV文件，所以我们正在这样做。</p><p id="e5d7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">首先，我们进入Postgres控制台并执行<code class="fe nb nc nd ne b">COPY</code>命令</p><blockquote class="jn jo jp"><p id="3c9a" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">参考Postgres文档:</em><a class="ae lf" href="https://www.postgresql.org/docs/current/sql-copy.html" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://www.postgresql.org/docs/current/sql-copy.html</em></a></p></blockquote><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="293a" class="nv lh iq ne b be nw nx l ny nz">COPY acted_by TO '/tmp/acted_by.csv'  WITH DELIMITER ',' CSV HEADER;<br/>COPY directed_by TO '/tmp/directed_by.csv'  WITH DELIMITER ',' CSV HEADER;<br/>COPY with_genre TO '/tmp/with_genre.csv'  WITH DELIMITER ',' CSV HEADER;<br/>COPY people TO '/tmp/people.csv'  WITH DELIMITER ',' CSV HEADER;<br/>COPY movies TO '/tmp/movies.csv'  WITH DELIMITER ',' CSV HEADER;<br/>COPY genres TO '/tmp/genres.csv'  WITH DELIMITER ',' CSV HEADER;<br/>-- for user_watched_movies, we don't output HEADER, as we will parse it in importer in a no-header way.<br/>COPY user_watched_movies TO '/tmp/user_watched_movies.csv'  WITH DELIMITER ',' CSV;</span></pre><p id="03ec" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">然后将CSV文件复制到<code class="fe nb nc nd ne b">to_nebulagraph</code></p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="1696" class="nv lh iq ne b be nw nx l ny nz">mkdir -p to_nebulagraph<br/>docker cp postgres:/tmp/. to_nebulagraph/</span></pre><h2 id="365a" class="oe lh iq bd li oi oj dn lm ok ol dp lq mg om on lu mi oo op ly mk oq or mc os bi translated">将数据导入NebulaGraph</h2><p id="4b7f" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">引导星云星团</p><p id="6982" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">我们可以使用Nebula-Up和oneliner来创建一个NebulaGraph游乐场集群。</p><blockquote class="jn jo jp"><p id="d85f" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">注:</em></p><p id="d5b1" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">星云团:<a class="ae lf" href="https://github.com/wey-gu/nebula-up" rel="noopener ugc nofollow" target="_blank">https://github.com/wey-gu/nebula-up</a></p><p id="0864" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">数据集储存库:<a class="ae lf" href="https://github.com/wey-gu/movie-recommendation-dataset" rel="noopener ugc nofollow" target="_blank">https://github.com/wey-gu/movie-recommendation-dataset</a></p></blockquote><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="ade7" class="nv lh iq ne b be nw nx l ny nz">curl -fsSL nebula-up.siwei.io/install.sh | bash</span></pre><p id="f898" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><strong class="jt ir">定义数据模式</strong></p><p id="6429" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">首先，我们需要创建一个图形空间，然后在其上创建标记(顶点类型)和边类型:</p><p id="a725" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">访问Nebula控制台(NebulaGraph的CLI客户端):</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="379a" class="nv lh iq ne b be nw nx l ny nz">~/.nebula-up/console.sh</span></pre><p id="826d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">运行以下DDL(数据定义语言):</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="1867" class="nv lh iq ne b be nw nx l ny nz">CREATE SPACE moviegraph(partition_num=10,replica_factor=1,vid_type=fixed_string(32));<br/>:sleep 20<br/>USE moviegraph;<br/>CREATE TAG person(name string, birthdate string);<br/>CREATE TAG movie(name string);<br/>CREATE TAG genre(name string);<br/>CREATE TAG user(user_id string);<br/>CREATE EDGE acted_by();<br/>CREATE EDGE directed_by();<br/>CREATE EDGE with_genre();<br/>CREATE EDGE watched(rate float);<br/>exit</span></pre><p id="9ea4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">创建Nebula-Importer配置文件</p><p id="f112" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">该配置是一个YAML文件，描述了CSV文件和簇中的顶点或边数据之间的对应关系。</p><p id="b3c0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">详见文档:<a class="ae lf" href="https://docs.nebula-graph.io/master/nebula-importer/use-importer/" rel="noopener ugc nofollow" target="_blank">https://docs . nebula-graph . io/master/nebula-importer/use-importer/</a>。</p><p id="67ff" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">我已经为它创建了一个，可以在<a class="ae lf" href="https://github.com/wey-gu/movie-recommendation-dataset/blob/main/nebula-importer.yaml." rel="noopener ugc nofollow" target="_blank">https://github . com/wey-gu/movie-recommendation-dataset/blob/main/nebula-importer . YAML .</a>下载</p><p id="6f59" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">在这里，我们将直接下载配置文件。</p><blockquote class="jn jo jp"><p id="2b03" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">注意，这个文件不应该是dbt项目文件的一部分。:</em></p></blockquote><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="2351" class="nv lh iq ne b be nw nx l ny nz">cd ..<br/>wget https://raw.githubusercontent.com/wey-gu/movie-recommendation-dataset/main/nebula-importer.yaml</span></pre><p id="0e00" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">摄取数据</p><p id="2814" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">让我们使用docker中的Nebula-Importer来避免任何安装:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="fa88" class="nv lh iq ne b be nw nx l ny nz">docker run --rm -ti \<br/>    --network=nebula-net \<br/>    -v ${PWD}:/root/ \<br/>    -v ${PWD}/dbt_project/to_nebulagraph/:/data \<br/>    vesoft/nebula-importer:v3.2.0 \<br/>    --config /root/nebula-importer.yaml</span></pre><p id="5aad" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">执行后，所有数据都在NebulaGraph中，我们可以从Nebula-Console检查数据:</p><p id="53b7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">首先，再次访问控制台:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="47ee" class="nv lh iq ne b be nw nx l ny nz">~/.nebula-up/console.sh</span></pre><p id="beaa" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">进入图形空间并执行<code class="fe nb nc nd ne b">SHOW STATS</code></p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="af1f" class="nv lh iq ne b be nw nx l ny nz">USE moviegraph;<br/>SHOW STATS;</span></pre><p id="0ffd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">结果应该是这样的:</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="033d" class="nv lh iq ne b be nw nx l ny nz">(root@nebula) [moviegraph]&gt; SHOW STATS;<br/>+---------+---------------+---------+<br/>| Type    | Name          | Count   |<br/>+---------+---------------+---------+<br/>| "Tag"   | "genre"       | 14397   |<br/>| "Tag"   | "movie"       | 20701   |<br/>| "Tag"   | "person"      | 263907  |<br/>| "Tag"   | "user"        | 610     |<br/>| "Edge"  | "acted_by"    | 673763  |<br/>| "Edge"  | "directed_by" | 101949  |<br/>| "Edge"  | "watched"     | 31781   |<br/>| "Edge"  | "with_genre"  | 194009  |<br/>| "Space" | "vertices"    | 299615  |<br/>| "Space" | "edges"       | 1001502 |<br/>+---------+---------------+---------+<br/>Got 10 rows (time spent 1693/15136 us)</span></pre><p id="e140" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">使用Nebula-Studio，我们还可以在可视化界面中探索这个图表，例如，通过执行这个查询，我们可以看到它向id为u_124的用户推荐id为1891的电影的原因？</p><pre class="kq kr ks kt gt nr ne ns bn nt nu bi"><span id="4538" class="nv lh iq ne b be nw nx l ny nz">FIND NOLOOP PATH FROM "u_124" TO "1891" over * BIDIRECT UPTO 4 STEPS yield path as `p` | LIMIT 20</span></pre><p id="faca" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">结果可能是:曾经最受欢迎的星球大战电影的大多数演员和工作人员也参与了这部同样的“奥斯卡获奖”和“经典”电影。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nj"><img src="../Images/6cd14c9ac8427b0e3beed4424795d50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SNNQZ8EE5ufcKE06.jpg"/></div></div></figure><blockquote class="jn jo jp"><p id="3dea" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">在另一篇文章中，我使用了相同的图来演示更多的图数据库和图算法在推荐系统中的应用。如果有兴趣，请阅读:<a class="ae lf" href="https://siwei.io/recommendation-system-with-graphdb/." rel="noopener ugc nofollow" target="_blank"><em class="iq">https://siwei.io/recommendation-system-with-graphdb/.</em></a></p></blockquote><h1 id="c972" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">摘要</h1><p id="e083" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">当我们计划利用海量数据的图形数据库来转换知识和分析见解时，第一步通常是将多个数据源转换、处理和建模为图形数据。对于不知道从哪里开始的初学者来说，一个可行的想法是从所有相关的信息开始，描绘出最关心的关系，然后列出可以获得的顶点，以及需要附加的顶点。在确定初始建模之后，您可以使用ETL工具来清理原始数据，ETL成将被映射到图形的表结构，最后，使用import工具来导入NebulaGraph，用于进一步的模型迭代。</p><p id="e1b0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">在dbt的帮助下，我们可以对我们的建模和数据转换进行版本控制、测试和迭代，并逐渐进化和丰富所构建的知识图。</p></div></div>    
</body>
</html>