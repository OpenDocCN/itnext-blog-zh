<html>
<head>
<title>Uploading Files To Your Rails API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将文件上传到Rails API</h1>
<blockquote>原文：<a href="https://itnext.io/uploading-files-to-your-rails-api-6b293a4a5c90?source=collection_archive---------1-----------------------#2018-01-30">https://itnext.io/uploading-files-to-your-rails-api-6b293a4a5c90?source=collection_archive---------1-----------------------#2018-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b56b9ccc91bd1bdd88268a45f66861f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OANLBh1KWY4JTEZdM05xhw.png"/></div></div></figure><p id="db58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近在做一个项目，需要从我的前端(使用React)上传相对大量的文件到一个独立的API后端(使用Rails)。这些由图像和音频组成的文件将使用回形针进行处理，并存储在S3。到目前为止，我只使用JSON与API交互——尽管<a class="ae kw" href="https://medium.com/@dakota.lillie/uploading-files-using-carrierwave-in-rails-81ef54ebbcdb" rel="noopener">我写的第一篇博文</a>是关于使用CarrierWave上传图像的，那是在全栈Rails环境中，在那里我可以依靠Rails的神奇表单助手来简化这种方式。然而，上传文件是一项非常普通的任务——能有多难呢？</p><p id="33ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实证明，非常困难。接下来是三天的痛苦，我不停地谷歌和搜索Stack Overflow，找到几个与我的特定设置相关的资源，没有一个能解决我遇到的问题。然而，当我最终找到答案(不是从网上，而是从一个同事那里)时，它是如此简单和平庸，以至于我无法相信在我访问过的任何一个网站上都没有人提出过这个答案。</p><p id="6958" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在我不断寻求填补我在互联网知识方面遇到的任何空白的过程中，本指南旨在充当我希望找到的演练。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="6efc" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">两种方法:表单数据与Base64</h2><p id="3510" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">有两种上传文件的方法可供选择:使用表单数据或将文件编码为base64字符串。根据我的理解，表单数据是更好的选择，但是为了理解为什么，让我们先来仔细看看base64。</p><p id="c2f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Base64是一种将二进制数据转换为ASCII文本的编码形式。这很有用，因为如果文件(通常由二进制组成)被表示为字符串，它们可以使用JSON传输。</p><p id="d116" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是通过base64编码传输文件有它的缺陷。首先，base64增加了编码/解码过程的一些计算开销，实际上增加了33%的文件大小，使其不太适合较大的文件。如果你感兴趣的话，这里有一段视频解释了原因:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="cba5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个问题是，根据我的经验，在base64编码/解码过程中，文件很容易丢失它们的MIME类型(和其他元数据),成为无用的二进制文件堆。你可能会问，什么是哑剧类型？嗯，当你看一个base64字符串时，它可能看起来像这样(这个例子是从<a class="ae kw" href="https://www.pluralsight.com/guides/ruby-ruby-on-rails/handling-file-upload-using-ruby-on-rails-5-api" rel="noopener ugc nofollow" target="_blank">这里的</a>偷来的):</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="5783" class="le lf iq mj b gy mn mo l mp mq">data:image/gif;base64,iVBORw0KGgoAAAANag...//rest of the base64 text</span></pre><p id="a495" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一部分<code class="fe mr ms mt mj b">image/gif</code>，是一个MIME类型。MIME代表<em class="mu">多用途互联网邮件扩展</em>，它本质上是对给定文件应该是哪种文件的描述。MIME类型以一种<code class="fe mr ms mt mj b">type/subtype</code>格式构建，一些常见的例子包括<code class="fe mr ms mt mj b">text/html</code>、<code class="fe mr ms mt mj b">image/jpg</code>或<code class="fe mr ms mt mj b">audio/mpeg</code>(你可以在这里找到<a class="ae kw" href="https://www.freeformatter.com/mime-types-list.html#mime-types-list" rel="noopener ugc nofollow" target="_blank">一个更广泛的列表</a>)。如果没有检测到MIME类型，一个文件被赋予类型<code class="fe mr ms mt mj b">application/octet-stream</code>，这基本上意味着它只是普通的二进制数据。</p><p id="76b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我一直遇到的问题是，当我上传的文件(wav音频文件，在这个时间点)被解码时，它们的类型会变成<code class="fe mr ms mt mj b">application/octet-stream</code>。这意味着它们不能被打开，也不能被有效地破坏。我最终设法解决了这个问题，使用了一种没有任何文档的曲别针方法。但是很明显这并不理想，这个过程不应该如此困难。有一种更好的方法:表单数据。</p><p id="1814" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据<a class="ae kw" href="https://www.w3.org/" rel="noopener ugc nofollow" target="_blank"> W3C </a>，表单数据是在HTML 4中明确引入的，目的是处理"<a class="ae kw" href="https://www.pluralsight.com/guides/ruby-ruby-on-rails/handling-file-upload-using-ruby-on-rails-5-api" rel="noopener ugc nofollow" target="_blank">包含文件、非ASCII数据和二进制数据</a>的表单。它由一组键/值对组成，类似于JSON，每一对都代表表单中的一个输入。它非常适合我们的目的——事实上，我研究base64的唯一原因是，有一段时间，我无法让表单数据工作。所以让我们探索一下:如何让它工作。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="2bc5" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">前端</h2><p id="cac3" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">在这个例子中，我将使用普通的Javascript，以确保它的可访问性最大化(如果你愿意，一切都应该可以很容易地转换成React或任何其他框架):</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mv mh l"/></div></figure><p id="e679" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个例子所做的只是显示文件的元数据——要让它真正做任何事情，您需要提供自己的API端点来代替我在这里使用的未定义的<code class="fe mr ms mt mj b">API_ROOT</code>变量。我用注释对代码进行了注释，试图弄清楚每一步发生了什么，并提供了两个单独的例子来说明如何向一个<code class="fe mr ms mt mj b">FormData</code>对象添加数据，要么在实例化时添加，要么在之后使用<code class="fe mr ms mt mj b">.append()</code>添加。</p><p id="4892" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望您能理解要点，即表单数据是通过用<code class="fe mr ms mt mj b">new</code>关键字实例化的<code class="fe mr ms mt mj b">FormData</code>对象连接的，该对象填充了数据并用作<code class="fe mr ms mt mj b">POST</code>请求的主体。但是请注意一个非常重要的细节fetch请求不包含任何头。如果您习惯于使用JSON与API交互，就像我一样，您可能习惯于这样定义请求的头:</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="d11c" class="le lf iq mj b gy mn mo l mp mq">{'Content-Type': 'application/json'}</span></pre><p id="318c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我花了几天时间才弄明白的事情— <strong class="ka ir">使用表单数据时，不要在请求中包含内容类型的标题</strong>。</p><p id="bd52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会像我想的那样，将<code class="fe mr ms mt mj b">Content-Type</code>头改为<code class="fe mr ms mt mj b">multipart/form-data</code>。当我这样做时，我的Rails服务器上出现错误消息，指出我上传的内容(在我的例子中是wav音频文件)与请求的内容类型不匹配。然而，将<code class="fe mr ms mt mj b">Content-Type</code>更改为<code class="fe mr ms mt mj b">audio/wav</code>，消除了错误，使得数据根本不会显示在Rails控制器中。找不到任何与我的困境相关的有用文章，我愤怒地转向base64和更熟悉的JSON格式，这带来了上面详述的一系列问题。</p><p id="c862" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，一个简单的问题就解决了，只需要拖三天就可以解决。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/e43286b8217c11a22fcd5cacc8397109.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*WcRHeFysRQRU6LL50MoBww.png"/></div></figure><p id="c069" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我已经发泄完了我的沮丧，让我们简单地看一下后端。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="51d0" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">后端</h2><p id="e6d1" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">我假设如果您正在阅读本文，您可能已经熟悉Rails，并且知道如何启动和运行API。一旦您为端点设置了路由，配置了一个控制器操作来处理该端点，并将您的获取请求定向到该端点，您应该会收到如下所示的数据:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/98b4bdd1673c58002f2dd1ad200e23fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-mW75j6uNqy1IzEi9WMVJA.png"/></div></div></figure><p id="7fc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，对于您的特定设置，许多细节看起来会有所不同——这张截图来自我正在开发的应用程序，该应用程序涉及上传与音乐样本库相关联的图像。但大体结构应该差不多。你应该能够看到上传的文件及其文件名，内容类型等。</p><p id="a13f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从这里开始，它应该是相当简单的——具体的实现将根据您使用的是回形针还是CarrierWave而有所不同。我不打算详细介绍如何设置它们或配置它们在S3上存储文件……这超出了我试图涵盖的范围，并且有大量<a class="ae kw" href="https://scotch.io/tutorials/file-upload-in-rails-with-paperclip" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae kw" href="https://code.tutsplus.com/articles/uploading-with-rails-and-carrierwave--cms-28409" rel="noopener ugc nofollow" target="_blank">文章</a>的<a class="ae kw" href="https://devcenter.heroku.com/articles/paperclip-s3" rel="noopener ugc nofollow" target="_blank">已经</a>描述了<a class="ae kw" href="https://gist.github.com/cblunt/1303386" rel="noopener ugc nofollow" target="_blank">如何</a>到<a class="ae kw" href="http://www.rubydoc.info/github/thoughtbot/paperclip/Paperclip/Storage/S3" rel="noopener ugc nofollow" target="_blank">做</a> <a class="ae kw" href="https://medium.com/@dakota.lillie/uploading-files-using-carrierwave-in-rails-81ef54ebbcdb" rel="noopener">那个</a>。不管怎么说，这并不是最难的部分，至少对我来说…让这个过程如此令人沮丧的是首先要弄清楚如何将数据从React/JavaScript转移到Rails。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="506e" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">结论</h2><p id="1157" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">我应该注意到这不是唯一的方法——如果你使用react，还有一个叫做<a class="ae kw" href="https://github.com/odysseyscience/react-s3-uploader" rel="noopener ugc nofollow" target="_blank"> react-s3-uploader </a>的组件，它可以让你直接从React上传到s3，然后把文件的url保存到你的后端。这是可行的，但是我个人仍然建议通过后端处理S3集成，原因如下:</p><ol class=""><li id="c9a7" class="my mz iq ka b kb kc kf kg kj na kn nb kr nc kv nd ne nf ng bi translated">由于使用回形针/CarrierWave时，文件直接与数据库中的记录相关联，因此当这些记录被删除时，文件也将被删除。对你来说，这可能不是重要的(甚至是令人想要的)行为——但是，对我来说，这是一个重要的因素。我正在做的项目涉及到上传数千个文件，我特别不想让一堆没用的文件占用宝贵的空间。</li><li id="9044" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">回形针和CarrierWave可以轻松地为您的上传添加预处理。在我的例子中，我将wav音频文件转换成mp3，同时生成更小的“缩略图”版本的图像文件。我实际上没有使用过react-S3-uploader——它似乎有一个<code class="fe mr ms mt mj b">preprocess</code>道具，所以它可能允许你做这样的事情。但是回形针和CarrierWave的设计使得这种处理变得非常简单。</li></ol><p id="530b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这些了，伙计们！</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="7bd8" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">来源:</h2><div class="nm nn gp gr no np"><a href="https://www.pluralsight.com/guides/ruby-ruby-on-rails/handling-file-upload-using-ruby-on-rails-5-api" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">使用Ruby on Rails 5 API处理文件上传</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">喜欢这个指南吗？通过点击心脏让社区知道！贡献者感谢以下用户…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.pluralsight.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od jw np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="http://blog.littleblimp.com/post/119230396893/direct-uploads-to-s3-with-react-rails-and" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">使用React、Rails和回形针直接上传到S3</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">终于，续集来了！或者也许这是好莱坞式的重启，但不是狗屎。很久以前，我写了一点…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">blog.littleblimp.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od jw np"/></div></div></a></div></div></div>    
</body>
</html>