<html>
<head>
<title>Broken Promises: Building JavaScript Promises from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破碎的承诺:从零开始构建JavaScript承诺</h1>
<blockquote>原文：<a href="https://itnext.io/broken-promises-a-barely-working-implementation-of-js-promises-ed7f99071f54?source=collection_archive---------1-----------------------#2018-05-02">https://itnext.io/broken-promises-a-barely-working-implementation-of-js-promises-ed7f99071f54?source=collection_archive---------1-----------------------#2018-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="752a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">标题中破碎的承诺部分实际上指的是我放弃的周末计划，为了呆在家里深入研究Javascript承诺的内部。您在下面看到的是Javascript Promises的一个有限但有效的实现，以及一个模仿的fetch API(名为<code class="fe kl km kn ko b">get</code>)来证明它是有效的。</p><p id="6b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，快速回顾一下什么是承诺，承诺有什么作用。</p><p id="d2fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">编辑:</strong> <a class="kp kq ep" href="https://medium.com/u/a4951bc68f93?source=post_page-----ed7f99071f54--------------------------------" rel="noopener" target="_blank"> <strong class="jp ir">詹姆斯·布朗宁</strong> </a> <strong class="jp ir">在评论中指出，我的承诺版本在一些重要方面有所欠缺。建议看看他的评论。</strong></p><h1 id="39ce" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">承诺</h1><p id="88e9" class="pw-post-body-paragraph jn jo iq jp b jq lp js jt ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk ij bi translated">用最简单的话来说，Promise允许您异步运行一些代码(不阻塞程序其余部分的执行)，然后在代码完成后运行其他代码，并依赖于结果(无论是失败还是成功)。</p><p id="68c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更重要的是，它避免了JS开发人员多年来所说的“回调地狱”。</p><h2 id="c086" class="lu ks iq bd kt lv lw dn kx lx ly dp lb jy lz ma lf kc mb mc lj kg md me ln mf bi translated">术语</h2><p id="088f" class="pw-post-body-paragraph jn jo iq jp b jq lp js jt ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk ij bi translated">我在上面使用了“完成”、“失败”和“成功”这些词，但这些并不是承诺实际使用的术语。而是分别使用“已解决”、“已拒绝”和“已解决”等词。在承诺“解决”之前，它被称为“待定”。</p><h2 id="a05a" class="lu ks iq bd kt lv lw dn kx lx ly dp lb jy lz ma lf kc mb mc lj kg md me ln mf bi translated">承诺建造者</h2><p id="d67b" class="pw-post-body-paragraph jn jo iq jp b jq lp js jt ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk ij bi translated">承诺是使用构造器模式创建的。Promise构造函数采用1个参数，该函数具有以下签名:</p><p id="38e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">function(<strong class="jp ir">resolveCallback</strong>, <strong class="jp ir">rejectCallback</strong>)</code></p><ul class=""><li id="7c21" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">resolveCallback —承诺解决时要调用的函数。</li><li id="04f7" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">rejectCallback —承诺被拒绝时调用的函数。</li></ul><p id="8a55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mu">注:有关构建传递给构造函数的函数体的详细信息，请参见下面的</em> <strong class="jp ir"> <em class="mu">使用承诺</em> </strong> <em class="mu">一节。</em></p><p id="8d3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构造函数返回一个Promise对象，该对象跟踪它的状态(status ),并且只能处理一次。这意味着resolver和rejector功能一起只能接收一个呼叫，并且状态不能从resolved更改为rejected，反之亦然。</p><h2 id="4e01" class="lu ks iq bd kt lv lw dn kx lx ly dp lb jy lz ma lf kc mb mc lj kg md me ln mf bi translated">界面</h2><p id="3fb4" class="pw-post-body-paragraph jn jo iq jp b jq lp js jt ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk ij bi translated">Promises实现了<strong class="jp ir">enable</strong>接口(实际上我相信他们是这个术语的创始人)，这仅仅意味着你可以在它们完成后调用<code class="fe kl km kn ko b">then</code>来运行代码。</p><p id="73e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b"><strong class="jp ir">then</strong></code> <strong class="jp ir">:功能</strong></p><ul class=""><li id="7598" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">接受解析时调用的回调。</li><li id="a315" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">回调应该接受一个参数，即解析器返回的值。</li><li id="413f" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">返回自身，以便可以链接方法。</li></ul><p id="1a05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们还公开了一个<code class="fe kl km kn ko b">catch</code>方法，该方法类似于<code class="fe kl km kn ko b">then</code>,只是它只在promise拒绝时运行。</p><p id="d537" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b"><strong class="jp ir">catch</strong></code> <strong class="jp ir">:功能</strong></p><ul class=""><li id="cd28" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">接受拒绝时调用的回调。</li><li id="923e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">回调应该有一个参数，即rejector返回的值。</li><li id="e107" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">返回自身，以便可以链接方法。</li></ul><p id="3e3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，它们公开了一个<code class="fe kl km kn ko b">finally</code>方法，该方法在承诺解决之后被调用，并且<code class="fe kl km kn ko b">then</code>或<code class="fe kl km kn ko b">catch</code>回调被调用，不管它是拒绝还是解决。</p><p id="2af9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b"><strong class="jp ir">finally</strong></code> <strong class="jp ir">:功能</strong></p><ul class=""><li id="79bc" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">等待承诺完成并等待<code class="fe kl km kn ko b">then</code>或<code class="fe kl km kn ko b">catch</code>回调运行。</li><li id="c9b6" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">无论如何都要调用回调。</li></ul><h2 id="6a46" class="lu ks iq bd kt lv lw dn kx lx ly dp lb jy lz ma lf kc mb mc lj kg md me ln mf bi translated">我的实现</h2><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/dfbc3dbeef39e771578340b5c4aa0249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lMK6lo8mvnNIHfrnRgeOOQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">my promise——JS Promises的准系统实现</figcaption></figure><h2 id="4213" class="lu ks iq bd kt lv lw dn kx lx ly dp lb jy lz ma lf kc mb mc lj kg md me ln mf bi translated">利用承诺</h2><p id="4a52" class="pw-post-body-paragraph jn jo iq jp b jq lp js jt ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk ij bi translated">如果你是一名javascript开发人员，你会意识到承诺，并且在使用类似于<code class="fe kl km kn ko b">fetch</code> API的东西时，你几乎肯定会从中受益。然而，不太可能的是，您已经直接创建了一个。让我们改变这一点。</p><p id="6569" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，Promise构造函数接受一个参数，这个函数本身接受两个回调函数。该函数的内部逻辑是重要的部分，该逻辑是:什么时候应该调用<code class="fe kl km kn ko b">resolve</code>回调，什么时候应该调用<code class="fe kl km kn ko b">reject</code>回调。</p><p id="5afa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何使用<code class="fe kl km kn ko b">MyPromise</code>来实现这一点(这将与使用Javascript提供的原生Promise没有什么不同)。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nl"><img src="../Images/a1ff9c26160f14a4fbe377535731cedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrleCWMbjIMcJPsovsU7sw.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">get——一个使用MyPromise的模仿获取API</figcaption></figure><p id="ab9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理解我在这里做什么应该很简单:我定义了一个XMLHttpRequest对象，并给它附加了几个事件侦听器。如果响应的状态为200，我将它传递给<code class="fe kl km kn ko b">resolve</code>回调，否则它的状态将在一个错误对象中传递给<code class="fe kl km kn ko b">reject</code>。如果请求本身抛出一个错误，我会将一个带有消息“网络错误”的错误传递给<code class="fe kl km kn ko b">reject</code>。</p><p id="27b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来测试一下。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nm"><img src="../Images/6bd349e2457122d72a9f06d81659e6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LplgVzMh1jWTiY9AQg7GCg.png"/></div></div></figure><p id="ca8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快看，这东西能用！</p><p id="376a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我写这篇博文主要是为了提高我自己对JS Promises内部的理解，但我希望它对你也有帮助。如果我遗漏了什么重要的东西或者使用了误导性的术语，请告诉我。</p><p id="11c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>