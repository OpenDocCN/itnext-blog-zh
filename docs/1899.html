<html>
<head>
<title>Assessing performance of group-wise max queries in MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySQL中分组最大查询的性能评估</h1>
<blockquote>原文：<a href="https://itnext.io/assessing-performance-of-group-wise-max-queries-in-mysql-8d3056fb36fa?source=collection_archive---------1-----------------------#2019-02-20">https://itnext.io/assessing-performance-of-group-wise-max-queries-in-mysql-8d3056fb36fa?source=collection_archive---------1-----------------------#2019-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1b8c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何有效地在连接中找到最新的相关行</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e5793a01e075844555660e25d0e599d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HMkmEY0lZ-Aojfu_CwTrHA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:英纳斯</figcaption></figure><h1 id="f694" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">介绍</h1><p id="49d9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">关系数据库有时会很棘手。</p><p id="c558" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我目前正在开发一个应用程序，处理我们客户拥有的一些资产。这些资产是在我们的平台上创建的，他们会不时更新一些信息。</p><p id="87c2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们以<code class="fe mo mp mq mr b">Vehicles</code>为例。我有一个看起来像这样的表格结构:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="82fd" class="mw kw iq mr b gy mx my l mz na">CREATE TABLE `Vehicles` (<br/>  `id` varchar(50) NOT NULL,<br/>  `organizationId` varchar(50) NOT NULL,<br/>  `plate` char(7) NOT NULL,<br/>  `vehicleInfo` json DEFAULT NULL,<br/>  `createdAt` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,<br/>  `updatedAt` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,<br/>  PRIMARY KEY (`id`),<br/>  UNIQUE KEY `unq_Vehicles_orgId_plate_idx` (`organizationId`,`plate`) USING BTREE,<br/>  KEY `Vehicles_createdAt_idx` (`createdAt`),<br/>);<br/><br/>CREATE TABLE `VehicleUpdates` (<br/>  `id` varchar(50) NOT NULL,<br/>  `organizationId` varchar(50) NOT NULL,<br/>  `vehiclePlate` char(7) NOT NULL,<br/>  `status` varchar(15) NOT NULL,<br/>  `createdAt` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,<br/>  `updatedAt` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,<br/>  PRIMARY KEY (`id`),<br/>  KEY `VehicleUpdates_orgId_vhclPlt_createdAt_idx` (`organizationId`,`vehiclePlate`,`createdAt`) USING BTREE<br/>);</span></pre><p id="9ca4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">两个表的关系是<code class="fe mo mp mq mr b">M:N</code>，我可以使用<code class="fe mo mp mq mr b">(organizationId, vehiclePlate)</code>找到给定车辆的所有更新。</p><p id="1bd8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在，我的应用程序有了一个新的要求，即在归还车辆时，我还必须携带最新的更新信息。</p><p id="3078" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">经过一段时间的挖掘，我发现我的新需求有一个名字:“组级Max”。</p><p id="7a1c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在撰写本文时，我的生产MySQL服务器正在Amazon RDS上运行版本<code class="fe mo mp mq mr b">5.7.23</code>。<code class="fe mo mp mq mr b">Vehicles</code>表有<code class="fe mo mp mq mr b">15.832</code>行，<code class="fe mo mp mq mr b">VehicleUpdates</code>有<code class="fe mo mp mq mr b">271.910</code>行。</p><h1 id="274d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">可用的解决方案</h1><p id="840a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我偶然发现了瑞克·詹姆斯写的这个博客。他描述了问题，并提出了一些解决方案，考虑到他们的表现。我选了两个对我来说更有意义的。</p><blockquote class="nc"><p id="0525" class="nd ne iq bd nf ng nh ni nj nk nl mi dk translated">公平地说，詹姆斯先生的建议只解决了我的一部分问题。我必须在另一个<code class="fe mo mp mq mr b">LEFT JOIN</code>中使用它们，才能满足我的要求。</p></blockquote><h2 id="4582" class="mw kw iq bd kx nm nn dn lb no np dp lf lw nq nr lh ma ns nt lj me nu nv ll nw bi translated">不相关的子查询</h2><p id="4a4c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">根据瑞克·詹姆斯的说法，这个解是<code class="fe mo mp mq mr b">O(M)</code>，其中<code class="fe mo mp mq mr b">M</code>是输出行数。因为我使用的是<code class="fe mo mp mq mr b">5.7</code>，已经有了正确的索引，不能有重复的，所以这种方法工作得很好。</p><p id="e8fa" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我写了一个这样的查询:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="5173" class="mw kw iq mr b gy mx my l mz na">SELECT SQL_NO_CACHE vu1.*<br/>    FROM VehicleUpdates AS vu1<br/>    JOIN<br/>      ( SELECT  vehiclePlate, organizationId, MAX(createdAt) AS createdAt<br/>            FROM  VehicleUpdates<br/>            where organizationId = @orgId<br/>            GROUP BY organizationId, vehiclePlate<br/>      ) AS vu2 USING (organizationId, vehiclePlate, createdAt);</span></pre><p id="c63d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这个查询的平均执行时间是<code class="fe mo mp mq mr b">25 ms</code>。那似乎很有希望！</p><p id="36ec" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后，我将<code class="fe mo mp mq mr b">Vehicles</code>表添加到查询中，以解决我的实际问题:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="affd" class="mw kw iq mr b gy mx my l mz na">SELECT SQL_NO_CACHE v.*, vu1.* <br/>FROM Vehicles AS v<br/>LEFT JOIN (<br/>        VehicleUpdates AS vu1<br/>        JOIN<br/>          ( SELECT  vehiclePlate, organizationId, MAX(createdAt) AS createdAt<br/>                FROM  VehicleUpdates<br/>                GROUP BY organizationId, vehiclePlate<br/>          ) AS vu2 ON vu1.organizationId = vu2.organizationId<br/>                and vu1.vehiclePlate = vu2.vehiclePlate<br/>                and vu1.createdAt = vu2.createdAt<br/>    )<br/>        ON vu1.organizationId = v.organizationId <br/>            AND vu1.vehiclePlate = v.plate;</span></pre><p id="b9f5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">不幸的是，这导致平均执行时间为<code class="fe mo mp mq mr b">2,200 ms</code>。对我来说完全是交易破坏者😞。</p><blockquote class="nx ny nz"><p id="12c4" class="ln lo oa lp b lq mj jr ls lt mk ju lv ob ml ly lz oc mm mc md od mn mg mh mi ij bi translated">我永远不会在生产中运行这种全表扫描。我至少会在organizationId列上有一个条件，并且可能还会设置一个<code class="fe mo mp mq mr b">LIMIT</code>子句。让我们试一试！</p></blockquote><p id="b6f3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后我继续说:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="291a" class="mw kw iq mr b gy mx my l mz na">SELECT SQL_NO_CACHE v.*, vu1.* <br/>FROM Vehicles AS v<br/>LEFT JOIN (<br/>        VehicleUpdates AS vu1<br/>        JOIN<br/>          ( SELECT  vehiclePlate, organizationId, MAX(createdAt) AS createdAt<br/>                FROM  VehicleUpdates<br/>                GROUP BY organizationId, vehiclePlate<br/>          ) AS vu2 ON vu1.organizationId = vu2.organizationId<br/>                and vu1.vehiclePlate = vu2.vehiclePlate<br/>                and vu1.createdAt = vu2.createdAt<br/>    )<br/>        ON vu1.organizationId = v.organizationId <br/>            AND vu1.vehiclePlate = v.plate<br/><strong class="mr ir">WHERE v.organizationId = '&lt;SOME ORGANIZATION ID&gt;'</strong><br/>LIMIT 100;</span></pre><p id="135a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">结果呢？🥁🥁🥁…:我的平均成绩是<code class="fe mo mp mq mr b">320 ms</code>。好多了，但我的申请还是没通过😢。</p><p id="203b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我还没准备好放弃！在检查了上面查询的<code class="fe mo mp mq mr b">EXPLAIN</code>的输出后，我注意到最内层的<code class="fe mo mp mq mr b">JOIN</code>是使用<code class="fe mo mp mq mr b"><a class="ae nb" href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_range" rel="noopener ugc nofollow" target="_blank">range</a></code>生成的，而所有其他的都使用了<code class="fe mo mp mq mr b"><a class="ae nb" href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_ref" rel="noopener ugc nofollow" target="_blank">ref</a></code>。</p><p id="7d01" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">结果是最内层的<code class="fe mo mp mq mr b">JOIN</code>查询效率很低，因为它扫描了整个<code class="fe mo mp mq mr b">VehicleUpdates</code>表，结果却被顶层<code class="fe mo mp mq mr b">LEFT JOIN</code>中的<code class="fe mo mp mq mr b">ON</code>子句过滤掉了。</p><p id="767d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">由于MySQL引擎不会为我优化这一点，我不得不自己做，在最内层的查询中添加一个<code class="fe mo mp mq mr b">WHERE</code>子句，将搜索的行数限制为只有那些具有特定<code class="fe mo mp mq mr b">organizationId</code>的行:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="e044" class="mw kw iq mr b gy mx my l mz na">SELECT SQL_NO_CACHE v.*, vu1.* <br/>FROM Vehicles AS v<br/>LEFT JOIN (<br/>        VehicleUpdates AS vu1<br/>        JOIN<br/>          ( SELECT  vehiclePlate, organizationId, MAX(createdAt) AS createdAt<br/>                FROM  VehicleUpdates<br/>                <strong class="mr ir">WHERE organizationId = '&lt;SOME ORGANIZATION ID&gt;'</strong><br/>                GROUP BY organizationId, vehiclePlate<br/>          ) AS vu2 ON vu1.organizationId = vu2.organizationId<br/>                and vu1.vehiclePlate = vu2.vehiclePlate<br/>                and vu1.createdAt = vu2.createdAt<br/>    )<br/>        ON vu1.organizationId = v.organizationId <br/>            AND vu1.vehiclePlate = v.plate<br/>WHERE v.organizationId = '&lt;SOME ORGANIZATION ID&gt;'<br/>LIMIT 100;</span></pre><p id="7db0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这给了我平均执行时间<code class="fe mo mp mq mr b">50 ms</code>。现在我们正在谈话😊！再次运行<code class="fe mo mp mq mr b">EXPLAIN</code>向我展示了所有使用<code class="fe mo mp mq mr b">ref</code>的连接。</p><p id="3887" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然而，这个查询相当复杂。在最内层的子查询中添加一个<code class="fe mo mp mq mr b">WHERE</code>子句的需要不允许我创建一个视图来简化它😔。</p><h2 id="1ba0" class="mw kw iq bd kx nm oe dn lb no of dp lf lw og nr lh ma oh nt lj me oi nv ll nw bi translated">左连接方法</h2><p id="4e3e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">瑞克·詹姆斯表示，这种方法取决于<code class="fe mo mp mq mr b">join_buffer_size</code>。至少在理论上，它不可能像不相关的子查询那样快。</p><p id="cc81" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我以这样一个查询结束:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="497f" class="mw kw iq mr b gy mx my l mz na">SELECT  vu1.*<br/>    FROM  VehicleUpdates AS vu1<br/>    LEFT JOIN  VehicleUpdates AS vu2 <br/>        ON vu1.organizationId = vu2.organizationId <br/>        AND vu1.vehiclePlate = vu2.vehiclePlate<br/>        AND vu2.createdAt &gt; vu1.createdAt<br/>    WHERE vu2.id IS NULL;</span></pre><p id="88cd" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">平均执行时间约为<code class="fe mo mp mq mr b">40 ms</code>。不如等价的不相关子查询方法好，但仍然可以接受😅。</p><p id="35c5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">好了，现在开始真正的问题，我得到了:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="50de" class="mw kw iq mr b gy mx my l mz na">SELECT SQL_NO_CACHE v.*, vu1.*<br/>FROM  Vehicles AS v<br/>LEFT JOIN VehicleUpdates AS vu1 <br/>    ON v.plate = vu1.vehiclePlate <br/>        AND v.organizationId = vu1.organizationId<br/>LEFT JOIN  VehicleUpdates AS vu2 <br/>    ON vu1.organizationId = vu2.organizationId <br/>        AND vu1.vehiclePlate = vu2.vehiclePlate<br/>        AND vu2.createdAt &gt; vu1.createdAt<br/>    AND vu2.id IS NULL;</span></pre><p id="7df2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果没有<code class="fe mo mp mq mr b">LIMIT</code>子句，这个查询平均运行<code class="fe mo mp mq mr b">12,000 ms</code>。那太多了😲😲😲！！！</p><p id="da55" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">好的，然后我写了实际的生产查询:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="cd46" class="mw kw iq mr b gy mx my l mz na">SELECT SQL_NO_CACHE v.*, vu1.*<br/>FROM  Vehicles AS v<br/>LEFT JOIN VehicleUpdates AS vu1 <br/>    ON v.plate = vu1.vehiclePlate <br/>        AND v.organizationId = vu1.organizationId<br/>LEFT JOIN  VehicleUpdates AS vu2 <br/>    ON vu1.organizationId = vu2.organizationId <br/>        AND vu1.vehiclePlate = vu2.vehiclePlate<br/>        AND vu2.createdAt &gt; vu1.createdAt<br/><strong class="mr ir">WHERE v.organizationId = '&lt;SOME ORGANIZATION ID&gt;'</strong><br/>    AND vu2.id IS NULL<br/><strong class="mr ir">LIMIT 100;</strong></span></pre><p id="63ac" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">结果呢？🥁🥁🥁…:我得到了与没有<code class="fe mo mp mq mr b">Vehicles</code>表的查询相同的<code class="fe mo mp mq mr b">40 ms</code>🎉🎉🎉！</p><h1 id="897f" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结论</h1><p id="6e03" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">事实证明，<code class="fe mo mp mq mr b">LEFT JOIN</code>的方法表现稍好，这与我对瑞克·詹姆斯博客文章的预期相反。</p><p id="25d5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">差异非常小，可能是由于统计噪声，因为我没有使用任何合适的基准工具或严格的方法。我对拥有最少和最多相关车辆的<code class="fe mo mp mq mr b">organizationId</code>进行了20次查询，然后计算了执行时间的算术平均值。我更愿意说两者有相似的表现。</p><p id="17e5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然而，我最终选择了<code class="fe mo mp mq mr b">LEFT JOIN</code>方法，因为它允许我创建一个视图来简化最终的查询:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="c47b" class="mw kw iq mr b gy mx my l mz na">CREATE VIEW LatestVehicleUpdates AS<br/>SELECT vu1.id, vu1.organizationId, vu1.vehiclePlate, vu1.status, vu1.createdAt, vu1.updatedAt<br/>FROM VehicleUpdates AS vu1 <br/>LEFT JOIN  VehicleUpdates AS vu2 <br/>    ON vu1.organizationId = vu2.organizationId <br/>        AND vu1.vehiclePlate = vu2.vehiclePlate<br/>        AND vu2.createdAt &gt; vu1.createdAt<br/>WHERE vu2.id IS NULL;</span></pre><p id="ca1c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后，我可以运行以下查询来解决我最初的问题:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="cfaa" class="mw kw iq mr b gy mx my l mz na">SELECT v.*, lvu.*<br/>FROM Vehicles<br/>LEFT JOIN LatestVehicleUpdates as lvu<br/>    ON v.organizationId = lvu.organizationId<br/>    AND v.plate = lvu.vehiclePlate<br/>WHERE organizationId =  '&lt;SOME ORGANIZATION ID&gt;'<br/>LIMIT 100;</span></pre><p id="6443" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">那都是乡亲们！</p></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="ae3c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你喜欢你刚刚读的吗？给我买杯啤酒(如果早于下午5点，我可能会泡杯咖啡):</p><div class="oq or gp gr os ot"><a href="https://tippin.me/@hbarcelos90" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">tippin.me</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">使用闪电网络和比特币，通过网络收取小额小费和微支付的简单方法。</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">tippin.me</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kp ot"/></div></div></a></div></div></div>    
</body>
</html>