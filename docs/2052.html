<html>
<head>
<title>What is: chroot — system call and utility in Linux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是:ch root—Linux中的系统调用和实用程序</h1>
<blockquote>原文：<a href="https://itnext.io/what-is-chroot-the-system-call-and-utility-in-linux-19d8bdf5c599?source=collection_archive---------3-----------------------#2019-03-23">https://itnext.io/what-is-chroot-the-system-call-and-utility-in-linux-19d8bdf5c599?source=collection_archive---------3-----------------------#2019-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c058e8bbf1c99f8585675fb1e8bfa157.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/0*-f4halpnqvgS32Ec.jpg"/></div></figure><p id="3b28" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">chroot()</code>是在1979年被添加到第7版Unix中的，用于文件系统隔离。</p><p id="f630" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事实上，它是整个当前容器化思想的前身，只是现在使用了名称空间和cgroups，而早期的chroot用于创建一个与主机隔离的环境，例如，可以用于测试目的。</p><p id="6aa8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另外，<em class="kx"> ch </em>和<em class="kx"> root </em>是(文件系统的)<em class="kx"> change </em>和<em class="kx"> root </em>的“缩写”。</p><h2 id="bb43" class="ky kz iq bd la lb lc dn ld le lf dp lg kf lh li lj kj lk ll lm kn ln lo lp lq bi translated">Linux文件系统树</h2><p id="4587" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Linux中的目录树通常看起来像next(参见<a class="ae kw" href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" rel="noopener ugc nofollow" target="_blank">文件系统层次标准</a>):</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lw"><img src="../Images/5b6cc23dac13282573aac0df68064a36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TCG9NaFcJvJzn7uz.png"/></div></div></figure><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="0162" class="ky kz iq kv b gy mj mk l ml mm">$ tree -d -L 1 /<br/>/<br/>├── bin -&gt; usr/bin<br/>├── boot<br/>├── data<br/>├── dev<br/>├── etc<br/>├── home<br/>├── lib -&gt; usr/lib<br/>├── lib64 -&gt; usr/lib<br/>├── lost+found<br/>├── mnt<br/>├── opt<br/>├── proc<br/>├── root<br/>├── run<br/>├── sbin -&gt; usr/bin<br/>├── srv<br/>├── sys<br/>├── tmp<br/>├── usr<br/>└── var</span></pre><p id="e449" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">chroot()</code>允许创建一个嵌套文件系统树，可通过下图演示:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lw"><img src="../Images/073670f698cedd3ecb47ca5db75dec77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q0VSpKGLOhr5aUiS.png"/></div></div></figure><p id="3627" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面我们将通过一些C代码的例子来仔细看看<code class="fe ks kt ku kv b">chroot()</code>，以及<code class="fe ks kt ku kv b">chroot</code>实用程序及其在操作系统中的用法。</p><h2 id="045d" class="ky kz iq bd la lb lc dn ld le lf dp lg kf lh li lj kj lk ll lm kn ln lo lp lq bi translated"><code class="fe ks kt ku kv b">chroot()</code>-Linux系统调用</h2><p id="d119" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">因此，chroot旨在通过更改文件系统的根目录来限制对文件系统的访问。</p><p id="f827" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">也就是说，不是像这样的目录结构:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="c67e" class="ky kz iq kv b gy mj mk l ml mm">$ tree -d -L 1 /<br/>/<br/>├── bin -&gt; usr/bin<br/>├── boot<br/>├── data<br/>...<br/>├── tmp<br/>├── usr<br/>└── var</span></pre><p id="8cba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个进程将只看到那些被传递给<code class="fe ks kt ku kv b">chroot()</code>的参数限制在顶层的。</p><p id="fc85" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们创建下一个要使用的目录，例如:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="aa26" class="ky kz iq kv b gy mj mk l ml mm">$ mkdir -p /tmp/chroot/{1,2,3,4}</span></pre><p id="7c3f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们用C语言编写下一段代码:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="7d68" class="ky kz iq kv b gy mj mk l ml mm">#include &lt;stdio.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include &lt;dirent.h&gt;<br/><br/>int main(void) {<br/><br/>    // check path before chroot()<br/>    char t_cwd[PATH_MAX];<br/>    getcwd(t_cwd, sizeof(t_cwd));<br/>    printf("Current dir before chroot(): %s\n", t_cwd);<br/><br/>    // do chroot()<br/>    chdir("/tmp/chroot/");<br/>    if (chroot("/tmp/chroot/") != 0) {<br/>        perror("chroot /tmp/chroot/");<br/>        return 1;<br/>    }<br/><br/>    // check path path after chroot()<br/>    char a_cwd[PATH_MAX];<br/>    getcwd(a_cwd, sizeof(a_cwd));<br/>    printf("Current dir after chroot(): %s\n", a_cwd);<br/><br/>    // point dr struct to the "root"<br/>    struct dirent *de;<br/>    DIR *dr = opendir("/");  <br/>  <br/>    // run readdir() and list "root"'s content<br/>    while ((de = readdir(dr)) != NULL)  <br/>        printf("%s\n", de-&gt;d_name);  <br/><br/>    // try to open /etc/passwd from a "host" filesystem<br/>    FILE *f;<br/>    f = fopen("/etc/passwd", "r");<br/><br/>    if (f == NULL) {<br/>        perror("/etc/passwd");<br/>        return 1;<br/>    } else {<br/>        char buf[100];<br/>        while (fgets(buf, sizeof(buf), f)) {<br/>             printf("%s", buf);<br/>        }<br/>    }<br/><br/>    return 0;<br/>}</span></pre><p id="ea8f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里它将:</p><ul class=""><li id="d1b4" class="mn mo iq jw b jx jy kb kc kf mp kj mq kn mr kr ms mt mu mv bi translated">调用<code class="fe ks kt ku kv b">chroot()</code>前检查当前路径</li><li id="1ad4" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">呼叫<code class="fe ks kt ku kv b">chroot()</code></li><li id="634a" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">再次检查当前路径</li><li id="b048" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">获取“根”内容</li><li id="0da7" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">尝试打开“真实”文件系统上的<code class="fe ks kt ku kv b">/etc/passwd</code>文件</li></ul><p id="9cca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">构建它:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="11b3" class="ky kz iq kv b gy mj mk l ml mm">$ gcc chroot_example.c -o chroot_example</span></pre><p id="1cd8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并运行检查(由于<code class="fe ks kt ku kv b">chroot()</code>只能由root使用，因此<code class="fe ks kt ku kv b">sudo</code>):</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="b1be" class="ky kz iq kv b gy mj mk l ml mm">$ sudo ./chroot_example<br/>Current dir before chroot(): /home/setevoy/Scripts/C<br/>Current dir after chroot(): /<br/>.<br/>..<br/>4<br/>3<br/>2<br/>1<br/>/etc/passwd: No such file or directory</span></pre><p id="9d19" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">chroot()</code>本身是在内核的<code class="fe ks kt ku kv b"><a class="ae kw" href="https://elixir.bootlin.com/linux/v5.0.3/source/fs/open.c#L519" rel="noopener ugc nofollow" target="_blank">open.c</a></code>文件中定义的:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="0838" class="ky kz iq kv b gy mj mk l ml mm">SYSCALL_DEFINE1(chroot, const char __user *, filename)<br/>{<br/>  return ksys_chroot(filename);<br/>}</span></pre><p id="9e9d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并将返回<code class="fe ks kt ku kv b"><a class="ae kw" href="https://elixir.bootlin.com/linux/v5.0.3/source/fs/open.c#L486" rel="noopener ugc nofollow" target="_blank">ksys_chroot()</a></code>:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="a3ae" class="ky kz iq kv b gy mj mk l ml mm">int ksys_chroot(const char __user *filename)<br/>{<br/>  struct path path;<br/>  int error;<br/>  unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;<br/>retry:<br/>  error = user_path_at(AT_FDCWD, filename, lookup_flags, &amp;path);<br/>  if (error)<br/>    goto out;<br/><br/>  error = inode_permission(path.dentry-&gt;d_inode, MAY_EXEC | MAY_CHDIR);<br/>  if (error)<br/>    goto dput_and_out;<br/><br/>  error = -EPERM;<br/>  if (!ns_capable(current_user_ns(), CAP_SYS_CHROOT))<br/>    goto dput_and_out;<br/>  error = security_path_chroot(&amp;path);<br/>  if (error)<br/>    goto dput_and_out;<br/><br/>  set_fs_root(current-&gt;fs, &amp;path);<br/>  error = 0;<br/>dput_and_out:<br/>  path_put(&amp;path);<br/>  if (retry_estale(error, lookup_flags)) {<br/>    lookup_flags |= LOOKUP_REVAL;<br/>    goto retry;<br/>  }<br/>out:<br/>  return error;<br/>}</span></pre><p id="89ee" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它将依次调用流程的<code class="fe ks kt ku kv b"><a class="ae kw" href="https://elixir.bootlin.com/linux/latest/source/fs/fs_struct.c#L14" rel="noopener ugc nofollow" target="_blank">set_fs_root()</a></code>:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="142b" class="ky kz iq kv b gy mj mk l ml mm">void set_fs_root(struct fs_struct *fs, const struct path *path)<br/>{<br/>  struct path old_root;<br/><br/>  path_get(path);<br/>  spin_lock(&amp;fs-&gt;lock);<br/>  write_seqcount_begin(&amp;fs-&gt;seq);<br/>  old_root = fs-&gt;root;<br/>  fs-&gt;root = *path;<br/>  write_seqcount_end(&amp;fs-&gt;seq);<br/>  spin_unlock(&amp;fs-&gt;lock);<br/>  if (old_root.dentry)<br/>    path_put(&amp;old_root);<br/>}</span></pre><p id="a21c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在这里&gt; &gt; 和<a class="ae kw" href="https://stackoverflow.com/a/28128030/2720802" rel="noopener ugc nofollow" target="_blank">这里&gt; &gt; &gt; </a>找到好的syscalls描述。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h2 id="399d" class="ky kz iq bd la lb lc dn ld le lf dp lg kf lh li lj kj lk ll lm kn ln lo lp lq bi translated"><code class="fe ks kt ku kv b">chroot</code>-Linux实用程序</h2><p id="4cd6" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">要在Linux中创建一个隔离空间，您可以使用<code class="fe ks kt ku kv b">chroot</code>实用程序:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="ac70" class="ky kz iq kv b gy mj mk l ml mm">$ which chroot<br/>/usr/bin/chroot<br/>$ file /usr/bin/chroot<br/>/usr/bin/chroot: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f3861107940247a67dbbf6343fa5ff1c1c70305c, stripped</span></pre><p id="f010" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们用一个隔离的文件系统为我们的“监狱”创建一个目录:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="3921" class="ky kz iq kv b gy mj mk l ml mm">$ cd /tmp/<br/>$ mkdir changed_root</span></pre><p id="ee76" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">实际上，<code class="fe ks kt ku kv b">chroot</code>实用程序将调用同一个<code class="fe ks kt ku kv b">chroot()</code>系统调用——让我们用<code class="fe ks kt ku kv b"><a class="ae kw" href="https://rtfm.co.ua/linux-strace-otslezhivaem-vypolnenie-processa/" rel="noopener ugc nofollow" target="_blank">strace</a></code>检查一下:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="11a6" class="ky kz iq kv b gy mj mk l ml mm">$ sudo strace -e trace=chroot chroot changed_root/<br/>chroot("changed_root/")                 = 0<br/>chroot: failed to run command ‘/bin/bash’: No such file or directory<br/>+++ exited with 127 +++</span></pre><p id="8db3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="kx"> '/bin/bash ':没有这样的文件或目录</em>错误是因为在这个新环境中没有<code class="fe ks kt ku kv b">/bin</code>目录和<code class="fe ks kt ku kv b">bash</code>可执行文件。</p><p id="1003" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">同样，如果尝试调用任何其他程序，也会返回这样的错误:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="624c" class="ky kz iq kv b gy mj mk l ml mm">[setevoy@setevoy-arch-work /tmp]  $ which ls<br/>/usr/bin/ls<br/>[setevoy@setevoy-arch-work /tmp]  $ sudo chroot changed_root /usr/bin/ls<br/>chroot: failed to run command ‘/usr/bin/ls’: No such file or directory</span></pre><p id="a707" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们修复它——在我们的<code class="fe ks kt ku kv b">/tmp/changed_root</code>中创建<code class="fe ks kt ku kv b">/bin</code>目录，并从这个“容器”内的一个“主机”中复制<code class="fe ks kt ku kv b">bash</code>文件:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="35d6" class="ky kz iq kv b gy mj mk l ml mm">[setevoy@setevoy-arch-work /tmp]  $ mkdir changed_root/bin<br/>[setevoy@setevoy-arch-work /tmp]  $ cp /bin/bash changed_root/bin<br/>[setevoy@setevoy-arch-work /tmp]  $ file changed_root/bin/bash<br/>changed_root/bin/bash: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=357034d1736cd97d2c8f8347045250dbd0de998e, stripped</span></pre><p id="d090" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">再试一次:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="6220" class="ky kz iq kv b gy mj mk l ml mm">[setevoy@setevoy-arch-work /tmp]  $ sudo chroot changed_root /bin/bash<br/>chroot: failed to run command ‘/bin/bash’: No such file or directory</span></pre><p id="49ab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好吧。</p><p id="c3b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但现在是因为没有必要的库而导致的— <code class="fe ks kt ku kv b">chroot</code>就是说不出来这个。</p><p id="3ec5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查<code class="fe ks kt ku kv b">bash</code>与<code class="fe ks kt ku kv b"><a class="ae kw" href="http://man7.org/linux/man-pages/man1/ldd.1.html" rel="noopener ugc nofollow" target="_blank">ldd</a></code>的相关性:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="186e" class="ky kz iq kv b gy mj mk l ml mm">[setevoy@setevoy-arch-work /tmp]  $ ldd /bin/bash<br/>linux-vdso.so.1 (0x00007ffe37f16000)<br/>libreadline.so.8 =&gt; /usr/lib/libreadline.so.8 (0x00007f39b13d2000)<br/>libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007f39b13cd000)<br/>libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f39b1209000)<br/>libncursesw.so.6 =&gt; /usr/lib/libncursesw.so.6 (0x00007f39b119a000)<br/>/lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f39b153f000)</span></pre><p id="93f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们新的工作目录中再创建两个目录— <code class="fe ks kt ku kv b">/lib</code>和<code class="fe ks kt ku kv b">/lib64</code>:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="1967" class="ky kz iq kv b gy mj mk l ml mm">[setevoy@setevoy-arch-work /tmp]  $ mkdir changed_root/usr/lib changed_root/lib64</span></pre><p id="7266" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并复制libs文件:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="3f7c" class="ky kz iq kv b gy mj mk l ml mm">[setevoy@setevoy-arch-work /tmp]  $ cp /usr/lib/libreadline.so.8 changed_root/usr/lib/<br/>[setevoy@setevoy-arch-work /tmp]  $ cp /usr/lib/libdl.so.2 changed_root/usr/lib/<br/>[setevoy@setevoy-arch-work /tmp]  $ cp /usr/lib/libc.so.6 changed_root/usr/lib/<br/>[setevoy@setevoy-arch-work /tmp]  $ cp /usr/lib/libncursesw.so.6 changed_root/usr/lib/<br/>[setevoy@setevoy-arch-work /tmp]  $ cp /lib64/ld-linux-x86-64.so.2 changed_root/lib64</span></pre><p id="497e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">再次运行<code class="fe ks kt ku kv b">chroot</code>:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="13b5" class="ky kz iq kv b gy mj mk l ml mm">[setevoy@setevoy-arch-work /tmp]  $ sudo chroot changed_root/<br/>bash-5.0#</span></pre><p id="abc5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们有了在这里运行的<code class="fe ks kt ku kv b">bash</code>和它所有的内置函数:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="2531" class="ky kz iq kv b gy mj mk l ml mm">bash-5.0# pwd<br/>/</span></pre><p id="c032" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是很明显——没有其他外部实用程序可以在这里工作:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="c837" class="ky kz iq kv b gy mj mk l ml mm">bash-5.0# ls -l<br/>bash: ls: command not found</span></pre><p id="31ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这可以用我们为<code class="fe ks kt ku kv b">bash</code>所做的同样的方法来修复:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="a87e" class="ky kz iq kv b gy mj mk l ml mm">[setevoy@setevoy-arch-work /tmp]  $ which ls<br/>/usr/bin/ls<br/>[setevoy@setevoy-arch-work /tmp]  $ cp /usr/bin/ls changed_root/bin/<br/>[setevoy@setevoy-arch-work /tmp]  $ ldd /usr/bin/ls<br/>linux-vdso.so.1 (0x00007ffdebbf5000)<br/>libcap.so.2 =&gt; /usr/lib/libcap.so.2 (0x00007fa5b147d000)<br/>libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007fa5b12b9000)<br/>/lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007fa5b14d8000)<br/>[setevoy@setevoy-arch-work /tmp]  $ cp /usr/lib/libcap.so.2 changed_root/usr/lib/</span></pre><p id="adf1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">其他库已经被复制，所以让我们再次运行<code class="fe ks kt ku kv b">ls</code>:</p><pre class="lx ly lz ma gt mf kv mg mh aw mi bi"><span id="31c8" class="ky kz iq kv b gy mj mk l ml mm">bash-5.0# /bin/ls -l /<br/>total 0<br/>drwxr-xr-x 2 1000 1000  80 Mar 22 11:45 bin<br/>drwxr-xr-x 2 1000 1000 120 Mar 22 11:37 lib<br/>drwxr-xr-x 2 1000 1000  60 Mar 22 11:38 lib64<br/>drwxr-xr-x 3 1000 1000  60 Mar 22 11:39 usr</span></pre><h2 id="44b3" class="ky kz iq bd la lb lc dn ld le lf dp lg kf lh li lj kj lk ll lm kn ln lo lp lq bi translated">请参见</h2><ul class=""><li id="d4ac" class="mn mo iq jw b jx lr kb ls kf ni kj nj kn nk kr ms mt mu mv bi translated"><a class="ae kw" href="https://blog.selectel.com/containerization-mechanisms-namespaces/" rel="noopener ugc nofollow" target="_blank">容器化机制:名称空间</a></li><li id="3a68" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated"><a class="ae kw" href="https://www.geeksforgeeks.org/linux-virtualization-using-chroot-jail/" rel="noopener ugc nofollow" target="_blank"> Linux虚拟化— Chroot Jail </a></li><li id="9a01" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/chroot-cgroups-and-namespaces-an-overview-37124d995e3d"> chroot、cgroups和名称空间——概述</a></li><li id="b64a" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated"><a class="ae kw" href="https://utcc.utoronto.ca/~cks/space/blog/unix/ChrootHistory" rel="noopener ugc nofollow" target="_blank">ch root()有点令人惊讶的历史</a></li><li id="b8a6" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated"><a class="ae kw" href="https://linux.die.net/man/2/chroot" rel="noopener ugc nofollow" target="_blank"> chroot(2) — Linux手册页</a></li><li id="9288" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated"><a class="ae kw" href="https://lwn.net/Articles/604287/" rel="noopener ugc nofollow" target="_blank">系统调用剖析，第1部分</a></li></ul></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="70f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="kx">最初发布于</em> <a class="ae kw" href="https://rtfm.co.ua/en/what-is-chroot-the-system-call-and-utility-in-linux/" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> RTFM: Linux、DevOps和系统管理</em> </a> <em class="kx">。</em></p></div></div>    
</body>
</html>