<html>
<head>
<title>Redux-Observable code that fixes everything.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">redux-修复一切的可观察代码。</h1>
<blockquote>原文：<a href="https://itnext.io/redux-observable-code-that-fixes-everything-b7832b904b6b?source=collection_archive---------3-----------------------#2019-12-12">https://itnext.io/redux-observable-code-that-fixes-everything-b7832b904b6b?source=collection_archive---------3-----------------------#2019-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5d0a115226c640a23d6739c0f004603b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2VYEtfjrRjdAL1Hd"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@realaxer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">田宽</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h2 id="9716" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph">使得复杂的冗余可观测数据更容易查找。</h2><div class=""/><div class=""><h2 id="3c72" class="pw-subtitle-paragraph km jp jg bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated">一个简单的提示就能让你成功。</h2></div><p id="9411" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果您曾经使用过Redux-Observable，那么您可能会遇到这样的情况:您需要在管道的顶部分派一些东西，然后再做其他事情。</p><p id="c5f8" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这是一个常见的问题，但不是一目了然的问题。因为Redux-Observable v1会自动调度任何通过管道的内容，这意味着您必须拆分管道以完成第一个操作，然后切换到另一个继续原始管道的可观察对象。</p><h1 id="4ddf" class="ma mb jg bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">管道分裂</h1><p id="8c70" class="pw-post-body-paragraph le lf jg lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">它看起来像这样:</p><figure class="mx my mz na gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f708" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">使用这种方法，您最终必须以一种非常复杂的方式分割管道，这对于初学者来说并不明显。这在所有用例中都有效，这也是我目前为止设置所有Redux-Observable项目的方式。我甚至说<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/redux-observable-can-solve-your-state-problems-15b23a9649d7"> <em class="nd"> Redux-Observable里的流水线分裂会解决你的状态问题</em> </a>。</p><p id="784d" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Redux-Observable有一些奇怪的地方，管道分割(如本例所示)是影响新手的最大问题之一。可悲的是，这也是<em class="nd"/>类的事情Redux-Observable应该使之变得容易。</p><p id="8659" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我经常在<a class="ae jd" href="https://gitter.im/redux-observable/redux-observable" rel="noopener ugc nofollow" target="_blank"> Redux-Observable的官方Gitter chat </a>上看到关于管道拆分的问题(或者缺乏如何拆分的知识)，一个朋友今天在他使用Redux-Observable的第二天问了我同样的问题。</p><h1 id="da19" class="ma mb jg bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">反模式</h1><p id="7356" class="pw-post-body-paragraph le lf jg lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">Redux-Observable自动将任何失败的操作分派给订阅者。因此，我在我的文章中提出了一种不同的模式来解决这个问题:<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/the-best-practice-anti-pattern-5e8bd873aadf"> <em class="nd"> Redux-Observable的最佳实践是一种反模式</em> </a>。</p><p id="529e" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我对管道分割的解决方案是从Redux公开<code class="fe ne nf ng nh b">dispatch</code>方法。我还要求你不要让行动通过管道，以确保你不是有时自动调度，有时手动调度。</p><p id="2f4a" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">看起来是这样的:</p><figure class="mx my mz na gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="bcf1" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">很快，您应该能够看出这是一个重大的改进。不仅保留了顺序执行，而且从逻辑上讲，这对人们来说很有意义。</p><p id="2546" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">它也减少了你跳转的深度，并且更容易可视化按顺序执行的事件序列。这是一个非常巧妙的解决方案，我还没能找到它崩溃的情况。</p><p id="5d7d" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">需要注意的一点是，这种方法依赖于副作用的同步执行。在<code class="fe ne nf ng nh b">tap</code>中调用<code class="fe ne nf ng nh b">dispatch</code>是一个副作用。当您调用它时，在下一个操作符执行之前，必须运行一堆reducer代码和其他史诗。这可能会也可能不会立即显现出来。由于Redux同步执行reducers，这就是为什么它这样工作的原因。</p><p id="3e59" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">对于大多数人来说，我认为手动分派比自动分派更有意义。它更直观，但不是官方认可的。事实上，它被主要开发者Jay Phelps称为反模式。</p><p id="2e25" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">不过，这并不意味着什么坏事。杰伊在Twitter上澄清说，我正在以非设计的方式使用该库，而不是说我在做一些破坏的事情。</p><h1 id="6333" class="ma mb jg bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">埃弗特·鲍方法</h1><p id="7689" class="pw-post-body-paragraph le lf jg lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">Evert是谁，这是什么方法？Evert Bouw是Redux-Observable的贡献者，也是该库的生产用户。</p><p id="3e4f" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在ReactConf 2019上展示了Evert我的反模式方法后，他提出了一个利用自动分派的不同解决方案:</p><figure class="mx my mz na gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7472" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">他解决的关键是<code class="fe ne nf ng nh b">startWith</code>和<code class="fe ne nf ng nh b">endWith</code>。看看这个特殊的例子，它极大地简化了定时动作的输出。它甚至会跳出与反模式版本完全相同的标签。</p><p id="b430" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一些警告:</p><ul class=""><li id="e47e" class="ni nj jg lg b lh li lk ll ln nk lr nl lv nm lz nn no np nq bi translated">您会丢失管道操作符的顺序执行。<code class="fe ne nf ng nh b">startWith</code>必须放在任何计算当前值的管道下面。</li><li id="9cbc" class="ni nj jg lg b lh nr lk ns ln nt lr nu lv nv lz nn no np nq bi translated">你必须知道<code class="fe ne nf ng nh b">startWith</code>是存在的，当它在任何其他操作符(包括传入值的操作符)之前被订阅时，它首先在管道中执行。</li><li id="a6ba" class="ni nj jg lg b lh nr lk ns ln nt lr nu lv nv lz nn no np nq bi translated">如果您需要<code class="fe ne nf ng nh b">endWith</code>中的<code class="fe ne nf ng nh b">state$</code>，那么您将需要返回一个带有动作数组的<code class="fe ne nf ng nh b">concatMap</code>操作符。<code class="fe ne nf ng nh b">concatMap</code>采用一个回调函数，确保您在那个时间点拥有<code class="fe ne nf ng nh b">state$</code>，而不是在内部可观察对象被创建的时候。</li></ul><p id="4fe3" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Evert的方法让我大吃一惊。虽然我以前使用过<code class="fe ne nf ng nh b">startWith</code>和<code class="fe ne nf ng nh b">endWith</code>，但是我从来没有考虑过在这个特定的场景中使用它们。当我重构没有<code class="fe ne nf ng nh b">dispatch</code>可用的现有项目时，这将是一个巨大的帮助。</p><h2 id="d498" class="nw mb jg bd mc nx ny dn mg nz oa dp mk ln ob oc mm lr od oe mo lv of og mq jm bi translated">你可以做得更多！</h2><p id="9661" class="pw-post-body-paragraph le lf jg lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated"><code class="fe ne nf ng nh b">startWith</code>和<code class="fe ne nf ng nh b">endWith</code>都带多个参数。每一个都单独得到输出，就像你使用<code class="fe ne nf ng nh b">of</code>可观测值一样:</p><figure class="mx my mz na gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="85d5" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">和我上面的注释一样，记住<code class="fe ne nf ng nh b">endWith</code>接受一个值，而不是一个回调。要在运行时获得最新的值，请使用<code class="fe ne nf ng nh b">concatMap</code>或类似的代码。我再怎么强调这一点也不为过，因为如果你不小心的话，它会引起海森伯格综合症。</p><h1 id="dbe9" class="ma mb jg bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">结论</h1><p id="fb7e" class="pw-post-body-paragraph le lf jg lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">这些解决方案中哪一个最适合您的项目？<strong class="lg jq">你想出了哪些解决同样问题的方法？</strong></p><p id="f021" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我仍然不确定Evert的方法是否在每种情况下都有效，但我会尝试一下，看看结果。这里肯定有潜力，但在超级复杂的史诗中(我似乎经常写的那种)，管道分裂或<code class="fe ne nf ng nh b">dispatch</code>可能是唯一的方法。</p><p id="3add" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我鼓励你<strong class="lg jq">评论你对这个话题的想法和体验</strong>，这样我们才能真正改善Redux-Observable开发者体验。</p><h1 id="b61f" class="ma mb jg bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">更多阅读</h1><p id="519e" class="pw-post-body-paragraph le lf jg lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">如果你喜欢你所读的，请查看我关于类似的令人大开眼界的主题的其他文章:</p><ul class=""><li id="0eff" class="ni nj jg lg b lh li lk ll ln nk lr nl lv nm lz nn no np nq bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/redux-observable-can-solve-your-state-problems-15b23a9649d7"> Redux-Observable将解决您的状态问题</a></li><li id="e80e" class="ni nj jg lg b lh nr lk ns ln nt lr nu lv nv lz nn no np nq bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/the-best-practice-anti-pattern-5e8bd873aadf"> Redux-Observable的最佳实践是反模式</a></li><li id="5581" class="ni nj jg lg b lh nr lk ns ln nt lr nu lv nv lz nn no np nq bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/the-definitive-guide-to-callbacks-in-javascript-44a39c065292">回访:权威指南</a></li><li id="ea95" class="ni nj jg lg b lh nr lk ns ln nt lr nu lv nv lz nn no np nq bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/promises-the-definitive-guide-6a49e0dbf3b7">承诺:权威指南</a></li></ul></div></div>    
</body>
</html>