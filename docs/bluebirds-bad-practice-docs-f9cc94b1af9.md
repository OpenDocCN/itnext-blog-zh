# 蓝鸟的不良行为记录

> 原文：<https://itnext.io/bluebirds-bad-practice-docs-f9cc94b1af9?source=collection_archive---------3----------------------->

![](img/f38947cf2a8d98adc4f755ba8249c231.png)

照片由 [Benoit Gauzere](https://unsplash.com/@bgauzere?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

## Node.js 开发人员使用的糟糕的最佳实践

*这篇文章颇有争议。我知道。我发表这篇文章是希望能让这个行业朝着积极的方向发展，但是我知道总有磨合期或者完全错误的可能性。*

有很多 promise 库，但是到目前为止，最流行的，也可能是您将在产品中实际看到的，是 Bluebird。这是一个很棒的 promise 库，有很多特性，但是有一个很大的缺陷。

# 名称又能代表什么呢

不是作为`Bluebird`导入的，官方文档和常用的是这样命名`Promise`:

```
const Promise = require('bluebird')// orimport Promise from 'bluebird'
```

这是因为蓝鸟实际上早在承诺出现在 JavaScript 之前就出现了。虽然将它作为`Promise`导入可以让你编写和你一直做的一样的承诺代码以及一些额外的东西，但这可能会让其他开发者非常困惑，因为不是所有的承诺都是蓝鸟承诺。

例如，如果你导入另一个使用承诺的库，它们就不是蓝鸟承诺。还有，如果你用`fetch`那些也不会是蓝鸟的承诺。最后，如果你创建了自己的承诺，但忘记在应用程序的其他地方导入蓝鸟，那些*也*不会是蓝鸟承诺。

## 覆盖所有的东西！

解决办法是用蓝鸟覆盖全球承诺。我反对这样做有很多原因，但其中之一是突然之间你的整个应用程序的 JavaScript 版本不再遵循规范。这是另一个会给你的项目带来新进展的事情，你必须解释清楚。

在重写 JavaScript 全局变量的过程中，还会遇到很多其他问题。在我看来，很难在使用和不使用蓝鸟的项目之间进行上下文切换。另一个是切换库的能力。一旦你把自己和蓝鸟绑在一起，你就被它缠住了。如果它有很大的安全漏洞呢？如果想用 RxJS 代替呢？你不能围绕它写作，而是强迫自己把它用在任何事情上。

## 爱你的邻居(6 个月后就是你)

我可能听起来很奇怪，因为今天很多人都这样使用蓝鸟，但从我的个人经验来看，我不建议这样做。一旦行业发生变化，你的应用程序现在使用传统技术，你就要为变化做好准备。

这都是维护的问题。在某种程度上，用老方法(或者真的是错误的方法)做事会让雇佣新开发人员的成本更高。根据我的经验，当你要求开发人员处理遗留代码时，他们会希望这是暂时的，或者很快就会重写。

虽然您可能不希望同时使用本机实现和 Bluebird，但我的建议是总是在您希望使用它的地方导入 Bluebird，并总是将导入的库命名为`Bluebird`，以向所有开发人员发出“我正在使用 Bluebird promise 库”的信号。

有了这样的改变，其他开发人员就不必每次在一个文件中时都猜测或不断检查 Bluebird 是否被导入到每个文件中。这样，你总是知道你有什么样的承诺。现在，您的应用程序可以随着时间的推移轻松维护和重构，而不用担心这个迫在眉睫的蓝鸟问题。

# 许诺

像 RxJS 中的`bindCallback`一样，您可以使用`Promise.promisify`在承诺中自动包装回调函数。我在家里的灯光控制器软件的第一个版本中使用了这种方法，因为每当我想使用时，将回调转换为承诺会很累。

另一方面，我不建议使用`Promise.promisifyAll`。我知道它有它的用途，但是它改变了你给它的对象，我喜欢明确地说明这些事情，特别是因为现在你把你的常规库绑定到了蓝鸟上。我不喜欢改变 Node.js 库或者你的浏览器的`window`对象，因为开发人员不会知道到底发生了什么。

## 我能有所有的问题吗？

例如，开发人员可能会导入`fs`原生 Node.js 库，却发现每个函数都有一个自定义的 promisified async 版本，该版本返回一个承诺而不是接受一个回调，并且代码库中没有任何内容与官方 Node.js 文档匹配。这是混淆视听的好方法。

在承诺的版本后面加上“async”会使它更加混乱，因为从技术上来说`fs.readFile`已经是异步的了，但是现在有了`fs.readFileAsync`也是异步的，但是明确地承诺了。为什么不是`fs.readFilePromisified`？太久了？也许你不应该变异`fs`。

换一种方式来说，现在有两种完全不同的方式来调用本地库上的函数。您不是将这些调用包装在您自己的实用程序文件中(这也有它的缺点)，而是依靠代码审查，可能是林挺规则，以及口碑来确保开发人员使用首选的方法。

否则，您将拥有一个包含各种编码风格的大型代码库。总是留给下一个接手的开发人员一个头痛的问题，他想知道为什么这里是一种方式，而在另一个地方是完全不同的方式。

如果你在过去的 20 年里曾经使用过 JavaScript，你会遇到同样的事情导致你的噩梦(你甚至可以覆盖`undefined`)，并且在 React 流行起来的时候，它被羞愧地淘汰了。蓝鸟早于这种变化，但最新的文件也没有警告它；事实上，他们鼓励这样做。

像这样改变图书馆和全球价值观是《T2》之后的活遗产。这是将您的项目与单个库捆绑在一起的好方法。

# 结论

我知道这是有争议的。我希望使用蓝鸟的开发者有他们自己的恐怖故事，但事实是，我可能会得到很多负面反馈。如果你在我的评估中发现了缺陷，**我鼓励你提供反馈**，这样我就知道下次写文章时应该改进什么。

# 更多阅读

如果你喜欢你所读的，请查看我关于类似的令人大开眼界的主题的其他文章:

*   [无冗余的冗余可观察](/redux-observable-without-redux-ff4a2b5a4b39)
*   [特性标志:真正敏捷](/feature-flags-be-truly-agile-820ff50294c)
*   [用食物表情符号制作便便](/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223)
*   [使用转换器加速 JavaScript 数组](/using-transducers-to-speed-up-javascript-arrays-92677d000096)