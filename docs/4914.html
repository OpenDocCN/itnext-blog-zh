<html>
<head>
<title>Syntax Tree and Alternative to LINQ in Interaction with SQL Databases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">语法树和与SQL数据库交互的LINQ的替代方案</h1>
<blockquote>原文：<a href="https://itnext.io/syntax-tree-and-alternative-to-linq-in-interaction-with-sql-databases-656b78fe00dc?source=collection_archive---------1-----------------------#2020-10-22">https://itnext.io/syntax-tree-and-alternative-to-linq-in-interaction-with-sql-databases-656b78fe00dc?source=collection_archive---------1-----------------------#2020-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c000c58d581e768f4eef95283dec5fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*1podaI9L-C-sxKmiQlMdfg.png"/></div></figure><p id="06d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个遗留的企业项目，我被要求改进它的“高级”过滤功能。</p><p id="ec13" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在他们有这样的东西之前:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/802f69d79e24c04cc51c6311e0fb08e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*BqOVDTfLdKUtF98_VQSfgQ.png"/></div></figure><p id="bdc1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是想要这样的东西:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi kx"><img src="../Images/0b6ad79e18a5c7c4e93694a9e0323f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6dMU_H2Kz5bT5JbHB-jj_w.png"/></div></div></figure><p id="9757" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们跳过UI部分，专注于数据访问层。像99%的类似项目一样，这个项目使用sql数据库(MS SQL，但这并不重要),这个项目属于类似项目的一部分，它不与实体框架斗争，而是将所有逻辑放在存储过程中。执行“高级”搜索的过程如下所示:</p><pre class="kt ku kv kw gt lc ld le lf aw lg bi"><span id="900e" class="lh li iq ld b gy lj lk l ll lm">CREATE PROCEDURE dbo.SomeContextUserFind<br/>    (<a class="ae ln" href="http://twitter.com/ContextId" rel="noopener ugc nofollow" target="_blank">@ContextId</a> int, <a class="ae ln" href="http://twitter.com/Filter" rel="noopener ugc nofollow" target="_blank">@Filter</a> nvarchar(max)) AS<br/>BEGIN</span><span id="da6d" class="lh li iq ld b gy lo lk l ll lm">DECLARE <a class="ae ln" href="http://twitter.com/sql" rel="noopener ugc nofollow" target="_blank">@sql</a> nvarchar(max) = <br/>    N'SELECT U.UserId, U.FirstName, U.LastName<br/>    FROM [User] U<br/>    INNER JOIN [SomeContext] [C]<br/>      ON ....<br/>    WHERE [C].ContextId = <a class="ae ln" href="http://twitter.com/p1" rel="noopener ugc nofollow" target="_blank">@p1</a> AND ' + <a class="ae ln" href="http://twitter.com/Filter" rel="noopener ugc nofollow" target="_blank">@Filter</a>;</span><span id="ae00" class="lh li iq ld b gy lo lk l ll lm">EXEC sp_executesql <br/>    <br/>    <a class="ae ln" href="http://twitter.com/sql" rel="noopener ugc nofollow" target="_blank">@sql</a>,<br/>    N'<a class="ae ln" href="http://twitter.com/p1" rel="noopener ugc nofollow" target="_blank">@p1</a> int',<br/>    <a class="ae ln" href="http://twitter.com/p1" rel="noopener ugc nofollow" target="_blank">@p1</a>=<a class="ae ln" href="http://twitter.com/ContextId" rel="noopener ugc nofollow" target="_blank">@ContextId</a><br/>END</span></pre><p id="77ea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">生成过滤器字符串的代码如下所示:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="7747" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当然，这不是你见过的最棒的代码，但是不幸的是遗留项目(或者甚至还没有遗留)经常充满了类似的东西。不管怎么说，它就是这样，应该有所改进。</p><p id="65e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我想到的第一个想法是在“FilterItem”中添加更多的字段，使构建逻辑更加复杂，但我很快意识到这是一条没有出路的道路——维护这样的代码非常困难，我永远也不会实现所需的功能。</p><p id="6892" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这一点上，我想起了“抽象语法树”，这显然是这种情况下的最佳选择，现在我将解释它是什么以及它如何有所帮助。</p><p id="8863" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">抽象语法树</strong></p><p id="b34f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，让我们看看将要创建的过滤器字符串，例如:</p><pre class="kt ku kv kw gt lc ld le lf aw lg bi"><span id="71ae" class="lh li iq ld b gy lj lk l ll lm">[FirstName]='John' AND ([LastName]='Smith' OR [LastName]='Doe')</span></pre><p id="bea7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们可以注意到一些结构:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lr"><img src="../Images/5b76685149ba4f13373a03c14f2682d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RXzedZCI-oEQ0nA6mpVz7A.png"/></div></div></figure><p id="bdf0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个结构是一棵树，这意味着我们可以创建几个简单的类来描述它:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ls"><img src="../Images/ee7b57821a6a7b2ae784f397264b7124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qQgBQarJnyVGc-7W4ussg.png"/></div></div></figure><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="7a5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用这些类，我们可以创建一个表示原始过滤器的对象:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="33b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事实上，这种被称为“抽象语法树”的结构可以用来表示更复杂的查询，但它们都有一个可以存储在单个对象中的“根”。</p><p id="3e9a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“抽象语法树”是用定义的语法规则解析某种形式语言(在我们的例子中是布尔表达式语言)的短语的结果。这样的规则有特定的符号。例如，我们简单语言的规则(布尔表达式的子集)可以写成:</p><pre class="kt ku kv kw gt lc ld le lf aw lg bi"><span id="e564" class="lh li iq ld b gy lj lk l ll lm">&lt;eqPredicate&gt; ::= &lt;column&gt; = &lt;str&gt;<br/>&lt;or&gt; ::= &lt;eqPredicate&gt;|or|&lt;and&gt; OR &lt;eqPredicate&gt;|or|&lt;and&gt;<br/>&lt;and&gt; ::= &lt;eqPredicate&gt;|(&lt;or&gt;)|&lt;and&gt; AND &lt;eqPredicate&gt;|(&lt;or&gt;)|&lt;and&gt;</span></pre><p id="6306" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="lt">注意:“抽象”意味着语法没有描述所有的语言细节，例如，分组括号、额外空格等。</em></p><p id="e884" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">解析本身是一个独立的大主题，现在它并不那么重要，因为我们已经准备好了语法树，所以让我们专注于我们可以用它们做什么。</p><p id="0625" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> SQL代码生成</strong></p><p id="3353" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">显然，我们最重要的任务是将语法树转换回文本，我们有几种方法可以做到这一点。</p><p id="72fa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第一种方法是使用模式匹配，这非常简单:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="1698" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，构建器将包含以下行:</p><pre class="kt ku kv kw gt lc ld le lf aw lg bi"><span id="2949" class="lh li iq ld b gy lj lk l ll lm">[FirstName]='John' AND ([LastName]='Smith' OR [LastName]='Joe')</span></pre><p id="413d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看来这就是我们所需要的！</p><p id="2fce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">访客</strong></p><p id="a14a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管我热衷于函数式编程，但在这种情况下，面向对象的方法可能会提供更有效的解决方案——我说的是“访问者”模式。这种模式的思想是，我们不试图确定一个对象的类型，而是给它一个所有可能动作的列表(以接口的形式)，对象自己选择最适合它的类型的动作。让我们来定义这个列表:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="b653" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">任何物体(我们的结构)都可以接受选择:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="391f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们可以将sql代码的生成提取到一个单独的类中:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="6dc9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并按如下方式使用它:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="f5ba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">结果，我们将得到所需的字符串:</p><pre class="kt ku kv kw gt lc ld le lf aw lg bi"><span id="fa86" class="lh li iq ld b gy lj lk l ll lm">[FirstName]='John' AND ([LastName]='Smith' OR [LastName]='Joe')</span></pre><p id="2564" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与模式匹配相比，使用“访问者”模式有几个优点。因此，例如，具体类型的选择总是详尽的，因为向结构中添加新类型总是会导致<strong class="jw ir"> IExprVisitor </strong>接口的变化，结果是需要扩展其所有实现(否则将会出现编译错误)。</p><p id="4ac5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">遍历和括号</strong></p><p id="39cb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个算法有几个方面需要注意。</p><p id="9a61" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，它到底是如何工作的？</p><p id="aac8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事实上，这里我们正在对语法树进行深度优先遍历，sql代码是该遍历的一个轨迹:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lu"><img src="../Images/485fae88bb9054186ef932607bc58182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3O5mIMCE98mmBS7JyUXTw.png"/></div></div></figure><p id="6e04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第二，括号会怎么样？</p><p id="e95e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">重点是布尔表达式有一定的求值顺序。首先计算“与”运算，然后计算“或”运算。需要括号来改变这个顺序，因为括号中的任何表达式在计算中都有更高的优先级。但是在语法树中，求值的顺序是由结构本身给出的(从分支到根)，所以不需要单独的括号类型。</p><p id="ec96" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">语法的扩展</strong></p><p id="b7d0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当然，在现实中，我们还需要其他谓词，例如“不等于”,为了能够使用它，我们只需要添加一个新的类:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="5e86" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于我们有了一个新类型，编译器告诉我们需要为它实现SQL代码生成:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="e117" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们只创建了一组非常简单的布尔谓词，MS SQL支持更多，但是正如您所看到的，您可以轻松地添加所有需要的语言结构。</p><p id="d0a1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">顺便说一下，SQL Server文档包含所有非常有用的<a class="ae ln" href="https://docs.microsoft.com/en-us/sql/t-sql/queries/search-condition-transact-sql" rel="noopener ugc nofollow" target="_blank"> SQL语法</a>规则:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lv"><img src="../Images/5abbb6b812597648dcac56f891d46a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VzVFd-VQ_v4yayq0UOcQHA.png"/></div></div></figure><p id="f92a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">操作员超载</strong></p><p id="2726" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">显然，通过调用类构造函数来创建语法树一点也不方便。然而，C#运算符重载可以帮助我们做到这一点。</p><p id="cc55" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们执行以下操作:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="0c90" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们可以用一种非常简单明了的方式创建一个语法树:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="ff9e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">结果还是会是:</p><pre class="kt ku kv kw gt lc ld le lf aw lg bi"><span id="4cb5" class="lh li iq ld b gy lj lk l ll lm">[FirstName]='John' AND ([LastName]='Smith' OR [LastName]='Doe')</span></pre><p id="f94e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="lt">注意:C#不允许重载</em> <strong class="jw ir"> &amp; &amp; </strong> <em class="lt">和</em> <strong class="jw ir"> || </strong> <em class="lt">操作符，实际上这是有意义的，因为如果结果已知，这些操作符将停止进一步的计算，但是我们需要所有的部分来构建语法树(它将由SQL数据库进行计算)。</em></p><p id="84ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">接下来是什么</strong></p><p id="60b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们似乎已经用布尔过滤器解决了这个问题，但是排序和分页呢？有时还需要附加sql视图(或派生表)来对计算字段进行筛选(或排序)。</p><p id="676b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">没问题！让我们实现所有的<a class="ae ln" href="https://docs.microsoft.com/en-us/sql/t-sql/queries/select-transact-sql" rel="noopener ugc nofollow" target="_blank"> SQL SELECT </a>语法:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/bfc76976150d0f6cf75ae1ddaf945af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*-dRhcWuBfITil785rSl2BA.png"/></div></figure><p id="92a4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当然，您不需要自己去做，因为有几个库(<a class="ae ln" href="https://github.com/0x1000000/SqExpress" rel="noopener ugc nofollow" target="_blank">例如我的</a>)已经实现了这一点，所以只需将这种方法视为与SQL数据库交互的另一种方式。</p><p id="f044" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">LINQ的替代方案</strong></p><p id="b2f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们所做的操作符重载有点类似于LINQ表达式，事实上有一些实际的相似之处。C#编译器生成语法树，然后实体框架或“LINQ到SQL”等库将这些树转换成真正的SQL代码。这种方法的主要问题是编译器生成C#语言的语法树，但是我们需要SQL！将命令式C#反映到声明式SQL中并不是一件容易的事情，而且结果往往是不可预测的。</p><p id="4353" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我更喜欢一种不同的方法——它可以使用真正的SQL语法，而不是使用C #语法作为基础。除了编译器，它还可以使用运算符重载、扩展方法和流畅的生成器。</p><p id="4f87" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一方面，使用这种方法，我们获得了几乎与使用存储过程相同的灵活性。另一方面，我们有强大的类型、智能感知和不移动到数据库的业务逻辑。和…没有必要谷歌如何使用LINQ左连接)</p><p id="50c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一个优点是数据更新语句(插入、更新、删除甚至合并)也可以以相同的方式实现，并且不需要从数据库中加载成千上万的记录来更新一个列。</p><p id="4bdd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个使用真正的SQL语法作为基础可以做什么的例子(t <a class="ae ln" href="https://github.com/0x1000000/SqExpress#more-tables-and-foreign-keys" rel="noopener ugc nofollow" target="_blank">从这里开始</a>):</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="fa38" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">结论</strong></p><p id="c84d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">语法树是一种非常强大的数据结构，你迟早会遇到它。这些可能是LINQ表达式，或者你可能需要创建一个罗斯林分析器，或者你可能想自己创建自己的语法，就像我几年前为了重构一个遗留项目所做的那样。无论如何，理解这种结构并能够使用它是很重要的。</p><p id="3512" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ln" href="https://github.com/0x1000000/SqExpress" rel="noopener ugc nofollow" target="_blank"> <em class="lt">链接到SqExpress </em> </a> <em class="lt"> —一个部分包含本文代码的项目。</em></p></div></div>    
</body>
</html>