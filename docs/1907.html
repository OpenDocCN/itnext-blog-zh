<html>
<head>
<title>Vue.js App Performance Optimization: part 3— Lazy loading Vuex modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js应用程序性能优化:第3部分—延迟加载Vuex模块</h1>
<blockquote>原文：<a href="https://itnext.io/vue-js-app-performance-optimization-part-3-lazy-loading-vuex-modules-ed67cf555976?source=collection_archive---------0-----------------------#2019-02-22">https://itnext.io/vue-js-app-performance-optimization-part-3-lazy-loading-vuex-modules-ed67cf555976?source=collection_archive---------0-----------------------#2019-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/110e1f07b77a73e1a25e6ba8b62baab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8V4nPzrELcD2Tkjy4DtNQ.png"/></div></div></figure><p id="365d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在</strong> <a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/vue-js-app-performance-optimization-part-2-lazy-loading-routes-and-vendor-bundle-anti-pattern-4a62236e09f9"> <strong class="ka ir">的上一部分</strong> </a> <strong class="ka ir">中，我们学习了足以显著提高应用程序性能的模式——按路线分割代码。虽然按路线分割代码非常有帮助，但在用户访问我们的网站后，仍然有很多代码是不需要的。在本系列的这一部分中，我们将重点关注状态管理的代码分割——Vuex模块。</strong></p><p id="57bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该系列基于从<a class="ae kw" href="https://github.com/DivanteLtd/vue-storefront" rel="noopener ugc nofollow" target="_blank"> Vue店面</a>性能优化流程中获得的经验。通过使用下面的技术，我们能够将初始包的大小减少70%,并在一眨眼的时间内完成加载。</p><p id="7423" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://vueschool.io/articles/vuejs-tutorials/lazy-loading-and-code-splitting-in-vue-js/" rel="noopener ugc nofollow" target="_blank">第1部分—性能优化和延迟加载简介。</a></p><p id="c5c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/vue-js-app-performance-optimization-part-2-lazy-loading-routes-and-vendor-bundle-anti-pattern-4a62236e09f9">第2部分—惰性加载路线和供应商捆绑反模式。</a></p><p id="7135" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/vue-js-app-performance-optimization-part-3-lazy-loading-vuex-modules-ed67cf555976">第3部分—惰性加载Vuex模块</a></p><p id="5b8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第4部分——提供良好的等待体验和延迟加载单个组件——很快</p><p id="637c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第5部分—延迟加载库并寻找更小的等价库—很快</p><p id="f664" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第6部分——UI库的性能友好使用</p><p id="39f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第7部分—利用服务工作者缓存—很快</p><p id="543e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第8部分—预取</p><h1 id="5d19" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">两种类型的Vuex模块</h1><p id="20cc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在我们进一步了解如何惰性加载<a class="ae kw" href="https://vuex.vuejs.org/guide/modules.html" rel="noopener ugc nofollow" target="_blank"> Vuex模块</a>之前，您需要了解一件重要的事情。您需要了解注册Vuex模块的可能方法及其优缺点。</p><p id="23da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">静态Vuex模块</strong>在商店初始化期间声明。以下是显式创建的静态模块的示例:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9586" class="mj ky iq mf b gy mk ml l mm mn">// store.js<br/>import { <!-- -->userAccountModule } from './modules/userAccount'</span><span id="5471" class="mj ky iq mf b gy mo ml l mm mn">const store = new Vuex.Store({<br/>  modules: {<br/>    user: <!-- -->userAccountModule<br/>  }<br/>})</span></pre><p id="1b88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码将用静态模块<code class="fe mp mq mr mf b">userAccountModule</code>创建一个新的Vuex商店。静态模块不能被取消注册(它们的注册也不能被延迟)和它们的结构(不是状态！)在存储初始化后无法更改。</p><p id="9117" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这种限制对于大多数模块来说不是问题，并且在一个地方声明所有模块对于将所有与数据相关的内容保存在一个地方非常有帮助，但是这种方法也有一些缺点。</p><p id="ae0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们的应用程序中有一个带有专用Vuex模块的管理仪表板。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="db35" class="mj ky iq mf b gy mk ml l mm mn">// store.js<br/>import { <!-- -->userAccountModule } from './modules/userAccount'<br/>import { admin<!-- -->Module } from './modules/admin'</span><span id="41cc" class="mj ky iq mf b gy mo ml l mm mn">const store = new Vuex.Store({<br/>  modules: {<br/>    user: <!-- -->userAccountModule, <br/>    admin: adminModule<br/>  }<br/>})</span></pre><p id="9683" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以想象这样的模块会非常大。即使dashboard将只被一小部分用户使用，并且由于静态Vuex模块的集中注册，它的所有代码都将在主包中结束。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/c35b8ffae63bf683467ec0a03f40ffdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMvePcANptY83r80Go3Mtg.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">我们所有的模块都捆绑在一个文件中</figcaption></figure><p id="af5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这肯定不是我们想要的结局。我们需要一种只在<code class="fe mp mq mr mf b">/admin</code>路径中加载这个模块的方法。正如你可能已经猜到的，静态模块不能满足我们的需要。所有静态模块都需要在Vuex商店创建时注册，因此它们不能在以后注册。</p><p id="baaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是动态模块<strong class="ka ir"> </strong>可以帮助我们的地方！</p><p id="605b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">与静态模块相对的动态模块</strong>可以在 Vuex商店创建后<strong class="ka ir">注册。这种简洁的功能意味着我们不需要在应用程序初始化时下载动态模块，可以将它捆绑在不同的代码块中，或者在需要时延迟加载。</strong></p><p id="fe9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先让我们看看动态注册了<code class="fe mp mq mr mf b">admin</code>模块后，前面的代码会是什么样子。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3524" class="mj ky iq mf b gy mk ml l mm mn">// store.js<br/>import { <!-- -->userAccountModule } from './modules/userAccount'<br/>import { admin<!-- -->Module } from './modules/admin'</span><span id="f08f" class="mj ky iq mf b gy mo ml l mm mn">const store = new Vuex.Store({<br/>  modules: {<br/>    user: <!-- -->userAccountModule, <br/>  }<br/>})</span><span id="43ea" class="mj ky iq mf b gy mo ml l mm mn">store.registerModule('admin', adminModule)</span></pre><p id="bd98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们没有将<code class="fe mp mq mr mf b">adminModule</code>对象直接传递给我们商店的<code class="fe mp mq mr mf b">modules</code>属性，而是在商店创建后用<code class="fe mp mq mr mf b"><a class="ae kw" href="https://vuex.vuejs.org/api/#registermodule" rel="noopener ugc nofollow" target="_blank">registerModule</a></code>方法注册了它。</p><p id="fd1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">动态注册不需要对模块本身进行任何修改，因此任何Vuex模块都可以静态或动态注册。</p><p id="2879" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，在目前的形式下，这个动态注册的模块并没有给我们带来任何优势。</p><h1 id="48e4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">正确代码分割的Vuex模块</h1><p id="dbf6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们回到我们的问题。既然我们知道了如何动态注册<code class="fe mp mq mr mf b">admin</code>模块，我们当然可以尝试将它的代码放到<code class="fe mp mq mr mf b">/admin</code>路由包中。</p><p id="39a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们暂时停下来简要了解一下我们正在使用的应用程序。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/0709b332431e9597e5a954ef3ac10bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ult4uXG6nDjt4nzEipGECQ.png"/></div></div></figure><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1feb" class="mj ky iq mf b gy mk ml l mm mn">// router.js<br/>import VueRouter from 'vue-router'<br/>const Home = () =&gt; import('./Home.vue')<br/>const Admin = () =&gt; import('./Admin.vue')</span><span id="f743" class="mj ky iq mf b gy mo ml l mm mn">const routes = [<br/>  { path: '/', component: Home },<br/>  { path: '/admin', component: Admin }<br/>]</span><span id="4377" class="mj ky iq mf b gy mo ml l mm mn">export const router = new VueRouter({ routes }) </span></pre><p id="ea72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mp mq mr mf b">router.js</code>中，我们有两条延迟加载的代码分割路由。通过上面看到的代码，我们的<code class="fe mp mq mr mf b">admin</code> Vuex模块仍然在主<code class="fe mp mq mr mf b">app.js</code>包中，因为它在<code class="fe mp mq mr mf b">store.js</code>中是静态导入的。</p><p id="9344" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们解决这个问题，将这个模块只提供给进入<code class="fe mp mq mr mf b">/admin</code>路线的用户，这样其他人就不会下载多余的代码。</p><p id="796c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们将在<code class="fe mp mq mr mf b">/admin</code>路由组件中加载<code class="fe mp mq mr mf b">admin</code>模块，而不是在<code class="fe mp mq mr mf b">store.js</code>中导入并注册它。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="331f" class="mj ky iq mf b gy mk ml l mm mn">// store.js<br/>import { <!-- -->userAccountModule } from './modules/userAccount'</span><span id="6833" class="mj ky iq mf b gy mo ml l mm mn">export const store = new Vuex.Store({<br/>  modules: {<br/>    user: <!-- -->userAccountModule, <br/>  }<br/>})</span><span id="0e02" class="mj ky iq mf b gy mo ml l mm mn">// Admin.vue<br/>import adminModule from './admin.js'</span><span id="39ff" class="mj ky iq mf b gy mo ml l mm mn">export default { <br/>  // other component logic<br/>  mounted () { <br/>    this.$store.registerModule('admin', adminModule)<br/>  },<br/>  beforeDestroy () {<br/>   <!-- -->this.$store.unregisterModule('admin')<br/>  }<br/>}</span></pre><p id="7cda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看发生了什么！</p><p id="31b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在导入并注册<code class="fe mp mq mr mf b">Admin.vue</code> ( <code class="fe mp mq mr mf b">/admin</code>路线)内的<code class="fe mp mq mr mf b">admin</code>店铺。在代码的后面，一旦用户退出管理面板，我们将取消注册该模块，以防止同一个模块的多次注册。</p><p id="0c0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，因为<code class="fe mp mq mr mf b">admin</code>模块是在<code class="fe mp mq mr mf b">Admin.vue</code>而不是<code class="fe mp mq mr mf b">store.js</code>中导入的，所以它将与代码分离的<code class="fe mp mq mr mf b">Admnin.vue</code>捆绑在一起！</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/79ab3bdf202c534c03f2a8dcd0dab139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6w7lmBHGSniC1nfz4qLdUg.png"/></div></div></figure><blockquote class="mz na nb"><p id="2704" class="jy jz nc ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated"><strong class="ka ir">重要提示</strong>:如果您正在使用SSR模式，请确保您正在<code class="fe mp mq mr mf b">mounted</code>钩子中注册模块。否则会导致内存泄漏，因为<code class="fe mp mq mr mf b">beforeDestroy</code>钩子没有在服务器端进行评估。</p></blockquote><p id="d2ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们知道了如何使用动态Vuex模块注册将我们的路由特定模块分发到适当的包中。让我们看看稍微复杂一点的用例。</p><h1 id="1097" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">惰性加载Vuex模块</h1><p id="30c3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">假设我们的<code class="fe mp mq mr mf b">Home.vue</code>上有推荐部分，我们希望在这里展示对我们服务的积极评价。他们有很多，所以我们不想在用户进入我们的网站后立即显示他们。只有当用户需要时才显示它们会好得多。我们可以添加<em class="nc">“显示评价”</em>按钮，点击后将加载并显示其下方的评价。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/ef0adc69f36c212a06ef26ac54faf73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8puS6MPWVBsR_amfZT1Rw.png"/></div></div></figure><p id="22ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了存储客户评价数据，我们还需要一个Vuex模块。姑且称之为<code class="fe mp mq mr mf b">testimonials</code>。该模块将负责显示以前添加的证明和添加新的。我们不需要知道实现细节。</p><p id="a9c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望<code class="fe mp mq mr mf b">testimonials</code>模块只有在用户点击按钮时才被下载，因为以前不需要它。让我们看看如何利用动态模块注册和动态导入来实现这一功能。<code class="fe mp mq mr mf b">Testimonials.vue</code>是<code class="fe mp mq mr mf b">Home.vue.</code>内部的组件</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/3be80de6d5dd47268705d6655f6b664c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-b6NfyNgstA2S8siebyMw.png"/></div></div></figure><p id="78e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们快速回顾一下代码。</p><p id="b44a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户点击<code class="fe mp mq mr mf b">Show Testimonials</code>按钮时<code class="fe mp mq mr mf b">getTestimonials()</code>方法被调用。它负责调用正在获取<code class="fe mp mq mr mf b">testimonials.js</code>的<code class="fe mp mq mr mf b">getTestimonialsModule() </code>。一旦promise被解析(这意味着模块被加载)，我们就动态地注册它，并分派负责获取证明的动作。</p><p id="6c53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">多亏了动态导入<code class="fe mp mq mr mf b">testimonials.js</code>内容被捆绑到一个单独的文件中，只有当<code class="fe mp mq mr mf b">getTestimonialsModule</code>方法被调用时才会被下载。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/f89da90c02e9cdcf1278b17f1bbbb583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQjEeTznwCQQgPA3ftDrbw.png"/></div></div></figure><p id="91fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们需要退出管理面板时，我们只是在<code class="fe mp mq mr mf b">beforeDestroy</code>生命周期挂钩中注销先前注册的模块，所以如果我们再次进入这条路径，它不会重复。</p><h1 id="b210" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">包裹</h1><p id="5b42" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">尽管静态Vuex模块注册对于大多数用例来说已经足够，但是在某些情况下，我们可能需要使用动态注册。</p><ul class=""><li id="1eac" class="nj nk iq ka b kb kc kf kg kj nl kn nm kr nn kv no np nq nr bi translated"><strong class="ka ir">如果模块只在特定的路由上需要，</strong>那么我们可以在适当的路由组件中动态注册它，这样它就不会出现在主包中。</li><li id="4883" class="nj nk iq ka b kb ns kf nt kj nu kn nv kr nw kv no np nq nr bi translated"><strong class="ka ir">如果只是在一些交互之后才需要模块，</strong>那么我们需要把动态模块注册和动态导入结合起来，用一种合适的方法来实现模块的延迟加载。</li></ul><p id="d87a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码分割Vuex模块的能力是一个强大的工具。您在应用程序中处理的与数据相关的操作越多，就捆绑包大小而言，节省的就越多。</p><p id="93d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列的下一部分，我们将学习如何延迟加载单个组件，更重要的是，哪些组件应该延迟加载。</p></div></div>    
</body>
</html>