<html>
<head>
<title>The perils of functional CSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">功能性CSS的危险</h1>
<blockquote>原文：<a href="https://itnext.io/the-perils-of-functional-css-c9484d1b4680?source=collection_archive---------4-----------------------#2019-06-10">https://itnext.io/the-perils-of-functional-css-c9484d1b4680?source=collection_archive---------4-----------------------#2019-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/06983b3a322edbfe41f777b636c96265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXKRdc2wmiAKx_5R2UXVTw.png"/></div></div></figure><p id="e6c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数式CSS是一个有争议的话题，经常引发激烈的评论讨论。在这种情况下，从审慎的观点中梳理出夸张的说法可能会很棘手。</p><p id="9340" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我对这个问题的看法，基于我最近在一个构建web应用程序的项目中对这种方法的实验。</p><h1 id="0724" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">一、什么是函数式CSS？</h1><p id="32ea" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">函数式CSS(有时称为原子CSS)是使用小型的、不可变的和显式命名的实用程序类来构造组件的实践。各种现成的类库，如<a class="ae lz" href="https://tachyons.io/docs/layout/grid/" rel="noopener ugc nofollow" target="_blank">超光速粒子</a>和越来越受欢迎的<a class="ae lz" href="https://tailwindcss.com/docs/what-is-tailwind/" rel="noopener ugc nofollow" target="_blank">顺风CSS </a>，如雨后春笋般涌现，使得从功能CSS开始变得尽可能容易。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/9dc6881b1075a772262437c6cf806c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4rGXwev8_WvJoY57WsJYgg.jpeg"/></div></div></figure><p id="2e27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，与其创建一个自定义组件，不如按语义或视觉命名，例如:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="fdd7" class="mk kx iq mg b gy ml mm l mn mo">&lt;div class=”card”&gt;A card&lt;/div&gt;</span></pre><p id="e3e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过实用程序类的组合在标记中构造组件的样式规则。例如:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="1c5c" class="mk kx iq mg b gy ml mm l mn mo">&lt;div class="padding-sm border-radius-sm bgc-white"&gt;&lt;/div&gt;</span></pre><p id="f509" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如函数式编程鼓励纯粹性和可预测性一样，函数式CSS提倡使用单一用途和“纯粹”的类，这些类无论上下文(或传统编程中的“范围”)如何，都具有一致的行为。</p><p id="3f96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检验一个类是否是“功能性”的一个很好的试金石是检查使用它的结果是否能从它的名字中立即辨别出来。此外，您可以询问该名称是否只应用单一样式规则(尽管也有例外)。</p><p id="8de3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">功能性CSS可以被视为对古老的“语义”类名最佳实践的反叛——例如“新闻项目”或“问候”——长期以来被著名的<a class="ae lz" href="http://www.csszengarden.com/" rel="noopener ugc nofollow" target="_blank"> CSS Zen Garden </a>和著名的开发者Jeffery Zeldman 所支持。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/09013070a5c980ab26f55a9b14847fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WLlYuI1_8sd8SOhvBUnQDQ.jpeg"/></div></div></figure><p id="2181" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，functional CSS认为，试图坚持HTML和CSS之间错误的“关注点分离”是没有意义的，因为正如<a class="ae lz" href="https://vuejs.org/v2/guide/single-file-components.html#What-About-Separation-of-Concerns" rel="noopener ugc nofollow" target="_blank"> Vue.js文档指出的那样</a>:</p><blockquote class="mp mq mr"><p id="6004" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated"><em class="iq">“…关注点的分离不等于文件类型的分离。”</em></p></blockquote><p id="5665" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了编写真正可重用的CSS，我们已经进入了视觉和功能抽象，例如“卡片”而不是“新闻项目”，或者“媒体对象”而不是“作者简介”。这是所有UI库的前提，从<a class="ae lz" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank">引导</a>到<a class="ae lz" href="https://semantic-ui.com/" rel="noopener ugc nofollow" target="_blank">语义UI </a>。正如《顺风CSS》的作者亚当·瓦森所说:</p><blockquote class="mp mq mr"><p id="d340" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated">这是无法假装的。堆叠式表单比。右对齐；它们都是根据它们如何影响标记的表示来命名的，我们在标记中使用这些类来实现特定的表示结果。</p></blockquote><p id="1b4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数式CSS通过鼓励我们完全放弃这些抽象，将这一点发挥到了极致。函数式方法建议我们使用我们选择的库的不可变实用程序类，而不是试图为可能永远不会重用的组件命名，这意味着您可能永远不必再次编写自己的CSS。</p><h1 id="9c56" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">问题</h1><h1 id="cdc3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">语境</h1><p id="bcb9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">也许最显著的问题——在某些情况下也是<em class="ms">特性</em>——是函数式方法如何违背CSS的上下文感知特性。</p><p id="a1c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然BEM和SMACSS等方法促进了扁平的类层次结构，限制了特异性，但在许多情况下，上下文感知规则是有意义的。获取基于父类切换显示的新闻列表:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="62d0" class="mk kx iq mg b gy ml mm l mn mo">&lt;ul class="summary-list"&gt;<br/>     &lt;li class="summary-list__item"&gt;A list item.&lt;/li&gt;<br/>&lt;/ul&gt;<br/></span><span id="8741" class="mk kx iq mg b gy mw mm l mn mo">&lt;ul class="summary-list summary-list--compact"&gt;<br/>     &lt;li class="summary-list__item"&gt;A list item.&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="b510" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一种方法是遍历每个新闻条目，并为每个条目添加一个<code class="fe mx my mz mg b">summary-list__item--compact</code>类(或者组成其等价物的功能集)，但是，这会导致每个条目的性能下降，并且您还会失去轻松“挂钩”到紧凑视图进行其他更改的能力(例如，将父显示从<code class="fe mx my mz mg b">grid</code>切换到<code class="fe mx my mz mg b">block</code>)。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/5ffa0f0be1ba0d63e112e89bd6f86103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtiKv70S39R8XWAqYV2v4w.jpeg"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated"><em class="ne">你如何用功能方法复制显示模式切换？</em></figcaption></figure><p id="05e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主题化也有类似的问题。传统的函数类如<code class="fe mx my mz mg b">text-black</code>必须按元素进行映射和更改，这是一个性能噩梦。想象一下，基于它们的上下文来改变函数类的含义——这不仅会令人困惑，而且几乎是不可能的，因为它们有着广泛的非特定用途。</p><p id="8c5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，你可以通过创建自己的别名来逃避这些问题，比如<code class="fe mx my mz mg b">primary</code> / <code class="fe mx my mz mg b">secondary</code>等等:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c041" class="mk kx iq mg b gy ml mm l mn mo">.text-primary { @apply .text-black; }<br/>.t-dark .text-primary { @apply .text-white; }</span></pre><p id="8492" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者更好的是，如果您的浏览器支持要求允许，在CSS变量<a class="ae lz" href="https://www.browserlondon.com/blog/2019/01/15/css-variables-theming/" rel="noopener ugc nofollow" target="_blank">旁边使用别名:</a></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="76a2" class="mk kx iq mg b gy ml mm l mn mo">::root { --t-primary: black; }<br/>.t-dark { --t-primary: white; }<br/>.text-primary { color: var(--t-primary); }</span></pre><p id="9634" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不管怎样，当你将类的明确的功能性含义别名或隐藏到抽象的概念中时，不管它是主要的/次要的还是“特色的”等等，你已经移除了<em class="ms">功能性</em>方面。</p><p id="2c73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，对于一些支持者来说，这可能才是重点。《超光速粒子》的作者亚当·莫尔斯<a class="ae lz" href="http://mrmrs.io/writing/2016/03/24/scalable-css/" rel="noopener ugc nofollow" target="_blank">指出</a>:</p><blockquote class="mp mq mr"><p id="a9dc" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated"><em class="iq">‘让一个类根据上下文重新定义多个定义并不能解决问题，反而会制造问题。’</em></p></blockquote><p id="6755" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，只有当类名是文体描述性的，比如<code class="fe mx my mz mg b">float-left</code>，并且上下文改变了具体含义时，这才是一个问题。在上下文中改变一个在语义上定义的模块，例如<code class="fe mx my mz mg b">news</code>或者在一个UI结构中定义的模块，例如<code class="fe mx my mz mg b">card</code>，可能比Morse在他的例子中提出的问题要少得多:</p><blockquote class="mp mq mr"><p id="4d8d" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated">想象一下，如果你有一个名为“filesize”的函数，你给它传递一个文件名，它返回文件大小。听起来很棒。但是想象一下，如果有时它返回文件中的行数。听起来一点也不好，不是吗？</p></blockquote><p id="e674" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一种不同的上下文需要考虑，那就是关系选择器的使用，比如直系后代(<code class="fe mx my mz mg b">&gt;</code>)和相邻兄弟(<code class="fe mx my mz mg b">+</code>)。这些使模块能够根据它们的周围环境来决定它们的外观，并且已经成为诸如臭名昭著的<a class="ae lz" href="https://alistapart.com/article/axiomatic-css-and-lobotomized-owls/" rel="noopener ugc nofollow" target="_blank">脑叶切除猫头鹰选择器</a>之类的技术的基础:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ebde" class="mk kx iq mg b gy ml mm l mn mo">ul &gt; * + * { margin-top: 10px; }</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/f3bf8bac22b7505f3106405eb3a7a582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eVhzBX1AXBU7QEFzavvg-w.jpeg"/></div></div></figure><p id="19ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数式CSS传统上避开这些方法，采用更明确的基于模板的有类或无类方法，在这种方法中，您可以简单地在最后一项或第一项中不包含margin类:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="47f9" class="mk kx iq mg b gy ml mm l mn mo">&lt;ul&gt;<br/>   &lt;li&gt;Apple&lt;/li&gt;<br/>   &lt;li class="margin-top-10"&gt;Orange&lt;/li&gt;<br/>   &lt;li class="margin-top-10"&gt;Pear&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="47d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不仅在模板化中处理这一点很麻烦，如果用JS动态添加或删除一个项目，您还必须手动调整类。</p><p id="9437" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，没有什么能阻止你创建一个间距实用类或模块，但是这又一次让我们更接近Wathan在他今天的“功能”方法之旅中描述的“内容不可知的实用类”的中间立场。</p><h1 id="d598" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">响应式设计</h1><p id="a372" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">作为功能性CSS过程的一部分，类是预定义的，这意味着您也将预先定义您的固定断点(例如' sm'/'md'/'lg ')。不幸的是，这种方法并不符合我们所知的现代响应式设计。</p><p id="57c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">特定的“宏”断点早已失宠，当一个组件看起来不再正确时，就倾向于特定于组件的断点或“调整”。随着诸如<a class="ae lz" href="http://www.heydonworks.com/article/the-flexbox-holy-albatross" rel="noopener ugc nofollow" target="_blank"> Flexbox圣信天翁</a>和<a class="ae lz" href="https://www.webdesignerdepot.com/2018/05/a-simple-introduction-to-intrinsic-web-design/" rel="noopener ugc nofollow" target="_blank">“内在”网页设计</a>的兴起，更不用说对某种形式的容器查询不可避免的原生支持，这感觉非常过时。在我们渴望更少的同质性和更多的组件外设计的时候，将模块显示绑定到特定的宏断点感觉很奇怪。</p><p id="e5f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最重要的是，当使用功能性CSS库时，诸如CSS-grid这样的工具是没有意义的，因为有趣的网格定义的规则往往非常具体，你很可能最终要编写一个组件来使它们工作。</p><h1 id="8c4d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">伪元素和选择器</h1><p id="e56f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">由于伪元素不以传统方式存在于HTML中，功能性CSS不能有效地针对它们，这是有问题的。事实上，如果不涉及组件抽象或某种规则定义的复制，这个问题就没有真正的解决方案。</p><p id="5e14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，Wathan <a class="ae lz" href="https://github.com/tailwindcss/discuss/issues/184" rel="noopener ugc nofollow" target="_blank">建议</a>注册一个“<a class="ae lz" href="https://github.com/tailwindcss/tailwindcss/releases#registering-new-variants-from-plugins" rel="noopener ugc nofollow" target="_blank">变体</a>”，这会给你一个额外的类，比如<code class="fe mx my mz mg b">before-text-red</code>。修复方法是将这个类放在包含“before”规则的组件上，但是一旦你达到这个长度，你实际上是将实用程序类添加到父类中，而不是直接应用到父类中。</p><h1 id="c07e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">黑客解决方案</h1><p id="b5fa" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">也许函数式CSS最不专业但可能最普遍的问题是它只会让开发人员变得懒惰。</p><p id="9896" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一个问题的最佳解决方案是一个定制的组件，那么你可能应该做一个定制的组件。由于教条地坚持实用类库的简单性，函数式CSS可以说给了开发人员一个不去创建原始组件的借口。</p><h1 id="0686" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">函数式CSS的优点</h1><h1 id="8081" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">表演</h1><p id="90d3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">不可否认，遵循功能性CSS方法可以带来一些性能上的好处，因为以这种方式创建项目所需的实际CSS数量很少。对于一般的网站或网络应用程序来说，整体影响可能是微妙的，但这肯定是一个不错的意外收获。另外，由于您更新CSS的频率降低了，您将受益于一个更加缓存友好的样式表。</p><p id="462e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，<a class="ae lz" href="http://nicolasgallagher.com/about-html-semantics-front-end-architecture/" rel="noopener ugc nofollow" target="_blank"> Nicholas Glasser </a>认为这种好处有些转移视线:</p><blockquote class="mp mq mr"><p id="ba94" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated"><em class="iq">‘使用预处理程序的有经验的CSS开发人员不需要过分担心编译后的CSS中一定程度的重复，因为它可以很好地适应HTTP压缩后较小的文件大小。通过预处理器，更易维护的“CSS”代码的好处应该超过对原始和缩小输出CSS的美学或大小的关注。</em></p></blockquote><p id="4d39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不管您对更小的CSS的影响有什么想法，迁移到函数式方法的性能优势中也可能存在人的因素。例如，开发人员入职更加直接，由于您的团队共享库或代码库，跨项目的生产率可以大幅提高。这不是函数式CSS独有的特性(例如，Bootstrap也是如此)，但如果情况合适，这仍然是一个潜在的优势。</p><p id="0175" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，功能性CSS使得核心前端团队之外的团队成员更容易对给定的站点或项目进行更改。由于减少了CSS编写开销并避免了抽象，后端开发人员完全有可能独立地对项目进行更改，这在小型团队中非常有用。</p><h1 id="2248" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">一致性</h1><p id="0368" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">从一个特定的角度来看，功能方法提供的预定义值可以为整个项目的一致性带来实际的好处。瓦森又一次简洁地阐明了这一点，<a class="ae lz" href="https://adamwathan.me/css-utility-classes-and-separation-of-concerns/" rel="noopener ugc nofollow" target="_blank">暗示说</a>:</p><blockquote class="mp mq mr"><p id="ee87" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated">“当一个项目中的每个人都从有限的选项中选择自己的风格时，你的CSS就不会随着项目的规模而线性增长，你可以免费获得一致性。”</p></blockquote><p id="685d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这在高流失率的团队中可能特别有意义，例如雇佣了许多承包商或自由职业者的团队，或者在团队之间转移项目的责任时(或者甚至在没有自己的内部开发人员的公司的外部机构之间)。然而，<a class="ae lz" href="https://frontstuff.io/in-defense-of-utility-first-css" rel="noopener ugc nofollow" target="_blank"> Sarah Dayan </a>认为代码或布局不一致主要是“人的问题，而不是技术问题”，如果“你不遵循你的团队制定的规则、风格指南和最佳实践”，即使坚持功能性CSS方法也没有用。</p><h1 id="477a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么不两者兼而有之呢？</h1><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/76279bbff9fe19e11e13537a96ea13e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glRUlZlchokykC2YsOwS1g.jpeg"/></div></div></figure><p id="fab7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管争论的双方都很紧张，但是有一种<a class="ae lz" href="https://css-tricks.com/why-cant-we-use-functional-css-and-regular-css-at-the-same-time/" rel="noopener ugc nofollow" target="_blank">日益增长的趋同</a>倾向于同时采用组件和功能的方法，这种方法被顺风公司称为<a class="ae lz" href="https://adamwathan.me/css-utility-classes-and-separation-of-concerns/" rel="noopener ugc nofollow" target="_blank">“实用优先”</a>:</p><blockquote class="mp mq mr"><p id="159b" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated"><em class="iq">“我之所以称我对CSS采取的方法为实用优先，是因为我试图从实用程序中构建一切，并且只在出现重复模式时提取它们……对CSS采取组件优先的方法意味着你为事物创建组件，即使它们永远不会被重用。这种不成熟的抽象是样式表大量膨胀和复杂的根源。</em></p></blockquote><p id="ccb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组件到离散实体的抽象只有在有特定需求时才会出现，例如，一个重复的UI模式将在某种程度上受益于更传统的“语义”分组。在Tailwind中，这种组合看起来像这样，与传统的预处理器mixin没有什么不同:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="936c" class="mk kx iq mg b gy ml mm l mn mo">.btn {<br/>   @apply font-bold py-2 px-4 rounded;<br/>}</span></pre><p id="666b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然实用类有它们的位置，并且适度使用会非常有用，但这种“组合”肯定会抵消传统组件驱动CSS的任何好处。如果一个按钮值得抽象，那么很难想象许多UI组件<em class="ms">不值得抽象，它们是真正“一次性使用”的，就像Adam给出的导航条例子。</em></p><p id="092a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，当你把一个类组成一个抽象的时候，你就失去了:</p><ul class=""><li id="c935" class="nf ng iq ka b kb kc kf kg kj nh kn ni kr nj kv nk nl nm nn bi translated">类名的明确性。</li><li id="2b79" class="nf ng iq ka b kb no kf np kj nq kn nr kr ns kv nk nl nm nn bi translated">不必命名或设计组件的好处。</li><li id="3d1f" class="nf ng iq ka b kb no kf np kj nq kn nr kr ns kv nk nl nm nn bi translated">不用自己写CSS节省的时间。</li></ul><p id="ab0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更糟糕的是，组件类和功能实用程序类的广泛组合实际上使得<em class="ms">更难理解</em>，并且在决定什么是对类的有价值的和可重用的修改以及什么应该保持一次性变化时，给开发人员带来了更多的负担:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a02a" class="mk kx iq mg b gy ml mm l mn mo">&lt;!-- Should this be 'card--large' and 'card--light' ? --&gt;<br/>&lt;div class="card bg-white padding-lg"&gt;Card&lt;/div&gt;</span></pre><p id="c1de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种混合有可能是极具破坏性的，尤其是当新的或经验不足的开发人员使用函数类作为“撤销”组件规则的出口时(例如，增加“card”中定义的填充)。</p><p id="44e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保可读性和可维护性的唯一方法是对两者的应用都非常严格，这样它们就不会交叉或共享关注点:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7057" class="mk kx iq mg b gy ml mm l mn mo">&lt;div class="bg-white padding-md flex"&gt;<br/>   &lt;div class="profile"&gt;Jay Freestone etc.&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><h1 id="1c6e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="9236" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">综上所述，功能性CSS对我这个前端开发者来说意义不大。我认为一个专门的前端团队管理他们自己的CSS方法会更有成效，而不是被束缚在标准化类库的束缚中。</p><p id="2d0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果你不是很擅长CSS，并且努力想出适当的抽象，或者如果你没有一个专门的前端团队来处理这方面的事情，我可以看到函数式CSS是多么有用。我不认为后端开发人员编写了大多数功能性CSS库是巧合。</p><p id="415d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一名前端开发人员，如果你<em class="ms">真的</em>认为功能性CSS可以解决你或你的团队面临的问题，我的建议是首先考虑这个问题实际上是否更人性化。我认为这句来自<a class="ae lz" href="http://www.zeldman.com/2017/01/03/kiss-my-classname/" rel="noopener ugc nofollow" target="_blank">泽尔德曼</a>的话说得很好:</p><blockquote class="mp mq mr"><p id="c53a" class="jy jz ms ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated"><em class="iq">我不认为问题在于语义标记的原则或者CSS中的层叠。我认为问题在于十几个人一起做某件事却不互相交流。</em></p></blockquote></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h2 id="aaf5" class="mk kx iq bd ky oa ob dn lc oc od dp lg kj oe of lk kn og oh lo kr oi oj ls ok bi translated">关于浏览器</h2><p id="a621" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们为更好、更高效的工作场所创建企业网络应用。我们已经帮助壳牌、英国航空公司和英国政府等客户提高效率，简化业务。在<a class="ae lz" href="http://www.browserlondon.com" rel="noopener ugc nofollow" target="_blank"> Browser London </a>访问我们。</p><p id="ef69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ms">原载于2019年6月10日</em><a class="ae lz" href="https://www.browserlondon.com/blog/2019/06/10/functional-css-perils/" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://www.browserlondon.com</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>