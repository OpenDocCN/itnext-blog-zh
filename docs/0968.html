<html>
<head>
<title>Module Oriented Architecture — Part 5: Implicit Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向模块的体系结构第5部分:隐式路由</h1>
<blockquote>原文：<a href="https://itnext.io/module-oriented-architecture-part-5-implicit-routing-655b468ca1b4?source=collection_archive---------7-----------------------#2018-06-25">https://itnext.io/module-oriented-architecture-part-5-implicit-routing-655b468ca1b4?source=collection_archive---------7-----------------------#2018-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…从<a class="ae kl" href="https://medium.com/@poksi/module-oriented-architecture-part-4-non-conforming-modules-9c18ec2d2180" rel="noopener">第4部分</a>继续</p><p id="272c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在本系列中几次提到，它的目标并不是最好地利用Swift语义和尽可能做出最好的Swift代码，因为它以非常通用的方式处理MOA问题，以语言不可知的方式描述问题和提出解决方案，它只是在Swift中实现它。</p><p id="1a0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，当一些代码问题可能会使架构有点破旧或为糟糕的编码打开一个潜在的漏洞时，那么我认为做一些内务处理是正确的，如果这使我们得到一些一般性的改进，那么让我们利用这个机会。</p><h1 id="dde7" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">模块路由器问题</h1><h2 id="24e0" class="lk kn iq bd ko ll lm dn ks ln lo dp kw jy lp lq la kc lr ls le kg lt lu li lv bi translated">条件式</h2><p id="87ab" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">模块路由器听起来是一个不错的想法，尽管它可能会带来一些模糊性，并且很容易与来自<strong class="jp ir"> VIPER </strong>架构的<strong class="jp ir">路由器</strong>相混淆，这当然不是。我们的路由器应该将调用路由到模块，而不是管理任何类型的<strong class="jp ir">视图</strong>线框。如果我们看看它在第3章中做了什么，它可能会变得非常清楚，随着向我们的模块添加方法/功能，它可以很快成为一个相当大的类，主要由一个大的<code class="fe mb mc md me b">switch</code>子句定义。那是代码的味道，巨大的就像一个大而臭的代码，里面有一大罐有趣的豆子…</p><h2 id="6aad" class="lk kn iq bd ko ll lm dn ks ln lo dp kw jy lp lq la kc lr ls le kg lt lu li lv bi translated">内存利用率</h2><p id="cad1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">虽然内存在这里看起来不是一个大问题，因为我们将路由器定义为<code class="fe mb mc md me b">lazy</code>，这仍然感觉不太对，因为路由器对象可能会用自己的图为几乎每个<code class="fe mb mc md me b">path</code>初始化一个新的类。这可能会造成大量的内存使用，特别是如果我们必须处理一些来自iOS SDK的相当“繁重”的类。</p><h1 id="849d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">解决办法</h1><p id="6ff8" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当条件成为一个决策链时，那么应用一些<strong class="jp ir"> <em class="mf">多态性</em> </strong>通常是最好的方式。此外，就路由而言，被路由对象可以通过订阅潜在可路由类列表来很好地路由自己，并通过控制反转来自己执行路由。听起来是个不错的解决方案。其实就是这么整齐，省去了<code class="fe mb mc md me b">ModuleRouter</code>。但是乐趣不止于此！函数<code class="fe mb mc md me b">open</code>中的代码实际上非常通用，我们可以简单地将它移到<code class="fe mb mc md me b">ModuleType</code>的扩展中，从而使它的实现更加精简！</p><p id="c622" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看上面提到的代码中发生了什么:</p><h2 id="22de" class="lk kn iq bd ko ll lm dn ks ln lo dp kw jy lp lq la kc lr ls le kg lt lu li lv bi translated"><code class="fe mb mc md me b">1. ModuleRouter is </code>替换为<code class="fe mb mc md me b">ModuleRoutable</code>:</h2><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e820" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到，想要被路由到的那个类，需要用某个模块路径来标识自己，这个路径稍后会在模块中被匹配，这样这里的函数<code class="fe mb mc md me b">route</code>就可以被调用。静态函数是一种不幸的变通方法，因此具体的对象只能用它的类型来初始化。我们很快就会发现为什么使用反射。</p><p id="4e88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是<code class="fe mb mc md me b">PaymentsInteractor:</code>如何实现<code class="fe mb mc md me b">ModuleRoutable</code></p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="1b68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里看到的是，我们已经将<code class="fe mb mc md me b">route(parameters:callback:)</code>函数引入了被路由的类本身，使其成为隐式的。正如已经提到的，<code class="fe mb mc md me b">routable()</code>仅仅是一个静态初始化器，而<code class="fe mb mc md me b">getPath()</code>用特定的路径标识类，所以它可以从模块中被调用。有人可能会说，我们只是把<code class="fe mb mc md me b">switch</code>语句放到了Intercator中，它肯定没有这个位置。好吧，现在我们不讨论内部模块架构，而是讨论我们如何从外部到内部再返回。在真实场景中，订阅模块为<code class="fe mb mc md me b">ModuleRoutable</code>的对象可能是<strong class="jp ir">演示者</strong>和<strong class="jp ir">视图模型</strong>…但这将在其他时间处理。</p><h2 id="f5af" class="lk kn iq bd ko ll lm dn ks ln lo dp kw jy lp lq la kc lr ls le kg lt lu li lv bi translated">2.模块支付模块变得非常通用</h2><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f710" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mb mc md me b">ModuleType</code>获得新属性<code class="fe mb mc md me b">subscribedRoutables</code>。该属性包含已预订的可传递类别的类型。它们不是用所有潜在的大对象图来初始化，而是只在路由到。</p><p id="7e86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以看到，than函数<code class="fe mb mc md me b">open</code>现在已经移动到扩展中，我们的<code class="fe mb mc md me b">PaymentsModule</code>现在只包含它的标识路由、路径和可路由类。</p><h1 id="6252" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">利益</h1><p id="f906" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">嗯，我们实现了我们设定的目标。上面有一些很好的糖果:</p><ul class=""><li id="9077" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">在使用类型<strong class="jp ir">路由器</strong>方面不再有歧义，这可能会让一些使用<strong class="jp ir">毒蛇</strong>的开发者感到困惑</li><li id="1139" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><strong class="jp ir">【x】路由器</strong>类如此消失，路由控制被给予那些应该被路由的路由器</li><li id="a850" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><strong class="jp ir">【x】模块</strong>类现在几乎变成了声明性的、描述性的、零实现的、线程安全的类。</li></ul><p id="ce4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想在这个系列中展示的最后一件事是如何处理<strong class="jp ir"> iOS故事板</strong>以及我们如何控制<strong class="jp ir">【UX】</strong>和<strong class="jp ir">用户从iOS导航类到我们面向模块的架构的旅程</strong>。</p><p id="a384" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里检查1.1版本<a class="ae kl" href="https://github.com/poksi592/module-architecture-demo/tree/1.1" rel="noopener ugc nofollow" target="_blank">的变化。</a></p><p id="10c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来<a class="ae kl" href="https://medium.com/@poksi/module-oriented-architecture-part-6-outsmarting-the-mvc-26ef66111057" rel="noopener">部分</a>将讨论我们如何创建模块，在iOS故事板和视图控制器的情况下，这些模块也处理表示层。</p></div></div>    
</body>
</html>