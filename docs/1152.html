<html>
<head>
<title>GraphQL Authentication using OAuth &amp; JSON Web Tokens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OAuth和JSON Web令牌的GraphQL认证</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-authentication-using-oauth-json-web-tokens-bdb829602a5c?source=collection_archive---------3-----------------------#2018-07-31">https://itnext.io/graphql-authentication-using-oauth-json-web-tokens-bdb829602a5c?source=collection_archive---------3-----------------------#2018-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9fe654f91e63854ef857b25682916def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8fITsswMNubUavSp7bJRgQ.jpeg"/></div></div></figure><figure class="jy jz ka kb gt jr"><div class="bz fp l di"><div class="kc kd l"/></div></figure><p id="847e" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这篇文章是我上周写的一篇文章的后续，讨论了如何使用passport 向GraphQL服务器添加<a class="ae lc" href="https://medium.com/@mjw56/graphql-authentication-with-passport-d75c08d5fbdc" rel="noopener">认证。我将在这篇文章的基础上讨论如何用一个安全的</a><a class="ae lc" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌(JWT) </a>包装生成的OAuth令牌，这样访问令牌就不会通过网络传递。</p><p id="62c6" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在之前的文章中，应用程序使用OAuth策略和passport模块在节点服务器上持久化用户会话。使用JSON Web令牌时要知道的关键是没有服务器会话。</p><figure class="jy jz ka kb gt jr gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/5987d74c185743a9b11e012e1e749ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*vwqQumyppsbG0vtgmDC1dA.jpeg"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">没有服务器会话</figcaption></figure><p id="0283" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">本质上，我们将在服务器上使用一个秘密的服务器密钥对JWT进行编码，并将其作为cookie发送回客户端。在响应返回到客户端之后，服务器不知道任何关于本地JWT的信息，因为它没有被持久化。对于来自客户端的每个需要进行身份验证的请求，客户端将使用收到的cookie发回JWT。然后，服务器可以读取传入的请求，获取cookie的JWT值，再次使用秘密密钥对其进行解码，如果一切正常，则对解码后的信息做任何需要做的事情，并将其传递给受保护的路由。简而言之，这就是JWT的工作方式。一旦你理解了一些关键的想法，这就非常简单了。我将向您展示我是如何用<a class="ae lc" href="https://github.com/prismagraphql/graphql-yoga" rel="noopener ugc nofollow" target="_blank"> graphql-yoga </a>和现有的<a class="ae lc" href="https://github.com/JMPerez/passport-spotify" rel="noopener ugc nofollow" target="_blank"> passport策略</a>来实现它的，我已经准备好获取Spotify API的访问令牌。</p><p id="bb8b" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">首先需要的是将插入passport的<a class="ae lc" href="https://www.npmjs.com/package/passport-jwt" rel="noopener ugc nofollow" target="_blank"> passport-jwt </a>模块。这个模块将帮助我们定义一个中间件策略，如何从cookie中获取传入请求的JWT，并检查它以确保它是有效的。接下来，我们将需要<a class="ae lc" href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener ugc nofollow" target="_blank"> jsonwebtoken </a>，它将是用于生成实际JWT的包。</p><p id="1557" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们来看看第一段代码。这是将要生成JWT的函数。JWT的就像他们所说的那样——一个由JSON生成的用于网络的令牌。这里我传入一个用户，但这实际上可以是您想要编码的任何JSON数据。这里最重要的部分是用来编码的密钥。当令牌从客户端发回时，它将使用相同的密钥对其进行解码。</p><figure class="jy jz ka kb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/c94fe84546ee67868c1bdff0481b8eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKSil57feF3XMcDkCHRMrg.png"/></div></div></figure><p id="bdff" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">接下来，在从Spotify OAuth登录流接收到经过身份验证的用户数据后，我将生成这个令牌。当用户登录Spotify时，我的应用程序会打开一个新的模态窗口，然后它会在我的节点服务器上重定向回route。</p><figure class="jy jz ka kb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lj"><img src="../Images/66eefacd9a95dd96488c3a6d58d5d0ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSATIA2X8QXEAFy_706LZQ.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">set-jwt-cookie</figcaption></figure><p id="548b" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">该代码片段创建了JWT，并将其作为cookie放在被设置回的响应上。此后，服务器会忘记JWT曾经存在过，浏览器会设置cookie。</p><p id="33c2" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">最后一步是将JWT身份验证放在节点服务器上的路由前面，因为已经发布了JWT。对于我的用例，我使用的是graphql-yoga，幸运的是他们的服务器公开了express应用程序实例，所以中间件可以像这样放在<code class="fe lk ll lm ln b">/graphql</code>路径上</p><figure class="jy jz ka kb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/229e2dd9c4217d8a7b65498892adc51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LnqVyB6QRjk5UNOOF9ibdA.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">graph QL-yoga-中间件</figcaption></figure><p id="3d70" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">要记住的一件重要事情是，在他们的服务器上使用<code class="fe lk ll lm ln b">passport</code>中间件需要再次初始化！我第一次尝试的时候被它绊倒了。</p><p id="f4bb" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">最后，这是我为<code class="fe lk ll lm ln b">passport-jwt</code>使用的策略代码:</p><figure class="jy jz ka kb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/755efee7b4c27b12915fa9283a50af94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_AZqCrPXPdcyS5vUoEFCg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">护照-智威汤逊-战略</figcaption></figure><p id="afb4" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这里我传入了一个定制的提取器函数，它从传入的请求中提取cookie。然后，该模块使用秘密密钥对令牌进行解码。一旦完成，它就可以将未编码的数据传递给下一个中间件。</p><figure class="jy jz ka kb gt jr gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/e9ec2c18dfad58cc4169fa4ffeb90d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*q4MOCf7mNxVlgGYb0C6PGA.png"/></div></figure><p id="cdb9" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在我的例子中是GraphQL服务器，我再次拦截请求，从请求中获取新的用户数据，并将其传递给GraphQL上下文。这个数据有一个访问令牌，我的API需要这个令牌来调用Spotify API以获取数据。有了这个，我的<code class="fe lk ll lm ln b">/graphql</code>端点就成功地设置在认证之后。</p><p id="4334" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这是我将JWT认证添加到我的服务器的<a class="ae lc" href="https://github.com/mjw56/spotify/commit/7047d99c9bc6c28e97827986377bd87e3222c837" rel="noopener ugc nofollow" target="_blank">提交</a>。</p><p id="3afa" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">黑客快乐！</p><p id="2a1f" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><a class="ae lc" href="https://www.shutterstock.com/g/praet" rel="noopener ugc nofollow" target="_blank">标题照片致谢</a></p></div></div>    
</body>
</html>