<html>
<head>
<title>A directory structure for React projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React项目的目录结构</h1>
<blockquote>原文：<a href="https://itnext.io/a-directory-structure-for-react-projects-99fb084c61f1?source=collection_archive---------8-----------------------#2020-07-19">https://itnext.io/a-directory-structure-for-react-projects-99fb084c61f1?source=collection_archive---------8-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8214f67815e2edf4ad4736b65664294b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uFC-Nm1PTDn3rInq.png"/></div></div></figure><p id="6ac9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经回答了问题“你如何在一个<em class="kz"> React </em>项目中组织你的组件？”在过去几个月的内部邮件列表中出现过几次。我想分享我在上一个项目中使用的结构。</p><p id="547b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我有一个<a class="ae la" href="https://github.com/sirech/cookery2-frontend" rel="noopener ugc nofollow" target="_blank">小项目</a>作为例子。它基于两个简单的概念:</p><ul class=""><li id="5d38" class="lb lc it kd b ke kf ki kj km ld kq le ku lf ky lg lh li lj bi translated">文件夹是功能</li><li id="6536" class="lb lc it kd b ke lk ki ll km lm kq ln ku lo ky lg lh li lj bi translated">使用<code class="fe lp lq lr ls b">index.ts</code>来区分公共和私有组件。</li></ul><h1 id="90de" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">文件夹是功能</h1><p id="e0f9" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">我以前叫这个<em class="kz">垂直结构化组件</em>，但是这个名字更朗朗上口！这个想法是远离功能结构，在那里你有像<code class="fe lp lq lr ls b">controllers</code>、<code class="fe lp lq lr ls b">models</code>或<code class="fe lp lq lr ls b">services</code>这样的东西。相反，您应该围绕特性对代码进行分组。文件夹包含理解应用程序中特定功能所需的全部内容。代码更紧密地映射了域。如果你喜欢<a class="ae la" href="https://en.wikipedia.org/wiki/Domain-driven_design" rel="noopener ugc nofollow" target="_blank">领域驱动设计</a>，那对你来说应该是美妙的。</p><p id="92b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个例子。我有一个视图来显示食谱的细节，包括配料和步骤列表。数据是通过服务从后端获取的。页面大致如下所示:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/2627eba317c82bcc5b6e46a1f6c5903d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/0*H10DByzrhEfNprLP.png"/></div></figure><p id="19c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的代码中，我将把整个特性放在一个文件夹中，如下所示:</p><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="9044" class="nf lu it ls b gy ng nh l ni nj">recipe-details<br/>├── Ingredients.tsx<br/>├── RecipeDetails.test.tsx<br/>├── RecipeDetails.tsx<br/>├── Steps.tsx<br/>├── __mocks__ <br/>│ └── recipeDetails.service.ts <br/>├── index.ts <br/>└── recipeDetails.service.ts</span></pre><p id="ee2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">主要成分是<code class="fe lp lq lr ls b">RecipeDetails</code>。还有其他更小的组件，<code class="fe lp lq lr ls b">Ingredients</code>和<code class="fe lp lq lr ls b">Steps</code>。有一个服务可以与API、一些测试和模拟对话。通过查看这个文件夹，我能够理解这个特性，而不必梳理我的应用程序的多个部分。</p><h1 id="38b4" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">扩大规模</h1><p id="f7d4" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">随着应用程序变得越来越复杂，这些文件夹可能会增长到一个文件夹中有太多文件的程度。提取组件有助于保持组件较小。</p><p id="df36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在一个项目中做的另一个优化是引入了<code class="fe lp lq lr ls b">pages</code>的概念。页面就像一个功能，但是与一个URL相关联。将你的代码分成几个页面符合用户对你的应用的看法，并且有助于代码的拆分。</p><h1 id="3a51" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">使用index.ts来区分公共组件和私有组件</h1><p id="72bc" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">有了<em class="kz"> TypeScript </em>，你就无法像在<em class="kz"> Kotlin </em>中那样将代码分组到包中。不过，您可以用文件夹来模拟它。我喜欢使用文件夹的<code class="fe lp lq lr ls b">index.ts</code>作为入口点。如果部件被出口到那里，您只能从外部<strong class="kd iu">进口部件。回到我们的<code class="fe lp lq lr ls b">recipe-details</code>，我唯一想要导出的组件是<code class="fe lp lq lr ls b">RecipeDetails</code>，所以我的<code class="fe lp lq lr ls b">index.ts</code>看起来是这样的:</strong></p><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="d5b3" class="nf lu it ls b gy ng nh l ni nj">export { default } from './RecipeDetails'</span></pre><p id="5a11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我从主<code class="fe lp lq lr ls b">App.tsx</code>进口的是这样的:</p><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="f05e" class="nf lu it ls b gy ng nh l ni nj">import RecipeDetails from 'recipe-details'</span></pre><p id="02d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<a class="ae la" href="https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-internal-modules.md" rel="noopener ugc nofollow" target="_blank"> eslint-plugin-import </a>插件的帮助下，使用<a class="ae la" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> eslint </a>来执行这个约定。这不是一个合适的包系统，但在实践中它工作得很好。</p><p id="2a61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lp lq lr ls b">Ingredients</code>和<code class="fe lp lq lr ls b">Steps</code>都是私有组件。它们旨在仅用于该文件夹的上下文中，以确保所有组件保持较小。他们没有专门的测试，而是按照<a class="ae la" href="https://github.com/testing-library/react-testing-library" rel="noopener ugc nofollow" target="_blank"> React测试库</a>的原则，作为整个特性的一部分进行测试。</p><h1 id="b165" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">对公共组件使用绝对导入</h1><p id="42e2" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">这使得重构变得更加容易。</p><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="37e7" class="nf lu it ls b gy ng nh l ni nj">import Navigation from 'navigation'</span></pre><p id="d2a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是通过在<code class="fe lp lq lr ls b">tsconfig.json</code>中进行小调整来完成的:</p><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="7d91" class="nf lu it ls b gy ng nh l ni nj">{<br/>   "include": ["src"]<br/>}</span></pre><h1 id="6243" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><code class="fe lp lq lr ls b">components</code>下的通用组件</h1><p id="8d74" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">当心过度抽象！不要试图创建过于通用的组件。它最终会带来更多的复杂性。如果你确实有一些可以重用的组件，我喜欢把它们放在一个<code class="fe lp lq lr ls b">components</code>文件夹中:</p><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="dfd1" class="nf lu it ls b gy ng nh l ni nj">components <br/>├── adapter-link <br/>│ ├── AdapterLink.tsx <br/>│ └── index.ts <br/>└── recipe<br/>  ├── Recipe.test.tsx<br/>  ├── Recipe.tsx<br/>  ├── index.ts<br/>  └── types.ts</span></pre><h1 id="9595" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">不要害怕修补</h1><p id="9107" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">没有什么是一成不变的。保持元件小。不要让文件夹变得太大。有意义的时候把他们分组。并且给<a class="ae la" href="https://hceris.com/book-review-effective-typescript/" rel="noopener ugc nofollow" target="_blank">有效的打字稿</a>读一读，真的是一本好书。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="9363" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">原载于2020年7月19日</em><a class="ae la" href="https://hceris.com/a-directory-structure-for-react-projects/" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://hceris.com</em></a><em class="kz">。</em></p></div></div>    
</body>
</html>