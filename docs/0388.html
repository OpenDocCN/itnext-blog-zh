<html>
<head>
<title>Building Multi-tenant Web API using dot net core and best practices (Tutorial)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用. net core和最佳实践构建多租户Web API(教程)</h1>
<blockquote>原文：<a href="https://itnext.io/building-multi-tenant-web-api-using-dot-net-core-and-best-practices-8dce439bfae7?source=collection_archive---------1-----------------------#2018-03-03">https://itnext.io/building-multi-tenant-web-api-using-dot-net-core-and-best-practices-8dce439bfae7?source=collection_archive---------1-----------------------#2018-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="60b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了取得成功并处理越来越多的客户和合作伙伴，业务需要增长，如果一家公司没有准备好应对这一负载，那么机会就有可能被错过。这给游戏带来了可伸缩性的话题，作为公司应该解决的主要需求之一。因为解决这一需求的可能方法之一是构建多租户解决方案。随着这个话题变得越来越重要，有很多选择可以实现这一点，例如使用微软的弹性数据库(弹性工具)。然而在特殊的情况下，比如我在项目中遇到的情况，并不是所有的产品需求都可以用现有的选项来满足。这让我想到了收集我在这个话题上的经验并在下面展示出来。</p><p id="3811" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">众所周知，有两种主要方法来解决应用程序扩展问题——水平和垂直。水平扩展将为您带来动态扩展的好处，并意味着处理多个数据库，因为每个租户都有自己的数据库/碎片。纵向扩展方法假设有一个数据库为多个租户服务。</p><p id="9798" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的文章中，我将通过如何构建多租户web API应用程序的分步指南来解决水平伸缩的方法。</p><p id="8236" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想更新多租户架构的某些方面，或者它有哪些优点和缺点</p><p id="4710" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我建议您访问以下资源:</p><ul class=""><li id="05dd" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><a class="ae kx" href="https://servicematters.servicenow.com/2016/02/01/why-cloud-architecture-matters-the-multi-instance-advantage-over-multi-tenant/" rel="noopener ugc nofollow" target="_blank">云架构为何重要:多实例相对于多租户的优势</a></li><li id="3fbe" class="ko kp it js b jt ky jx kz kb la kf lb kj lc kn kt ku kv kw bi translated"><a class="ae kx" href="https://dzone.com/articles/why-multi-tenant-application-architecture-matters" rel="noopener ugc nofollow" target="_blank">为什么多租户应用架构在2017年如此重要</a></li><li id="4525" class="ko kp it js b jt ky jx kz kb la kf lb kj lc kn kt ku kv kw bi translated"><a class="ae kx" href="https://docs.microsoft.com/en-us/azure/sql-database/sql-database-design-patterns-multi-tenancy-saas-applications" rel="noopener ugc nofollow" target="_blank">多租户SaaS应用和Azure SQL数据库的设计模式</a></li></ul><h1 id="f2f5" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">体系结构</h1><p id="bbd4" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们先简单看一下架构。以下示例是基于N-tire设计的</p><p id="e3a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">体系结构，具有以下几层:</p><ul class=""><li id="8fba" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">表示层或web api</li><li id="7a12" class="ko kp it js b jt ky jx kz kb la kf lb kj lc kn kt ku kv kw bi translated">将容纳所有业务逻辑的服务层</li><li id="d48d" class="ko kp it js b jt ky jx kz kb la kf lb kj lc kn kt ku kv kw bi translated">使用<a class="ae kx" href="https://martinfowler.com/eaaCatalog/unitOfWork.html" rel="noopener ugc nofollow" target="_blank"> UnitOfWork </a>和<a class="ae kx" href="https://msdn.microsoft.com/en-us/library/ff649690.aspx" rel="noopener ugc nofollow" target="_blank">存储库</a>模式实现的数据访问层。作为这个例子中的ORM，我使用了实体框架核心。</li></ul><p id="686b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">租户分离的关键组件是<a class="ae kx" href="https://github.com/Boriszn/DeviceManager.Api/blob/master/src/DeviceManager.Api/Data/Management/ContextFactory.cs" rel="noopener ugc nofollow" target="_blank"> <em class="mg"> ContextFactory </em> </a>，它包含从HTTP头获取租户id、使用<a class="ae kx" href="https://github.com/Boriszn/DeviceManager.Api/blob/master/src/DeviceManager.Api/Data/Management/DataBaseManager.cs" rel="noopener ugc nofollow" target="_blank"><em class="mg">database manager</em></a><em class="mg"/>检索租户数据库名称以及替换连接字符串中的数据库名称的逻辑。结果，创建了数据库上下文(实体框架上下文)。</p><p id="0583" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下图演示了这种体系结构。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mh"><img src="../Images/d3d5c03d8448948cf9672b88e4b814c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3t-q0vFTY8L3Rn4J0pSAQ.png"/></div></div></figure><h1 id="8dcd" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">履行</h1><p id="bfda" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">如你所见，架构在这里并不复杂，浏览一下，我建议<br/>关注实现它的步骤。</p><h2 id="c91d" class="mt le it bd lf mu mv dn lj mw mx dp ln kb my mz lr kf na nb lv kj nc nd lz ne bi translated">1.创建上下文工厂</h2><p id="2348" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">正如我之前提到的<em class="mg"> ContextFactory </em>是整个架构的关键组件。它构建特定于租户数据库实体框架上下文(在当前示例中为<em class="mg"> DeviceApiContext </em>)</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4fcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mg"> ContextFactory </em>的源代码可用<strong class="js iu"> </strong> <a class="ae kx" href="https://github.com/Boriszn/DeviceManager.Api/blob/master/src/DeviceManager.Api/Data/Management/ContextFactory.cs" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">此处</strong> </a></p><h2 id="1f5c" class="mt le it bd lf mu mv dn lj mw mx dp ln kb my mz lr kf na nb lv kj nc nd lz ne bi translated">3.添加数据库管理器</h2><p id="d63a" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">数据库管理器协调所有租户元数据，如租户数据库名称、激活</p><p id="0125" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">租户的状态(激活/停用)和其他属性的集合。为了演示一个基本原理，我在当前的解决方案中使用了dictionary。稍后，字典应该被更合适的解决方案所取代，比如包含租户元数据的SQL或NoSQL数据库。这个想法类似于微软弹性工具中使用的<a class="ae kx" href="https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-shard-map-management" rel="noopener ugc nofollow" target="_blank">分片地图管理器</a>。租户元数据还可以包括存储数据库名称的字段、激活/停用租户的选项、甚至基于CSS/SASS/LESS文件的前端应用程序的租户样式等等</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3028" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mg">数据库管理器</em>的源代码可用<strong class="js iu"> </strong> <a class="ae kx" href="https://github.com/Boriszn/DeviceManager.Api/blob/master/src/DeviceManager.Api/Data/Management/DataBaseManager.cs" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">此处</strong> </a></p><h2 id="4cdb" class="mt le it bd lf mu mv dn lj mw mx dp ln kb my mz lr kf na nb lv kj nc nd lz ne bi translated">4.添加工作单元类(包含提交到特定上下文方法)</h2><p id="a30b" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated"><em class="mg"> UnitOfWork </em>解决两个任务。它提交实体框架在实体中所做的所有更改，并处理特定的上下文。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此处 可用<a class="ae kx" href="https://github.com/Boriszn/DeviceManager.Api/blob/master/src/DeviceManager.Api/Data/Management/UnitOfWork.cs" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">的UnitOfWork源代码</strong></a></p><h2 id="aeb1" class="mt le it bd lf mu mv dn lj mw mx dp ln kb my mz lr kf na nb lv kj nc nd lz ne bi translated">5.添加通用存储库类。</h2><p id="6532" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">存储库将在EF实体中进行更改，工作单元将向租户数据库提交更改。请注意，EF使用<a class="ae kx" href="https://docs.microsoft.com/en-us/ef/core/querying/tracking" rel="noopener ugc nofollow" target="_blank">跟踪机制来改变内存。</a></p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="527e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">资源库的源代码可用<a class="ae kx" href="https://github.com/Boriszn/DeviceManager.Api/blob/master/src/DeviceManager.Api/Data/Management/Repository.cs" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">此处</strong> </a></p><h2 id="1d0b" class="mt le it bd lf mu mv dn lj mw mx dp ln kb my mz lr kf na nb lv kj nc nd lz ne bi translated">5.添加租户标题操作过滤器。</h2><p id="ecd5" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated"><em class="mg">TenantHeaderOperationFilter</em>类将租户id字段添加到所有API调用中(作为HTTP头)。在使用auth0.com服务的解决方案中，可以将身份服务器或租户注入JWT令牌。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f303" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是应用过滤器后API的外观。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nh"><img src="../Images/9bd2e664aa456918dd60d6a93422bb85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Lw0-R7Zn-_s7rzDcIejkg.png"/></div></div></figure><p id="2cd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务类的当前示例(<em class="mg"> DeviceService.cs </em>)包含按id检索设备和为特定租户添加新设备的功能。服务层可用的源代码<a class="ae kx" href="https://github.com/Boriszn/DeviceManager.Api/blob/master/src/DeviceManager.Api/Services/DeviceService.cs" rel="noopener ugc nofollow" target="_blank">此处</a></p><h1 id="b3f6" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="6012" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在这篇文章中，我解释了如何构建“随时可用”的多租户解决方案，并给出了如何在您的产品/业务中使用它的一些建议。正如我之前提到的，这个解决方案是现成的，所以它可以作为“样板”项目或部分使用。</p><h1 id="521a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">源代码</h1><p id="7224" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">该项目的源代码可在<a class="ae kx" href="https://github.com/Boriszn/DeviceManager.Api" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Git库中找到，此处</strong> </a></p><p id="078a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原文<a class="ae kx" href="https://boris-zaikin.blogspot.de/2017/10/build-multitenant-api-based-on-swagger.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div></div>    
</body>
</html>