<html>
<head>
<title>Get a Shell to a Kubernetes Node</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">获取Kubernetes节点的外壳</h1>
<blockquote>原文：<a href="https://itnext.io/get-a-shell-to-a-kubernetes-node-9b720a15a4fe?source=collection_archive---------1-----------------------#2019-07-27">https://itnext.io/get-a-shell-to-a-kubernetes-node-9b720a15a4fe?source=collection_archive---------1-----------------------#2019-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6feec9b1e0b5e177e19e9320450427a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DM30mxQm6JqAOfhnGcSJUQ.jpeg"/></div></div></figure><p id="63e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Kubernetes集群的整个生命周期中，您可能需要访问一个集群工作节点。这种访问可以用于维护、配置检查、日志收集或其他故障排除操作。更重要的是，如果您可以在需要时启用这种访问，并在完成任务后禁用它，那就更好了。</p><h1 id="f7d9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">SSH方法</h1><p id="bed1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">虽然可以用SSH访问配置Kubernetes节点，但这也使worker节点更容易受到攻击。使用SSH需要在工程师的机器和EC2实例之间建立网络连接，这是您可能希望避免的。一些用户设置跳转服务器(也称为堡垒主机)作为典型模式，以最小化来自互联网的攻击面。但是这种方法仍然需要您管理对bastion服务器的访问并保护SSH密钥。IMHO，管理支持SSH基础设施是一个很高的代价，特别是如果您只是想获得对工作节点的shell访问或运行一些命令。</p><h1 id="046f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Kubernetes方法</h1><p id="3772" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Kubernetes命令行工具<code class="fe lz ma mb mc b">kubectl</code>允许您对Kubernetes集群运行不同的命令。您可以操纵Kubernetes API对象、管理worker节点、检查集群、在运行的容器中执行命令，以及<a class="ae md" href="https://kubernetes.io/docs/tasks/debug-application-cluster/get-shell-running-container/" rel="noopener ugc nofollow" target="_blank">获得一个运行的容器的交互式shell</a>。</p><p id="9328" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设你有一只<code class="fe lz ma mb mc b">pod</code>，名叫<code class="fe lz ma mb mc b">shell-demo</code>。要在这个<code class="fe lz ma mb mc b">pod</code>上获得运行容器的shell，只需运行:</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="9059" class="mm kx iq mc b gy mn mo l mp mq">kubectl exec -it shell-demo -- /bin/bash </span><span id="3989" class="mm kx iq mc b gy mr mo l mp mq"># see shell prompt ... <br/>root@shell-demo:/#</span></pre><h1 id="22f8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><code class="fe lz ma mb mc b">exec</code>是如何工作的？</h1><p id="0209" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe lz ma mb mc b">kubectl exec</code>调用Kubernetes API服务器，它“要求”一个<code class="fe lz ma mb mc b">Kubelet</code>“节点代理”针对CRI(容器运行时接口)运行一个<code class="fe lz ma mb mc b">exec</code>命令，最常见的是Docker运行时。</p><p id="39ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lz ma mb mc b">docker exec</code>API/命令创建一个新进程，将其名称空间设置为目标容器的名称空间，然后执行所请求的命令，还处理所创建进程的输入和输出流。</p><h1 id="87d3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">这个想法</h1><blockquote class="ms mt mu"><p id="f66c" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated"><em class="iq">Linux系统从每种类型(挂载、进程、ipc、网络、UTS和用户)都有一个名称空间开始，供所有进程使用。</em></p></blockquote><p id="c3a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我们需要做的是运行一个新的<code class="fe lz ma mb mc b">pod</code>，并把它连接到一个工作者节点的主机名称空间。</p><h1 id="fa61" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">助手程序</h1><p id="73e6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">可以使用任何带有shell的Docker映像作为“主机shell”容器。有一个限制，您应该知道——不可能连接目标容器(或主机)的<code class="fe lz ma mb mc b">mount namespace</code>。</p><p id="27b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是<code class="fe lz ma mb mc b">util-linux</code>包中的一个小程序，可以用其他进程的<code class="fe lz ma mb mc b">namespaces</code>(和<code class="fe lz ma mb mc b">cgroups</code>)运行程序。正是我们需要的！</p><p id="b623" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数Linux发行版都附带了一个过时的版本<code class="fe lz ma mb mc b">util-linux</code>。所以，我准备了带有<code class="fe lz ma mb mc b">nsenter</code>程序的<a class="ae md" href="https://hub.docker.com/r/alexeiled/nsenterr" rel="noopener ugc nofollow" target="_blank">alexeiled/nsenter</a>Docker图像。这是一个超级小的Docker映像，大小为<code class="fe lz ma mb mc b">900K</code>，由<code class="fe lz ma mb mc b">scratch</code>映像和一个静态链接的<code class="fe lz ma mb mc b">nsenter</code>二进制文件(<code class="fe lz ma mb mc b">v2.34</code>)创建。</p><p id="9422" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用下面的助手脚本，也可以在<a class="ae md" href="https://github.com/alexei-led/nsenter" rel="noopener ugc nofollow" target="_blank">Alexei-led/nsenter</a>GitHub存储库中找到，在指定的Kubernetes worker节点上运行一个新的<code class="fe lz ma mb mc b">nsenter pod</code>。这个助手脚本在主机的进程和网络名称空间中创建一个<em class="mv">特权</em> <code class="fe lz ma mb mc b">nsenter pod</code>，运行带有<code class="fe lz ma mb mc b">--all</code>标志的<code class="fe lz ma mb mc b">nsenter</code>，加入所有的<code class="fe lz ma mb mc b">namespaces</code>和<code class="fe lz ma mb mc b">cgroups</code>，并作为<em class="mv">超级用户</em>(使用<code class="fe lz ma mb mc b">su -</code>命令)运行一个默认shell。</p><p id="abba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lz ma mb mc b">nodeSelector</code>可以指定运行<code class="fe lz ma mb mc b">nsenter pod</code>的目标Kubernetes节点。如果指定，<code class="fe lz ma mb mc b">"tolerations": [{"operator": "Exists"}]</code>参数有助于匹配任何节点<code class="fe lz ma mb mc b">taint</code>。</p><h2 id="af05" class="mm kx iq bd ky mz na dn lc nb nc dp lg kj nd ne lk kn nf ng lo kr nh ni ls nj bi translated">助手脚本</h2><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="7965" class="mm kx iq mc b gy mn mo l mp mq"># get cluster nodes<br/>kubectl get nodes</span><span id="1539" class="mm kx iq mc b gy mr mo l mp mq"># output<br/>NAME                                            STATUS  AGE<br/>ip-192-168-151-104.us-west-2.compute.internal   Ready   8d      <br/>ip-192-168-171-140.us-west-2.compute.internal   Ready   7d11h</span><span id="a10b" class="mm kx iq mc b gy mr mo l mp mq"># open superuser shell on specified node<br/>./nsenter-node.sh ip-192-168-151-104.us-west-2.compute.internal</span><span id="bfe7" class="mm kx iq mc b gy mr mo l mp mq"># prompt<br/>[root@ip-192-168-151-104 ~]#</span><span id="98c3" class="mm kx iq mc b gy mr mo l mp mq"># pod will be destroyed on exit<br/>...</span></pre><p id="e573" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lz ma mb mc b">nsenter-node.sh</code></p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="a142" class="mm kx iq mc b gy mn mo l mp mq">#!/bin/sh<br/>set -x</span><span id="b952" class="mm kx iq mc b gy mr mo l mp mq">node=${1}<br/>nodeName=$(kubectl get node ${node} -o template --template='{{index .metadata.labels "kubernetes.io/hostname"}}') <br/>nodeSelector='"nodeSelector": { "kubernetes.io/hostname": "'${nodeName:?}'" },'<br/>podName=${USER}-nsenter-${node}</span><span id="6a79" class="mm kx iq mc b gy mr mo l mp mq">kubectl run ${podName:?} --restart=Never -it --rm --image overriden --overrides '<br/>{<br/>  "spec": {<br/>    "hostPID": true,<br/>    "hostNetwork": true,<br/>    '"${nodeSelector?}"'<br/>    "tolerations": [{<br/>        "operator": "Exists"<br/>    }],<br/>    "containers": [<br/>      {<br/>        "name": "nsenter",<br/>        "image": "alexeiled/nsenter:2.34",<br/>        "command": [<br/>          "/nsenter", "--all", "--target=1", "--", "su", "-"<br/>        ],<br/>        "stdin": true,<br/>        "tty": true,<br/>        "securityContext": {<br/>          "privileged": true<br/>        }<br/>      }<br/>    ]<br/>  }<br/>}' --attach "$@"</span></pre><h1 id="8410" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">AWS上Kubernetes工作节点的管理</h1><p id="da47" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在AWS、亚马逊EKS或自我管理的Kubernetes集群上运行Kubernetes集群时，可以使用【AWS系统管理器】<a class="ae md" href="https://aws.amazon.com/systems-manager/)" rel="noopener ugc nofollow" target="_blank">【https://aws.amazon.com/systems-manager/】</a>管理Kubernetes节点。使用AWS Systems Manager (AWS SSM ),您可以自动化多项管理任务、应用补丁和更新、运行命令以及在任何受管节点上访问shell，而无需维护SSH基础架构。</p><p id="ebb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了管理一个Kubernetes节点(AWS EC2主机)，你需要安装并启动一个SSM代理守护进程，更多细节见<a class="ae md" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-ssm-agent.html" rel="noopener ugc nofollow" target="_blank"> AWS文档</a>。</p><p id="aac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们正在采用Kubernetes方法，这意味着我们将在集群中的每个Kubernetes节点上运行一个SSM代理作为<code class="fe lz ma mb mc b">daemonset</code>。这种方法允许您运行更新版本的SSM代理，而无需将其安装到主机上，并且仅在需要时才运行。</p><h2 id="d4d3" class="mm kx iq bd ky mz na dn lc nb nc dp lg kj nd ne lk kn nf ng lo kr nh ni ls nj bi translated">预先请求</h2><p id="0cf8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><strong class="ka ir">选项1(更安全)</strong></p><p id="c59b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以将AWS IAM角色与Kubernetes服务帐户相关联，并使用该服务帐户运行SSM代理<em class="mv"> DaemonSet。</em></p><p id="b96e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是最安全的选择。您只将<code class="fe lz ma mb mc b">AmazonEC2RoleforSSM</code> IAM角色分配给SSM代理，并在需要访问集群节点时创建SSM <em class="mv"> DaemonSet </em>。你也可以用<code class="fe lz ma mb mc b">nodeSelector</code>锁定特定的节点。</p><p id="c60d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个新的Kubernetes服务帐户(例如<code class="fe lz ma mb mc b">ssm-sa</code>，并将其连接到IAM角色，附带<code class="fe lz ma mb mc b">AmazonEC2RoleforSSM</code>策略。</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="a119" class="mm kx iq mc b gy mn mo l mp mq">$ export CLUSTER_NAME=gaia-kube<br/>$ export SA_NAME=ssm-sa</span><span id="afab" class="mm kx iq mc b gy mr mo l mp mq"># setup IAM OIDC provider for EKS cluster<br/>$ <strong class="mc ir">eksctl utils associate-iam-oidc-provider — region=us-west-2 — name=$CLUSTER_NAME — approve</strong></span><span id="bbe3" class="mm kx iq mc b gy mr mo l mp mq"># create K8s service account linked to IAM role in kube-system namespace<br/>$ <strong class="mc ir">eksctl create iamserviceaccount — name $SA_NAME — cluster $CLUSTER_NAME — namespace kube-system \<br/> — attach-policy-arn arn:aws:iam::aws:policy/service-role/AmazonEC2RoleforSSM \<br/> — override-existing-serviceaccounts \<br/> — approve</strong></span><span id="377a" class="mm kx iq mc b gy mr mo l mp mq">[ℹ] using region us-west-2<br/>[ℹ] 1 iamserviceaccount (kube-system/ssm-sa) was included (based on the include/exclude rules)<br/>[!] serviceaccounts that exists in Kubernetes will be excluded, use — override-existing-serviceaccounts to override<br/>[ℹ] 1 task: { 2 sequential sub-tasks: { create IAM role for serviceaccount “kube-system/ssm-sa”, create serviceaccount “kube-system/ssm-sa” } }<br/>[ℹ] building iamserviceaccount stack “eksctl-gaia-kube-addon-iamserviceaccount-kube-system-ssm-sa”<br/>[ℹ] deploying stack “eksctl-gaia-kube-addon-iamserviceaccount-kube-system-ssm-sa”<br/>[ℹ] created serviceaccount “kube-system/ssm-sa”</span></pre><p id="5b29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">配置SSM <em class="mv">守护进程</em>以使用此服务帐户。</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="bd57" class="mm kx iq mc b gy mn mo l mp mq">apiVersion: apps/v1<br/>kind: DaemonSet<br/>metadata:<br/> name: ssm-agent<br/> labels:<br/> k8s-app: ssm-agent<br/> namespace: kube-syste<br/>spec:<br/> …<br/> template:<br/> …<br/> spec:<br/> <strong class="mc ir">serviceAccountName: ssm-sa</strong><br/> containers:<br/> — image: alexeiled/aws-ssm-agent<br/> name: ssm-agent<br/> …</span></pre><p id="bbbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，部署SSM <em class="mv">守护进程</em>并访问您的集群节点。</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="9009" class="mm kx iq mc b gy mn mo l mp mq">kubectl create -f daemonset.xml</span></pre><p id="2e75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">备选方案2(不太安全)</strong></p><p id="9dac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，您需要将<code class="fe lz ma mb mc b">AmazonEC2RoleforSSM</code>策略附加到Kubernetes worker nodes实例角色。如果没有这个策略，您将无法使用AWS SSM管理Kubernetes工作节点。</p><h1 id="6995" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设置</h1><p id="6ca5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">然后，克隆<a class="ae md" href="https://github.com/alexei-led/kube-ssm-agent" rel="noopener ugc nofollow" target="_blank">Alexei-led/kube-SSM-agent</a>GitHub库。它包含一个正确配置的SSM代理<code class="fe lz ma mb mc b">daemonset</code>文件。</p><p id="a040" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lz ma mb mc b">daemonset</code>使用包含以下内容的<code class="fe lz ma mb mc b"><a class="ae md" href="https://hub.docker.com/r/alexeiled/aws-ssm-agent" rel="noopener ugc nofollow" target="_blank">alexeiled/aws-ssm-agent:&lt;ver&gt;</a></code> Docker图像:</p><ol class=""><li id="9861" class="nk nl iq ka b kb kc kf kg kj nm kn nn kr no kv np nq nr ns bi translated">AWS SSM代理，与Docker图像标签版本相同</li><li id="6103" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated">Docker CLI客户端</li><li id="1b9f" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated">AWS CLI客户端</li><li id="503e" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated">Vim和其他有用的程序</li></ol><p id="769e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行以部署新的SSM代理daemonset:</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="e14c" class="mm kx iq mc b gy mn mo l mp mq">kubectl create -f daemonset.yaml</span></pre><p id="2d6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦SSM代理daemonset运行，您就可以运行任何<code class="fe lz ma mb mc b">aws ssm</code>命令。</p><p id="51af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行以启动新的SSM终端会话:</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="0745" class="mm kx iq mc b gy mn mo l mp mq">AWS_DEFAULT_REGION=us-west-2 aws ssm start-session --target &lt;instance-id&gt;</span><span id="c25d" class="mm kx iq mc b gy mr mo l mp mq">starting session with SessionId: ...</span><span id="b3c6" class="mm kx iq mc b gy mr mo l mp mq">sh-4.2$ ls<br/>sh-4.2$ pwd<br/>/opt/amazon/ssm<br/>sh-4.2$ bash -i<br/>[ssm-user@ip-192-168-84-111 ssm]$</span><span id="7188" class="mm kx iq mc b gy mr mo l mp mq">[ssm-user@ip-192-168-84-111 ssm]$ exit<br/>sh-4.2$ exit</span><span id="c645" class="mm kx iq mc b gy mr mo l mp mq">Exiting session with sessionId: ...</span></pre><h2 id="0420" class="mm kx iq bd ky mz na dn lc nb nc dp lg kj nd ne lk kn nf ng lo kr nh ni ls nj bi translated"><code class="fe lz ma mb mc b">daemonset.yaml</code>文件</h2><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="b3fd" class="mm kx iq mc b gy mn mo l mp mq">apiVersion: apps/v1<br/>kind: DaemonSet<br/>metadata:<br/>  name: ssm-agent<br/>  labels:<br/>    k8s-app: ssm-agent<br/>  namespace: kube-system<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      name: ssm-agent<br/>  template:<br/>    metadata:<br/>      labels:<br/>        name: ssm-agent<br/>    spec:<br/>      # use IAM role associated with K8s service<br/>      serviceAccountName: ssm-sa<br/>      # join host network namespace<br/>      hostNetwork: true<br/>      # join host process namespace<br/>      hostPID: true<br/>      # join host IPC namespace<br/>      hostIPC: true <br/>      # tolerations<br/>      tolerations:<br/>      - effect: NoExecute<br/>        operator: Exists<br/>      - effect: NoSchedule<br/>        operator: Exists<br/>      containers:<br/>      - image: alexeiled/aws-ssm-agent:2.3.680<br/>        imagePullPolicy: Always<br/>        name: ssm-agent<br/>        securityContext:<br/>          runAsUser: 0<br/>          privileged: true<br/>        volumeMounts:<br/>        # Allows systemctl to communicate with the systemd running on the host<br/>        - name: dbus<br/>          mountPath: /var/run/dbus<br/>        - name: run-systemd<br/>          mountPath: /run/systemd<br/>        # Allows to peek into systemd units that are baked into the official EKS AMI<br/>        - name: etc-systemd<br/>          mountPath: /etc/systemd<br/>        # This is needed in order to fetch logs NOT managed by journald<br/>        # journallog is stored only in memory by default, so we need<br/>        #<br/>        # If all you need is access to persistent journals, /var/log/journal/* would be enough<br/>        # FYI, the volatile log store /var/run/journal was empty on my nodes. Perhaps it isn't used in Amazon Linux 2 / EKS AMI?<br/>        # See <a class="ae md" href="https://askubuntu.com/a/1082910" rel="noopener ugc nofollow" target="_blank">https://askubuntu.com/a/1082910</a> for more background<br/>        - name: var-log<br/>          mountPath: /var/log<br/>        - name: var-run<br/>          mountPath: /var/run<br/>        - name: run<br/>          mountPath: /run<br/>        - name: usr-lib-systemd<br/>          mountPath: /usr/lib/systemd<br/>        - name: etc-machine-id<br/>          mountPath: /etc/machine-id<br/>        - name: etc-sudoers<br/>          mountPath: /etc/sudoers.d<br/>      volumes:<br/>      # for systemctl to systemd access<br/>      - name: dbus<br/>        hostPath:<br/>          path: /var/run/dbus<br/>          type: Directory<br/>      - name: run-systemd<br/>        hostPath:<br/>          path: /run/systemd<br/>          type: Directory<br/>      - name: etc-systemd<br/>        hostPath:<br/>          path: /etc/systemd<br/>          type: Directory<br/>      - name: var-log<br/>        hostPath:<br/>          path: /var/log<br/>          type: Directory<br/>      # mainly for dockerd access via /var/run/docker.sock<br/>      - name: var-run<br/>        hostPath:<br/>          path: /var/run<br/>          type: Directory<br/>      # var-run implies you also need this, because<br/>      # /var/run is a synmlink to /run<br/>      # sh-4.2$ ls -lah /var/run<br/>      # lrwxrwxrwx 1 root root 6 Nov 14 07:22 /var/run -&gt; ../run<br/>      - name: run<br/>        hostPath:<br/>          path: /run<br/>          type: Directory<br/>      - name: usr-lib-systemd<br/>        hostPath:<br/>          path: /usr/lib/systemd<br/>          type: Directory<br/>      # Required by journalctl to locate the current boot.<br/>      # If omitted, journalctl is unable to locate host's current boot journal<br/>      - name: etc-machine-id<br/>        hostPath:<br/>          path: /etc/machine-id<br/>          type: File<br/>      # Avoid this error &gt; ERROR [MessageGatewayService] Failed to add ssm-user to sudoers file: open /etc/sudoers.d/ssm-agent-users: no such file or directory<br/>      - name: etc-sudoers<br/>        hostPath:<br/>          path: /etc/sudoers.d<br/>          type: Directory</span></pre><h1 id="8431" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="2fc9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如您所见，以纯Kubernetes的方式管理Kubernetes节点相对容易，无需冒不必要的风险和管理复杂的SSH基础设施。</p><h1 id="1fbb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">参考</h1><p id="de34" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">- <a class="ae md" href="https://hub.docker.com/r/alexeiled/nsenter" rel="noopener ugc nofollow" target="_blank"> alexei-led/nsenter </a> Docker image <br/> - <a class="ae md" href="https://github.com/alexei-led/nsenter" rel="noopener ugc nofollow" target="_blank"> alexei-led/nsenter </a> GitHub repository <br/> - <a class="ae md" href="http://man7.org/linux/man-pages/man1/nsenter.1.html" rel="noopener ugc nofollow" target="_blank"> nsenter </a> man page <br/> - <a class="ae md" href="https://github.com/alexei-led/kube-ssm-agent" rel="noopener ugc nofollow" target="_blank"> alexei-led/kube-ssm-agent </a> SSM Agent for Amazon EKS</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="77a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mv"> 草稿发表于 </em> <a class="ae md" href="https://alexei-led.github.io/post/k8s_node_shell/" rel="noopener ugc nofollow" target="_blank"> <em class="mv"> https://alexei-led.github.io </em> </a> <em class="mv">(T18)</em></p></div></div>    
</body>
</html>