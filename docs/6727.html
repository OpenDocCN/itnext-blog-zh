<html>
<head>
<title>Active-Passive Background Service In .Net 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">主动-被动后台服务。网络6</h1>
<blockquote>原文：<a href="https://itnext.io/active-passive-background-service-in-net-6-952f3aebd1b7?source=collection_archive---------0-----------------------#2022-02-11">https://itnext.io/active-passive-background-service-in-net-6-952f3aebd1b7?source=collection_archive---------0-----------------------#2022-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e3d5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">背景故事:</h2></div><p id="66ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">假设您有多台服务器试图在某个时间间隔(比如1秒或更快)内访问和操作一些数据。服务器试图操作的数据只能由一个进程同时访问。在其他情况下，它会导致一些不可预测和难以跟踪的问题。</p><p id="919e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该能够在多个服务器上的同一个后台服务上运行多个实例。同时，只有一个实例应该在“活动”模式下运行，这意味着做功。其他的要以“被动”模式运行，等到“主动”的一个下去，再自动从“被动”切换到“主动”。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/873b3b80ed9f209ac8db030022d55146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqSTCiAhrG6R24QhaUfqHA.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">体系结构</figcaption></figure><p id="d1e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上图所示，我们将实现面向推送的服务发现功能来满足需求。每个实例将在开始时在外部数据源中注册自己(可以是任何Azure数据库/SQL Server/No-SQL)。所有实例都将包含一个逻辑，告诉它们应该以哪种模式工作。如果出现意外的服务器故障，我们将实现实例的自动注销逻辑。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ma"><img src="../Images/ff595a700533e5c16ec25e5b69b833b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2an8Xu97O8Ssmv01tg0WTQ.png"/></div></div></figure><h1 id="504b" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">要求:</h1><h2 id="5291" class="mt mc iq bd md mu mv dn mh mw mx dp ml ko my mz mn ks na nb mp kw nc nd mr ne bi translated">功能要求:</h2><ul class=""><li id="fe30" class="nf ng iq kh b ki nh kl ni ko nj ks nk kw nl la nm nn no np bi translated">每个后台服务都必须能够操作数据。</li><li id="631c" class="nf ng iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">每个后台服务必须能够在“被动”模式下工作。</li><li id="7d8d" class="nf ng iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">每个后台服务必须能够在“活动”模式下工作。</li><li id="da39" class="nf ng iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">每个后台服务将在开始时注册自己。</li><li id="5ee7" class="nf ng iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">每个后台服务将在X秒后重新注册。</li><li id="40d7" class="nf ng iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">每个后台服务将在退出时注销自己。</li><li id="7fdb" class="nf ng iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">如果后台服务无法注销自身(例如，服务器崩溃)，则应该由另一个服务注销它。</li></ul><h2 id="2892" class="mt mc iq bd md mu mv dn mh mw mx dp ml ko my mz mn ks na nb mp kw nc nd mr ne bi translated">非功能性要求:</h2><ul class=""><li id="687a" class="nf ng iq kh b ki nh kl ni ko nj ks nk kw nl la nm nn no np bi translated">NET 6工作进程。</li><li id="550f" class="nf ng iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">服务器对互联网的访问受到限制。</li><li id="9abf" class="nf ng iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">服务器可能会意外崩溃。</li></ul><h2 id="08e6" class="mt mc iq bd md mu mv dn mh mw mx dp ml ko my mz mn ks na nb mp kw nc nd mr ne bi translated">后台服务</h2><p id="ec65" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">NET 6主机允许将多个托管服务注册为同一主机的一部分。在这种情况下，应用程序将包含两个并行工作的长期运行的后台服务。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ny"><img src="../Images/5396a3a10dc826f77be1f3e653a97d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tP33ulMkd5QhxwccnNU_GQ.png"/></div></div></figure><h1 id="e96f" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">履行</h1><p id="5da3" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">让我们从后台服务实现开始。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="016e" class="mt mc iq bd md mu mv dn mh mw mx dp ml ko my mz mn ks na nb mp kw nc nd mr ne bi translated">RegisterInstanceWorkerProcess</h2><p id="1602" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">在Execute Async方法(第24行)中包含了我们的整个逻辑。<br/>因为这是工作进程，我们有一个while循环，每1秒迭代一次，并执行以下操作:</p><ul class=""><li id="b354" class="nf ng iq kh b ki kj kl km ko ob ks oc kw od la nm nn no np bi translated">用唯一的实例id注册工作进程实例。</li><li id="7b2e" class="nf ng iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">删除孤立实例</li><li id="6c87" class="nf ng iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">等待1秒钟，重复整个操作。</li></ul><p id="d09e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有任何错误，我们记录错误，停止实例并尝试取消注册它(StopAsync方法)。StopAsync方法只有在我们正常停止工作进程时才会触发。如果出现意外的严重故障(例如，服务器因断电而停机)，该方法将不会执行。在这个场景中，工作进程的另一个实例将注销这个实例(第36行的<strong class="kh ir"> DeleteOprhantInstanes </strong>方法)。</p><h2 id="61c4" class="mt mc iq bd md mu mv dn mh mw mx dp ml ko my mz mn ks na nb mp kw nc nd mr ne bi translated">工人</h2><p id="f863" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">工作进程要简单得多——在while循环中，我们检查实例应该是主动的还是被动的。根据结果，我们执行相应的逻辑(DoInActive和DoInPassive方法)。</p><h2 id="d82f" class="mt mc iq bd md mu mv dn mh mw mx dp ml ko my mz mn ks na nb mp kw nc nd mr ne bi translated">RegisterInstanceService</h2><p id="9192" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">本文的核心是我们的RegisterInstanceService类。这个类包含四个方法。<br/>我们来看看:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="176f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第20行，我们有一个<strong class="kh ir">注册方法</strong>。<br/>该方法获取所有已注册的实例，如果已注册的实例中没有当前活动的实例，我们注册一个新的实例并将其设置为活动的。如果我们的实例已经存在(因为我们每10秒注册一次)，我们只需更新注册日期。</p><p id="d492" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Unregister方法</strong>(第36行)只是删除我们的数据存储的一个实例。</p><p id="59c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> IsActive </strong>(第41行)方法也很简单。从所有注册的实例中，我们试图找到具有当前id的实例，并返回活动标志。</p><p id="94d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> DeleteOrphantInstances </strong>比较有意思。该方法允许我们删除仍然在数据存储中但至少1分钟没有更新的所有实例。这种方法保证了即使一些实例在没有取消注册情况下会崩溃，我们仍然会自动将它们从数据存储中删除，从而允许其他实例接管“活动”模式。</p><h1 id="16be" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated"><strong class="ak">总结</strong></h1><p id="6c04" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">有时我们不能使用专用的工具/框架来实现利益相关者所要求的功能。这一次，它是一个主动的功能。</p><p id="a5c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的GitHub上有完整的代码和工作解决方案。</p><div class="oe of gp gr og oh"><a href="https://github.com/Ridikk12/ActivePassiveWorkerProcess" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">GitHub-ridikk 12/ActivePassiveWorkerProcess</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>