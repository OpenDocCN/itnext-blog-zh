<html>
<head>
<title>Solve any external library error in TypeScript with module augmentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用模块扩充解决TypeScript中的任何外部库错误</h1>
<blockquote>原文：<a href="https://itnext.io/solve-any-external-library-error-in-typescript-with-module-augmentation-850be741fda2?source=collection_archive---------2-----------------------#2022-01-05">https://itnext.io/solve-any-external-library-error-in-typescript-with-module-augmentation-850be741fda2?source=collection_archive---------2-----------------------#2022-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2a14b2a228e705b0dd7b6d2e8e4ac601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVxNbfpnMB02R6_kLSdy-w.png"/></div></div></figure><p id="f760" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本TypeScript教程将介绍我们如何使用模块扩充来解决在使用外部库时可能遇到的任何类型错误。当你遇到困难时，使用模块扩充来调整那些你无法访问的模块。</p><h1 id="d513" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">TypeScript中的声明合并</h1><p id="ca87" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在我们深入研究模块扩充之前，让我们简要介绍一下声明合并在TypeScript中是如何工作的，因为它们遵循相同的基本原则。</p><p id="a3ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TypeScript使用声明合并将多个类型组合成一个合并的声明，前提是这些类型具有相同的名称。</p><p id="82d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用TypeScript来组合各种类型，例如相互之间的接口、枚举与枚举、命名空间与命名空间等等。例外情况是类合并，这是不允许的。</p><p id="fe35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们简单介绍一个例子:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/f1cf655c625a645cd83bb7ac43c87c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ddlUd14DjU9vEUdOzRk8Dw.png"/></div></div></figure><p id="bb3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码定义了一个带有<code class="fe mh mi mj mk b">make</code>属性的<code class="fe mh mi mj mk b">Car </code>类和一个带有<code class="fe mh mi mj mk b">type</code>属性的<code class="fe mh mi mj mk b">Car</code>接口。然后，我们创建一个Car实例，并将其赋给<code class="fe mh mi mj mk b">myCar</code>常量。因此，<code class="fe mh mi mj mk b">myCar</code>将同时包含<code class="fe mh mi mj mk b">make</code>和<code class="fe mh mi mj mk b">type</code>属性。</p><p id="4421" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果我们尝试在接口中添加一个方法声明会怎么样呢？</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/763c28784cb4008c3eac0c9fc93c0d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qATJme5adiClOY3hl9PKtg.png"/></div></div></figure><p id="2e8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，我们会得到一个错误，因为我们没有drive方法的实际实现。然而，我们可以使用<code class="fe mh mi mj mk b">Car</code>原型添加一个:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/53ec50c6b5e12295bfc4d4331f9d0497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujeRFuw_5PFT901GtU99Ag.png"/></div></div></figure><p id="6097" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能会想“为什么不创建一个同名的类，并初始化它们呢？”但是请记住，TypeScript通常不允许您合并类。然而，你可以用<a class="ae mm" href="https://www.typescriptlang.org/docs/handbook/mixins.html" rel="noopener ugc nofollow" target="_blank"> mixins </a>实现一个解决方法，但是这超出了本文的范围。</p><p id="d4c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在我们的<code class="fe mh mi mj mk b">Car</code>实例上调用我们的方法<code class="fe mh mi mj mk b">drive</code>将会工作，我们已经成功地合并了我们的类和接口！</p><h1 id="c8cb" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">模块扩充</h1><p id="2c2d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在我们知道了声明合并在TypeScript中是如何工作的，让我们看看模块增强如何帮助我们扩展外部模块。</p><p id="4567" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过创建一个新模块来实现这一点，该模块导入我们想要增强的模块，用定制功能增强它们，然后导出它们。</p><p id="9a15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看另一个例子。</p><p id="6224" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们将创建一个<code class="fe mh mi mj mk b">car.ts</code>模块:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/4323d2335c0f91f334e008acd266d71c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqzVV5FWrcn7Mom2ZU1d1w.png"/></div></div></figure><p id="2d25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们创建将增强<code class="fe mh mi mj mk b">car.ts</code>的<code class="fe mh mi mj mk b">augmented.ts</code>模块:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/02d1dfd815f96ac6a8bb6dac4a919836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnjC5SPr_L55ufStgROzuA.png"/></div></div></figure><p id="b8ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码将导入我们想要扩充的TypeScript文件，并创建与我们的类同名的<code class="fe mh mi mj mk b">interface</code>。我们声明了一个新的公共接口，它添加了一个<code class="fe mh mi mj mk b">fly</code>方法。添加这个之后，我们现在可以在我们的TypeScript实例上调用<code class="fe mh mi mj mk b">fly</code>。</p><p id="b885" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码还会在扩充TypeScript类后将其导出。现在我们可以在我们的<code class="fe mh mi mj mk b">Car</code>实例中使用增强的<code class="fe mh mi mj mk b">fly</code>方法了！</p><p id="0c66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意:您不能增加默认导出，只能增加命名导出。原因是您需要通过导出名称来扩充导出，而</strong> <code class="fe mh mi mj mk b"><strong class="kd iu">default</strong></code> <strong class="kd iu">是一个保留字。</strong></p><h1 id="8660" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用全局增强扩展第三方模块</h1><p id="d1c8" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在让我们看看如何使用全局模块增强来扩展第三方包中的模块。</p><p id="de34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">全局增强技术类似于我们以前讨论过的模块增强，其工作原理如下:</p><ul class=""><li id="5431" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">检查要扩展的TypeScript模块的名称</li><li id="f6c1" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">创建相应的d.ts文件</li><li id="8e2e" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">扩充模块</li></ul><p id="85d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们尝试用自定义类型扩展<code class="fe mh mi mj mk b">react-beatiful-dnd</code>库。首先，我们将创建<code class="fe mh mi mj mk b">react-beautiful-dnd.d.ts</code>文件并添加以下代码:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/d05f5b9fb2779c4b70dc84c7e640599e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h3ZE3Sb-PbMCCJUgCQuoeQ.png"/></div></div></figure><p id="9868" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，我们为来自<code class="fe mh mi mj mk b">react-beautiful-dnd</code>的<code class="fe mh mi mj mk b">Draggable</code>组件添加了一个类型声明。</p><p id="b900" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是你真正需要的！现在，我们可以像这样在应用程序中使用我们的类型:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/d2215199b22f0d0d65984962ca1622c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJI62Vvb6v4trJpAM5aa0A.png"/></div></div></figure><p id="887c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们使用的是TypeScript自动获取的<code class="fe mh mi mj mk b">d.ts</code>文件，所以我们可以像平常一样导入我们的库。</p><h1 id="8048" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="b847" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在这篇文章中，我们通过例子学习了TypeScript中声明合并的基础知识。我们还讨论了模块增强和使用全局增强来扩展第三方模块，以解决您在使用类型时可能遇到的任何问题。我希望这篇文章对你有用！</p><p id="5601" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想获得更多的网络开发、反馈和打字技巧，可以考虑在Twitter上关注我，在那里我分享我学到的东西。</p><p id="dc74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">编码快乐！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="00f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ni">原载于2022年1月5日</em><a class="ae mm" href="https://isamatov.com/typescript-module-augmentation/" rel="noopener ugc nofollow" target="_blank"><em class="ni">https://isamatov.com</em></a><em class="ni">。</em></p></div></div>    
</body>
</html>