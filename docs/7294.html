<html>
<head>
<title>How to write DDD, scalable and type-safe NodeJS backends.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写DDD、可伸缩和类型安全的NodeJS后端？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-write-ddd-scalable-and-type-safe-nodejs-backends-e0711403a755?source=collection_archive---------0-----------------------#2022-08-12">https://itnext.io/how-to-write-ddd-scalable-and-type-safe-nodejs-backends-e0711403a755?source=collection_archive---------0-----------------------#2022-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/54fd85746d0ac670ec4cfee74815330b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ifYb3jjDhDWXvfDS5zO5AQ.jpeg"/></div></div></figure><p id="0d8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将介绍一种用typescript编写NodeJS代码的方法，这种代码是可伸缩的，并且易于推理。此外，我们将应用CQRS和领域驱动的设计原则，即使这个领域还不是众所周知的。之后，我们将讨论如何扩展应用程序，以及如何将它分成几个微服务。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="0b05" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">从写入中拆分读取</h1><p id="afd0" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">几乎每个应用程序的读取次数都远远多于写入次数。因此，扩展读取端应该是我们的首要任务。最初，我们可以从单个数据库实例开始；让我们使用Postgres作为一个读(以及后来的写)数据库。为了扩展Postgres，我们可以很容易地设置一个只读副本集，用于查询数据。然而，数据复制引入了最终一致性，这意味着当查询副本时，数据可能是陈旧的。这应该在您的前端考虑到(使用版本控制)。这就是为什么最好从单个实例开始，并在必要时引入读取副本集。</p><p id="d4ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在NodeJS应用程序中，我们只需编写查询任何读取副本的路由/解析器。知道我们应该在查询副本之间有一些负载平衡是很重要的。如果您自己托管数据库，可以使用类似Pgpool-II的工具。然而，使用云解决方案来托管数据库可能更好也更便宜。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/85a8fe40111addbef8c352164bc17dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*ZnwiaoN9lMfwCM9UArxDRg.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">碎片1和2是读取副本，用于查询</figcaption></figure><p id="7fff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的是，在查询和读取数据时，我们不应该引入任何副作用，从而避免数据的内部和外部突变。这是应用CQRS的一个基本原则。</p><p id="e5fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一种方法是使用Hasura之类的服务，它将数据库模型映射到GraphQL类型和解析器。此外，它们提供现成的授权和身份验证规则。真的推荐给你去看看。如果你想只写SQL，检查一下https://github.com/adelsz/pgtyped<a class="ae mp" href="https://github.com/adelsz/pgtyped" rel="noopener ugc nofollow" target="_blank">的包</a>，它提供了codegen工具来运行你的类型安全的查询。对于我个人的项目，我主要使用Hasura结合前端的<a class="ae mp" href="https://www.graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL代码生成器</a>读取/查询数据。</p><h1 id="5395" class="ld le iq bd lf lg mq li lj lk mr lm ln lo ms lq lr ls mt lu lv lw mu ly lz ma bi translated">改变数据</h1><p id="bfd0" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我发现计算机科学中最难的事情之一是管理状态。因此，这可能是最难掌握的部分。让我们定义一个简单的支付和订单服务，我们将使用它作为一个例子，看看我们会想出什么。</p><p id="d86a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们将应用一个领域驱动的方法:定义在我们的服务中可能发生的事件(只是一些，我不是领域专家)</p><ul class=""><li id="7eef" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">订单已满</li><li id="d211" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">订单已取消</li><li id="599d" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">已下单</li><li id="6d7a" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">请求付款</li><li id="135a" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">付款已付</li><li id="d109" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">付款已取消</li></ul><p id="a4fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在typescript中定义它:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4676" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用带有一些泛型的<code class="fe nl nm nn no b"><em class="np">TEvent</em></code>作为基本类型，以确保事件数据有效载荷的相同结构。</p><p id="ee17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是时候定义在某些不变量下产生事件的命令了。我们将对命令使用函数方法，而不是集合根或类。因此给出了一个纯粹的函数:</p><blockquote class="nq"><p id="1249" class="nr ns iq bd nt nu nv nw nx ny nz kv dk translated">命令(状态，有效负载)= &gt;[事件]；</p></blockquote><p id="4304" class="pw-post-body-paragraph jy jz iq ka b kb oa kd ke kf ob kh ki kj oc kl km kn od kp kq kr oe kt ku kv ij bi translated">typescript实现:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e72d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些命令处理程序应该保存业务不变量。如您所见，这些函数是纯函数，因此很容易测试。使用helper函数的一个好处是我们将额外拥有类型安全。</p><p id="f87c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在有了基本的应用程序，它有一些业务不变量，没有额外的库/框架作为依赖。</p><p id="3fc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在我们的实现中有一个缺失的特性，那就是工作流，或者更好的称呼，我们案例中的事件流。</p><p id="0086" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当事件X发生时，我们在应用程序中给出了下一个事件流，然后事件Y也发生了:</p><ul class=""><li id="bd4f" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">订单-&gt;付款请求</li><li id="aa12" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">付款已付-&gt;订单已完成</li><li id="e719" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">付款取消-&gt;订单取消</li></ul><p id="6311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们只有一个服务，处理付款和订单，我们会做所有的事情。在下一部分中，我将解释如何将其移动到2个微服务。</p><p id="5daa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在进行过程中，有几种方法可以解决我们的问题:</p><ul class=""><li id="9a7c" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">在我们的控制器中调用多个命令。然而，这带来了一个缺点，当我们在多个地方调用我们的命令时，很容易忘记工作流需求。</li><li id="9539" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">在命令处理程序中创建事件。例如，place_order命令创建两个事件，OrderPlaced和PaymentRequested。然而，这将使以后更难重构和转移到单独的服务。此外，place_order的输入应该具有request_payment命令的附加数据。</li><li id="e362" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">为流创建新的命令处理程序，并隐藏(不导出)底层命令。在我看来，这是两全其美。</li></ul><p id="c0a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个流是这样的:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="991e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时从命令处理程序返回新的派生状态是有用的，那么我们需要将命令处理程序的签名修改为:</p><blockquote class="nq"><p id="b5cf" class="nr ns iq bd nt nu nv nw nx ny nz kv dk translated">command(state，payload)= &gt; { newState:derived state，events: [events] }</p></blockquote><h2 id="743a" class="of le iq bd lf og oh dn lj oi oj dp ln kj ok ol lr kn om on lv kr oo op lz oq bi translated">如何保持状态/事件</h2><p id="6087" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">目前，我们还没有为写端引入任何持久化。有几种方法可以做到这一点。</p><ul class=""><li id="f675" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">Eventsourcing (ES):存储所有事件并从事件流中创建投影</li><li id="9027" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">使用(关系)数据库并更新提交中的预测/模型</li></ul><p id="3c36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你的系统每秒写入次数很少(低于100次)时，你真的不应该考虑用<strong class="ka ir">事件源</strong>来存储事件。也许只是出于法律原因，你应该调查一下；否则，它将引入许多新的挑战，例如事件排序和预测的最终一致性。此外，对事件进行版本控制很困难，您需要特定的基础设施来处理它。</p><blockquote class="nq"><p id="243b" class="nr ns iq bd nt nu nv nw nx ny nz kv dk translated">我强烈建议您不要在系统每秒写入次数很低的时候使用事件源，尤其是在域和事件负载未知或不稳定的时候。</p></blockquote><p id="68a9" class="pw-post-body-paragraph jy jz iq ka b kb oa kd ke kf ob kh ki kj oc kl km kn od kp kq kr oe kt ku kv ij bi translated">但是，您可以出于审计目的自由使用事件，但要避免进行预测。</p><h2 id="db78" class="of le iq bd lf og or dn lj oi os dp ln kj ot ol lr kn ou on lv kr ov op lz oq bi translated">使用关系数据库</h2><p id="3bae" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">至于阅读方面，我们将再次尝试。我们将应用与commandHandlers相同的“映射”方法，但是输入和输出是不同的:</p><blockquote class="nq"><p id="de79" class="nr ns iq bd nt nu nv nw nx ny nz kv dk translated">SQL mapper(event)= &gt;[查询]</p></blockquote><p id="eeb4" class="pw-post-body-paragraph jy jz iq ka b kb oa kd ke kf ob kh ki kj oc kl km kn od kp kq kr oe kt ku kv ij bi translated">类型安全代码:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="606d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能想知道为什么我们返回一个<em class="np">查询</em>对象的数组，那是因为这是<strong class="ka ir">引入副作用或者更新将在事务中运行的读取</strong>的投影的好地方。此外，我们可以使用额外查询来确保跨业务逻辑的一致性，稍后将详细介绍。</p><p id="1a69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的控制器看起来会像这样(我只是为这个想法实现了2):</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d69c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">使业务规则在并发请求中保持一致</strong></p><p id="13fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在当前的实现中，有一个主要问题。当同时调用payPaymentController时，可能会两次完成订单，从而两次发出事件。当将来我们将引入副作用/工作时，如邮寄给我们的客户或运送产品，这尤其糟糕。DDD说，我们应该把保持一致状态的实体分裂成聚合根。然而，这个原则需要对领域有很好的了解(这通常是缺乏的)。在我看来，我们可以确保与其他技术的一致性，基于每个事件。我们可以使用数据库约束来避免每个事件的版本属性的一致性问题。想法如下。当我们有一个应该一致的模型时，我们将在模型上引入一个版本号。对于影响模型的每个事件，我们将版本增加1。当我们提交数据库时，我们通过使约束无效来确保数据库中不存在该模型的更高版本。我们正在使用乐观锁定，它的优点是性能更好，而不是使用其他锁定机制。如果数据库事务抛出错误，我们只需重试整个<code class="fe nl nm nn no b">payPaymentController</code>函数或中止整个请求(最终用户需要重新提交)</p><p id="8905" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何实施:</p><ul class=""><li id="3b89" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">首先，我们在数据库表的<code class="fe nl nm nn no b">version</code>列上定义一个约束:<code class="fe nl nm nn no b">version ≥ 0</code></li><li id="f36a" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">其次，我们为特定事件向sql映射器添加一个额外的查询:</li></ul><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="eb00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保一致性查询优先于更新查询是很重要的。</p><p id="3ec5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了提高性能，可以在<code class="fe nl nm nn no b">id + version</code>列上添加一个索引，以加快更新速度。</p><p id="3e1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，理解我们应该在我们的控制器/解析器中只产生一个副作用(可以与许多提交一致)是很重要的。</p><p id="623c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建带有控制器/解析器的NodeJS服务器，有许多库，如ExpressJS和FastifyJS。这里就不讨论这些库/框架了。但是，您应该考虑一下哪些是水平扩展的(大多数都是这样)。</p><h1 id="ca99" class="ld le iq bd lf lg mq li lj lk mr lm ln lo ms lq lr ls mt lu lv lw mu ly lz ma bi translated">摘要</h1><p id="70b3" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我们有一个基本的、可测试的、类型安全的服务实现。这取决于Postgres实例的速度，可以扩展很多。这是因为我们在设计中避免使用表锁和行锁，而是使用乐观锁和优化读取。<strong class="ka ir">在下一部分，我们将讨论如何以一致的方式添加额外的功能，如电子邮件作业、空闲通知和任何其他副作用。</strong>我们还将把服务分成两个独立的微服务。</p><p id="36ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编辑:后续文章<a class="ae mp" href="https://medium.com/itnext/how-to-create-simple-and-scalable-event-driven-nodejs-services-14e9dee75a74" rel="noopener">https://medium . com/it next/how-to-create-simple-and-scalable-event-driven-nodejs-services-14e 9 dee 75 a 74</a></p><p id="d5f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>