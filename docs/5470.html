<html>
<head>
<title>Blazor: switching Server and WebAssembly at runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Blazor:在运行时切换服务器和WebAssembly</h1>
<blockquote>原文：<a href="https://itnext.io/blazor-switching-server-and-webassembly-at-runtime-d65c25fd4d8?source=collection_archive---------1-----------------------#2021-03-14">https://itnext.io/blazor-switching-server-and-webassembly-at-runtime-d65c25fd4d8?source=collection_archive---------1-----------------------#2021-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2c216012e7bc2ced9ddb13cfc5cde04f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-ibhFirQk3nFhEOFUINvA.png"/></div></div></figure><p id="a0ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ASP。NET Core Blazor是一个web框架，设计用于在基于WebAssembly的浏览器中运行客户端<em class="kw">。NET运行时(Blazor WebAssembly)或者ASP.NET核心的<em class="kw">服务器端</em>(Blazor Server)，但是这两种模式<a class="ae kx" href="https://github.com/dotnet/aspnetcore/issues/17678" rel="noopener ugc nofollow" target="_blank">不能同时使用</a>。关于托管模型的更多信息可以在文档中找到<a class="ae kx" href="https://docs.microsoft.com/ru-ru/aspnet/core/blazor/hosting-models?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">。</a></em></p><p id="b12c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文描述了如何</p><ul class=""><li id="7b1a" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">在一个应用程序中同时运行Server和WebAssembly，</li><li id="f5fe" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">在运行时从服务器切换到WebAssembly，无需重新加载应用程序，</li><li id="5f83" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">实现通用基于Cookie的认证机制，</li><li id="6665" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">使用gRPC同步服务器和WebAssembly状态。</li></ul><p id="3e5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TL；博士:</p><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lm"><img src="../Images/6046ee9dc2114819fe100047a99c2a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xJk4b-WLZvUu7WFY.gif"/></div></div></figure><p id="fc9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://github.com/jdtcn/HybridBlazor" rel="noopener ugc nofollow" target="_blank">代码可在GitHub上获得。</a></p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="1590" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">简介:为什么我们需要它</h1><p id="9db7" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">两种托管模式各有利弊:</p><p id="6cbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Blazor服务器优点:</p><ul class=""><li id="d67b" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">下载的资源较小(约250 KB)。</li><li id="dfdc" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">快速加载。</li><li id="6cca" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">响应式用户界面。</li></ul><p id="2dfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Blazor服务器缺点:</p><ul class=""><li id="9155" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">由于DOM的更改是在服务器上计算的，所以一个响应迅速的UI需要可靠而快速地连接到服务器。</li><li id="7de8" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">如果连接中断，浏览器中的应用程序将停止工作。</li><li id="3c1c" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">如果服务器重新启动，浏览器应用程序将停止工作，界面状态将丢失。</li><li id="6425" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">难以扩展，因为客户端只能与存储其状态的服务器一起工作。</li></ul><p id="e20f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Blazor WebAssembly优点:</p><ul class=""><li id="b2b2" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">Blazor Server没有缺点，因为该应用程序在浏览器中离线运行。比如可以离线工作，或者做PWA。</li></ul><p id="3c67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Blazor WebAssembly缺点:</p><ul class=""><li id="ea3d" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">不体面的大尺寸:10-15mb。</li><li id="ede5" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">由于这种大小，从链接到界面出现(第一次启动)可能需要15-20秒，这在现代世界已经是不可接受的了。</li></ul><p id="4cbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的是，预渲染对于两种主机模型都是可用的，它极大地提高了响应能力，我们将使用它。但是，即使启用了WebAssembly的预渲染，界面也将长时间保持无响应，第一次启动时为15-20秒，重复启动时为5-10秒。</p><p id="dd0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了结合服务器和WebAssembly的优点，我有了实现混合操作模式的想法:应用程序应该在服务器模式下运行，然后在用户不注意的情况下进入WebAssembly模式，例如，当在页面之间导航时。</p><p id="5ae4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我将告诉你我是如何实现的。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="6bff" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">第1部分:同时运行服务器和WebAssembly</h1><p id="2337" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">我们需要从<a class="ae kx" href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/prerendering-and-integration?view=aspnetcore-5.0&amp;pivots=webassembly" rel="noopener ugc nofollow" target="_blank">在ASP.NET核心应用程序中托管</a> WebAssembly应用程序开始，然后启用预渲染。</p><p id="1c3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这个配置，Blazor在文件<code class="fe nb nc nd ne b"><a class="ae kx" href="https://github.com/jdtcn/HybridBlazor/blob/main/HybridBlazor/Server/Pages/_Host.cshtml" rel="noopener ugc nofollow" target="_blank">_Host.cshtml</a></code>中启动，向页面添加一个组件<a class="ae kx" href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/component-tag-helper?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">来创建我们的应用程序的DOM </a>，并下载使我们的应用程序具有交互性的脚本。</p><p id="a1e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于服务器，它看起来像这样:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="45be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这样的WebAssembly:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="91b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，没有什么可以阻止我们同时加载它们:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="803b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这当然行不通。重点是<code class="fe nb nc nd ne b">&lt;component&gt;</code>标签变成了这样的html:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2658" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在应用程序初始化期间，Blazor会查找这个片段，然后用应用程序的DOM替换它。如果脚本<code class="fe nb nc nd ne b">blazor.server.js</code>和<code class="fe nb nc nd ne b">blazor.webassembly.js</code>同时运行，它们将竞争第一个组件，忽略第二个组件。</p><p id="28a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们只在<code class="fe nb nc nd ne b">blazor.server.js</code>结束后才开始运行<code class="fe nb nc nd ne b">blazor.webassembly.js</code>，这很容易避免，就像这样:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="068b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在这两个应用程序都启动了，但是不能正常工作。问题是两个应用程序都订阅事件(点击、提交、onpush等。)在<code class="fe nb nc nd ne b">document</code>和<code class="fe nb nc nd ne b">window</code>上。因此，Server和WebAssembly会尝试处理彼此的事件。</p><p id="4f72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只想让它们监听它们的<code class="fe nb nc nd ne b">&lt;srvr-app&gt;</code>和<code class="fe nb nc nd ne b">&lt;wasm-app&gt;</code>节点中的事件。要做到这一点，我们将不得不打破js最佳实践，并为窗口和文档覆盖<code class="fe nb nc nd ne b">addEventListener</code>:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="43b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两个应用程序现在都可以工作了。剩下的就是等待WebAssembly加载，并通过隐藏<code class="fe nb nc nd ne b">&lt;srvr-app&gt;</code>和显示<code class="fe nb nc nd ne b">&lt;wasm-app&gt;</code>来启用它:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="09ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将这个逻辑放在文件<code class="fe nb nc nd ne b"><a class="ae kx" href="https://github.com/jdtcn/HybridBlazor/blob/main/HybridBlazor/Client/wwwroot/blazor.hybrid.js" rel="noopener ugc nofollow" target="_blank">blazor.hybrid.js</a></code>中，并将其连接到<code class="fe nb nc nd ne b">_Host.cshtml</code>而不是前两个脚本。在同一个文件中，我们将放置一个函数，该函数将根据来自应用程序的信号切换放置模型。我们将从应用程序的c#代码中调用它。</p><p id="f3ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从c#应用程序的角度，让我们创建一个<code class="fe nb nc nd ne b"><a class="ae kx" href="https://github.com/jdtcn/HybridBlazor/blob/main/HybridBlazor/Client/Shared/RuntimeHeader.razor" rel="noopener ugc nofollow" target="_blank">RuntimeHeader.razor</a></code>组件，其内容如下:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1da5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样，混合应用程序正在工作。还需要增加一些便利，例如，可以在<code class="fe nb nc nd ne b">appsettings.json</code>中设置运行应用的类型</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="74bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nb nc nd ne b">HybridType</code>在哪里</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="f590" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">第2部分:身份验证</h1><p id="a1b7" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">为了同时使用Server和WebAssembly，我们需要创建一个适用于这两种模型的身份验证机制。</p><p id="4159" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于服务器端和客户端位于同一个应用程序中，Cookie身份验证对我们来说很好。</p><p id="d4a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们像往常一样配置<code class="fe nb nc nd ne b"><a class="ae kx" href="https://github.com/jdtcn/HybridBlazor/blob/main/HybridBlazor/Server/Startup.cs" rel="noopener ugc nofollow" target="_blank">Startup.cs</a></code>使用Cookie认证<a class="ae kx" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="b085" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题仍然有待解决:当Blazor服务器执行应用程序的客户端代码(通过HTTP调用API)时，它将在其进程中使用HttpClient。这意味着为了授权机制能够工作，我们需要向这个HttpClient实例添加客户机cookies。让我们配置依赖注入，以便它为Blazor服务器创建正确的HttpClient:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e599" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Blazor服务器在进程中对自己的API请求现在将被授权。</p><p id="01f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在Blazor Server中，我们不能使用Set-Cookie HTTP头，因为它会为我们内部的HttpClient设置Cookie。因此，对于Blazor Server和Blazor WebAssembly，我们将创建<code class="fe nb nc nd ne b">IAuthService</code>接口的不同实现，以强制Blazor Server为客户端浏览器设置cookie。</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9cf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于WebAssembly <code class="fe nb nc nd ne b"><a class="ae kx" href="https://github.com/jdtcn/HybridBlazor/blob/main/HybridBlazor/Client/WasmAuthService.cs" rel="noopener ugc nofollow" target="_blank">WasmAuthService.cs</a></code>和服务器<code class="fe nb nc nd ne b"><a class="ae kx" href="https://github.com/jdtcn/HybridBlazor/blob/main/HybridBlazor/Server/Services/ServerAuthService.cs" rel="noopener ugc nofollow" target="_blank">ServerAuthService.cs</a></code>。</p><p id="3031" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在有了一个身份验证机制，可以同时用于Blazor服务器和Blazor WebAssembly。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="0f3a" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">第3部分:同步服务器和WebAssembly状态</h1><p id="e2cc" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">这是一项艰巨的任务。如果我们限制自己在导航时将服务器切换到WebAssembly，我们可以跳过解决它。</p><p id="34db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们不会寻找简单的方法，我们将使用gRPC流同步组件<code class="fe nb nc nd ne b"><a class="ae kx" href="https://github.com/jdtcn/HybridBlazor/blob/main/HybridBlazor/Client/Pages/Counter.razor" rel="noopener ugc nofollow" target="_blank">Counter.razor</a></code>的状态。</p><p id="bf4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，让我们创建一个gRPC服务。</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="dd00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并在<code class="fe nb nc nd ne b"><a class="ae kx" href="https://github.com/jdtcn/HybridBlazor/blob/main/HybridBlazor/Server/Services/CounterService.cs" rel="noopener ugc nofollow" target="_blank">CounterService.cs</a></code>中实现。</p><p id="f294" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看我们的应用程序是如何静态类型化的，在客户端的<code class="fe nb nc nd ne b">Counter.razor</code>中，我们创建了一个<code class="fe nb nc nd ne b">ICounterService</code>的实例:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="7693" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在后端，我们看到了使用<code class="fe nb nc nd ne b">SubscribeAsync</code>方法的地方:</p><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/14ac12d836481a929c9e10ec3ff66f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KWcwoPTklS0nyQZ_.png"/></div></div></figure><p id="6944" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以通过<a class="ae kx" href="https://github.com/protobuf-net/protobuf-net.Grpc" rel="noopener ugc nofollow" target="_blank"> protobuf-net实现。Grpc </a>库，它允许我们在创建Grpc服务时使用代码优先的方法，而不是编写*。手动创建原型文件。</p><p id="27fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们配置依赖注入来创建gRPC服务的实例:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="28bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的DI可以创建gRPC服务了。gRPC服务中的授权检查是使用<code class="fe nb nc nd ne b">[Authorize]</code>属性执行的，就像常规的ASP.NET核心控制器一样。在这个应用程序中，服务<code class="fe nb nc nd ne b"><a class="ae kx" href="https://github.com/jdtcn/HybridBlazor/blob/main/HybridBlazor/Server/Services/WeatherForecastService.cs" rel="noopener ugc nofollow" target="_blank">WeatherForecastService</a></code>用这个属性标记。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="b2b3" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">结果</h1><p id="5226" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">事实证明，制作一个混合ASP.NET核心Blazor应用程序并不困难。该应用程序可以托管在Kestrel、IIS (IIS仅支持HTTPS)和Docker(使用Kestrel)中。</p><p id="4a08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果项目<a class="ae kx" href="https://github.com/jdtcn/HybridBlazor" rel="noopener ugc nofollow" target="_blank">可以在GitHub </a>上获得。</p><p id="cdb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我还为docker发布了一张图片:</p><pre class="ln lo lp lq gt ni ne nj nk aw nl bi"><span id="ef47" class="nm lz iq ne b gy nn no l np nq">&gt; docker run --rm -p 80:80/tcp jdtcn/hybridblazorserver:latest</span></pre><p id="8d6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在任何模式下运行容器中的应用程序:</p><pre class="ln lo lp lq gt ni ne nj nk aw nl bi"><span id="7878" class="nm lz iq ne b gy nn no l np nq">&gt; docker run --rm -p 80:80/tcp jdtcn/hybridblazorserver:latest -e HybridType=HybridManual</span></pre><p id="56bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用<code class="fe nb nc nd ne b">demo</code>用户名和密码登录。</p><p id="7261" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">新的Blazor框架给了c#开发者无限的想象空间。</p><p id="a2f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">试试吧，实验！</p></div></div>    
</body>
</html>