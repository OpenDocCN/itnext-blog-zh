<html>
<head>
<title>Visualizing Python modules and dependencies with Neo4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Neo4j可视化Python模块和依赖关系</h1>
<blockquote>原文：<a href="https://itnext.io/visualizing-python-modules-and-dependencies-with-neo4j-d90cd86c1f3f?source=collection_archive---------3-----------------------#2021-08-18">https://itnext.io/visualizing-python-modules-and-dependencies-with-neo4j-d90cd86c1f3f?source=collection_archive---------3-----------------------#2021-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/06e3e2c230f4683695563f1ff5c99a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/0*kKOJ006QrlRQmF3M.png"/></div></figure><p id="3df8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我从<a class="ae ks" href="http://blog.adnansiddiqi.me/tag/blockchain-programming/" rel="noopener ugc nofollow" target="_blank">区块链编程</a>系列中抽出一点时间写这篇文章，因为我发现它非常有趣。</p><p id="fbeb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">前几天，我发现了一条关于在Neo4J中可视化python模块的推文(<em class="kt">，不幸的是，我忘了加书签，再也找不到了</em>)。Python开发者Guido 回复了这条微博。那条推文留在了我的脑海里，我认为这是一个探索Neo4j的绝佳借口。除了Neo4j，我一直在考虑探索一些图形数据库。出于一些奇怪的原因，我已经忽略Neo4j很长一段时间了，很可能是因为我根本不喜欢的<em class="kt"> Java </em>这个东西。我试过Arangodb，但它是GUI，但不知何故，它的GUI不够流畅。无论如何，在我继续之前，这是它看起来的样子:</p><figure class="ku kv kw kx gt jr"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="caa1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以说这个演示是<code class="fe la lb lc ld b">pip show</code>命令的剥离版。</p><p id="be4b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在开始实际工作之前，让我们简单讨论一下Neo4j和图形数据库。</p><h1 id="2a20" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是图形数据库</h1><p id="4c5e" class="pw-post-body-paragraph ju jv iq jw b jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr ij bi translated">根据<a class="ae ks" href="https://en.wikipedia.org/wiki/Graph_database" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="mh mi mj"><p id="7452" class="ju jv kt jw b jx jy jz ka kb kc kd ke mk kg kh ki ml kk kl km mm ko kp kq kr ij bi translated">..图形数据库(GDB)是一种使用图形结构进行语义查询的数据库，具有节点、边和属性来表示和存储数据。[1]该系统的一个关键概念是图(或边或关系)。该图将存储中的数据项关联到节点和边的集合，边表示节点之间的关系。</p></blockquote><p id="b9e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://neo4j.com/developer/graph-database/" rel="noopener ugc nofollow" target="_blank"> Neo4j </a>将其定义为:</p><blockquote class="mh mi mj"><p id="f58c" class="ju jv kt jw b jx jy jz ka kb kc kd ke mk kg kh ki ml kk kl km mm ko kp kq kr ij bi translated">简单地说，图数据库是一种被设计成将数据之间的关系视为与数据本身同等重要的数据库。它旨在保存数据，而不是将其限制在预定义的模型中。相反，数据的存储就像我们第一次提取数据一样——显示每个单独的实体如何与其他实体连接或相关。</p></blockquote><p id="5e43" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">基本上，图形数据库是关于数据及其关系的。图形数据库基于<a class="ae ks" href="https://en.wikipedia.org/wiki/Category:Graph_algorithms" rel="noopener ugc nofollow" target="_blank">图形算法</a>，图形算法本身基于<a class="ae ks" href="https://en.wikipedia.org/wiki/Graph_theory" rel="noopener ugc nofollow" target="_blank">图论</a>。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/8aaae56576bb1fe2cf1727e8e64e16a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tn1yD_ok5KJ4Z8ia.jpg"/></div></div></figure><h1 id="2f92" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么选择图形数据库</h1><p id="1e4d" class="pw-post-body-paragraph ju jv iq jw b jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr ij bi translated">可能有几个原因，但其中一些是:</p><ul class=""><li id="25a1" class="ms mt iq jw b jx jy kb kc kf mu kj mv kn mw kr mx my mz na bi translated"><strong class="jw ir">连通性:- </strong>在RDBMS中，通常将数据存储在表中。通常情况下，您不需要关系，数据存储为单个实体。例如国家列表等。如果你的项目不需要太多的关系，那么图形数据库是没有用的。在我的例子中，同样的事情也可以在RDBMS中完成，但在图形数据库中效率更高，因为所有需要的信息都可以在节点级获得，只需要获取节点之间的关系。</li><li id="2663" class="ms mt iq jw b jx nb kb nc kf nd kj ne kn nf kr mx my mz na bi translated"><strong class="jw ir">更改频率:- </strong>在RDBMS世界中，如果您想添加一条新信息，您必须更改表以添加一列。在图形数据库中情况并非如此，因为信息是以属性的形式添加的。</li></ul><p id="9257" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在网上进一步了解它。让我们继续前进，设置我们的开发环境。我用的是docker版本。</p><h1 id="c330" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">开发设置</h1><p id="49a7" class="pw-post-body-paragraph ju jv iq jw b jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr ij bi translated">启动Docker，执行命令<code class="fe la lb lc ld b">docker pull neo4j</code>拉Neo4j docker镜像。</p><p id="5a9f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要运行它，请执行以下命令:</p><p id="10dd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe la lb lc ld b">docker run --publish=7474:7474 --publish=7687:7687 --volume=$HOME/neo4j/data:/data neo4j</code></p><p id="4a5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您将看到类似下面的内容:</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ng"><img src="../Images/9026e76519054bc013c7cda0106eaeff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cdhqtu1ZEmIyFRZz.png"/></div></div></figure><p id="e957" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当你访问<code class="fe la lb lc ld b">d</code>时，它显示如下:</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ng"><img src="../Images/2c5d45da194b5940f0e41c5a34d2210d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TQcektHJ5IulLyRP.png"/></div></div></figure><p id="9fe5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Neo4j使用<a class="ae ks" href="https://neo4j.com/developer/cypher/" rel="noopener ugc nofollow" target="_blank">密码查询语言</a> e进行不同的操作。让我们讨论几个密码查询</p><h1 id="4055" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建节点</h1><p id="81b7" class="pw-post-body-paragraph ju jv iq jw b jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr ij bi translated">为了创建某种类型的节点，您将执行以下命令:</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nh"><img src="../Images/05ff98440c8bf6336130485bb4b3900f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-VDptatHOz1UerTX.png"/></div></div></figure><p id="cf17" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里创建了一个类型为<code class="fe la lb lc ld b">Module</code>的节点，其属性为<code class="fe la lb lc ld b">name</code>。我最初使用这个查询，但是我想确保所有的节点都是惟一的，如果存在就不要创建，所以我使用了这个查询</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ni"><img src="../Images/19ffa3fc57639516832fc15707ef418e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ETZlE4y1TaNJRy1l.png"/></div></div></figure><h1 id="e4fd" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建节点之间的关系</h1><p id="c86b" class="pw-post-body-paragraph ju jv iq jw b jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr ij bi translated">创建节点之间的关系也不难。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ng"><img src="../Images/2fbbda0f5ab78a9e03f8cca348b0d236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CWhtkdvTG6L1fXgP.png"/></div></div></figure><p id="c881" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该查询基于<code class="fe la lb lc ld b">name</code>属性匹配几个节点，如果找到，它将创建一个带有标签<code class="fe la lb lc ld b">USED_BY</code>的方向关系。<code class="fe la lb lc ld b">-&gt;</code>用于告知关系从<code class="fe la lb lc ld b">a</code>到<code class="fe la lb lc ld b">b</code>开始。</p><h1 id="7c86" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Neo4j Python集成</h1><p id="2f0f" class="pw-post-body-paragraph ju jv iq jw b jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr ij bi translated">好了，我们知道创建节点和关系需要哪些查询。我们的目的是通过Python与neo4j进行通信。为此，我使用neo4j <a class="ae ks" href="https://github.com/neo4j/neo4j-python-driver" rel="noopener ugc nofollow" target="_blank"> Python驱动程序</a>。</p><p id="ca3c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们需要我的机器上安装的所有模块的列表</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ng"><img src="../Images/45cda97ffcaac817f94303be9b1b32c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k-0SHtxdl1GJrlQH.png"/></div></div></figure><p id="1955" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我导入了<code class="fe la lb lc ld b">pkg_resources</code>来获取所有安装的模块。接下来，我需要获取单个已安装模块的信息。为此，我将使用<code class="fe la lb lc ld b">pip show &lt;module_name&gt;</code>命令。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ng"><img src="../Images/3d994552d104d3340b5849d939e13411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ltCLle8XAahMf2La.png"/></div></div></figure><p id="55c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe la lb lc ld b">__main__</code>函数现在看起来如下:</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ng"><img src="../Images/ecd9b568b9dd9956960f283ea0b779bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HsJ4eQivYn8_1sL6.png"/></div></div></figure><p id="753e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在是可视化节点的时候了。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/072aae1ca66619d788ec4e958fb44cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*kdc_cNJnYGuTAHVB.gif"/></div></figure><p id="be8e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里，我将著名的<em class="kt">请求</em>库进行HTTP。看起来很美，不是吗？</p><h1 id="a168" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="a105" class="pw-post-body-paragraph ju jv iq jw b jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr ij bi translated">在本文中，您了解了在neo4j图形数据库中获取数据并可视化实体之间的关系是多么容易。我已经介绍了neo4j的要点。您应该进一步探索优化的搜索查询，并在您的应用程序中使用返回的结果。像往常一样，代码可以在<a class="ae ks" href="https://github.com/kadnan/Neo4jPythonModulesVisualization" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="c939" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="kt">原载于2021年8月18日</em><a class="ae ks" href="http://blog.adnansiddiqi.me/visualizing-python-modules-and-dependencies-with-neo4j/" rel="noopener ugc nofollow" target="_blank"><em class="kt">http://blog . adnansiddiqi . me</em></a><em class="kt">。</em></p></div></div>    
</body>
</html>