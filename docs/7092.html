<html>
<head>
<title>Merge JavaScript Objects in an Array with Different Defined Properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并具有不同定义属性的数组中的JavaScript对象</h1>
<blockquote>原文：<a href="https://itnext.io/merge-javascript-objects-in-an-array-with-different-defined-properties-5c1e2c3ca634?source=collection_archive---------1-----------------------#2022-06-09">https://itnext.io/merge-javascript-objects-in-an-array-with-different-defined-properties-5c1e2c3ca634?source=collection_archive---------1-----------------------#2022-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cd0a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Array.reduce()是组合共享一个键但不一定是属性的对象的解决方案。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/59d1830ea2a87154c9fce04ab3499e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*lgPMacUZzZHA_IC_.jpg"/></div></figure><h1 id="7f74" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">介绍</h1><p id="ad7d" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在最近的工作中，我遇到了一个有趣的问题:我需要根据匹配的键将多个JavaScript对象合并到一个数组中。</p><p id="b102" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">起初，这听起来相对简单，但是还有更多故事阻止我使用<a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir">扩展操作符</strong> </a>或<code class="fe mh mi mj mk b"><a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir">Object.assign()</strong></a></code>来组合这些对象。</p><ol class=""><li id="b6f1" class="ml mm iq lh b li mb ll mc lo mn ls mo lw mp ma mq mr ms mt bi translated">这些对象<em class="mu">中的每一个都可能</em>共享一个公共密钥——这是没有保证的，并且</li><li id="266a" class="ml mm iq lh b li mv ll mw lo mx ls my lw mz ma mq mr ms mt bi translated">尽管它们在每个对象中都有相同的属性，但并不是所有这些属性都在每个对象中定义——对象可以有<code class="fe mh mi mj mk b">property: value</code>或<code class="fe mh mi mj mk b">property: undefined</code>。</li></ol><p id="55b9" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我需要将共享一个公共键的对象的所有属性以及它们的定义值组合成一个新的单个对象。为了让它更难一点，我需要它在打字稿中工作。😅</p><p id="cf5f" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">所以今天，我将向您展示如何使用JavaScript的</strong> <code class="fe mh mi mj mk b"><strong class="lh ir">reduce()</strong></code> <strong class="lh ir">函数合并一个数组中两个(或更多)具有不同定义属性的对象。</strong></p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="2cda" class="kn ko iq bd kp kq nh ks kt ku ni kw kx jw nj jx kz jz nk ka lb kc nl kd ld le bi translated">背景:<code class="fe mh mi mj mk b">motion.qo</code>和<code class="fe mh mi mj mk b">air.qo</code>事件</h1><p id="8994" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于那些对这种事情在现实生活中什么时候出现感到好奇的人，这里有一些关于我的情况的背景。</p><p id="4842" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我在一家名为<a class="ae mg" href="https://blues.io/?&amp;utm_source=medium&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=merge-js-objects" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir">蓝调无线</strong> </a>的物联网(IoT)初创公司担任软件工程师。我们的主要使命是让物联网开发变得更简单，不管是否有可靠的互联网连接。Blues通过<a class="ae mg" href="https://blues.io/products/notecard/?&amp;utm_source=medium&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=merge-js-objects" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir">note cards</strong></a><strong class="lh ir"/>实现这一点——可以嵌入任何“边缘”物联网设备的预付费蜂窝设备，以JSON的形式将传感器数据传输到安全云:<a class="ae mg" href="https://blues.io/products/notehub/?&amp;utm_source=medium&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=merge-js-objects" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir"> Notehub </strong> </a>。</p><p id="90b2" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">除了生产这种硬件并提供安全的云连接来发送物联网数据，我们还构建了软件应用程序，用户可以将他们的设备连接到这些应用程序，并以图表和图形的形式查看传感器数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/2934c207cfe7983ec3decc86b47c6026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*XmYVpeiqbHIBRNy2.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">以下是显示各种传感器数据的图表示例。</figcaption></figure><p id="1777" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们正在构建的一个web应用程序涉及报告两种类型数据的传感器:</p><ul class=""><li id="79d3" class="ml mm iq lh b li mb ll mc lo mn ls mo lw mp ma nq mr ms mt bi translated"><strong class="lh ir">空气质量</strong>温度、湿度、传感器电压和压力等读数，以及</li><li id="1bf5" class="ml mm iq lh b li mv ll mw lo mx ls my lw mz ma nq mr ms mt bi translated"><strong class="lh ir">运动</strong>读数，如当前检测到的运动计数和一段时间内检测到的运动总数。</li></ul><p id="557c" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">因此，单个传感器生成两个不同的JSON有效载荷，从Notecard发送到Notehub，然后Notehub将它们路由到我们的web应用程序，以在图表中呈现。</p><p id="d504" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">下面是一些交付给应用程序的事件的示例。</p><p id="a71b" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">传感器事件示例</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/99424d46b0b5fe7b5bd5b82897ed5109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*oazKklV4nteKh3M1MiPjBQ.png"/></div></figure><p id="dbd3" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">如您所见，数组中的前两个对象共享同一个<code class="fe mh mi mj mk b">abc</code>的<code class="fe mh mi mj mk b">sensorId</code>，但是它们有不同的定义属性。</p><p id="ca15" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">第一个对象有<code class="fe mh mi mj mk b">motion</code>属性(和未定义的<code class="fe mh mi mj mk b">air quality</code>属性)，第二个对象有定义的<code class="fe mh mi mj mk b">air quality</code>属性(和未定义的<code class="fe mh mi mj mk b">motion</code>属性)，第三个对象有完全不同的<code class="fe mh mi mj mk b">sensorId</code>；这是来自另一个传感器的<code class="fe mh mi mj mk b">motion</code>读数。</p><p id="5340" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这让我想到了我的问题:如何组合具有相同<code class="fe mh mi mj mk b">sensorId</code> <em class="mu">和</em>的对象，并从每个对象中获取所有已定义的属性。</p><p id="de42" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">所以，让我们开始吧。</p><h2 id="5ff0" class="ns ko iq bd kp nt nu dn kt nv nw dp kx lo nx ny kz ls nz oa lb lw ob oc ld od bi translated">用<code class="fe mh mi mj mk b">mergeObject()</code>函数和<code class="fe mh mi mj mk b">reduce()</code>合并相似的对象</h2><p id="29cf" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">鉴于我在这篇文章中多次提到“合并”和“组合”，你可能已经想到JavaScript数组函数<code class="fe mh mi mj mk b"><a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir">reduce()</strong></a></code>可能会在这里发挥作用，而且确实如此。</p><p id="121f" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最基本的是，<code class="fe mh mi mj mk b">reduce()</code>遍历<strong class="lh ir">数组中的每个元素</strong>，并将其添加到其前面所有值的<strong class="lh ir">累加器</strong>中，直到最后只返回一个值。同样的事情可以用一组对象来完成，只需要多一点逻辑。</p><blockquote class="oe of og"><p id="c4b9" class="lf lg mu lh b li mb jr lk ll mc ju ln oh md lq lr oi me lu lv oj mf ly lz ma ij bi translated"><em class="iq">如果你想对</em> <code class="fe mh mi mj mk b"><em class="iq">reduce()</em></code> <em class="iq">有更透彻的解释，我鼓励你查阅一下</em> <a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Mozilla文档</em> </a> <em class="iq">。</em></p><p id="2146" class="lf lg mu lh b li mb jr lk ll mc ju ln oh md lq lr oi me lu lv oj mf ly lz ma ij bi translated">他们的例子很棒，我仍然定期访问它，讨论各种话题。</p></blockquote><p id="aff7" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">下面是我想出的具有TypeScript风格的解决方案，它获取一个对象数组，找到共享一个公共键的对象，然后返回一个包含这些对象的新数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi ok"><img src="../Images/f37d639cb416c7b6b25d68462783dd52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WD1Vagy9-XsllJgqGCkh6Q.png"/></div></div></figure><p id="a842" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">好吧，我意识到上面有相当多的功能，所以有必要解释一下。</p><h2 id="9f27" class="ns ko iq bd kp nt nu dn kt nv nw dp kx lo nx ny kz ls nz oa lb lw ob oc ld od bi translated">HasSensorId</h2><p id="91d5" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe mh mi mj mk b">HasSensorId</code>接口非常直接:这意味着只要引用这个接口，对象的属性中就必须有一串<code class="fe mh mi mj mk b">sensorId</code>。</p><p id="e912" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">现在，让我们一个接一个地检查这些函数的其余部分。</p><h2 id="a67b" class="ns ko iq bd kp nt nu dn kt nv nw dp kx lo nx ny kz ls nz oa lb lw ob oc ld od bi translated">mergeObject()</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi op"><img src="../Images/3ca6180043c564894eed76114408605c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2JZbDGjz9KiGREt5OIxO3g.png"/></div></div></figure><p id="2c3a" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这个<code class="fe mh mi mj mk b">mergeObject()</code>函数实际上是合并对象的函数。</p><p id="aa9d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">该函数接受的<code class="fe mh mi mj mk b">A</code>和<code class="fe mh mi mj mk b">B</code>对象是具有共同<code class="fe mh mi mj mk b">sensorId</code>属性的两个对象，<code class="fe mh mi mj mk b">res</code>变量将是它们的属性(和值)组合后新返回的对象。</p><p id="8b9d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">发生的第一件事是使用<a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals" rel="noopener ugc nofollow" target="_blank">扩展操作符</a>将两个对象组合在一起，然后使用<code class="fe mh mi mj mk b"><a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank">Object.keys()</a></code>将它们的键提取到自己的数组中。如果您将样本<code class="fe mh mi mj mk b">sensorEvents</code>数组传递给这个函数，<code class="fe mh mi mj mk b">Object.keys()</code>数组将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi op"><img src="../Images/d27964f10ce6db23bd51b7ce834ea5af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bhibPzg8lrw-ylUOV5JAOw.png"/></div></div></figure><p id="5fd1" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">提取关键点后，每个关键点作为一个关键点添加到新的<code class="fe mh mi mj mk b">res</code>对象中，如果<code class="fe mh mi mj mk b">B</code>对象在该关键点的值存在(<code class="fe mh mi mj mk b">B[key]</code>，则作为<code class="fe mh mi mj mk b">res</code>对象的值添加，否则，添加<code class="fe mh mi mj mk b">A</code>对象的值(即使是<code class="fe mh mi mj mk b">undefined</code>)。</p><p id="3cc2" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最终返回的<code class="fe mh mi mj mk b">res</code>对象如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi op"><img src="../Images/2d711d3afe2d4749dd54085aa3ab4f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBUE81JEvrkExlFul54qxw.png"/></div></div></figure><p id="513a" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最后，<code class="fe mh mi mj mk b">V</code>和<code class="fe mh mi mj mk b">any</code>引用是TypeScript实现的一部分。通过查看剩余的代码，我们可以看到<code class="fe mh mi mj mk b">V</code>是<code class="fe mh mi mj mk b">HasSensorId</code>接口的扩展，这意味着任何事件对象都将<code class="fe mh mi mj mk b">sensorId</code>作为属性。而<code class="fe mh mi mj mk b">any</code>意味着传递给函数的对象可以有任何属性(或者没有)，所以很灵活。</p><p id="2425" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">好了，进入下一个功能！</p><h2 id="8aa7" class="ns ko iq bd kp nt nu dn kt nv nw dp kx lo nx ny kz ls nz oa lb lw ob oc ld od bi translated">减速器()</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/2d3a1b266c91026ccb484dc0a6cc1d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*FJqLSCTEK1Y3gt3JKSJuFg.png"/></div></figure><p id="8ed2" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><code class="fe mh mi mj mk b">reducer()</code>函数很好地利用了JavaScript中真正的<code class="fe mh mi mj mk b"><a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"><strong class="lh ir">Map</strong></a></code> <a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ir">对象</strong> </a> <strong class="lh ir"> </strong>。它还使用了<code class="fe mh mi mj mk b">HasSensorId</code>接口，确保每个对象都有一个<code class="fe mh mi mj mk b">sensorId</code>属性。</p><p id="9dfc" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">每个传递到函数中的<code class="fe mh mi mj mk b">event</code>对象，其<code class="fe mh mi mj mk b">sensorId</code>都变成了一个<code class="fe mh mi mj mk b">key</code>变量。<code class="fe mh mi mj mk b">previous</code>变量依赖于Map的<code class="fe mh mi mj mk b"><a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get" rel="noopener ugc nofollow" target="_blank">get()</a></code> <a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get" rel="noopener ugc nofollow" target="_blank">函数</a>来获取具有相同<code class="fe mh mi mj mk b">sensorId</code>键的任何其他Map对象，如果找到另一个对象，则在调用<code class="fe mh mi mj mk b">mergeObject()</code>函数时，新的<code class="fe mh mi mj mk b">event</code>将与它组合。如果没有匹配的<code class="fe mh mi mj mk b">previous</code>对象，一个空对象被传递给<code class="fe mh mi mj mk b">mergeObject()</code>，一个新的<code class="fe mh mi mj mk b">merged</code>变量仍然被返回。</p><p id="ff05" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最后，地图<code class="fe mh mi mj mk b"><a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set" rel="noopener ugc nofollow" target="_blank">set()</a></code> <a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set" rel="noopener ugc nofollow" target="_blank">函数</a>将<code class="fe mh mi mj mk b">key</code>和<code class="fe mh mi mj mk b">merged</code>变量添加到<code class="fe mh mi mj mk b">groups</code>地图对象中。</p><p id="772e" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">如果我们的三个<code class="fe mh mi mj mk b">sensorEvents</code>通过这个函数运行，最终出现的<code class="fe mh mi mj mk b">groups</code>对象看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi ok"><img src="../Images/7bedc159a226e94be9dd6de8ecef9d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkRrJ7pw9PlBCjOkv4cJqQ.png"/></div></div></figure><p id="fd96" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">所以我们继续这个代码示例的倒数第二部分，<code class="fe mh mi mj mk b">reducedEventsIterator</code>。</p><h2 id="0eca" class="ns ko iq bd kp nt nu dn kt nv nw dp kx lo nx ny kz ls nz oa lb lw ob oc ld od bi translated">reducedEventsIterator</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi op"><img src="../Images/f95a172d81e5de72b799771bbc1eaba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZs8lctlW2fcYoCYvVy2EQ.png"/></div></div></figure><p id="5e7f" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><code class="fe mh mi mj mk b">reducedEventsIterator</code>变量是我们在<code class="fe mh mi mj mk b">sensorEvents</code>数组上调用<code class="fe mh mi mj mk b">reduce()</code>的地方。<code class="fe mh mi mj mk b">reducer()</code>函数作为数组中每个事件必须运行的第一个参数被传递，一个新的<code class="fe mh mi mj mk b">Map()</code>对象作为累加器对象被传递，它们最终将被聚集在一起。</p><p id="a688" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在<code class="fe mh mi mj mk b"><a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Object/values" rel="noopener ugc nofollow" target="_blank">Object.values()</a></code>方法被链接到末尾之前，数组看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi ok"><img src="../Images/92f3be7651b9437e5d1f0e1e23c4e440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lz0NHeQl2rrRM5pbH4C2tw.png"/></div></div></figure><p id="397d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在调用了<code class="fe mh mi mj mk b">.values()</code>之后，最终的<code class="fe mh mi mj mk b">reducedEventsIterator</code>看起来更像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi ok"><img src="../Images/da971774c13e305b20052860945f80b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eunSqPYz_4Q0_NqXCTGFw.png"/></div></div></figure><p id="1814" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这就把我们带到了最后一步:将这个对象映射转换回一个正确的JavaScript对象数组(以及由此带来的所有好处——数组更容易操作)。</p><h2 id="c42c" class="ns ko iq bd kp nt nu dn kt nv nw dp kx lo nx ny kz ls nz oa lb lw ob oc ld od bi translated">最终合并的数组:reducedEvents</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi op"><img src="../Images/4a627515796f16a652b0a9ea095599b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voqvc5V3UFrBlmAP1im_8g.png"/></div></div></figure><p id="e1cb" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">可以说这是整个教程中最简单的部分，对象的映射只需通过将它传递给方法就可以转换回数组。</p><blockquote class="oe of og"><p id="8659" class="lf lg mu lh b li mb jr lk ll mc ju ln oh md lq lr oi me lu lv oj mf ly lz ma ij bi translated"><strong class="lh ir"> <em class="iq">谨防</em> </strong> <code class="fe mh mi mj mk b"><strong class="lh ir"><em class="iq">Array.from()</em></strong></code> <strong class="lh ir"> <em class="iq">用于复制深层对象</em> </strong></p><p id="71d1" class="lf lg mu lh b li mb jr lk ll mc ju ln oh md lq lr oi me lu lv oj mf ly lz ma ij bi translated"><em class="iq">如果你有需要复制的深度嵌套的对象，那么</em> <code class="fe mh mi mj mk b"><em class="iq">Array.from()</em></code> <em class="iq">可能不适合你。它只生成数组的浅拷贝实例。</em></p></blockquote><p id="3bad" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">因此，如果我们将上面显示的示例传感器事件传递到我们的<code class="fe mh mi mj mk b">reducedEventsIterator()</code>函数中，最终结果如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi ok"><img src="../Images/8efce73bfe0ad443975c0ae8e02f0240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMRUM9AA-mMd-Ys1vM6Uog.png"/></div></div></figure><p id="2608" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这样就有了:一个包含所有可用属性的新合并对象的数组。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="d9d5" class="kn ko iq bd kp kq nh ks kt ku ni kw kx jw nj jx kz jz nk ka lb kc nl kd ld le bi translated">结论</h1><p id="2ace" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我喜欢做软件工程师的一个原因是因为我可以定期解决所有有趣的问题。最近，当我构建一个web应用程序来显示来自工作中的物联网传感器的数据时，我遇到了一个更独特的问题:获取一系列传感器事件，如果它们属于同一个传感器，则将这些事件合并在一起。问题是，所有的事件都有相同的属性，但是根据您正在查看的事件，有一半的属性的值是<code class="fe mh mi mj mk b">undefined</code>。</p><p id="ff94" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">因此，我不能使用spread操作符或<code class="fe mh mi mj mk b">Object.assign()</code>将这些事件合并到一个对象中，而是必须更有创造性地使用一些额外的函数和<code class="fe mh mi mj mk b">reduce()</code>方法。但是它起作用了——即使混合了TypeScript。</p><p id="5243" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">过几周再来看看——我会写更多关于JavaScript、React、IoT或其他与web开发相关的东西。</p><p id="679a" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">如果你想确保你不会错过我写的一篇文章，在这里注册我的时事通讯:<a class="ae mg" href="https://paigeniedringhaus.substack.com" rel="noopener ugc nofollow" target="_blank">https://paigeniedringhaus.substack.com</a></p><p id="ae3e" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">感谢阅读。我希望这段JavaScript能在将来帮助你——谁能想到合并对象会如此有趣，对吗？</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="8307" class="kn ko iq bd kp kq nh ks kt ku ni kw kx jw nj jx kz jz nk ka lb kc nl kd ld le bi translated">参考资料和更多资源</h1><ul class=""><li id="371e" class="ml mm iq lh b li lj ll lm lo or ls os lw ot ma nq mr ms mt bi translated"><a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals" rel="noopener ugc nofollow" target="_blank">传播运算符</a> Mozilla文档</li><li id="ee19" class="ml mm iq lh b li mv ll mw lo mx ls my lw mz ma nq mr ms mt bi translated"><a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank">object . assign()</a>Mozilla docs</li><li id="f031" class="ml mm iq lh b li mv ll mw lo mx ls my lw mz ma nq mr ms mt bi translated"><a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">地图对象</a> Mozilla文档</li><li id="ab3e" class="ml mm iq lh b li mv ll mw lo mx ls my lw mz ma nq mr ms mt bi translated">蓝调无线<a class="ae mg" href="https://blues.io/?&amp;utm_source=medium&amp;utm_medium=web&amp;utm_campaign=sparrow-accelerator&amp;utm_content=merge-js-objects" rel="noopener ugc nofollow" target="_blank">网站</a></li><li id="d501" class="ml mm iq lh b li mv ll mw lo mx ls my lw mz ma nq mr ms mt bi translated">JavaScript数组方法<a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"> reduce() </a></li></ul></div></div>    
</body>
</html>