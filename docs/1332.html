<html>
<head>
<title>How to set Firebase security rules for your Flamelink project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为您的Flamelink项目设置Firebase安全规则</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-set-firebase-security-rules-for-your-flamelink-project-d855e8210198?source=collection_archive---------5-----------------------#2018-09-13">https://itnext.io/how-to-set-firebase-security-rules-for-your-flamelink-project-d855e8210198?source=collection_archive---------5-----------------------#2018-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c634905835deffb8e6df379fa259cf99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GP0t7I3CXbma7EHrkk08JA.jpeg"/></div></div></figure><p id="5ae5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以你终于准备好把你的Flamelink项目的训练轮子拿下来并投入使用了。在此之前，您是否已经为您的数据库设置了适当的规则？不，真的，你应该！</p><blockquote class="kw kx ky"><p id="2c36" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">如果这是你第一次听说Flamelink，一个Firebase的CMS，看看我们的<a class="ae ld" href="https://flamelink.io" rel="noopener ugc nofollow" target="_blank">网站</a>开始吧。将你的Firebase项目链接到Flamelink后，请回到这里阅读关于保护你的内容。</p></blockquote><h2 id="306c" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">编辑:请注意，本文讨论的是为Firebase实时数据库而不是云Firestore设置安全规则。CF将很快发布更多信息。</h2><p id="4de1" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">不久前，一个新的Firebase项目以<em class="kz">测试模式</em>发布，即。<em class="kz">读取</em>和<em class="kz">写入</em>对实时数据库上的任何人开放。从那时起，Firebase的优秀人员决定改变这一点，默认在<em class="kz">锁定模式</em>下没有读写权限。这样做是因为许多开发人员从不费心为他们在生产中运行的项目收紧安全规则，让他们的数据库对任何人开放。</p><p id="35e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当您的数据库处于锁定模式时，Flamelink无法工作，因为我们无法从您的浏览器读取/写入数据库。在锁定模式下访问数据库的唯一方法是从服务器环境访问，这需要通过服务帐户进行访问。在Flamelink，我们决定不走这条路，让您，最终用户，完全控制您的项目，以及您在晚上睡觉时给我们的访问级别。就我们所能提供的无缝用户体验而言，这是有代价的，将来我们可能会提供这两个选项，但我离题了。</p><p id="83d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了快速开始使用Flamelink，我们建议您为RTDB(实时数据库)设置以下数据库规则:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="95be" class="le lf iq mh b gy ml mm l mn mo">{<br/>  "rules": {<br/>    "flamelink": {<br/>      ".read": "auth != null",<br/>      ".write": "auth != null",<br/>      "users": {<br/>        ".indexOn": ["email", "id"]<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="fd76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用简单的英语来说，就是:</p><blockquote class="kw kx ky"><p id="7495" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">在"<strong class="ka ir"> flamelink </strong>"名称空间之外没有访问权限，但对"<strong class="ka ir"> flamelink </strong>"名称空间内的已验证用户有读写权限。</p></blockquote><p id="a2d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kz">用户在“email”和“id”字段上的索引只是为了更好的查询性能，对于这篇关于访问控制的文章并不重要。</em></p><p id="cf9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这对于快速入门来说是不错的，但是您可以想象一下，允许任何经过身份验证的用户写入您的数据库并不是生产就绪的安全性。另一方面，您可能希望任何人都可以阅读某些内容，不管他们是否登录——比如您网站上的博客帖子等。那么这怎么改善呢？让我们来看几个选项。</p><h2 id="3fd4" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">需要知道的事情</h2><p id="8fc7" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">关于为RTDB设置安全性规则，需要了解一些事项:</p><ol class=""><li id="4b74" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">从服务器访问时，安全规则会被完全忽略，只有客户端(浏览器)访问时才会应用安全规则</li><li id="735a" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">如果规则授予父节点读/写访问权限，则DB结构中进一步嵌套的任何其他子节点也将具有访问权限。换句话说，如果DB结构中更高一级的规则已经是<strong class="ka ir">真</strong>，那么您不能将规则设置为<strong class="ka ir">假</strong>。</li></ol><p id="9340" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您还不熟悉RTDB安全规则，请观看此视频，它是一个非常好的介绍:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">摘自https://firebase.google.com/docs/database/security/<a class="ae ld" href="https://firebase.google.com/docs/database/security/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h2 id="4f35" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">您的应用程序或网站的读取权限</h2><p id="176c" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">最简单的方法是授予任何人对非敏感内容的读取权限，因此我们将首先解决这个问题。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="da54" class="le lf iq mh b gy ml mm l mn mo">{<br/>  "rules": {<br/>    "flamelink": {<br/>      ".read": "auth != null",<br/>      ".write": "auth != null",<br/>      "users": {<br/>        ".indexOn": ["email"]<br/>      },<br/>      "environments": {<br/>        "$environment": {<br/>          "content": {<br/>            <strong class="mh ir">"nonSensitiveContentType": {<br/>              ".read": true<br/>            }</strong><br/>          }<br/>          "schemas": {<br/>            <strong class="mh ir">".read": true</strong><br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="1c70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您需要注意的是“nonSensitiveContentType”属性，您可以用特定内容类型的键替换它。这是特定于您的数据的，所以请查看您的数据库。您可以为任意多的内容类型执行此操作。如果您愿意，也可以通过设置以下内容来使所有内容可读:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6949" class="le lf iq mh b gy ml mm l mn mo">"content": {<br/>  <strong class="mh ir">".read": true</strong><br/>}</span></pre><p id="f2ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这正是我们在示例中对“模式”所做的。如果你使用官方的<a class="ae ld" href="https://flamelink.github.io/flamelink" rel="noopener ugc nofollow" target="_blank"> Flamelink JavaScript SDK </a>，你将不得不授予“模式”的读取权限，因为这用于确定字段是否有效、是否相关以及其他一些好处，如缓存。</p><p id="75ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你的应用程序用户的另一个读访问选项是仍然要求用户被认证，但是使用<a class="ae ld" href="https://firebase.google.com/docs/auth/web/anonymous-auth" rel="noopener ugc nofollow" target="_blank"> Firebase的匿名登录</a>。这样做的好处是，你的数据库只能从你的应用程序中读取(或者你是否允许对你的项目进行身份验证)，而不能通过REST端点读取。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h2 id="7946" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">特定用户的写权限</h2><p id="f570" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">要将对数据库的写访问权限仅限于Flamelink CMS用户，您可以在规则中指定唯一的id(uid ),如下所示:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8b6c" class="le lf iq mh b gy ml mm l mn mo">{<br/>  "rules": {<br/>    "flamelink": {<br/>      ".read": "auth != null",<br/>      <strong class="mh ir">".write": "auth.uid === '2TnyIXYi3FPeizykrJiLT972Oy53'",</strong><br/>      "users": {<br/>        ".indexOn": ["email"]<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="f125" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在您的<a class="ae ld" href="https://console.firebase.google.com" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>的“认证”部分找到您的用户的UID。您也可以非常容易地指定多个uid:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1502" class="le lf iq mh b gy ml mm l mn mo">".write": "auth.uid === '2TnyIXYi3FPeizykrJiLT972Oy53' || auth.uid === 'LOkg1qVvLgTHWPyOkeBgrGaNuHy3'"</span></pre><p id="a7e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您决定匿名登录您的所有应用程序用户，您可以通过检查“匿名”提供商来进一步限制写入:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="be37" class="le lf iq mh b gy ml mm l mn mo">".write": "<strong class="mh ir">auth.provider !== 'anonymous'</strong>"</span></pre></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h2 id="5d7f" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">非常动态的规则</h2><p id="c24c" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">首先，我想说我们并不建议你必须这样做，但这是可能的。继续… </p><p id="8631" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Flamelink中，用户被分配到权限组，每个权限组都有一个唯一的ID。这些权限组映射到应用程序中的特定权限。例如，一个权限组可以被配置为只允许对模式的"<strong class="ka ir">视图</strong>访问，但是对内容的完全<a class="ae ld" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a>访问。我们可以利用这些权限组来动态限制数据库级别的访问。</p><p id="0149" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我坦白，这可能会变得很糟糕。我们将首先看一下如何在您的内容类型上实施"<strong class="ka ir"> view </strong>"权限，但是同样的技术可以用于任何其他CRUD操作。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="7384" class="le lf iq mh b gy ml mm l mn mo">{<br/>  "rules": {<br/>    "flamelink": {<br/>      ".read": "auth != null",<br/>      ".write": "auth != null",<br/>      "environments": {<br/>        "$environment": {<br/>          "content": {<br/>            "$contentType": {<br/>              "$locale": {<br/>                <strong class="mh ir">".read": "auth != null &amp;&amp; root.child('flamelink').child('permissions').child(root.child('flamelink').child('users').child(auth.uid).child('permissions').val() + '').child('content').child($environment).child($contentType).child('view').val() === true"</strong><br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="a441" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哇！什么鬼东西？！好吧，让我们把它分解一下，因为这个想法很简单，语法没那么复杂。我保证会有意义的。</p><p id="f6fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">想法:</strong>获取用户的权限组，并检查该权限组是否被设置为允许对特定内容的“查看”权限。</p><p id="8abe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">语法:</strong>规则由两部分组成:获取权限组ID，然后检查该组的权限配置。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b9dd" class="le lf iq mh b gy ml mm l mn mo">root<br/>  .child('<strong class="mh ir">flamelink</strong>')<br/>  .child('<strong class="mh ir">users</strong>')<br/>  .child(<strong class="mh ir">auth.uid</strong>)<br/>  .child('<strong class="mh ir">permissions</strong>')<br/>  .val() + ''</span></pre><p id="c6da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码从数据库的根目录开始，一直到<code class="fe nq nr ns mh b">flamelink.users.&lt;uid&gt;.permissions</code>，其中&lt; uid &gt;是试图访问数据库的用户的用户id。这个数据库字段的值是一个整数，所以我们用<code class="fe nq nr ns mh b">+ ''</code>将它转换成一个字符串，这样我们就可以在规则的下一部分使用它。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ce3a" class="le lf iq mh b gy ml mm l mn mo">root<br/>  .child('<strong class="mh ir">flamelink</strong>')<br/>  .child('<strong class="mh ir">permissions</strong>')<br/>  .child(<strong class="mh ir">&lt;our-previous-query&gt;</strong>)<br/>  .child('<strong class="mh ir">content</strong>')<br/>  .child(<strong class="mh ir">$environment</strong>)<br/>  .child(<strong class="mh ir">$contentType</strong>)<br/>  .child('<strong class="mh ir">view</strong>')<br/>  .val() === true</span></pre><p id="8902" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，我们从DB的根目录开始，向下钻取，直到得到实际的权限组配置:<code class="fe nq nr ns mh b">flamelink.permissions.&lt;user-permission-group&gt;.content.&lt;environment&gt;.&lt;content-type&gt;.view</code>。</p><p id="a462" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个权限组配置由以下4个布尔属性组成，这些属性映射到标准CRUD配置:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8e21" class="le lf iq mh b gy ml mm l mn mo">{<br/>  <strong class="mh ir">create</strong>: true,<br/>  <strong class="mh ir">delete</strong>: false,<br/>  <strong class="mh ir">update</strong>: true<strong class="mh ir">,<br/>  view</strong>: true<br/>}</span></pre><p id="e241" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要检查任何其他权限，只需将“<strong class="ka ir">视图</strong>替换为“<strong class="ka ir">更新</strong>”、“<strong class="ka ir">删除</strong>或“<strong class="ka ir">创建</strong>”。</p><p id="f06c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能还注意到了规则开头的<code class="fe nq nr ns mh b">auth != null</code>部分。这是为了确保我们仍在检查用户是否登录，否则，我们所有的努力工作都会被某个没有登录的人取消。</p><p id="28be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是<code class="fe nq nr ns mh b">".read"</code>规则。<code class="fe nq nr ns mh b">".write"</code>规则类似于我们的读取，但更复杂，因为我们还需要考虑用户试图对数据做什么，以确定我们是否应该检查<strong class="ka ir">创建</strong>、<strong class="ka ir">更新</strong>或<strong class="ka ir">删除</strong>配置。</p><p id="59ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们是勇敢的开发者，所以让我们继续。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="805d" class="le lf iq mh b gy ml mm l mn mo">{<br/>    ".write": "<strong class="mh ir">auth !== null</strong> &amp;&amp;<br/>    ((<strong class="mh ir">!data.exists()</strong> &amp;&amp;<br/>      root<br/>        .child('flamelink')<br/>        .child('permissions')<br/>        .child(<br/>          root<br/>            .child('flamelink')<br/>            .child('users')<br/>            .child(auth.uid)<br/>            .child('permissions')<br/>            .val() + ''<br/>        )<br/>        .child('content')<br/>        .child($environment)<br/>        .child($contentType)<br/>        .child('<strong class="mh ir">create</strong>')<br/>        .val() === true) ||<br/>      (<strong class="mh ir">!newData.exists()</strong> &amp;&amp;<br/>        root<br/>          .child('flamelink')<br/>          .child('permissions')<br/>          .child(<br/>            root<br/>              .child('flamelink')<br/>              .child('users')<br/>              .child(auth.uid)<br/>              .child('permissions')<br/>              .val() + ''<br/>          )<br/>          .child('content')<br/>          .child($environment)<br/>          .child($contentType)<br/>          .child('<strong class="mh ir">delete</strong>')<br/>          .val() === true) ||<br/>      (<strong class="mh ir">data.exists() &amp;&amp; newData.exists()</strong> &amp;&amp;<br/>        root<br/>          .child('flamelink')<br/>          .child('permissions')<br/>          .child(<br/>            root<br/>              .child('flamelink')<br/>              .child('users')<br/>              .child(auth.uid)<br/>              .child('permissions')<br/>              .val()<br/>          )<br/>          .child('content')<br/>          .child($environment)<br/>          .child($contentType)<br/>          .child('<strong class="mh ir">update</strong>')<br/>          .val() === true))"<br/>  }</span></pre><p id="566e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们扯掉了绷带，这里发生了什么？</p><p id="ee9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了对登录用户的<code class="fe nq nr ns mh b">auth != null</code>检查，我们的规则有3个不同的部分，每个部分处理不同的动作(创建、删除和更新)。</p><p id="7541" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的<strong class="ka ir"> create </strong>动作，我们利用Firebase的<code class="fe nq nr ns mh b">data.exist()</code>方法来检查特定内容当前是否不存在数据。这就是我们知道有人试图添加新数据的方式。</p><p id="3813" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的<strong class="ka ir">删除</strong>操作，我们使用<code class="fe nq nr ns mh b">newData.exists()</code>方法来检查新数据是否不存在。如果用户的行为不会产生新的数据，我们知道他们试图删除一些东西。</p><p id="e464" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们最后的<strong class="ka ir">更新</strong>动作，我们结合了<code class="fe nq nr ns mh b">data.exists()</code>和<code class="fe nq nr ns mh b">newData.exists()</code>方法来确定用户试图将现有数据更改为其他数据。</p><p id="d6a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还不算太糟，是吗？</p><p id="fee0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有关如何应用的完整示例，请参见本<a class="ae ld" href="https://gist.github.com/jperasmus/73741d5d86ad146b56b61f552786c167" rel="noopener ugc nofollow" target="_blank">要点</a>。</p><p id="e477" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法并非没有局限性。由于Flamelink是一款常青树，并且不断发展的产品，因此会不断添加新功能，这可能会导致新节点添加到数据库中。如果您对数据库的限制太多，以至于我们无法对您的数据库结构进行必要的更新，您将无法使用这些闪亮的新特性。您可以通过将我们前面看到的UID特定规则与这个动态设置相结合来解决这个问题，并确保如果当前登录的用户是项目的所有者，则可以对数据库进行任何写入。这将确保当推出新功能并且所有者登录到项目中时，应用必要的数据库结构更改。</p><blockquote class="kw kx ky"><p id="f09c" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">尽管如此，我们很少进行结构上的改变，因为产品的常青特性。</p></blockquote></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h2 id="07c3" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">Firebase自定义声明</h2><p id="2eb3" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">我们把最好的留到了最后。最有说服力的解决方案是使用Firebase鲜为人知的特性:<a class="ae ld" href="https://firebase.google.com/docs/auth/admin/custom-claims" rel="noopener ugc nofollow" target="_blank">自定义声明</a>。我们很乐意将带有自定义声明的Flamelink开箱即用，但自定义声明只能使用Firebase Admin SDK从特权服务器环境中设置。这意味着你，项目所有者，将不得不自己处理这个问题。</p><p id="6bbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">什么是自定义声明？</strong></p><p id="3ac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单地说，自定义声明是在用户帐户上设置的自定义属性。例如，您可以为用户设置一个<code class="fe nq nr ns mh b">isAdmin</code>属性。这非常强大，因为它提供了在Firebase应用程序中实现各种访问控制策略的能力，包括基于角色的访问控制。令人惊奇的是，这些自定义属性可以用在数据库的安全规则中。</p><p id="fb17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">关于如何使用它们的一些想法</strong></p><p id="8efa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自定义声明应仅用于访问控制，而不是存储任何其他用户数据。最好在数据库中存储额外的数据。</p><p id="d2dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在设置自定义声明时，您可以保持简单，并在所有Firebase用户上设置一个名为<code class="fe nq nr ns mh b">flamelinkUser</code>的属性，该属性应该对内容具有写访问权限。或者，您可以将声明设置为您喜欢的详细声明，但是请记住自定义声明有效负载不应超过1000字节的限制。建议将其设置得尽可能小，因为这些声明会随所有网络请求一起发送，并且较大的负载会对性能产生负面影响。</p><p id="9e0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">如何在我们的安全规则中使用这些自定义声明？</strong></p><p id="705f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦设置好，在我们的数据库安全规则中检查自定义声明就变得非常容易。所有自定义声明都在经过身份验证的用户的身份验证令牌上设置。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="91e2" class="le lf iq mh b gy ml mm l mn mo">{<br/>  "rules": {<br/>    "flamelink": {<br/>      ".read": "auth != null",<br/><strong class="mh ir">      ".write": "auth.token.flamelinkUser === true"</strong><br/>    }<br/>  }<br/>}</span></pre><p id="42fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">如何为您的用户设置自定义声明？</strong></p><p id="8777" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置自定义声明的唯一要求是使用Firebase Admin SDK从服务器环境中进行设置，无论是使用您运行的独立Express服务器还是使用Firebase 的<a class="ae ld" href="https://firebase.google.com/docs/functions/" rel="noopener ugc nofollow" target="_blank">云功能，都由您决定。代码如下所示(示例使用JavaScript，但是您可以使用任何受支持的服务器端语言):</a></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6a7c" class="le lf iq mh b gy ml mm l mn mo">// import admin SDK<br/><strong class="mh ir">const admin = require('firebase-admin');</strong></span><span id="363e" class="le lf iq mh b gy nt mm l mn mo">// initialize admin app with any of the supported options<br/><strong class="mh ir">admin.initializeApp(/* config here */);</strong></span><span id="2221" class="le lf iq mh b gy nt mm l mn mo">// create your custom claims object (whatever you want)<br/><strong class="mh ir">const customClaims = {<br/>  flamelinkUser: true<br/>};</strong></span><span id="45d7" class="le lf iq mh b gy nt mm l mn mo">// set the custom claims object for given UID<br/><strong class="mh ir">admin.auth().setCustomUserClaims(user.uid, customClaims)</strong></span></pre><p id="1c80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nq nr ns mh b">admin.auth().setCustomUserClaims()</code>方法返回一个承诺。值得注意的是，设置新的自定义声明会覆盖任何现有的自定义声明，因此您可能希望在再次设置之前先检索现有的声明并对其进行更新。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h2 id="9002" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">结论</h2><p id="ae1e" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">希望这能让您了解Firebase安全规则是多么强大和灵活。我鼓励你在<a class="ae ld" href="https://firebase.google.com/docs/database/security/" rel="noopener ugc nofollow" target="_blank"> Firebase的文档</a>中阅读更多关于这些规则的内容。</p><p id="6145" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您对我们如何改进这些安全规则有任何其他想法，请在下面的评论中告诉我们，或者加入我们的<a class="ae ld" href="https://flamelink.io/slack" rel="noopener ugc nofollow" target="_blank"> Slack社区，</a>我们非常欢迎您的加入。</p></div></div>    
</body>
</html>