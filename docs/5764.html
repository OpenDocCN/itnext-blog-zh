<html>
<head>
<title>Elasticsearch on Nomad</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">游牧民族的弹性研究</h1>
<blockquote>原文：<a href="https://itnext.io/elasticsearch-on-nomad-ae685b762779?source=collection_archive---------2-----------------------#2021-05-20">https://itnext.io/elasticsearch-on-nomad-ae685b762779?source=collection_archive---------2-----------------------#2021-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5c8fa3c804f1a578ab61a8856d7e2b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lfmj5NS4h1_d00m0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@rstone_design?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瑞安·斯通</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9e8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我在<a class="ae kc" href="https://mykidong.medium.com/install-nomad-cluster-d9a40d2206f5" rel="noopener">之前的文章</a>中提到的，我一直在寻找Kubernetes的替代品，在容器编排器上部署有状态的应用程序。通常，有状态应用程序需要卷来保存数据。当提交有状态应用程序作业时，应该动态地提供卷。但是目前，Nomad不支持Kubernetes所支持的这种动态卷供应。然而，Nomad给了我操作有状态应用程序的优势。Kubernetes上没有启动、停止和重新部署Statefulsets之类的有状态应用程序而不丢失数据的概念。如果在Kubernetes上删除了statefulsets，恢复PVs上的数据真的很难，否则PVs上的数据就会丢失。如果您想在Kubernetes上部署Statefulsets，您应该使用这样的补丁来保存PVs上的数据。另一方面，在Nomad上，您可以简单地停止正在运行的有状态应用程序作业，并在不丢失数据的情况下重新部署它们，这在最独立的环境中我们已经很熟悉了。由于这个原因，对于我来说，Nomad是处理在容器编排器上运行的有状态应用程序的工作负载编排器的理想选择。当然，使用Nomad有利也有弊，例如，因为Nomad不支持动态卷供应，所以在运行分布式有状态应用程序之前，您必须创建和注册大量的卷，这对于编写Nomad作业来说是非常繁琐和低效的，您将在本文中看到这一点。</p><p id="625c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们来谈谈在Nomad上部署Elasticsearch。Elasticsearch是一个分布式搜索引擎，它以分布式方式保存卷上的数据。你将在下面看到如何在Nomad上部署Elasticsearch，在这篇文章的最后，我们还将看到如何在Nomad上部署Kibana。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="24b5" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">开始之前</h1><p id="1970" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在继续之前，应该有几个组件可供您使用。</p><ul class=""><li id="6620" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">Ceph v14</li><li id="d0b1" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">Ceph CSI v3.3.1</li><li id="1ca2" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">nomad 1 . 0 . 4版</li><li id="f6fe" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">咨询模板v0.22.1</li></ul><h1 id="d98a" class="li lj iq bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">构建弹性搜索Docker图像</h1><p id="787f" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">有一个预构建的elasticsearch docker图像，但我将构建一个elasticsearch docker图像用于我们的示例。</p><p id="6470" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建弹性搜索的<code class="fe ne nf ng nh b">Dockerfile</code>。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="ddc8" class="nq lj iq nh b gy nr ns l nt nu">FROM centos:7<br/><br/>ENV <em class="nv">APP_HOME </em>/opt/elasticsearch<br/>ENV <em class="nv">ES_TMPDIR</em>=${<em class="nv">APP_HOME</em>}/temp<br/>ENV <em class="nv">ES_USER </em>elasticsearch<br/><br/>RUN useradd -ms /bin/bash -d ${<em class="nv">APP_HOME</em>} ${<em class="nv">ES_USER</em>}<br/><br/>RUN yum install nmap-ncat -y<br/><br/>RUN set -ex \<br/>    &amp;&amp; ES_PACK_NAME=elasticsearch-7.12.1 \<br/>    &amp;&amp; FILE_NAME=${<em class="nv">ES_PACK_NAME</em>}-linux-x86_64.tar.gz \<br/>    &amp;&amp; curl -O https://artifacts.elastic.co/downloads/elasticsearch/${<em class="nv">FILE_NAME</em>} \<br/>    &amp;&amp; tar -zxf ${<em class="nv">FILE_NAME</em>} \<br/>    &amp;&amp; cp -R ${<em class="nv">ES_PACK_NAME</em>}/* ${<em class="nv">APP_HOME</em>} \<br/>    &amp;&amp; rm -rf ${<em class="nv">APP_HOME</em>}/config/elasticsearch.yml \<br/>    &amp;&amp; rm -rf ${<em class="nv">APP_HOME</em>}/config/jvm.options \<br/>    &amp;&amp; rm -rf ${<em class="nv">FILE_NAME</em>} \<br/>    &amp;&amp; rm -rf ${<em class="nv">ES_PACK_NAME</em>}<br/><br/>RUN mkdir -p ${<em class="nv">APP_HOME</em>}/temp<br/>RUN ls -al ${<em class="nv">APP_HOME</em>}<br/><br/>RUN chmod a+x -R ${<em class="nv">APP_HOME</em>}/bin<br/>RUN chown ${<em class="nv">ES_USER</em>}: -R ${<em class="nv">APP_HOME</em>}<br/><br/>RUN set -ex \<br/>    &amp;&amp; echo 'elasticsearch   - nofile 65536' &gt;&gt; /etc/security/limits.d/elasticsearch.conf \<br/>    &amp;&amp; echo 'elasticsearch   - nproc  65536' &gt;&gt; /etc/security/limits.d/elasticsearch.conf \<br/>    &amp;&amp; echo 'root  soft  memlock unlimited' &gt;&gt; /etc/security/limits.d/elasticsearch.conf \<br/>    &amp;&amp; echo 'root  hard  memlock unlimited' &gt;&gt; /etc/security/limits.d/elasticsearch.conf<br/>RUN cat /etc/security/limits.d/elasticsearch.conf<br/><br/>USER ${<em class="nv">ES_USER</em>}<br/>WORKDIR ${<em class="nv">APP_HOME</em>}<br/>EXPOSE 9200 9300</span></pre><p id="9202" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Elasticsearch <code class="fe ne nf ng nh b">7.12.1</code>将安装在基于CentOS 7基础映像的docker映像上。</p><p id="b409" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">建立和推广弹性搜索的docker形象。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="800f" class="nq lj iq nh b gy nr ns l nt nu"># image.<br/>export ES_IMAGE=mykidong/elasticsearch:7.12.1</span><span id="a01b" class="nq lj iq nh b gy nw ns l nt nu"># build.<br/>docker build . -t ${ES_IMAGE};</span><span id="c0df" class="nq lj iq nh b gy nw ns l nt nu">## push.<br/>docker push ${ES_IMAGE};</span></pre><h1 id="d5bf" class="li lj iq bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">在Nomad上部署弹性搜索</h1><p id="8782" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">要在Nomad上部署有状态的应用程序作业，需要预先为作业提供卷。Elasticsearch需要保存索引等数据的卷。如前所述，Nomad不支持动态配置卷，所有卷都需要手动创建和注册。我希望Nomad在不久的将来支持这种动态卷供应。</p><p id="9b7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在Nomad上部署3个主节点和2个数据节点。每个节点将相互使用一个调配的卷来保存数据。</p><h2 id="9536" class="nq lj iq bd lk nx ny dn lo nz oa dp ls ko ob oc lw ks od oe ma kw of og me oh bi translated">创建名称空间</h2><p id="ef75" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">创建一个运行所有elasticsearch任务的名称空间。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="e6f4" class="nq lj iq nh b gy nr ns l nt nu">nomad namespace apply -description "Elasticsearch Cluster" elasticsearch;</span></pre><h2 id="35e4" class="nq lj iq bd lk nx ny dn lo nz oa dp ls ko ob oc lw ks od oe ma kw of og me oh bi translated">创建和注册卷</h2><p id="1cda" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果你想知道如何在Nomad上提供卷，你应该事先看看<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/provision-volumes-from-external-ceph-storage-on-kubernetes-and-nomad-using-ceph-csi-7ad9b15e9809">的博客</a>。</p><p id="643a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将为主节点和数据节点创建5个卷。</p><p id="530c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们为elasticsearch的第一个主节点创建一个卷。要创建ceph池的映像，您应该键入如下内容。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="1a6c" class="nq lj iq nh b gy nr ns l nt nu">sudo rbd create csi-vol-00000000-1111-2222-bbbb-cacacacacae2 --size 2048 --pool myPool --image-feature layering;</span></pre><p id="8109" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要注册用创建的ceph映像映射的卷，如下所示。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="286c" class="nq lj iq nh b gy nr ns l nt nu">cat &lt;&lt;EOF &gt; es-volume-master-0.hcl<br/>type = "csi"<br/>id   = "es-master-0"<br/>name = "es-master-0"<br/>external_id     = "0001-0024-62c42aed-9839-4da6-8c09-9d220f56e924-0000000000000009-00000000-1111-2222-bbbb-cacacacacae2"<br/>access_mode     = "single-node-writer"<br/>attachment_mode = "file-system"<br/>mount_options {<br/>  fs_type = "ext4"<br/>}<br/>plugin_id       = "ceph-csi"<br/>secrets {<br/>  userID  = "admin"<br/>  userKey = "AQAvo5JgP++oEhAAeZb1j/MTWyLGGJC6abCNFw=="<br/>}<br/>context {<br/>  clusterID = "62c42aed-9839-4da6-8c09-9d220f56e924"<br/>  pool      = "myPool"<br/>  imageFeatures = "layering"<br/>}<br/>EOF</span></pre><p id="7b40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并运行以下命令在Nomad上注册该卷。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="dfd2" class="nq lj iq nh b gy nr ns l nt nu">nomad volume register -namespace=elasticsearch es-volume-master-0.hcl;</span></pre><p id="43b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为上面注册的卷，您应该再创建和注册4个卷。为elasticsearch创建和注册所有卷的完整脚本可以在这里看到:<a class="ae kc" href="https://gist.github.com/mykidong/5fce30ad4203807aea6281ee57cb49f2" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/myki dong/5 FCE 30 ad 4203807 AEA 6281 ee 57 CB 49 f 2</a></p><p id="3a16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成卷注册后，您可以看到卷的状态如下。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="ee43" class="nq lj iq nh b gy nr ns l nt nu">nomad volume status -namespace elasticsearch;<br/>Container Storage Interface<br/>ID        Name         Plugin ID  Schedulable  Access Mode<br/>es-data-  es-data-0    ceph-csi   true         single-node-writer<br/>es-data-  es-data-1    ceph-csi   true         single-node-writer<br/>es-maste  es-master-0  ceph-csi   true         single-node-writer<br/>es-maste  es-master-1  ceph-csi   true         single-node-writer<br/>es-maste  es-master-2  ceph-csi   true         single-node-writer</span></pre><p id="f7b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，它准备将这些卷附加到Nomad上的elasticsearch任务中。</p><h2 id="57b8" class="nq lj iq bd lk nx ny dn lo nz oa dp ls ko ob oc lw ks od oe ma kw of og me oh bi translated">创建弹性搜索游牧工作</h2><p id="e4b7" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们在Nomad上部署了三个主节点和两个数据节点。我们可能会想象弹性搜索游牧工作会是这样的。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="1e18" class="nq lj iq nh b gy nr ns l nt nu">job "elasticsearch" {<br/>   ...<br/>  group "master" {<br/>     count = 3<br/>     ...<br/>  }  <br/>  group "data" {<br/>     count = 2<br/>     ...<br/>  }<br/>}</span></pre><p id="e223" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ne nf ng nh b">master</code>组中，将运行三个主节点任务，在<code class="fe ne nf ng nh b">data</code>组中，将运行两个数据节点任务。</p><p id="75e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但问题是使用CSI进行卷装载。让我们在组和任务中添加<code class="fe ne nf ng nh b">volume</code>和<code class="fe ne nf ng nh b">volume_mount</code>节，看看为什么卷挂载是问题所在。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="9f45" class="nq lj iq nh b gy nr ns l nt nu">job "elasticsearch" {<br/>   ...<br/>  group "master" {<br/>    count = 3<br/>    ...<br/>    volume "ceph-volume" {<br/>      type = "csi"<br/>      read_only = false<br/>      source = "es-master-${NOMAD_ALLOC_INDEX}"<br/>    }<br/>    task "elasticsearch" {<br/>      driver = "docker"<br/>      ...<br/>      volume_mount {<br/>        volume      = "ceph-volume"<br/>        destination = "/srv"<br/>        read_only   = false<br/>      }<br/>      ...<br/>    }<br/>  } <br/>  group "data" {<br/>     count = 2<br/>     ...<br/>     volume "ceph-volume" {<br/>      type = "csi"<br/>      read_only = false<br/>      source = "es-data-${NOMAD_ALLOC_INDEX}"<br/>    }<br/>    task "elasticsearch" {<br/>      driver = "docker"<br/>      ...<br/>      volume_mount {<br/>        volume      = "ceph-volume"<br/>        destination = "/srv"<br/>        read_only   = false<br/>      }<br/>      ...<br/>    }<br/>  }<br/>}</span></pre><p id="fb1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng nh b">NOMAD_ALLOC_INDEX</code>是分配指标，用来区分组中任务的实例，如0、1、2等。如果当前主节点任务的分配索引为0，那么将挂载上一节注册的<code class="fe ne nf ng nh b">es-master-0</code>的卷，分配索引为1的<code class="fe ne nf ng nh b">es-master-1</code>的卷，分配索引为2的<code class="fe ne nf ng nh b">es-master-2</code>的卷。以这种方式在nomad作业中挂载多个卷会很不错。但是因为<code class="fe ne nf ng nh b">volume</code>节的值不能在运行时动态设置，所以上面的作业不能正常工作。</p><p id="952b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为在<code class="fe ne nf ng nh b">volume</code>节中只允许设置静态值，所以我们应该如下计划elasticsearch nomad作业。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="057e" class="nq lj iq nh b gy nr ns l nt nu">job "elasticsearch" {<br/>   ...<br/>  group "master-0" {<br/>     count = 1<br/>     ...<br/>  }<br/>  group "master-1" {<br/>     count = 1<br/>     ...<br/>  }<br/>  group "master-2" {<br/>     count = 1<br/>     ...<br/>  }<br/>  group "data-0" {<br/>     count = 1<br/>     ...<br/>  }<br/>  group "data-1" {<br/>     count = 1<br/>     ...<br/>  }<br/>}</span></pre><p id="42cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为，由于在<code class="fe ne nf ng nh b">volume</code>节中缺乏支持变量名插值，写这么长的nomad作业真的没有效率。例如，如果您想在nomad上运行100个数据节点，您将放弃它来编写这么长的Nomad作业脚本。</p><p id="5238" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看elasticsearch job中<code class="fe ne nf ng nh b">master-0</code>的完整组。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="9125" class="nq lj iq nh b gy nr ns l nt nu">job "elasticsearch" {<br/>   ...<br/>  group "master-0" {<br/>    count = 1<br/>    restart {<br/>      attempts = 3<br/>      delay = "30s"<br/>      interval = "5m"<br/>      mode = "fail"<br/>    }<br/>    network {<br/>      port "request" {<br/>      }<br/>      port "communication" {<br/>      }<br/>    }<br/>    volume "ceph-volume" {<br/>      type = "csi"<br/>      read_only = false<br/>      source = "es-master-0"<br/>    }<br/>    task "elasticsearch" {<br/>      driver = "docker"<br/>      kill_timeout = "300s"<br/>      kill_signal = "SIGTERM"<br/>      volume_mount {<br/>        volume      = "ceph-volume"<br/>        destination = "/srv"<br/>        read_only   = false<br/>      }<br/>      env {<br/>        ES_TMPDIR = "/opt/elasticsearch/temp"<br/>      }<br/>      template {<br/>        data = &lt;&lt;EOF<br/>cluster:<br/>  name: my-cluster<br/>  publish:<br/>    timeout: 300s<br/>  join:<br/>    timeout: 300s<br/>  initial_master_nodes:<br/>    - {{ env "NOMAD_IP_communication" }}:{{ env "NOMAD_HOST_PORT_communication" }}<br/>node:<br/>  name: es-master-0<br/>  master: true<br/>  data: false<br/>  ingest: false<br/>network:<br/>  host: 0.0.0.0<br/>discovery:<br/>  seed_hosts:<br/>    - {{ env "NOMAD_IP_communication" }}:{{ env "NOMAD_HOST_PORT_communication" }}<br/>path:<br/>  data:<br/>    - /srv/data<br/>  logs: /srv/log<br/>bootstrap.memory_lock: true<br/>indices.query.bool.max_clause_count: 10000<br/>EOF<br/>        destination = "local/elasticsearch.yml"<br/>      }<br/>      template {<br/>        data = &lt;&lt;EOF<br/>-Xms512m<br/>-Xmx512m<br/>8-13:-XX:+UseConcMarkSweepGC<br/>8-13:-XX:CMSInitiatingOccupancyFraction=75<br/>8-13:-XX:+UseCMSInitiatingOccupancyOnly<br/>14-:-XX:+UseG1GC<br/>-Djava.io.tmpdir=${ES_TMPDIR}<br/>-XX:+HeapDumpOnOutOfMemoryError<br/>-XX:HeapDumpPath=data<br/>-XX:ErrorFile=logs/hs_err_pid%p.log<br/>8:-XX:+PrintGCDetails<br/>8:-XX:+PrintGCDateStamps<br/>8:-XX:+PrintTenuringDistribution<br/>8:-XX:+PrintGCApplicationStoppedTime<br/>8:-Xloggc:logs/gc.log<br/>8:-XX:+UseGCLogFileRotation<br/>8:-XX:NumberOfGCLogFiles=32<br/>8:-XX:GCLogFileSize=64m<br/>9-:-Xlog:gc*,gc+age=trace,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m<br/>EOF<br/>        destination = "local/jvm.options"<br/>      }<br/>      config {<br/>        image = "mykidong/elasticsearch:7.12.1"<br/>        force_pull = false<br/>        volumes = [<br/>          "./local/elasticsearch.yml:/opt/elasticsearch/config/elasticsearch.yml",<br/>          "./local/jvm.options:/opt/elasticsearch/config/jvm.options"<br/>        ]<br/>        command = "bin/elasticsearch"<br/>        args = [<br/>          "-Enetwork.publish_host=${NOMAD_IP_request}",<br/>          "-Ehttp.publish_port=${NOMAD_HOST_PORT_request}",<br/>          "-Ehttp.port=${NOMAD_PORT_request}",<br/>          "-Etransport.publish_port=${NOMAD_HOST_PORT_communication}",<br/>          "-Etransport.tcp.port=${NOMAD_PORT_communication}"<br/>        ]<br/>        ports = [<br/>          "request",<br/>          "communication"<br/>        ]<br/>        ulimit {<br/>          memlock = "-1"<br/>          nofile = "65536"<br/>          nproc = "65536"<br/>        }<br/>      }<br/>      resources {<br/>        cpu = 100<br/>        memory = 1024<br/>      }<br/>      service {<br/>        name = "es-req"<br/>        port = "request"<br/>        check {<br/>          name = "rest-tcp"<br/>          type = "tcp"<br/>          interval = "10s"<br/>          timeout = "2s"<br/>        }<br/>        check {<br/>          name     = "rest-http"<br/>          type     = "http"<br/>          path     = "/"<br/>          interval = "5s"<br/>          timeout  = "4s"<br/>        }<br/>      }<br/>      service {<br/>        name = "es-master-0-comm"<br/>        port = "communication"<br/>        check {<br/>          type = "tcp"<br/>          interval = "10s"<br/>          timeout = "2s"<br/>        }<br/>      }<br/>    }<br/>  }<br/>  ...<br/>}</span></pre><p id="a924" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看一看<code class="fe ne nf ng nh b">task </code>中的<code class="fe ne nf ng nh b">template </code>节。使用这些模板，<code class="fe ne nf ng nh b">elasticsearch.yml</code>和<code class="fe ne nf ng nh b">jvm.options</code>的配置将被创建并链接到elasticsearch容器。有两个<code class="fe ne nf ng nh b">service</code>节，用于请求elasticsearch的服务<code class="fe ne nf ng nh b">es-req</code>和用于elasticsearch集群中节点间通信的服务<code class="fe ne nf ng nh b">es-master-0-comm</code>将注册到Consul。您可以使用<a class="ae kc" href="https://github.com/hashicorp/consul-template" rel="noopener ugc nofollow" target="_blank"> Consul-Template </a>在服务<code class="fe ne nf ng nh b">es-req</code>中获取elasticsearch节点的IP地址和端口。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2360" class="nq lj iq nh b gy nr ns l nt nu">cat &lt;&lt;EOF &gt; service.tpl<br/>{{ range service "es-req" }}<br/>  - {{ .Address }}:{{ .Port }}{{ end }}<br/>EOF</span><span id="6f6c" class="nq lj iq nh b gy nw ns l nt nu">consul-template -template service.tpl -dry;<br/>&gt;</span><span id="e46e" class="nq lj iq nh b gy nw ns l nt nu">  - 10.0.0.200:30246<br/>  - 10.0.0.200:22052<br/>  - 10.0.0.200:26345<br/>  - 10.0.0.200:20821<br/>  - 10.0.0.200:30044</span></pre><p id="db41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">卷<code class="fe ne nf ng nh b">es-master-0</code>已经被挂载到<code class="fe ne nf ng nh b">/srv</code>的路径上。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="5887" class="nq lj iq nh b gy nr ns l nt nu">    volume "ceph-volume" {<br/>      type = "csi"<br/>      read_only = false<br/>      source = "es-master-0"<br/>    }<br/>    task "elasticsearch" {<br/>      ...<br/>      volume_mount {<br/>        volume      = "ceph-volume"<br/>        destination = "/srv"<br/>        read_only   = false<br/>      }<br/>      ...<br/>    }</span></pre><p id="5fc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在容器参数中，可以设置附加的弹性搜索配置。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2a75" class="nq lj iq nh b gy nr ns l nt nu">        args = [<br/>          "-Enetwork.publish_host=${NOMAD_IP_request}",<br/>          "-Ehttp.publish_port=${NOMAD_HOST_PORT_request}",<br/>          "-Ehttp.port=${NOMAD_PORT_request}",<br/>          "-Etransport.publish_port=${NOMAD_HOST_PORT_communication}",<br/>          "-Etransport.tcp.port=${NOMAD_PORT_communication}"<br/>        ]</span></pre><p id="3e5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以得到分配任务的IP地址。变量<code class="fe ne nf ng nh b">NOMAD_IP_&lt;network-port-name&gt;</code>是端口为<code class="fe ne nf ng nh b">&lt;network-port-name&gt;</code>的已分配任务的IP地址，例如<code class="fe ne nf ng nh b">NOMAD_IP_request</code>是监听<code class="fe ne nf ng nh b">request</code>端口的已分配任务<code class="fe ne nf ng nh b">elasticsearch</code>的IP地址。</p><p id="788c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng nh b">NOMAD_HOST_PORT_&lt;network-port-name&gt;</code>是端口名为<code class="fe ne nf ng nh b">&lt;network-port-name&gt;</code>的已分配任务容器的发布端口，<code class="fe ne nf ng nh b">NOMAD_PORT_&lt;network-port-name&gt;</code>是端口名为<code class="fe ne nf ng nh b">&lt;network-port-name&gt;</code>的已分配任务容器正在监听的容器端口。例如，<code class="fe ne nf ng nh b">http.publish_port</code>将被设置为已分配任务容器的已发布<code class="fe ne nf ng nh b">request</code>端口，<code class="fe ne nf ng nh b">transport.publish_port</code>将被设置为已分配任务容器的已发布<code class="fe ne nf ng nh b">communication</code>端口。</p><p id="5c34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们现在已经看到了<code class="fe ne nf ng nh b">master-0</code>小组的详细情况。你可以在这里看到elasticsearch nomad job <code class="fe ne nf ng nh b">elasticsearch.nomad</code>的完整代码:<a class="ae kc" href="https://gist.github.com/mykidong/aea105d29e47fafb1ccaeaf2edc5c183" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/myki dong/AEA 105d 29 e 47 fafb 1c caeaf 2 ed C5 c 183</a></p><p id="40c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们运行elasticsearch nomad job。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="deed" class="nq lj iq nh b gy nr ns l nt nu">nomad job run elasticsearch.nomad;</span></pre><p id="bf60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正确运行elasticsearch作业后，您将看到elasticsearch集群的健康状况。Elasticsearch请求的ip地址和端口可以使用如上所述的consul-template获得。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2c96" class="nq lj iq nh b gy nr ns l nt nu">curl <a class="ae kc" href="http://10.0.0.200:26345/_cluster/health?pretty" rel="noopener ugc nofollow" target="_blank">http://10.0.0.200:26345/_cluster/health?pretty</a><br/>{<br/>  "cluster_name" : "my-cluster",<br/>  "status" : "green",<br/>  "timed_out" : false,<br/>  "number_of_nodes" : 5,<br/>  "number_of_data_nodes" : 2,<br/>  "active_primary_shards" : 9,<br/>  "active_shards" : 18,<br/>  "relocating_shards" : 0,<br/>  "initializing_shards" : 0,<br/>  "unassigned_shards" : 0,<br/>  "delayed_unassigned_shards" : 0,<br/>  "number_of_pending_tasks" : 0,<br/>  "number_of_in_flight_fetch" : 0,<br/>  "task_max_waiting_in_queue_millis" : 0,<br/>  "active_shards_percent_as_number" : 100.0<br/>}</span></pre><p id="5dce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们有了一个elasticsearch集群，它由运行在Nomad上的3个主节点和2个数据节点组成！</p><h1 id="0d36" class="li lj iq bd lk ll mz ln lo lp na lr ls lt nb lv lw lx nc lz ma mb nd md me mf bi translated">在游牧部落部署基巴纳</h1><p id="eaf0" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">使用Kibana，您可以在elasticsearch中查询索引，并轻松构建仪表板。</p><p id="cccb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建Kibana docker图像。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2559" class="nq lj iq nh b gy nr ns l nt nu">FROM centos:7<br/><br/>ENV <em class="nv">APP_HOME </em>/opt/kibana<br/>ENV <em class="nv">KIBANA_USER </em>kibana<br/><br/>RUN useradd -ms /bin/bash -d ${<em class="nv">APP_HOME</em>} ${<em class="nv">KIBANA_USER</em>}<br/><br/>RUN yum install nmap-ncat -y<br/><br/>RUN set -ex \<br/>    &amp;&amp; PACK_NAME=kibana-7.12.1-linux-x86_64 \<br/>    &amp;&amp; FILE_NAME=${<em class="nv">PACK_NAME</em>}.tar.gz \<br/>    &amp;&amp; curl -O https://artifacts.elastic.co/downloads/kibana/${<em class="nv">FILE_NAME</em>} \<br/>    &amp;&amp; tar -zxf ${<em class="nv">FILE_NAME</em>} \<br/>    &amp;&amp; cp -R ${<em class="nv">PACK_NAME</em>}/* ${<em class="nv">APP_HOME</em>} \<br/>    &amp;&amp; rm -rf ${<em class="nv">APP_HOME</em>}/config/kibana.yml \<br/>    &amp;&amp; rm -rf ${<em class="nv">FILE_NAME</em>} \<br/>    &amp;&amp; rm -rf ${<em class="nv">PACK_NAME</em>}<br/><br/>RUN mkdir -p ${<em class="nv">APP_HOME</em>}/temp<br/>RUN ls -al ${<em class="nv">APP_HOME</em>}<br/><br/>RUN chmod a+x -R ${<em class="nv">APP_HOME</em>}/bin<br/>RUN chown ${<em class="nv">KIBANA_USER</em>}: -R ${<em class="nv">APP_HOME</em>}<br/><br/>USER ${<em class="nv">KIBANA_USER</em>}<br/>WORKDIR ${<em class="nv">APP_HOME</em>}<br/>EXPOSE 5601</span></pre><p id="8264" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为Kibana构建docker映像。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="16c5" class="nq lj iq nh b gy nr ns l nt nu"># image.<br/>export KIBANA_IMAGE=mykidong/kibana:7.12.1</span><span id="3b8e" class="nq lj iq nh b gy nw ns l nt nu"># build.<br/>docker build . -t ${KIBANA_IMAGE};</span><span id="6fe7" class="nq lj iq nh b gy nw ns l nt nu">## push.<br/>docker push ${KIBANA_IMAGE};</span></pre><p id="ade4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为Kibana数据创建并注册一个卷。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="d75e" class="nq lj iq nh b gy nr ns l nt nu">## create an image in the pool of ceph.<br/>sudo rbd create csi-vol-00000000-1111-2222-bbbb-cacacacacag1 --size 2048 --pool myPool --image-feature layering;</span><span id="324f" class="nq lj iq nh b gy nw ns l nt nu">## es kibana volume.<br/>cat &lt;&lt;EOF &gt; es-volume-kibana.hcl<br/>type = "csi"<br/>id   = "es-kibana"<br/>name = "es-kibana"<br/>external_id     = "0001-0024-62c42aed-9839-4da6-8c09-9d220f56e924-0000000000000009-00000000-1111-2222-bbbb-cacacacacag1"<br/>access_mode     = "single-node-writer"<br/>attachment_mode = "file-system"<br/>mount_options {<br/>  fs_type = "ext4"<br/>}<br/>plugin_id       = "ceph-csi"<br/>secrets {<br/>  userID  = "admin"<br/>  userKey = "AQAvo5JgP++oEhAAeZb1j/MTWyLGGJC6abCNFw=="<br/>}<br/>context {<br/>  clusterID = "62c42aed-9839-4da6-8c09-9d220f56e924"<br/>  pool      = "myPool"<br/>  imageFeatures = "layering"<br/>}<br/>EOF</span><span id="60f7" class="nq lj iq nh b gy nw ns l nt nu"># register volume.<br/>nomad volume register -namespace=elasticsearch es-volume-kibana.hcl;</span></pre><p id="415b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，创建基巴纳游牧民工作<code class="fe ne nf ng nh b">kibana.nomad</code>。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="15ae" class="nq lj iq nh b gy nr ns l nt nu">job "kibana" {<br/>  namespace = "elasticsearch"<br/>  datacenters = ["dc1"]<br/>  type        = "service"<br/>  update {<br/>    max_parallel     = 1<br/>    health_check     = "checks"<br/>    min_healthy_time = "30s"<br/>    healthy_deadline = "5m"<br/>    auto_revert      = true<br/>    canary           = 0<br/>    stagger          = "30s"<br/>  }<br/>  group "kibana-server" {<br/>    count = 1<br/>    restart {<br/>      attempts = 3<br/>      delay = "30s"<br/>      interval = "5m"<br/>      mode = "fail"<br/>    }<br/>    network {<br/>      port "http" {<br/>        static = 5601<br/>      }<br/>    }<br/>    volume "ceph-volume" {<br/>      type = "csi"<br/>      read_only = false<br/>      source = "es-kibana"<br/>    }<br/>    task "await-es-req" {<br/>      driver = "docker"<br/>      config {<br/>        image        = "busybox:1.28"<br/>        command      = "sh"<br/>        args         = ["-c", "echo -n 'Waiting for service'; until nslookup es-req.service.consul 2&gt;&amp;1 &gt;/dev/null; do echo '.'; sleep 2; done"]<br/>        network_mode = "host"<br/>      }<br/>      resources {<br/>        cpu    = 200<br/>        memory = 128<br/>      }<br/>      lifecycle {<br/>        hook    = "prestart"<br/>        sidecar = false<br/>      }<br/>    }<br/>    task "kibana" {<br/>      driver = "docker"<br/>      kill_timeout = "300s"<br/>      kill_signal = "SIGTERM"<br/>      volume_mount {<br/>        volume      = "ceph-volume"<br/>        destination = "/srv"<br/>        read_only   = false<br/>      }<br/>      template {<br/>        data = &lt;&lt;EOF<br/>elasticsearch:<br/>  hosts:<br/>    - <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/{{range">http://{{range</a> $index, $element := service "es-req"}}{{if eq $index 0}}{{ .Address }}:{{ .Port }}{{end}}{{end}}<br/>path:<br/>  data: /srv/data<br/>EOF<br/>        destination = "local/kibana.yml"<br/>      }<br/>      config {<br/>        image = "mykidong/kibana:7.12.1"<br/>        force_pull = false<br/>        volumes = [<br/>          "./local/kibana.yml:/opt/kibana/config/kibana.yml",<br/>        ]<br/>        command = "bin/kibana"<br/>        args = [<br/>          "--host",<br/>          "0.0.0.0",<br/>          "--port",<br/>          "${NOMAD_PORT_http}"<br/>        ]<br/>        ports = [<br/>          "http"<br/>        ]<br/>        ulimit {<br/>          memlock = "-1"<br/>          nofile = "65536"<br/>          nproc = "65536"<br/>        }<br/>      }<br/>      resources {<br/>        cpu = 100<br/>        memory = 1024<br/>      }<br/>      service {<br/>        name = "es-kibana-http"<br/>        port = "http"<br/>        check {<br/>          name = "http-tcp"<br/>          type = "tcp"<br/>          interval = "10s"<br/>          timeout = "2s"<br/>        }<br/>        check {<br/>          name     = "http-http"<br/>          type     = "http"<br/>          path     = "/"<br/>          interval = "5s"<br/>          timeout  = "4s"<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="1894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在运行Kibana任务之前，将运行预启动任务<code class="fe ne nf ng nh b">await-es-req</code>。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="d663" class="nq lj iq nh b gy nr ns l nt nu">    ... <br/>    task "await-es-req" {<br/>      driver = "docker"<br/>      config {<br/>        image        = "busybox:1.28"<br/>        command      = "sh"<br/>        args         = ["-c", "echo -n 'Waiting for service'; until nslookup es-req.service.consul 2&gt;&amp;1 &gt;/dev/null; do echo '.'; sleep 2; done"]<br/>        network_mode = "host"<br/>      }<br/>      resources {<br/>        cpu    = 200<br/>        memory = 128<br/>      }<br/>      lifecycle {<br/>        hook    = "prestart"<br/>        sidecar = false<br/>      }<br/>    }<br/>    ...</span></pre><p id="0acc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个预启动任务将等待在Consul中注册的服务<code class="fe ne nf ng nh b">es-req</code>准备就绪，也就是说，elasticsearch准备好获取请求。</p><p id="fc28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看kibana配置中的elasticsearch主机<code class="fe ne nf ng nh b">kibana.yml</code>。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="1ab8" class="nq lj iq nh b gy nr ns l nt nu">elasticsearch:<br/>  hosts:<br/>    - <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/{{range">http://{{range</a> $index, $element := service "es-req"}}{{if eq $index 0}}{{ .Address }}:{{ .Port }}{{end}}{{end}}</span></pre><p id="2ddd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将获得服务<code class="fe ne nf ng nh b">es-req</code>中第一个元素的IP地址和端口，该服务已经在consul上注册以处理elasticsearch请求。</p><p id="4c30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们运行基巴纳游牧工作。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="f27a" class="nq lj iq nh b gy nr ns l nt nu">nomad job run kibana.nomad</span></pre><p id="3f00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要找到访问Kibana UI的IP地址和端口，请使用下面的consul-template脚本。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="1ff0" class="nq lj iq nh b gy nr ns l nt nu">cat &lt;&lt;EOF &gt; service.tpl<br/>{{ range service "es-kibana-http" }}{{ .Address }}:{{ .Port }}{{ end }}<br/>EOF</span><span id="2b9e" class="nq lj iq nh b gy nw ns l nt nu"># print result to standout.<br/>consul-template -template service.tpl -dry;<br/>&gt;<br/>10.0.0.200:5601</span></pre><p id="0b18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Kibana UI中，可以在添加数据&gt;示例数据中创建<code class="fe ne nf ng nh b">Sample eCommerce orders</code>，然后看起来是这样的。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/2240195b95641dbcbc8fb842c553d349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWiOUjGJ0L5eMim5qSLnDg.png"/></div></div></figure><p id="58da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以再做一件事来检查在Nomad上重新部署elasticsearch后的数据丢失情况。让我们重新部署弹性搜索工作。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="75b9" class="nq lj iq nh b gy nr ns l nt nu">## stop elasticsearch.<br/>nomad stop -purge -namespace elasticsearch elasticsearch;</span><span id="5f09" class="nq lj iq nh b gy nw ns l nt nu"># run elasticsearch job.<br/>nomad job run elasticsearch.nomad;</span></pre><p id="7028" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">停止并再次部署kibana作业。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="3eb3" class="nq lj iq nh b gy nr ns l nt nu"># stop kibana job.<br/>nomad job stop -purge -namespace elasticsearch kibana</span><span id="182d" class="nq lj iq nh b gy nw ns l nt nu"># run kibana job.<br/>nomad job run kibana.nomad</span></pre><p id="7dea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，您将在Kibana UI中的示例电子商务仪表板中看到没有丢失的数据。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="6c9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们现在所看到的，Nomad目前不支持运行时的<code class="fe ne nf ng nh b">volume</code>节中的变量名插值或动态的卷供应，这应该会在不久的将来得到改进。尽管如此，我认为，Nomad能够以一种简单的方式更好地处理有状态应用程序，而不会丢失数据。</p></div></div>    
</body>
</html>