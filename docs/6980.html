<html>
<head>
<title>Configurable Kong API Gateway with Micronaut Services in Kotlin — A very odd Yucca tribute concert</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可配置的Kong API网关与科特林的Micronaut服务——一场非常奇怪的丝兰致敬音乐会</h1>
<blockquote>原文：<a href="https://itnext.io/configurable-kong-api-gateway-with-micronaut-services-in-kotlin-a-very-odd-yucca-tribute-concert-e0a978618eab?source=collection_archive---------1-----------------------#2022-05-03">https://itnext.io/configurable-kong-api-gateway-with-micronaut-services-in-kotlin-a-very-odd-yucca-tribute-concert-e0a978618eab?source=collection_archive---------1-----------------------#2022-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1764baccc9d5236cda63706df5f15e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EfRx_PvVS2CAer3Z7c90XA.png"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="d809" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">电影《金刚》于1933年4月28日<strong class="kk iu"/><strong class="kk iu"/>上映。快进和大金刚，1994年6月14日发布的电子游戏。孔似乎和大猩猩有着很好的关系。<strong class="kk iu">街头霸王乐队</strong>，虚拟乐队，成立于<strong class="kk iu"> 1998 </strong>。他们与本文无关，但我爱他们的音乐。最后，<strong class="kk iu">孔框架</strong>很晚才发布。他们的第一张专辑于2017年10月发行。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="3559" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">孔的故事开始于<strong class="kk iu"> 2007 </strong>由<a class="ae lg" href="https://konghq.com/blog/author/augusto" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">现任<strong class="kk iu">CEO【2022】</strong>奥古斯图·马利蒂</strong> </a>在米兰的一个车库里。在那里，他创立了MemboxX，成为欧洲最早的数据存储服务提供商之一。两年后，<strong class="kk iu"> Marietti </strong>共同创立了<a class="ae lg" href="https://konghq.com/blog/mashape-has-a-new-homepage" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> Mashape </strong> </a>，其核心是与应用服务器一起提供的功能的“混搭”。该公司迅速转移到美国旧金山。2015年，该公司推出了一个名为Kong的开源项目，并于2017年将该公司更名为Kong Inc .如今(2021)，<strong class="kk iu">孔</strong>是以API网关功能最为人熟知的品牌。然而，<strong class="kk iu">孔</strong>也是其他产品的品牌，如<a class="ae lg" href="https://konghq.com/kong-mesh" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">孔网</strong></a><a class="ae lg" href="https://konghq.com/user-calls/intro-to-insomnia" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">Imsonia</strong></a><a class="ae lg" href="https://konghq.com/kong-konnect" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">Konnect</strong></a>。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="e301" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我第一次听说孔是在几年前(今天是<strong class="kk iu"> 2021 </strong>)，那时候我在网上搜索IT内容时会看到与<strong class="kk iu">孔</strong>相关的代码。我看到了他们的<strong class="kk iu">广告</strong>，也读到了一些关于他们的东西，但是我从来没有真正用过它，或者我从来不知道它到底是干什么用的。有了一点动力，今年我能够花一些时间来弄清楚我能用它做什么。然后我发现<strong class="kk iu">孔</strong>被实现为一个系统的<strong class="kk iu">网关</strong>。在这种情况下，系统可以是任何东西。在我们的例子中，我们将把它作为一个网关，连接到由<strong class="kk iu"> docker-compose </strong>创建的网络。Kong 作为一种代理，我们可以改变一些属性来检测在这样的网络中对我们的应用程序的访问模式。</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/1c1e7a6544c64763e2ac9328ffa5ce3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*x-mXnahg4ud8wOSTyIPUvQ.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><strong class="bd lq">孔标志</strong></figcaption></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="34d8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><a class="ae lg" href="https://github.com/jesperancinha/buy-odd-yucca-concert" rel="noopener ugc nofollow" target="_blank">在本文中，我们将了解如何实现</a> <strong class="kk iu"> API-Gateway，</strong>它能为我们做什么，以及我们如何通过<strong class="kk iu">限速</strong>插件在现实生活中使用它。</p><h1 id="9ba3" class="lr ls it bd lq lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">情况</h1><p id="1a7f" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi translated">我为了做到这一点而创建的工作概念，围绕着一个为预订音乐会门票而创建的应用程序。在这种情况下，我们将实施一个我称之为<strong class="kk iu">丝兰演唱会</strong>的概念。其思想是传递数据，以便尽快释放资源，从而接收更多的数据。这个想法是让一个系统尽可能具有反应能力，允许创建音乐会的门票。在这个<strong class="kk iu">丝兰</strong>概念中，我们有某种队列来接收数据，然后让我们的系统在后台处理它。通过这样做，我们释放了应用程序，以便可以将更多的请求放入队列中，然后以异步方式进行处理。通过允许系统具有反应性，我们还需要确保它能够检测到滥用。滥用系统可以有多种形式，如果你熟悉<strong class="kk iu">道德黑客</strong> g或<strong class="kk iu">软件安全</strong>概念，你就会知道对反应式系统(实际上是任何系统，但可能对反应式系统更是如此)的最大威胁之一是<strong class="kk iu"> DDoS </strong>攻击。<strong class="kk iu"> DDoS </strong>攻击是指<strong class="kk iu">分布式</strong>拒绝<strong class="kk iu">服务</strong>的攻击。防止这种情况的方法是使用像<strong class="kk iu"> Kong </strong>这样的软件网关服务，或者依赖于您的提供商的共享服务，这可以限制您的工作灵活性，并且不允许您安装某些类型的软件。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="6fc1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">但是，在进一步离题之前，让我们先谈谈我们想要达到的目标。在这种情况下，预订票的目的是为了看演出。在这个<strong class="kk iu"> Yucca </strong>概念中，门票与一个或多个强制性音乐会日、可选的一杯或多杯饮料、可选的一餐或多餐以及可选的停车相关联。客户立即获得一个预订参考，然后注册完成。由于<strong class="kk iu">丝兰</strong>提供的大部分音乐会都是在线的，而且预计出席人数会非常多，所以不可能完成注册，因为顾客可以实时在线或在售票处注册门票。因此，我们知道，我们将对不同的票段有不同的最高价格。我们还知道，超过一定的比率，成为<strong class="kk iu"> DDoS </strong>攻击的几率也会增加。根据同样的原则，我们也知道有些人会预订机票，但实际上不会完成请求，也可能会有取消。无论我们计算的门票需求的最大比率是多少，人们也可能会预订一顿饭和一杯饮料。这意味着我们得到的价格是票价的两倍。一场音乐会通常持续3天左右，因此在这种情况下，我们可以考虑门票请求的大致三倍价格值。最后，由于停车位非常有限，费率限制应该低得多。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="2a9f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">那么如果部署后，速率被超越，我们该怎么办？Kong允许我们在一段时间内阻止进一步的请求，并且根据我们可以根据我们的期望定义的标准。我们可以通过这种方式避免<strong class="kk iu"> DDoS </strong>攻击。</p><h1 id="0136" class="lr ls it bd lq lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">体系结构</h1><p id="0505" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi translated">对于实现，我想到的第一个问题是:“我想用什么语言实现这个应用程序？”。考虑到目前JVM领域的新来者,<strong class="kk iu"> Kotlin </strong>的大肆宣传，我决定进一步尝试。自从去年(<strong class="kk iu"> 2021 </strong>)以来，它变得非常强大，这让我有理由去检查它，以及如何将我在<strong class="kk iu">科特林</strong>和<strong class="kk iu">微机器人</strong>的研究结合起来。对于这个具体的例子，我也想尝试一些新的东西，只是想看看它是如何工作的，以及我能从使用一个新的框架中得到什么。因此，一旦确定我想使用<strong class="kk iu"> Kotlin </strong>和<strong class="kk iu"> Micronaut </strong>，我仍然缺少某种流管理系统、队列或其他东西。我只是想要一些我可以注入一些请求，回复客户端并释放资源的东西。实际上，我想让每一个端点都尽可能地具有反应性。所以我添加了<strong class="kk iu"> Redis </strong>并实现了一个<strong class="kk iu">发布者-订阅者</strong>系统，通常用于<strong class="kk iu">反应式</strong> <strong class="kk iu">工程</strong>。“为什么不是<strong class="kk iu">卡夫卡</strong>”。我在这个问题上已经取得了进展，因为卡夫卡是IT世界中的一个巨型框架，似乎这就是我们目前所知道的全部。那和<strong class="kk iu"> Akka </strong>溪流。所以为了做一些对我来说完全新的事情，我选择了Redis。但是我仍然不满意，因为我仍然必须选择，从哪个反应式编程模型中选择。正如我之前所探索的，<strong class="kk iu"> Spring </strong>有webflux，但是在这里我使用的是<strong class="kk iu"> Micronaut。</strong>如今，IT界的另一件大事是<strong class="kk iu">协程。</strong>这就是有人所说的公然抄袭<strong class="kk iu">项目织机</strong>。不管怎样，因为我以前从来没有用过这个，所以我决定实际使用它。至于其他，我使用非常传统的<strong class="kk iu"> Docker/Docker-compose </strong>方式在本地启动容器，没有什么特别的，只是因为如果我添加更高级的启动容器的方式，那将超出本文的范围。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="d90a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在解决我们的架构时，我决定每一个不同的请求类型都将在它自己的服务上运行。在这里，我试图遵循一些非常非常基本的<strong class="kk iu">微服务</strong>架构，其中每个服务都有自己的职责。在下面的序列图中，我们可以看到在代码方面我们要看什么:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/7f60f71e7fee7cd730d141fa16fa12c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6IjFHp8wMDm4A9POp3otA.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><strong class="bd lq">非常粗略的建筑草图</strong></figcaption></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="e950" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">所以在这张图中我们可以有几个玩家，但是唯一对公众开放的玩家是<strong class="kk iu"> yucca-api </strong>。这个应用程序负责生成一个收据id(一个<strong class="kk iu"> UUID </strong>)，并立即返回给客户端。在客户或买家不知情的情况下，机票实际上还没有被处理，甚至还不在数据库中。让我问你一个问题。你有没有收到过类似<strong class="kk iu">“你的请求正在处理中”的邮件。一小时内你会收到你的票。如果您需要致电我们的帮助台，请保留此参考号码。”？</strong>。这正是正在发生的事情。你只是得到一个购买确认，但除此之外，你什么也得不到。与此同时,<strong class="kk iu"> yucca-api </strong>已经获得了您的请求，并为您的机票请求分配了一个刚刚保存到数据库中的收据参考号。然后它会把它运到<strong class="kk iu"> Redis </strong>。<strong class="kk iu">后端</strong>中的监听器现在将取回这个请求，并通过<strong class="kk iu"> REST </strong>将其发送给<strong class="kk iu"> yucca-ticket </strong>。这使得以完全异步的方式处理票据的其余部分成为可能。<strong class="kk iu"> yucca-ticket </strong>以完全相同的方式运行，除了现在，当它被听众拿起时，它将把票分成三部分:<strong class="kk iu">音乐会数据</strong>、<strong class="kk iu">停车数据</strong>和<strong class="kk iu">餐饮数据</strong>。准确地说，它实际上将请求分成四个部分。<strong class="kk iu">餐饮</strong>数据，如果你没注意到，分为<strong class="kk iu">酒水</strong>和<strong class="kk iu">餐食</strong>。一旦完成，将对<strong class="kk iu">三个</strong>不同的<strong class="kk iu"> API的</strong>执行<strong class="kk iu">四个</strong> rest调用。这些是<strong class="kk iu">丝兰餐饮，丝兰音乐会</strong>和<strong class="kk iu">丝兰停车场</strong>。这些服务提供了4个端点。所有这些都没有提供REST调用，因为它们是每张票据执行的最后一个请求。然而，它们也以一种被动的方式处理这些最后的请求，在收到不同的有效载荷后立即响应，并且只花时间将它们设置到由<strong class="kk iu"> Redis </strong>提供的发布-订阅系统。此时，我们已经完成了票证请求，用户只会收到一封电子邮件。这最后一点已经超出了本文的范围。我们可以在下面的序列图中看到整个过程的运行:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/a3d556ffb98fad4d3efd328a70142d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pz_i4BPOAUeH8VQ__hucew.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><strong class="bd lq">丝兰项目顺序图</strong></figcaption></figure><p id="7eee" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">请查看项目主页，以便更好地查看此<a class="ae lg" href="https://github.com/jesperancinha/buy-odd-yucca-concert" rel="noopener ugc nofollow" target="_blank">序列图。</a></p><p id="f8bd" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了理解这一切在数据库中是如何进行的，仔细看看er模型也很重要:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/5627d0953cd79ee7dc6330a38914a0d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rEs1L1N3vFvt7nZpsDiow.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><strong class="bd lq">实体关系模型</strong></figcaption></figure><p id="9aa1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这将允许我们收集在初始有效载荷中发送的所有数据。</p><h1 id="a007" class="lr ls it bd lq lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">履行</h1><p id="54b0" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi translated">实现这个系统确实需要大量的研究，但我还是做了一些事情。一个是<strong class="kk iu">编解码器</strong>，它为我们的REST请求和进出<strong class="kk iu"> Redis </strong>发布-订阅系统的数据流提供有效负载。因为我想让它尽可能通用，所以我用<strong class="kk iu">具体化的</strong>类型创建了它。这只是为了方便起见，也是为了探索Kotlin编程语言。我们稍后会看到为什么这可能是一个可怕的想法:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/1bd5bf5cd25f9556a771ad4968d11e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpoyM7WwWz2-Ime5RgM9jA.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><strong class="bd lq"> readTypedObject具体化和代码实现</strong></figcaption></figure><p id="31c3" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">正如我们所看到的，有两个重要的接口是我们的<strong class="kk iu"> DTO </strong>类型需要遵循的。它们需要是<strong class="kk iu"> <em class="mx">可序列化的</em> </strong>并且它们还需要是<strong class="kk iu"> <em class="mx">类型的</em> </strong>。这只是为了让我们能够将它们序列化为Redis。仅<strong class="kk iu">其余</strong>控制器通常不需要<strong class="kk iu">可串行化</strong>接口。对于不知道<strong class="kk iu">用</strong>是什么的人来说，这是<strong class="kk iu"> <em class="mx">的一个<strong class="kk iu"> <em class="mx">极度含糖版</em> </strong>用<strong class="kk iu"> Java </strong>里的资源</em> </strong>试试。如果你在Kotlin中使用它，你可能甚至不知道这是在做什么，所以如果你还不知道，要小心。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="72cd" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">因为我们也在看数据模型是如何在<strong class="kk iu"> Micronaut </strong>中创建的，所以看一些创建的实体也很重要。在这种情况下，我们将从TicketReservation实体开始，看看一些关系是如何实现的:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/d20670045b9a2b94e90fb53d5cb337b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NEFmOFVa0Aogyuqv--vsaw.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><strong class="bd lq"> <em class="mz">票券预留</em> </strong></figcaption></figure><p id="efbd" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">MappedEntity注释允许我们创建实体。简而言之，实体代表了我们通过代码处理表格的方式。Micronaut 有这样的规定，如果你知道<strong class="kk iu"> Hibernate </strong>你可能已经熟悉了实体。在本文中，它们是完全相同的。假设我们看到的是一个反应式模型，实际的数据库关系，特别是复杂的关系，比如<strong class="kk iu">多对多</strong>、<strong class="kk iu">多对一</strong>、<strong class="kk iu">一对一</strong>和<strong class="kk iu">一对多</strong>几乎没有意义。然而，我们可以使用Join注释做一些其他的事情，这看起来工作得很好。一个票证保留区是个人的，因此我们只能将一个停车保留区与其关联。这在任何意义上都是一对一的关系。一旦预定了停车位，只有一个顾客可以使用，并且一个顾客只能使用一个停车位。这是一个逻辑要求，因为这样我们可以向与会者承诺公平的停车位使用。让我们看一下ParkingReservation的实现:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/f3e4b5e84a601fe9e562eeb6f2d37429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KE70qY-vl-nU578DTHaFpA.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><strong class="bd lq">停车保护</strong></figcaption></figure><p id="085a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这种情况下，ParkingReservation只是一个中间件表，它指向定义停车号的实际停车场表。这就是我们如何分配停车位。表之间的实际关系由连接注释维护:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/2c62a5aa2d0755104e4a575f1fb85e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G-0JSIku51c1xPaIS4FcdQ.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><strong class="bd lq">停止ReservationRepository </strong></figcaption></figure><p id="dda9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果你注意到，机票预订实体本身并没有提及<strong class="kk iu">酒水</strong>、<strong class="kk iu">餐饮</strong>或<strong class="kk iu">演唱会</strong>的预订天数。这将是许多音乐会的许多门票预订、许多饮料的许多门票预订和许多餐饮的许多门票预订的情况。这些关系中的许多关键字与反应式体系结构不匹配。在一个模块化的体系结构中，我们会定义一个餐饮列表、一个饮料列表和一个音乐会日期列表，从而定义多对多的关系，用一个连接表将它们无缝地绑定在一起。饮料和饭菜实际上是菜单中的固定项目，我们真正需要的是它们的预订对应项目。虽然门票预订和饮料之间的关系是多对多关系，但是门票预订和饮料预订之间的关系是一对多关系。换句话说，对于我们拥有的每个机票预订，我们可以进行许多饮料预订，但是所有这些预订只能与一个机票预订相关联，因此是一对多。我们可以将同样的推理应用于餐饮预订和音乐会预订。</p><p id="231e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这个项目中，我们使用使用外键的脚本来创建数据库，尽管在我们的代码中，我们实际上并没有使用和执行<strong class="kk iu">连接</strong>，而是以一种<strong class="kk iu">热切</strong>的方式。以下是这方面的一个例子:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/169f7e0ac4b0cf4fe7701e21d972d219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UY4_5dR6iLl42axKpjyEuw.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><strong class="bd lq">ticker _ reservation _ concert _ day关系</strong></figcaption></figure><p id="9652" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在<strong class="kk iu"> Micronaut的</strong>术语中，正如在<strong class="kk iu"> spring </strong>中一样，一个<strong class="kk iu">表</strong>也被称为一个<strong class="kk iu">关系</strong>。如果您已经注意到，所有重要的<strong class="kk iu">表</strong>都包含一个<strong class="kk iu">引用</strong>字段。该参考字段将给予客户的号码保存在门票中，当音乐会开始时，他们可以在入口处检索凭证和门票。这个项目中没有实现，但是提到它的意图是很重要的。因此，在第一个实例中不使用过去的表。这只是一个展示所使用的表格样式的例子。</p><h1 id="82ce" class="lr ls it bd lq lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">设置孔</h1><p id="c925" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi translated">在学习了一点应用程序是如何设置的之后，我们终于可以开始看看<strong class="kk iu">孔</strong>是如何设置的了。我已经了解了如何在第一个实例中使用PostgreSQL数据库持久化、Kong迁移映像和Kong服务来启动<strong class="kk iu"> Kong </strong>。让我们来看看位于项目根目录下的实际docker-compose.yaml文件中的代码片段:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/a8f972a307df55eaea5545162334d6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*junwbmC3IUT7iA7WSJkRJw.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated"><strong class="bd lq"> Docker撰写启动YAML </strong></figcaption></figure><p id="0122" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">当Kong启动时，我们需要让它运行我们喜欢的模式。因为我想在docker-compose启动时加载设置，所以我别无选择，只能说我不想使用Kong的持久性模型。上面的摘录来自我专门用于集成测试的<strong class="kk iu"> docker-compose-it.yaml </strong>。因此，从上到下，我们首先看到docker-migrations-up服务的声明。这实际上是另一个Kong映像，我们使用它作为runnable来执行到数据库的迁移。如前所述，对于集成测试来说，这在技术上是不必要的。第二个服务是另一个<strong class="kk iu">孔</strong>容器，我们用它来实际运行<strong class="kk iu">孔</strong>。在这个设置中确实有很多要谈的，但是对于本文，我们只关注端口<strong class="kk iu"> 8000 </strong>。这个端口就是我们将要用来访问所有应用程序<strong class="kk iu"> API的端口。Kong </strong>使用这个端口(或者我们想要配置的任何端口)作为网关接入点，将所有流量重定向到目的地<strong class="kk iu"> API </strong>。如果您在前面的图中注意到，在任何情况下都没有对任何<strong class="kk iu">API</strong>的直接访问。我们很快会谈到香港的其他港口。但是首先，我们研究一下<strong class="kk iu"> env </strong>变量。特定的孔变量允许多种配置。允许自动安装加载的有:</p><ul class=""><li id="45cd" class="nd ne it kk b kl km kp kq kt nf kx ng lb nh lf ni nj nk nl bi translated"><strong class="kk iu">孔_数据库</strong> = "关"</li><li id="cf8f" class="nd ne it kk b kl nm kp nn kt no kx np lb nq lf ni nj nk nl bi translated"><strong class="kk iu">孔_声明性_配置</strong> ="/opt/kong/kong.yaml</li></ul><p id="45b8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于<strong class="kk iu">KONG _ DECLARATIVE _ CONFIG</strong>，我正在使用volume <strong class="kk iu">获取那里的配置。/kong:/opt/kong。</strong></p><p id="7999" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我们找到了数据库。在这种情况下，创建的卷允许使用以下启动脚本初始化数据库:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/707a23b5a20029d63107a10acfab01cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRXcer7VSEnOk4HIsGmc7g.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">创建自<a class="ae lg" href="https://github.com/mrts/docker-postgresql-multiple-databases/blob/master/create-multiple-postgresql-databases.sh" rel="noopener ugc nofollow" target="_blank">https://github . com/mrts/docker-PostgreSQL-multiple-databases/blob/master/create-multiple-PostgreSQL-databases . sh</a></figcaption></figure><p id="a138" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这个脚本基本上允许基于不同的名称和文件夹名称创建不同的数据库，并使用不同的data.sql和schema.sql脚本。这使得代码更简洁，更易于使用。我正在使用的文件是由这个文件发展而来的。</p><p id="3c34" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我们可以看看kong文件，它设置了端口、URL和映射:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/d519b127fe5e6c3f7c3d383e710b7090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0XkILmos5jeWEut1uWyOUQ.png"/></div></div></figure><p id="f0be" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这个映射直接与集成测试一起加载。如果我们只是在本地运行我们的设置，那么我们使用不同的方法。</p><p id="962a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">首先我们使用<strong class="kk iu"> docker-compose up </strong>。这将启动所有的东西和容器，直到它稳定下来。一旦启动完成，我们需要将这个配置文件手动注入到<strong class="kk iu">孔</strong>中。为此，<strong class="kk iu"> Kong </strong>提供了一个名为<a class="ae lg" href="https://docs.konghq.com/deck/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> deck </strong> </a> <strong class="kk iu">的小工具。</strong>请查看他们的<a class="ae lg" href="https://docs.konghq.com/deck/" rel="noopener ugc nofollow" target="_blank">网站</a>了解更多关于如何安装的信息。在我创建的<strong class="kk iu"> Makefile，</strong>中，有一条我们可以用来自动完成这项工作的指令，这里我使用一个小的<strong class="kk iu"> bash </strong>轮询技巧来检查<strong class="kk iu"> Kong </strong>是否已经启动。轮询本身位于<strong class="kk iu"> kong_wait.sh </strong>文件中:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/4f931312d8644c4c842cbbdec1bc9e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXLNFO-80P91KA_awsaB1w.png"/></div></div></figure><p id="9c15" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，在<strong class="kk iu"> Makefile </strong>中，我们可以看到这段代码，它调用了:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/4dfae25be5309c4cba986660b901a380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EazTdvRp80BrUaD284vaw.png"/></div></div></figure><p id="6809" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">需要知道的是<strong class="kk iu"> kong.yaml </strong>文件是<strong class="kk iu">端点</strong>的<strong class="kk iu">配置</strong>文件。在速率限制方面，我们可以使用<strong class="kk iu"> REST </strong>调用。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="0792" class="lr ls it bd lq lt nu lv lw lx nv lz ma mb nw md me mf nx mh mi mj ny ml mm mn bi translated">奔跑的孔</h1><p id="a9ee" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi translated">正如我之前提到的，端口<strong class="kk iu"> 8000 </strong>是至关重要的，以便访问不同的API，并允许Kong对请求执行网关过滤。在这个项目中，我们正在研究限速。速率限制可以分别应用于路径和不同的<strong class="kk iu"> API的</strong>。我们可以看到这些<strong class="kk iu"> API </strong>的每个定义都单独使用另一个<strong class="kk iu">孔API。</strong>在端口<strong class="kk iu"> 8001 </strong>上，该API被打开，并遵循我们自己的配置。在本节中，我们将运行我们的应用程序，因此现在请在根目录下运行以下命令:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1d503c8b3cf44ac77c4c90d279b7e7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*U24dWFzoXx-UfJGOIOH-zg.png"/></div></figure><p id="1499" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这将运行我们之前看到的<strong class="kk iu"> docker </strong>命令。如果一切运行顺利，您应该让所有容器运行。完成后，请在<a class="ae lg" href="http://localhost:8001." rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">上打开浏览器http://localhost:8001。</strong> </a>在这里你会发现<strong class="kk iu">孔</strong>里面的各种配置列表。这只是热身的样子。现在请看这个网址:<a class="ae lg" href="http://localhost:8001/plugins" rel="noopener ugc nofollow" target="_blank">http://localhost:8001/plugins</a>。您应该会看到一个插件列表。其中一个可能与此类似:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/32527e0ddc7b76324e2cabf73bb5adf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUOdI8nSrQBLBqJ0DAtlHg.png"/></div></div></figure><p id="5376" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这意味着<strong class="kk iu">速率限制</strong>处于活动状态，在这种情况下，我们限制每秒<strong class="kk iu"> 1 </strong>个请求，每小时<strong class="kk iu"> 10000 </strong>个请求。在这一点上知道<strong class="kk iu">孔</strong>不允许您进行重叠配置也很重要。例如，如果您只允许每小时发出<strong class="kk iu"> 1 </strong>个请求，这意味着您每秒只能发出<strong class="kk iu"> 60 * 60 </strong> = <strong class="kk iu"> 3600 </strong>个请求。如果您配置的时间超过了<strong class="kk iu">秒</strong>，那么<strong class="kk iu">孔</strong>将会正确地让您知道<strong class="kk iu">秒</strong>限制与<strong class="kk iu">小时</strong>限制相冲突，它将会返回这样一条消息:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/e6b86f4084c5ee71f218028b1e21e248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SAMdeCeJ9xbsitByMloRKA.png"/></div></div></figure><p id="c17c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">但是现在，我们还没有插件配置，所以让我们开始吧。请在命令行中运行以下命令:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/b9204d5b84f49202d3dc3a6853e480aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rvY4ukMY1V8TpaolkRJVQ.png"/></div></div></figure><p id="ea20" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这仅仅意味着<strong class="kk iu"> API </strong>现在有了一个插件，在实践中，每秒钟只允许通过网关推送多达<strong class="kk iu"> 1 </strong>个请求。本质上，我们限制我们的音乐会以每秒1次的速度创作。所有其他人都将得到一个错误。在这种情况下，我们希望我们的分析以及我们如何着手评估请求尽可能透明。这就是为什么我们将<strong class="kk iu"> local、true </strong>和<strong class="kk iu"> false </strong>的默认值分别设置为<strong class="kk iu"> config.policy、config.fault_tolerant </strong>和<strong class="kk iu">config . hide _ client _ headers</strong><strong class="kk iu">。</strong></p><p id="e069" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们准备开始轨迹。在另一个命令行上，请运行以下命令:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/0342528dcaff85315f758ce4e7103ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*lpwZuewul2wEg-MyrKFTzQ.png"/></div></figure><p id="83ec" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这会引发蝗虫。如果你不知道蝗虫，这基本上是一个基准工具。了解如何将其直接安装在<a class="ae lg" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank">源</a>处。我们对性能测试不感兴趣。相反，我们希望在实践中看到<strong class="kk iu">限速</strong>是如何工作的。也许现在看一下我们的测试用例是个好主意。我们先来看看位于<strong class="kk iu"> /locust/welcome: </strong>的python中的任务脚本</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/ac0106b9a3271fc7401f666c92f6bf65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gLODw9CNLgIeMKusCg0MZw.png"/></div></div></figure><p id="fe7f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这些Id是对我们数据库中数据的引用。我正在修正每秒执行一次最低限度<strong class="kk iu">的请求</strong>。在蝗虫术语中，这意味着<strong class="kk iu">每只蝗虫每秒执行一次这个任务</strong>。由于该任务执行两个post请求，这意味着我们每秒至少发出<strong class="kk iu"> 2个请求</strong>。请求是固定的。被调用的函数调用<strong class="kk iu"> API </strong>:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/cc6285ac4b81dc7572d4850d8c7db7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mjoaQtlDxqC6BH-MVIeu2g.png"/></div></div></figure><p id="f1fa" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><strong class="kk iu">有效载荷</strong>只是一个人预订一杯饮料、一顿饭、一个停车位和一场音乐会的一般格式的表示。我们将使用这些数据来确保我们能够执行测试:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/25ef14b9ff5c5b17d6ca35b9274916a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOuPP9j5vRX25BgUHqNJ7Q.png"/></div></div></figure><p id="4337" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们准备开始我们的<strong class="kk iu">蝗虫</strong>测试。如果您注意到命令行日志中有这样的内容:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/0d8f18ae1cb430636b71f2d89000c2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_JBznYAtbYwGDoio60pkg.png"/></div></div></figure><p id="1ea8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果你运行的是一个好的终端，你应该可以点击链接直接进入<a class="ae lg" href="http://localhost:8089" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">http://localhost:8089</strong></a><strong class="kk iu">:</strong></p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/406766e7cbfe0dc6cd9238272465f858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*21bZjx044b97EUL2HYq4Rw.png"/></div></div></figure><p id="c8e2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">就顺其自然吧。它将<strong class="kk iu">启动一个用户</strong>，并以每秒<strong class="kk iu"> 1的速度</strong>产生更多用户。这意味着，由于我们将<strong class="kk iu">孔</strong>配置为在<strong class="kk iu"> yucca-api </strong>网关上以每秒<strong class="kk iu"> 1个请求</strong>的速率<strong class="kk iu">最大</strong>发出请求，我们几乎没有向<strong class="kk iu">网关</strong>发送请求。我们会出错。我们的日志将如下所示:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/dcfb0b51284445f81c1477ed06ded19b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_gmYHyPnm0cpGpFpEMa7Q.png"/></div></div></figure><p id="7bc6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">所以<strong class="kk iu">孔</strong>，现在配置为每秒只接受一个请求，将不能每秒接受<strong class="kk iu"> 2个请求</strong>，如果你以前注意过，这正是我们的蝗虫任务所做的。让蝗虫继续跑吧。</p><p id="9bbe" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在我们的命令行中，当您运行第一个请求时，应该会得到类似这样的结果:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/bd429312cc3a7c08b5aa2aef625fec11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92X7gDwtTg1rWqZMIal78w.png"/></div></div></figure><p id="230c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这意味着我们已经激活了一个插件，并将其命名为<strong class="kk iu">限速</strong>。这也是我们可以为<strong class="kk iu">孔激活的插件地图的关键。</strong>我们现在想改变费率，所以我们需要移除这个插件并创建一个新的。在这种情况下，我们需要指出我们想要删除的插件的id。在我们的例子中，它是:<strong class="kk iu">0ff 09073–3e 16–4442-ac78–428 b 25818 b7f:</strong></p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/0aa6091c02c03b1e08fdd80252fa8780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7FNyGC5rBAQeL4-2zRwqqg.png"/></div></div></figure><p id="cb69" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在，我将向您展示我们如何在运行中改变这个现场<strong class="kk iu"/>。只要确保蝗虫<strong class="kk iu">还在运行。</strong>立即运行该命令:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/44ab8c019eaba32e7c5e19101eb79dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ncPxk5qzGCjAJf4cSkg8Tw.png"/></div></div></figure><p id="c9d6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">您现在应该不会收到任何错误:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/29a2860f3aa8ead7fe0ab548f7d4bec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IifWvvSbikNLoFGnhKepnQ.png"/></div></div></figure><p id="81f6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">从这一点开始，你应该了解如何改变其他<strong class="kk iu">请求</strong>的速率。请随意尝试，在所有子请求上尝试不同的组合。</p><h1 id="58c8" class="lr ls it bd lq lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">问答</strong></h1><pre class="li lj lk ll gt og oh oi oj aw ok bi"><span id="d152" class="ol ls it oh b gy om on l oo op"><strong class="oh iu">"How do we know when the ticket is complete in the back end?"</strong></span></pre><p id="fd97" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">因为我们异步处理票据，所以实际上没有办法以异步的方式知道这一点。我们最不希望的就是加入所有这些过程，然后等待它们在某个地方结束。这也是不可能的，因为不同的服务应该被允许在不同的机器、领域、区域和域上工作，使得多线程控制不可能。可以做的是使用某种轮询系统来检查所有的数据库元素何时被接收并被正确地保存到数据库中。它应该在一个单独的服务，将通过数据库爬行和验证这些信息。</p><h1 id="9c95" class="lr ls it bd lq lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="6c25" class="pw-post-body-paragraph ki kj it kk b kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf im bi translated">感谢你和我一起关注这个项目，并乐于看到一切是如何运作的。希望已经给你很好的介绍了<strong class="kk iu">孔</strong>中<strong class="kk iu">限速</strong>的基础知识。利用<strong class="kk iu">孔</strong>，我们可以做的不仅仅是<strong class="kk iu">限速。孔有无限的选择和可能。</strong></p><p id="a40f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">关于<strong class="kk iu"> Micronaut </strong>，我真的相信它是Spring的一个很好的竞争对手，我特别喜欢这个想法，它让我把注意力集中到工程问题上，而不是当前围绕代码美的<strong class="kk iu">炒作</strong>。这是我用<strong class="kk iu"> Spring </strong>没有真正经历过的事情。对于<strong class="kk iu"> Micronaut </strong>，仅仅作为一个例子，我不得不考虑<strong class="kk iu">注释处理器</strong>，并选择其中哪一个对我的开发很重要。这是我在其他企业框架中没有见过的。Micronaut 迫使我们在很低的层次上思考我们做了什么，而其他框架似乎为我们做了很多事情，这可能是一个苦乐参半的礼物。</p><p id="53bb" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">关于<strong class="kk iu"> Kotlin，</strong>这个项目让我进一步加深了对这种<strong class="kk iu">新语言</strong>和似乎是让所有人神魂颠倒的技术<strong class="kk iu">的怀疑。在这里，我必须诚实地说，如果我比较Java的发展方式和Kotlin闯入IT领域的方式，我认为我的灵魂仍然是分裂的。尽管这种新语言有很多优点，但它开始看起来更像是JVM世界的美丽，而不是面向工程的语言。我可以说，使用<strong class="kk iu"> </strong>的东西，比如</strong>的<strong class="kk iu">，<strong class="kk iu">具体化了</strong>，并且不用考虑我是<strong class="kk iu">实现了</strong>还是<strong class="kk iu">扩展了</strong>也删除了相当多的语言词汇，我们在思考过程中需要词汇和<strong class="kk iu">语义</strong>。由<strong class="kk iu"> Kotlin </strong>带来的关于<strong class="kk iu">【不必】</strong>的整个哲学也扩展到了<strong class="kk iu">实用程序</strong> <strong class="kk iu">函数</strong>的使用，我们现在把它作为<strong class="kk iu">扩展</strong>函数。有时你会在<strong class="kk iu">接口</strong>、<strong class="kk iu">类</strong>、<strong class="kk iu">伴随对象</strong>或<strong class="kk iu">中看到它们，无论它们在哪里，</strong>你都会发现它们非常符合<strong class="kk iu">墨菲定律</strong>。现在<strong class="kk iu">这个有问题</strong>吗？<strong class="kk iu">不是直接</strong>，但是我已经在<strong class="kk iu"> Kotlin </strong>世界见证了太多我在<strong class="kk iu"> Java </strong>世界不习惯看到的<strong class="kk iu">风格讨论</strong>。例如使用<strong class="kk iu"> findById()？</strong>就是“<strong class="kk iu">那么丑，你怎么能这样？</strong>”，因为“<strong class="kk iu"> findByIdOrNull更像</strong>Kotlin”。有研究表明<strong class="kk iu">快捷方式</strong>和<strong class="kk iu">分割</strong>语言(不仅仅是编程)可能会潜在地损害我们的思维方式，因为它<strong class="kk iu">限制了我们的表达选择</strong>。但是，嘿，我只是不允许自己跳进这样的想法，即<strong class="kk iu"> Java </strong>比<strong class="kk iu"> Kotlin </strong>差。在这个项目中，我做了很多让我的生活更轻松的事情。但是我注意到，例如，我甚至不需要考虑原语。</strong> No <strong class="kk iu"> int，no long，no float，not double </strong>。这只是一种动力，因为我一直在Kotlin为我的项目工作，我甚至没有想过。<strong class="kk iu">但我知道它们是什么</strong>。正因为如此，我一直有这个疑问。如果我没有<strong class="kk iu"> Java </strong>的背景，我会明白我现在做的关于<strong class="kk iu"> Kotlin的事情吗？我越来越觉得我不会。然而<strong class="kk iu">给</strong>留下深刻印象的是<strong class="kk iu">协程</strong>的想法，但是随着项目<a class="ae lg" href="https://openjdk.java.net/projects/loom/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"/></a>持续多年，现在才出现，对于这两个彼此非常相似的想法，我应该得出什么结论呢？</strong></p><p id="2adf" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我必须说，我非常高兴为这篇文章研究了<strong class="kk iu"> Micronaut </strong>和<strong class="kk iu"> Kong </strong>。不过，我不确定该怎么看待<strong class="kk iu">科特林</strong>。我想我的下一个项目将会是最新的<strong class="kk iu"> Java </strong>版本，也许之后我会将<strong class="kk iu"> Java </strong>与<strong class="kk iu"> Kotlin </strong>进行对比。使用<strong class="kk iu"> Redis </strong>作为我的项目的一种快速解决方案的救生艇，一个<strong class="kk iu">队列</strong>系统就像一个<strong class="kk iu">魔咒</strong>一样工作，我对此非常满意。</p><p id="9e60" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我已经将这个应用程序的所有源代码放在了<a class="ae lg" href="https://github.com/jesperancinha/buy-odd-yucca-concert" rel="noopener ugc nofollow" target="_blank"> GitLab </a>中</p><p id="12c1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我希望你能像我喜欢写这篇文章一样喜欢它。</p><p id="d918" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我很想听听你的想法，所以请在下面留下你的评论。</p><p id="d959" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">感谢您的阅读！</p><div class="oq or gp gr os ot"><a href="https://www.zsiegel.com/2022/01/25/Micronaut-JDBC-R2DBC-Flyway-multiple-schemas" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">使用Micronaut数据、JDBC、R2DBC、TestContainers和具有多个模式的Flyway</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">支持exdividend.app的核心开源项目之一是Micronaut。Micronaut是基于全栈JVM的…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">www.zsiegel.com</p></div></div></div></a></div><div class="oq or gp gr os ot"><a href="https://blog.pallav.dev/realtime-testing-micronaut-postgres-and-testcontainer" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">实时测试:Micronaut、Postgres和Testcontainer</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">直到现在，我们才能够使用H2数据库，使用JDBC在Micronaut中创建应用程序。我们甚至能够…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">blog.pallav.dev</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph jz ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://dev.to/mkbaldwin/micronaut-a-five-minute-introduction-c27" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">Micronaut:五分钟的介绍。</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">Micronaut是一个新的开源Java/JVM框架，用于创建微服务应用程序。发展由…引领</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">开发到</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph jz ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://docs.konghq.com/gateway/2.6.x/plan-and-deploy/licenses/deploy-license/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">部署企业许可证- v2.8.x | Kong文档</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">将企业许可证部署到Kong Gateway安装中，以访问特定于企业的功能。</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">docs.konghq.com</p></div></div><div class="pc l"><div class="pj l pe pf pg pc ph jz ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://docs.konghq.com/gateway/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">Kong Gateway - v2.8.x | Kong文档</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">Kong Gateway是一个轻量级、快速、灵活的云原生API网关。API网关是一个反向代理，它允许…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">docs.konghq.com</p></div></div><div class="pc l"><div class="pk l pe pf pg pc ph jz ot"/></div></div></a></div></div></div>    
</body>
</html>