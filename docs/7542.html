<html>
<head>
<title>Use TypeScript Record Types for Better Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript记录类型以获得更好的代码</h1>
<blockquote>原文：<a href="https://itnext.io/use-typescript-record-types-for-better-code-ce1768c6cb53?source=collection_archive---------0-----------------------#2022-10-29">https://itnext.io/use-typescript-record-types-for-better-code-ce1768c6cb53?source=collection_archive---------0-----------------------#2022-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5ffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript <code class="fe kl km kn ko b">Record</code>是TypeScript中我最喜欢的实用程序类型之一，但我发现它不太受重视。</p><p id="67f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当充分利用它的潜力时，无论您是在后端还是前端使用TypeScript，它都可以帮助团队编写更好、更少出错、更易维护的代码(尤其是当您同时在后端和前端使用TypeScript时！);我向你保证，你会在5分钟之内写出更好的代码。</p><p id="6e1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kp" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type" rel="noopener ugc nofollow" target="_blank">该实用程序类型的文档非常少</a>:</p><blockquote class="kq kr ks"><p id="83ec" class="jn jo kt jp b jq jr js jt ju jv jw jx ku jz ka kb kv kd ke kf kw kh ki kj kk ij bi translated">构造一个对象类型，其属性键为<code class="fe kl km kn ko b">Keys</code>，属性值为<code class="fe kl km kn ko b">Type</code>。该实用工具可用于将一种类型的属性映射到另一种类型。</p></blockquote><p id="5b7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且并没有暴露出<code class="fe kl km kn ko b">Record</code>型的真正<strong class="jp ir"> <em class="kt">超能力</em> </strong>:强制执行穷尽式办案。</p><p id="9b1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过一个简单的React示例来看看如何使用这个特性编写更好的代码。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="c5af" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">了解记录类型</h1><p id="c9ad" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">如果我们这样定义一个类型:</p><pre class="mh mi mj mk gt ml ko mm mn aw mo bi"><span id="d7cd" class="mp lf iq ko b gy mq mr l ms mt">type Fruit = 'Apple' | 'Banana' | 'Cherry'</span></pre><p id="18f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后使用该类型作为<code class="fe kl km kn ko b">Record</code>的键:</p><pre class="mh mi mj mk gt ml ko mm mn aw mo bi"><span id="421d" class="mp lf iq ko b gy mq mr l ms mt">const fruitScientificNames: <strong class="ko ir">Record&lt;Fruit, string&gt;</strong> = {</span><span id="b0c6" class="mp lf iq ko b gy mu mr l ms mt">}</span></pre><p id="c66f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们会注意到TypeScript立即给我们一个警告:</p><figure class="mh mi mj mk gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mv"><img src="../Images/a7365e1e67d4905c585ac1e9f669b28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVvL6qc3eViVyoWJRgLAjA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">TypeScript希望记录中包含union Fruit中定义的每个值的条目。</figcaption></figure><p id="8141" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，我们需要在<code class="fe kl km kn ko b">Record</code>中为每个<code class="fe kl km kn ko b">Fruit</code>添加一个条目:</p><figure class="mh mi mj mk gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nh"><img src="../Images/0cb040d463ffe9b21fd45688c09ecdc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eO6_Pq7pUG3-5cCouQ8Tzg.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">现在我们的错误被清除了。</figcaption></figure><p id="a688" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在<code class="fe kl km kn ko b">Fruit</code>中添加另一个条目:</p><pre class="mh mi mj mk gt ml ko mm mn aw mo bi"><span id="3c66" class="mp lf iq ko b gy mq mr l ms mt">type Fruit = 'Apple' | 'Banana' | 'Cherry' <strong class="ko ir">| </strong>'<strong class="ko ir">Dragonfruit'</strong></span><span id="1e51" class="mp lf iq ko b gy mu mr l ms mt">const fruitScientificNames: Record&lt;Fruit, string&gt; = {<br/>  Apple: 'Malus',<br/>  Banana: 'Musa',<br/>  Cherry: 'Prunus'<br/>}</span></pre><p id="3681" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再次得到一个错误，因为我们没有为“Dragonfruit”添加一个条目:</p><figure class="mh mi mj mk gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mv"><img src="../Images/3780a467c1ed2a9ae5ba5ade9c0519d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5G-xqjsGKgWhYRi3RD4pCA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">TypeScript将要求我们在记录中添加一个Dragonfruit条目。</figcaption></figure><p id="af25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这本身就很有趣，但是我们如何利用<code class="fe kl km kn ko b">Record</code>类型的这一特性来编写更好、更易维护的代码呢？</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="bf79" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对记录类型做更多事情</h1><p id="494e" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">需要理解的另一件事是，我们并不局限于<code class="fe kl km kn ko b">Record</code>中的字符串；我们可以像函数一样保存值槽中的任何内容:</p><pre class="mh mi mj mk gt ml ko mm mn aw mo bi"><span id="2e1b" class="mp lf iq ko b gy mq mr l ms mt">const fruitWriter: Record&lt;Fruit, <strong class="ko ir">() =&gt; void</strong>&gt; = {<br/>  Apple: () =&gt; console.log('Apple'),<br/>  Banana: () =&gt; console.log('Banana'),<br/>  Cherry: () =&gt; console.log('Cherry')<br/>}</span><span id="e2f6" class="mp lf iq ko b gy mu mr l ms mt">// Now we can invoke like this:<br/>fruitWriter['Apple']()</span></pre><p id="0c76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">Record</code>现在将一个<code class="fe kl km kn ko b">Fruit</code>映射到一个没有参数也不返回值的函数。</p><p id="aa6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们不限于简单的函数，我们当然可以指定参数:</p><pre class="mh mi mj mk gt ml ko mm mn aw mo bi"><span id="0406" class="mp lf iq ko b gy mq mr l ms mt">// Function to lowercase an input string.<br/><strong class="ko ir">const lowerFn = (text: string) =&gt; text.toLocaleLowerCase()</strong></span><span id="58c4" class="mp lf iq ko b gy mu mr l ms mt">const lowercaseFruitWriter: Record&lt;<br/>  Fruit,<br/>  ( <strong class="ko ir">fn: (text: string) =&gt; string</strong> ) =&gt; void<br/>&gt; = {<br/>  Apple: (<strong class="ko ir">fn</strong>) =&gt; console.log(<strong class="ko ir">fn</strong>('Apple')),<br/>  Banana: (<strong class="ko ir">fn</strong>) =&gt; console.log(<strong class="ko ir">fn</strong>('Banana')),<br/>  Cherry: (<strong class="ko ir">fn</strong>) =&gt; console.log(<strong class="ko ir">fn</strong>('Cherry'))<br/>}</span><span id="096e" class="mp lf iq ko b gy mu mr l ms mt">// Prints 'apple'<br/>lowercaseFruitWriter['Apple'](<strong class="ko ir">lowerFn</strong>)</span></pre><p id="d6a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和返回类型:</p><pre class="mh mi mj mk gt ml ko mm mn aw mo bi"><span id="e483" class="mp lf iq ko b gy mq mr l ms mt">const lowerFn = (text: string) =&gt; text.toLocaleLowerCase()</span><span id="4970" class="mp lf iq ko b gy mu mr l ms mt">const lowercaseFruitWriter: Record&lt;<br/>  Fruit,<br/>  ( fn: (text: string) =&gt; string ) =&gt; <strong class="ko ir">string</strong><br/>&gt; = {<br/>  Apple: (fn) =&gt; fn('Apple'),<br/>  Banana: (fn) =&gt; fn('Banana'),<br/>  Cherry: (fn) =&gt; fn('Cherry')<br/>}</span><span id="3df5" class="mp lf iq ko b gy mu mr l ms mt"><strong class="ko ir">console.log</strong>(lowercaseFruitWriter['Apple'](lowerFn))</span></pre><p id="f680" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了它，我们现在可以做更多有趣的事情，比如构建和返回React组件，定义一系列验证器函数，或者执行一些特定于水果的操作。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="efc2" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不易出错的代码</h1><p id="f812" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">在许多情况下，当构建UI或后端逻辑时，会出现代码必须基于鉴别器值执行某些操作的情况。</p><p id="d3df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，这将通过<code class="fe kl km kn ko b">switch-case</code>或<code class="fe kl km kn ko b">if-elseif-else</code>来完成。</p><pre class="mh mi mj mk gt ml ko mm mn aw mo bi"><span id="e502" class="mp lf iq ko b gy mq mr l ms mt">function fruitPrinter(fruit: Fruit) {<br/>  switch (fruit) {<br/>    case 'Apple':<br/>      console.log('apple')<br/>      break<br/>    case 'Banana':<br/>      console.log('banana')<br/>      break<br/>    default:<br/>      console.log('')<br/>  }<br/>}</span></pre><p id="ce27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了更加冗长之外，<strong class="jp ir">这里真正的问题是，如果我们给</strong> <code class="fe kl km kn ko b">Fruit</code> <strong class="jp ir">添加另一个值，我们将不会被通知我们需要更新代码的所有位置，以处理这个新情况</strong>。相反，<strong class="jp ir"> <em class="kt">在运行时</em> </strong>，代码会落入<code class="fe kl km kn ko b">default</code>块，呈现给用户一些不希望的行为。</p><p id="4f17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果每次添加新的<code class="fe kl km kn ko b">Fruit</code>时，编译器都会通知我们代码中所有需要更新的地方，这不是很好吗？</p><p id="dd74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kt">有了</em> </strong> <code class="fe kl km kn ko b">Record</code> <strong class="jp ir"> <em class="kt">，我们就能在编译时找到这些漏洞，写出更安全的代码。</em> </strong></p><p id="63f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在React中利用这一点，而不是使用<code class="fe kl km kn ko b">switch-case</code>或<code class="fe kl km kn ko b">if-else</code>进行条件渲染:</p><figure class="mh mi mj mk gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ni"><img src="../Images/02eb7afd566536a87ae249cd9317b34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8xce_oS2NC_8vkY2PeL0A.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">这是一个非常简单的例子，说明我们如何使用记录来确保我们总是有水果的成分。注意我们<strong class="bd lg">不需要</strong>的东西:if-else或switch-case！</figcaption></figure><figure class="mh mi mj mk gt mw gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/bc60230b54d59ac9c5e8b175abbeded4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/1*7gv0w9magGua-3mT2_s99g.gif"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">我们简单的应用程序和组件</figcaption></figure><p id="3c6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是真正的优势在于添加“Dragonfruit”会导致开发/构建时出错:</p><figure class="mh mi mj mk gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nk"><img src="../Images/2d67a6970255f45b92fbb00f78b0c97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_SX9XilUUWX1zQPI2steA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">我们的记录缺少一个“火龙果”条目</figcaption></figure><p id="98bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使是中等规模的代码库，这也会在正确处理新案例方面产生巨大的差异，因为引入新的选项会立即提醒我们必须在代码库中添加该选项的处理。</p><blockquote class="nl"><p id="26a8" class="nm nn iq bd no np nq nr ns nt nu kk dk translated"><code class="fe kl km kn ko b">Record</code>式的真<strong class="ak"> <em class="nv">超能力</em> </strong>:强制执行穷尽式办案</p></blockquote><p id="827e" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">考虑到我们的选项不是水果，而是<code class="fe kl km kn ko b">IdentityProvider</code> s或<code class="fe kl km kn ko b">DatabaseType</code> s或<code class="fe kl km kn ko b">ApiEndpoint</code> s。使用<code class="fe kl km kn ko b">Record</code>，我们可以很容易地确保无论何时添加新选项，前端和后端都可以在开发/构建时而不是运行时正确地处理新情况。</p><p id="6e74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于TypeScript执行了详尽的案例处理，我们不仅使应用程序更容易维护，我们还将代码流从<em class="kt">程序性的</em>转移到<em class="kt">结构性的</em>；换句话说，<strong class="jp ir"> <em class="kt">我们用结构来支配流程的控制</em> </strong> <em class="kt">。</em></p><p id="56df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想看如何使用<code class="fe kl km kn ko b">Record</code>类型创建<code class="fe kl km kn ko b">Factory</code>设计模式的例子，可以看看我的另一篇文章:<a class="ae kp" href="https://medium.com/codex/structural-control-flow-with-object-oriented-programming-part-2-7d18526146de" rel="noopener"> <strong class="jp ir">面向对象编程的结构化控制流</strong> </a> <strong class="jp ir"> : </strong></p><pre class="mh mi mj mk gt ml ko mm mn aw mo bi"><span id="e8fd" class="mp lf iq ko b gy mq mr l ms mt">// The Record holds a constructor; how cool is that?<br/>const shippingStrategies: Record&lt;<br/>  ShippingMethod, {<br/>  <strong class="ko ir">new(weight: number, hasLiquid: boolean): ShippingStrategy</strong><br/>}&gt; = {<br/>  USPS: UspsShippingStrategy,<br/>  UPS: UpsShippingStrategy,<br/>  FedEx: FedExShippingStrategy,<br/>  DHL: DhlShippingStrategy<br/>}</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="987a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这篇关于TypeScript的<code class="fe kl km kn ko b">Record</code>类型的短文能帮助您理解如何利用其隐藏的超强能力来编写更好、更易维护的代码！使用TypeScript的前端和后端团队都可以利用这个简单的构造来显著提高可维护性和正确性，同时还简化了代码，几乎没有额外的负担！</p><p id="5838" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢这篇文章，可以看看我写的其他文章，给我一个关注，并在<em class="kt">Twitter</em><strong class="jp ir"><em class="kt"/></strong><a class="ae kp" href="https://twitter.com/chrlschn" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kt">@ chrlschn</em></strong></a><strong class="jp ir"><em class="kt"/></strong><em class="kt">或</em><strong class="jp ir"><em class="kt"/></strong><a class="ae kp" href="https://www.linkedin.com/in/charlescchen/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kt">LinkedIn</em></strong></a><strong class="jp ir"><em class="kt">。</em> </strong>同时查看我当前的项目<a class="ae kp" href="https://turas.app" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kt">turas . app</em></strong></a>。</p></div></div>    
</body>
</html>