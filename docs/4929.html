<html>
<head>
<title>OpenShift Service Mesh essentials — Part IV — Features: Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenShift服务网格基础—第四部分—功能:路由</h1>
<blockquote>原文：<a href="https://itnext.io/openshift-service-mesh-essentials-part-iv-features-routing-3189dae64615?source=collection_archive---------1-----------------------#2020-10-26">https://itnext.io/openshift-service-mesh-essentials-part-iv-features-routing-3189dae64615?source=collection_archive---------1-----------------------#2020-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3b22f972264c3a8d2432819e70bea11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJw27t_0-OXuHIr0zl322Q.jpeg"/></div></div></figure><p id="a9c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本系列的第一篇文章中，我们解释了为什么服务网格作为您的架构的一部分是有用的。</p><div class="kz la gp gr lb lc"><a href="https://medium.com/swlh/openshift-service-mesh-essentials-part-i-the-why-and-what-of-it-a3ef09bf8aa8" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">open shift Service Mesh Essentials—第一部分—原因和内容</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">在这第一篇文章中，我们将讨论一些关于OpenShift服务网格的介绍性问题，包括它的特性…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">medium.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq jz lc"/></div></div></a></div><p id="f156" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将开始配置服务网格，以更好地理解我们当时谈到的它的主要好处之一:高级路由。您可以使用这一功能来修改您的应用程序的行为，而不必在您的微服务中包含作为API网关或附加代码的外部部分。</p><p id="8da0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将谈到一些我们已经讨论过的控制平面和数据平面概念，因此如果您没有阅读之前的文章，我鼓励您阅读:</p><div class="kz la gp gr lb lc"><a href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">OpenShift服务网格基础—第二部分—控制平面</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">在第二篇文章中，我们将介绍OpenShift服务网格控制平面的准备和部署。</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">luis-javier-arizmendi-alonso.medium.com</p></div></div><div class="ll l"><div class="lr l ln lo lp ll lq jz lc"/></div></div></a></div><div class="kz la gp gr lb lc"><a href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-iii-data-plane-341ce477c269" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">OpenShift服务网格基础—第三部分—数据平面</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">在本文中，我们将通过展示一个应用程序部署来探索OpenShift服务网格数据平面…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">luis-javier-arizmendi-alonso.medium.com</p></div></div><div class="ll l"><div class="ls l ln lo lp ll lq jz lc"/></div></div></a></div><h1 id="b81e" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">部署示例应用程序</h1><p id="8b5a" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">我将使用与您在Istio文档中找到的相同的经典<a class="ae mw" href="https://istio.io/latest/docs/examples/bookinfo/" rel="noopener ugc nofollow" target="_blank">示例应用程序:Bookinfo </a></p><p id="31a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该应用程序由四个主要部分组成:产品页面(登录页面)、有三个不同版本的评论(星级变化，从v1的无到v3的红星)、详细信息和评级。</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/1b914c8bcd8c27dba9f39e710e5f81ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVxZMwjBnVHJLSsdf6oDqQ.png"/></div></div></figure><p id="7a07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在这里仔细检查部署YAML <a class="ae mw" href="https://raw.githubusercontent.com/istio/istio/release-1.4/samples/bookinfo/platform/kube/bookinfo.yaml" rel="noopener ugc nofollow" target="_blank">，但是那些不包括我们在OpenShift中需要的边车注入注释。为了简化操作，我将创建一个定义整个应用程序的对象，这很有用，因为使用Web控制台上的“+”按钮一次只能创建一个对象。我们这里有两个选项来将多个对象包含在一个单独的对象中，使用<em class="nc">种类:列表</em>或<em class="nc">种类:模板</em>。</a></p><p id="fb6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">唯一能在“+”按钮中工作的将是Template，所以这是我将使用的一个，但是请记住，当您使用这种技术创建模板时，您将需要在第二步中“提供”该模板。</p><p id="47ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，看一下YAML对象(你将看到我是如何加入一些额外的注释和标签来使应用程序在开发者控制台上看起来更漂亮的)，然后检查下面的步骤。</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="8b73" class="ni lu it ne b gy nj nk l nl nm">kind: Template<br/>apiVersion: template.openshift.io/v1<br/>metadata:<br/>  name: bookinfo-app<br/>objects:<br/>  ##############################<br/>  # Details service<br/>  ##############################<br/>- apiVersion: v1<br/>  kind: Service<br/>  metadata:<br/>    name: details<br/>    labels:<br/>      app: details<br/>      service: details<br/>  spec:<br/>    ports:<br/>    - port: 9080<br/>      name: http<br/>    selector:<br/>      app: details<br/>      <br/>- apiVersion: v1<br/>  kind: ServiceAccount<br/>  metadata:<br/>    name: bookinfo-details<br/>    labels:<br/>      account: details<br/>- apiVersion: apps/v1<br/>  kind: Deployment<br/>  metadata:<br/>    name: details-v1<br/>    labels:<br/>      app: details<br/>      version: v1<br/>      app.openshift.io/runtime: ruby<br/>      app.kubernetes.io/part-of: Details<br/>  spec:<br/>    replicas: 1<br/>    selector:<br/>      matchLabels:<br/>        app: details<br/>        version: v1<br/>    template:<br/>      metadata:<br/>        annotations:<br/>          sidecar.istio.io/inject: "true"<br/>        labels:<br/>          app: details<br/>          version: v1<br/>      spec:<br/>        serviceAccountName: bookinfo-details<br/>        containers:<br/>        - name: details<br/>          image: maistra/examples-bookinfo-details-v1:1.1.0<br/>          imagePullPolicy: IfNotPresent<br/>          ports:<br/>          - containerPort: 9080</span><span id="6a82" class="ni lu it ne b gy nn nk l nl nm">##############################<br/>  # Ratings service<br/>  ##############################<br/>- apiVersion: v1<br/>  kind: Service<br/>  metadata:<br/>    name: ratings<br/>    labels:<br/>      app: ratings<br/>      service: ratings<br/>  spec:<br/>    ports:<br/>    - port: 9080<br/>      name: http<br/>    selector:<br/>      app: ratings<br/>      <br/>- apiVersion: v1<br/>  kind: ServiceAccount<br/>  metadata:<br/>    name: bookinfo-ratings<br/>    labels:<br/>      account: ratings<br/>      <br/>- apiVersion: apps/v1<br/>  kind: Deployment<br/>  metadata:<br/>    name: ratings-v1<br/>    labels:<br/>      app: ratings<br/>      version: v1<br/>      app.openshift.io/runtime: nodejs<br/>      app.kubernetes.io/part-of: Ratings<br/>  spec:<br/>    replicas: 1<br/>    selector:<br/>      matchLabels:<br/>        app: ratings<br/>        version: v1<br/>    template:<br/>      metadata:<br/>        annotations:<br/>          sidecar.istio.io/inject: "true"<br/>        labels:<br/>          app: ratings<br/>          version: v1<br/>      spec:<br/>        serviceAccountName: bookinfo-ratings<br/>        containers:<br/>        - name: ratings<br/>          image: maistra/examples-bookinfo-ratings-v1:1.1.0<br/>          imagePullPolicy: IfNotPresent<br/>          ports:<br/>          - containerPort: 9080</span><span id="65e9" class="ni lu it ne b gy nn nk l nl nm">##############################<br/>  # Reviews service<br/>  ##############################<br/>- apiVersion: v1<br/>  kind: Service<br/>  metadata:<br/>    name: reviews<br/>    labels:<br/>      app: reviews<br/>      service: reviews<br/>  spec:<br/>    ports:<br/>    - port: 9080<br/>      name: http<br/>    selector:<br/>      app: reviews<br/>      <br/>- apiVersion: v1<br/>  kind: ServiceAccount<br/>  metadata:<br/>    name: bookinfo-reviews<br/>    labels:<br/>      account: reviews<br/>      <br/>- apiVersion: apps/v1<br/>  kind: Deployment<br/>  metadata:<br/>    name: reviews-v1<br/>    labels:<br/>      app: reviews<br/>      version: v1<br/>      app.openshift.io/runtime: java<br/>      app.kubernetes.io/part-of: Reviews<br/>  spec:<br/>    replicas: 1<br/>    selector:<br/>      matchLabels:<br/>        app: reviews<br/>        version: v1<br/>    template:<br/>      metadata:<br/>        annotations:<br/>          sidecar.istio.io/inject: "true"<br/>        labels:<br/>          app: reviews<br/>          version: v1<br/>      spec:<br/>        serviceAccountName: bookinfo-reviews<br/>        containers:<br/>        - name: reviews<br/>          image: maistra/examples-bookinfo-reviews-v1:1.1.0<br/>          imagePullPolicy: IfNotPresent<br/>          ports:<br/>          - containerPort: 9080<br/>          <br/>- apiVersion: apps/v1<br/>  kind: Deployment<br/>  metadata:<br/>    name: reviews-v2<br/>    labels:<br/>      app: reviews<br/>      version: v2<br/>      app.openshift.io/runtime: java<br/>      app.kubernetes.io/part-of: Reviews<br/>    annotations:<br/>      app.openshift.io/connects-to: ratings-v1<br/>  spec:<br/>    replicas: 1<br/>    selector:<br/>      matchLabels:<br/>        app: reviews<br/>        version: v2<br/>    template:<br/>      metadata:<br/>        annotations:<br/>          sidecar.istio.io/inject: "true"<br/>        labels:<br/>          app: reviews<br/>          version: v2<br/>      spec:<br/>        serviceAccountName: bookinfo-reviews<br/>        containers:<br/>        - name: reviews<br/>          image: maistra/examples-bookinfo-reviews-v2:1.1.0<br/>          imagePullPolicy: IfNotPresent<br/>          ports:<br/>          - containerPort: 9080<br/>          <br/>- apiVersion: apps/v1<br/>  kind: Deployment<br/>  metadata:<br/>    name: reviews-v3<br/>    labels:<br/>      app: reviews<br/>      version: v3<br/>      app.openshift.io/runtime: java<br/>      app.kubernetes.io/part-of: Reviews<br/>    annotations:<br/>      app.openshift.io/connects-to: ratings-v1<br/>  spec:<br/>    replicas: 1<br/>    selector:<br/>      matchLabels:<br/>        app: reviews<br/>        version: v3<br/>    template:<br/>      metadata:<br/>        annotations:<br/>          sidecar.istio.io/inject: "true"<br/>        labels:<br/>          app: reviews<br/>          version: v3<br/>      spec:<br/>        serviceAccountName: bookinfo-reviews<br/>        containers:<br/>        - name: reviews<br/>          image: maistra/examples-bookinfo-reviews-v3:1.1.0<br/>          imagePullPolicy: IfNotPresent<br/>          ports:<br/>          - containerPort: 9080</span><span id="cf77" class="ni lu it ne b gy nn nk l nl nm">##############################<br/>  # Productpage services<br/>  ##############################<br/>- apiVersion: v1<br/>  kind: Service<br/>  metadata:<br/>    name: productpage<br/>    labels:<br/>      app: productpage<br/>      service: productpage<br/>  spec:<br/>    ports:<br/>    - port: 9080<br/>      name: http<br/>    selector:<br/>      app: productpage<br/>      <br/>- apiVersion: v1<br/>  kind: ServiceAccount<br/>  metadata:<br/>    name: bookinfo-productpage<br/>    labels:<br/>      account: productpage<br/>      <br/>- apiVersion: apps/v1<br/>  kind: Deployment<br/>  metadata:<br/>    name: productpage-v1<br/>    labels:<br/>      app: productpage<br/>      version: v1<br/>      app.openshift.io/runtime: python<br/>      app.kubernetes.io/part-of: ProductPage<br/>    annotations:<br/>      app.openshift.io/connects-to: reviews-v1,reviews-v2,reviews-v3,details-v1 <br/>  spec:<br/>    replicas: 1<br/>    selector:<br/>      matchLabels:<br/>        app: productpage<br/>        version: v1<br/>    template:<br/>      metadata:<br/>        annotations:<br/>          sidecar.istio.io/inject: "true"<br/>        labels:<br/>          app: productpage<br/>          version: v1<br/>      spec:<br/>        serviceAccountName: bookinfo-productpage<br/>        containers:<br/>        - name: productpage<br/>          image: maistra/examples-bookinfo-productpage-v1:1.1.0<br/>          imagePullPolicy: IfNotPresent<br/>          ports:<br/>          - containerPort: 9080</span></pre><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/a5e21d32d7851acba9a3e02e123a230c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9HKIl0ZGMWx9v_L4RxCbLQ.gif"/></div></div></figure><p id="7f86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们想要公开应用程序，所以现在我们必须创建<em class="nc">网关</em>和<em class="nc">虚拟服务</em>对象。如果你不知道我在说什么，看看上一篇文章中做的<a class="ae mw" href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-iii-data-plane-341ce477c269" rel="noopener"> OpenShift服务网格数据平面回顾。</a></p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="1098" class="ni lu it ne b gy nj nk l nl nm">apiVersion: networking.istio.io/v1alpha3<br/>kind: Gateway<br/>metadata:<br/>  name: bookinfo-gateway<br/>spec:<br/>  selector:<br/>    istio: ingressgateway<br/>  servers:<br/>  - port:<br/>      number: 80<br/>      name: http<br/>      protocol: HTTP<br/>    hosts:<br/>    - "bookinfo.&lt;domain&gt;"</span><span id="b1c9" class="ni lu it ne b gy nn nk l nl nm">apiVersion: networking.istio.io/v1alpha3<br/>kind: VirtualService<br/>metadata:<br/>  name: bookinfo-vs<br/>spec:<br/>  hosts:<br/>  - "bookinfo.&lt;domain&gt;"<br/>  gateways:<br/>  - bookinfo-gateway<br/>  http:<br/>  - route:<br/>    - destination:<br/>        host: productpage<br/>        port:<br/>          number: 9080</span></pre><p id="3abf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成后，您应该可以访问该应用程序:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/181d8e5d394e10e2fe4e86f4f1d95b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84Jw-EM-IvlaUz9kxVxpiQ.png"/></div></div></figure><p id="642f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是登录页面，但是为了到达实际的“服务”，您应该选择一个可能的请求(正常或测试)或者直接进入:</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="170d" class="ni lu it ne b gy nj nk l nl nm">http://bookinfo.&lt;domain&gt;/productpage</span></pre><p id="c488" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以开始使用服务网格功能了。</p><h1 id="fbcf" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">配置流量路由</h1><p id="0a05" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">在这一节中，我们将探索Istio提供的一些高级路由功能。</p><h2 id="d48e" class="ni lu it bd lv nq nr dn lz ns nt dp md km nu nv mh kq nw nx ml ku ny nz mp oa bi translated">重定向登录页面</h2><p id="e15b" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">在这个例子中，我想去掉的第一件事是登录页面，我想直接进入评论，所以我需要一种方法来重定向我来自`<em class="nc"> bookinfo的请求。&lt;域&gt; / </em>`到`<em class="nc"> bookinfo。&lt;域&gt; /productpage </em>`中</p><p id="22a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还记得配置中介绍网关实际路由的部分吗？VirtualService，因此创建一个重定向请求的附加VirtualService就足够了。</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="b322" class="ni lu it ne b gy nj nk l nl nm">apiVersion: networking.istio.io/v1alpha3<br/>kind: VirtualService<br/>metadata:<br/>  name: bookinfo-vs-redirect<br/>spec:<br/>  hosts:<br/>  - "bookinfo.&lt;domain&gt;"<br/>  gateways:<br/>  - bookinfo-gateway<br/>  http:<br/>  - match:<br/>    - uri:<br/>        exact: /<br/>    redirect:<br/>      uri: /productpage</span></pre><p id="f98d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们将要使用的VirtualService定义中，有两件事情需要注意:</p><p id="c4f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">1-有一个"<em class="nc"> match </em> "/redirect语句将选择受影响的请求，在本例中，任何请求都指向`<em class="nc"> bookinfo。&lt;域&gt; / </em>`，并重定向到`<em class="nc"> bookinfo。&lt;域&gt;/产品页面</em>`</p><p id="330a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2-没有"<em class="nc"> route </em>"语句，将使用已经配置的语句。这里，我们在已经部署的<em class="nc">虚拟服务</em>的基础上添加了额外的配置，因为<code class="fe ob oc od ne b">istio-pilot</code>会将额外的路由规则合并到主机的现有配置中。您现在可能会想到一个问题:如果我们可以通过创建额外的VirtualService对象来添加配置，那么应用VirtualService对象的顺序是什么？</p><p id="20fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">答案是顺序无法保证，所以注意不要配置冲突的规则。关于这一点也有一个很好的实践，试着配置一个“默认”规则(没有<em class="nc">匹配</em>语句或者有<em class="nc">匹配</em> =*)放在列表的末尾。</p><h2 id="bcc5" class="ni lu it bd lv nq nr dn lz ns nt dp md km nu nv mh kq nw nx ml ku ny nz mp oa bi translated">多个微服务版本</h2><p id="45f9" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">当我们打开`<em class="nc"> bookinfo。&lt;域&gt; / </em>`我们的请求到达<em class="nc">产品页面</em>服务(这是我们在第一个<em class="nc">虚拟服务</em>中定义的)，然后<em class="nc">产品页面</em>将通过向Kubernetes服务名称发送请求来查询<em class="nc">详细信息</em>和<em class="nc">评论</em>微服务，如您在<a class="ae mw" href="https://github.com/istio/istio/blob/master/samples/bookinfo/src/productpage/productpage.py" rel="noopener ugc nofollow" target="_blank">源代码</a>中所见:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/99a18f476b3778c8c83b82983a06a7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEUXtLqBJJ3-SRQZPXPfaQ.png"/></div></div></figure><p id="e5dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“r<em class="nc">eviews</em>”Kubernetes服务后面有三个pod:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/8e47acc557b3c49dd1172ee800ae04c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*gmlgtQOYBsKQE0gRuevMrw.png"/></div></figure><p id="8540" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个POD运行不同的容器映像(不同的版本)，并且它们是由不同的部署创建的(它们共享服务，因为它们也共享“<em class="nc"> app: reviews </em>”标签)。如你所知，Kubernetes服务的负载平衡行为是循环的，这就是为什么每次你刷新`<em class="nc"> bookinfo。&lt;域&gt; / </em>`你会看到你正在到达一个不同版本的<em class="nc">评论</em>微服务(你可以看一看，看看评级星是如何变化的)。</p><p id="7cda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢Kiali，让我们轻松测试一下这种行为。首先，我们需要向我们的服务发送多个请求，因为我不想不断刷新我的web浏览器，所以我将使用一个<em class="nc"> watch </em>加<em class="nc">T25】一个<em class="nc"> curl </em>命令(包括-L以便跟随HTTP重定向):</em></p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="96ca" class="ni lu it ne b gy nj nk l nl nm">watch --interval 1 curl -L <a class="ae mw" href="http://bookinfo" rel="noopener ugc nofollow" target="_blank">http://bookinfo</a>.&lt;domain&gt;</span></pre><p id="e06a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，您可以转到Kiali&gt;Graph并启用“请求百分比”:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div class="gh gi og"><img src="../Images/2f5edb0e0dcf49bd862ebd49aa443666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*kFm_OgRJbUS7Zoi65r31Qg.png"/></div></figure><p id="80dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以看到点评服务和不同应用程序版本之间的流量百分比应该接近33% (100/3)</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/61d6ee155720f399cc164ed307828aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYq1xuA7Swj8z6GbGeExrw.png"/></div></div></figure><p id="d2bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，如果我想按照任何常规的部署策略来部署我的不同版本，例如，A/B或蓝绿色部署，该怎么办呢？我们如何改变这种默认行为，例如，将总流量的80%发送到一个特定版本？</p><p id="256f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">无论有没有OpenShift服务网格，这都是可能的，但正如您所理解的，当您有OpenShift服务网格时，可能性会更大。</p><p id="a9d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想了解如何在“简单的”OpenShift中做到这一点，我建议你看看我创建的OCP开发者入门实验室:</p><div class="kz la gp gr lb lc"><a href="https://github.com/luisarizmendi/lab-ocp-intro" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">luisarizmendi/lab-ocp-intro</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">本教程将作为帮助您理解Openshift概念的逐步指南。我们将部署…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="oi l ln lo lp ll lq jz lc"/></div></div></a></div><p id="056b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你没有自己的OpenShift集群，你可以通过在learn.openshift.com订购一个免费的OpenShift游乐场来运行它，尽管这个环境只能持续一个小时。</p><blockquote class="oj ok ol"><p id="9af2" class="kb kc nc kd b ke kf kg kh ki kj kk kl om kn ko kp on kr ks kt oo kv kw kx ky im bi translated"><strong class="kd iu">注意</strong>:如果您想在KVM中部署OpenShift集群，您可能会发现这个库很有用:<a class="ae mw" href="https://github.com/luisarizmendi/ocp-kvm-bm-upi" rel="noopener ugc nofollow" target="_blank"> ocp-kvm-bm-upi </a>和<a class="ae mw" href="https://github.com/luisarizmendi/ocp-libvirt-ipi" rel="noopener ugc nofollow" target="_blank"> ocp-libvirt-ipi </a>。如果您只是需要关于OpenShift先决条件的帮助，您可以使用这个角色:<a class="ae mw" href="https://github.com/luisarizmendi/ocp-prereq-role" rel="noopener ugc nofollow" target="_blank"> ocp-prereq-role </a></p></blockquote><p id="90c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你只是想阅读<a class="ae mw" href="https://github.com/luisarizmendi/lab-ocp-intro/blob/master/workshop/content/modules/16advdeploystrategy.adoc" rel="noopener ugc nofollow" target="_blank">的内容，我介绍了不同的部署策略，以及如何在OpenShift中配置它们，你可以看看研讨会源代码中的ADOC文件。</a></p><p id="621d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，当使用不带服务网格的OpenShift时，背后的想法不是改变Kubernetes服务对象的行为方式，而是使用OpenShift路由器的扩展功能(将它们与常规入口控制器对象进行比较)。</p><p id="d742" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">OpenShift服务网格不会改变标准的Kubernetes服务对象，但也不会使用OpenShift路由器，它会通过配置<em class="nc"> VirtualService </em>对象来配置路由规则。</p><p id="6587" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要在配置虚拟服务时考虑以下几点:</p><ul class=""><li id="513c" class="op oq it kd b ke kf ki kj km or kq os ku ot ky ou ov ow ox bi translated">当请求发送到Kubernetes服务名(而不是用于从集群外部到达服务的URI)时，它必须生效，因此我们需要在“host”字段中添加服务名。</li><li id="9fd5" class="op oq it kd b ke oy ki oz km pa kq pb ku pc ky ou ov ow ox bi translated">我们需要一种方法来区分不同的微服务版本，这里我们需要讨论一个新的对象，Istio<a class="ae mw" href="https://istio.io/latest/docs/reference/config/networking/destination-rule/" rel="noopener ugc nofollow" target="_blank"><em class="nc">destination rules</em></a></li></ul><p id="2d2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc"> DestinationRules </em>影响流量在被<em class="nc"> VirtualService </em>路由后的交付方式，但也可用于定义如何隔离我们不同的微服务版本，并在<em class="nc"> VirtualService </em>对象中使用该定义。</p><p id="c6c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中，我们将使用我们在每个不同版本的每个部署对象中配置的标签(特别是标签“<em class="nc"> version </em>”)。</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="cb01" class="ni lu it ne b gy nj nk l nl nm">apiVersion: networking.istio.io/v1alpha3<br/>kind: DestinationRule<br/>metadata:<br/>  name: reviews-dr<br/>spec:<br/>  host: reviews<br/>  subsets:<br/>  - name: <strong class="ne iu">v1</strong><br/>    labels:<br/>      <strong class="ne iu">version: v1</strong><br/>  - name: <strong class="ne iu">v2</strong><br/>    labels:<br/>      <strong class="ne iu">version: v2</strong><br/>  - name: <strong class="ne iu">v3</strong><br/>    labels:<br/>      <strong class="ne iu">version: v3</strong></span></pre><p id="0eb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，我们给每个标签匹配起了一个名字(即。使用将在虚拟服务的“<em class="nc">子集</em>字段中使用的<em class="nc">版本=v1 </em>时，命名<em class="nc"> v1 </em>:</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="8278" class="ni lu it ne b gy nj nk l nl nm">apiVersion: networking.istio.io/v1alpha3<br/>kind: VirtualService<br/>metadata:<br/>  name: reviews-80v1-20v2<br/>spec:<br/>  hosts:<br/>    - reviews<br/>  http:<br/>  - route:<br/>    - destination:<br/>        <strong class="ne iu">host: reviews</strong><br/>        <strong class="ne iu">subset: v1</strong><br/>     <strong class="ne iu"> weight: 80</strong><br/>    - destination:<br/>       <strong class="ne iu"> host: reviews<br/>        subset: v2</strong><br/>      <strong class="ne iu">weight: 20</strong></span></pre><p id="32cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过这种方式，我们可以区分不同的微服务版本(在本例中应用不同的权重),而不必部署多个Kubernetes服务对象。</p><p id="1d68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在Kiali中查看这些百分比，80%到v1，20%到v2，0%到v3</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/cfa479999f0e67a5aead3a6d214a2e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*QxIsGblvSJcd1GoEIDXtTA.png"/></div></figure><p id="9fc4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kiali还可以更容易地发现我们使用此<em class="nc">虚拟服务</em>配置的80/20流量分布:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pe"><img src="../Images/70a0aa689a31d7ee19815ac0da70aac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8Cxehnx8mrdqfgUBgIkYg.png"/></div></div></figure><p id="5507" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我试图用几个子集字段配置一个<em class="nc">虚拟服务</em>，但是我忘记创建匹配的<em class="nc"> DestinationRule </em>怎么办？在创建<em class="nc">虚拟服务</em>时，您不会注意到任何事情，但是如果您看一下Kiali UI，您会看到一些消息:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pf"><img src="../Images/1d64a1356510ce27e92744625c4c315f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0psyVXPxL8QcjzwhHQVfNg.png"/></div></div></figure><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pg"><img src="../Images/21c2c75828738dd4849123ebafc07ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URWhLstPq3aeH4YzzJYDrA.png"/></div></div></figure><p id="21dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用上面的配置，我们将80%的请求发送到v1，20%发送到v2(未使用v3)。如果您删除权重变量，您将得到定义的子集之间的50/50(v3也不会被使用)。这很好，但并不令人印象深刻，因为我们可以在没有服务网格的情况下使用OpenShift获得相同的行为(尽管在这种情况下更复杂，灵活性更低)，让我们超越这一点，基于其他触发器配置路由，而不仅仅是“权重”，让我们基于HTTP头进行路由。</p><p id="e88f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你注意的话，在主页的右上角你可以找到一个“登录”按钮:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ph"><img src="../Images/7bf2e844550ea9e51b0dfc12c1e4e25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHllow07NPAXfn4qN7K78w.png"/></div></div></figure><p id="0b17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mw" href="https://github.com/istio/istio/blob/81fe6075722b5a083743ee6d7180daff1bb77f93/samples/bookinfo/src/productpage/productpage.py" rel="noopener ugc nofollow" target="_blank">查看应用程序的源代码</a>，您可以看到该按钮正在做什么，它正在设置一个变量“<em class="nc"> user </em>，其名称在“<em class="nc"> session </em>数组中引入。</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/b7098363d29722ed4f8741fc56a69beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*Bo1K406Xgw87krC5Lz9-CA.png"/></div></figure><p id="f488" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您继续查看代码，您会看到它是如何在一个名为“<em class="nc">最终用户</em>的新头中转发变量“<em class="nc">用户</em>”(到<em class="nc">评论</em>和<em class="nc">细节</em>服务):</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/1fffb132238a5544683912fb8bd5f75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*p1E9kH929sE1keId4oOjTA.png"/></div></figure><p id="95c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您在没有登录的情况下请求页面时，您可以通过检查HTTP cookies来检查它实际上是如何工作的，当您登录时，您应该会看到有一个名为“session”的新Cookie:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/7e949f6771272f7277a027c5b75c15cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DjmgdtbgQLCr359R8BmMCw.gif"/></div></div></figure><p id="012e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的“会话”Cookie的内容是:</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="38ab" class="ni lu it ne b gy nj nk l nl nm">eyJ1c2VyIjoiamFzb24ifQ.X48MLA.aeYGJKietWgCLAPAgNrSMCO85NA</span></pre><p id="acb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您使用base64解码该内容，您将看到实际的变量和值:</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="2694" class="ni lu it ne b gy nj nk l nl nm">$ echo -ne eyJ1c2VyIjoiamFzb24ifQ.X48MLA.aeYGJKietWgCLAPAgNrSMCO85NA | base64 -d</span><span id="d902" class="ni lu it ne b gy nn nk l nl nm">{"user":"jason"}</span></pre><p id="8ccc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来的想法是检查这个头，并根据发现的内容决定如何路由请求，但是请记住，我们已经检查了代码，我们发现这里有两个不同的头，我应该使用哪个头呢？(位于从我的浏览器到<em class="nc">产品页面</em>的请求中的<em class="nc">会话</em>头或者从<em class="nc">产品页面</em>转发到<em class="nc">的<em class="nc">最终用户</em>头审查</em>微服务，并且也包含用户信息)</p><p id="cdcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们想要修改的流量是对reviews微服务的请求，因此我们需要选择包含在这些请求中的报头，即<em class="nc">最终用户</em>报头。</p><p id="2046" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然我们知道我们需要基于<em class="nc">终端用户</em>头创建一个规则，那么让我们来确定匹配的实际值。我将使用与您在Istio文档中找到的示例相同的示例:</p><ul class=""><li id="1ae8" class="op oq it kd b ke kf ki kj km or kq os ku ot ky ou ov ow ox bi translated">当您以“Jason”用户的身份登录时，您将到达reviews微服务的版本v2(您将在“Review”下找到黑色星星)</li><li id="e8ae" class="op oq it kd b ke oy ki oz km pa kq pb ku pc ky ou ov ow ox bi translated">当以任何其他用户身份登录或未登录时，请求将被路由到reviews微服务的版本v1(无星号)</li></ul><p id="8f13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您还记得在第一个例子中，我们将请求重定向到"/"，我们在<em class="nc">虚拟服务</em>中使用了一个"<em class="nc">匹配</em>"语句来选择流量，这次我们也将使用它，但不是URI，我们将看看头部。</p><p id="4597" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果"<em class="nc">最终用户</em>标题上的内容与"<em class="nc"> jason </em>"完全匹配，请求将被路由到reviews v2(请记住，我们使用的是由之前创建的<em class="nc"> DestinationRule </em>定义的“子集”)</p><blockquote class="oj ok ol"><p id="8071" class="kb kc nc kd b ke kf kg kh ki kj kk kl om kn ko kp on kr ks kt oo kv kw kx ky im bi translated">注意:这个VirtualService与上一个不冲突，在上一个中，我们以80/20的方式进行平衡，所以您可以同时配置两个服务，但是在继续基于头配置这个服务之前，最好删除那个服务。</p></blockquote><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="0847" class="ni lu it ne b gy nj nk l nl nm">apiVersion: networking.istio.io/v1alpha3<br/>kind: VirtualService<br/>metadata:<br/>  name: reviews-jasonv2<br/>spec:<br/>  hosts:<br/>    - reviews<br/>  http:<br/><strong class="ne iu">  - match:<br/>    - headers:<br/>        end-user:<br/>          exact: jason<br/>    route:<br/>    - destination:<br/>        host: reviews<br/>        subset: v2</strong><br/>  - route:<br/>    - destination:<br/>        host: reviews<br/>        subset: v1</span></pre><p id="dd1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查看我们实际配置的内容(我删除了以前的VirtualService，因此在未登录时我应该使用循环法来获得平衡):</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/9f1fe0b5ae9dcd678999b1d20d76ac2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Q4k32FbqPXhmQCuow7AKNQ.gif"/></div></div></figure><p id="2983" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很好，不是吗？现在，您可以开始使用匹配规则，并且“header”或URI不是唯一可以用来匹配您想要路由的流量的值，您可以查看<a class="ae mw" href="https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest" rel="noopener ugc nofollow" target="_blank"> Istio文档，您会发现可以检查的不同字段</a>。</p><h2 id="ff0c" class="ni lu it bd lv nq nr dn lz ns nt dp md km nu nv mh kq nw nx ml ku ny nz mp oa bi translated">交通镜</h2><p id="31f9" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">通过Istio，您可以配置流量镜像，以便将实时流量的副本发送到镜像服务，这有助于故障排除、测试(您可以放置新版本的应用程序并检查其行为)或监控。</p><p id="1d8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们使用这个特性来仔细检查一下,<em class="nc"> productpage </em>服务是否正在将请求转发给具有新标题<em class="nc">最终用户</em>的<em class="nc"> reviews </em>服务(而不是我们在web浏览器上看到的<em class="nc">会话</em>标题),并且该标题包含我们在上一节中看到的用户变量。</p><p id="0f9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，这个流量是内部的，所以我要做的是将来自<em class="nc">product page</em>-<em class="nc">reviews</em>的流量镜像到一个新的服务，该服务将侦听HTTP请求并在日志中打印包含的信息，这样我们就可以稍后查看POD日志并检查标题。</p><p id="eb8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将使用<a class="ae mw" href="https://github.com/mendhak/docker-http-https-echo" rel="noopener ugc nofollow" target="_blank">这个应用程序</a>执行我所说的操作，获取HTTP请求，并将内容写入日志，因此第一步是将其部署在我们的服务网格上。</p><p id="916a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了部署它，我创建了这个部署对象，它指向容器映像并允许端口9080，这是从<em class="nc"> productpage </em>到<em class="nc"> reviews </em>微服务的原始请求将使用的端口，你怎么知道呢？有一个简单的方法，你可以在这里使用Jaeger(点击Kiali中的“分布式追踪”部分)。您只需要选择一个跟踪并查看详细信息，以便找到内部请求使用的端口。</p><blockquote class="oj ok ol"><p id="12ab" class="kb kc nc kd b ke kf kg kh ki kj kk kl om kn ko kp on kr ks kt oo kv kw kx ky im bi translated"><strong class="kd iu">注意</strong>:记住，在这个控制平面(controlplane-a) <a class="ae mw" href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener">中，我们将“traceSampling”配置为10% </a>，因此在这种情况下，只有10%的请求会在Jaeger中结束。</p></blockquote><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pk"><img src="../Images/10a94a5a9927f062cfbbe52f9db825ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUNYQhB7SHgaAvoA-32J8w.png"/></div></div></figure><p id="9134" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是实际的部署对象，请注意，我们向POD开放了端口9080，但是为了将应用程序配置为侦听该端口，我们需要包括一些环境变量:</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="1155" class="ni lu it ne b gy nj nk l nl nm">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: http-https-echo<br/>  labels:<br/>    app: http-https-echo<br/>    version: v1<br/>    app.kubernetes.io/part-of: Mirror<br/>  annotations:<br/>    app.openshift.io/connects-to: productpage-v1<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: http-https-echo<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: http-https-echo<br/>        version: v1<br/>      annotations:<br/>        sidecar.istio.io/inject: "true"<br/>    spec:<br/>      containers:<br/>        - name: http-https-echo<br/>          image: mendhak/http-https-echo<br/>          ports:<br/>            - containerPort: 9080<br/>              protocol: TCP<br/>            - containerPort: 9443<br/>              protocol: TCP<br/>          env:<br/>            - name: HTTP_PORT<br/>              value: '9080'<br/>            - name: HTTPS_PORT<br/>              value: '9443'</span></pre><p id="6d81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了部署之外，我们将像以前一样配置一个Kubernetes服务:</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="b523" class="ni lu it ne b gy nj nk l nl nm">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mirror<br/>  labels:<br/>    app: http-https-echo<br/>    service: http-https-echo<br/>spec:<br/>  ports:<br/>  - port: 9080<br/>    name: http<br/>  selector:<br/>    app: http-https-echo</span></pre><p id="5953" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">服务正在侦听(它不会出现在Kiali中，因为没有流量到达该服务)，现在我们需要镜像流量。我们希望检查带有报头的流量，因此我们只需要捕获对<em class="nc"> reviews </em> version 2的请求，这是我们配置的在我们作为“Jason”用户登录的情况下需要联系的请求(我们也可以作为其他用户登录并检查v1)。</p><p id="25aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要修改<em class="nc"> VirtualService </em>，在<em class="nc"> reviews </em> v2的route语句下添加mirror部分:</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="5651" class="ni lu it ne b gy nj nk l nl nm">apiVersion: networking.istio.io/v1alpha3<br/>kind: VirtualService<br/>metadata:<br/>  name: reviews-jasonv2<br/>spec:<br/>  hosts:<br/>    - reviews<br/>  http:<br/>  - match:<br/>    - headers:<br/>        end-user:<br/>          exact: jason<br/>    route:<br/>    - destination:<br/>        host: reviews<br/>        subset: v2<br/><strong class="ne iu">    mirror:<br/>      host: mirror<br/>    mirror_percent: 100</strong><br/>  - route:<br/>    - destination:<br/>        host: reviews<br/>        subset: v1</span></pre><p id="403a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用Kiali而不是OpenShift Web控制台来修改该对象:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/810b2bbf1f925fc8b6ab05dfd577383f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JCc9fGM5mV7r_1YhIuJYqw.gif"/></div></div></figure><p id="4984" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，在作为“Jason”用户登录时，使用Web浏览器向应用程序发送一些请求，流量必须镜像到新的pod，并保存在日志中:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/75aac045cc4140cf41c4fee1bd718fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iXfi5psCV8okrt8HQCjeBQ.gif"/></div></div></figure><p id="ca89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，我们能够通过镜像流量来收集内部通信的信息，这不会影响实际的服务，并且我们检查了转发的报头<em class="nc">最终用户</em>如何包含具有正确用户名的用户变量。</p><h2 id="f6e0" class="ni lu it bd lv nq nr dn lz ns nt dp md km nu nv mh kq nw nx ml ku ny nz mp oa bi translated">管理出口流量</h2><p id="cbca" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">Istio还允许控制出口流量。我们可以配置如何将流量发送到服务网格之外，例如，如果您的组织对使用专用节点离开服务网格的流量有安全要求，这将非常有用(就像我们在OpenShift worker nodes 系列的“<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/security-zones-in-openshift-worker-nodes-part-i-introduction-4f85762962d7">安全区域”中对Openshift但没有服务网格所做的那样)</a></p><p id="25e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一点使这种配置不同于入口路由。当您为入口配置任何路由规则时，您包括指向<em class="nc">服务</em>的<em class="nc">虚拟服务</em>对象，这些服务通过从Kubernetes集群获取信息而被发现并自动包括在服务网格服务注册中心中(因为我们创建了一个服务Kubernetes对象以便访问应用程序)。当您想要为出口流量配置路由规则时，您没有这样的Kubernetes服务(因为这些服务是为您在集群上运行的应用程序创建的),因此服务网格无法继续进行服务发现并更新其自己的服务注册表。</p><p id="433d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这可以通过使用<a class="ae mw" href="https://istio.io/latest/docs/reference/config/networking/service-entry/" rel="noopener ugc nofollow" target="_blank"> Istio <em class="nc"> ServiceEntry </em>对象</a>手动包含条目来解决，这样可以向Istio的内部服务注册表添加额外的条目。</p><p id="afa8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是首先，由于我们的应用程序不需要任何到外部资源的连接，我们将部署一个带有CentOS映像的POD，从这里我们将使用<em class="nc"> curl </em>查询OpenShift集群之外的内容。</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="31ba" class="ni lu it ne b gy nj nk l nl nm">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: egress-test<br/>  annotations:<br/>    sidecar.istio.io/inject: "true"<br/>spec:<br/>  containers:<br/>  - name: example-pod<br/>    command: ["/bin/bash", "-c", "sleep 99999999999"]<br/>    image: centos/tools</span></pre><p id="b97d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您像我们在上一篇文章中所做的那样测试出口流量，您将会看到它正在使用节点的IP，但是如果您在创建ServiceEntry、EgressGateway和相关的VirtualService(见下文)之后尝试，您将会看到出口流量开始使用出口网关。</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="2ae7" class="ni lu it ne b gy nj nk l nl nm">apiVersion: networking.istio.io/v1alpha3<br/>kind: ServiceEntry<br/>metadata:<br/>  name: ifconfig<br/>spec:<br/>  hosts:<br/>  - ifconfig.io<br/>  ports:<br/>  - number: 80<br/>    name: http-port<br/>    protocol: HTTP<br/>  - number: 443<br/>    name: https<br/>    protocol: HTTPS<br/>  resolution: DNS</span><span id="3a4a" class="ni lu it ne b gy nn nk l nl nm">---</span><span id="87fa" class="ni lu it ne b gy nn nk l nl nm">apiVersion: networking.istio.io/v1alpha3<br/>kind: Gateway<br/>metadata:<br/>  name: istio-egressgateway<br/>spec:<br/>  selector:<br/>    istio: egressgateway<br/>  servers:<br/>  - port:<br/>      number: 80<br/>      name: http<br/>      protocol: HTTP<br/>    hosts:<br/>    - ifconfig.io</span><span id="8da4" class="ni lu it ne b gy nn nk l nl nm">---<br/>apiVersion: networking.istio.io/v1alpha3<br/>kind: VirtualService<br/>metadata:<br/>  name: direct-ifconfig-through-egress-gateway<br/>spec:<br/>  hosts:<br/>  - ifconfig.io<br/>  gateways:<br/>  - istio-egressgateway<br/>  - mesh<br/>  http:<br/>  - match:<br/>    - gateways:<br/>      - mesh<br/>      port: 80<br/>    route:<br/>    - destination:<br/>        host: istio-egressgateway.istio-system.svc.cluster.local<br/>        port:<br/>          number: 80<br/>      weight: 100<br/>  - match:<br/>    - gateways:<br/>      - istio-egressgateway<br/>      port: 80<br/>    route:<br/>    - destination:<br/>        host: ifconfig.io<br/>        port:<br/>          number: 80<br/>      weight: 100</span></pre><p id="2d2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面您可以看到来自egress-test POD的出口流量如何首先使用其所在节点的IP地址(在我的例子中是worker1)，但是在创建对象之后，它开始使用出口路由器所在的IP地址(在我的例子中是worker0):</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/e29416d46e565f93f4af35ca1c1aa9f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WQg21v3-7DJew5TGyJJyTA.gif"/></div></div></figure><p id="dc1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于现在流量正在通过出口路由器，您现在可以对出口流量应用额外的控制和安全策略(我们将在下一篇文章中了解如何操作)以及出口流量操作，例如，假设您希望确保您的应用程序在端口443而不是80上使用ifconfig.io…您可以通过调整VirtualService中的目标端口来动态修改从集群到外部服务的请求(在本例中为ifconfig . io )(查看粗体文本并与之前的VirtualService进行比较)</p><pre class="my mz na nb gt nd ne nf ng aw nh bi"><span id="f9d3" class="ni lu it ne b gy nj nk l nl nm">apiVersion: networking.istio.io/v1alpha3<br/>kind: VirtualService<br/>metadata:<br/>  name: direct-ifconfig-through-egress-gateway<br/>spec:<br/>  hosts:<br/>  - ifconfig.io<br/>  gateways:<br/>  - istio-egressgateway<br/>  - mesh<br/>  http:<br/>  - match:<br/>    - gateways:<br/>      - mesh<br/>      port: 80<br/>    route:<br/>    - destination:<br/>        host: istio-egressgateway.istio-system.svc.cluster.local<br/>        port:<br/>          number: 80<br/>      weight: 100<br/>  - match:<br/>    - gateways:<br/>      - istio-egressgateway<br/>      port: 80<br/>    route:<br/><strong class="ne iu">    - destination:<br/>        host: ifconfig.io<br/>        port:<br/>          number: 443</strong><br/>      weight: 100</span></pre><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pl"><img src="../Images/1f95795dbec7d3550a4c3983b60a0575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OIsdm7PFnRtM6PWZ.png"/></div></div></figure><blockquote class="pm"><p id="49dd" class="pn po it bd pp pq pr ps pt pu pv ky dk translated">在本系列的下一篇文章中，我们将继续探索OpenShift服务网格(Istio)的特性，保持好奇…</p></blockquote></div></div>    
</body>
</html>