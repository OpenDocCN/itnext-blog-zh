<html>
<head>
<title>NodeJs MongoDb fixture from Mongoose schema — Fakingoose with node-mongodb-fixtures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自Mongoose模式的NodeJs MongoDb fixture—faking goose with node-MongoDb-fixture</h1>
<blockquote>原文：<a href="https://itnext.io/mongodb-fixture-from-mongoose-schema-fakingoose-with-node-mongodb-fixtures-83013238727f?source=collection_archive---------7-----------------------#2019-10-07">https://itnext.io/mongodb-fixture-from-mongoose-schema-fakingoose-with-node-mongodb-fixtures-83013238727f?source=collection_archive---------7-----------------------#2019-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8a30cdfede99dab371fe7a39abb56c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uD2poo96_ncRkTuRqU1ruA.jpeg"/></div></div></figure><p id="c14a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文将向您介绍在运行测试之前用样本数据加载MongoDB数据库的步骤，然后在测试完成后删除数据。将使用两个包来创建夹具:</p><ul class=""><li id="c449" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae lf" href="https://www.npmjs.com/package/fakingoose" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">faking goose</strong></a>将用于根据用<strong class="ka ir">mongose</strong>定义的实体模式生成假的或模拟的数据。</li><li id="31cf" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><a class="ae lf" href="https://github.com/cdimascio/node-mongodb-fixtures#readme" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">node-mong db-fixture</strong></a>用于运行测试前保存数据，测试完成后删除数据。</li></ul></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="4f28" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">这篇文章中的一个附件</h1><p id="3133" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">术语fixture根据上下文、编程语言或框架而变化。</p><ul class=""><li id="ab57" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">测试正在运行的已知状态</strong></li></ul><blockquote class="mv mw mx"><p id="13ef" class="jy jz my ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated">编写测试最耗时的部分之一是编写代码将世界设置在一个已知的状态，然后在测试完成时将它返回到原始状态。这种已知状态被称为测试的<em class="iq">夹具</em>。<br/><a class="ae lf" href="https://phpunit.readthedocs.io/en/8.3/fixtures.html" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">PHP-单元文档</strong> </a></p><p id="ebfc" class="jy jz my ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated">一个<a class="ae lf" href="https://en.wikipedia.org/wiki/Test_fixture" rel="noopener ugc nofollow" target="_blank">测试夹具</a>(也称为测试环境)是运行测试所需的一组<a class="ae lf" href="https://en.wikipedia.org/wiki/Precondition" rel="noopener ugc nofollow" target="_blank">前提条件</a>或状态。开发人员应该在测试之前设置一个已知的良好状态，并在测试之后返回到原始状态。<br/> <a class="ae lf" href="https://en.wikipedia.org/wiki/XUnit#Test_fixtures" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">维基百科</strong> </a> <strong class="ka ir"> (xUnit) </strong></p></blockquote><ul class=""><li id="dd90" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">包含样本数据的文件</strong></li></ul><blockquote class="mv mw mx"><p id="bea6" class="jy jz my ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated"><strong class="ka ir"> Fixtures </strong>是样本数据的别称。Fixtures允许您在测试运行之前用预定义的数据填充测试数据库。夹具是独立于数据库的，并且是在YAML编写的。每个型号有一个文件。</p><p id="eaed" class="jy jz my ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated"><a class="ae lf" href="https://guides.rubyonrails.org/testing.html#the-low-down-on-fixtures" rel="noopener ugc nofollow" target="_blank">RubyOnRails.org</a></p></blockquote><ul class=""><li id="de61" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">设置所需状态的过程。</strong></li></ul><blockquote class="mv mw mx"><p id="2991" class="jy jz my ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated">软件测试夹具通过提供所有必要的代码来初始化系统，从而满足可能存在的任何先决条件，从而为测试过程设置系统。例如，在运行测试之前，从客户站点加载一个具有已知参数的数据库。<a class="ae lf" href="https://en.wikipedia.org/wiki/Test_fixture#Software" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="iq"> <br/> </em>百科</strong> </a></p></blockquote><p id="a4d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在本文中，fixture是最后一个定义，它是设置运行测试所需的已知状态的代码。</strong></p><h1 id="0ca8" class="ls lt iq bd lu lv nc lx ly lz nd mb mc md ne mf mg mh nf mj mk ml ng mn mo mp bi translated">一个样本系统</h1><p id="8c5d" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">让我们定义一个提供<strong class="ka ir"> <em class="my"> HTTP </em> </strong>资源<strong class="ka ir"> <em class="my"> /articles </em> </strong>的假想服务。这个资源的数据存储在MongoDB数据库中。该服务使用<a class="ae lf" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">快递</strong> </a> <strong class="ka ir">实现。我们的Express应用程序将具有以下结构。</strong></p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/9ac7dd75a039983c9315e11bbb550819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eftjNh3czA76ekGNWRXyA.png"/></div></div></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="92e6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">测试工具</h1><p id="d42e" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们将使用的工具包括</p><ul class=""><li id="6aa7" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae lf" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">摩卡</strong></a>:JavaScript的测试者。</li><li id="4723" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><a class="ae lf" href="http://chaijs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">柴</strong> </a>:一个断言库。我们使用Chai和一个额外的插件，<a class="ae lf" href="https://www.chaijs.com/plugins/chai-http/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> ChaiHttp </strong> </a>。ChaiHttp插件为Chai添加了Http请求行为，并允许我们向Express应用程序发出HTTP请求。</li><li id="48ef" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><a class="ae lf" href="https://www.npmjs.com/package/fakingoose" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">Fakingoose</strong></a>:NodeJS的模拟数据生成器，使用Mongoose模式生成假对象。</li><li id="e888" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><a class="ae lf" href="https://github.com/cdimascio/node-mongodb-fixtures#readme" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">node-MongoDB-fixtures</strong></a>:NodeJS的夹具管理模块。这个模块负责将夹具数据保存到MongoDB。</li><li id="fa02" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><a class="ae lf" href="https://github.com/testcontainers/testcontainers-node" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">TestTontainers</strong></a>:提供管理Docker容器的API的模块。在运行测试之前，它将在一个<a class="ae lf" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank"> Docker容器</a>中加载一个MongoDb服务器。一旦测试完成，Docker容器将被停止。</li></ul><p id="4cc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">安装摩卡</strong></p><p id="a88c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">全球安装摩卡:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="1347" class="nr lt iq nn b gy ns nt l nu nv">$ npm i -g mocha</span></pre><p id="aa14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者作为我们项目的开发依赖:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="8628" class="nr lt iq nn b gy ns nt l nu nv">$ npm i -D mocha</span></pre><p id="1dc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">安装测试依赖项:</strong></p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="5ff6" class="nr lt iq nn b gy ns nt l nu nv">$ npm i -D chai chai-http fakingoose node-mongodb-fixtures testcontainers</span></pre><h1 id="b4fe" class="ls lt iq bd lu lv nc lx ly lz nd mb mc md ne mf mg mh nf mj mk ml ng mn mo mp bi translated">管理测试数据—设置和清理</h1><p id="0fcc" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">两个javascript文件将包含我们的夹具代码:</p><ol class=""><li id="e360" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nw lc ld le bi translated">第一个文件将保存模拟数据。</li><li id="65b1" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv nw lc ld le bi translated">第二个文件将使用前一个文件中的模拟数据来填充MongoDB数据库。</li></ol><h2 id="fa1a" class="nr lt iq bd lu nx ny dn ly nz oa dp mc kj ob oc mg kn od oe mk kr of og mo oh bi translated">1.生成模拟数据</h2><p id="4c36" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">node-mongodb-fixtures需要一个包含所有fixture数据文件的目录，每个集合一个文件。每个文件必须与其目标集合共享相同的名称。让我们创建一个名为<em class="my"> articles.js. </em>的javascript文件，该文件返回的数据将用于创建<em class="my"> articles </em>集合中的文章。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="cbd0" class="nr lt iq nn b gy ns nt l nu nv"><em class="my">// fixtures/entities/articles.js</em></span><span id="927e" class="nr lt iq nn b gy oi nt l nu nv"><em class="my">const</em> <strong class="nn ir">fakingoose</strong> = require('fakingoose');<br/><em class="my">const</em> <strong class="nn ir">ArticleSchema</strong> = require('../../../lib/schemas/article.schema');<br/><em class="my">const</em> <strong class="nn ir">articleFactory</strong> = fakingoose(<strong class="nn ir">ArticleSchema</strong>, { _id: { tostring: <strong class="nn ir">false</strong> }, authorId: { tostring: <strong class="nn ir">false</strong> } });</span><span id="5934" class="nr lt iq nn b gy oi nt l nu nv"><strong class="nn ir">module</strong>.exports = [<br/>  articleFactory.<em class="my">generate</em>(),<br/>  articleFactory.<em class="my">generate</em>()<br/>];</span></pre><p id="e31d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中:</p><ul class=""><li id="b252" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">Fakingoose工厂是基于为<em class="my"> Article </em>实体定义的Mongoose模式创建的。然后，这个工厂用于生成模拟对象。</li><li id="b53a" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">生成的模拟数据作为模拟对象的数组导出。</li></ul><h2 id="043c" class="nr lt iq bd lu nx ny dn ly nz oa dp mc kj ob oc mg kn od oe mk kr of og mo oh bi translated">2.数据库加载和清理</h2><p id="79f1" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">下一步是使用模拟数据目录中的文件提供的数据来填充数据库。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="0125" class="nr lt iq nn b gy ns nt l nu nv">// tests/fixtures/article.fixtures.js</span><span id="0fb7" class="nr lt iq nn b gy oi nt l nu nv"><strong class="nn ir"><em class="my">const</em></strong> <strong class="nn ir">Fixtures</strong> = require('<em class="my">node-mongodb-fixtures</em>');<br/><strong class="nn ir"><em class="my">const</em></strong> <strong class="nn ir">path</strong> = require('<em class="my">path</em>');</span><span id="bb87" class="nr lt iq nn b gy oi nt l nu nv">module.exports = <strong class="nn ir"><em class="my">async</em></strong> (dbUrl) =&gt; {<br/>  <em class="my">const</em> <strong class="nn ir">fixtures</strong> = new Fixtures({ dir: path.resolve(__dirname, './entities') });<br/>  <br/>  <strong class="nn ir">await</strong> fixtures.<em class="my">connect</em>(dbUrl).<em class="my">then</em>(() =&gt; <strong class="nn ir">fixtures</strong>.<em class="my">load</em>());  <br/>  <br/>  <strong class="nn ir">const</strong> <strong class="nn ir">articles</strong> = <strong class="nn ir"><em class="my">await</em></strong>   Promise.<strong class="nn ir"><em class="my">resolve</em></strong>(fixtures._db.<em class="my">collection</em>('articles'))<br/>  .<em class="my">then</em>((collection) =&gt; {<br/>    <strong class="nn ir"><em class="my">return</em></strong> <strong class="nn ir">collection</strong>.<em class="my">find</em>().<em class="my">toArray</em>();<br/> });</span><span id="1ee8" class="nr lt iq nn b gy oi nt l nu nv"><strong class="nn ir"><em class="my"> const</em></strong> <strong class="nn ir">cleanup</strong> = () =&gt; <strong class="nn ir">fixtures</strong>.<em class="my">unload</em>()<br/>   .<em class="my">then</em>(() =&gt; <strong class="nn ir">fixtures</strong>.disconnect());</span><span id="d200" class="nr lt iq nn b gy oi nt l nu nv"> <strong class="nn ir"><em class="my">return</em></strong> { <strong class="nn ir">cleanup</strong>, entities: <strong class="nn ir">articles</strong> };<br/>}</span></pre><p id="d35b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，模块返回了一个函数。该函数使用node-mongodb-fixtures模块将生成的模拟数据保存在mongodb数据库中，该数据库的URI作为参数传递。该函数返回一个具有两个属性的对象:</p><ul class=""><li id="7203" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">实体:</strong>MongoDB数据库中保存的文章。</li><li id="84a4" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><strong class="ka ir">清理:</strong>调用者可以用来清理数据库的函数。调用这个返回函数的最佳时机是在测试完成之后。</li></ul></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="4715" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">测试业务逻辑</h1><p id="ef40" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们希望编写简单的测试来检查我们的API是否返回了正确的数据。</p><p id="296b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的测试套件是用mocha的默认接口(<strong class="ka ir"> BDD </strong>)编写的。测试套件、钩子和测试可以使用Mocha提供的不同接口来定义，即:<strong class="ka ir"> BDD </strong>、<strong class="ka ir"> TDD </strong>、<strong class="ka ir"> Exports </strong>、<strong class="ka ir"> QUnit </strong>和<strong class="ka ir">requires</strong>。对于想了解更多的好奇者来说，Mocha文档提供了更多关于接口的细节。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="d1e5" class="nr lt iq nn b gy ns nt l nu nv">// tests/article-api.test.js</span><span id="e4a7" class="nr lt iq nn b gy oi nt l nu nv">const chai = require('chai');<br/>const chaiHttp = require('chai-http');<br/>const createArticles = require('../fixtures/article.fixtures');<br/>const appSetup = require('../setup');<br/>const { expect } = chai;<br/>chai.use(chaiHttp);</span><span id="0864" class="nr lt iq nn b gy oi nt l nu nv"><strong class="nn ir">describe</strong>('Articles', () =&gt; {<br/>  let deleteArticles, articles, stopDb, dbUrl, app;<br/>  <strong class="nn ir">before</strong>(async () =&gt; {<br/>    ({ app, dbUrl, stopDb } = await appSetup.init());<br/>    ({ cleanup: deleteArticles, entities: articles } =<br/>       await <strong class="nn ir">createArticles</strong>(`${dbUrl}/test-db`));<br/>  });</span><span id="f31a" class="nr lt iq nn b gy oi nt l nu nv"><strong class="nn ir">  after</strong>(() =&gt; deleteArticles().then(stopDb));</span><span id="6fef" class="nr lt iq nn b gy oi nt l nu nv"><strong class="nn ir">  describe</strong>('GET /', () =&gt; {<br/>    <strong class="nn ir">it</strong>('must fetch all articles', async () =&gt; {<br/>      const response = await chai.request(app).get('/articles');<br/>      expect(response).to.have.status(200);<br/>      expect(response.body.articles).to.have.lengthOf(2);<br/>    });</span><span id="0e9b" class="nr lt iq nn b gy oi nt l nu nv">    <strong class="nn ir">it</strong>('must fetch a single article by ID', async () =&gt; {<br/>      const [, secondArticle] = articles;<br/>      const response = await chai.request(app)<br/>        .get(`/articles/${secondArticle._id}`);<br/>      expect(response).to.have.status(200); <br/>      expect(response.body.article.id).to.eql(secondArticle.id);<br/>    });</span><span id="88b0" class="nr lt iq nn b gy oi nt l nu nv">    <strong class="nn ir">it</strong>('must respond with a NOT FOUND error', async () =&gt; {<br/>      const response = await chai.request(app)<br/>       .get(`/articles/${articles[1].authorId}`);<br/>      expect(response).to.have.status(404);<br/>    });<br/>  });<br/>});</span></pre><p id="a7e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的测试中</p><ul class=""><li id="6f7f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">Express应用程序和MongoDb数据库的初始设置在<strong class="ka ir"> before() </strong>钩子中完成。一旦数据库启动，<strong class="ka ir"> createArticles() </strong>函数(之前定义的<em class="my"> article.fixtures.js </em>)用于在MongoDB数据库中创建示例文章。该函数返回一个清理方法(重命名为<strong class="ka ir"> deleteArticles() </strong>)和已保存文章的列表。这种清理方法被存储起来以备后用。</li><li id="d983" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">mocha的<strong class="ka ir"> it() </strong>函数用于定义通过向Express App发送HTTP请求来检查API行为的测试。</li><li id="bafb" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">()后的<strong class="ka ir"/>钩子用于从数据库中删除数据。在before()钩子中定义的<strong class="ka ir"> deleteArticles() </strong>函数在这里用于在测试完成后从数据库中删除创建的文章。</li></ul></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="0893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Fakingoose和node-mongodb-fixtures，我们为测试创建了fixture代码。Fakingoose用于生成数据，而node-mongodb-fixtures <strong class="ka ir"> </strong>提供假数据的保存和删除。摩卡和柴用于测试，但你可以使用任何其他替代品。</p><p id="ce4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的源代码可以在<a class="ae lf" href="https://github.com/faboulaws/blog-source-code/tree/master/fixtures-tutorial--fakingoose-with-node-mongodb-fixtures" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="7360" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>