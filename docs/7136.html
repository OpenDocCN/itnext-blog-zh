<html>
<head>
<title>Benchmarking to the Bottom — Iterating Arrays in .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">底层基准测试——迭代数组。网</h1>
<blockquote>原文：<a href="https://itnext.io/benchmarking-to-the-bottom-iterating-arrays-in-net-a58a539656e2?source=collection_archive---------3-----------------------#2022-06-21">https://itnext.io/benchmarking-to-the-bottom-iterating-arrays-in-net-a58a539656e2?source=collection_archive---------3-----------------------#2022-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="65ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">寻找迭代数组的最快方法，同时在。NET使用<a class="ae ki" href="https://benchmarkdotnet.org/" rel="noopener ugc nofollow" target="_blank">BenchmarkDotNet</a>验证大规模性能。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/61fad17c4f925a99c0c40e8a7d584b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGPokFhrLsYa_k66iYxMiA.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">BenchmarkDotNet —一个强大的。用于基准测试的. NET库</figcaption></figure><p id="b691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近花了一些时间查看一个旧系统，想知道如何让它性能更好。有许多方法可以使这样的系统更快、性能更好，但是我想避免大规模的重构，以将风险降到最低。具体来说，我关注的是那些可以累积起来产生更大影响的小项目。最明显的是整个系统的升级，但当这不是一个选项时，这些小变化可能是一个工程师必须做出的改变。</p><p id="67ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">做这项工作已经激发了我的兴趣，首先，我想知道哪种方式是做这些日常小事的最佳方式。我正在慢慢构建一个小的任务系列。它可能会消耗不同的库来完成一个任务，或者直接比较每天的任务。无论哪种方式，都可以学到教训，获得乐趣。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6129" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">迭代和访问数组</h1><p id="4760" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">今天我决定看看可以迭代一个<a class="ae ki" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/" rel="noopener ugc nofollow" target="_blank">数组</a>的许多不同方法。这并不复杂，但是考虑到软件工程师经常使用C#中的列表和数组，解决它们也是有价值的。<br/> <br/>胜负的关键实际上是将数组中的项赋给一个变量。这将确保值正在被读取，不访问该项的纯迭代可能导致扭曲的结果。</p><p id="495f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是通过<a class="ae ki" href="https://benchmarkdotnet.org/" rel="noopener ugc nofollow" target="_blank"> BenchmarkDotNet </a>使用和测试的方法。</p><ul class=""><li id="feed" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ki" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement" rel="noopener ugc nofollow" target="_blank">为</a></li><li id="4510" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ki" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement" rel="noopener ugc nofollow" target="_blank"> ForEach </a></li><li id="18a0" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ki" href="https://docs.microsoft.com/en-us/dotnet/api/system.array.foreach" rel="noopener ugc nofollow" target="_blank">数组ForEach </a></li><li id="6b77" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ki" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1.getenumerator" rel="noopener ugc nofollow" target="_blank">获取枚举器</a></li><li id="86bc" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ki" href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1" rel="noopener ugc nofollow" target="_blank">跨度为</a></li><li id="a58d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ki" href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1" rel="noopener ugc nofollow" target="_blank"> Span ForEach </a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7aae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">理论</h1><p id="18d4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">鉴于与<a class="ae ki" href="https://medium.com/@stphnwlsh/benchmarking-your-way-to-the-bottom-iterating-lists-7ab4e6d2dbf6" rel="noopener">之前的测试</a>的相似性，我可以想象<code class="fe nn no np nq b">Span</code>方法将是我们这里的明显赢家。由于没有LINQ方法可供选择，我将选择所有方法中表现最差的<code class="fe nn no np nq b">GetEnumerator</code>方法。我预计<code class="fe nn no np nq b">for</code>环线会离<code class="fe nn no np nq b">Span</code>相当近，而<code class="fe nn no np nq b">foreach</code>会稍微靠后一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0d37" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置</h1><p id="de55" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用<a class="ae ki" href="https://benchmarkdotnet.org/" rel="noopener ugc nofollow" target="_blank"> BenchmarkDotNet </a>创建一个控制台应用程序使得运行基准测试变得非常简单。为了确保涵盖旧系统，这些测试将在两个<strong class="lb iu">中运行。NET Framework 4.8 </strong>和<strong class="lb iu">。NET 6.0 </strong>因为这是当前对. NET的长期支持版本。一个用于旧世界，一个用于新世界。</p><p id="4226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前提很简单。创建一个100和10，000深的字符串<code class="fe nn no np nq b">Array</code>。然后运行测试来迭代每一项，并重复这样做，直到<a class="ae ki" href="https://benchmarkdotnet.org/" rel="noopener ugc nofollow" target="_blank"> BenchmarkDotNet </a>乐意给我们一个结果。这应该给我们一个合理的假设，最快的方式去做这件事。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">迭代数组的设置方法</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a7aa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方法</h1><p id="7082" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来是为我想要测试的每种类型的<code class="fe nn no np nq b">Array</code>迭代创建一个方法。每种方法都做一件事来使它成为一个均匀的基准。每个方法将遍历<code class="fe nn no np nq b">Array</code>中的每个条目，访问列表中的条目，并将其赋给一个变量。一旦所有的项目都被处理，它将完成并记录完成任务所用的时间。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e77" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结果</h1><p id="7183" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">幸运的是，<a class="ae ki" href="https://benchmarkdotnet.org/" rel="noopener ugc nofollow" target="_blank"> BenchmarkDotNet </a>包含了一个排名栏，可以清楚地显示哪一轮测试胜出。当您阅读这些结果时，您可以使用Mean列来比较每个测试之间的运行时间差异。其中一些有明显的赢家，而其他的差别可以忽略不计。</p><h1 id="7526" class="mc md it bd me mf nt mh mi mj nu ml mm jz nv ka mo kc nw kd mq kf nx kg ms mt bi translated">。NET Framework 4.8 —迭代和访问</h1><pre class="kk kl km kn gt ny nq nz oa aw ob bi"><span id="4850" class="oc md it nq b gy od oe l of og">| Rank | Method        | N     |           Mean |<br/>| ---: | ------------- | ----- | -------------: |<br/>|    1 | ForEachLoop   | 100   |       305.9 ns |<br/>|    2 | ForLoop       | 100   |       343.9 ns |<br/>|    3 | ArrayForEach  | 100   |       451.1 ns |<br/>|    4 | GetEnumerator | 100   |    10,561.3 ns |<br/>|    5 | ForEachLoop   | 10000 |    30,064.2 ns |<br/>|    6 | ForLoop       | 10000 |    33,541.9 ns |<br/>|    7 | ArrayForEach  | 10000 |    43,825.3 ns |<br/>|    8 | GetEnumerator | 10000 | 1,055,741.5 ns |</span></pre><h1 id="a2c3" class="mc md it bd me mf nt mh mi mj nu ml mm jz nv ka mo kc nw kd mq kf nx kg ms mt bi translated">。NET 6.0 —迭代和访问</h1><pre class="kk kl km kn gt ny nq nz oa aw ob bi"><span id="1a50" class="oc md it nq b gy od oe l of og">| Rank | Method        | N     |         Mean |<br/>| ---: | ------------- | ----- | -----------: |<br/>|    1 | SpanForEach   | 100   |     141.9 ns |<br/>|    2 | ForLoop       | 100   |     173.6 ns |<br/>|    2 | ForEachLoop   | 100   |     175.2 ns |<br/>|    2 | SpanFor       | 100   |     175.5 ns |<br/>|    3 | ArrayForEach  | 100   |     370.7 ns |<br/>|    4 | GetEnumerator | 100   |   6,190.5 ns |<br/>|    5 | SpanForEach   | 10000 |  12,333.7 ns |<br/>|    6 | ForLoop       | 10000 |  16,181.6 ns |<br/>|    6 | SpanFor       | 10000 |  16,187.0 ns |<br/>|    6 | ForEachLoop   | 10000 |  16,251.8 ns |<br/>|    7 | ArrayForEach  | 10000 |  36,155.1 ns |<br/>|    8 | GetEnumerator | 10000 | 611,853.5 ns |</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a3d8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">思想</h1><h2 id="a693" class="oc md it bd me oh oi dn mi oj ok dp mm li ol om mo lm on oo mq lq op oq ms or bi translated">。NET框架4.8</h2><p id="cfbc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">老实说，这很令人惊讶，从测试结果来看<code class="fe nn no np nq b">foreach</code>是明显的赢家。鉴于它在<code class="fe nn no np nq b">List</code>上糟糕的表现，我真的没想到会这样。它比<code class="fe nn no np nq b">for</code>循环更快地迭代更大和更小的数组。数组有了新的冠军。正如所料，GetEnumerator绝对是表现最差的。结果很明显，如果你<code class="fe nn no np nq b">Array.Foreach</code>支持<code class="fe nn no np nq b">foreach</code>，那么是时候重构你的代码了。你可以带着它或者带着<code class="fe nn no np nq b">for</code>环离开，因为差别不是很大。</p><h2 id="4c9a" class="oc md it bd me oh oi dn mi oj ok dp mm li ol om mo lm on oo mq lq op oq ms or bi translated">。NET 6.0</h2><p id="aa61" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个熟悉的故事。NET 6.0的<code class="fe nn no np nq b">Span</code> <code class="fe nn no np nq b">foreach</code>方法拿回家的奖品。紧随其后的是<code class="fe nn no np nq b">for</code>、<code class="fe nn no np nq b">foreach</code>和<code class="fe nn no np nq b">Span</code> <code class="fe nn no np nq b">for</code>，这让我觉得不值得在这里进行大规模的重构。虽然只有很小的收益，但是任何新代码都应该使用一个<code class="fe nn no np nq b">Span</code>和一个<code class="fe nn no np nq b">foreach</code>的组合。<code class="fe nn no np nq b">Array.ForEach</code>远远落后于此，完全值得重构。<code class="fe nn no np nq b">GetEnumerator</code>已经放下的够多了，只是不值得你浪费时间。</p><h2 id="5d5c" class="oc md it bd me oh oi dn mi oj ok dp mm li ol om mo lm on oo mq lq op oq ms or bi translated">ForEach FTW</h2><p id="14d1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然在某些领域没有改变生活，但是<code class="fe nn no np nq b">foreach</code>循环显然是赢家，应该作为<strong class="lb iu">的首选迭代器来实现。网6.0 </strong>和<strong class="lb iu">。NET框架4.8 </strong>应用程序。只要记住。NET 6.0来使它也成为一个<code class="fe nn no np nq b">Span</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a76a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">密码</h1><p id="b4bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所有这些代码都是开源的。你可以在<a class="ae ki" href="https://github.com/stphnwlsh/Benchmarking" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到我的标杆作品。结果是运行基准测试的GitHub动作的输出，您应该能够在该存储库中找到详细的输出。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><pre class="kk kl km kn gt ny nq nz oa aw ob bi"><span id="7fa1" class="oc md it nq b gy od oe l of og"><strong class="nq iu">Support</strong></span><span id="bcf3" class="oc md it nq b gy os oe l of og">If you like this, or want to checkout my other work, please connect with me on <a class="ae ki" href="https://www.linkedin.com/in/stphnwlsh" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, <a class="ae ki" href="https://twitter.com/stphnwlsh" rel="noopener ugc nofollow" target="_blank">Twitter</a> or <a class="ae ki" href="https://github.com/stphnwlsh" rel="noopener ugc nofollow" target="_blank">GitHub</a>.</span></pre></div></div>    
</body>
</html>