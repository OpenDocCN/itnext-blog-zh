<html>
<head>
<title>JavaScript: Split a String into Equal Lengths</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:将字符串分割成相等的长度</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-split-a-string-into-equal-lengths-848eb811f383?source=collection_archive---------2-----------------------#2019-12-10">https://itnext.io/javascript-split-a-string-into-equal-lengths-848eb811f383?source=collection_archive---------2-----------------------#2019-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1665" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">找出提取预定长度的子字符串以及任何余数的最简单方法。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/70df6ce24f45437f0b2afa5b723c8813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJH96a2feg45hvYNjtq99g.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@barrettward?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Barrett Ward </a>在<a class="ae le" href="https://unsplash.com/s/photos/cut-boards?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a3b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不管你编码了多长时间，你总会发现自己有一些看似简单的任务，而你的工具箱里却没有现成的解决方案。</p><p id="4a8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你在StackOverflow或MDN上找不到一个让你<em class="lf">【doh】</em>继续工作的快速答案，那么你可能只能自己编码了。就我个人而言，我喜欢那些时刻。这是我作为一名程序员的生活目标。</p><h2 id="567d" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">任务</h2><p id="96eb" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我有一个任意长度的JavaScript字符串，我需要像积木一样把它分成相等的长度，并保留任何余数。</p><p id="1582" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着最近语言的巨大进步，似乎已经有了一个字符串方法，不是吗？我们可以在给定的分隔符上拆分一个字符串，并得到一个子字符串数组。为什么不按给定的长度分割，并选择性地取回剩余部分呢？</p><p id="d413" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">直到有人意识到我们只需要一个声明性的方法来完成这个任务，我想找到最简单的方法来完成它。</p><h2 id="b70f" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">蛮力</h2><p id="03f3" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">这几乎从来都不是最好的答案，但我们经常使用蛮力方法，这样我们就可以继续做更重要的事情。世界上80%的技术可能都是基于这一理念。<em class="lf">快去快回。</em></p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="8b81" class="lg lh it mf b gy mj mk l ml mm">// Split string into pieces</span><span id="4b27" class="lg lh it mf b gy mn mk l ml mm">const max_size = 10;<br/>const str_1 = str.slice(0, max_size);<br/>const str_2 = str.slice(max_size, max_size * 2);<br/>const str_3 = str.slice(max_size * 2, max_size * 2 + max_size);<br/>const str_4 = str.slice(max_size * 2 + max_size);<br/><br/>assert.equal(`${str_1}${str_2}${str_3}${str_4}`, str);</span></pre><p id="7191" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">呃。<em class="lf">为什么不好？</em></p><p id="00ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，它假设知道原始字符串的长度。它知道只有三个相等的长度加上一个余数。更长的字符串需要更多的代码行。此外，这只是fugly和难以阅读。</p><p id="d58b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不过，它确实让我通过了单元测试。但是今天，我真的需要这么做。可重复地，用任意长度的字符串。</p><h2 id="575d" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">更好的解决方案</h2><p id="da0e" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">蛮力之后的下一步通常是细化。我可以把上面的变成一个循环，把切片参数变成可读性更好的变量。我还需要计算循环的次数。然后检查是否有余数。</p><p id="85d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，整个事情开始变得有些乏味和沉闷。不管我用什么方法，我都要有至少和强力方法一样多的代码行。我想如果是这样的话，至少我可以试着优雅地做这件事。</p><p id="8d1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">以下是我想到的:</em></p><p id="7b8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用正则表达式<code class="fe mo mp mq mf b">yardstick</code>重复匹配长度为<code class="fe mo mp mq mf b">max_size</code>的任何字符，将它们放入数组<code class="fe mo mp mq mf b">pieces</code>。将所有这些片段的总长度放入变量<code class="fe mo mp mq mf b">accumulated</code>中，并通过获取字符串长度的<code class="fe mo mp mq mf b">modulo</code>和<code class="fe mo mp mq mf b">accumulated</code>来确定是否有余数。如果有模，那么从字符串中切下最后一位，并把它推到<code class="fe mo mp mq mf b">pieces</code>数组上。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="00e3" class="lg lh it mf b gy mj mk l ml mm">const max_size = 10;<br/>const yardstick = new RegExp(`.{${max_size}}`, 'g'); // /.{10}/g;<br/>const pieces = str.match(yardstick);<br/>const accumulated = (pieces.length * max_size);<br/>const modulo = str.length % accumulated;<br/>if (modulo) pieces.push(str.slice(accumulated));</span></pre><h2 id="1395" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">砰。把它提高一个等级！</h2><p id="bd03" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">也许你需要在整个应用程序中这样做，而不想在任何地方都包含它。也许你想在许多应用程序中使用它。为什么不把它作为原型方法添加到String中呢？</p><p id="5370" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将坚持“积木”的比喻，并采用polyfill风格，确保它适用于旧的浏览器(例如，使用<code class="fe mo mp mq mf b">var</code>而不是<code class="fe mo mp mq mf b">const</code>)。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="16ec" class="lg lh it mf b gy mj mk l ml mm">if (!String.prototype.cordwood) {<br/>  String.prototype.cordwood = function(cordlen) {<br/>  if (cordlen === undefined || cordlen &gt; this.length) {<br/>    cordlen = this.length;<br/>  }<br/>  <!-- -->var yardstick = new RegExp(`.{${<!-- -->cordlen<!-- -->}}`, 'g');<br/>  var pieces = this.match(yardstick);<br/>  var accumulated = (pieces.length * <!-- -->cordlen<!-- -->);<br/>  var modulo = this.length % accumulated;<br/>  if (modulo) pieces.push(this.slice(accumulated));<!-- -->	<br/>  return pieces;<br/> };<br/>}</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mr"><img src="../Images/d27ba4fa019d547ffbf0524a7ccadbbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wE32tiLfNHIcCJ9iCxeDw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我们的String.cordwood函数正在运行</figcaption></figure><p id="6564" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上GitHub <a class="ae le" href="https://gist.github.com/cliffhall/46275ed4d8270b5330e6b58e00ea5e9c" rel="noopener ugc nofollow" target="_blank">要点</a>如下。</p><p id="0433" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你对此有更好的解决方案，我很想听听。否则，我希望这能帮助其他人更快地开始他们的工作。</p></div></div>    
</body>
</html>