<html>
<head>
<title>Modern Application Server Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代应用服务器基础</h1>
<blockquote>原文：<a href="https://itnext.io/modern-application-server-basics-58a9aa8e9600?source=collection_archive---------2-----------------------#2021-03-24">https://itnext.io/modern-application-server-basics-58a9aa8e9600?source=collection_archive---------2-----------------------#2021-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6e6e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个重要的知识是，在基于Unix的操作系统中，一切都是文件。许多操作系统对象表示为文件。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/33994d92b7b718374247f4c662f4dd53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6V1BRwFzy4JcDTvQ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">奥马尔·弗洛雷斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8056" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网络调用是I/O交互的子类型。网络调用的第一步是创建套接字。所有的应用服务器启动一个套接字，并准备好为它们提供IP地址和端口号。初始化后，服务器准备接受新的连接。</p><p id="7e84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可伸缩性是应用服务器的首要问题。我们让很多客户都可以使用，而不会阻止他们中的每一个。我们有一个生活区的程序。制造可伸缩服务器的“野蛮”方法是对每个请求创建另一个进程。但是现代应用服务器如何处理数百万个请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/41b232de7ba63658fa59b4629cb3aa70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3VBKT37S9RxLSFM49Loz-g.jpeg"/></div></div></figure><p id="ac65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们说过，在开始时，基于Unix的操作系统上的每个对象都是一个文件。但是每个网络请求、每个磁盘操作和每个I/O设备交互都有数百万次。我们如何以可用且灵活的方式在这些文件上进行交互。第一种方法是线程。进程将每个线程上的一个任务委托给交互内核来处理应用服务器上的每个请求。根据工艺，这些都是轻量级零件。然而，不管我们的应用服务器上的线程大小如何，多个线程可能一次访问同一个文件描述符。另一个问题是线程创建受到操作系统的限制。</p><h1 id="7574" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">如果我们使用同一个线程来处理多个请求会怎么样？</h1><p id="0987" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Linux发行版有许多基于系统调用的IO复用机制，允许以非阻塞方式与相关资源进行“物理交互”。大多数现代应用服务器、平台都是在这些系统调用的基础上构建的。<a class="ae kv" href="http://www.kegel.com/c10k.html" rel="noopener ugc nofollow" target="_blank">丹·凯格尔将这些非阻断机制分为三类。</a>前两类名称依赖电路理论。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/96cb318fd1db8ff54c0d7c078355524d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cCP29aEo4EvN2iS709HCEQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">I/O多路复用机制</figcaption></figure><h1 id="a932" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">级别触发的通知</h1><p id="7bab" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">级别触发是一种基于事件的文件处理方式，意味着当状态完全改变时，可以处理任何动作。在这种情况下，内核告诉线程文件是否准备好被处理。两个主要的系统调用用于执行这种“传统的”通知。它只是根据条件生成输出。然而，基于边缘的系统使用“活动”。</p><h2 id="df60" class="mr lu iq bd lv ms mt dn lz mu mv dp md lf mw mx mf lj my mz mh ln na nb mj nc bi translated">选择/投票</h2><p id="b2f1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">读取系统调用是一种遗留方式，它只观察一个描述符并等待它被处理。选择是同步多路复用IO。但是它可以监视文件描述符的读写。请求是否会在定义的时间内过期，可能需要一个超时值。它返回要处理的文件描述符的数量。我们可以在与ioctl系统调用结合时使用异步应用服务器。</p><blockquote class="nd ne nf"><p id="c3d8" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">ioctl，使用文件描述符进行设备交互的系统调用</p></blockquote><p id="f512" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">轮询与选择系统调用具有相同的目标。我们可以给成千上万的文件描述符观看，虽然选择。</p><h1 id="352f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">边缘触发通知</h1><p id="cd3d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">边缘触发意味着我们的系统将在状态转换发生时得到通知，包括从活动到非活动以及从非活动到活动。根据级别触发的通知，边缘是更复杂的系统，因为我们需要定义上升和下降阈值。当条件仍然有效时，级别触发的系统可以连续共享事件，但是边缘系统只能在边缘发生时立即共享事件。</p><h2 id="c7c8" class="mr lu iq bd lv ms mt dn lz mu mv dp md lf mw mx mf lj my mz mh ln na nb mj nc bi translated">epoll / kqueue</h2><p id="332a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">epoll不是系统调用。它是一个位于内核端的API。它与轮询/选择系统调用进行相同的操作。它不是一个单独的命令，<a class="ae kv" href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/#.XyXXJxMzZ6I" rel="noopener ugc nofollow" target="_blank">它有三个系统调用，用于在操作系统</a>上进行边缘触发通知。</p><p id="66f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://copyconstruct.medium.com/the-method-to-epolls-madness-d9d2d6378642" rel="noopener"> epoll也工作在电平触发模式</a>。在级别触发模式下，当文件描述符可供处理时，它会连续发送一个I/O事件。与级别触发相反，无论文件描述符是否发生变化，都可以发布新的事件。手册页暗示级别触发的epoll是轮询系统调用的更快版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/6373371989f1cf02269718419c919de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZg2eOVCmROd_XQC2_Itqg.png"/></div></div></figure><p id="46c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">轮询调用使搜索变得容易一个重要的好处是，当找到可用的文件描述符时，epoll调用具有O(1)复杂度。当数据可用于处理时，poll会尝试在所有已注册的文件描述符中检查合适的文件描述符。然而，无论每个文件描述符上是否发生新的I/O处理，基于边缘的epoll总是可以发送事件。因此很容易找到可用的文件描述符来进行I/O处理。kqueue具有类似epoll的特性，但是只能在基于BSD的系统下工作。kqueue和epoll都解决了这个瓶颈问题，解决了c10k问题，同时将复杂度降低到O(1)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/a0dae25f948a2909cdf2098947aa7f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1atbtnU4koREUjInYSA6ZA.png"/></div></div></figure><p id="0e6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个好处是epoll调用动态地允许新的套接字连接。当使用轮询调用建立新的套接字连接时，您需要初始化step以从内核获取可用的文件描述符。使用epoll API，您只需发送一个事件来接受新的套接字连接。</p><p id="af97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于轮询的系统调用使用用户空间来评估文件描述符。它应该将用户空间的大量数据复制到内核空间。然而，kqueue和epoll也在内核空间中进行事件处理。它解决了代码空间之间的大量复制过程。</p><h1 id="2087" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">结论</strong></h1><p id="6408" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当我们检查Linux中的I / O机制时，可以看到Kegel的问题实际上是用基于事件的体系结构解决的。Golang的goroutine结构，node js的事件循环机制，netty框架的通道结构，其实都是解决c10k问题的一些面向事件的解决方案。</p></div></div>    
</body>
</html>