<html>
<head>
<title>Streams API New Features after Java 8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 8之后的流API新特性</h1>
<blockquote>原文：<a href="https://itnext.io/streams-api-new-features-after-java-8-f2df81bed5ac?source=collection_archive---------2-----------------------#2019-07-08">https://itnext.io/streams-api-new-features-after-java-8-f2df81bed5ac?source=collection_archive---------2-----------------------#2019-07-08</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6145" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">dropWhile，takeWhile和…</h2></div><figure class="kj kk kl km gu kn gi gj paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gi gj gk"><img src="../Images/3f33ba42920317f6ed14e88a08244540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrYIcaHbd23AAd88N9yIlw.png"/></div></div></figure><p id="ac6f" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">毫无疑问，Java 8中引入的最重要的特性是<code class="fe lq lr ls lt b"><a class="ae lu" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener ugc nofollow" target="_blank">lambda expression</a></code>，它最大和最重要的用途是在<code class="fe lq lr ls lt b"><a class="ae lu" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description" rel="noopener ugc nofollow" target="_blank">Stream API</a></code>。</p><p id="b22f" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated"><code class="fe lq lr ls lt b"><a class="ae lu" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description" rel="noopener ugc nofollow" target="_blank">Java 8 Stream API</a></code>允许开发人员通过将<code class="fe lq lr ls lt b"><a class="ae lu" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener ugc nofollow" target="_blank">lambda expression</a></code>传递给一组高阶函数(map、filter、forEach和……)来以函数风格的方式操作集合。</p><p id="3c5a" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">在发布Java 8和增加Java开发者之间使用<code class="fe lq lr ls lt b"><a class="ae lu" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description" rel="noopener ugc nofollow" target="_blank">Stream API</a></code>的流行度之后，我们正在等待JDK下一版本的<code class="fe lq lr ls lt b"><a class="ae lu" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description" rel="noopener ugc nofollow" target="_blank">Stream API</a></code>中的新特性(例如新的高阶函数)。通过发布Java 9，我们在<code class="fe lq lr ls lt b"><a class="ae lu" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description" rel="noopener ugc nofollow" target="_blank">Stream API</a></code>中看到了新的改进，但是在Java 10和11中没有变化。让我们来看看Java 8之后引入的<code class="fe lq lr ls lt b"><a class="ae lu" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description" rel="noopener ugc nofollow" target="_blank">Stream API</a></code>中的新特性:</p><h1 id="aa32" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">抓紧时间</h1><p id="018c" class="pw-post-body-paragraph ku kv iu kw b kx mn jv kz la mo jy lc ld mp lf lg lh mq lj lk ll mr ln lo lp in bi translated"><code class="fe lq lr ls lt b">takeWhile</code>是从Java 9开始添加的，它获得一个<code class="fe lq lr ls lt b">predicate</code>作为参数，从流中获取元素，直到第一个元素与谓词不匹配，然后处理将完成，该元素加上流的其余部分将被丢弃。它类似于<code class="fe lq lr ls lt b">filter</code>方法，除了<code class="fe lq lr ls lt b">filter</code>方法将<code class="fe lq lr ls lt b">predicate</code>应用于流的所有元素。</p><figure class="kj kk kl km gu kn gi gj paragraph-image"><div class="gi gj ms"><img src="../Images/d5f3f0b71fb84349104dab0dd0ec84ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*436I3-phbs2-0xtQ6SQfeA.png"/></div><figcaption class="mt mu gk gi gj mv mw bd b be z dk translated">图片来自<a class="ae lu" href="http://www.eclipse.org/" rel="noopener ugc nofollow" target="_blank"> Eclipse Foundation </a></figcaption></figure><figure class="kj kk kl km gu kn gi gj paragraph-image"><div class="gi gj ms"><img src="../Images/ae2406560c14132aa6bcec2c56d796da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*dmSRwlTzuKk1kzjYUaiV-A.png"/></div><figcaption class="mt mu gk gi gj mv mw bd b be z dk translated">图片来自<a class="ae lu" href="http://www.eclipse.org/" rel="noopener ugc nofollow" target="_blank"> Eclipse Foundation </a></figcaption></figure><p id="e9e2" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">例如，假设您想要使用<code class="fe lq lr ls lt b">Stream API</code>在终端中打印以下形状:</p><pre class="kj kk kl km gu mx lt my mz aw na bi"><span id="18e9" class="nb lw iu lt b gz nc nd l ne nf">*<br/>**<br/>***<br/>****<br/>*****<br/>******</span></pre><p id="a78b" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">你可以通过<code class="fe lq lr ls lt b">takeWhile</code>轻松写出来:</p><figure class="kj kk kl km gu kn"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="fd5b" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">上述定义对有序流有意义。那么无序的会发生什么呢？根据官方<a class="ae lu" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#takeWhile-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="ni nj nk"><p id="498c" class="ku kv nl kw b kx ky jv kz la lb jy lc nm le lf lg nn li lj lk no lm ln lo lp in bi translated">如果这个流是无序的，并且这个流的一些(但不是全部)元素匹配给定的谓词，那么这个操作的行为是不确定的；它可以自由选择匹配元素的任何子集(包括空集)。</p></blockquote><p id="6fe0" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">这意味着对无序流的每次执行都会得到不同的结果。</p><figure class="kj kk kl km gu kn"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="4ffa" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">输出可以是:<code class="fe lq lr ls lt b">1</code>或者<code class="fe lq lr ls lt b">3 2 1</code>！</p><h1 id="a12b" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">下降时间</h1><p id="79ae" class="pw-post-body-paragraph ku kv iu kw b kx mn jv kz la mo jy lc ld mp lf lg lh mq lj lk ll mr ln lo lp in bi translated"><code class="fe lq lr ls lt b">dropWhile</code>从Java 9开始增加。它与<code class="fe lq lr ls lt b">takeWhile</code>相反，从流中删除元素，直到第一个不匹配谓词的元素，然后返回该元素和流的其余部分。</p><figure class="kj kk kl km gu kn gi gj paragraph-image"><div class="gi gj ms"><img src="../Images/b2403e4ad687763cce1fcc2166c47ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*8Qajx5u34-OoU3vcdv-5Bw.png"/></div><figcaption class="mt mu gk gi gj mv mw bd b be z dk translated">图片来自<a class="ae lu" href="http://www.eclipse.org/" rel="noopener ugc nofollow" target="_blank"> Eclipse Foundation </a></figcaption></figure><p id="ead0" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">在无序的流中，<code class="fe lq lr ls lt b">dropWhile</code>看起来像<code class="fe lq lr ls lt b">takeWhile</code>并且是不确定的。</p><h1 id="058c" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">ofNullable</h1><p id="3c37" class="pw-post-body-paragraph ku kv iu kw b kx mn jv kz la mo jy lc ld mp lf lg lh mq lj lk ll mr ln lo lp in bi translated">这个静态工厂方法允许我们创建一个包含单个元素或空元素的流(对于空参数值)。</p><h1 id="b4af" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">重复</h1><p id="30b5" class="pw-post-body-paragraph ku kv iu kw b kx mn jv kz la mo jy lc ld mp lf lg lh mq lj lk ll mr ln lo lp in bi translated">Stream API有一个<code class="fe lq lr ls lt b">iterate</code>方法，该方法采用一个T类型的种子元素和一个函数，它用于创建一个无限流&lt; T &gt;，方法是从种子元素开始，迭代应用函数以获得下一个元素:</p><figure class="kj kk kl km gu kn"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="b77a" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">输出:</p><pre class="kj kk kl km gu mx lt my mz aw na bi"><span id="01c4" class="nb lw iu lt b gz nc nd l ne nf">0<br/>2<br/>4<br/>...</span></pre><p id="04d4" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">添加了一个新的<code class="fe lq lr ls lt b">iterate</code>方法，因为Java 9是旧方法的修改版本，它通过添加一个谓词作为方法参数来确定流何时必须终止:</p><figure class="kj kk kl km gu kn"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="8639" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">它相当于for语句的这个实现:</p><figure class="kj kk kl km gu kn"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="77bb" class="pw-post-body-paragraph ku kv iu kw b kx ky jv kz la lb jy lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">输出:</p><pre class="kj kk kl km gu mx lt my mz aw na bi"><span id="83c5" class="nb lw iu lt b gz nc nd l ne nf">0<br/>2<br/>4<br/>6<br/>8<br/>10</span></pre><h1 id="f00e" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated">结论</h1><p id="4c3f" class="pw-post-body-paragraph ku kv iu kw b kx mn jv kz la mo jy lc ld mp lf lg lh mq lj lk ll mr ln lo lp in bi translated">我试图通过一些示例和描述来描述Java 8之后Java Stream API的主要改进。我期待在即将到来的Java版本中Java Stream API的新特性。</p><h1 id="cdf1" class="lv lw iu bd lx ly lz ma mb mc md me mf ka mg kb mh kd mi ke mj kg mk kh ml mm bi translated"><strong class="ak">资源:</strong></h1><ul class=""><li id="f6a7" class="np nq iu kw b kx mn la mo ld nr lh ns ll nt lp nu nv nw nx bi translated"><a class="ae lu" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Stream.html" rel="noopener ugc nofollow" target="_blank">流(Java SE 11 &amp; JDK 11 ) —甲骨文帮助中心</a></li><li id="f186" class="np nq iu kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated"><a class="ae lu" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html" rel="noopener ugc nofollow" target="_blank">Java . util . stream(Java SE 11&amp;JDK 11)—Oracle Docs</a></li></ul></div></div>    
</body>
</html>