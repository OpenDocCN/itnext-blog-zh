<html>
<head>
<title>Implementing Ansible AWX — Gitlab integration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实施AWX — Gitlab集成</h1>
<blockquote>原文：<a href="https://itnext.io/implementing-ansible-awx-gitlab-integration-52c98f113ad0?source=collection_archive---------1-----------------------#2020-10-28">https://itnext.io/implementing-ansible-awx-gitlab-integration-52c98f113ad0?source=collection_archive---------1-----------------------#2020-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4d88" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">包括网钩。还有Kubernetes。</h2></div><p id="0d49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Ansible AWX(或其商业对手，Red-Hat的Ansible Tower)是一个基于Ansible的Web UI驱动的企业部署自动化工具。Gitlab是一个越来越受欢迎的基于git的存储库管理器，有很多附加选项。稍加修改，这两者真的可以发挥彼此的优势。</p><p id="ccda" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AWX真的希望被部署到Kubernetes或类似的基于docker的编排解决方案中，如open shift——只需阅读<a class="ae lb" href="https://github.com/ansible/awx/blob/devel/INSTALL.md" rel="noopener ugc nofollow" target="_blank">文档</a>。这意味着它希望遵循K8s的核心理念，尽可能做到无状态，这也意味着你应该将所有的剧本、库存和角色存储在其他地方——这就是Gitlab的用武之地。</p><p id="4467" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">老实说，我曾试图绕过AWX计划的部署场景一段时间，虽然它的工作，它远远不是最佳的。例如，我将一个非官方的基于RPM的AWX发行版部署到一个CentOS VM中，将附加的先决条件直接安装到它的virtualenv中，尝试修复各种路径以便AWX的Ansible worker可以找到它们，等等。但它并不优雅——它更像是一项黑客工作，这使得工作流程的任何升级或更改都是计划或执行的痛苦。</p><h1 id="1e32" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">(随波逐流)</strong></h1><p id="b125" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">更好的方法是将上述所有内容存储在一个源代码控制管理系统(SCM)中，比如Gitlab。我现在的做法是将这些可行的部分分开:</p><ul class=""><li id="af87" class="lz ma iq kh b ki kj kl km ko mb ks mc kw md la me mf mg mh bi translated">比赛</li><li id="060c" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">角色</li><li id="de0d" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">存货</li></ul><p id="9f59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个角色应该是一个独立的git项目，因为它更容易被Ansible Galaxy插件共享和引用。库存进一步细化到生产、开发和归档库存(最后一项库存主要用于参考，因为Ansible库存可以作为IaC文档提供给有经验的人员)。</p><p id="e3b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变化最大的是库存回购。一旦更改发布到Gitlab，我们希望它通知AWX下载最新版本，这样我们就可以部署它了。剧本和角色也是如此(应该尽可能模块化、可插拔和可重用——你应该通过清单而不是剧本来描述特定的部署)。</p><h1 id="6542" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">定义项目</strong></h1><p id="da00" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">首先，你要为剧、角色、库存创建合适的Gitlab项目(repos)。你也可以用同一个回购来交易和库存，但我喜欢把它们分开。角色应该放在单独的项目中，但是你可以通过Gitlab的组和子组来组织它们。</p><p id="a9cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了这样的设置，我们应该在AWX (SCM类型Git)添加库存和游戏作为项目。您必须在Gitlab中创建一个用户，该用户有权克隆代码并将其添加到AWX。</p><p id="443c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成这些之后，我们实际上可以开始在AWX定义库存和模板了(尽管它们现在相当静态)。对于每个库存，您可以定义一个同步源(在“源”选项卡下选择“来源于项目”)，对于每个模板，您可以指定一个播放。您输入的路径是相对于git repo的根路径(即<code class="fe mn mo mp mq b">production/servers.yml</code>)。最后可以手动同步，看看有没有效果。</p><h1 id="f976" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">定义角色</strong></h1><p id="3a1e" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">角色有些不同，因为它们实际上不需要自己的项目。Ansible扮演角色的方式是在一个专门的<code class="fe mn mo mp mq b">requirements.yml</code>文件中为您的剧本指定角色要求。这将由AWX自动读取并调用</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="fc9c" class="mz ld iq mq b gy na nb l nc nd">ansible-galaxy install -r roles/requirements.yml</span></pre><p id="a0ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着你应该让<code class="fe mn mo mp mq b">roles/requirements.yml</code>在SCM项目中托管你的剧本(而不是在这个文件夹中有实际的角色，不久前我被指控有罪)，也就是说你的剧本文件夹结构看起来有点像这样:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="0f3f" class="mz ld iq mq b gy na nb l nc nd">|maintenance<br/>|   |_________update.yml<br/>|   |_________set_pass.yml<br/>|   |_________common_packages.yml<br/>|<br/>|web-ops<br/>|   |_________apache-php-mysql.yml<br/>|   |_________nginx-php.yml<br/>|<br/>|database-ops<br/>|   |_________restore.yml<br/>|   |_________create.yml<br/>|<br/>|roles<br/>|   |_________requirements.yml</span></pre><p id="7b25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这只是一个例子，但是这里的想法是上面所有的都扮演参考角色(例如，安装php、httpd、nginx和mysqld)，然后这些角色的来源由<code class="fe mn mo mp mq b">requirements.yml</code>指定:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="8695" class="mz ld iq mq b gy na nb l nc nd">- src: git+https://gitlab.com/ansible/roles/httpd.git<br/>  name: httpd</span><span id="6d9d" class="mz ld iq mq b gy ne nb l nc nd">- src: git+https://gitlab.com/ansible/roles/mysql.git<br/>  name: mysql</span><span id="5bc2" class="mz ld iq mq b gy ne nb l nc nd">- src: git+https://gitlab.com/ansible/roles/nginx.git<br/>  name: nginx</span><span id="4046" class="mz ld iq mq b gy ne nb l nc nd">- src: git+https://gitlab.com/ansible/roles/php.git<br/>  name: php</span></pre><p id="0a79" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，这些路径完全是虚构的，但是您明白了——我们没有在项目的roles目录下提供每个角色，而是定义了它们的Gitlab repos，这样AWX就可以为您提取它们。</p><h1 id="b866" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">我答应了webhooks。</h1><p id="48f3" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">所以，让我们有网钩。虽然您可以指定AWX按计划从Gitlab中拉出(或者手动……哎呀！)，当源代码发生变化时，AWX刷新项目是非常有益的。我们将通过一个webhook来处理这个问题，它将在git push事件上触发，并随后触发AWX项目更新。</p><p id="c864" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，Gitlab项目支持现成的webhooks，但它相当稀疏——您可以指定认证令牌和URL。问题是，可以通过API调用触发AWX从SCM拉取，但是它希望它的参数包含在HTTP请求的正文中，而不是URL中(这是Gitlab唯一支持的)。所以我们需要在两者之间进行转换。</p><p id="e803" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，有一个方便的Go应用程序，你猜对了，叫做<a class="ae lb" href="https://github.com/adnanh/webhook" rel="noopener ugc nofollow" target="_blank"> Webhook </a>。它解析各种请求参数并执行脚本作为输出。您可以轻松地编译该应用程序—它将提供一个可执行文件，默认情况下该文件将侦听端口9000，解析传入的请求并执行适当的操作。</p><p id="bde7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你猜怎么着？这使得它成为在Docker / Kubernetes环境下运行的主要嫌疑对象。您也可以跳过这一步，只进行自述文件中指定的常规安装:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="0f26" class="mz ld iq mq b gy na nb l nc nd">go get github.com/adnanh/webhook<br/>go build github.com/adnanh/webhook</span></pre><p id="4999" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你选择在Docker下运行，这里有一个Docker文件:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="c1a7" class="mz ld iq mq b gy na nb l nc nd">FROM golang:1.15<br/>WORKDIR /go/src/</span><span id="e9bc" class="mz ld iq mq b gy ne nb l nc nd">RUN go get github.com/adnanh/webhook<br/>RUN CGO_ENABLED=0 GOOS=linux go build github.com/adnanh/webhook</span><span id="eaeb" class="mz ld iq mq b gy ne nb l nc nd">FROM alpine:latest<br/>WORKDIR /opt<br/>RUN mkdir -p /opt/webhook/bin &amp;&amp; \<br/>mkdir -p /opt/webhook/scripts &amp;&amp; \<br/>apk --no-cache add curl<br/>COPY --from=0 /go/src/webhook /opt/webhook/bin/<br/>COPY scripts/ /opt/webhook/scripts</span><span id="56cf" class="mz ld iq mq b gy ne nb l nc nd">CMD ["/opt/webhook/bin/webhook",  "-hooks", "/opt/webhook/scripts/hook.json", "--verbose"]</span></pre><p id="54c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，让我们用它来做一个Kubernetes部署，因为它非常简单:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="881e" class="mz ld iq mq b gy na nb l nc nd">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: webhook  <br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: webhook<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: webhook<br/>    spec:<br/>      volumes:<br/>        - name: webhook-confs<br/>          configMap:<br/>            name: webhook-confs<br/>            defaultMode: 0777<br/>      containers:<br/>      - name: webhook<br/>        image: netcomhr/webhook<br/>        imagePullPolicy: Always       <br/>        ports:<br/>        - containerPort: 9000<br/>        volumeMounts:<br/>        - name: webhook-confs<br/>          mountPath: /opt/webhook/scripts                    <br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: webhook<br/>  namespace: misc<br/>spec:  <br/>  type: LoadBalancer  <br/>  ports:<br/>    - name: webhook-port<br/>      port: 9000<br/>      targetPort: 9000<br/>      protocol: TCP<br/>  selector:<br/>    app: webhook</span></pre><p id="6e79" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，您可以通过拉我的预构建映像(<code class="fe mn mo mp mq b">netcomhr/webhook</code>)来直接使用这个清单，或者您可以通过提供的docker文件来构建您自己的映像。</p><p id="8d96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">dockerfile和manifest都引用了<code class="fe mn mo mp mq b">/opt/webhook/scripts</code>目录中的脚本，特别是包含实际钩子定义的<code class="fe mn mo mp mq b">hook.json</code>(这是webhook监听器的强制启动参数)。我将在这里提供一个配置(映射)示例:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="2b86" class="mz ld iq mq b gy na nb l nc nd">---<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: webhook-confs  <br/>data: <br/>  hook.json: |<br/>    [<br/>      {<br/>      "id": "update-project",<br/>        "execute-command": "/opt/webhook/scripts/update-project.sh",<br/>        "command-working-directory": "/opt/webhook/scripts/",<br/>        "pass-arguments-to-command": [<br/>          {<br/>            "source": "url",<br/>            "name": "id"<br/>          },<br/>          {<br/>            "source": "header",<br/>            "name": "X-Gitlab-Token"<br/>          }<br/>        ]<br/>      }<br/>    ]<br/>  <br/>  update-project.sh: |<br/>    #!/bin/sh<br/>    proj=$1<br/>    secret="$2"<br/>    if [ "$secret" == "<!-- -->228c56aaaBbajk<!-- -->" ]; then<br/>        curl -qs \<br/>            -d '{"extra_vars":{"target":"somehost"}}' \<br/>            -H "Content-type: application/json" \<br/>            -u &lt;awx_user&gt;:&lt;awx_pass&gt;  \<br/>            --insecure \<br/>            "https://awx.local/api/v2/projects/$proj/update/"<br/>    fi</span></pre><p id="4a01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe mn mo mp mq b">hook.json</code>将分析标题和URL，并调用<code class="fe mn mo mp mq b">update-project.sh</code>,向其传递两个参数——来自URL的id参数和Gitlab令牌——我们将在Gitlab中定义webhook时提供这两个参数。</p><p id="a2c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该id必须是我们正在更新的AWX项目的id。在Gitlab项目的webhook设置中，我们将指定如下内容:</p><figure class="mr ms mt mu gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/caa763270a57e0280e1cd6f0805b1ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vO0UAwWhFbgEPy-Dned8A.png"/></div></div></figure><p id="e7ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">172.20.20.17:9000是webhook侦听器的示例地址，可以是独立的，也可以是在K8s下运行的。<code class="fe mn mo mp mq b">update-project</code>URL的一部分对应于<code class="fe mn mo mp mq b">hooks.json</code>中的定义。id参数和秘密令牌将被传递给<code class="fe mn mo mp mq b">update-project.sh</code>。</p><p id="50fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mn mo mp mq b">update-project.sh</code>中，我们然后检查令牌(<code class="fe mn mo mp mq b">if [ "$secret" == "228c56aaaBbajk" ]</code>)的有效性，并调用结构化的<code class="fe mn mo mp mq b">curl</code>命令，该命令将使用Gitlab提供的id更新AWX项目。这是非常基本的安全检查，我相信可以改进，但这已经超出了现在的范围。</p><p id="14f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要注意，除了运行简单的项目更新，您还可以在各种事件上从Gitlab调用AWX作业。在这种情况下，看一下<code class="fe mn mo mp mq b">-d '{"extra_vars":{"target":"somehost"}}' \. </code>，虽然这里根本不需要它(因为我们只是更新一个项目)，但如果您需要从模板运行一个作业，我提供它作为参考——这是向它提供(额外)变量的方式。</p><p id="87cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还需要创建一个用户来更新AWX的项目，并为其提供一个简单的“更新”角色来更新相关的项目。然后调整curl请求的用户和密码:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="c183" class="mz ld iq mq b gy na nb l nc nd">-u &lt;awx_user&gt;:&lt;awx_pass&gt;  \</span></pre><p id="a950" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请不要使用您的管理员帐户。</p><p id="8734" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，如果您不知道如何找到您的AWX项目的id，只需从项目菜单中打开有问题的项目并查看URL，它应该类似于:</p><p id="94a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://awx.netcom.local/#/projects/47?project_search=page_size:20;order_by:name" rel="noopener ugc nofollow" target="_blank">https://awx.local/#/projects/54?project _ search = page _ size:20；order_by:名称</a></p><p id="1f98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们的项目id是54，所以来自Gitlab的webhook调用应该是:</p><p id="c0c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="http://172.20.20.17:9000/hooks/update-project?id=54" rel="noopener ugc nofollow" target="_blank">http://172 . 20 . 20 . 17:9000/hooks/update-project？id=54 </a></p><h1 id="0bf2" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">从这里…</h1><p id="7808" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">…只有天空才是极限。既然您现在有了从Gitlab调用AWX操作的基本框架，您可以扩展<code class="fe mn mo mp mq b">hooks.json</code>来读取Gitlab的请求头、请求体或URL的各个部分，并执行您希望的任何操作。AWX和Gitlab都有自己的API，所以你可以混合搭配。当一个新的发布标签被创建时，你可以自动为你的应用提供整个机器集群的场景只有一步之遥！</p><p id="6c34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯……实际上比一步多一点点，但是每条路都有起点。</p></div></div>    
</body>
</html>