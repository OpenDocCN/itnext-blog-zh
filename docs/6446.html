<html>
<head>
<title>Style Development Log 2 — Endpoint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">风格发展日志2 —终点</h1>
<blockquote>原文：<a href="https://itnext.io/style-development-log-2-endpoint-c0a0566b44db?source=collection_archive---------3-----------------------#2021-11-18">https://itnext.io/style-development-log-2-endpoint-c0a0566b44db?source=collection_archive---------3-----------------------#2021-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="d18f" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">加入我们的不和谐社区</em><a class="ae kp" href="https://discord.gg/hdCdYfwS4C" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://discord.gg/bPcscvBM</em></a><em class="iq">获取消息。</em></p></blockquote><p id="539d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我将在一个系列中分享与风格后端框架相关的发展，我已经在<a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/style-backend-framework-d544bdb78a36">文章</a>中宣布了。如果你对<br/>风格没有概念或者不理解下面例子中的组件，请看看主文章。</p><p id="29c4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">众所周知，服务器响应客户端的点称为<code class="fe kt ku kv kw b">endpoint</code>。请求中的所有有效路径都以服务器上的端点结束。此外，在运行良好的服务器上，所有无效路径都应该被重定向到有效路径(即使只是一个发送错误代码的端点。).</p><p id="d80e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">换句话说，端点是服务器中最重要、最丰富的组件。在这种情况下，除了用“样式”尽可能容易地编码之外，我更喜欢不损失性能的方法。</p><h1 id="1290" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">端点组件</strong></h1><p id="e149" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">像所有其他东西一样，<code class="fe kt ku kv kw b">Endpoint</code>是一个<code class="fe kt ku kv kw b">Component</code>。所以它可以放在任何你想放的地方。但是，端点不接收子实例。所有其他组件都有一个/多个子实例。因此，端点构成了组件树的端点。</p><p id="0230" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">基本上，创建端点的方法是创建一个<code class="fe kt ku kv kw b">Endpoint</code>接口。</p><p id="6dc1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">Enpoint接口应该覆盖<code class="fe kt ku kv kw b">onCall</code>方法。该方法在中途处理请求。</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="a70d" class="mi ky iq kw b gy mj mk l ml mm">class MyEndpoint extends Endpoint {</span><span id="80a2" class="mi ky iq kw b gy mn mk l ml mm">  @override<br/>  FutureOr&lt;Object&gt; onCall(Request request) {<br/>    return "Hello World!"<strong class="kw ir">;<br/>  </strong>}</span><span id="5d62" class="mi ky iq kw b gy mn mk l ml mm">}</span></pre><h2 id="fd8b" class="mi ky iq bd kz mo mp dn ld mq mr dp lh kq ms mt ll kr mu mv lp ks mw mx lt my bi translated"><strong class="ak">路线上的地点</strong></h2><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="6143" class="mi ky iq kw b gy mj mk l ml mm">class MyServer extends StatelessComponent {<br/>  const MyServer({Key? key}) : super(key: key)<strong class="kw ir">;<br/><br/>  </strong>@override<br/>  Component build(BuildContext context) {<br/>    return Server(children: [</span><span id="d05c" class="mi ky iq kw b gy mn mk l ml mm">      /// <a class="ae kp" href="http://host:port/hello" rel="noopener ugc nofollow" target="_blank">http://localhost/hello</a><br/>      Route("hello"<strong class="kw ir">, </strong>root: MyEndpoint()<strong class="kw ir"><br/></strong><br/>      ])<strong class="kw ir">;<br/>  </strong>}<br/>}</span></pre><h1 id="f1f4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">状态端点</h1><p id="1624" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">StatefulEndpoint仅在必要时可用于保持状态。</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="68be" class="mi ky iq kw b gy mj mk l ml mm">class MyStatefulEndpoint extends StatefulEndpoint {<br/>  @override<br/>  EndpointState&lt;StatefulEndpoint&gt; createState() =&gt; _MyStatefulEndpointState()<strong class="kw ir">;<br/></strong>}<br/><br/>class _MyStatefulEndpointState extends EndpointState&lt;MyStatefulEndpoint&gt; {<br/>  <br/>  int counter = <strong class="kw ir">0;<br/>  <br/>  </strong>@override<br/>  FutureOr&lt;Object&gt; onCall(Request request) {<br/>    counter++<strong class="kw ir">;<br/>    </strong>return counter<strong class="kw ir">;<br/>  </strong>}<br/>}</span></pre><blockquote class="jn jo jp"><p id="7d41" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">为避免冲突，使用<code class="fe kt ku kv kw b">CallQueue(MyStatefulEndpoint())</code></p></blockquote><h2 id="ae9d" class="mi ky iq bd kz mo mp dn ld mq mr dp lh kq ms mt ll kr mu mv lp ks mw mx lt my bi translated">OnCall返回类型</h2><p id="dab2" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">如您所见，onCall函数应该返回一个对象实例。</p><p id="ab1d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">但是在某些情况下，您可能会得到一个错误。因为支持的类型只有以下几种:</p><blockquote class="jn jo jp"><p id="41ec" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">未来支持。</p></blockquote><p id="23aa" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">1.可编码的(Json可编码的。即使内容类型不是json。也叫Uint8List)</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="aca1" class="mi ky iq kw b gy mj mk l ml mm">return "any"<strong class="kw ir">;</strong></span></pre><p id="8630" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">2.<code class="fe kt ku kv kw b">Response</code>实例(使用request.response(..).这种方式可以设置自定义标题，状态码等。)</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="369f" class="mi ky iq kw b gy mj mk l ml mm">return request.response(Body("message"),statusCode: 230)<strong class="kw ir">;</strong></span></pre><p id="8e0d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">3.AccessEvent(使用当前数据执行事件访问并使用数据进行响应)</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="e42c" class="mi ky iq kw b gy mj mk l ml mm">return Read(collection: "greeters"<strong class="kw ir">, </strong>identifier: "john")<strong class="kw ir">;</strong></span></pre><p id="c592" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">4.DbResult(使用自定义数据访问执行事件，并使用数据进行响应)</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="5a30" class="mi ky iq kw b gy mj mk l ml mm">final db = context<br/>  .findAncestorStateOfType&lt;MyTopLevelDataAccess&gt;()!<br/>  .context.dataAccess<strong class="kw ir">;</strong></span><span id="1e44" class="mi ky iq kw b gy mn mk l ml mm">return db.read(Read(collection: "greeters"<strong class="kw ir">, </strong>identifier: "john"))<strong class="kw ir">;</strong></span></pre><p id="9f80" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">5.车身仪表</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="5ead" class="mi ky iq kw b gy mj mk l ml mm">return Body("data")<strong class="kw ir">; // auto content-type<br/></strong>return JsonBody({"hello" : "world"})<strong class="kw ir">;<br/></strong>return BinaryBody(Uint8List.fromList([]))<strong class="kw ir">;<br/></strong>return StringBody("data")<strong class="kw ir">;</strong></span></pre><blockquote class="jn jo jp"><p id="d7ca" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">有缓存控制端点。跟随我进行缓存控制演示。</p><p id="d03d" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">小型高速缓存控制端点示例:</p></blockquote><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="d6b3" class="mi ky iq kw b gy mj mk l ml mm">class MyLastModifiedEndpoint extends LastModifiedEndpoint {</span><span id="3098" class="mi ky iq kw b gy mn mk l ml mm">  @override<br/>  FutureOr&lt;ResponseWithCacheControl&lt;DateTime&gt;&gt; onRequest(<br/>      ValidationRequest&lt;DateTime&gt; request) {</span><span id="bd89" class="mi ky iq kw b gy mn mk l ml mm">    return ResponseWithLastModified("Hello"<strong class="kw ir">,<br/>        </strong>request: request<strong class="kw ir">, </strong>lastModified: DateTime.now())<strong class="kw ir">;</strong></span><span id="bf1d" class="mi ky iq kw b gy mn mk l ml mm"><strong class="kw ir">  </strong>}</span><span id="9400" class="mi ky iq kw b gy mn mk l ml mm">}</span></pre><h2 id="0803" class="mi ky iq bd kz mo mp dn ld mq mr dp lh kq ms mt ll kr mu mv lp ks mw mx lt my bi translated">提高绩效</h2><p id="8f28" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">通过预先指定端点的返回类型，可以将性能提高3倍。</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="f88a" class="mi ky iq kw b gy mj mk l ml mm">class AnyEndpoint extends Endpoint {<br/>  AnyEndpoint() : super()<strong class="kw ir">;</strong></span><span id="30cc" class="mi ky iq kw b gy mn mk l ml mm"><strong class="kw ir">  /// Prefer type<br/>  </strong>@override<br/>  EndpointPreferredType? get preferredType =&gt;<br/>      EndpointPreferredType.anyEncodable<strong class="kw ir">;<br/><br/>  </strong>@override<br/>  FutureOr&lt;Object&gt; onCall(Request request) {<br/>    return "any"<strong class="kw ir">;<br/>  </strong>}<br/>}</span></pre><p id="7958" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">可用值有:<code class="fe kt ku kv kw b">body </code>、<code class="fe kt ku kv kw b">response </code>、<code class="fe kt ku kv kw b">anyEncodable </code>、<code class="fe kt ku kv kw b">dbResult </code>、<code class="fe kt ku kv kw b">accessEvent .</code></p><blockquote class="jn jo jp"><p id="cd54" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">为什么绩效提高了？不是检查每个请求的返回值类型，而是在返回类型已知的地方创建EndpointCalling实例。</p></blockquote><h1 id="5974" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">简单端点</strong></h1><p id="3c13" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">在核心风格包中有许多简单的组件。与端点相关的简易组件将在下面列出。</p><h2 id="cff7" class="mi ky iq bd kz mo mp dn ld mq mr dp lh kq ms mt ll kr mu mv lp ks mw mx lt my bi translated">简单端点</h2><p id="145f" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">您可以只定义onCall函数，而不是定义一个接口。</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="f3df" class="mi ky iq kw b gy mj mk l ml mm">SimpleEndpoint((request<strong class="kw ir">,</strong>context) =&gt; <br/>"Hello ${request.arguments["user"]}!"<br/>)<strong class="kw ir">,</strong></span></pre><p id="1270" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">对于静态响应。</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="f6d0" class="mi ky iq kw b gy mj mk l ml mm">SimpleEndpoint.static("Hello World!")<strong class="kw ir">,</strong></span></pre><h2 id="64c1" class="mi ky iq bd kz mo mp dn ld mq mr dp lh kq ms mt ll kr mu mv lp ks mw mx lt my bi translated">接入点</h2><p id="4773" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">接入点使用当前数据访问执行由eventBuilder创建的访问事件，并将数据发送到客户端。</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="7281" class="mi ky iq kw b gy mj mk l ml mm">AccessPoint((req<strong class="kw ir">, </strong>_) =&gt; Read(<br/>    request: req<strong class="kw ir">,<br/>    </strong>collection: "greeters"<strong class="kw ir">,<br/>    </strong>identifier: req.arguments["user"]!))<strong class="kw ir">,</strong></span></pre><h2 id="ccf0" class="mi ky iq bd kz mo mp dn ld mq mr dp lh kq ms mt ll kr mu mv lp ks mw mx lt my bi translated">RestAccessPoint</h2><p id="4125" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">根据Rest Api标准，它是一个AccessPoint定义。</p><p id="a283" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">查看剩余的<a class="ae kp" href="https://github.com/Mehmetyaz/style/blob/main/packages/style/documentation/data_access/simple_access_point.md" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="4999" class="mi ky iq kw b gy mj mk l ml mm">RestAccessPoint("route")<strong class="kw ir">,</strong></span></pre><h2 id="2993" class="mi ky iq bd kz mo mp dn ld mq mr dp lh kq ms mt ll kr mu mv lp ks mw mx lt my bi translated">内容交付</h2><p id="07fd" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">它为你的文件服务。支持缓存控制和监视更改。</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="a024" class="mi ky iq kw b gy mj mk l ml mm">ContentDelivery("/directory/to/contents")</span></pre><h2 id="1dc6" class="mi ky iq bd kz mo mp dn ld mq mr dp lh kq ms mt ll kr mu mv lp ks mw mx lt my bi translated">扔</h2><p id="6eed" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">始终投掷终点</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="41cc" class="mi ky iq kw b gy mj mk l ml mm">Throw(ServiceUnavailable("coming_soon"))<strong class="kw ir">,</strong></span></pre><h2 id="bcc8" class="mi ky iq bd kz mo mp dn ld mq mr dp lh kq ms mt ll kr mu mv lp ks mw mx lt my bi translated">再直接的</h2><p id="d7d8" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">将请求重定向到内部或外部路径。</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="dd12" class="mi ky iq kw b gy mj mk l ml mm">Redirect("../hello")<strong class="kw ir">,<br/></strong>Redirect("https://www.google.com")<strong class="kw ir">,</strong></span></pre><p id="b456" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">或者由请求产生</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="5680" class="mi ky iq kw b gy mj mk l ml mm">GeneratedRedirect(<br/>  generate: (r) =&gt; "../hello?u=${r.arguments["user"]}"<br/>)<strong class="kw ir">,</strong></span></pre></div></div>    
</body>
</html>