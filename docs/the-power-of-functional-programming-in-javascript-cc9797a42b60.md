# Javascript 中函数式编程的威力

> 原文：<https://itnext.io/the-power-of-functional-programming-in-javascript-cc9797a42b60?source=collection_archive---------1----------------------->

![](img/94a63d5edffef842444ba971d893d492.png)

几年前，我犯了一个简单的编码错误，这个错误让我开始欣赏函数式编程及其好处。在开发一个 Javascript 应用程序时，我向一个函数传递了一个键-值对的数组，目的是对传入数组的元素进行一些值更改，并发回一个包含这些更改的**全新的**数组。

然而，我没有使用[映射](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)函数或其他生成新**数组的方法，而是简单地让函数对传入的数组进行这些更改，并将原来的**数组返回给调用者。****

在 Javascript 中，**原语数据类型**(字符串、数字、布尔、空和未定义)通过值传递**，通过引用**传递**对象**。这意味着原始数据类型是**不可变的**，对象是**可变的**。

在我的程序中，通过改变原始数组，我改变了这个数组**的状态，只要它在程序**中被引用。

当我运行我的代码时，我不明白为什么我在应用程序中的原始用户列表会发生意外变化，直到一位同事指出发生了什么。

如果遵循了函数式编程的主要范例，我就不会犯这个错误。这篇文章的目的是解释什么是函数式编程，以及为什么它是一个值得遵循的范例。

# 什么是函数式编程？

函数式编程是一种将计算视为对**值**的操纵，避免改变 [**状态**](https://en.wikipedia.org/wiki/Program_state) 和 [**可变**](https://en.wikipedia.org/wiki/Immutable_object) 数据的范式。

在函数代码中，函数的输出值只取决于传递给函数的 [**参数**](https://en.wikipedia.org/wiki/Function_argument) 。换句话说，用参数 *x* 的*相同的*值调用函数 *f* 两次，每次都会产生*相同的*结果 *f(x)* 。

这与面向过程和面向对象的程序形成对比，它们通常依赖于一个[局部](https://en.wikipedia.org/wiki/Local_state)或[全局状态](https://en.wikipedia.org/wiki/Global_variable)，当用相同的参数但不同的程序状态调用时，它们可能在不同的时间产生不同的结果。

通过消除这些副作用，函数式程序变得可预测、简单、易于理解、松散耦合和可扩展。

让我们进一步解开**状态**和**可变性**。

# 可变和不可变

*不可变*表示状态创建后不能修改。*可变*表示状态创建后可以修改。在 Javascript 中，原始数据类型是不可变的。任何*对象*(键值对、数组、函数、用‘new’关键字创建的对象)在 Javascript 中都是可变的，并且在创建后可以修改。

# 状态

如果一个程序被设计成能记住之前的事件或用户交互，它就被描述为有状态的；记忆的信息称为系统的**状态**。

因此，状态跟踪变量和对象在**时间**内的变化。

在编程中，状态是由相关函数的参数之外的变量来维护的。

像 C++和 Java 这样的面向对象语言在类和对象中以成员变量的形式大量使用状态变量。像 C 这样的过程语言通常使用在当前范围之外声明的全局变量来跟踪状态。

然而，在 Javascript 中，这是不鼓励的。使用可变数据维护状态变量将意味着函数将具有隐藏的或不可预测的依赖关系，这与 javascript 的函数纯度不一致。

好的，但是如果维护状态是 Javascript 应用程序中的一个关键需求，那么这是如何实现的呢？

幸运的是，以一种纯功能的方式跟踪状态是可能的。我们通过将状态信息从一个函数传递到下一个函数来做到这一点，从而使这些依赖关系**显式**(而不是将它们**隐式**存储在可变数据中)。

因此，功能方法是从先前的状态返回新的状态。这些函数本身不保存任何信息，因此它们总是将状态 *m* 更新为状态 *n* 。

纯函数因此可以被组合，以提供事件流，这些事件流**明确地模拟时间**，而不依赖于外部状态。

在面向对象编程中，一个代码**对象**代表一个域对象的状态；它会随着时间的推移而变化，以反映该域对象的变化。

在函数式编程中，一个**值**代表一个域对象的状态；它永远不会改变，你只是创建不同的值来代表不同的状态。

# 但是基于值的编程有多高效呢？

在你的内心深处，也许你会认为这种范式(总是从一个函数返回一个新值，从不改变一个现有的值)是低效的。

![](img/adf17a82c0aa0efe3f9b0531587e5965.png)

例如，假设我有一个一百万整数的列表，并希望将第十个增加一个单位。复制第十个位置有新数字的整个列表是一种浪费。

你可能是对的，但这只是向语言编译器或解释器描述操作的概念性方式。编译器或解释器可以随意获取第一个列表，只覆盖第十个位置。

Javascript 编译器因此被优化以使纯函数高效。持久数据结构被设计成有效地重用以前的结构，因此一个变化只提供一个**增量**，而不是一个全新的再现。

通过将变异细节留给编译器，事情也变得更有效，更不容易出错。如果编译器能够推理出当许多线程想要在不同位置更新同一列表时的情况，则由编译器来确保覆盖不会发生冲突。相反，如果操作被描述为“转到这个位置并覆盖您找到的内容”，那么负责确保覆盖不冲突的是程序员，而不是编译器。将这些操作细节留给程序员会导致令人讨厌的错误、[竞争条件](https://searchstorage.techtarget.com/definition/race-condition)和缺乏并发性。

好了，我们来看一些函数式编程的可视化表示，让概念更清晰。

# 一本活页本

![](img/7543bb69ac3b604c70fd4802c802d6f7.png)

在一本活页本中，每一页都代表了当时的世界。随后的每一页都通过略微修改之前的表述来推进故事的发展。

在一个功能性翻页书程序中，会有一个函数接受一个**翻页书页面**作为参数并返回一个新页面。

以这种方式，故事“展开”而不会实际改变现有对象的状态。我们只是用新的一页取代每一页。当我们完成后，我们就有了一个完整的翻页书，它可以向后和向前翻页，因为该功能只是在书中添加了新的页面，而不会改变书中任何现有页面的状态。

在本例中，我们生成了一个简单的功能性 ASCII 艺术“翻页书”，它被记录到控制台。

# 传送带

![](img/8c8609c82be0c827cedad94daf09cd94.png)

在传送带或装配线上，原始输入沿着传送带上的不同步骤向下传递，每一步都以某种方式添加或修改物品，并将其传递给传送带上的下一个功能。

功能可以被认为是将原始输入(零件)转化为加工产品(输出)的步骤。).函数式编程中的装配线**构建新的输出，同时保持输入不变**，而传统面向对象编程中的装配线**转换输入**。

一个简单实用的“传送带”处理器。

# 从价值观的角度思考

概念化和理解函数式编程的好处的一个好方法是根据**值**来思考。

在函数式编程的世界中，一切都是一个值，您可以将函数应用于值(可能是函数)以产生新的值，最好不会产生任何副作用。

[**Rich Hickey**](https://purelyfunctional.tv/programmer-profiles/rich-hickey/)[clo jure](https://clojure.org/)(一种函数式编程语言)的作者在 [**这个优秀的视频**](https://www.infoq.com/presentations/Value-Values) 中总结了这个概念。

简而言之，他解释说可变对象是位置的抽象，或者是内存地址的方便表示，或者是持久存储中的表/文档/记录的方便表示。

他将这种范式称为面向位置的编程(PLOP ),并解释了它是如何从早期计算机的限制中诞生的，在早期计算机中，RAM 和持久存储昂贵且短缺，使得以位置为中心的实现成为必要。

在现代计算中，这些限制不再存在。因此，位置不再是一个关注点，在信息模型中也没有相关性。这只是一个实施细节，我们不应该把它提升到一等公民的地位。相反，程序应该只关心自己的价值。

在面向值的编程模型中，值是不可变的、容易共享的、语义透明的(你可以看到它是什么)。

> 如果你遇到一个值，你可以开始使用它，因为它是不可变的！这是函数式编程和高阶函数的关键。你可以无处不在地分享，你永远不需要担心你不能搞乱别人，也没有人能搞乱你。

Rich 描述的价值编程的其他一些令人敬畏的好处是:

对值的运算**稳定**(对相同的值执行相同的运算将总是产生相同的答案)。这意味着很容易产生结果。因此，测试和调试可以再现故障，而无需首先复制状态。

值与**语言无关**，支持多语言编程。地点是由语言结构定义的。所以对于地点，你没有一个独立于你的语言的定义，你可以用它作为信息共享的基础。

值为**通用**。它们由很少的值类型组成(列表、映射、集合、字符串、数字)。这意味着它们很容易用任何语言来表示，并且它们的集合有基本的抽象。

价值观造就最好的**界面**。数据驱动的界面简单且易于移动。他们也可以很容易地排队。在面向位置的编程中，接口是特定于类的，这意味着重用不容易。来自不同命名空间的类是不可互操作的。

位置与应用程序、语言和程序流紧密相关。**值聚合为值**。这意味着你可以添加、吸收和合成价值观。所有这些好处对作文也有好处。相比之下，合并或组合位置没有任何好处。

价值观很容易传递价值观，无忧无虑。为了共享位置，你需要发送一个可以改变的对象的引用(它是可变的)。我们只需要看看互联网就知道这是实践:所有从客户机通过 HTTP 发送到服务器的数据都是值(JSON、text、blobs)，而不是对象。

记住价值观很容易:复制一份就行了。记忆地点是困难的，因为它是可变的，所以会随着它的一生而改变。价值观稳定。地方不是。

# **函数式编程和 Javascript 库/框架。**

世界上最流行的两个客户端 Javascript 库/框架是 [**React**](https://reactjs.org/) 和 [**Angular**](https://angular.io/) 。两者都解决了反应式编程的难题，也就是说，根据应用程序状态的变化有效地更新视图或用户界面。

React 使用**组件**、**状态**和**道具**的范例设计了一个架构。

Angular 决定使用 [**RxJS**](https://rxjs-dev.firebaseapp.com/) 作为其 MVC 架构的关键组件。

然而，两者都需要通过使用**纯函数和不可变状态**来维护状态。

> 所有的 React 组件必须表现得像纯函数一样
> 
> [‘RxJS 的强大之处在于它能够使用纯函数产生值。这意味着你的代码不容易出错。](https://rxjs-dev.firebaseapp.com/guide/overview)

# 参考

[](https://dev.to/navi/why-functional-programming-matters-2o95) [## 为什么函数式编程很重要

### navneet sa hota Jul 8 ' 183min readAt Pesto，我们最近学到了两件事:有意识地编程和…

开发到](https://dev.to/navi/why-functional-programming-matters-2o95) [](https://www.sitepoint.com/immutability-javascript/) [## JavaScript - SitePoint 中的不变性

### Christian Johansen 介绍了什么是不变性，如何在 JavaScript 中使用不变性，以及它为什么有用。

www.sitepoint.com](https://www.sitepoint.com/immutability-javascript/) [](https://www.infoq.com/presentations/Value-Values) [## 主题演讲:价值观的价值

### Rich Hickey 比较了面向值的编程和面向位置的编程，得出的结论是命令的时间…

www.infoq.com](https://www.infoq.com/presentations/Value-Values) [](https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State) [## haskell/理解单子/状态- Wikibooks，开放世界的开放书籍

### 如果你以前用其他语言编程过，你可能写过一些“保持状态”的函数。对于那些新的…

en.wikibooks.org](https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State) [](https://en.wikipedia.org/wiki/Functional_programming) [## 函数式编程-维基百科

### 编辑描述

en.wikipedia.org](https://en.wikipedia.org/wiki/Functional_programming)