<html>
<head>
<title>Setup a Micro Frontend Architecture With Vue and single-spa</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue和单spa设置微前端架构</h1>
<blockquote>原文：<a href="https://itnext.io/setup-a-micro-frontend-architecture-with-vue-and-single-spa-2c89528bf72f?source=collection_archive---------0-----------------------#2020-08-26">https://itnext.io/setup-a-micro-frontend-architecture-with-vue-and-single-spa-2c89528bf72f?source=collection_archive---------0-----------------------#2020-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="32dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<a class="ae kl" href="https://single-spa.js.org/" rel="noopener ugc nofollow" target="_blank"> single-spa </a>通过多个Vue.js应用构建微前端架构的实践演练。请注意，您可以用自己选择的框架替换Vue。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><blockquote class="kt ku kv"><p id="348b" class="jn jo kw jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">听听<a class="ae kl" href="https://viewsonvue.com/building-micro-frontends-with-lawrence-almeida-vue-160" rel="noopener ugc nofollow" target="_blank">对Vue第160集</a>的看法，在那里我讨论了我们如何在<a class="ae kl" href="https://unbabel.com/" rel="noopener ugc nofollow" target="_blank">unbal</a>实现这个架构的细节。</p></blockquote></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/75afbe2a9495fe2ab5b1c347a760c3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JU46xiDLVBPiLJc49IXhw.jpeg"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">照片由<a class="ae kl" href="https://unsplash.com/s/photos/blocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kl" href="https://unsplash.com/@lastnameeaster?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> La-Rel复活节</a>拍摄</figcaption></figure><p id="c18a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">三部分指南的第一部分，旨在为如何使用single-spa为您的项目设置和组织微前端架构奠定基础。</p><p id="9ad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第1部分</strong> —设置orchestrator层，加载必要的资产、第三方库和我们的微应用；</p><p id="71fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二部分(TBD) </strong> —组织通用的风格和可重用的组件；在应用程序之间共享和操作状态；</p><p id="3577" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第3部分(TBD) </strong> —部署到网络，同时避免并发；</p><h1 id="e2e7" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">什么是微前端？</h1><p id="3f28" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">微前端的概念已经存在了一段时间，但在过去几年里得到了更多的关注。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi mt"><img src="../Images/171f05c804221552f9fdb1cb85007a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oAojPr5rh4XmW5wTXJGN6w.jpeg"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">2015-2020年谷歌趋势上搜索词“微前端”的演变</figcaption></figure><p id="a011" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微前端扩展了后端微服务的概念:将一个web应用程序(一个整体SPA)分解成不同的部分。然后，通过orchestrator层，将每个部分组装(或组合)在一起。这样做有多种方式。在我们的例子中，我们将使用单spa进行所谓的客户端组合。</p><h1 id="0093" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">什么时候应该使用这种方法？</h1><p id="5f8d" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在<a class="mu mv ep" href="https://medium.com/u/f67c142acd49?source=post_page-----2c89528bf72f--------------------------------" rel="noopener" target="_blank">un label</a>我们目前为一款面向客户的新产品使用微前端架构。</p><p id="31cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像任何技术决策一样，也有权衡。在决定采用这种方法时，我们权衡了几个因素:</p><ul class=""><li id="4092" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">要构建的产品将由至少6个不同的区域组成，即界面；</li><li id="18f8" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">几个多学科团队将拥有并完全自主地交付产品的各个部分；</li><li id="f159" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">有可能部分改变产品堆栈的部件。虽然Vue是公司选择的框架，但我们不知道3年后它是否还是我们想要使用的；</li></ul><p id="bb90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">你应该考虑这些优势:</strong></p><ul class=""><li id="6007" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">团队在以不同的速度向产品交付价值方面有更大的自主权，因为他们的开发可以很大程度上独立于其他团队；</li><li id="0be7" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">拥有完全独立的存储库、测试和部署流程的能力；</li><li id="2e10" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">能够轻松覆盖部分应用程序界面(即A/B测试、增量展示)；</li><li id="636a" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">在不影响应用程序其他部分的情况下，并行使用不同的框架或进行实验；</li><li id="a3d7" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">能够重构产品的一部分，而不必一次全部改变；</li></ul><p id="8d3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">你应该考虑这些警告:</strong></p><ul class=""><li id="0a10" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">根据您正在构建的产品的范围和特性，设置、部署和维护的开销会增加；</li><li id="8d0b" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">更多可移动的部分:重要的是要有一个可靠的文档来说明一切是如何设置和关联的，以及定义指导方针来管理如何在架构中进行开发；</li><li id="8de4" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">让开发人员更深入地了解架构、其生命周期和依赖性。因此，拥有完整的文档是必要的；</li><li id="4544" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">微前端仍然相对较新，对于如何实现这一点，没有放之四海而皆准的方法或公认的共识。根据你的情况，准备好做相当多的R&amp;D；</li></ul><p id="4a07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据我的经验，在构建相对较大的web应用程序时，这种方法是最好的，在这种情况下，您希望为多个团队提供灵活性，并有足够的时间致力于治理和文档编制。</p><p id="7483" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">话虽如此，你绝对可以和2-3人的团队甚至是单独的团队一起利用许多微前端的优势。</p><h1 id="3295" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">架构图</h1><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nk"><img src="../Images/2c359e6b44cb352e216eaf6f225f10c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PV9IrLdAEB-BJAFXQgEvfA.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">简而言之:供应商依赖关系从CDN加载，app 1和2捆绑包从S3/GCS加载，我们的orchestrator将它们组合/捆绑在一起。</figcaption></figure><h1 id="7cd7" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">构建Orchestrator应用程序</h1><p id="bce2" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">orchestrator应用程序只不过是持有single-spa的项目，single-spa负责根据应用程序的激活功能来决定加载哪些应用程序(稍后将详细介绍)。</p><p id="448a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本演练遵循单温泉的<a class="ae kl" href="https://single-spa.js.org/docs/recommended-setup" rel="noopener ugc nofollow" target="_blank">推荐设置</a>。还可以查看<a class="ae kl" href="https://github.com/vue-microfrontends" rel="noopener ugc nofollow" target="_blank"> vue-microfrontends示例repo </a>。</p><h2 id="aad4" class="nl lr iq bd ls nm nn dn lw no np dp ma jy nq nr me kc ns nt mi kg nu nv mm nw bi translated">创建项目</h2><ol class=""><li id="340a" class="mw mx iq jp b jq mo ju mp jy nx kc ny kg nz kk oa nc nd ne bi translated">创建一个父文件夹，将所有项目文件夹和<em class="kw"> cd </em>放入其中；</li><li id="92b2" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated">创建一个名为<em class="kw"> orchestrator </em>的文件夹，并将<em class="kw"> cd </em>放入其中；</li><li id="1819" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated">运行<em class="kw"> npm init </em>创建一个空的<em class="kw"> package.json — </em>当询问入口文件名时，将其设置为<em class="kw">main . js；</em></li><li id="b8e1" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated">修改<em class="kw"> package.json的</em>脚本:</li></ol><pre class="lb lc ld le gt ob oc od oe aw of bi"><span id="9abb" class="nl lr iq oc b gy og oh l oi oj">...<br/><em class="kw">"scripts"</em>: {<br/>  <em class="kw">"serve"</em>: "webpack-dev-server --mode=development --env.isLocal=true",<br/>  <em class="kw">"lint"</em>: "eslint src",<br/>  <em class="kw">"prettier"</em>: "prettier --write './**'",<br/>  <em class="kw">"build"</em>: "webpack --mode=production"<br/>},<br/>...</span></pre><p id="c32d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.安装所需的依赖项:</p><pre class="lb lc ld le gt ob oc od oe aw of bi"><span id="602b" class="nl lr iq oc b gy og oh l oi oj">npm i -D @babel/core @babel/preset-env @types/systemjs babel-eslint babel-loader clean-webpack-plugin concurrently eslint eslint-config-important-stuff eslint-config-prettier eslint-plugin-prettier html-webpack-plugin mini-css-extract-plugin prettier pretty-quick webpack webpack-cli webpack-dev-server <em class="kw">dotenv-webpack</em></span></pre><h2 id="6a87" class="nl lr iq bd ls nm nn dn lw no np dp ma jy nq nr me kc ns nt mi kg nu nv mm nw bi translated">添加index.ejs</h2><p id="acc7" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">这是我们的用户在访问我们的应用程序时会碰到的。它使用<a class="ae kl" href="https://ejs.co/" rel="noopener ugc nofollow" target="_blank"> EJS </a>在构建时轻松生成HTML标记。</p><p id="257b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Orchestrator文件夹的根目录下，创建一个<em class="kw"> index.ejs </em>文件，并添加以下内容:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9a70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这里发生了什么？</strong></p><ol class=""><li id="3021" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk oa nc nd ne bi translated">我们希望通过<a class="ae kl" href="https://github.com/WICG/import-maps" rel="noopener ugc nofollow" target="_blank">导入映射</a>在浏览器中使用“裸导入说明符”。因为导入映射规范只在Chrome中实现，所以我们将使用<a class="ae kl" href="https://github.com/systemjs/systemjs" rel="noopener ugc nofollow" target="_blank"> SystemJS </a>来加载我们的导入映射(第9行)并导入我们想要的模块(第25行)；</li><li id="f031" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated">第12–13行允许我们加载额外的模块或者覆盖在<em class="kw"> importmap.json中定义的模块；</em></li><li id="e2dd" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated">第25行加载我们项目的入口点(<em class="kw">main . js</em>)；</li><li id="6a00" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated">因为SystemJS是一个动态JS模块加载器，并且通过使用<a class="ae kl" href="https://github.com/joeldenning/import-map-overrides" rel="noopener ugc nofollow" target="_blank"> import-map-overrides </a>(第27行)，我们能够动态地重新加载模块(稍后将详细介绍)；</li><li id="adbe" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated"><em class="kw"> style </em>标签暂时是临时的，只是用来样式化我们将在本演练的第2部分中使用的Snackbar</li></ol><p id="cdc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这种浏览器ES模块+导入映射的方法<a class="ae kl" href="https://single-spa.js.org/docs/recommended-setup" rel="noopener ugc nofollow" target="_blank">有几个优点</a>，但主要是，它允许我们只加载一次跨微应用程序共享的依赖项(例如Vue)并在应用程序之间轻松共享通用代码。</p><h2 id="f2a4" class="nl lr iq bd ls nm nn dn lw no np dp ma jy nq nr me kc ns nt mi kg nu nv mm nw bi translated">添加importmap.json</h2><p id="71d5" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在项目的根目录下创建一个名为<em class="kw"> importmap.json </em>的文件，并添加以下内容:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="13d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个文件决定了我们想要在浏览器中导入的位置。目前，我们只加载我们的架构所需的库，但是一旦这些库可用，它也会指向我们的应用程序的位置。我们现在在本地加载它，但是这个JSON文件也应该是独立服务的，允许你从任何CI/CD过程中单独地改变它。例如，您可以使用<a class="ae kl" href="https://jsonbin.io/" rel="noopener ugc nofollow" target="_blank"> jsonbin.io </a>来托管JSON(仅用于测试)并轻松地更改其内容。</p><p id="9f92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了基本的依赖关系(<em class="kw"> single-spa </em>，<em class="kw">vue</em>&amp;<em class="kw">vue-router</em>)，我们还导入了两个库，我们将在本演练的第二部分中使用:</p><ul class=""><li id="4390" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><a class="ae kl" href="https://github.com/mroderick/PubSubJS" rel="noopener ugc nofollow" target="_blank"> pubsub-js </a>，发布/订阅模式实现，将充当事件总线；</li><li id="d173" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><a class="ae kl" href="https://www.polonel.com/snackbar/" rel="noopener ugc nofollow" target="_blank"> snackbar </a>，一个素材风格通知敬酒；</li></ul><h2 id="88f8" class="nl lr iq bd ls nm nn dn lw no np dp ma jy nq nr me kc ns nt mi kg nu nv mm nw bi translated">添加local-importmap.json</h2><p id="4baf" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">拥有一个本地导入映射对于本地开发来说是至关重要的，否则我们需要本地旋转每个微前端，以使整个架构正常运行。<em class="kw"> local-importmap.json </em>允许我们添加和覆盖在<em class="kw"> importmap.json </em>中定义的任何东西(即，覆盖一个在暂存或生产中的应用，或者加载一个不同版本的Vue)。</p><p id="6696" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将只为在本地运行的Orchestrator应用程序定义入口点:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f268" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将此文件添加到您的<em class="kw">中。gitignore </em>，允许团队成员根据他们的工作导入不同的应用，而不影响其他人的导入。</p><h2 id="16ad" class="nl lr iq bd ls nm nn dn lw no np dp ma jy nq nr me kc ns nt mi kg nu nv mm nw bi translated">添加webpack.config.js</h2><p id="3d33" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在项目的根目录下创建一个webpack.config.js，并向其中添加以下内容:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="66ca" class="nl lr iq bd ls nm nn dn lw no np dp ma jy nq nr me kc ns nt mi kg nu nv mm nw bi translated">添加<em class="om">。环境</em></h2><p id="4acc" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">折出一个<em class="kw">。env </em>文件，内容为:</p><pre class="lb lc ld le gt ob oc od oe aw of bi"><span id="3054" class="nl lr iq oc b gy og oh l oi oj">NODE_ENV=development</span></pre><h2 id="5fbc" class="nl lr iq bd ls nm nn dn lw no np dp ma jy nq nr me kc ns nt mi kg nu nv mm nw bi translated">添加main.js</h2><p id="ec20" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">添加一个<em class="kw"> main.js </em>文件，内容如下:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="90c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在入口点非常简单:它导入<em class="kw"> single-spa </em>，等待所有模块被导入(<em class="kw">pubsub-js</em>&amp;<em class="kw">snack bar</em>)，一旦被加载，启动<em class="kw"> single-spa </em>并显示一个成功提示。随着架构的发展，我们将向该文件添加更多内容。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="3702" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在可以运行<em class="kw"> npm run serve </em>并访问<em class="kw"> http://localhost:5000 </em>。如果一切顺利，你应该会看到左下角的祝酒词写着“单人水疗已加载”。</p><p id="c05d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有了基本的设置，我们将使用它来加载和编排我们将要构建的微前端。</p><p id="13d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">orchestrator应用程序应该看起来像这样。</p><h1 id="8b5b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">创建第一个Vue应用</h1><p id="8a2c" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我们的Vue应用程序需要进行一些小的修改，以便可以在<em class="kw"> single-spa </em>中注册。幸运的是，single-spa允许轻松地<a class="ae kl" href="https://single-spa.js.org/docs/ecosystem" rel="noopener ugc nofollow" target="_blank">与所有主要框架</a>集成。</p><p id="765d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们将使用<a class="ae kl" href="https://github.com/single-spa/vue-cli-plugin-single-spa" rel="noopener ugc nofollow" target="_blank">vue-CLI-plugin-single-spa</a>为我们执行这些更改。</p><ol class=""><li id="aea0" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk oa nc nd ne bi translated">在父文件夹中，创建一个名为<em class="kw"> app-one </em>的Vue应用:</li></ol><pre class="lb lc ld le gt ob oc od oe aw of bi"><span id="0ba8" class="nl lr iq oc b gy og oh l oi oj">vue create app-one</span></pre><p id="3348" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<em class="kw">将</em>CD到<em class="kw"> app-one </em>中，安装<em class="kw"> single-spa </em> Vue插件，该插件将按照此处所述的<a class="ae kl" href="https://single-spa.js.org/docs/ecosystem-vue/" rel="noopener ugc nofollow" target="_blank">执行更改:</a></p><pre class="lb lc ld le gt ob oc od oe aw of bi"><span id="758e" class="nl lr iq oc b gy og oh l oi oj">vue add single-spa</span></pre><p id="71b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.安装<em class="kw"> webpack </em>的<em class="kw"> EventHooksPlugin: </em></p><pre class="lb lc ld le gt ob oc od oe aw of bi"><span id="39f2" class="nl lr iq oc b gy og oh l oi oj">npm i -D event-hooks-webpack-plugin</span></pre><p id="2d67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.通过删除<em class="kw">组件</em>、<em class="kw">资产</em>和<em class="kw">公共</em>文件夹，从Vue中清除样板代码，并修改<em class="kw"> App.vue </em>如下:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="4710" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.创建一个<em class="kw"> vue.config.js </em>并添加以下内容:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="45cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里需要注意一些事情:</p><ul class=""><li id="b8e2" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">我们告诉<em class="kw"> webpack </em>我们希望输出在bundle文件夹的根目录下完成(第17行)；</li><li id="ea0b" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">我们通过<em class="kw"> config.externals </em>告诉webpack不要在最终捆绑包中包含一些依赖项，因为Vue和vue-router将由Orchestrator应用程序提供；</li><li id="75a5" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">我们没有散列文件名；</li><li id="251f" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">我们正在从<em class="kw">dist</em>build文件夹中删除<em class="kw">index.html</em>，因为它没有必要；</li></ul></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="e5f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">App-one现在应该像这个分支中的<a class="ae kl" href="https://github.com/mstrlaw/app-one/tree/0-bare-bones" rel="noopener ugc nofollow" target="_blank">所示进行设置。让我们旋转它并确保它的入口文件是可访问的。</a></p><p id="8d17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行<em class="kw"> npm运行serve </em>访问<em class="kw">http://localhost:8080/app . js .</em>你应该能看到编译好的Javascript <em class="kw">。</em></p><h2 id="a422" class="nl lr iq bd ls nm nn dn lw no np dp ma jy nq nr me kc ns nt mi kg nu nv mm nw bi translated">向single-spa注册应用程序</h2><p id="52a0" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我们现在需要告诉<em class="kw"> single-spa </em>我们想要注册一个应用程序，以便在Orchestrator应用程序中安装它。在Orchestrator应用程序中:</p><ol class=""><li id="662a" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk oa nc nd ne bi translated">将模块条目添加到<em class="kw"> local-importmap.json </em>以便SystemJS可以导入它:</li></ol><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="56ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>键值"<em class="kw"> app-one" </em>必须与位于<em class="kw">src/set-public-path . js .</em>中的app的<em class="kw"> setPublicPath </em>函数使用的键值相同</p><p id="4768" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.修改<em class="kw"> main.js </em>，使其看起来像这样:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="0e63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里<a class="ae kl" href="https://single-spa.js.org/docs/api#registerapplication" rel="noopener ugc nofollow" target="_blank"> registerApplication </a>用于在<em class="kw"> single-spa中注册一个app。</em></p><p id="d335" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kw"> activeWhen </em> </strong>是一个重要的功能(激活功能)，本质上决定了这个app应该在什么时候挂载。它必须返回<em class="kw"> true </em>才能安装它。在本例中，我们只是希望当前位置以“/”开头，但是您可以验证许多其他方面，例如用户是否有特定的角色、设备类型等。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi on"><img src="../Images/390a03e02434f767e90024611608af76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HgFlCgEhHwz4laydtEkFkg.gif"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">通过Chrome的开发工具检查应用程序</figcaption></figure><p id="4e10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在访问<a class="ae kl" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>应该会看到文字“App One”。如果我们使用开发人员工具检查浏览器的代码，我们可以看到single-spa将我们的应用程序附加到body标签上。</p><p id="6ca7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以继续更改<em class="kw"> H1 </em>标签的内容，并验证热代码重载功能是否按预期工作。</p><h1 id="1306" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">创建第二个Vue应用程序</h1><p id="72a7" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我们现在将按照上一节中的步骤1至5创建另一个Vue应用程序，但这些更改除外:</p><ol class=""><li id="a889" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk oa nc nd ne bi translated">命名为“app-two”；</li><li id="d3fe" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated">将<em class="kw"> vue.config.js </em>中的端口号改为8081，以避免与<em class="kw"> app-one的端口冲突；</em></li><li id="6ed0" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated">将<em class="kw"> App.vue </em>中<em class="kw"> H1 </em>标签的内容修改为“App Two”；</li></ol><h2 id="32b7" class="nl lr iq bd ls nm nn dn lw no np dp ma jy nq nr me kc ns nt mi kg nu nv mm nw bi translated">注册应用程序-二</h2><ol class=""><li id="4551" class="mw mx iq jp b jq mo ju mp jy nx kc ny kg nz kk oa nc nd ne bi translated">同样，我们将把模块入口点添加到我们的local-importmap.json文件中，看起来像这样:</li></ol><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="b888" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.现在将它注册到<em class="kw"> main.js </em>中，但这次我们将抽象一下应用程序是如何注册的:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="7fa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在访问http://localhost:5000，我们应该会看到我们的两个应用程序:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi on"><img src="../Images/e31aa349ff31888347bdfbe545d59d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Khnb91P43Fk5vpJULHbVDA.gif"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">我们的两个应用程序显示在彼此之上。</figcaption></figure><p id="75fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个阶段，你的代码应该是这样的<a class="ae kl" href="https://github.com/mstrlaw/orchestrator/tree/1-add-microapp" rel="noopener ugc nofollow" target="_blank">用于<em class="kw">编排器</em>，这样的</a><a class="ae kl" href="https://github.com/mstrlaw/app-one/tree/0-bare-bones" rel="noopener ugc nofollow" target="_blank">用于<em class="kw"> app-one </em>，这样的</a><a class="ae kl" href="https://github.com/mstrlaw/app-two/tree/0-bare-bones" rel="noopener ugc nofollow" target="_blank">用于<em class="kw"> app-two </em>。</a></p><h1 id="86f2" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">控制布局</h1><p id="8544" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">请注意，在上面的图片中，我们的应用程序堆叠在一起。</p><p id="fa36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是<em class="kw">单spa </em>的默认行为。如果你只允许在每个位置安装一个app(即<em class="kw">app-一个</em>用于<em class="kw"> /foo </em>和<em class="kw">app-两个</em>用于<em class="kw"> /bar </em>)，这应该不成问题。</p><p id="aa6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果你想同时安装两个应用程序并控制它们的位置呢？为此，我们可以使用<a class="ae kl" href="https://vuejs.org/v2/api/#el" rel="noopener ugc nofollow" target="_blank"> appOption.el </a>来定义我们希望Vue在哪里安装应用程序。</p><h2 id="669c" class="nl lr iq bd ls nm nn dn lw no np dp ma jy nq nr me kc ns nt mi kg nu nv mm nw bi translated">定义占位符元素</h2><p id="74b2" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我们将分别在id为“appOne-placeholder<em class="kw">”</em>和“app two-placeholder<em class="kw">”</em>的元素中安装<em class="kw"> app-one </em>和<em class="kw"> app-two </em>。我们已经用决定占位符如何定位的内容替换了样式标签(我们稍后将应用前面的样式)。</p><ol class=""><li id="1e6b" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk oa nc nd ne bi translated">首先，我们必须修改Orchestrator的<em class="kw"> index.ejs </em>来为微前端提供接收占位符。修改文件，使其看起来像:</li></ol><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="a396" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.将<em class="kw"> app-one </em>的<em class="kw"> main.js </em>修改为<em class="kw"> : </em></p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="5ad1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<em class="kw"> containerSelector </em>(在本例中是id属性)的值必须与我们之前定义的占位符的值相匹配。我们还添加了第23行到第29行，以便能够正常使用<a class="ae kl" href="https://single-spa.js.org/docs/devtools" rel="noopener ugc nofollow" target="_blank"> <em class="kw">单spa </em>的扩展</a>高亮功能。</p><p id="1494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.对<em class="kw"> app-two </em>的<em class="kw"> main.js </em>做同样的操作，只是将<em class="kw"> containerSelector </em>的值改为“# app two-placeholder”；</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="440c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们现在能够同时拥有这两个应用程序:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi on"><img src="../Images/6d9de31997f04423d5a3bf833ac8a68f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8OBuq_JfvapN_lahIAI3rw.gif"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">安装在各自占位符容器中的应用程序。</figcaption></figure><p id="ac0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个阶段，你的代码应该是这样的<a class="ae kl" href="https://github.com/mstrlaw/orchestrator/tree/2-layout-control" rel="noopener ugc nofollow" target="_blank"/>代表<em class="kw">指挥</em>，<a class="ae kl" href="https://github.com/mstrlaw/app-one/tree/2-mount-on-el" rel="noopener ugc nofollow" target="_blank">是这样的</a>代表<em class="kw">app-一个</em>和<a class="ae kl" href="https://github.com/mstrlaw/app-two/tree/2-mount-on-el" rel="noopener ugc nofollow" target="_blank">是这样的</a>代表<em class="kw">app-两个</em>。您现在应该对如何使用single-spa创建微前端架构有了很好的理解。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="f568" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们应该把所有的CSS都放在index.ejs中吗？它应该存在于orchestrator应用程序中吗？应用程序如何“共享状态”？我可以重用组件吗？本指南的第二部分将重点向您展示如何做到这些以及更多。</p><p id="bc49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同时…</p><h1 id="c48f" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">阅读材料</h1><p id="bca0" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">..以下是更多关于微前端架构的学习和探索资源:</p><ul class=""><li id="e6b1" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><a class="ae kl" href="http://geers.tv/" rel="noopener ugc nofollow" target="_blank"> Michael Geers </a> <a class="ae kl" href="https://micro-frontends.org/" rel="noopener ugc nofollow" target="_blank">写了大量关于微前端的</a>；</li><li id="8857" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><a class="ae kl" href="https://www.youtube.com/watch?v=PnH7MwfgTwI" rel="noopener ugc nofollow" target="_blank">用微前端扩展你的项目</a>(视频)和<a class="ae kl" href="https://medium.com/@lucamezzalira/micro-frontends-decisions-framework-ebcd22256513" rel="noopener">微前端决策框架</a>，均由<a class="mu mv ep" href="https://medium.com/u/9119c54d607d?source=post_page-----2c89528bf72f--------------------------------" rel="noopener" target="_blank">Luca mezzalira</a>；</li><li id="2764" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><a class="ae kl" href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener ugc nofollow" target="_blank">微前端条</a>通过<a class="ae kl" href="https://camjackson.net/" rel="noopener ugc nofollow" target="_blank">凸轮杰克逊</a>；</li><li id="16f3" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><a class="ae kl" href="https://www.youtube.com/watch?v=3EUfbnHi6Wg&amp;list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU" rel="noopener ugc nofollow" target="_blank">微前端和单spa视频系列</a>作者<a class="mu mv ep" href="https://medium.com/u/a142a504a37c?source=post_page-----2c89528bf72f--------------------------------" rel="noopener" target="_blank"> Joel Denning </a>《单spa》作者；</li></ul></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="91b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给这篇文章一个👏如果您发现它有用，请在第2部分发布后立即关注我。感谢阅读！</p></div></div>    
</body>
</html>