<html>
<head>
<title>4 Ways to Listen to Page Scrolling for Dynamic UI in Angular ft. RXJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular ft中动态UI听页面滚动的4种方法。RXJS</h1>
<blockquote>原文：<a href="https://itnext.io/4-ways-to-listen-to-page-scrolling-for-dynamic-ui-in-angular-ft-rxjs-5a83f91ee487?source=collection_archive---------0-----------------------#2020-05-11">https://itnext.io/4-ways-to-listen-to-page-scrolling-for-dynamic-ui-in-angular-ft-rxjs-5a83f91ee487?source=collection_archive---------0-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1638" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个解释，演示了4种监听窗口滚动事件的方法，以实现无限滚动、滚动动画或动态模块加载等功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea7577691e6d27b44186453d6e8a8874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mp0TrpwMwyRG16wge6VXpw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一些活力</figcaption></figure><h1 id="f867" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">动态用户界面和流畅的用户体验</h1><p id="3f7c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi mm translated">创建动态的、反应灵敏的、智能的web应用程序需要变得<strong class="ls iu">反应灵敏</strong>。但是对用户事件的反应，比如滚动，可以改善应用程序的T4，而不仅仅是外观。</p><p id="f8b7" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">例如，使用窗口滚动，您可以根据需要动态呈现组件或延迟加载代码块。这远远超出了应用程序的美学范畴。通过<strong class="ls iu">节省主包大小的能力，它可以<strong class="ls iu">改善页面加载时间</strong>；</strong>这是在页面加载时立即加载的代码块。</p><blockquote class="na nb nc"><p id="830f" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated">Angular编译器提供了分割代码块的能力，通过使用es6动态<strong class="ls iu">导入</strong>将该代码从包的其余部分中分离出来。</p></blockquote><h2 id="7fbd" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">窗口滚动用在哪里？</h2><p id="b06d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">想想您每天使用的现代web应用程序。你认为这些网站拥有<strong class="ls iu">高质量的用户界面和用户体验</strong>。</p><p id="bcfb" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">你会发现它们中的大多数要么在scroll  上有<a class="ae nt" href="https://github.com/michalsnik/aos" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu">动画，以无限滚动为特色来帮助他们的搜索功能，要么会在你需要的时候动态加载资源。你会注意到隐藏在视图之外的内容，<strong class="ls iu">显示动画或过渡，</strong>滑入或淡出视图。</strong></a></p><blockquote class="na nb nc"><p id="7faf" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated">Angular使用<strong class="ls iu">内置的主机装饰器</strong>使得监听用户事件更加容易，比如滚动。另外，RXJS提供了使用observables 来更新和存储我们从听众那里收集的计算结果的<strong class="ls iu">能力。</strong></p></blockquote><h2 id="4ed2" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">用例</h2><p id="c426" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">动态用户界面</strong> —也许你有一个<strong class="ls iu">博客，你想在一篇文章的顶部显示一个进度条</strong>来指示<strong class="ls iu">这篇文章已经被阅读了多少</strong>(或者更准确地说，是被滚动了)。</p><p id="8f38" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">性能</strong> —您可能有一个对性能产生负面影响的<strong class="ls iu">大模块。</strong>您可能已经注意到页面加载时间的增加，并且您想要按需加载该模块。您可以使用窗口滚动来预测用户何时需要访问该模块中提供的功能。</p><p id="eb48" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">如果你知道多种方法来监听窗口滚动事件和<strong class="ls iu">跟踪沿X或Y轴(水平或垂直)的滚动位置</strong>，那么实现这些例子将会简单10倍。</p><p id="6e5b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">在本文中，我们将关注Y轴</strong>(垂直方向)。</p><blockquote class="na nb nc"><p id="543e" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated">值得注意的是，使用窗口并不是实现这种功能的唯一方式。还有<a class="ae nt" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank"> IntersectionObserver </a>和<a class="ae nt" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" rel="noopener ugc nofollow" target="_blank"> MutationObserver </a>，这取决于你是想只在到达一个<strong class="ls iu">交叉点</strong>(页面上的位置)时才知道<strong class="ls iu">，还是你<strong class="ls iu">不想</strong>听滚动，而是你想听DOM的变化(<strong class="ls iu"> Mutation </strong>)。</strong></p></blockquote><h2 id="d292" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">基于窗口滚动的一些想法</h2><ul class=""><li id="ac7c" class="nu nv it ls b lt lu lw lx lz nw md nx mh ny ml nz oa ob oc bi translated"><strong class="ls iu">动画</strong>/转场</li><li id="b135" class="nu nv it ls b lt od lw oe lz of md og mh oh ml nz oa ob oc bi translated">UI组件— <strong class="ls iu">滚动百分比/阅读进度，</strong>相对于全部可用内容。</li><li id="d481" class="nu nv it ls b lt od lw oe lz of md og mh oh ml nz oa ob oc bi translated"><strong class="ls iu">无限滚动</strong>——到达视口末端时渲染/加载更多数据。</li><li id="bc01" class="nu nv it ls b lt od lw oe lz of md og mh oh ml nz oa ob oc bi translated"><strong class="ls iu">异步模块加载</strong>与<strong class="ls iu">导入</strong>。</li></ul><h1 id="3ec7" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">为什么我需要不止一种方法来滚动窗口？</h1><h2 id="e05d" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">简短的回答</h2><p id="b8f8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">浏览器兼容性/差异和您的CSS的组合</p><h2 id="9b50" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">冗长的回答</h2><p id="f709" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">根据浏览器的不同，<strong class="ls iu">默认可滚动元素引用DOM中不同的元素</strong>。您的CSS可能会导致默认的可滚动元素被覆盖或冗余，这意味着您不能再滚动它，或者有一个z索引更高的新滚动容器。</p><p id="e40a" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">因此，您必须<strong class="ls iu">确保您将监听器连接到适当的元素</strong>(正在滚动的那个)。不注意这些复杂性将导致您的滚动功能中断<strong class="ls iu">、</strong>，导致无法正确确定哪个元素正在触发滚动事件。</p><h1 id="ede6" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">影响默认滚动行为的方法</h1><p id="59d0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在我们实现我们的窗口滚动功能之前，我们需要知道<strong class="ls iu">你可以有意地，有时是无意地，影响你需要听的元素的方式。</strong></p><p id="dba9" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这包括详细说明实际的浏览器差异，以确保CSS和JavaScript/TypeScript代码的组合在不同的浏览器之间是兼容的。这些细节将通知我们的窗口滚动决策。</p><p id="15d3" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们将关注3种最常见的浏览器:<strong class="ls iu"> Chrome、Safari和Firefox </strong>。</p><h2 id="154c" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">铬</h2><ul class=""><li id="e49b" class="nu nv it ls b lt lu lw lx lz nw md nx mh ny ml nz oa ob oc bi translated">默认的滚动元素指的是<code class="fe oi oj ok ol b">&lt;html&gt;</code>元素。</li></ul><h2 id="87b9" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">旅行队</h2><ul class=""><li id="ff03" class="nu nv it ls b lt lu lw lx lz nw md nx mh ny ml nz oa ob oc bi translated">默认的滚动元素指的是<code class="fe oi oj ok ol b">&lt;body&gt;</code>元素。</li></ul><h2 id="7332" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">火狐浏览器</h2><ul class=""><li id="70f2" class="nu nv it ls b lt lu lw lx lz nw md nx mh ny ml nz oa ob oc bi translated"><code class="fe oi oj ok ol b">&lt;html&gt;</code>元素(和Chrome一样)</li></ul><p id="7820" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">了解这些可以在调试与滚动事件相关的问题时提供一些见解。例如，它可以指出您可以在一个浏览器中正确侦听滚动事件，但在另一个浏览器中却不能的原因。</p><p id="ad55" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">原因可能是应用于默认滚动元素<code class="fe oi oj ok ol b">&lt;html&gt;</code>或<code class="fe oi oj ok ol b">&lt;body&gt;</code>的<strong class="ls iu"> CSS，或者您通过在子元素上使用<code class="fe oi oj ok ol b">overflow-y: scroll</code>、<code class="fe oi oj ok ol b">position: absolute</code>或<code class="fe oi oj ok ol b">position: relative</code>(仅举几个例子)覆盖了默认滚动容器。</strong></p><blockquote class="na nb nc"><p id="c808" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated">所以本质上，确保你没有任何阻止垂直滚动的样式(CSS)，比如那些应用于<code class="fe oi oj ok ol b">&lt;html&gt;</code>或<code class="fe oi oj ok ol b">&lt;body&gt;</code>元素的样式</p></blockquote><h2 id="7d40" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">在现代浏览器中获得正确的滚动元素</h2><p id="27da" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如上所述，返回的元素将指向相对于浏览器的默认可滚动元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">函数来获取正确的默认滚动元素</figcaption></figure><h1 id="6e97" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">使用角度服务单例</h1><p id="12e5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们将通过创建和使用角度服务来实现我们的窗口滚动功能。这个服务将是一个<strong class="ls iu">单例</strong>，意味着应用程序范围的，让它<strong class="ls iu">干</strong>(不要重复自己)。我们将使用<a class="ae nt" href="https://www.learnrxjs.io/" rel="noopener ugc nofollow" target="_blank"> RXJS </a>来创建一个<a class="ae nt" href="https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject" rel="noopener ugc nofollow" target="_blank">行为主体</a>和一个可观察对象，该可观察对象将<strong class="ls iu">发出包含更新后的Y轴滚动位置</strong>的值，我们可以对这些值做出异步反应。</p><h1 id="2efa" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">获得沿Y轴的精确滚动位置</h1><p id="3362" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">创建精确的动画和动态用户体验<strong class="ls iu">需要获得正确的测量值</strong>。我们将关注的度量是用户从页面顶部开始滚动的<strong class="ls iu">距离，</strong>被称为<code class="fe oi oj ok ol b">scrollY</code>或<code class="fe oi oj ok ol b">scrollTop</code>位置，这是沿着Y轴的度量。</p><p id="e4fe" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">例如，<strong class="ls iu">如果scrollY为0，则表明用户在文件夹上方，在页面顶部</strong>。这可能意味着用户已经滚动到那里，或者他们刚刚导航到该页面，还没有开始滚动。</p><blockquote class="oo"><p id="1273" class="op oq it bd or os ot ou ov ow ox ml dk translated">如果您的动画或过渡是基于可用内容的滚动百分比，那么获得精确的度量就特别重要。</p></blockquote><blockquote class="na nb nc"><p id="8b25" class="lq lr nd ls b lt oy ju lv lw oz jx ly ne pa mb mc nf pb mf mg ng pc mj mk ml im bi translated">例如:如果你想显示用户在一篇文章上滚动了多远。</p></blockquote><h2 id="b2c2" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">获取当前沿Y轴的滚动位置</h2><p id="1367" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">使用随着滚动事件触发而发出的<code class="fe oi oj ok ol b"><a class="ae nt" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/target" rel="noopener ugc nofollow" target="_blank">Event</a></code>对象，我们可以获得滚动位置来更新scrollY值。<strong class="ls iu">我们将在每次触发滚动事件时使用这个函数。</strong></p><p id="3e6f" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">如您所见，我们访问<code class="fe oi oj ok ol b">.target</code>属性来查询<code class="fe oi oj ok ol b"><a class="ae nt" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop" rel="noopener ugc nofollow" target="_blank">scrollTop</a></code>值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">获取当前滚动Y轴位置</figcaption></figure></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><h1 id="a15c" class="ky kz it bd la lb pk ld le lf pl lh li jz pm ka lk kc pn kd lm kf po kg lo lp bi translated">方法1:使用渲染2</h1><p id="95e8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu"> Renderer2 </strong>，Renderer的继任者是Angular标准库的一部分，可通过依赖注入注入到组件中。它提供了与DOM交互和更新DOM的API。<strong class="ls iu">这是</strong>与DOM <strong class="ls iu">交互的首选方式，也是SSR(服务器端渲染)兼容的</strong>。</p><p id="7003" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">使用<strong class="ls iu"> Renderer2 </strong>是监听窗口事件的简单方法。只需给它传递一个<code class="fe oi oj ok ol b">string</code>(‘window’)作为第一个参数。然后你可以通过<strong class="ls iu">回调函数</strong>来更新Y位置，这个函数会在用户滚动时被调用。然后你会想要调用我们的<code class="fe oi oj ok ol b">getYPosition()</code>函数来获得正确的<code class="fe oi oj ok ol b">scrollY</code>值。</p><blockquote class="na nb nc"><p id="2d12" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated"><strong class="ls iu">稍后，我们将使用计算出的<code class="fe oi oj ok ol b">scrollY</code>值更新我们(将要创建的)<code class="fe oi oj ok ol b"><em class="it">WindowScrollService</em></code>中的行为主题</strong>，但是现在，我们将<strong class="ls iu">登录到控制台</strong>来检查我们的代码是否按预期工作。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">渲染2窗口滚动</figcaption></figure><p id="6076" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">然而，使用这种方法，您会希望<strong class="ls iu">将监听函数<strong class="ls iu"> </strong>的返回值</strong>存储在组件范围的变量<code class="fe oi oj ok ol b">listener</code>中。这确保了<strong class="ls iu">当不再需要事件监听器时，通过最终销毁事件监听器来防止内存泄漏。你可以通过调用上面<code class="fe oi oj ok ol b">ngOnDestroy()</code>生命周期钩子中<code class="fe oi oj ok ol b">this.listener();</code>的listen函数的结果来做到这一点。</strong></p><h1 id="7df6" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">方法2:主机监听器</h1><p id="aeba" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在我们所有的方法中，这可以说是最'<strong class="ls iu"> Angular的方式</strong>来监听滚动事件，也就是说这是一个<strong class="ls iu">独享</strong>给Angular的方法。除了监听host元素，<strong class="ls iu"> HostListener </strong>可以监听<code class="fe oi oj ok ol b"><strong class="ls iu">window</strong></code> <strong class="ls iu">。</strong></p><p id="d523" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">所以这里我们可以将<code class="fe oi oj ok ol b">window:scroll</code>传递给<code class="fe oi oj ok ol b">HostListener</code>函数装饰器，然后以通常的方式调用<code class="fe oi oj ok ol b">getYPosition</code>函数来更新<code class="fe oi oj ok ol b">scrollY</code>值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">主机监听器窗口滚动</figcaption></figure><h2 id="ab4f" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">使用HostListener的替代方法</h2><blockquote class="na nb nc"><p id="5080" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated">如果您的默认滚动元素上有CSS阻止您使用该窗口</p></blockquote><p id="ecf3" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">找到替代的可滚动元素并监听滚动事件</strong></p><p id="7495" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">与上面的方法几乎相同，只是<strong class="ls iu">用字符串<code class="fe oi oj ok ol b">scroll</code>替换</strong>host listener decorator参数中的<code class="fe oi oj ok ol b">window:scroll</code>标记。</p><p id="2c4c" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这是使用HostListener的<strong class="ls iu">更常见的</strong>方法，尽管如果您必须使用此方法来实现任何类型的窗口滚动功能，那么这将表明您已经编写了一些难以调试的<strong class="ls iu">CSS，并且可能已经花了整整30分钟<strong class="ls iu">来尝试找到您正在滚动的正确元素。</strong></strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">HostListener根元素滚动</figcaption></figure><h1 id="97f3" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">方法3:使用RXJS</h1><p id="2323" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">在角度应用中，使用RXJS进行异步操作应该是一个熟悉的过程</strong>。使用observables if我最喜欢的方式，因为与<code class="fe oi oj ok ol b">OnPush</code>变更检测策略结合使用会带来性能优势。当在整个应用程序中转换和使用observable时，我们可以确保通过observable进行的<strong class="ls iu">更改总是通过异步管道</strong>反映在DOM中，一直到Angular模板。</p><p id="7779" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们将使用从<code class="fe oi oj ok ol b">rxjs</code>导入的可观察值<code class="fe oi oj ok ol b">fromEvent</code>。我们路过<code class="fe oi oj ok ol b">window</code>。从这里，你可以通过<code class="fe oi oj ok ol b">subscribe</code>回调来更新滚动的Y位置，或者你可以存储可观察值来转换并最终在模板中使用，但是<strong class="ls iu">因为我们试图保持干燥，我们选择使用subscribe函数。</strong></p><p id="feeb" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">和往常一样，<strong class="ls iu">记住退订可观察订阅</strong>很重要。所以当组件被破坏时，一定要打电话给<code class="fe oi oj ok ol b">unsubscribe</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">RXJS窗口滚动</figcaption></figure><p id="42d8" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">当包含组件被销毁时，我最喜欢的销毁可观察对象的方法是通过一个在 <code class="fe oi oj ok ol b"><strong class="ls iu">NgOnDestroy</strong></code> <strong class="ls iu">生命周期钩子</strong>中发出一个值的主题<strong class="ls iu">。所以要破坏可观测的，我们就叫<code class="fe oi oj ok ol b">next()</code>。</strong></p><h1 id="4d91" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">方法4:监听HTML元素滚动事件</h1><h2 id="f292" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">监听HTML事件</h2><p id="9824" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">也许<strong class="ls iu">监听滚动事件最简单的方法</strong>:绑定到实际的HTML元素。更简单的是，<strong class="ls iu">你可以使用<code class="fe oi oj ok ol b">window:scroll</code>事件发射器从DOM </strong>中的任何HTML元素开始滚动窗口。使用这种方法，您只需<strong class="ls iu">传递一个函数</strong>在滚动事件触发时调用，就像您使用任何其他事件监听器(如<code class="fe oi oj ok ol b">mouseenter</code>或<code class="fe oi oj ok ol b">click</code>)一样。<strong class="ls iu">简单！</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">HTML事件侦听器</figcaption></figure><h1 id="b62c" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">创建窗口滚动服务</h1><p id="0507" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">角度服务单件鼓励代码重用</strong>并确保你不重复自己(DRY)，这在涉及到事件监听器和频繁更新DOM时尤为重要。</p><p id="a199" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">这些都是CPU密集型任务</strong>，应该仔细监控以防止出现性能瓶颈。这主要是由于浏览器不得不花费大量精力来重画和检测变化，这最终会影响最终用户的体验。</p><p id="1ba8" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">因此，我们将通过一个服务</strong> <code class="fe oi oj ok ol b">WindowScrollService</code> <strong class="ls iu">专门处理窗口滚动。</strong></p><h2 id="2f21" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">让我们创建服务</h2><p id="52b2" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">对于那些使用angular CLI的人(我想是大多数)，你需要…</p><pre class="kj kk kl km gt pp ol pq pr aw ps bi"><span id="5dc8" class="nh kz it ol b gy pt pu l pv pw">$ ng g s services/window-scroll</span></pre><p id="5a7c" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这将在<code class="fe oi oj ok ol b">/services</code>目录中生成<code class="fe oi oj ok ol b">WindowScrollService</code>。</p><h2 id="0dd5" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">设置服务</h2><p id="d585" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">首先，我们创建一个<code class="fe oi oj ok ol b"><strong class="ls iu">BehaviourSubject</strong></code>来存储<strong class="ls iu">滚动</strong>位置。此外，我们从<code class="fe oi oj ok ol b">scrollY</code> BehaviorSubject创建一个可观察对象，以监听变化。<strong class="ls iu">可观察的</strong> <code class="fe oi oj ok ol b"><strong class="ls iu">scroll$</strong></code> <strong class="ls iu">将是在整个应用</strong>中被监听的值，无论在哪里需要读取<code class="fe oi oj ok ol b">scrollY</code>位置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="57d6" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">使用窗口滚动服务</h2><p id="9866" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">更新行为主体<code class="fe oi oj ok ol b">scrollY</code>就像<strong class="ls iu">用</strong> <code class="fe oi oj ok ol b"><strong class="ls iu">scrollY</strong></code> <strong class="ls iu">值作为参数</strong>调用 <code class="fe oi oj ok ol b"><strong class="ls iu">.next()</strong></code> <strong class="ls iu">一样简单。这取代了之前用于演示目的的<code class="fe oi oj ok ol b">console.log</code>。然后，我们可以尽可能多地使用<code class="fe oi oj ok ol b">scrollY$</code> observable，而不需要附加任何更多的窗口滚动监听器。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">正在更新WindowScrollService中的BehaviourSubject</figcaption></figure><p id="633d" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我选择了<strong class="ls iu"> HostListener(方法2) </strong>来演示我们的<code class="fe oi oj ok ol b">WindowScrollService</code>的用法，没有任何真正的原因，除了它是<strong class="ls iu">最不冗长的</strong>。</p><h2 id="31fb" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">有用:获得最大滚动高度</h2><p id="ae5e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这对于依赖于<strong class="ls iu">已滚动内容的计算百分比</strong>的功能非常有用。例如上面提到的那些。这里，我们需要从这些值中取最大值，以获得可滚动高度的最精确值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="51e4" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">倾听scrollY更新并对其做出反应</h2><p id="efe0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">对滚动位置更新的反应就像<strong class="ls iu">监听</strong> <code class="fe oi oj ok ol b"><strong class="ls iu">scrollY$</strong></code> <strong class="ls iu">可观察到的</strong>并根据发出的值执行代码一样简单。例如，计算滚动内容的百分比，这将是..</p><pre class="kj kk kl km gt pp ol pq pr aw ps bi"><span id="4149" class="nh kz it ol b gy pt pu l pv pw">scrollY - scrollHeight / 100</span></pre><p id="7419" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">你可能想用…来取整这个值</p><pre class="kj kk kl km gt pp ol pq pr aw ps bi"><span id="19a5" class="nh kz it ol b gy pt pu l pv pw">Math.round(scrollY - scrollHeight / 100)</span></pre><h2 id="c9b7" class="nh kz it bd la ni nj dn le nk nl dp li lz nm nn lk md no np lm mh nq nr lo ns bi translated">就是这样，你永远不应该被听窗口滚动的方法所束缚！</h2><blockquote class="oo"><p id="44ca" class="op oq it bd or os ot ou ov ow ox ml dk translated">有任何问题，请在评论中告诉我！</p></blockquote><h1 id="9f9a" class="ky kz it bd la lb lc ld le lf lg lh li jz px ka lk kc py kd lm kf pz kg lo lp bi translated">使用窗口滚动的项目</h1><div class="qa qb gp gr qc qd"><a href="https://www.npmjs.com/package/window-scroll-manager" rel="noopener  ugc nofollow" target="_blank"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">窗口滚动管理器</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">一个小的库，广播更多高性能的窗口滚动事件。听window onscroll事件非常…</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">www.npmjs.com</p></div></div><div class="qm l"><div class="qn l qo qp qq qm qr ks qd"/></div></div></a></div><div class="qa qb gp gr qc qd"><a href="https://www.npmjs.com/package/infinite-scroll" rel="noopener  ugc nofollow" target="_blank"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">无限卷轴</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">参见infinite-scroll.com的完整文档和演示。直接链接到unpkg上的无限滚动文件。npm: npm安装…</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">www.npmjs.com</p></div></div></div></a></div><div class="qa qb gp gr qc qd"><a href="https://www.npmjs.com/package/ng-scroll-progress" rel="noopener  ugc nofollow" target="_blank"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">ng-滚动-进度</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">角度进度条的页面数量滚动bower bower安装-保存ng-滚动-进度npm安装npm安装…</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">www.npmjs.com</p></div></div><div class="qm l"><div class="qs l qo qp qq qm qr ks qd"/></div></div></a></div></div></div>    
</body>
</html>