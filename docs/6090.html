<html>
<head>
<title>Go: functions, methods, pointers and interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go:函数、方法、指针和接口</h1>
<blockquote>原文：<a href="https://itnext.io/go-functions-methods-pointers-and-interfaces-1c034fd198d3?source=collection_archive---------0-----------------------#2021-08-14">https://itnext.io/go-functions-methods-pointers-and-interfaces-1c034fd198d3?source=collection_archive---------0-----------------------#2021-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="80cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在一个简单的例子中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3b525f340d653bcf99af4e6687544571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YsH2F890rzvA1qIVeeb9IA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由Renee French创建的原始地鼠图像，使用由Maria Letta创建的地鼠图像</figcaption></figure><p id="3603" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章是专门为我的儿子写的，他很难理解如何使用指针和接口。</p><p id="29a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使解释完整，我(在他的帮助下)添加了两件事:函数和方法。我认为这两个是指针和/或接口的补充。反之亦然。</p><p id="d4fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本解释分为六个部分，每一部分都是对前一部分的补充。我试图让一切尽可能简单。如果您发现错误，请不要犹豫，提出意见。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="373c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">1.基础知识</h1><p id="137f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们将从非常简单的事情开始。我们正在创建两个结构:<code class="fe my mz na nb b">Car</code>和<code class="fe my mz na nb b">Truck</code>。两者都有一个领域<code class="fe my mz na nb b">name</code>。</p><p id="3da7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在一个代码中，我们将创建两个变量，即<code class="fe my mz na nb b">bmw</code>和<code class="fe my mz na nb b">volvo</code>，并带有一个字段<code class="fe my mz na nb b">name</code>。然后我们将打印变量<code class="fe my mz na nb b">name</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2ff9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，这里没什么特别的。希望这是您在运行代码时看到的结果。</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="c79d" class="ni mc it nb b gy nj nk l nl nm">bmw is the best car<br/>volvo is the best truck</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="9483" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">2.用函数改变名字，传递一个值</h1><p id="651d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">假设我们想要更改<code class="fe my mz na nb b">name</code>字段，并再次打印结果。我们有多种选择，如何做到这一点，在这个特定的例子中，我们将使用简单的函数“传递值”，或“传递整个结构”。</p><p id="f540" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，我们需要创建两个函数，即<code class="fe my mz na nb b">changeNameOfCar()</code>和<code class="fe my mz na nb b">changeNameOfTruck()</code>。</p><p id="08e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在代码中(第17、18行),我们使用这些新函数改变了这两个变量的<code class="fe my mz na nb b">name</code>字段。</p><p id="3c0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两个函数返回带有附加信息<code class="fe my mz na nb b">“\n\t… changed with simple function</code>的名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1b20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您运行代码，这就是您将看到的结果。</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="f1fe" class="ni mc it nb b gy nj nk l nl nm">bmw is the best car<br/>        ... changed with simple function<br/>volvo is the best truck<br/>        ... changed with simple function</span></pre><p id="ef24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，我们通过调用适当的函数并将值传递给它，成功地更改了变量<code class="fe my mz na nb b">bmw</code>和<code class="fe my mz na nb b">volvo</code>的字段<code class="fe my mz na nb b">name</code>。</p><p id="7ff4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们传递了整个变量<code class="fe my mz na nb b">bmw</code>和<code class="fe my mz na nb b">volvo</code>。在这两个函数<code class="fe my mz na nb b">changeNameOfCar() </code>和<code class="fe my mz na nb b">changeNameOfTruck()</code>中，我们使用<code class="fe my mz na nb b">bmw</code>和<code class="fe my mz na nb b">volvo</code>变量的副本来处理<strong class="la iu">。</strong></p><p id="9d33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了对原来的变量进行更改，我们需要将更改后的<code class="fe my mz na nb b">name</code>返回，并将其赋给原来的<code class="fe my mz na nb b">bmw.name</code>和<code class="fe my mz na nb b">volvo.name</code>。</p><p id="f570" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">先前方法的“问题”是基于“记忆”的。如果你有一个包含数百万个字段的巨大结构，将包含数百万个字段的变量传递给那个函数是不明智的。第一种方法是只传递您想要更改的字段，如<code class="fe my mz na nb b">bmw.name</code>，第二种方法是传递一个指向该变量的指针。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="776c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">3.使用指针通过函数更改名称</h1><p id="a8fb" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">首先，什么是指针？</p><p id="e64e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象一下。你有辆车，那辆宝马。那是一个物理对象。那辆车就停在某个地方。某个地方有地址，比如123城市12街。</p><p id="52e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个地址是一个指针，指向汽车的物理位置。</p><p id="763a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这个角度来看，如果你有你的车停在那个地址的家里，你希望有人只是检查一下，如果车是好的(因为你在度假)，你可以简单地告诉某人“你能检查一下，我的车在123城市12街真的在那里吗？”。123城市的12号街道是你汽车的指针。你开车的地方是物理上的，嗯，那是宇宙中的一个物理位置。</p><p id="ff37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有一个变量bmw，它在你的计算机内存中占据了一个位置，你也有一个地址，一个指向那个位置的指针。</p><p id="5854" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着:如果你有一个有数百万字段的变量，你想用一个函数来使用和/或改变这个变量，你可以简单地传递一个指针到内存中的一个位置，这个变量的位置。不需要传递整个变量。</p><p id="1977" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是第19–20行的两个新函数的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d96b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两个新功能<code class="fe my mz na nb b">changeNameOfCarUsingPointer()</code>和<code class="fe my mz na nb b">changeNameOfTruckUsingPointer()</code>。如你所见，你没有将变量<code class="fe my mz na nb b">bmw</code>和<code class="fe my mz na nb b">volvo</code>传递给这些函数，而是传递了指针<code class="fe my mz na nb b">&amp;bmw</code>和<code class="fe my mz na nb b">&amp;volvo</code>。只是这两个变量所在的内存位置的地址。仅此而已。</p><p id="7283" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为你传递的是指向你的变量的指针，所以你是在这两个新函数中直接使用原来的变量，而不是使用一个副本！</p><p id="ffd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着没有必要像我们在第17–18行所做的那样，将<code class="fe my mz na nb b">bmw.name</code>和<code class="fe my mz na nb b">volvo.name</code>改回来。这也意味着不需要从这两个新函数返回一些东西。</p><p id="ab1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过传递一个值，您正在使用原始变量的副本。要对原始变量进行更改，您需要从函数发回更改的内容。</p><p id="11c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过传递一个指针，你就可以使用那个原始变量的内存位置。您在此函数中所做的任何更改都会影响原始变量。</p><p id="2580" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也许你在问，哪种方法更好。传递值，还是传递指针？答案是:都不是。两者各有利弊。</p><p id="5481" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我个人的简单方法是这样的:如果变量很小(从内存的角度来看)，就像那个<code class="fe my mz na nb b">volvo</code>和<code class="fe my mz na nb b">bmw</code>变量，我会一直传递值。以确保函数不会影响原始变量。假设这是我的安全视角。</p><p id="6d9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是如果我有一个很大的变量，比如一个10MB的变量，有几百万个字段(请举例说明)，我想改变其中的很多字段，我会传递指针，因为我不想在内存中再复制一个10MB的变量。</p><p id="d0e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您运行上面的代码，您将看到结果。</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="7e30" class="ni mc it nb b gy nj nk l nl nm">bmw is the best car<br/> … changed with simple function<br/> … changed using pointer<br/>volvo is the best truck<br/> … changed with simple function<br/> … changed using pointer</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8314" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">4.用方法改变名字，传递一个值</h1><p id="0840" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">首先，我们需要区分方法和函数。这种差异主要是语法上的，但也有一个微妙的功能上的差异，您将在后面看到。</p><p id="7d3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果使用函数来处理结构变量，语法如下:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="c216" class="ni mc it nb b gy nj nk l nl nm">nameOfFunction(variable)</span></pre><p id="0545" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果使用方法处理结构变量，语法如下:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="40a2" class="ni mc it nb b gy nj nk l nl nm">variable.nameOfMethod()</span></pre><p id="dfc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，从文本的角度来看，我们只是交换了变量的位置和函数/方法的名称。一般来说，这就是区别所在，因为你可以用函数做的一切，都可以用方法来做。但是正如我所写的，有一个小的不同，你会看到。</p><p id="e623" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们将使用一种方法通过传递值来更改变量名。参见下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0966" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两个新方法在第21–22行。当你在第44–50行检查它们的实现时，你可以观察到它们的实现和函数一样，都是传递值。</p><p id="6a9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这个角度来看，功能是相同的，当您运行代码时，您将看到结果。</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="f21b" class="ni mc it nb b gy nj nk l nl nm">bmw is the best car<br/>        ... changed with simple function<br/>        ... changed using pointer<br/>        ... changed with method<br/>volvo is the best truck<br/>        ... changed with simple function<br/>        ... changed using pointer<br/>        ... changed with method</span></pre><p id="08e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是现在关于这些差异。</p><p id="d594" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们写道，我们的第一个函数是<code class="fe my mz na nb b">changeNameOfCar()</code>，我们在其中传递了整个<code class="fe my mz na nb b">volvo</code>变量，所以它看起来和功能都像<code class="fe my mz na nb b">changeNameOfCar(volvo)</code>。但是不需要传递整个变量，你可以做一个类似于<code class="fe my mz na nb b">changeNameOfCar(volvo.name</code>的函数，只把<code class="fe my mz na nb b">volvo.name</code>传递给那个函数(当然，你必须适当地调整函数。</p><p id="7333" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是通过使用方法<code class="fe my mz na nb b">volvo.changeNameUsingMethod</code>，你不可能只传递名字，你不能像<code class="fe my mz na nb b">volvo.name.changeNameUsingMethod()</code>那样使用它。</p><p id="37ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用方法，您正在处理整个变量。因为我们传递的是值，所以你是在处理这个变量的一个新副本。就像函数一样，我们需要返回一些东西，并把它们赋回给原来的函数。</p><p id="8ca2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也许你已经发现了另一个不同之处。对于函数，通常不能对两种不同类型的变量使用相同的名称。您不能将<code class="fe my mz na nb b">changeName()</code>用于<code class="fe my mz na nb b">Truck</code>和<code class="fe my mz na nb b">Car</code>。</p><p id="edab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如您所见，您可以对不同类型的变量使用相同的方法名。但是您需要为这两个变量实现这个方法(第44–50行)。两个方法，名称相同，输入类型不同。</p><p id="c2e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以你可以有<code class="fe my mz na nb b">volvo.ChangeName()</code>、<code class="fe my mz na nb b">bmw.ChangeName()</code>、<code class="fe my mz na nb b">elonMusk.ChangeName()</code>和/或<code class="fe my mz na nb b">Quercus.ChangeName()</code>、<em class="nn">。</em>四种不同方法的一个名称。</p><p id="fe65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们稍后处理接口时，这将是有用的。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c19d" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">5.用方法改变名字，传递一个指针</h1><p id="940e" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">到目前为止，您有望理解传递值和传递指针之间以及函数和方法之间的区别。</p><p id="2984" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还缺少最后一部分:使用方法和传递指针。就像是利用了那两个世界的精华。</p><p id="9373" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是更新后的代码，在第23–24行有这两个新函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="548f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码几乎是一样的，但是因为我们传递的是指针，所以不需要从方法返回一些东西，并把这些东西赋给原始变量。</p><p id="83ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们在实现中没有使用<code class="fe my mz na nb b">(t Truck)</code>，而是使用了指针，即<code class="fe my mz na nb b">(t *Truck)</code>。请确保在使用方法时总是检查这一点，因为在使用方法时没有像在<code class="fe my mz na nb b">changeNameOfCarUsingPointer(&amp;bmw)</code>中那样传递指针<code class="fe my mz na nb b">&amp;variable</code>。使用方法时没有<code class="fe my mz na nb b">&amp;</code>。</p><p id="4efd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行代码并查看结果。</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="a2dd" class="ni mc it nb b gy nj nk l nl nm">bmw is the best car<br/>        ... changed with simple function<br/>        ... changed using pointer<br/>        ... changed with method<br/>        ... changed with method using pointer<br/>volvo is the best truck<br/>        ... changed with simple function<br/>        ... changed using pointer<br/>        ... changed with method<br/>        ... changed with method using pointer</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="31f3" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">间奏曲</h1><p id="4da8" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">到目前为止，我们有四种可能的方法来处理一个问题，改变一个变量的名字，在这种情况下:</p><ol class=""><li id="8493" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">函数，值(更安全，但是复制数据)</li><li id="be3e" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">函数，指针(不安全—您正在更改原始数据，但不是复制数据)</li><li id="6fe6" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">方法，值(相同的like函数，但是你总是复制整个变量，你可以对不同类型的变量使用相同的名字)</li><li id="b636" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">方法、指针(与函数和指针一样，与previous一样，您可以反复使用相同的名称)</li></ol></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="e563" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">6.使用界面</h1><p id="6e94" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">假设您想创建一个带有“子类型”的类型<code class="fe my mz na nb b">Vehicle</code>，比如<code class="fe my mz na nb b">Car</code>、<code class="fe my mz na nb b">Truck</code>、<code class="fe my mz na nb b">Motorcycle</code>等等。你想创建这种类型<code class="fe my mz na nb b">Vehicle</code>的原因是:在代码的某个地方，你想创建一个所有这些车辆的数组，并在一个循环中改变它们的名字，使用已经为<code class="fe my mz na nb b">Car</code>和<code class="fe my mz na nb b">Truck</code>编写的方法。</p><p id="8ae6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如下面的代码所示，我们正在创建一个数组<code class="fe my mz na nb b">vehicles</code>并添加已经创建的<code class="fe my mz na nb b">volvo</code>和<code class="fe my mz na nb b">bmw</code>。</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="b294" class="ni mc it nb b gy nj nk l nl nm">var vehicles []Vehicle<br/>vehicles = append(vehicles, &amp;bmw)<br/>vehicles = append(vehicles, &amp;volvo)<br/><br/>for _, vehicle := range vehicles {<br/>   vehicle.changeNameUsingMethodWithPointer()<br/>}</span></pre><p id="bfa3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问题是，我们的代码中没有类型<code class="fe my mz na nb b">Vehicle</code>。第二个问题是…我们如何将已经编写好的<code class="fe my mz na nb b">Car</code>和<code class="fe my mz na nb b">Truck</code>方法与不存在的<code class="fe my mz na nb b">Vehicle</code>方法结合起来。</p><p id="6e7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你插入代码，你会看到红色的曲线，表明有问题。</p><p id="fa94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">去救援吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7ee3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面是完整的代码，如你所见，除了上面的7行(数组和循环)，我们在第13-15行只添加了三行:</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="0557" class="ni mc it nb b gy nj nk l nl nm">type Vehicle interface {<br/>   changeNameUsingMethodWithPointer()<br/>}</span></pre><p id="0c14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这三行新代码创建了一个名为<code class="fe my mz na nb b">Vehicle</code>的接口。把它当作所有标准结构的“主类型”，在这个例子中是<code class="fe my mz na nb b">car</code>和<code class="fe my mz na nb b">truck</code>。这个接口只有一个方法<code class="fe my mz na nb b">changeNameUsingMethodWithPointer()</code>。我们已经为<code class="fe my mz na nb b">Car</code>和<code class="fe my mz na nb b">Truck</code>实现了这个方法。</p><p id="3625" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，你现在可以把<code class="fe my mz na nb b">bmw</code>和<code class="fe my mz na nb b">volvo</code>当成<code class="fe my mz na nb b">Vehicle</code>了。</p><p id="8aed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这也意味着，你可以创建一个不同类型变量的数组，你可以把所有这些不同类型的变量当作一类，也就是<code class="fe my mz na nb b">Vehicle</code>，在这种情况下。</p><p id="94b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您现在运行代码，您可以看到我们使用指针的方法为<code class="fe my mz na nb b">bmw</code>和<code class="fe my mz na nb b">volvo</code>分别调用了两次。第一次在第27–28行，第二次在第35行的循环中。</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="8d99" class="ni mc it nb b gy nj nk l nl nm">bmw is the best car<br/>        ... changed with simple function<br/>        ... changed using pointer<br/>        ... changed with method<br/>        ... changed with method using pointer<br/>        ... changed with method using pointer<br/>volvo is the best truck<br/>        ... changed with simple function<br/>        ... changed using pointer<br/>        ... changed with method<br/>        ... changed with method using pointer<br/>        ... changed with method using pointer</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="ce7d" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">摘要</h1><p id="5a5c" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这是停下来让你试验的恰当时机。没有必要让这篇文章变得更复杂。</p><p id="17ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以同时使用传递值和指针。</p><p id="0a8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以尝试返回多个值。</p><p id="fb47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以玩围棋的<code class="fe my mz na nb b">reflect</code>。</p><p id="9b13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以把更多的东西组合在一起，以<code class="fe my mz na nb b">bmw.ChangePatrametersTo(name: “My brand new car”, date: "14.8.2021", diary: &amp;allCarsIHave)</code>结束。</p><p id="021f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以做很多事情。</p><p id="9c66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是你需要从头开始理解它，我希望这篇文章能帮助你。</p><p id="3820" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解围棋，你可以阅读<a class="ae oc" rel="noopener ugc nofollow" target="_blank" href="/7-reasons-you-should-try-use-go-5fb4714015d1">彼得·贾霍达</a>写的这篇文章。</p><p id="3e9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而且如果想查一些实际的东西，还有<a class="od oe ep" href="https://medium.com/u/6f72c855da06?source=post_page-----1c034fd198d3--------------------------------" rel="noopener" target="_blank">彼得·贾霍达</a>的<a class="ae oc" href="https://medium.com/swlh/create-go-service-the-easy-way-de827d7f07cf" rel="noopener"> 10集教程</a>。</p></div></div>    
</body>
</html>