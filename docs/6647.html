<html>
<head>
<title>You’re running untrusted code!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您正在运行不受信任的代码！</h1>
<blockquote>原文：<a href="https://itnext.io/running-untrusted-code-844ce4ad499a?source=collection_archive---------3-----------------------#2022-01-16">https://itnext.io/running-untrusted-code-844ce4ad499a?source=collection_archive---------3-----------------------#2022-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7cf04d15959518d6df35208d0fe6f934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uHNnu3nLtyMB6eZ2tp7hFQ.jpeg"/></div></div></figure><p id="66ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">去年12月，Log4Shell缩短了JVM世界里很多人的夜晚。更糟糕的是，使用地震类比在最初的地震后引起了许多余震。我立即在Log4Shell和安全管理器之间建立了联系。起初，我不想写它，但我已经收到这样做的请求，我不能走开。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/839e8172494df1de18f548355bf08a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EkizUZOgJjwPXEHJgUHFcQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated"><a class="ae lf" href="https://twitter.com/JohannesRabauer/status/1471012592495865860" rel="noopener ugc nofollow" target="_blank">https://Twitter . com/Johannes rabauer/status/1471012592495865860</a></figcaption></figure><p id="75a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提醒一下，Oracle团队不赞成在Java 17中使用安全管理器。它做出这一决定的一个理由是，它最初是为了防范小程序而设计的。小程序是从互联网上下载的，所以它们必须被认为是不可信的代码。因此，我们必须在沙箱中运行它们。</p><p id="2bba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然他们从来没有这样说过，但是这种说法有一个隐含的结果:因为小程序现在被否决了，所以我们只运行可信的代码。<em class="lg">因此</em>，我们可以放开安全经理了。这显然是错误的，我会在这篇文章中解释原因。</p><p id="af58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行在基础设施内部的代码可以被信任的前提是危险的——无论是在内部还是在云中。让我列举一些支持这种说法的论据。</p><h1 id="97c6" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">图书馆不可信</h1><p id="2155" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">明智的开发人员不会重新发明轮子:他们使用现有的库和/或框架。</p><p id="d64b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，从安全的角度来看，这意味着这种第三方代码的用户应该仔细审核它。我们应该寻找缺陷:错误和漏洞。</p><p id="ae2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个行业的二十年里，我从未见过这样的审计。</p><p id="d235" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">人们可能会赞成定制代码。可惜，这解决不了任何问题。定制代码遭受同样的问题、错误和漏洞。更糟糕的是，它没有得到与标准库相同的关注，因此研究人员无法花费时间来发现这些问题，这是没有成本的。</p><h1 id="36a6" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">构建不可信</h1><p id="c509" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">假设您拥有审计代码所需的所有资源——时间、金钱和技能。进一步想象一下，审计没有发现任何可疑之处。最后，想象一下审计的结论是100%可靠的。</p><p id="aaef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是没有什么能保证JAR是从源代码构建的结果，即使构建是公共的。恶意的提供者可以用另一个替换真正的JAR。</p><h1 id="2c4a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">身份不可信</h1><p id="5166" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">供应商可以在罐子上签名以保证它是真的。签名基于非对称加密技术:</p><ol class=""><li id="0f71" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">提供者用自己的私钥对JAR进行签名</li><li id="a597" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">它用私钥生成一个公钥</li><li id="4152" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">人们可以使用公钥读取签名，并检查提供者是否签署了JAR。</li></ol><p id="5dc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，任何人都可以验证JAR来自特定的提供者。</p><p id="3bd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JDK提供了<code class="fe my mz na nb b">jarsigner</code>工具来签署罐子。不幸的是，大多数图书馆都不使用它。例如，我已经验证了以下依赖关系:</p><ul class=""><li id="9723" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv nc mq mr ms bi translated"><code class="fe my mz na nb b">org.slf4j:slf4j-api:1.7.32</code></li><li id="3ffd" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><code class="fe my mz na nb b">com.fasterxml.jackson.core:jackson-core:2.13.0</code></li><li id="38f0" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><code class="fe my mz na nb b">org.mockito:mockito-core:4.1.0</code></li><li id="c2cc" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><code class="fe my mz na nb b">org.junit.jupiter:junit-jupiter-api:5.8.2</code></li><li id="e41a" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><code class="fe my mz na nb b">org.apache.commons:commons-collections4:4.4</code></li><li id="3376" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><code class="fe my mz na nb b">org.eclipse.collections:eclipse-collections:10.4.0</code></li><li id="3c80" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><code class="fe my mz na nb b">com.google.protobuf:protobuf-java:3.18.0</code></li><li id="3c93" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><code class="fe my mz na nb b">com.itextpdf:itextpdf:5.5.13.2</code></li><li id="5eec" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><code class="fe my mz na nb b">com.zaxxer:HikariCP:5.0.0</code></li><li id="b1df" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><code class="fe my mz na nb b">com.vladmihalcea.flexy-pool:flexy-pool-core:2.2.3</code></li><li id="b181" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><code class="fe my mz na nb b">org.springframework:spring-beans:5.3.13</code></li><li id="e68f" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><code class="fe my mz na nb b">jakarta.platform:jakarta.jakartaee-api:9.1.0</code></li></ul><p id="27dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的十二个罐子中，只有一个签有<code class="fe my mz na nb b">jarsigner</code>的。如果你感兴趣，这是Eclipse收藏。</p><p id="7a54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，为了对抗<a class="ae lf" href="https://en.wikipedia.org/wiki/Supply_chain_attack" rel="noopener ugc nofollow" target="_blank">供应链攻击</a>，工件库已经开始要求签名工件。例如，Sonatype <a class="ae lf" href="https://central.sonatype.org/publish/requirements/#sign-files-with-gpgpgp" rel="noopener ugc nofollow" target="_blank">要求每个上传的文件都有一个签名</a>，<em class="lg">即</em>，POM，JAR，sources JAR，JavaDocs JAR等等。</p><p id="6e99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以用Maven验证签名:</p><pre class="kx ky kz la gt nd nb ne nf aw ng bi"><span id="0165" class="nh li iq nb b gy ni nj l nk nl">mvn org.simplify4u.plugins:pgpverify-maven-plugin:show -Dartifact=com.zaxxer:HikariCP:5.0.0</span></pre><p id="b751" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它输出以下内容:</p><pre class="kx ky kz la gt nd nb ne nf aw ng bi"><span id="6b54" class="nh li iq nb b gy ni nj l nk nl">Artifact:<br/>        groupId:     com.zaxxer<br/>        artifactId:  HikariCP<br/>        type:        jar<br/>        version:     5.0.0</span><span id="79d8" class="nh li iq nb b gy nm nj l nk nl">PGP signature:<br/>        version:     4<br/>        algorithm:   SHA256withRSA<br/>        keyId:       0x4CC08E7F47C3EC76<br/>        create date: Wed Jul 14 04:49:52 CEST 2021<br/>        status:      valid</span><span id="376e" class="nh li iq nb b gy nm nj l nk nl">PGP key:<br/>        version:     4<br/>        algorithm:   RSA (Encrypt or Sign)<br/>        bits:        2048<br/>        fingerprint: 0xF3A90E6B10E809F851AB4FC54CC08E7F47C3EC76<br/>        create date: Wed Sep 18 02:51:23 CEST 2013<br/>        uids:        [Brett Wooldridge (Sonatype) &lt;brett.wooldridge@gmail.com&gt;]</span></pre><p id="4a45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，这些都没有多大意义。签名并不断言提供者的身份。它告诉引用的电子邮件的私钥用引用的电子邮件的私钥对其进行签名。没有什么可以阻止恶意参与者使用相同的电子邮件或类似的电子邮件创建另一个私钥。</p><h1 id="ee5d" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">功能不可信</h1><p id="6fda" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">在这一点上，我认为情况看起来相当糟糕。但比那更糟。以上都不能解释Log4J漏洞。核心原因是它提供了大多数开发者既不需要也不使用的功能。</p><p id="d4e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不想深究太多的细节，因为它已经在许多地方解释过了。可以说Log4J提供了<a class="ae lf" href="https://logging.apache.org/log4j/2.x/manual/lookups.html" rel="noopener ugc nofollow" target="_blank">查找</a>。查找是与另一个系统的集成，它允许丰富日志而不仅仅是消息。例如，Spring Boot查找允许获取Spring Boot的属性。丰富日志是有意义的，比如用<code class="fe my mz na nb b">spring.application.name</code>。</p><p id="f24a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在所有可用的查找中，有些似乎有点可疑。例如，环境变量、系统属性，甚至JNDI。后者是Log4J漏洞的根本原因。</p><p id="fae2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种隐藏的特性并不是Log4J特有的。我碰巧知道H2数据库驱动程序中有一个基于Swing的GUI管理应用程序。我只是偶然知道了这件事。</p><p id="a0b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是开发人员使用一个库作为他们的核心功能，<em class="lg">，例如，</em>，日志。如果一个人止步于此，他将永远不会知道图书馆的全部能力。因此，当库做了一些它不应该做的事情时，比如从远程JNDI资源树中读取<em class="lg">，比如</em>，人们会感到惊讶。</p><h1 id="8a2c" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">JVM不可信</h1><p id="cfc4" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">我承认这一部分的标题是误导，但我不能找到一个好的后续系列。这是上一节的后续，这次应用于JVM。</p><p id="79d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JVM提供了大量的特性，您只使用了其中的一两个。最明显的问题是Attach API。这个API从Java 1.6开始可用，它允许一个JVM更新已经加载到另一个JVM中的字节码。是的，你没看错:你可以改变正在运行的应用程序的字节码。更糟糕的是，如果重启JVM，代码会被再次加载，不会留下任何痕迹。</p><p id="fad2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想在生产中快速地对某个补丁进行猴子式修补，这是一个很酷的特性。<br/>然而:</p><ul class=""><li id="ffab" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv nc mq mr ms bi translated">大多数人不使用它</li><li id="90a2" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated">大多数人不知道这件事</li><li id="8611" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated">需要明确禁用该功能。默认情况下是打开的。</li></ul><p id="cdac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以建议你明天做的第一件事是检查你的基础设施并禁用它吗？</p><h1 id="7427" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">安全管理器可以被信任</h1><p id="42ca" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">我希望在这一点上，你明白这个问题。你运行的很多代码都不可信。更糟糕的是，我只考虑常规应用程序:构建在插件架构上的软件运行定义上不可信的代码。</p><p id="67ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安全管理器是一个JVM组件，它允许您定义一个应用程序可以做什么的白名单，而不管应用程序代码是什么。它解决了上述所有问题:你可以运行任何代码，但只允许它做有限的事情。</p><p id="3b2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安全管理器有几个缺点；其中最主要的是配置权限很无聊。但是，有一些工具可以生成策略文件。因为它们是自动化的，所以您需要仔细检查发现的权限。阅读大约500行配置比阅读10k或100k行代码更容易。</p><p id="fc33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于许多人不知道工具，很少有人使用安全管理器。但当它是，它是非常有益的。为了证明我的说法，你可以阅读<a class="ae lf" href="https://xeraa.net/blog/2021_mitigate-log4j2-log4shell-elasticsearch/" rel="noopener ugc nofollow" target="_blank">这篇帖子</a>或者跳到结论:<em class="lg">尽管Elasticsearch嵌入了一个易受攻击的Log4J版本，但它不容易受到Log4Shell的影响！</em></p><h1 id="944a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="e65e" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">安全性是非功能性需求。NFRs没有带来任何竞争优势，而且要花钱。简而言之，他们将预算从业务需求转移到<code class="fe my mz na nb b">/dev/null</code>。至少大部分业务部门是这么看的。</p><p id="fbcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为我们应该通过风险评估来处理安全问题。它要求首先列出所有可能的风险。恐怕对安全管理器的反对只是增加了几行风险，都与运行不受信任的代码有关。</p><p id="9308" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，关于安全管理器贬值的辩论并不是民间的。自从我站在<strong class="ka ir">一边反对</strong>贬值，我就一直受到公开攻击，甚至到了公然欺凌的地步。其他支持我的声音也受到了类似的待遇。</p><p id="6b95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不期望对这篇文章的反应会有任何不同。然而，我必须告诉社区成员发生了什么，我们失去了什么。</p><p id="c9c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢彼得·菲尔斯通和<a class="ae lf" href="https://twitter.com/GeertjanW" rel="noopener ugc nofollow" target="_blank">吉尔特詹·维伦加</a>对这篇文章的帮助。</p><p id="a151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="8e85" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv nc mq mr ms bi translated"><a class="ae lf" href="https://xeraa.net/blog/2021_mitigate-log4j2-log4shell-elasticsearch/" rel="noopener ugc nofollow" target="_blank">缓解弹性搜索中的log 4 J2/log 4 shell</a></li><li id="f382" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><a class="ae lf" href="https://foojay.io/today/jep-411-what-it-means-for-javas-security-model/" rel="noopener ugc nofollow" target="_blank">“JEP 411:它对Java的安全模型意味着什么，为什么你应该应用最小特权原则”</a></li><li id="eb87" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><a class="ae lf" href="https://foojay.io/today/why-jep-411-will-have-a-negative-impact-on-java-security/" rel="noopener ugc nofollow" target="_blank">最小特权原则以及JEP 411将如何对Java安全性产生负面影响</a></li><li id="0118" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv nc mq mr ms bi translated"><a class="ae lf" href="https://blog.frankel.ch/focus/jvm-security/" rel="noopener ugc nofollow" target="_blank"> JVM安全焦点</a></li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="4378" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lg">原载于</em> <a class="ae lf" href="https://blog.frankel.ch/running-untrusted-code/" rel="noopener ugc nofollow" target="_blank"> <em class="lg">一个Java怪胎</em></a><em class="lg">2022年1月22日</em></p></div></div>    
</body>
</html>