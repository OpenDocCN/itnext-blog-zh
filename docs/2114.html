<html>
<head>
<title>Routing with TypeScript decorators for node applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为节点应用程序使用类型脚本装饰器进行路由</h1>
<blockquote>原文：<a href="https://itnext.io/routing-with-typescript-decorators-for-node-applications-41a71f83f582?source=collection_archive---------7-----------------------#2019-04-02">https://itnext.io/routing-with-typescript-decorators-for-node-applications-41a71f83f582?source=collection_archive---------7-----------------------#2019-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7b13ee5879d7f1183156f5dea28ec284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SsnGgHhisKAEKXDC1XphSg.png"/></div></div></figure><p id="eb9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在编写TypeScript应用程序时，Decorators可能是一个有用的工具。我喜欢使用它们的一种方式是创建基于节点的MVC web应用程序，decorators为路由提供了一个方便的工具。像这样想一想:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c987" class="lf lg iq lb b gy lh li l lj lk"><a class="ae ll" href="http://twitter.com/Controller" rel="noopener ugc nofollow" target="_blank">@Controller</a>('/user')<br/>class UserController {<br/>    <a class="ae ll" href="http://twitter.com/Route" rel="noopener ugc nofollow" target="_blank">@Route</a>('/')<br/>    public index() {<br/>        // return proper response<br/>    }<br/>    <br/>    <a class="ae ll" href="http://twitter.com/Route" rel="noopener ugc nofollow" target="_blank">@Route</a>('/:name')<br/>    public details() {<br/>        // return proper response<br/>    }<br/>}</span></pre><p id="548c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将提供以<code class="fe lm ln lo lb b">/user</code>为前缀的路线，而<code class="fe lm ln lo lb b">/user</code>可能导致用户概述，而<code class="fe lm ln lo lb b">/user/:name</code>导致用户细节。如果你习惯于<a class="ae ll" href="https://symfony.com/doc/current/routing.html" rel="noopener ugc nofollow" target="_blank"> Symfony路由</a>或<a class="ae ll" href="https://docs.nestjs.com/controllers" rel="noopener ugc nofollow" target="_blank"> NestJS控制器</a>，这个概念可能看起来很熟悉。</p><h1 id="a2ed" class="lp lg iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">介绍</h1><p id="104d" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">在这篇文章中，我们将使用<a class="ae ll" href="https://www.npmjs.com/package/ts-node" rel="noopener ugc nofollow" target="_blank"> ts-node </a>构建一个带有TypeScript的<a class="ae ll" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>应用程序(这使得运行TypeScript应用程序而不必手动编译我们的<code class="fe lm ln lo lb b">.ts</code>文件成为可能)。</p><p id="9943" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以使用任何你想要的底层框架，例如<a class="ae ll" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> koa </a>、<a class="ae ll" href="https://hapijs.com/" rel="noopener ugc nofollow" target="_blank"> hapi </a>或者甚至是你自己的http服务器实现。差异应该仅在实际注册路由时出现，其他一切都应该保持不变。我选择express的唯一原因是因为我对它最有经验——但是你可以随意使用你想要的任何东西。</p><p id="053d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">万一你在找一个TL；DR:你可以在GitHub 上找到这篇文章的<a class="ae ll" href="https://github.com/nehalist/ts-decorator-routing" rel="noopener ugc nofollow" target="_blank">完整源代码(包括测试)。</a></p><h1 id="f957" class="lp lg iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">体系结构</h1><p id="afd7" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">用TypeScript实现路由功能有不同的方法。但是在开始实现之前，记住一些事情是很重要的。</p><p id="6529" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个重要信息是:</p><blockquote class="ms mt mu"><p id="667f" class="jy jz mr ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">Decorators是在类被声明时调用的，而不是在它被实例化时。</p></blockquote><p id="cddc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以当装饰我们的方法时，我们在我们的装饰器中使用实例化的对象。相反，我们只有一个可以使用的类声明。有关装饰工评估订单的详细信息，请参见此处的。</p><p id="00ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为装饰者只是函数，他们有自己的作用域。一旦我们意识到express的路由注册发生在decorators之外，这就有点成问题了:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/aded239a81324aa05175ce61ee83f3df.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*oWwANRrbZ7PI_KLN.png"/></div></figure><p id="3f37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将我们的路由从装饰器获取到express应用程序的一种方法是引入一个注册表类，它将由我们的装饰器填充，并在稍后注册我们的路由时读取。</p><p id="4b7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">但是</strong>有一种更简单的方法，它涉及到<a class="ae ll" href="https://github.com/rbuckton/reflect-metadata" rel="noopener ugc nofollow" target="_blank"> reflect-metadata </a>库(如果你在和decorators打交道，你可能已经在使用它了)。我们可以简单地将路由附加到控制器元数据，而不是使用单独的层(以注册表的形式):</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d0b8907a4b4c7e275ef669f4e85867b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*bVMBJMCKUDqmp8fp.png"/></div></figure><p id="ce6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只需将路由保存到控制器元数据中。稍后，当在我们的express应用程序中注册我们的路线时，我们已经需要加载我们的控制器——这就是我们简单地读取我们的路线元数据并正确注册它们的地方。</p><p id="1bb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">知道了所有这些，让我们开始实现我们的路由装饰器吧！</p><h1 id="f375" class="lp lg iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">快速申请</h1><p id="dc43" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">首先，我们需要创建我们的express应用程序。在我们的第一次迭代中，我们将只提供一条默认路线来测试是否一切正常:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3afa" class="lf lg iq lb b gy lh li l lj lk">// index.ts</span><span id="d740" class="lf lg iq lb b gy na li l lj lk">import 'reflect-metadata';<br/>import {Request, Response} from 'express';</span><span id="2e58" class="lf lg iq lb b gy na li l lj lk">const app = express();</span><span id="c6af" class="lf lg iq lb b gy na li l lj lk">app.get('/', (req: Request, res: Response) =&gt; {<br/>  res.send('Hello there!');<br/>});</span><span id="ffca" class="lf lg iq lb b gy na li l lj lk">app.listen(3000, () =&gt; {<br/>  console.log('Started express on port 3000');<br/>});</span></pre><blockquote class="ms mt mu"><p id="27bf" class="jy jz mr ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">每个应用程序只需要导入一次，因此这里是这样做的好地方。</p></blockquote><p id="e77a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用<code class="fe lm ln lo lb b">ts-node index.ts</code>启动你的服务器，前往<code class="fe lm ln lo lb b">localhost:3000</code>接受<a class="ae ll" href="https://www.youtube.com/watch?v=rEq1Z0bjdwc" rel="noopener ugc nofollow" target="_blank">奥比万</a>的友好问候。</p><h1 id="a890" class="lp lg iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">控制器装饰器</h1><p id="b874" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这个装饰器将被附加到我们的控制器上，并包含这个控制器的前缀:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="0c67" class="lf lg iq lb b gy lh li l lj lk">// Decorator/Controller.ts</span><span id="5096" class="lf lg iq lb b gy na li l lj lk">export const Controller = (prefix: string = ''): ClassDecorator =&gt; {<br/>  return (target: any) =&gt; {<br/>    Reflect.defineMetadata('prefix', prefix, target);</span><span id="68a3" class="lf lg iq lb b gy na li l lj lk">// Since routes are set by our methods this should almost never be true (except the controller has no methods)<br/>    if (! Reflect.hasMetadata('routes', target)) {<br/>      Reflect.defineMetadata('routes', [], target);<br/>    }<br/>  };<br/>};</span></pre><p id="54b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个非常简单的类装饰器，它在控制器上设置<code class="fe lm ln lo lb b">prefix</code>元数据，如果没有找到<code class="fe lm ln lo lb b">routes</code>元数据，就将其设置为一个空数组。如注释中所述，<code class="fe lm ln lo lb b">routes</code>几乎不应该是<code class="fe lm ln lo lb b">undefined</code>，除非我们的控制器没有修饰方法。</p><h1 id="04f4" class="lp lg iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">路线装饰者</h1><p id="7a56" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">为每个HTTP动词，如<code class="fe lm ln lo lb b">@Get</code>、<code class="fe lm ln lo lb b">@Post</code>等，都有一个装饰器会很方便..为了简单起见，我们只实现了<code class="fe lm ln lo lb b">@Get</code>装饰器:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8a93" class="lf lg iq lb b gy lh li l lj lk">// Decorator/Get.ts</span><span id="87e5" class="lf lg iq lb b gy na li l lj lk">import {RouteDefinition} from '..';</span><span id="2dbe" class="lf lg iq lb b gy na li l lj lk">export const Get = (path: string): MethodDecorator =&gt; {<br/>  // `target` equals our class, `propertyKey` equals our decorated method name<br/>  return (target, propertyKey: string): void =&gt; {<br/>    // In case this is the first route to be registered the `routes` metadata is likely to be undefined at this point.<br/>    // To prevent any further validation simply set it to an empty array here.<br/>    if (! Reflect.hasMetadata('routes', target.constructor)) {<br/>      Reflect.defineMetadata('routes', [], target.constructor);<br/>    }</span><span id="b35f" class="lf lg iq lb b gy na li l lj lk">// Get the routes stored so far, extend it by the new route and re-set the metadata.<br/>    const routes = Reflect.getMetadata('routes', target.constructor) as Array&lt;RouteDefinition&gt;;</span><span id="22e0" class="lf lg iq lb b gy na li l lj lk">routes.push({<br/>      requestMethod: 'get',<br/>      path,<br/>      methodName: propertyKey<br/>    });<br/>    Reflect.defineMetadata('routes', routes, target.constructor);<br/>  };<br/>};</span></pre><blockquote class="ms mt mu"><p id="7420" class="jy jz mr ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">重要:</em> </strong> <em class="iq">重要的是设定我们的目标</em> <code class="fe lm ln lo lb b"><em class="iq">target.constructor</em></code> <em class="iq">而不仅仅是</em> <code class="fe lm ln lo lb b"><em class="iq">target</em></code> <em class="iq">来恰当地处理元数据。</em></p></blockquote><p id="8a19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，这是一个非常简单的装饰器，它通过一个新的路由来扩展控制器上存储的路由。<code class="fe lm ln lo lb b">RouteDefinition</code>是定义路线形状的界面:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="2bae" class="lf lg iq lb b gy lh li l lj lk">// Model/RouteDefinition.ts</span><span id="532c" class="lf lg iq lb b gy na li l lj lk">export interface RouteDefinition {<br/>  // Path to our route<br/>  path: string;<br/>  // HTTP Request method (get, post, ...)<br/>  requestMethod: 'get' | 'post' | 'delete' | 'options' | 'put';<br/>  // Method name within our class responsible for this route<br/>  methodName: string;<br/>}</span></pre><blockquote class="ms mt mu"><p id="4bb5" class="jy jz mr ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">提示:</em> </strong> <em class="iq">如果您想在控制器之前添加一些中间件，最好将其存储在</em> <code class="fe lm ln lo lb b"><em class="iq">RouteDefinition</em></code> <em class="iq">中。</em></p></blockquote><p id="205e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经得到了我们需要的两个装饰者，可以返回到我们的express应用程序来注册我们的路线了。</p><h1 id="4733" class="lp lg iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">注册路线</h1><p id="a4ef" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">在将我们的路由注册到我们的express应用程序之前，让我们用新的decorators实现一个控制器:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="45bf" class="lf lg iq lb b gy lh li l lj lk">// UserController.ts</span><span id="ece2" class="lf lg iq lb b gy na li l lj lk">import {Controller} from '../src';<br/>import {Get} from '../src';<br/>import {Request, Response} from 'express';</span><span id="8d87" class="lf lg iq lb b gy na li l lj lk"><a class="ae ll" href="http://twitter.com/Controller" rel="noopener ugc nofollow" target="_blank">@Controller</a>('/user')<br/>export default class UserController {<br/>  <a class="ae ll" href="http://twitter.com/Get" rel="noopener ugc nofollow" target="_blank">@Get</a>('/')<br/>  public index(req: Request, res: Response) {<br/>    return res.send('User overview');<br/>  }</span><span id="d666" class="lf lg iq lb b gy na li l lj lk"><a class="ae ll" href="http://twitter.com/Get" rel="noopener ugc nofollow" target="_blank">@Get</a>('/:name')<br/>  public details(req: Request, res: Response) {<br/>    return res.send(`You are looking at the profile of ${req.params.name}`);<br/>  }<br/>}</span></pre><p id="59a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">标题到<code class="fe lm ln lo lb b">/user</code>应该显示一个“用户概述”信息，而<code class="fe lm ln lo lb b">/user/foobar</code>应该显示一个“你正在查看foobar的个人资料”信息。</p><p id="c79b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在这完全起作用之前，我们需要告诉express我们的路线——所以让我们回到我们的<code class="fe lm ln lo lb b">index.ts</code>:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="89b8" class="lf lg iq lb b gy lh li l lj lk">import 'reflect-metadata';<br/>import * as express from 'express';<br/>import UserController from './example/UserController';<br/>import {RouteDefinition} from './src';</span><span id="4f99" class="lf lg iq lb b gy na li l lj lk">const app = express();</span><span id="79bb" class="lf lg iq lb b gy na li l lj lk">app.get('/', (req: express.Request, res: express.Response) =&gt; {<br/>  res.send('Hello there!');<br/>});</span><span id="abb2" class="lf lg iq lb b gy na li l lj lk">// Iterate over all our controllers and register our routes<br/>[<br/>  UserController<br/>].forEach(controller =&gt; {<br/>  // This is our instantiated class<br/>  const instance                       = new controller();<br/>  // The prefix saved to our controller<br/>  const prefix                         = Reflect.getMetadata('prefix', controller);<br/>  // Our `routes` array containing all our routes for this controller<br/>  const routes: Array&lt;RouteDefinition&gt; = Reflect.getMetadata('routes', controller);<br/>  <br/>  // Iterate over all routes and register them to our express application <br/>  routes.forEach(route =&gt; {<br/>    // It would be a good idea at this point to substitute the `app[route.requestMethod]` with a `switch/case` statement<br/>    // since we can't be sure about the availability of methods on our `app` object. But for the sake of simplicity<br/>    // this should be enough for now.<br/>    app[route.requestMethod](prefix + route.path, (req: express.Request, res: express.Response) =&gt; {<br/>      // Execute our method for this path and pass our express request and response object.<br/>      instance[route.methodName](req, res);<br/>    });<br/>  });<br/>});</span><span id="a08e" class="lf lg iq lb b gy na li l lj lk">app.listen(3000, () =&gt; {<br/>  console.log('Started express on port 3000');<br/>});</span></pre><p id="68dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">瞧，就是这样。我们现在可以导航到<code class="fe lm ln lo lb b">/user</code>或<code class="fe lm ln lo lb b">/user/&lt;name&gt;</code>，并从我们的快速应用程序中获得适当的响应。<em class="mr">哇呼！</em></p><h1 id="f52c" class="lp lg iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">推进这种方法</h1><p id="8efe" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这是一个非常基本的方法，在实际实现中还有很多改进的空间。下面是一些关于改进这种实现的想法:</p><h1 id="cf12" class="lp lg iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">实例化</h1><p id="3079" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我们的控制器用<code class="fe lm ln lo lb b">new controller()</code>天真地实例化了。但是如果我们的控制器有一些<code class="fe lm ln lo lb b">constructor</code>参数呢？</p><p id="a997" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将是一个完美的用例来应用一些<a class="ae ll" href="https://nehalist.io/dependency-injection-in-typescript/" rel="noopener ugc nofollow" target="_blank">依赖注入，如前一篇文章</a>中所描述的，它将被插入到我们的控制器被实例化的地方。</p><h1 id="0607" class="lp lg iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">返回值</h1><p id="48b3" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我不是<code class="fe lm ln lo lb b">res.send()</code>的狂热粉丝——相反，如果响应可以是反映其内容的简单对象，那会非常方便(想想类似<code class="fe lm ln lo lb b">return new JsonResponse(/* ... */)</code>的东西)。这可以通过实现这样的响应对象并从我们的方法中返回它们来轻松完成——稍后，当注册我们的路由时，回调仍然会<code class="fe lm ln lo lb b">send</code>我们的响应:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="be24" class="lf lg iq lb b gy lh li l lj lk">app[route.requestMethod](prefix + route.path, (req: express.Request, res: express.Response) =&gt; {<br/>  const response = instance[route.methodName](req, res);<br/>  res.send(response.getContent()); // where `getContent` returns the actual response content</span></pre><p id="a8e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将需要对我们的返回值进行额外的验证，尤其是为了防止express由于缺少一个<code class="fe lm ln lo lb b">next()</code>调用而被阻塞(这个调用包含在<code class="fe lm ln lo lb b">send</code>中，但是如果您不使用<code class="fe lm ln lo lb b">send</code>则需要手动调用)。</p><h1 id="af6e" class="lp lg iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="8174" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">正如您刚刚看到的，通过TypeScript decorators处理路由非常简单，不需要太多的魔法，也不需要安装框架或任何额外的库。</p><p id="cf08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一如既往，这篇文章的全部源代码(包括测试)可以在GitHub 上找到。</p><p id="c48f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mr">如果你有其他方法来实现这个目标，或者对这篇文章中描述的方法有任何想法，请留下你的评论！</em></p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="a87b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mr">如果你喜欢这篇文章，请留下你的👏，关注我上</em> <a class="ae ll" href="https://twitter.com/nehalist" rel="noopener ugc nofollow" target="_blank"> <em class="mr">推特</em> </a> <em class="mr">并订阅</em> <a class="ae ll" href="https://nehalist.io/newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">我的快讯</em> </a> <em class="mr">。原载于2019年4月2日</em><a class="ae ll" href="https://nehalist.io/routing-with-typescript-decorators/" rel="noopener ugc nofollow" target="_blank"><em class="mr">nehalist . io</em></a><em class="mr">。</em></p></div></div>    
</body>
</html>