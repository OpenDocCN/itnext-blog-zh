<html>
<head>
<title>Redux without State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无状态还原</h1>
<blockquote>原文：<a href="https://itnext.io/redux-without-state-15e2f839055c?source=collection_archive---------5-----------------------#2019-08-21">https://itnext.io/redux-without-state-15e2f839055c?source=collection_archive---------5-----------------------#2019-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b46c9dfde6c5635fff5dbf697f3f0272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HuigGcMsQeUNCBDn"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">本·怀特在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="1939" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">为什么？</h2></div><p id="1256" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你能获得Redux的大部分好处，而且不用写一个reducer，会怎么样？</p><p id="9e10" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您必须支持一个遗留的AngularJS、jQuery、Backbone或Knockout应用程序，那该怎么办？如果您现在想使用Redux，您将不得不担心有两组状态。</p><p id="ebe2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以的！而你需要的只是没有状态的Redux。</p><p id="07b2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是Redux是一个状态管理器:</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/1fdb91b6db832e821f1491329b78ccf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*fScTboBVAsyDDdJAlcKhMA.png"/></div></figure><p id="0856" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么为什么会有人使用没有状态的Redux呢？这就像有人给了你一个已经吃过的苹果作为午餐。那有什么好处？</p><p id="7e16" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Redux的真正力量并不来自于状态管理。这只是关键成分的副作用:一个<strong class="kx jh">消息传递</strong>系统。</p><h1 id="a792" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">Redux中的消息传递</h1><p id="e913" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">在Redux中，消息被称为动作，它们通常用于更新状态。</p><p id="9b3a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">中间件功能是Redux的另一个关键元素，但是它们不更新状态。这些函数只分派动作或产生副作用(比如AJAX调用和控制台日志记录)。</p><p id="4f43" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着它们只监听动作，然后分派其他动作:</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mt"><img src="../Images/fc6462841596baba6a591109b48e2e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDcR-CCfuVuMbrC8GipA2Q.png"/></div></div></figure><p id="7722" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Redux中间件相当神奇。下面是一些例子，说明添加中间件后，可以用Redux操作做些什么:</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mt"><img src="../Images/8a25038aa9293357707867ee4348bd75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vw-LjaBmWQ4A5z0pnZIqoA.png"/></div></div></figure><p id="aba2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样的<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/redux-observable-without-redux-ff4a2b5a4b39">你不需要Redux来使用Redux-Observable </a>，你也不需要状态或者Redux中的动作系统。要理解Redux消息传递，您必须首先理解动作。</p><h2 id="8b08" class="mu lx jg bd ly mv mw dn mc mx my dp mg le mz na mi li nb nc mk lm nd ne mm nf bi translated">什么是行动？</h2><p id="ca76" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">Redux消息系统的核心是<strong class="kx jh">动作</strong>。它是一个具有<code class="fe ng nh ni nj b">type</code>属性的对象。</p><pre class="ls lt lu lv gt nk nj nl nm aw nn bi"><span id="28eb" class="mu lx jg nj b gy no np l nq nr">{ type: 'SOME_ACTION' }</span></pre><p id="3d31" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样。</p><p id="ba61" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ng nh ni nj b">type</code>可以是任何东西:<code class="fe ng nh ni nj b">string</code>、<code class="fe ng nh ni nj b">object</code>、<code class="fe ng nh ni nj b">symbol</code>，甚至<code class="fe ng nh ni nj b">number</code>。最佳实践是在所有大写字母中使用字符串，以便于调试。</p><p id="b98c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">动作是拥有无状态Redux的关键。</p><h1 id="8a55" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">无状态冗余</h1><p id="2897" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">实现自己的无状态Redux非常简单。我们将介绍几种不同的方法来创建您自己的。</p><p id="2dc4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以创建自己的<code class="fe ng nh ni nj b">dispatch</code>函数，如下所示:</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9eea" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">出于兼容性的原因，ES5中的例子。</p><p id="ee81" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果<code class="fe ng nh ni nj b">stateModifiers</code>中存在<code class="fe ng nh ni nj b">action.type</code>，则调用该函数并传入<code class="fe ng nh ni nj b">action</code>。</p><p id="1bf6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">听起来熟悉吗？</p><p id="7de0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Redux reducers也听动作。唯一的区别是缩减器不会改变状态，它会返回一个新的状态。</p><p id="fe87" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是您可能正在使用一个遗留系统，状态突变是正常的。这就是为什么这些状态修改函数允许你改变状态。</p><p id="6b98" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我们的<code class="fe ng nh ni nj b">dispatch</code>函数在AngularJS控制器中的样子:</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ab51" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每次我们改变状态，它都发生在<code class="fe ng nh ni nj b">stateModifiers</code>对象中。把这个想象成一个减速器函数。因为你的应用程序已经有了一个维护状态的方法，你所做的只是包装代码。</p><p id="e530" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不要为了使用Redux而重写AngularJS。让Redux与您现有的应用程序一起工作。您可以逐步添加<code class="fe ng nh ni nj b">dispatch</code>功能到您的控制器，并根据需要进行更新。这样，<strong class="kx jh">你不必仅仅为了从Redux中获益而改变渲染库</strong>。</p><p id="dd62" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">状态修改不再散落在你的代码库中。现在他们都在一个地方；容易找到，容易调试。</p><p id="c2fa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大部分情况下，你需要的只是<code class="fe ng nh ni nj b">dispatch</code>。开始控制台日志记录操作，您已经从Redux消息传递中受益。</p><h2 id="b7bb" class="mu lx jg bd ly mv mw dn mc mx my dp mg le mz na mi li nb nc mk lm nd ne mm nf bi translated">添加订户</h2><p id="842d" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">调度很棒，但是大多数Redux应用需要中间件。您需要某种方式来说明“当X被更改时，调度其他操作”。</p><p id="b563" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然像Knockout和Angular这样的大多数库允许您监听状态变化，但这只是等式的一部分。</p><p id="d7db" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可能想把一个动作转换成另一个动作或者产生副作用。一个这样的例子是连接到第三方库——想想支持聊天客户端和服务，如<a class="ae jd" href="https://logrocket.com/" rel="noopener ugc nofollow" target="_blank"> LogRocket </a>。很多时候，一个动作会触发多段代码执行。</p><p id="f400" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是为什么您需要一种方式来订阅您的<code class="fe ng nh ni nj b">dispatch</code>函数并在状态更新后执行中间件:</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5a36" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个简单的例子来说明你为什么需要中间件:</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="83c7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与我们前面的例子相比，当点击发生时，我们不再进行数据调用。相反，我们只调度<code class="fe ng nh ni nj b">GET_IDS</code>动作。</p><p id="005f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，两个中间件函数正在监听<code class="fe ng nh ni nj b">GET_IDS</code>。一个触发装载指示器。另一个打数据电话。</p><p id="5c72" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是Redux的关注点分离的亮点。您的点击处理程序不再需要管理您的业务逻辑；这是在状态修改器和中间件函数中处理的。</p><h2 id="03f6" class="mu lx jg bd ly mv mw dn mc mx my dp mg le mz na mi li nb nc mk lm nd ne mm nf bi translated">欺骗的</h2><p id="f5ca" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">如果您想使用您的<code class="fe ng nh ni nj b">stateModifiers</code>对象创建中间件，这在技术上是可能的。问题是，我不建议这么做。</p><p id="0d42" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您将状态修饰符与中间件功能结合起来，您就失去了将状态更新作为独立实体的一部分的机会。</p><h1 id="2636" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">使其可重复使用</h1><p id="e80a" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">假设您想在今天的应用程序中使用它。你会想用不同的方式来写。大概是这样的:</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5fd3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了错误日志，一切都包含在一个<code class="fe ng nh ni nj b">createStore</code>函数中，就像Redux一样。唯一的区别是除了“商店”内部订户列表之外，没有其他状态。</p><p id="816f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个版本中,<code class="fe ng nh ni nj b">subscribe</code>可以接受一组中间件，我们的调度函数有一些安全检查和错误记录。</p><p id="53ac" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你将<code class="fe ng nh ni nj b">window.__isDebugging</code>设置为<code class="fe ng nh ni nj b">true</code>，它也会记录下每一个动作，这样你就可以跟踪正在发生的事情。当然，这不是Redux的devtools，但仍然很有帮助。</p><p id="dc6d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你看到一个红色错误信息的大博客，你现在可以通过查看你的控制台来跟踪哪个操作导致了它。</p><p id="1c83" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是你如何使用它:</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="01d6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然Redux是一个“一个全局存储来管理它们”的库，但是这个无状态版本可以，并且可能应该，在每个控制器中使用。</p><p id="4c7c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样，您可以更好地控制正在发生的事情，而无需让整个应用程序全局感知自身。在许多遗留应用程序中，这是您想要的。</p><h2 id="3618" class="mu lx jg bd ly mv mw dn mc mx my dp mg le mz na mi li nb nc mk lm nd ne mm nf bi translated">将无状态Redux与合法Redux一起使用</h2><p id="e37d" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">你也可以对官方库进行无状态还原。你所要做的就是使用一个减速器，并且总是返回到先前的状态:</p><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="07fc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">没有定制的解决方案好，但是可以连接到现有的中间件库，比如Redux-Observable，没问题。</p><p id="020c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，如果您有能力引入npm依赖项，您可能也不需要无状态Redux。</p><h1 id="9581" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">真正的面向对象编程</h1><p id="8a5f" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我一直在谈论Redux的消息系统，好像它是一个非凡的东西，它确实是。</p><p id="4b54" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">艾伦·凯，那个称之为面向对象编程的家伙，实际上是在谈论面向消息编程。</p><p id="51a9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从2003年<a class="ae jd" href="http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en" rel="noopener ugc nofollow" target="_blank">发给艾伦·凯</a>的一封邮件中，他是这样说的:</p><blockquote class="nu nv nw"><p id="8306" class="kv kw nx kx b ky kz kh la lb lc kk ld ny lf lg lh nz lj lk ll oa ln lo lp lq ij bi translated">我认为对象就像生物细胞和/或网络上的单个计算机，只能与消息进行通信(所以消息传递在一开始就出现了——花了一段时间才明白如何用编程语言足够有效地进行消息传递才是有用的)。</p><p id="cf05" class="kv kw nx kx b ky kz kh la lb lc kk ld ny lf lg lh nz lj lk ll oa ln lo lp lq ij bi translated">我想摆脱数据。[……]我意识到，细胞/整个计算机的比喻将摆脱数据，而“</p></blockquote><p id="c0af" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简而言之，这就是无状态Redux。</p><h1 id="966f" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">结论</h1><p id="41e7" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">在Redux之前，没有太多好的方法来跟踪应用程序的状态。</p><p id="4cc7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回头看，jQuery的很多代码也是事件驱动的，就像Redux的消息系统一样。您将听到诸如单击事件处理程序、鼠标移动、跟踪更新、文档加载和图像加载之类的内容。但是为什么Redux这么干净，jQuery却变成了意大利面代码？</p><p id="c2bd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在过去，您订阅了特定的操作(事件)。你不能像Redux中间件那样订阅任何和所有的动作。此外，在使用事件发射器时，状态更新和中间件功能之间没有分离。</p><p id="0b91" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从成本上考虑Redux。</p><p id="2c26" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它有一点短期成本，但从长远来看，它具有广泛的可维护性，并将业务逻辑从您的视图中分离出来。即使有了无状态Redux，虽然您没有得到不可变的状态和易于测试的纯函数，但是您可以获得巨大的好处，知道到底发生了什么。</p><h1 id="87f6" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">更多阅读</h1><p id="73c7" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">如果你喜欢你所读的，请查看我关于类似的令人大开眼界的主题的其他文章:</p><ul class=""><li id="8d9c" class="ob oc jg kx b ky kz lb lc le od li oe lm of lq og oh oi oj bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/the-definitive-guide-to-callbacks-in-javascript-44a39c065292">试听:权威指南</a></li><li id="9398" class="ob oc jg kx b ky ok lb ol le om li on lm oo lq og oh oi oj bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/promises-the-definitive-guide-6a49e0dbf3b7">承诺:权威指南</a></li><li id="e1de" class="ob oc jg kx b ky ok lb ol le om li on lm oo lq og oh oi oj bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/feature-flags-be-truly-agile-820ff50294c">特性标志:真正敏捷</a></li><li id="c9f2" class="ob oc jg kx b ky ok lb ol le om li on lm oo lq og oh oi oj bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223">带有表情符号的函数式编程基础知识</a></li></ul></div></div>    
</body>
</html>