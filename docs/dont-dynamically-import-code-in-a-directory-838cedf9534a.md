# 不要在目录中动态导入代码

> 原文：<https://itnext.io/dont-dynamically-import-code-in-a-directory-838cedf9534a?source=collection_archive---------3----------------------->

一些开发人员正在追随一种趋势，即使用`fs`模块在 NodeJS 中按目录导入代码。

示例文件:src/models/index.js

这种方法的好处:

*   模块只需存在于一个目录中就可以导入。它们可以用作命名导出。

```
import { users } = from "../models";orconst { users } = require('../models');
```

*   没有必要更新一个巨大的索引文件。(代码行更少；较少样板文件)
*   可能有一个业务或架构需求来实现这一点，这将使本文的其余部分成为一个争论点。

> 我错过了什么好处吗？让我知道，我会添加它。我不想通过忽略事实来误导。

# 为什么不值得

## 1.该行为是意外的

不是所有的开发人员都知道导入技巧，特别是因为它通常仅限于某些目录，比如模型。那些开发者可能会打破现有的模式，直接导入一个模块。

```
const users = require("./models/users");
```

然后，另一个开发人员可以为他们的模型复制/粘贴相同的导入，从而在代码库中产生两种不同的模式。

## 2.未使用的文件可以运送给客户

如果上面的代码示例没有验证扩展，那么可能有一个名为`.DS_Store`的模块(至少在 Mac 上)。

一个名为`oxford-dictionary.js`的大文件会绕过那个过滤器。虽然它可能不会导致错误，但它不必要地增加了代码的大小。这似乎是一个极端的例子(确实如此)，但是在一个目录中有额外的文件并不罕见。许多开发人员将`*.spec.js`或`*.test.js`文件放在他们正在测试的代码旁边，以保持代码的可移植性。给定上面的代码示例，这些文件将包含在应用程序中。

denylist 可以过滤掉不想要的文件，但是这又能如何呢？捕捉或调试边缘案例所花费的时间可能比输入`module.exports.users = require('./users');`或`export { default } from './users';`所花费的时间还要多

一些树摇动代码捆绑器，像 webpack，可能足够聪明去删除不用的文件，或者他们可能太愚蠢去包含你真正想要的文件。

## 3.存在安全问题

包含代码的策略从 allowlist 更改为 denylist。使用 allowlist，只导入您想要包含的模块。denylist 在这种情况下是有缺陷的，因为需要考虑要排除的每个名称组合。

如果黑客或心怀不满的员工获得了对服务器的访问权，他们可以在目录中包含`bitcoin-miner.js`，巧妙地使用您的服务器和进程 ID (PID)来运行他们的代码。他们需要做的就是重新开始这个过程。

## 4.代码编辑器(ide)找不到你的定义

有些 ide，如 VSCode，使用静态定义的导入语句来导航代码库。但是，通过文件系统进行动态导入时，一些功能会停止工作:

*   编辑器会告诉你没有找到目标模块的定义。
*   `Rename Symbols`更改文件名不会更新参照，重命名参照也不会更新文件名。
*   `Go to References`IDE 不会知道你的模块用在哪里。就它而言，你的模块不存在。
*   `Intellisense/Auto-complete`从模块导入时，上下文菜单中没有命名导出列表。

> 你的 IDE 或插件能更好地处理这个问题吗？让我知道，我会更新这一部分。

## 5.静态分析和林挺工具分析静态代码

出于与上一点相同的原因，静态分析或林挺工具可能会认为 import/require 语句无效，因为它们找不到显式的 export 语句。

开发人员可能会浪费时间去理解为什么会引入一个 bug，结果却发现似乎无害地删除一个“未使用的”导入才是问题所在。

> 我说“可能”是因为我只运行了一个林挺工具，而不是一个全功能的静态分析工具来验证。当测试 eslint-plugin-import 时，只有在当前文件中没有使用导入时，linter 才尝试从外部验证模块的存在。然而，我在过去使用其他语言和旧版本的工具(如 Codacy)时遇到过这种情况。

## 6.手动搜索定义非常繁琐

开发人员可能很难手动找到定义。当搜索像`users`这样的模型时，可能会有数百个结果。此外，VSCode 在主搜索中不包括文件名。因此，找到下面定义的示例用户模型(带有未命名的导出)可能会很困难。

```
module.exports = { // ES6: export default
  create: () => { ... },
  read: () => { ... },
  update: () => { ... },
  delete: () => { ... }
};
```

(你可以通过`Go to File`搜索找到它)

## 7.添加一两行代码并不是负担

> 事实上，花在阅读和写作上的时间比远远超过 10 比 1。作为编写新代码工作的一部分，我们不断地阅读旧代码。…[因此，]让它容易阅读，就更容易写作。
> 
> ― **罗伯特·c·马丁，** [**干净的代码:敏捷软件技术手册**](https://www.goodreads.com/work/quotes/3779106)

显式导入模块只需几秒钟，可读性更好。将一个`index.js`文件视为一个允许列表，而不是样板代码。

## 8.删除代码时，您仍然需要更新引用

删除`users`模型时不需要更新`models/index.js`文件。一些开发人员认为更容易删除代码是一个好处。然而，由于需要手动搜索用法(例如:`const { users } = require('./models'); users.create();`)，代码删除变得更加困难。因此，这不包括在福利清单中。

## 9.更少的代码行并不总是意味着更好的代码

一些开发人员将简洁等同于简单。你可以从下面的例子中看出为什么不是这样的。

```
// One line of code
const state = lastLoginTime - now < 1000 ? loginAttempts > 10 ? "Locked" : "Active" : "Inactive"
```

```
// 9 lines of code
let state = "Inactive";if (loginAttempts > 10) {
  state = "Locked";
}if (lastLoginTime - now < 1000) {
  state = "Active"
}
```

第二个例子比第一个例子长八行，但是更容易理解。

# 结论

虽然自动导入代码看起来很吸引人，但可能不值得引入复杂性。一个让一个开发人员节省 30 秒的技巧可能会偷走另一个开发人员的一个小时——故障排除。或者，没有时间会因为缺乏意识而被浪费，无关的导入会潜入到产品代码中。

> 虽然这篇文章偏向于一个特定的结果，但事实不应该如此。如果你觉得我遗漏了重要的信息或者夸大了什么，请在评论中告诉我。