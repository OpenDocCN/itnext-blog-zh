<html>
<head>
<title>Cookies with React, Express and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带React、Express和Docker的Cookies</h1>
<blockquote>原文：<a href="https://itnext.io/cookies-with-react-express-and-docker-15296fac20fb?source=collection_archive---------1-----------------------#2019-07-02">https://itnext.io/cookies-with-react-express-and-docker-15296fac20fb?source=collection_archive---------1-----------------------#2019-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e4ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我不得不将JWT转移到cookies，以便在Docker微服务之间无缝使用它。我们在单独的url前缀上运行每个容器，这很难搞清楚，因为当url改变时cookies必须在那里。我找不到任何直接的解决方案，所以我决定写这篇文章，它可能对某人有用，甚至对未来的我有用。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/aa1f591c15bb44a1f0de89d248a52eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k87q1EVhYNPZ6Li_dcwV4g.jpeg"/></div></div></figure><p id="5313" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我只是假设你有工作的前端和后端容器，一切运行良好。我不会解释什么是cookies，因为有很多关于这个主题的更好的文章。</p><h2 id="a2e2" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">基本设置</h2><p id="23fc" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">让我们以简单快捷服务器为例来说明如何发送cookies。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="4ef6" class="kx ky iq lw b gy ma mb l mc md">// index.js</span><span id="0ff1" class="kx ky iq lw b gy me mb l mc md">const express = require("express")<br/>const session = require("express-session");</span><span id="ff9d" class="kx ky iq lw b gy me mb l mc md">const app = express()</span><span id="b3c3" class="kx ky iq lw b gy me mb l mc md">app.use(<br/>  session({<br/>    secret: process.env.LOGIN_SERVER_SECRET,<br/>    saveUninitialized: true,<br/>    resave: true,<br/>    cookie: {<br/>      httpOnly: false,<br/>      secure: false,<br/>    },<br/>  }),<br/>);</span><span id="fc1e" class="kx ky iq lw b gy me mb l mc md">app.get("/cookie", (req, res) =&gt; {<br/>  const options = {<br/>    secure: <!-- -->false<!-- -->,<br/>    httpOnly: <!-- -->false<!-- -->,<br/>    domain: ".your.domain.com"<br/>  }</span><span id="cda4" class="kx ky iq lw b gy me mb l mc md">  return res<br/>    .cookie("cookieName", "cookieValue", options)<br/>    .status(200)<br/>    .send("cookie sent")<br/>})<br/><br/>app.listen(8080)</span></pre><p id="6068" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，每当我们向<em class="mf"> localhost:8080/cookie </em>发送请求时，服务器都会用Set-Cookie头进行响应。当你直接在浏览器或类似Postman的应用程序中输入时，效果很好。当你在client.your.domain.com的T2运行客户端，在server.your.domain.com的T4运行服务器时，问题就出现了。我们开始遇到CORS问题。</p><p id="df40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看我们的客户端应用程序的基本设置。我使用create-react-app，并通过添加<a class="ae mg" href="https://www.npmjs.com/package/superagent" rel="noopener ugc nofollow" target="_blank"> superagent </a>(用于请求的伟大库)和每当我点击链接时发送请求来修改它。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="cbe4" class="kx ky iq lw b gy ma mb l mc md">// App.js</span><span id="c880" class="kx ky iq lw b gy me mb l mc md">import React from "react";<br/>import superagent from "superagent";<br/>import logo from "./logo.svg";<br/>import "./App.css";</span><span id="ea8d" class="kx ky iq lw b gy me mb l mc md">function App() {</span><span id="aecd" class="kx ky iq lw b gy me mb l mc md">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;header className="App-header"&gt;<br/>        &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br/>        &lt;p&gt;<br/>          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br/>        &lt;/p&gt;<br/>        &lt;a<br/>          className="App-link"<br/>          onClick={() =&gt;<br/>            superagent<br/>              .get("http://localhost:<!-- -->8080<!-- -->/cookie")<br/>              .then(response =&gt; {<br/>                console.log(response);<br/>              })<br/>          }<br/>        &gt;<br/>          Get Cookie<br/>        &lt;/a&gt;<br/>      &lt;/header&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="d241" class="kx ky iq lw b gy me mb l mc md">export default App;</span></pre><h2 id="869e" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">克-奥二氏分级量表</h2><p id="fa77" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">因为我们从不同的发起者发送请求，我们得到CORS问题。简单的解决方法是安装<a class="ae mg" href="https://www.npmjs.com/package/cors" rel="noopener ugc nofollow" target="_blank"> cors </a>包，并通过简单的例子将其添加到文档中。</p><p id="48ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，带有通配符(*/*)的简单cors不起作用。我们必须为cors设置一些自定义配置，并进行飞行前选项检查。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="038e" class="kx ky iq lw b gy ma mb l mc md">// index.js</span><span id="a192" class="kx ky iq lw b gy me mb l mc md">const express = require("express")<br/>const session = require("express-session");<br/>const cors <strong class="lw ir">=</strong> require("cors")</span><span id="4ced" class="kx ky iq lw b gy me mb l mc md">const app = express()</span><span id="8972" class="kx ky iq lw b gy me mb l mc md">app.use(<br/>  session({<br/>    secret: process.env.LOGIN_SERVER_SECRET,<br/>    saveUninitialized: true,<br/>    resave: true,<br/>    cookie: {<br/>      httpOnly: false,<br/>      secure: false,<br/>    },<br/>  }),<br/>);</span><span id="bb0d" class="kx ky iq lw b gy me mb l mc md">const corsOptions <strong class="lw ir">=</strong> {<br/>  origin: /\.your.domain\.com$/,    <em class="mf">// reqexp will match all prefixes<br/>  </em>methods: "GET,HEAD,POST,PATCH,DELETE,OPTIONS",<br/>  credentials: true,                // required to pass<br/>  allowedHeaders: "Content-Type, Authorization, X-Requested-With",<br/>}</span><span id="9204" class="kx ky iq lw b gy me mb l mc md"><em class="mf">// intercept pre-flight check for all routes<br/></em>app.options('*', cors(corsOptions))</span><span id="f549" class="kx ky iq lw b gy me mb l mc md"><em class="mf">// add cors middleware to route </em><br/>app.get("/cookie", <!-- -->cors(corsOptions),<!-- --> (req, res) =&gt; {<br/>  const options = {<br/>    secure: <!-- -->false<!-- -->,<br/>    httpOnly: <!-- -->false<!-- -->,<br/>    domain: ".your.domain.com"<br/>  }</span><span id="a0fd" class="kx ky iq lw b gy me mb l mc md">return res<br/>    .cookie("cookieName", "cookieValue", options)<br/>    .status(200)<br/>    .send("cookie sent")<br/>})<br/><br/>app.listen(8080)</span></pre><p id="0363" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前端还有一个变化。因为我们的服务器现在接受带有凭证的请求，所以我们必须发送一个凭证来传递cookie。这实际上是多了一行</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="a799" class="kx ky iq lw b gy ma mb l mc md">// App.js</span><span id="9407" class="kx ky iq lw b gy me mb l mc md">import React from "react";<br/>import superagent from "superagent";<br/>import logo from "./logo.svg";<br/>import "./App.css";</span><span id="833f" class="kx ky iq lw b gy me mb l mc md">function App() {</span><span id="7fbd" class="kx ky iq lw b gy me mb l mc md">return (<br/>    &lt;div className="App"&gt;<br/>      &lt;header className="App-header"&gt;<br/>        &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br/>        &lt;p&gt;<br/>          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br/>        &lt;/p&gt;<br/>        &lt;a<br/>          className="App-link"<br/>          onClick={() =&gt;<br/>            superagent<br/>              .get("http://localhost:<!-- -->8080<!-- -->/cookie")<br/>              .<!-- -->withCredentials()           <em class="mf">// it's simple as that</em><br/>              <!-- -->.then(response =&gt; {<br/>                console.log(response);<br/>              })<br/>          }<br/>        &gt;<br/>          Get Cookie<br/>        &lt;/a&gt;<br/>      &lt;/header&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="079a" class="kx ky iq lw b gy me mb l mc md">export default App;</span></pre><h2 id="751b" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">安全cookies</h2><p id="9470" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">您可能已经注意到，我在上面的例子中使用了不安全的cookies。这仅用于开发/本地目的。如果你想在生产中使用它，你必须考虑安全性。安全cookies只能在https上工作，所以你也必须注意这一点。一个好主意是将cookies的安全性设置为依赖于NODE_ENV，这样我们在开发和部署到prod时就不必记住它。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="062a" class="kx ky iq lw b gy ma mb l mc md">// index.js</span><span id="68fc" class="kx ky iq lw b gy me mb l mc md">===</span><span id="421c" class="kx ky iq lw b gy me mb l mc md">app.use(<br/>  session({<br/>    secret: process.env.LOGIN_SERVER_SECRET,<br/>    saveUninitialized: true,<br/>    resave: true,<br/>    cookie: {<br/>      httpOnly: true,            <em class="mf">// change both to true</em><br/>      secure: true,<br/>    },<br/>  }),<br/>);</span><span id="6c9b" class="kx ky iq lw b gy me mb l mc md">===</span><span id="f778" class="kx ky iq lw b gy me mb l mc md"><em class="mf">// dynamic change</em><br/>const isCookieSecure = <br/>  process.env.NODE_ENV === "production" ? true : false;</span><span id="2331" class="kx ky iq lw b gy me mb l mc md"><em class="mf">// add cors middleware to route </em><br/>app.get("/cookie", <!-- -->cors(corsOptions),<!-- --> (req, res) =&gt; {<br/>  const options = {<br/>    secure: <!-- -->isCookieSecure<!-- -->,<br/>    httpOnly: <!-- -->isCookieSecure<!-- -->,<br/>    domain: ".your.domain.com"<br/>  }</span><span id="b284" class="kx ky iq lw b gy me mb l mc md">return res<br/>    .cookie("cookieName", "cookieValue", options)<br/>    .status(200)<br/>    .send("cookie sent")<br/>})</span></pre><p id="0d4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本就是这样。你可以添加任意多的应用程序和服务器到你的docker中，并在任何地方享受cookies。它们将在请求和响应头中自动传递。感谢大家走到这一步，希望这对某些人有用:)</p><p id="f6ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在MDN上阅读更多关于<a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>、<a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS" rel="noopener ugc nofollow" target="_blank">选项</a>和<a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" rel="noopener ugc nofollow" target="_blank">饼干</a>的信息。如有任何问题或反馈，请发表评论。谢谢🙏</p></div></div>    
</body>
</html>