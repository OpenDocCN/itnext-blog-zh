# 科特林:序列

> 原文：<https://itnext.io/kotlin-sequences-c5a3f6228eca?source=collection_archive---------3----------------------->

![](img/779ee1238466713f1edb0ed29bacaf3f.png)

Johannes Hofmann 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

当使用集合和 Kotlin 的[大量的*集合函数*](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-collection/index.html) 时，我们倾向于忘记性能，假设 Kotlin 的*集合函数*设计得很好并且执行得非常好。尽管这是完全正确的，但是当我们链接这些函数时，性能会受到影响。

## 急切地创造中间系列

这些是 Kotlin 创建的集合，用于评估一系列的*集合函数*调用。

科特林在这个调用链上创建了两个列表。一个用于*贴图*的结果，另一个用于*过滤器*的结果。这对于少量的元素是可以的，但是对于大的列表就不行了。

# 顺序

在 Kotlin 中，你可以使用*序列*来避免创建中间集合。语法非常简单。

现在我们得到了相同的结果，但性能更好。我们可以用 *asSequence()* 将任何集合转换成序列，然后用 *toList()将其反向转换。*

列表中的每个元素首先被映射，然后被过滤，相反如果我们不使用*序列，*将首先映射所有列表，然后过滤那个*映射的结果*。

> 序列类似于 Java 的 8 s 流，但是没有在多个 CPU 上并行运行流操作的选项。

## 懒惰操作

执行*序列时有两种操作。*

*   ***中间运算:*** 返回另一个序列: *map()、filter()…*
*   ***终端操作:*** 返回一个元素。一个集合，一个数字，一个对象等: *toList()，find()，count()…*

只有当*终端操作*被调用*时，中间操作*才被执行。

## 创建一个序列

直接从 lambda 中创建一个序列非常有用，而且非常容易做到。我们使用带有“种子”值的*生成序列*，在本例中为 0，在本例中为λ*{ it+1 }*。

请注意，直到调用此链的 *sum、*和*终端操作*时，才会执行前 2 行。

## 改进序列

我们可以将*集合函数*分为两组。

*   总是在整个集合数据上运行的: *map()，filter()…*
*   不需要在所有数据上运行的: *find()、any()……*

有了这两个类别，并且如前所述，在一个*序列 e* 中，列表中的每个元素在传递到下一个元素之前执行所有的链操作，我们可以假设使用*序列*可以进一步提高性能。

在上面的代码中，我们可以在第一个链中看到 map 是在整个列表中执行的。

在第二个例子中，因为它是在一个*序列上执行的，*映射*在第一个元素上执行，然后传递给*查找*函数并终止。 *find* 函数在找到 lambda 的第一个出现时返回，而它恰好是我们数组中的第一个。*

> 作为一个 Kotlin 规则，每当你对一个大集合进行链式操作时，就使用序列。在常规收集中，急切的操作会高效地执行。

# 结论

当使用*集合函数链时，*我们可以更快地编码，使用标准库函数并获得可读代码。关注我们的集合有多大，当它们很大时使用*序列*，将避免未来的性能问题。