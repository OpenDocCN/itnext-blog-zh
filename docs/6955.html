<html>
<head>
<title>How to use request-scoped tokens with caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将请求范围的令牌用于缓存</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-request-scoped-tokens-with-caching-a397ed82998a?source=collection_archive---------2-----------------------#2022-04-25">https://itnext.io/how-to-use-request-scoped-tokens-with-caching-a397ed82998a?source=collection_archive---------2-----------------------#2022-04-25</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="9899" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在我从事的一个项目中，我需要从单点登录(SSO)服务器获取令牌，以便能够与另一个服务对话。该令牌的生命周期有限，需要不时刷新。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj km"><img src="../Images/0fd216819dcc1be59767ec862d49d901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*h1QrXIcCVQxx2n7JR48f9w.png"/></div><figcaption class="ku kv gk gi gj kw kx bd b be z dk translated">100000英尺概述</figcaption></figure><p id="4a30" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这里的设置相对简单。理论上<em class="ky">我的服务</em>甚至可以在每个传入事件上点击SSO，这在测试时当然是可以的，比如用浏览器点击http端点来触发事件。<br/>在生产环境中运行代码时，情况有所不同，因为a)它给SSO服务带来了巨大的负载，而SSO服务大多数时候是共享资源。b)每次对SSO的调用都会给<em class="ky">我的服务</em>的用户增加额外的等待时间。</p><p id="1420" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在我运行于<a class="ae kz" href="https://quarkus.io" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>的服务内部，我使用CDI进一步传递令牌，如下所示</p><pre class="kn ko kp kq gu la lb lc ld aw le bi"><span id="be62" class="lf lg ir lb b gz lh li l lj lk">@Produces<br/>public Token getToken() {<br/>    Token = sso.getToken(credentials);<br/>}</span></pre><p id="1c19" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">现在，关于CDI示波器的问题开始出现了。使用@ApplicationScoped可以很好地缓存令牌，但是在令牌过期时无法使其失效。另一方面，使用@RequestScoped会在每次将令牌注入bean时调用该方法，因此它是新的，但根本没有缓存。</p><p id="9115" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">解决方案是从CDI生产流程中间接获取令牌，如下所示:</p><pre class="kn ko kp kq gu la lb lc ld aw le bi"><span id="f3cf" class="lf lg ir lb b gz lh li l lj lk">@RequestScoped<br/>@Produces<br/>public Token getToken() {<br/>    Token = getTokenInternal()<br/>}</span></pre><p id="71dd" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">然后使用Quarkus-Cache缓存令牌并使其过期:</p><pre class="kn ko kp kq gu la lb lc ld aw le bi"><span id="f4e6" class="lf lg ir lb b gz lh li l lj lk">@CacheResult(cacheName = "<strong class="lb is">token-cache</strong>")<br/>Token getTokenInternal() {<br/>    Token = sso.getToken(credentials);<br/>}</span></pre><p id="16ec" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">通过这段代码，我们告诉Quarkus缓存从SSO获得的令牌(如果远程调用没有抛出异常)。缓存令牌的时间由application.properties中的条目决定:</p><pre class="kn ko kp kq gu la lb lc ld aw le bi"><span id="19bb" class="lf lg ir lb b gz lh li l lj lk">quarkus.cache.caffeine.<strong class="lb is">token-cache</strong>.expire-after-write=PT120s</span></pre><p id="0ec2" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在这种情况下，缓存中的令牌会在2分钟后过期。当然，该值应该随着令牌的到期而调整，并且理想情况下应该稍微短一点，以防止任何竞争情况。</p><p id="9e32" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们可以解析令牌的刷新时间，然后从代码内部调优缓存，但是这个解决方案非常简单，框架完成了所有繁重的工作。</p><p id="a949" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">GitHub 上有<a class="ae kz" href="https://github.com/RedHatInsights/notifications-backend/blob/master/common/src/main/java/com/redhat/cloud/notifications/openbridge/BridgeHelper.java#L89-L120" rel="noopener ugc nofollow" target="_blank">的完整代码。</a></p></div></div>    
</body>
</html>