<html>
<head>
<title>Performance Testing for Kubernetes Autoscaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes自动缩放的性能测试</h1>
<blockquote>原文：<a href="https://itnext.io/performance-testing-for-kubernetes-autoscaling-ed6418cf6f70?source=collection_archive---------2-----------------------#2020-01-05">https://itnext.io/performance-testing-for-kubernetes-autoscaling-ed6418cf6f70?source=collection_archive---------2-----------------------#2020-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e1bad55c9fd31d24ba07344fd12308a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5tKzqLEDeABBSshBHt9-w.png"/></div></div></figure><p id="2a35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在K8s上运行应用程序已经有一年左右的时间了，但直到最近才真正利用自动伸缩。以前我们在CPU上自动伸缩(75%)，但是我们的应用从来没有接近这个限制，我们运行了太多的实例。</p><p id="cf84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CPU通常被认为是一个不好的自动伸缩指标，但是为什么会这样呢？只有当人们意识到自动缩放时，我们才注意到我们每次发布时都完全扩展了应用程序。这是因为应用程序在启动时使用了超过75%的CPU。在运行了一些性能测试之后，我们还注意到，在CPU达到75%之前，我们的应用程序的性能就会下降。</p><p id="6ccf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得出的结论是，我们希望使用每秒请求数(RPS)作为我们的自动伸缩指标。该指标由我们的应用程序通过Prometheus公开，我们使用k8s运算符，因此这些指标可用于自动缩放。我们确实遇到了一个问题，因为Spring requests metrics name以sum而不是count结尾。普罗米修斯自动标度假设所有不以计数结尾的事物都是一个量规。</p><h2 id="b2ac" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">性能试验</h2><p id="18a1" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我很想说性能测试并不是我们想要的那个词，因为它意味着我们知道它在给定场景中应该如何表现。我们实际上想知道的是服务的断点，或者它何时停止按照我们想要的方式执行。在传统部署中，您的应用程序可以使用固定数量的资源。现在，我们实际上拥有了infinite，目标是只使用当前流量所需的容量。</p><p id="9620" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们想知道应用程序的单个实例的断点，所以在我们运行测试时，应该将它缩减为一个实例。这应该在非生产环境中进行，以免影响客户。然后，我们希望向我们的应用程序发送请求。要求尽可能与生产相似。尝试重现客户可能提出的不同类型的请求，包括错误情景。慢慢地增加服务中发送的RPS，大多数性能工具都有一个斜坡特性来实现这一点。当你看到你的应用程序停止执行你想要的，那就是停止的时候了。</p><h2 id="1d26" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">配置自动缩放</h2><p id="afaa" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">现在您知道每秒钟有多少请求会破坏您的应用程序。我们将我们的服务设置为该值的75%,因为这为突发流量提供了一些喘息空间。如果您有许多实例，您可能希望根据突发流量配置文件以更高的容量运行。</p><p id="bb4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们运行独立扩展的主动主动集群。在故障转移场景中，活动集群将以125%的容量运行。这种部署依赖于故障切换不是即时的，k8s/服务有时间纵向扩展，但有一些扩展空间。</p><p id="b572" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我认为真正意义上的性能测试现在可以完成了，因为我们有了一个应用程序应该能够处理的值。我建议在您的管道中进行一次性能测试，就好像您的应用程序的性能发生了变化，您需要更新您的自动伸缩配置。您的测试应该有一个断言，因为它是一个检查响应时间的<strong class="kd iu">测试</strong>，或者是一个您认为重要的指标。</p><h2 id="0938" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">技巧</h2><p id="22cf" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">在发现Spring和Node/Express应用程序的限制时，我注意到一件事，性能下降是突然发生的。这是我认为你不应该使用其他指标的原因之一。当这些指标显示出迹象时，为时已晚，您的应用程序已经失败了。</p><p id="2817" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想喊出<a class="ae lx" href="https://artillery.io/" rel="noopener ugc nofollow" target="_blank">cannon . io</a>，因为它是一个非常简单的性能测试工具，使用YAML进行配置。cannon的一个缺点是它是用Node编写的，所以是单线程的。我们的一些应用程序需要启动多个进程。另一个让炮兵获得更多RPS的方法是利用连接池。</p></div></div>    
</body>
</html>