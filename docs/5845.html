<html>
<head>
<title>Secures RESTful APIs with Quarkus OIDC and Auth0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用夸库斯·OIDC和Auth0保护RESTful APIs</h1>
<blockquote>原文：<a href="https://itnext.io/secures-restful-apis-with-quarkus-oidc-and-auth0-643475a9710c?source=collection_archive---------0-----------------------#2021-06-09">https://itnext.io/secures-restful-apis-with-quarkus-oidc-and-auth0-643475a9710c?source=collection_archive---------0-----------------------#2021-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0411" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Quarkus非常支持OAuth 2和OIDC协议。在本帖中，我们将探讨如何用夸库斯·OIDC和Auth0保护RESTful APIs。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2b4b3775d62080938b4239299a3550db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8eToBkiLUtTgQeiIbxXIQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@linglivestolaugh?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">谭曼玲</a>在<a class="ae lb" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="7697" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://www.quarkus.io" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>是众所周知的<em class="lc">超音速亚原子Java框架</em>来构建Kubernetes友好的云原生应用。在之前的文章<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/secures-rest-apis-with-spring-security-5-and-auth0-41d579ca1e27">中，我们已经讨论了如何用Spring Security和Auth0保护RESTful APIs，我们将用Quarkus OIDC扩展实现相同的功能。</a></p><p id="b2ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入<a class="ae lb" href="https://code.quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus开始编码</a>页面，确保已经添加了这些扩展:<em class="lc"> oidc </em>，<em class="lc"> resteasy </em>，<em class="lc"> resteasy-jackson </em>，<em class="lc"> hibernate-validator </em>，<em class="lc"> hibernate-orm-panache </em>，<em class="lc"> jdbc-postgresql </em>。然后像往常一样生成一个我们在<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/building-graphql-apis-with-quarkus-dbbf23f897df">前帖</a>中做过的项目骨架。将源代码导入您的IDE。</p><p id="a641" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开项目<em class="lc"> pom.xml </em>文件你应该会看到下面的依赖项。添加一个额外的Lombok依赖项来清理POJOs。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="4b73" class="li lj iq le b gy lk ll l lm ln">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-oidc&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-resteasy-jackson&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-hibernate-validator&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span><span id="3589" class="li lj iq le b gy lo ll l lm ln">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-arc&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span><span id="0828" class="li lj iq le b gy lo ll l lm ln">&lt;!-- Erase getters and setters --&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>    &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>    &lt;version&gt;1.18.20&lt;/version&gt;<br/>    &lt;optional&gt;true&lt;/optional&gt;<br/>&lt;/dependency&gt;</span></pre><p id="c722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将关注如何整合夸库斯·OIDC和Auth0。我们不打算解释RESTful APIs的开发进度，源代码的细节与我们在<a class="ae lb" href="https://hantsy.medium.com/kickstart-your-first-quarkus-application-cde54f469973" rel="noopener">我的Quarkus简介</a>中讨论过的非常相似。在进入下一步之前，请从我的github 查看一份<a class="ae lb" href="https://github.com/hantsy/quarkus-auth0-sample" rel="noopener ugc nofollow" target="_blank">这篇文章的源代码，并亲自探索一下。</a></p><p id="ed44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与Spring Security不同，Quarkus Security不遵循命名规则(<code class="fe lp lq lr le b">resourceserver</code>、<code class="fe lp lq lr le b">client</code>和<code class="fe lp lq lr le b">authorizationserver</code>等)。)对配置属性进行分类。Quarkus将OAuth2/OIDC配置属性绑定到功能名称(如<code class="fe lp lq lr le b">quarkus.oidc.xxx</code>、<code class="fe lp lq lr le b">quarkus.oidc-flow.xxx</code>等)，当你第一次来到Quarkus世界时，会感到困惑。</p><p id="7bd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数官方Quarkus OAuth2和OIDC示例和指南都依赖于Redhat的开源OAuth2/OIDC兼容授权服务器。如果您非常了解OAuth2/OIDC协议，那么转向Auth0并不困难。</p><p id="5742" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了让夸克鲁斯·OIDC与Auth0一起工作，在<em class="lc">应用程序中添加以下配置。</em></p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="2113" class="li lj iq le b gy lk ll l lm ln"># Oidc auth config for resource server<br/>quarkus.oidc.client-id=backend-api<br/>quarkus.oidc.auth-server-url=https://dev-ese8241b.us.auth0.com/<br/>quarkus.oidc.token.audience=https://hantsy.github.io/api<br/>#quarkus.oidc.application-type=service</span></pre><p id="0fee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认<em class="lc">quar kus . oidc . application-type</em>为<em class="lc"> service </em>，用于标识应用类型，<em class="lc"> service </em>相当于Spring Security中的<em class="lc"> resourceserver </em>。</p><blockquote class="ls lt lu"><p id="d2c0" class="jn jo lc jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated"><em class="iq">注意:</em> quarkus.oidc.client-id <em class="iq">必须提供，尽管这不是OAuth2 </em> client <em class="iq">角色。</em></p></blockquote><p id="cf14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当解析JWT令牌时，如果授权服务器支持OIDC配置协议，夸尔库斯·OIDC也可以从基本的<em class="lc"> auth-server-url </em>值中自动发现<em class="lc"> jwt集合url </em>。</p><p id="1916" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当提供了一个令牌受众时，Quarkus会自动验证它。您也可以自己验证JWT令牌中的受众或其他项目。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="ef41" class="li lj iq le b gy lk ll l lm ln">//@Provider<br/>public class AudienceValidator implements ContainerRequestFilter {</span><span id="66fb" class="li lj iq le b gy lo ll l lm ln">    @Inject<br/>    OidcConfigurationMetadata configMetadata;</span><span id="5645" class="li lj iq le b gy lo ll l lm ln">    @Inject<br/>    JsonWebToken jwt;</span><span id="2081" class="li lj iq le b gy lo ll l lm ln">    @Inject<br/>    SecurityIdentity identity;</span><span id="72c4" class="li lj iq le b gy lo ll l lm ln">    public void filter(ContainerRequestContext requestContext) {<br/>        String aud = configMetadata.get("audience");//.replace("{tenant-id}", identity.getAttribute("tenant-id"));<br/>        if (!jwt.getAudience().contains(aud)) {<br/>            requestContext.abortWith(Response.status(401).build());<br/>        }<br/>    }<br/>}</span></pre><p id="ab64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，<code class="fe lp lq lr le b">OidcConfigurationMetadata</code>是这个应用程序的OIDC配置属性。<code class="fe lp lq lr le b">JsonWebToken</code>是被解析的令牌声明。<code class="fe lp lq lr le b">SecurityIdenity</code>是一个通用的安全上下文对象，用于封装用户主体和角色，类似于JaxRS、EJB等公司的传统Jakarta EE <code class="fe lp lq lr le b">SecurityContext</code> API。</p><p id="a71d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了保护API并使一些API只对认证用户可用，Quarkus Security提供了一个<code class="fe lp lq lr le b">@Authenticated</code>注释。以下是对<code class="fe lp lq lr le b">PostResource</code>的修改版本，其中我们在所有<em class="lc">写</em>操作上添加了<code class="fe lp lq lr le b">@Authenticated</code>注释以保护资源。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="2b88" class="li lj iq le b gy lk ll l lm ln">@Path("/posts")<br/>@RequestScoped<br/>public class PostResource {<br/>    private final static Logger LOGGER = Logger.getLogger(PostResource.class.getName());</span><span id="2323" class="li lj iq le b gy lo ll l lm ln">    private final PostRepository posts;</span><span id="3352" class="li lj iq le b gy lo ll l lm ln">    @Context<br/>    UriInfo uriInfo;</span><span id="8447" class="li lj iq le b gy lo ll l lm ln">    @Inject<br/>    public PostResource(PostRepository posts) {<br/>        this.posts = posts;<br/>    }</span><span id="2778" class="li lj iq le b gy lo ll l lm ln">    @Path("count")<br/>    @GET<br/>    @Produces(MediaType.APPLICATION_JSON)<br/>    public Response countAllPosts(@QueryParam("q") String q) {<br/>        return ok(this.posts.countByKeyword(q)).build();<br/>    }</span><span id="7d10" class="li lj iq le b gy lo ll l lm ln">    @GET<br/>    @Produces(MediaType.APPLICATION_JSON)<br/>    public Response getAllPosts(<br/>            @QueryParam("q") String q,<br/>            @QueryParam("offset") @DefaultValue("0") int offset,<br/>            @QueryParam("limit") @DefaultValue("10") int limit</span><span id="fda9" class="li lj iq le b gy lo ll l lm ln">    ) {<br/>        return ok(this.posts.findByKeyword(q, offset, limit)).build();<br/>    }</span><span id="7baf" class="li lj iq le b gy lo ll l lm ln">    @POST<br/>    @Consumes(MediaType.APPLICATION_JSON)<br/>    @Authenticated<br/>    public Response savePost(@Valid CreatePostCommand post) {<br/>        Post saved = this.posts.save(Post.builder().title(post.title()).content(post.content()).build());<br/>        return created(<br/>                uriInfo.getBaseUriBuilder()<br/>                        .path("/posts/{id}")<br/>                        .build(saved.getId())<br/>        ).build();<br/>    }</span><span id="f5d6" class="li lj iq le b gy lo ll l lm ln">    @Path("{id}")<br/>    @GET<br/>    @Produces(MediaType.APPLICATION_JSON)<br/>    public Response getPostById(@PathParam("id") final Long id) {<br/>        return this.posts.findByIdOptional(id)<br/>                .map(post -&gt; ok(post).build())<br/>                .orElse(status(NOT_FOUND).build());<br/>    }</span><span id="3d68" class="li lj iq le b gy lo ll l lm ln">    @Path("{id}")<br/>    @PUT<br/>    @Consumes(MediaType.APPLICATION_JSON)<br/>    @Authenticated<br/>    public Response updatePost(@PathParam("id") final Long id, @Valid UpdatePostCommand post) {<br/>        return this.posts.findByIdOptional(id)<br/>                .map(existed -&gt; {<br/>                    existed.setTitle(post.title());<br/>                    existed.setContent(post.content());</span><span id="9d6d" class="li lj iq le b gy lo ll l lm ln">                    Post saved = this.posts.save(existed);<br/>                    return noContent().build();<br/>                })<br/>                .orElse(status(NOT_FOUND).build());<br/>    }</span><span id="138f" class="li lj iq le b gy lo ll l lm ln">    @Path("{id}/status")<br/>    @PUT<br/>    @Consumes(MediaType.APPLICATION_JSON)<br/>    @Authenticated<br/>    public Response updatePostStatus(@PathParam("id") final Long id, @Valid UpdatePostStatusCommand status) {<br/>        return this.posts.findByIdOptional(id)<br/>                .map(existed -&gt; {<br/>                    existed.setStatus(status.status());<br/>                    Post saved = this.posts.save(existed);<br/>                    return noContent().build();<br/>                })<br/>                .orElse(status(NOT_FOUND).build());<br/>    }</span><span id="03ef" class="li lj iq le b gy lo ll l lm ln">    @Path("{id}")<br/>    @DELETE<br/>    @Authenticated<br/>    public Response deletePost(@PathParam("id") final Long id) {<br/>        this.posts.deleteById(id);<br/>        return noContent().build();<br/>    }</span><span id="be77" class="li lj iq le b gy lo ll l lm ln">}</span></pre><p id="b95e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要手动测试应用程序，请登录auth0仪表板，按照我们在之前的Spring Security和Auth0 integration post 的<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/secures-rest-apis-with-spring-security-5-and-auth0-41d579ca1e27">中介绍的步骤，通过Auth0提供的<em class="lc">测试应用程序</em>获得一个令牌，然后使用<code class="fe lp lq lr le b">curl</code>命令或类似Postman的工具来访问受保护的API。</a></p><p id="da13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，Quarkus测试框架没有Spring灵活。在Spring生态系统中，Spring Security提供了测试工具来模拟单元测试中的MVC和JWT解码，不幸的是Quarkus没有提供这样一个简单的助手。但是有一些可能的方法来测试<em class="lc">服务</em>类型应用程序的安全性。</p><p id="20e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="lc"> pom.xml </em>文件中添加以下依赖项。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="fa6d" class="li lj iq le b gy lk ll l lm ln">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-test-security&lt;/artifactId&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span><span id="9b66" class="li lj iq le b gy lo ll l lm ln">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-elytron-security-properties-file-deployment&lt;/artifactId&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="b6da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了集中测试Quarkus应用程序中的业务逻辑，您可以在一个属性文件中设置嵌入式用户来替换数据库中的真实用户，并使Http基本身份验证能够绕过JWT令牌授权。</p><p id="3d43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个<em class="lc">src/test/resources/application-embedded-users . properties</em>文件来设置嵌入式用户并启用<em class="lc"> basic </em> auth。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="a3eb" class="li lj iq le b gy lk ll l lm ln">quarkus.security.users.embedded.enabled=true<br/>quarkus.security.users.embedded.plain-text=true<br/>quarkus.security.users.embedded.users.alice=password<br/>quarkus.security.users.embedded.roles.alice=user<br/>quarkus.security.users.embedded.users.admin=password<br/>quarkus.security.users.embedded.roles.admin=admin<br/>quarkus.http.auth.basic=true<br/>quarkus.oidc.enabled=false</span></pre><p id="835c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个<code class="fe lp lq lr le b">QuarkusTestProfile</code>来为一些特殊的目的对测试资源进行分类。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="25a2" class="li lj iq le b gy lk ll l lm ln">public class PropertiesFileEmbeddedUsersProfile implements QuarkusTestProfile {<br/>    @Override<br/>    public String getConfigProfile() {<br/>        return "embedded-users";<br/>    }<br/>}</span></pre><p id="ef52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个简单的测试，通过<code class="fe lp lq lr le b">@TestProfile</code>注释来应用这个测试概要。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="3679" class="li lj iq le b gy lk ll l lm ln">@QuarkusTest<br/>@TestHTTPEndpoint(PostResource.class)<br/>@TestProfile(PropertiesFileEmbeddedUsersProfile.class)<br/>public class TestSecurityLazyAuthTest {<br/></span><span id="a8c9" class="li lj iq le b gy lo ll l lm ln">    @Test<br/>    public void testGetAllPostsWithoutAuth() {<br/>        //@formatter:off<br/>        given()<br/>            .accept(ContentType.JSON)<br/>        .when()<br/>            .get("")<br/>        .then()<br/>            .statusCode(200);<br/>        //@formatter:on<br/>    }</span><span id="65ca" class="li lj iq le b gy lo ll l lm ln">    @Test<br/>    //@TestSecurity(authorizationEnabled = false)<br/>    public void testCreatPostsWithoutAuth() {<br/>        //@formatter:off<br/>        given()<br/>            .body(Post.builder().title("test title").content("test content").build())<br/>            .contentType(ContentType.JSON)<br/>        .when()<br/>            .post("")<br/>        .then()<br/>            .statusCode(401);<br/>        //@formatter:on<br/>    }</span><span id="19d6" class="li lj iq le b gy lo ll l lm ln">    @Test<br/>    @TestSecurity(user = "alice", roles = "user")<br/>    public void testCreatPostsWithAuth() {<br/>        //@formatter:off<br/>        given()<br/>            .body(Post.builder().title("test title").content("test content").build())<br/>            .contentType(ContentType.JSON)<br/>        .when()<br/>            .post("")<br/>        .then()<br/>            .statusCode(201);<br/>        //@formatter:on<br/>    }<br/>}</span></pre><p id="d665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，您可以生成本地RSA公钥/私钥对来执行JWT令牌验证过程。</p><p id="2f1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用OpenSSL生成密钥。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="f7b9" class="li lj iq le b gy lk ll l lm ln">openssl genrsa -out rsaPrivateKey.pem 2048<br/>openssl rsa -pubout -in rsaPrivateKey.pem -out publicKey.pem</span></pre><p id="59b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要一个额外的步骤来生成私钥，以便将其转换成PKCS#8格式。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="2efb" class="li lj iq le b gy lk ll l lm ln">openssl pkcs8 -topk8 -nocrypt -inform pem -in rsaPrivateKey.pem -outform pem -out privateKey.pem</span></pre><p id="9015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个<code class="fe lp lq lr le b">TestProfile</code>类来设置使用本地公钥来验证JWT令牌的属性。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="20e3" class="li lj iq le b gy lk ll l lm ln">public class InlinedPublicKeyProfile implements QuarkusTestProfile {<br/>    @Override<br/>    public Map&lt;String, String&gt; getConfigOverrides() {<br/>        return Map.of(<br/>                "quarkus.oidc.client-id", "test",<br/>                "quarkus.oidc.public-key", "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzcAl1DgYnAkpYelL4lxl" +<br/>                        "csdX0dHj92g+pMyjzWE3nzSV8i726lTJtg5kxaJyv8epEOAiMcelFk0v+9HMOPla" +<br/>                        "6/pgkEHE5PPyaHlgegDIzge2RQLidDwl8IWBksUkfDWjQk+JfrEPJxrES4OXUOyp" +<br/>                        "mO/XsNIGcbZfopi1Ook7XIjBPohuiHBcp8Fw1NVzaP7EvyYzxcxoIpa4Y/knF1Sa" +<br/>                        "FIBuMmA/lE7PHKlBqcsS1EXkyI1TBGcdH+VWhUvsDVehKSlZoUCE6XrWY3M/xzyb" +<br/>                        "gN+C9KPln+fQZ42Fnqo6PpD++NWRo8vgWxsMsqb+nltEQADfd8CFEuLt1BvObh8N" +<br/>                        "fQIDAQAB",<br/>                "quarkus.oidc.token.audience", "https://service.example.com",<br/>                "smallrye.jwt.sign.key-location", "privateKey.jwk"<br/>        );<br/>    }</span><span id="3f11" class="li lj iq le b gy lo ll l lm ln">}</span></pre><p id="4b07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在编写一个测试来验证它。<code class="fe lp lq lr le b">getAccessToken</code>使用我们在上一步中生成的私钥生成一个令牌。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="9833" class="li lj iq le b gy lk ll l lm ln">@QuarkusTest<br/>@TestProfile(InlinedPublicKeyProfile.class)<br/>public class InlinedPublicKeyAuthorizationTest {</span><span id="3e99" class="li lj iq le b gy lo ll l lm ln">    @Test<br/>    public void testBearerToken() {<br/>        //@formatter:off<br/>        given()<br/>            .auth().oauth2(getAccessToken("alice", Set.of("user")))<br/>            .body(new CreatePostCommand("test title", "test content"))<br/>            .contentType(ContentType.JSON)<br/>        .when()<br/>            .post("/posts")<br/>        .then()<br/>            .statusCode(201);<br/>        //@formatter:on<br/>    }</span><span id="bd44" class="li lj iq le b gy lo ll l lm ln">    //<br/>    private String getAccessToken(String userName, Set&lt;String&gt; groups) {<br/>        return Jwt.preferredUserName(userName)<br/>                .claim("scope", "write:posts")<br/>                .groups(groups)<br/>                .issuer("https://server.example.com")<br/>                .audience("https://service.example.com")<br/>                .jws()<br/>                .keyId("1")<br/>                .sign("privateKey.jwk");<br/>    }<br/>}</span></pre><p id="e868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们在测试中使用了定制的私有/公共密钥对，通过jwk set url从远程授权服务器获取公共密钥。</p><p id="f06c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把所有这些放在一起，运行应用程序。</p><p id="8ee5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从github获取<a class="ae lb" href="https://github.com/hantsy/quarkus-auth0-sample" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><p id="12a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">启动应用程序。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="3ea1" class="li lj iq le b gy lk ll l lm ln">docker compose up postgresql<br/>mvn clean quarkus:dev</span></pre><p id="2fdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从<a class="ae lb" href="https://github.com/hantsy/spring-security-auth0-sample/tree/master/ui" rel="noopener ugc nofollow" target="_blank">hantsy/spring-security-auth0-sample</a>中复制ui代码，我们已经在<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/integrating-auth0-into-your-angular-applications-42fabef31f3e">中将auth 0集成到您的Angular应用</a>中。这是一个用Angular 12编写的SPA应用程序。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="64f3" class="li lj iq le b gy lk ll l lm ln">npm install<br/>npm run start</span></pre><p id="1f23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开浏览器并导航至<a class="ae lb" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200 </a>。登录并点击<em class="lc">博客</em>菜单项，你会看到来自后端<em class="lc"> API </em>应用的数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ly"><img src="../Images/ffcb39f572732840a1fb048c4e343cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rH5z16Wd3GW_F2pX.png"/></div></div></figure></div></div>    
</body>
</html>