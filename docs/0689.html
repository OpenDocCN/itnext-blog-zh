<html>
<head>
<title>From express to Koa</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从快车到Koa</h1>
<blockquote>原文：<a href="https://itnext.io/from-express-to-koa-f3be4afdfd39?source=collection_archive---------2-----------------------#2018-05-08">https://itnext.io/from-express-to-koa-f3be4afdfd39?source=collection_archive---------2-----------------------#2018-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f7a137b292f6c1a5b74e5d7ab6a4e10c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5vF5YWfZPgkSz6paVDN33w.png"/></div></div></figure><p id="1789" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">nodeJs web框架有几个，最流行的一个是<a class="ae kw" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> express.js </a>。我想解释一下为什么在写服务器代码时，我决定从<em class="kx"> express.js </em>转移到<a class="ae kw" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> koa </a>。</p><p id="25fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要理解这篇文章，您应该了解:</p><ul class=""><li id="bb47" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated"><a class="ae kw" href="https://developer.mozilla.org/bm/docs/Web/JavaScript" rel="noopener ugc nofollow" target="_blank">JavaScript</a><br/>–什么是<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a><br/>–如何用<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> async/await </a>写承诺</li><li id="49ff" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated"><a class="ae kw" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">nodeJs</a><br/>——如何搭建一个简单的<a class="ae kw" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank">express . js</a>server<br/>——什么是<a class="ae kw" href="https://expressjs.com/en/guide/writing-middleware.html" rel="noopener ugc nofollow" target="_blank"> express中间件</a></li></ul><h1 id="ead9" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="4ba6" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">随着NodeJS版本7的出现，出现了对 <code class="fe mp mq mr ms b"><a class="ae kw" href="http://node.green/#ES2017-features-async-functions" rel="noopener ugc nofollow" target="_blank">async/await</a></code> <a class="ae kw" href="http://node.green/#ES2017-features-async-functions" rel="noopener ugc nofollow" target="_blank">函数</a>的<a class="ae kw" href="http://node.green/#ES2017-features-async-functions" rel="noopener ugc nofollow" target="_blank">支持。Koa只是和他们玩得更自然，➡️使用Koa。</a></p><h1 id="7321" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">表达</h1><p id="9095" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我们将编写一条简单的路线，它将:</p><ol class=""><li id="f95c" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv mt le lf lg bi translated">查询数据库获取一些资料</li><li id="7034" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv mt le lf lg bi translated">将结果传递给第二个数据库调用</li><li id="bd6f" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv mt le lf lg bi translated">然后发送最终结果作为响应</li></ol><h2 id="af80" class="mu ln iq bd lo mv mw dn ls mx my dp lw kj mz na ma kn nb nc me kr nd ne mi nf bi translated">节点样式回调</h2><p id="5cf1" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">这里我们将使用nodeJs风格的回调签名:<br/>一个回调函数，以<code class="fe mp mq mr ms b">error</code>为第一个自变量&amp; <code class="fe mp mq mr ms b">result</code>为第二个自变量。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9b30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止一切顺利。幸运的是，我们的数据库对象也支持承诺。</p><h2 id="bf0a" class="mu ln iq bd lo mv mw dn ls mx my dp lw kj mz na ma kn nb nc me kr nd ne mi nf bi translated">承诺</h2><p id="0b9f" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">下面的代码与上面的代码一样，但是:</p><ul class=""><li id="3244" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">我们可以简化我们的代码</li><li id="758c" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">我们不再复制错误控制</li><li id="276d" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated"><code class="fe mp mq mr ms b">catch</code>不会处理同步错误</li></ul><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3507" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止一切顺利。幸运的是，因为我们使用nodeJS &gt; = 7，所以我们可以使用async/await。</p><h2 id="f923" class="mu ln iq bd lo mv mw dn ls mx my dp lw kj mz na ma kn nb nc me kr nd ne mi nf bi translated">异步/等待</h2><p id="9c49" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">下面的代码与上面的代码一样，但是:</p><ul class=""><li id="eb63" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">我们有一个不太麻烦的代码</li><li id="c0aa" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">我们仍然没有复制错误控制</li><li id="3475" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">任何在<code class="fe mp mq mr ms b">try/catch</code>内部的错误都会被处理</li></ul><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5efc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止一切顺利。但是如果我们增加更多的路线，情况会变得更糟:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9ce0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你看到了吗？<br/>我们写了一遍又一遍<code class="fe mp mq mr ms b">try {} catch(error){ next(error) }</code>没什么大不了的，但是结尾很无聊……</p><p id="ba47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但幸运的是，我们可以为此编写一个包装函数！</p><h2 id="ff31" class="mu ln iq bd lo mv mw dn ls mx my dp lw kj mz na ma kn nb nc me kr nd ne mi nf bi translated">更好的异步/等待</h2><p id="3162" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">因此，让我们编写我们的包装器:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6965" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一篇更详细的文章是由<a class="ae kw" href="https://medium.com/@Abazhenov/using-async-await-in-express-with-node-8-b8af872c0016" rel="noopener">亚历克斯·巴泽诺夫</a>撰写的</p><p id="286c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，让我们在代码中使用它:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="88ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止一切顺利。但是，我们仍然需要编写一些样板文件来处理这个问题…</p><p id="409d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">KOA来了！</p><h1 id="7c74" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">寇阿相思树</h1><h2 id="5303" class="mu ln iq bd lo mv mw dn ls mx my dp lw kj mz na ma kn nb nc me kr nd ne mi nf bi translated">什么是KOA？</h2><p id="ee00" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">简而言之，是express.js背后的同一个团队使用JavaScript语言编写了一个web框架。<br/> <strong class="ka ir">它的核心是使用async/await </strong> <br/>你可以在这里找到<a class="ae kw" href="https://koajs.com/#introduction" rel="noopener ugc nofollow" target="_blank">的完整介绍</a></p><p id="e6dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用Koa设置服务器非常简单。<br/>对于路由，由于默认不提供任何东西，我们将使用<a class="ae kw" href="https://www.npmjs.com/package/koa-router" rel="noopener ugc nofollow" target="_blank"> koa-router </a></p><h2 id="8f19" class="mu ln iq bd lo mv mw dn ls mx my dp lw kj mz na ma kn nb nc me kr nd ne mi nf bi translated">设置路由器和错误中间件</h2><p id="501c" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">这段代码应该足够了:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="1cbf" class="mu ln iq bd lo mv mw dn ls mx my dp lw kj mz na ma kn nb nc me kr nd ne mi nf bi translated">书写我们的路线</h2><p id="eba8" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">这就是我们编写应用程序代码的方式:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="71cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我看来更瘦😀</p><ul class=""><li id="2813" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">没有重复的<code class="fe mp mq mr ms b">try/catch</code></li><li id="f6ed" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">不需要编写异步中间件</li><li id="1c68" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">不需要将我们所有的路由处理器都打包到那个中间件中</li><li id="2cbd" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">处理同步/异步错误</li></ul><h1 id="fc0b" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">关于Koa生态系统</h1><p id="7cd0" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">目前，Koa还没有express.js那么多的中间件。</p><p id="ee3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是<em class="kx">必须有</em>中间件已经在这里了，编写自己的中间件相当容易。<br/>我从来没有发现自己在Koa身上无法达到自己想要的情况。</p><p id="ce4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以如果你喜欢<code class="fe mp mq mr ms b">async/await</code>代码风格，给Koa一个尝试🙂</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="1154" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">原载于</em><a class="ae kw" href="https://hiswe.github.io/2018/07-from-express-to-koa/" rel="noopener ugc nofollow" target="_blank"><em class="kx">hiswe . github . io</em></a><em class="kx">。</em></p></div></div>    
</body>
</html>