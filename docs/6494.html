<html>
<head>
<title>Kick start your Electron development with BrowserView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BrowserView启动您的电子开发</h1>
<blockquote>原文：<a href="https://itnext.io/kick-start-your-electron-development-with-browserview-4d1044e69088?source=collection_archive---------1-----------------------#2021-12-03">https://itnext.io/kick-start-your-electron-development-with-browserview-4d1044e69088?source=collection_archive---------1-----------------------#2021-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/69bb2d641a190c6760931f7afa266a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFw5t31PutsatDTiI30SkQ.png"/></div></div></figure><h1 id="ff9f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="6521" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用<code class="fe lu lv lw lx b">&lt;webview&gt;</code>标签和<code class="fe lu lv lw lx b">nodeIntegration</code>电子标签已经变得很流行，但是它们也带来了深层次的问题，比如安全问题和铬依赖。所以它正迁移到<code class="fe lu lv lw lx b">BrowserView</code>去解决这些问题。让我们看看我们能用它做什么。</p><h1 id="71d6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">开始之前</h1><p id="0705" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">事先准备好<code class="fe lu lv lw lx b">main.js</code>和<code class="fe lu lv lw lx b">index.html</code>，以便正式快速启动。本文主要关注这两个脚本如何相互作用。</p><div class="ly lz gp gr ma mb"><a href="https://www.electronjs.org/docs/latest/tutorial/quick-start" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd ir gy z fp mg fr fs mh fu fw ip bi translated">快速启动|电子</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">本指南将引导你在电子版中创建一个准系统Hello World应用程序，类似于…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">www.electronjs.org</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp jw mb"/></div></div></a></div><h1 id="c89c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">盒子里有什么？</h1><p id="db3c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当你用电子制作一个应用程序时，主要有三个部分。</p><ul class=""><li id="1ae7" class="mq mr iq ky b kz ms ld mt lh mu ll mv lp mw lt mx my mz na bi translated">主流程(<code class="fe lu lv lw lx b">main.js</code>)</li><li id="3c1c" class="mq mr iq ky b kz nb ld nc lh nd ll ne lp nf lt mx my mz na bi translated"><code class="fe lu lv lw lx b">preload.js</code></li><li id="528b" class="mq mr iq ky b kz nb ld nc lh nd ll ne lp nf lt mx my mz na bi translated">渲染器进程(<code class="fe lu lv lw lx b">index.html</code>)</li></ul><p id="9271" class="pw-post-body-paragraph kw kx iq ky b kz ms lb lc ld mt lf lg lh ng lj lk ll nh ln lo lp ni lr ls lt ij bi translated"><code class="fe lu lv lw lx b">main.js</code>在托管Node.js的主进程中运行，管理应用的生命周期、渲染器进程等。你可以使用Node.js的全部特性，但是没有<code class="fe lu lv lw lx b">window</code>或<code class="fe lu lv lw lx b">document</code>对象。</p><p id="947c" class="pw-post-body-paragraph kw kx iq ky b kz ms lb lc ld mt lf lg lh ng lj lk ll nh ln lo lp ni lr ls lt ij bi translated">渲染器进程通过<code class="fe lu lv lw lx b">new BrowserWindow</code>从主进程创建。它是一个独立于主进程的浏览器进程。为了连接这两个进程，您可以附加preload.js，它在加载渲染器之前运行。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/dd8b6a35a07135786841e8cc46b1bf1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*smtVOQlhcaCp6V0qPKjIzw.png"/></div></figure><p id="82a9" class="pw-post-body-paragraph kw kx iq ky b kz ms lb lc ld mt lf lg lh ng lj lk ll nh ln lo lp ni lr ls lt ij bi translated">我如上所述是因为<code class="fe lu lv lw lx b">preload.js</code>是在渲染器进程中执行的。</p><blockquote class="no np nq"><p id="6561" class="kw kx nr ky b kz ms lb lc ld mt lf lg ns ng lj lk nt nh ln lo nu ni lr ls lt ij bi translated">预加载脚本包含在其web内容开始加载之前在渲染器进程中执行的代码。</p></blockquote><p id="63bf" class="pw-post-body-paragraph kw kx iq ky b kz ms lb lc ld mt lf lg lh ng lj lk ll nh ln lo lp ni lr ls lt ij bi translated">详见<a class="ae nv" href="https://www.electronjs.org/docs/latest/tutorial/process-model" rel="noopener ugc nofollow" target="_blank">官方流程模型页面</a>。</p><h1 id="9983" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">创建渲染器过程</h1><p id="27c7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要使用<code class="fe lu lv lw lx b">preload.js</code>启动渲染过程，必须按如下方式传递<code class="fe lu lv lw lx b">webPreferences</code>选项。</p><pre class="nk nl nm nn gt nw lx nx ny aw nz bi"><span id="f60d" class="oa jz iq lx b gy ob oc l od oe">app.whenReady().then(async () =&gt; {<br/>  mainWindow = new BrowserWindow({<br/>      webPreferences: {<br/>        nodeIntegration: false,<br/>        preload: path.join(__dirname, 'preload.js')<br/>      }<br/>  });</span><span id="a01e" class="oa jz iq lx b gy of oc l od oe">  mainWindow.loadFile('index.html')</span><span id="99ec" class="oa jz iq lx b gy of oc l od oe">  mainWindow.on('closed', () =&gt; {<br/>    mainWindow = null;<br/>  });<br/>});</span></pre><h1 id="d24e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">preload.js怎么办？</h1><p id="a20e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在<code class="fe lu lv lw lx b">preload.js</code>中，您可以在渲染器进程运行之前访问<code class="fe lu lv lw lx b">window</code>或<code class="fe lu lv lw lx b">document</code>对象。</p><p id="7e56" class="pw-post-body-paragraph kw kx iq ky b kz ms lb lc ld mt lf lg lh ng lj lk ll nh ln lo lp ni lr ls lt ij bi translated">要定义<code class="fe lu lv lw lx b">window</code>对象的特殊属性，应使用<code class="fe lu lv lw lx b">exposeInMainWorld</code>。您可以查看<a class="ae nv" href="https://www.electronjs.org/docs/latest/tutorial/context-isolation" rel="noopener ugc nofollow" target="_blank">官方上下文隔离页面</a>了解更多详情。它被命名为“在主世界中公开”,但与主进程无关。</p><p id="23ef" class="pw-post-body-paragraph kw kx iq ky b kz ms lb lc ld mt lf lg lh ng lj lk ll nh ln lo lp ni lr ls lt ij bi translated">这里有一个例子，</p><pre class="nk nl nm nn gt nw lx nx ny aw nz bi"><span id="7ff7" class="oa jz iq lx b gy ob oc l od oe">const { contextBridge, ipcRenderer } = require('electron')</span><span id="697e" class="oa jz iq lx b gy of oc l od oe">contextBridge.exposeInMainWorld(<br/>  'electron',<br/>  {<br/>    sendMessage: (body) =&gt; ipcRenderer.send('message', body),<br/>    onResponse: (listener) =&gt;<br/>      ipcRenderer.on(<br/>        'response',<br/>        (event, resp) =&gt; listener(resp)<br/>      )<br/>  }<br/>);</span></pre><h1 id="8e6f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">渲染器进程中的消息传递</h1><p id="1900" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要向主进程发送消息，可以使用<code class="fe lu lv lw lx b">preload.js</code>中定义的函数，如下所示:</p><pre class="nk nl nm nn gt nw lx nx ny aw nz bi"><span id="0463" class="oa jz iq lx b gy ob oc l od oe">window.electron.sendMessage({ message: 'Hello!' });</span></pre><p id="d1a3" class="pw-post-body-paragraph kw kx iq ky b kz ms lb lc ld mt lf lg lh ng lj lk ll nh ln lo lp ni lr ls lt ij bi translated">同样，您可以通过处理函数来接收主进程的响应，</p><pre class="nk nl nm nn gt nw lx nx ny aw nz bi"><span id="f88d" class="oa jz iq lx b gy ob oc l od oe">window.electron.onResponse(({ message }) =&gt; {<br/>  document.querySelector('#response').innerText = message;<br/>});</span></pre><h1 id="0d8f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">主进程中的消息传递</h1><p id="9f2c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">主进程可以通过<code class="fe lu lv lw lx b">webContents.send</code>向渲染器内容发送消息，</p><pre class="nk nl nm nn gt nw lx nx ny aw nz bi"><span id="6225" class="oa jz iq lx b gy ob oc l od oe">mainWindow.webContents.send('response', { message: 'Greeting!' });</span></pre><p id="c1d8" class="pw-post-body-paragraph kw kx iq ky b kz ms lb lc ld mt lf lg lh ng lj lk ll nh ln lo lp ni lr ls lt ij bi translated">要接收来自渲染进程的消息，<code class="fe lu lv lw lx b">ipcMain</code>可以如下使用:</p><pre class="nk nl nm nn gt nw lx nx ny aw nz bi"><span id="1d60" class="oa jz iq lx b gy ob oc l od oe">ipcMain.on('message', (event, { message }) =&gt; {<br/>  console.log('receive message: ' + message);<br/>})</span></pre><h1 id="b637" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="c83f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">编写运行在不同进程中的多个js文件是令人困惑的，但是当我们使用消息传递时，这是不可避免的。你可以试试<a class="ae nv" href="https://www.npmjs.com/package/electron-redux" rel="noopener ugc nofollow" target="_blank">电子还原</a>或者其他一些好的框架:)</p></div></div>    
</body>
</html>