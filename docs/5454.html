<html>
<head>
<title>Building Git in Elixir — Part 2 (Store Trees &amp; Initial Commit)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Elixir中构建Git第2部分(存储树和初始提交)</h1>
<blockquote>原文：<a href="https://itnext.io/building-git-in-elixir-part-2-store-trees-initial-commit-9013ed02b75a?source=collection_archive---------2-----------------------#2021-03-10">https://itnext.io/building-git-in-elixir-part-2-store-trees-initial-commit-9013ed02b75a?source=collection_archive---------2-----------------------#2021-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="bd57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/building-git-in-elixir-part-1-2f2ec245df74">上一篇文章</a>中，我关注于初始化存储库和存储文件内容的blobs。在本文中，我将重点讨论存储树和首次提交。</p><h1 id="b5ba" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">一点理论</h1><p id="9520" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">正如在<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/building-git-in-elixir-part-1-2f2ec245df74">上一篇文章</a>中所解释的，一棵树存储了关于所存储的斑点的某些信息。它是blobs之上的又一层间接寻址，以便于查找。如果我们使用<code class="fe ls lt lu lv b">git cat-file</code>命令检查Git的对象数据库，我们可以看到—</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/ba7c8ba41345ce611cb43e226347751c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZng0jcNA364g7AyBAlmxQ.png"/></div></div></figure><p id="a157" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，commit<strong class="js iu">88e 38705 fdbd 3608 cddbe 904 b 67 c 731 f 3234 c 45b</strong>是一个树，我们可以看到它存储了一个条目列表。每个条目包含文件的模式(100644)、单词<strong class="js iu"> blob </strong>、条目的对象ID和文件名。</p><p id="8225" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，git提交存储如下—</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mi"><img src="../Images/c5880af4ea991cea6398b34806aac603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i97wpLkEZW5B7MPQG-iGFA.png"/></div></div></figure><p id="9614" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，commit<strong class="js iu">6554 ab 08 c 8844 Fe 9 c 85346 a 7 F2 BF 021614 e2db 93</strong>存储了关于指向树的指针、作者和提交者信息、时间戳和提交消息的信息。</p><p id="0c62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要填充作者姓名和电子邮件，有多种方法，但通常是一个<strong class="js iu"> ~/。使用的gitconfig </strong>看起来像—</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mj"><img src="../Images/277ff6889b82aa1ecda16048beb75d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*beGcsLp2Ea9Btl7D9gDN4g.png"/></div></div></figure><p id="b8d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在本文中，我们将通过环境变量传递这些信息，我将在后面解释。</p><h1 id="5176" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">本文的重点</h1><p id="e3bf" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在本文中，重点是复制上述行为并实现—</p><ul class=""><li id="ddf9" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated"><strong class="js iu"> git commit </strong> —这样它可以存储树并保存初始提交和提交消息。还有，<strong class="js iu">头的</strong>文件在里面。git将被更新以存储初始提交的提交ID。</li></ul><h1 id="9b56" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">仙丹代码演练</h1><p id="bcdb" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">本文的源代码可以从—<a class="ae ko" href="https://github.com/imeraj/elixir_git" rel="noopener ugc nofollow" target="_blank">https://github.com/imeraj/elixir_git</a>获得</p><p id="6673" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特别是，这篇文章的代码可以在这个commit获得—</p><div class="mt mu gp gr mv mw"><a href="https://github.com/imeraj/elixir_git/commit/bba02d9ae5ac50880fb3f1fe7a1cb1eece1476f0" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">-存储树并写入提交imeraj/elixir_git@bba02d9</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">Git版本控制系统的Elixir实现——imeraj/Elixir _ Git</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">github.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk mg mw"/></div></div></a></div><p id="2daf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它包含一个关于如何构建可执行文件和使用<strong class="js iu"> git init </strong>和更新的<strong class="js iu"> commit </strong>命令的<strong class="js iu"> README </strong>文件。</p><h2 id="d264" class="nl kq it bd kr nm nn dn kv no np dp kz kb nq nr ld kf ns nt lh kj nu nv ll nw bi translated">一些代码重构</h2><p id="cf76" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">由于代码库在增长，我做了一些重构，将代码中使用的不同类型从<strong class="js iu"> lib → lib/types中移走。</strong>新的目录结构看起来像—</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/7a6d9e3cc836b12846467674a555cb77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*Xb5eKbW7ZKhZwaezZGZzmw.png"/></div></figure><p id="09d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了<strong class="js iu"> BLOB、Commit </strong>之外，我们还可以在这里看到一些新的类型。我将在本文中解释这些。</p><p id="8e3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，在数据库对象中编写新blobs的代码已被重构，如下所示，这样它可以编写任何对象，而无需知道类型</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">数据库. ex</figcaption></figure><h2 id="6f6e" class="nl kq it bd kr nm nn dn kv no np dp kz kb nq nr ld kf ns nt lh kj nu nv ll nw bi translated">储存树木</h2><p id="59f2" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">由于树由blob条目组成——每个blob一个条目，现在有两种新的类型— <strong class="js iu">条目</strong>和<strong class="js iu">树</strong>。树基本上是条目集合。</p><p id="d7ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是它们在代码中的样子—</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">entry.ex</figcaption></figure><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">tree.ex</figcaption></figure><p id="5fbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">条目</strong>类型非常简单，但是<strong class="js iu">树</strong>需要一些解释。函数<strong class="js iu"> to_s() </strong>负责格式化条目，使其与Git在树中写入条目的方式完全匹配。这里—</p><ul class=""><li id="104c" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated"><strong class="js iu">第15–20行</strong> —根据名称对条目进行排序，并为每个条目准备一个包含模式(100644)、空格、条目名称、空字节和条目oid的字符串。</li><li id="e6c4" class="mk ml it js b jt oe jx of kb og kf oh kj oi kn mp mq mr ms bi translated"><strong class="js iu">第22行</strong> —连接那些存储在树中的字符串</li></ul><p id="0b0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> commit.ex </strong>已经被重构，现在看起来如下——</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">提交. ex</figcaption></figure><p id="9641" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在有了新的<strong class="js iu">build _ { blob/tree/commit }</strong>函数来构建适当的对象，这样<strong class="js iu"> database.store() </strong>就可以在不查看类型的情况下编写这些对象。</p><p id="01c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="d382" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated"><strong class="js iu">第18行</strong> —在写入每个blob后创建一个<strong class="js iu">条目</strong>类型</li><li id="902a" class="mk ml it js b jt oe jx of kb og kf oh kj oi kn mp mq mr ms bi translated"><strong class="js iu">第56–62行</strong> —用这些条目构建一个<strong class="js iu">树</strong></li><li id="d3a1" class="mk ml it js b jt oe jx of kb og kf oh kj oi kn mp mq mr ms bi translated"><strong class="js iu">第28行</strong> —存储构建到对象数据库中的树</li></ul><p id="ebab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个阶段，egit能够在对象数据库中存储blobs和树。</p><h2 id="d546" class="nl kq it bd kr nm nn dn kv no np dp kz kb nq nr ld kf ns nt lh kj nu nv ll nw bi translated"><strong class="ak">存储提交</strong></h2><p id="50de" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">下一步是存储提交，特别是我们的第一次提交。</p><p id="096c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了传递作者姓名和电子邮件的配置，我使用了环境变量。所以，我把下面几行放到我的shell中。<strong class="js iu">剖面图</strong> —</p><pre class="lx ly lz ma gt oj lv ok ol aw om bi"><span id="888b" class="nl kq it lv b gy on oo l op oq">export EGIT_AUTHOR_NAME=”Meraj Molla”<br/>export EGIT_AUTHOR_EMAIL=”<a class="ae ko" href="mailto:meraj.enigma@gmail.com" rel="noopener ugc nofollow" target="_blank">meraj.enigma@gmail.com</a>”</span></pre><p id="e5d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当发出commit命令时，它读取这些变量并作为映射传递给commit函数—</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi or"><img src="../Images/08b2f68548e3f9f72253a6ef592fdc79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCkBy6EOGqb-vv_ZuzXFxg.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">来自cli.ex</figcaption></figure><p id="4fb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面粘贴的<strong class="js iu"> commit.ex </strong>处理该信息以存储提交。为此，我有一个新的类型<strong class="js iu">提交</strong>，如下<strong class="js iu"> — </strong></p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="62e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="7b2a" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated"><strong class="js iu">第14–23行</strong> —实现<strong class="js iu"> to_s() </strong>函数，该函数构建提交类型，使其包含五行文本——提交、作者、已提交、空行和提交消息的树信息</li></ul><p id="79d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">提交</strong>类型使用了一个<strong class="js iu">作者</strong>类型，看起来像是—</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c1db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="009e" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated"><strong class="js iu">第8–12行</strong> —实现<strong class="js iu"> to_s() </strong>函数，该函数格式化时间戳并以预期的方式创建一个包含作者姓名、电子邮件和时间戳的字符串。(<strong class="js iu"> <em class="os">注意:我在使用Calendar/Timex包使时区格式与escript Elixir应用程序一起正常工作时遇到了问题。所以时间戳格式并不完全像Git那样。在这个问题解决之前，我们将不得不忍受那个</em> </strong>)</li></ul><p id="ca9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的主<strong class="js iu"> commit.ex(粘贴在存储树部分)</strong> —</p><ul class=""><li id="89e2" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated"><strong class="js iu">第30-32行</strong> —用环境变量中传递的姓名和电子邮件以及时间戳构建<strong class="js iu">作者</strong>类型。</li></ul><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ot"><img src="../Images/ab05c5b817d534e6b609ffb75159b743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfnCJxElfc0Exq7FCs922A.png"/></div></div></figure><ul class=""><li id="56ea" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated"><strong class="js iu">第64–77行</strong> —从stdin收集提交消息(<strong class="js iu">第65行</strong>)并构建<strong class="js iu">提交</strong>类型</li></ul><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ou"><img src="../Images/77c9dbafef9c2620b985cc2ac2cabf0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T28VTPoIpUdA_e2Wf-44rw.png"/></div></div></figure><p id="0482" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个阶段，egit能够存储提交。我们还需要更新<strong class="js iu">。git/HEAD </strong>带有新提交的ID，并向终端打印一条消息。代码位于<strong class="js iu"> commit.ex </strong>中，如下所示</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ou"><img src="../Images/3ac02aaf6dd06704a9ba66b4da559e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sm5BN4Ws2KEzQ_q3-KQdTg.png"/></div></div></figure><p id="709f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一切顺利，我们应该会看到一行包含提交信息的输出(由第45行打印)</p><h2 id="3733" class="nl kq it bd kr nm nn dn kv no np dp kz kb nq nr ld kf ns nt lh kj nu nv ll nw bi translated"><strong class="ak">带着egit兜风</strong></h2><p id="52dc" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">到目前为止，我们已经构建了一个示例会话，如下所示</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mj"><img src="../Images/460cebfaa553169c311beeaabe50e138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAq7gKOZqvWqq0Y0_DKfdw.png"/></div></div></figure><p id="a97d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查根提交<strong class="js iu">4196 ADB 7 E3 B2 EC 1c 491 b 9 E6 a 565970015599 e384</strong>—</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ov"><img src="../Images/10b1c61b2168357f45532edcba94ed49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r49wjhQVqKnwtpX46HuqRg.png"/></div></div></figure><p id="8a1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将显示上面输入的作者信息和提交消息。</p><p id="3ccd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查一下提交树<strong class="js iu">88e 38705 fdbd 3608 cddbe 904 b 67 c 731 f 3234 c 45b—</strong></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ow"><img src="../Images/0a1db242c84b89dd4ff78a9712e56b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxXq6qjbR4PAhwN6Q801_A.png"/></div></div></figure><p id="995d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且其中一个blob提交了<strong class="js iu">ce 013625030 ba 8d ba 906 f 756967 f 9 e 9ca 394464 a</strong>——</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ox"><img src="../Images/ef42336284e5de3ebacab023c0d76b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_kIOYKJlO0yhnXMig4xoQ.png"/></div></div></figure><p id="3a83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我使用了<strong class="js iu"> git cat-file -p </strong>来分析和显示blobs、树和提交。因为egit用和git一样的方式表示对象数据库，所以这是可能的。</p><p id="a267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个阶段，我们还可以运行其他Git命令，如<strong class="js iu"> git show </strong>和<strong class="js iu"> git log </strong></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi oy"><img src="../Images/8cfb27b25635a049e7f55e412379dd0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9ZJJxcTpxfSxTGthjbh9w.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">git显示输出</figcaption></figure><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi oz"><img src="../Images/58a7aea0d93fa902f557fae2defcb853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0K9ame1ZXFqUy5dDoC26g.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">git日志输出</figcaption></figure><p id="9ca8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于上面提到的限制，只有时间戳不匹配，但其他方面看起来都很好:)</p><h1 id="c840" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="bf6d" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在本系列文章的第2部分中，我已经更新了git commit命令的初始实现，以便能够存储git树和保存提交。在下一篇文章中，我将在此基础上构建，这样我们就可以拥有提交历史。此外，如果文件内容没有改变，我将引入一些代码优化来避免不必要的磁盘写入。</p><p id="364a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="os">更多详细和深入的未来技术帖子请关注我这里或上</em><a class="ae ko" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"><em class="os">Twitter</em></a><em class="os">。</em></p><h1 id="f83f" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">参考</h1><ol class=""><li id="291f" class="mk ml it js b jt ln jx lo kb pa kf pb kj pc kn pd mq mr ms bi translated"><a class="ae ko" href="https://elixir-lang.org/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank">https://elixir-lang.org/getting-started/introduction.html</a></li><li id="7af2" class="mk ml it js b jt oe jx of kb og kf oh kj oi kn pd mq mr ms bi translated">【https://elixir-lang.org/docs.html T42】</li><li id="a67c" class="mk ml it js b jt oe jx of kb og kf oh kj oi kn pd mq mr ms bi translated"><a class="ae ko" href="https://git-scm.com/docs" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs</a></li><li id="f9b3" class="mk ml it js b jt oe jx of kb og kf oh kj oi kn pd mq mr ms bi translated"><a class="ae ko" href="https://github.com/imeraj/elixir_git" rel="noopener ugc nofollow" target="_blank">https://github.com/imeraj/elixir_git</a></li></ol></div></div>    
</body>
</html>