<html>
<head>
<title>Functional Programming: Groked</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程:Groked</h1>
<blockquote>原文：<a href="https://itnext.io/functional-programming-groked-c6bc9115cf3c?source=collection_archive---------2-----------------------#2019-03-27">https://itnext.io/functional-programming-groked-c6bc9115cf3c?source=collection_archive---------2-----------------------#2019-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0379" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">具有节点、反应、角度和Vue</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/b24b35a3a18880ffc93bfe632210fcc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*e-sKJBo4Y3ze7Mdq870-8w.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">娱乐和利润的FP</figcaption></figure><p id="900f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自从90年代末的艰难岁月以来，我一直与JS一起工作。我想我非常了解什么是函数式编程。</p><p id="4fcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，到处都是这些术语和概念，我开始怀疑:我真的明白了吗？</p><p id="c78f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我开始挖掘。这篇文章分享了我在挖掘过程中所学到的东西。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="210f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我认为，就具体细节而言，函数式编程(FP)相当容易理解。我在很大程度上是对的:仅仅是让<em class="lq">使用</em> JS，我就获得了很多。对你来说可能也是如此。</p><p id="939d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我学会了礼节，我开始明白对计划生育有三个方面的理解:</p><ul class=""><li id="088f" class="ly lz it kw b kx ky la lb ld ma lh mb ll mc lp md me mf mg bi translated"><strong class="kw iu">基本要点:</strong>看到代码就理解</li><li id="c93a" class="ly lz it kw b kx mh la mi ld mj lh mk ll ml lp md me mf mg bi translated"><strong class="kw iu">战术:</strong>充分理解FP的战术，以便在编码时将其作为一个工具</li><li id="8eb1" class="ly lz it kw b kx mh la mi ld mj lh mk ll ml lp md me mf mg bi translated"><strong class="kw iu">策略:</strong>充分理解FP的策略，以设计出结合其他方法使用它的系统</li></ul><p id="95d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有第四个潜在的东西:</p><ul class=""><li id="3d30" class="ly lz it kw b kx ky la lb ld ma lh mb ll mc lp md me mf mg bi translated"><strong class="kw iu">深奥:</strong>语言层面的实现和哲学。这是一些令人兴奋的东西。</li></ul><p id="52ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望能帮助你理解前三个问题。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="c667" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将从现代JS中的四个关键潮流来谈谈什么是FP并举例说明:<strong class="kw iu"> NodeJS </strong>，<strong class="kw iu"> React </strong>，<strong class="kw iu"> Angular </strong>和<strong class="kw iu"> VueJS </strong>。</p><p id="7828" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果要我用一句话来回答“什么是函数式编程”这个问题，我会说:函数式编程是一门使用函数达到最佳效果的学科，目的是在松散耦合的组件之间实现清晰的语法和较小的表面积。</p><p id="48f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事不宜迟！</p><h1 id="c42f" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">一级函数</h1><p id="e5ad" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">函数式编程的概念依赖于一级函数(FCF)。FCF与正常功能使用的区别在于，该功能被视为一个独立的事物，能够独立存在并被独立处理。</p><p id="e175" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也称为<em class="lq">作为数据的功能。本质上，当你为一个函数创建一个变量，传递一个函数作为一个参数，或者使用一个函数作为一个返回值的时候，你是在使用一级函数/函数作为数据。</em></p><h2 id="d35b" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated"><strong class="ak">功能引用</strong></h2><p id="f028" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">一个很好的例子是函数引用，如下所示。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="1db9" class="nj mn it nw b gy oa ob l oc od">let myFunction = new function() { console.info("foobar!"); }</span></pre><p id="7cb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了引用，您就可以将该函数作为完整的代码成员来使用。这包括调用它，将其作为参数传递，或将其用作返回值。并不是所有的语言都是如此，它创造了独特的逻辑和设计方法的可能性。</p><p id="d5c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在JS中，可以用普通语法调用它:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="d2fb" class="nj mn it nw b gy oa ob l oc od">myFunction(); // outputs "foobar"</span></pre><p id="9c0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript允许您定义自定义函数类型，就像它允许您使用<code class="fe oe of og nw b">prototype</code>定义自定义对象类型一样。</p><h2 id="ce5b" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">元功能</h2><p id="9274" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">利用其他函数的函数。我称它们为<em class="lq">元函数。</em>它们也被称为<em class="lq">高阶</em>功能<em class="lq">。</em></p><p id="12a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将依次介绍两种基本类型:作为参数的函数(消费者)和返回函数的函数(生成器)。</p><h2 id="22bd" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated"><strong class="ak">消费者:作为参数的函数</strong></h2><p id="0bfd" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">这才是FP真正的心脏。让我们看看它在服务器上的运行情况。这里看一下node和express web框架中的路由映射。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="ebdb" class="nj mn it nw b gy oa ob l oc od">var express = require('express');<br/>var app = express();</span><span id="3ea0" class="nj mn it nw b gy oh ob l oc od">app.get('/', function (req, res) {<br/>  res.send('One Love!');<br/>});</span></pre><p id="334b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一些经典的FP。当我们调用<code class="fe oe of og nw b">app.get()</code>时，我们传递一个函数。</p><p id="b418" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，启用NodeJS的整个想法就是<a class="ae oi" href="https://nodejs.org/es/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">事件循环</a>。Node架构的核心是FP:函数被交给引擎来执行。</p><p id="c6ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意函数将如何从框架中接收参数(<code class="fe oe of og nw b">req</code>和<code class="fe oe of og nw b">res</code>)。</p><h2 id="e5aa" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">"回拨"</h2><p id="11f9" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">这通常被称为回调函数。这些已经在JS中大量使用了..永远不会。这大概是FP最显眼也是最重要的特点。简而言之:你可能一直在使用回调，所以你可能一直在使用FP。</p><p id="f790" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回调是一个很好的、显而易见的术语:你正在传递一个函数，无论你传递给谁，它都将被回调。</p><p id="921f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个看似简单的特性实际上为应用程序中的“连接点”带来了很多好处，定义了应用程序的各个部分如何交互。例如，当您在普通JS(或任何框架)中将一个函数传递给DOM时，您是通过一个函数回调与浏览器进行交互。</p><p id="4e63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“回调”简单明了，但是围绕这个想法还有很多其他复杂的术语。</p><h2 id="68b5" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">匿名函数</h2><p id="56e7" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">当我们定义传递给Express的函数时，它是内联定义的，没有变量引用。这是一个匿名函数。</p><p id="17e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任何时候你看到一个没有引用的函数定义，那就是一个匿名函数。</p><h2 id="8618" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated"><code class="fe oe of og nw b">=&gt;</code>胖箭头语法</h2><p id="9af5" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">JavaScript 6(又名ECMAScript 6)引入了函数定义的简写。我们可以这样写快速回调。</p><p id="33be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe oe of og nw b">app.get('/', (req, res) =&gt; {<br/> res.send('One Love!');<br/>});</code></p><p id="a87a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们已经删除了<code class="fe oe of og nw b"><em class="lq">function </em></code>关键字。这个清洁剂。我们可以更进一步:</p><p id="30a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe oe of og nw b">app.get('/', (req, res) =&gt; res.send('One Love!') );</code></p><p id="f410" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们也去掉了花括号。相当干净。注意，如果只有一个参数，可以去掉括号；如果有返回值，而你没有花括号，函数将自动返回它计算的任何值。</p><h2 id="7ff8" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">React.js中的函数使用者</h2><p id="4cb0" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">FP在前端JS里也是遍地开花。在React中，回调用于处理元素上的事件:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="02dc" class="nj mn it nw b gy oa ob l oc od">&lt;button onClick={function() { alert('click'); }}&gt;<br/>  Click THIS.<br/>&lt;/button&gt;</span></pre><p id="f3a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，我们也可以使用粗箭头synax:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="69bb" class="nj mn it nw b gy oa ob l oc od">&lt;button onClick={ () =&gt; alert('click'); }&gt;<br/>  Click THIS.<br/>&lt;/button&gt;</span></pre><h2 id="c676" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated"><strong class="ak">匿名函数，胖箭头，</strong> <code class="fe oe of og nw b"><strong class="ak">this </strong></code> <strong class="ak">关键字</strong></h2><p id="5fa0" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">除了更简洁之外，胖箭头语法处理<code class="fe oe of og nw b">this</code>绑定的方式与普通匿名函数不同。</p><p id="72bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本质上，<code class="fe oe of og nw b">this</code>关键字将被解析为周围的功能上下文。因此，您可以说，胖箭头定义的函数将假定父函数或包装函数的上下文，而不是为自己创建新的上下文。在代码中:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="57bb" class="nj mn it nw b gy oa ob l oc od">var o = {};<br/>o.test = function(){<br/>  var standardAnon = function(){ <br/>    console.log("this = " + this);  <br/>  }<br/>  var fatArrow = () =&gt; console.log("this = " + this);<br/>  standardAnon(); <br/>  fatArrow();<br/>}<br/>o.test();</span></pre><p id="761b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">产出:</p><p id="7b60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe oe of og nw b">this = [object Window]<br/> this = [object Object]</code></p><p id="b8a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你多看几遍,<code class="fe oe of og nw b">this</code>的本质和两种匿名函数将会被牢牢植入(如果还没有的话)。</p><h2 id="6d68" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">词汇“范围”</h2><p id="1021" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">胖箭头语法的上述行为被称为<em class="lq">词法范围。</em>这是一种奇特的说法:由代码的单词本身定义的上下文。</p><p id="7ca4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，词法范围是在执行函数的代码行中找到的上下文，<em class="lq">而不是在函数定义的新上下文中。</em></p><p id="f263" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说:如果词法范围有效，那么<em class="lq"> this </em>关键字将用于函数的执行。</p><p id="0c6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">边注:</strong>根据JavaScript的<em class="lq">自己的命名约定</em>，这个应该叫做<em class="lq">词法上下文。</em>上下文<em class="lq"> </em>的意思是“什么是<code class="fe oe of og nw b">this</code>”。范围的意思是“哪些变量是可用的”。<em class="lq">叹息。</em></p><h2 id="c374" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">关闭</h2><p id="27f3" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">你将看到的另一个FP术语是<em class="lq"> closure。Closure更像是一个语言实现术语:它意味着功能上下文会一直存在，直到不存在对它们的引用。</em></p><p id="d9bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着函数范围能够被打包(“封闭”)并保持超出其自身的存在，以便在该范围之外执行。</p><p id="c77b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说:函数的词法范围继续存在。例如:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="26f3" class="nj mn it nw b gy oa ob l oc od">foo = function(){<br/>  var closuredVar = "From the parent closure";<br/>  var bar = function(){<br/>    console.log("I can see closuredVar: " + closuredVar);<br/>  }<br/>  bar();<br/>}<br/>foo();</span></pre><p id="2c03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于JS开发人员来说，这可能很平常，但这是一种重要的语言:它足够聪明，可以为了执行内部上下文而维护外部上下文。</p><p id="53ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个你可能很熟悉的例子，即使你不知道这个新奇的词。</p><p id="3c94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，你可能会想，“这就是它应该如何工作……显然，仍然存在对<code class="fe oe of og nw b">foo()</code>的调用，所以语言应该保留上下文，包括内部函数的上下文。”</p><p id="985d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是真的，这是它应该工作的明显方式(就像在任何垃圾收集语言中，您期望任何仍然有引用的变量继续存在)。只是在构建<em class="lq">语言本身的过程中，</em>实现那个显而易见的行为是不明显的，也不是微不足道的，至少可以这么说，交付它的方法被称为<em class="lq">闭包。</em></p><h2 id="f1e6" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">使用集合</h2><p id="6348" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">对于函数式编程来说，集合是一个明显的胜利——也许是最明显和突出的例子。通过使用函数参数，处理集合变得更容易和更容易理解。</p><p id="a2d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">各种数组(和类数组)函数:<code class="fe oe of og nw b">forEach, map, filter</code>和<code class="fe oe of og nw b">reduce</code>是这个故事中的明星。这些都内置在JS的集合中，它们都将函数作为参数，并将各个项传递给那个参数。</p><p id="3b94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一个简单的例子，下面是<code class="fe oe of og nw b">map</code>遍历一个数组并创建一个单词颠倒的新数组。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="7d0c" class="nj mn it nw b gy oa ob l oc od">let words = [“test”,”foo”,”bar”];<br/>let reversed = words.map(x =&gt; x.split(“”).reverse().join(“”))</span></pre><p id="1adb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些方法的真正美妙之处在于它们紧凑，并且允许代码和思想的流动顺利进行。</p><h2 id="c8b5" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">流畅的编程</h2><p id="a038" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">一般来说，关于集合API和FP的另一个伟大之处是“流畅编程”这个名字。这只是将函数链接在一起的能力，因为每个函数都返回一个值，下一个函数可以对该值进行操作。</p><p id="b742" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，在下面，我们使用上面的<code class="fe oe of og nw b">map</code>例子，并用对<code class="fe oe of og nw b">reduce</code>的调用来链接它。最终结果是，我们从<code class="fe oe of og nw b">map</code>得到一个新数组，其中包含反转的单词，然后从<code class="fe oe of og nw b">reduce.</code>得到一个组合字符串</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="fea7" class="nj mn it nw b gy oa ob l oc od">let words = [“test”,”foo”,”bar”];<br/>words.map(x =&gt; x.split(“”).reverse().join(“”))<br/>  .reduce((combined, x) =&gt; combined + “, “ + x);</span></pre><p id="15de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这清除了在“命令式”编码中看到的无关的逻辑，由此呈现了框定要完成的工作的逻辑，即循环数组。在循环修改的方法中做上面的事情会占用更多的代码行，并且不容易阅读。</p><p id="6fd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">开发人员很少停下来思考，可以关注他们试图实现的业务逻辑。</p><p id="010f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从更广泛的意义上来说，FP的工作方式是允许组件通过谨慎的、可移植的代码块(即函数)进行交互或通信。</p><p id="cae2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">驱动OOP(面向对象编程)的原理和驱动FP的原理是一样的:封装和编码到接口。</p><p id="0c99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只是这个函数是传递的功能中最小的一个。这使得它成为一个更干净的设计，因为任何时候你减少组件的表面面积，或者组件本身的占用空间，代码都更简单。</p><p id="0c75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，您可以将函数传递给其他函数(在数组api中或其他地方)视为函数接口。提供者函数(使用参数函数)是一般化逻辑的插件。</p><p id="e097" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这看起来很像OOP中的<em class="lq">策略模式</em>，但是同样，函数的紧凑性(以及JavaScript类型系统的动态性)使得组件协议非常紧密。</p><p id="cbd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">FP与OOP</p><p id="f12e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在OOP这个主题上，有一些风吹着，声称一个比另一个更好。这是一个完整帖子的主题，但我要在这里提到，他们每个人都擅长不同的事情。</p><p id="6f3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般来说，你不会在它们之间做出选择；你为了一个特定的目的在它们之间进行选择。</p><p id="ec1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总的来说，OOP有利于构建结构，FP有利于执行动作。对象和类就像汽车的底盘，或人体的骨骼，FP就像电气或神经系统。</p><p id="3596" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以看到这是事实，像react、vue和angular这样的现代UI框架都是基于<em class="lq">组件的</em>系统，这些系统类似于并经常使用OOP来定义结构。</p><p id="4a91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">生成器:返回函数的函数</strong></p><p id="3c16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">FP的另一个常见元素是返回函数的函数。这远不如函数作为参数常见。</p><p id="66e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为函数生成器通常在框架或库方面比在应用程序客户端代码方面更有用。应用程序开发人员通常负责向其他函数提供函数以满足框架需求，但很少负责提供创建函数的函数。</p><p id="8c0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个常见react模式的示例，其中粗箭头语法是链式的:</p><p id="5dac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe oe of og nw b">handleChange = field =&gt; e =&gt; {<br/> e.preventDefault();<br/> // Handle event<br/>}</code></p><p id="d5fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的目的是创建一个事件处理程序，它将接受有问题的字段，然后是<em class="lq">和</em>事件。这很有用，因为您可以将同一个<code class="fe oe of og nw b">handleChange</code>应用于多个字段。简而言之:同一个处理程序可用于多个领域。</p><h2 id="66e2" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">简化的功能</h2><p id="4d97" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">上面的react处理程序是一个定制函数的例子。“Curried function”是一个有点令人沮丧的名字:它纪念一个人，这很好，但它没有描述这个概念，这令人困惑。</p><p id="a6bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论如何，这个想法是当你有返回函数的函数时，你可以把对它们的调用链接在一起，这比创建一个有多个参数的函数更灵活。</p><p id="53d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当调用这些类型的函数时，您会遇到独特的“链式括号”语法:</p><p id="70aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe oe of og nw b">handleChange(field)(event)</code></p><p id="cb16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是对React如何调用我们的<code class="fe oe of og nw b">handleChange()</code> curried函数的一种推测。我们调用根函数，传入字段参数，然后取回另一个函数，并执行它，传入事件对象。</p><h1 id="939f" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">更多代码示例</h1><h2 id="bae0" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">角度4+和RxJS</h2><p id="b165" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">Angular 2是一个干净的突破和重写。它所做的真正有远见的事情之一是采用<a class="ae oi" href="https://www.learnrxjs.io/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>作为它的事件系统。这带来了两个巨大的好处:每个事件在任何地方都用相同的系统处理；赛事系统质量高，维护严谨。</p><p id="42d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而且事实证明:RxJS本身就是FP的一个漂亮例子。</p><p id="52d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RxJS的核心思想是通过创建事件生产者(可观察对象)和事件订阅者来分离代码，然后用函数操作符处理事件流。</p><p id="7932" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这类似于我们前面看到的JS数组方法的工作方式；事实上，将数据集合作为一组独立实例进行操作的想法被称为<em class="lq">流。</em></p><p id="bcb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了强调相似性，许多JS数组方法，如<code class="fe oe of og nw b">map</code>，以RxJS操作符的形式出现；不同之处在于，RxJS被设计为处理来自几乎任何来源的流数据，包括具有不确定的开始、停止、间歇和错误的实时来源。</p><p id="dd7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在RxJS的世界里，它被称为<em class="lq">反应式</em>编程。这里有一个简单的例子:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="074c" class="nj mn it nw b gy oa ob l oc od">var button = document.querySelector(‘button’); Rx.Observable.fromEvent(button, ‘click’).subscribe(() =&gt; console.log(‘Clicked!’));</span></pre><p id="c7b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这应该是显而易见的。这是一个应用于按钮元素的简单事件处理程序。</p><p id="3a82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Angular里，你会随处看到这个<em class="lq">。</em>处理组件事件和组件间交互，转换数据，处理后端API请求。</p><p id="e2f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是Angular监听鼠标事件，然后在光标移动到左上角时取消订阅的示例:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="92d8" class="nj mn it nw b gy oa ob l oc od">const <a class="ae oi" href="https://angular.io/api/service-worker/SwPush#subscription" rel="noopener ugc nofollow" target="_blank">subscription</a> = mouseMoves.subscribe((evt: MouseEvent) =&gt;{console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);<br/>  if (evt.clientX &lt; 40 &amp;&amp; evt.clientY &lt; 40) {<br/>    subscription.unsubscribe();<br/>  }<br/>});</span></pre><p id="6c0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个更复杂的例子:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="8672" class="nj mn it nw b gy oa ob l oc od">const typeahead = fromEvent(searchBox, ‘input’).pipe(<br/>  map((e: KeyboardEvent) =&gt; e.target.value),<br/>  filter(text =&gt; text.length &gt; 2),<br/>  debounceTime(10),<br/>  distinctUntilChanged(),<br/>  switchMap(() =&gt; ajax(‘/api/endpoint’))<br/>);</span></pre><p id="f3ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不打算在这里深究这个，但是看一看:这都是FP。它本质上处理来自提前键入功能的事件，通过使用一个可观察的(通过<code class="fe oe of og nw b">pipe()</code>命令)来确定何时命中提前键入数据的后端。</p><p id="e7a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">(这些例子来自<a class="ae oi" href="https://angular.io/guide/practical-observable-usage" rel="noopener ugc nofollow" target="_blank">角度文档</a>)。</p><h2 id="0fd1" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">vue . j</h2><p id="735f" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">Vue与React和Angular是同一个概念。它依赖于FP，虽然不像其他两个那样严重:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="1847" class="nj mn it nw b gy oa ob l oc od">data: function() {<br/>  return {<br/>    item: {<br/>      name: 'Foo',<br/>      description: 'Bar',<br/>    }<br/>  }<br/>}</span></pre><p id="c766" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以上是Vue组件上的数据字段的示例。这是一个从另一个函数返回一个函数的简单例子。</p><p id="3a5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Vuex更加以FP为中心。</p><h1 id="224e" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">再来几个FP术语</h1><h2 id="bab7" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">希腊字母的第11个</h2><p id="e738" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">经常与<em class="lq">匿名函数、</em>混淆，我们在这里讨论过。现实中，<em class="lq">更是一阶函数的同义词，</em>也涵盖在这里。</p><p id="f9e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">λ是函数作为数据的任何使用，即匿名函数或函数引用。</p><p id="c949" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有匿名函数都是Lambdas。并非所有的Lambdas都是匿名函数。我发现这个术语最好的解释者是这里的<a class="ae oi" href="https://gist.github.com/ericelliott/414be9be82128443f6df" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="caa8" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">纯函数</h2><p id="4df0" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">没有副作用的功能。</p><p id="cf8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些被认为是重要的(我认为是正确的),因为它们是复杂性的死胡同。</p><p id="81fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我的意思是:一个纯函数接受它的参数，并返回它的值，而不修改其他任何东西。用相同的参数重复调用一个纯函数肯定会返回相同的结果。</p><p id="7248" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Angular的通量式存储(ngrx)中，减速器在修改状态时使用纯函数作为动作。React鼓励纯功能，并坚持在修改道具时组件的行为要像纯功能一样。</p><p id="6953" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你能把逻辑表现为一个纯函数，那就去做。这意味着你已经实现了你的目标，没有不必要的改变外部状态或增加复杂性。</p><h2 id="53a7" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">对透明性有关的</h2><p id="8344" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">这与纯函数密切相关。</p><p id="774e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本质上，这意味着所讨论的函数对于它所修改的引用是透明的。再次:归结为只有参数和返回值参与执行它的工作。</p><h1 id="dfff" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="7691" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">底线是JS已经<em class="lq">一直</em>相当面向FP，这是它对函数巧妙处理的结果。普通JS和jQuery一代框架的事件处理程序都是FP风格的，就像React一样。</p><p id="7d9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事件的概念是FP的核心。通过使用函数作为软件组件之间的交互点，交互可以简化为事件回调的思想。这提供了非常小的接触点，并且组件之间的表面积越小越好。</p><p id="7ce9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次强调，理解FP的三个维度:</p><ul class=""><li id="47a7" class="ly lz it kw b kx ky la lb ld ma lh mb ll mc lp md me mf mg bi translated"><strong class="kw iu">具体细节:</strong>当你看到代码时理解它，并以类似的方式使用它:这对所有JS开发人员都很重要</li><li id="48ae" class="ly lz it kw b kx mh la mi ld mj lh mk ll ml lp md me mf mg bi translated"><strong class="kw iu">战术:</strong>理解FP的战术，足以在编码时将其作为工具；对架构师或主要开发人员至关重要</li><li id="4660" class="ly lz it kw b kx mh la mi ld mj lh mk ll ml lp md me mf mg bi translated"><strong class="kw iu">策略:</strong>充分理解FP的策略，以设计结合其他方法使用它的系统；如果您正在构建类似React的东西，而不是使用React，可能会更有趣</li></ul><p id="b7b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望，在追求这三个目标的过程中，我已经给了你一些动力。</p><h2 id="767a" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">关于计划生育的深层思考</h2><p id="3b24" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">关于FP的第四维(<strong class="kw iu">深奥的</strong>)的离别之思:我发现自己在阅读<a class="ae oi" href="https://en.wikipedia.org/wiki/Abductive_reasoning" rel="noopener ugc nofollow" target="_blank">溯因推理</a>，心想:“这是一些深奥的东西。”FP诞生于编程进化过程中形成阶段的激烈思考。</p><p id="5d5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，它直接关系到支撑软件本身的底层逻辑和心理结构。</p><p id="1c7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我喜欢那东西。但是它与日常编码没有什么关系。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="4ac4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顺便说一下，你知道吗，如果你点击并按住拍手按钮，它会增加。还蛮好玩的…如果你想试试的话:)</p></div></div>    
</body>
</html>