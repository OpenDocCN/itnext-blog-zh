<html>
<head>
<title>Redis 5.X under the hood: 2 — Intro to Redis Commands and Data Structures — part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis 5。引擎盖下的x:2—Redis命令和数据结构介绍—第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/redis-5-x-under-the-hood-2-intro-to-redis-commands-and-data-structures-part-1-41f05501cb52?source=collection_archive---------4-----------------------#2019-02-25">https://itnext.io/redis-5-x-under-the-hood-2-intro-to-redis-commands-and-data-structures-part-1-41f05501cb52?source=collection_archive---------4-----------------------#2019-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/014975259905eb19e642cfe7161b0f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLg4gNGA5Iq2b5ofiPGoJQ.jpeg"/></div></div></figure><p id="bacc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将研究Redis数据类型和重要操作，将它们与适合它们的用例结合起来。</p><ul class=""><li id="42d1" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">在本文的第1部分，我们将讨论为什么在使用Redis时需要考虑如何存储、访问和转换数据，同时讨论STRING数据类型。</li><li id="a895" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">列表和散列数据类型将在第2部分讨论。</li><li id="61df" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">第3部分将介绍集合、排序集合和地理数据类型。</li></ul><p id="591a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每种数据类型都提供不同的操作，每种操作都伴随着更高的复杂性和/或性能。</p><p id="e95a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">牢记了解每种数据类型的注意事项的极端重要性，因为<strong class="kd iu"> <em class="ln">“如果你只有一把锤子，一切看起来都像钉子”。</em>T3】</strong></p><p id="800a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将认为您有一个Redis服务器实例已经启动并正在运行，如本系列的前一篇文章<a class="ae lo" href="https://medium.com/@fcosta_oliveira/redis-5-x-under-the-hood-1-downloading-and-installing-redis-locally-3373fe67a154" rel="noopener">https://medium . com/@ fcosta _ Oliveira/Redis-5-x-under-the-hood-1-download-and-installing-Redis-locally-3373 Fe 67 a 154</a>所述。</p><h1 id="26da" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.1在我们深入研究数据类型之前:</h1><p id="ea4b" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">在深入研究数据类型之前，我们需要理解另一个重要的概念，即键空间。它本质上是一个字典——键-值模式——键和它们各自的值。</p><ul class=""><li id="8cbd" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">这些键是唯一的，可以是任何有效的Redis字符串。</li><li id="f8e6" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">这些值可以是任何一种Redis核心模块数据类型，并且只能通过它们的名称来访问。</li></ul><h1 id="d9c6" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.2还有一名顾问:</h1><p id="f55b" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">每种数据类型都提供不同的操作，每种操作都伴随着更高的复杂性和/或性能，操作的复杂性在文档中有所描述。</p><p id="9d52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以<a class="ae lo" href="https://redis.io/commands/set" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> SET </strong> </a>命令为例，带有一个<strong class="kd iu">时间复杂度:</strong> O(1)，表示一个常数时间操作。记住，我的O(1)和你的O(1)不一定相同。这只意味着操作的时间与键空间中的项目数量无关。</p><h1 id="c30a" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.3 Redis不是什么:</h1><p id="477e" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">Redis事务不是完全符合ACID的(原子性、一致性、隔离性和持久性)。如果预期有ACID交易，Redis不是最佳选择，不应使用。在这些情况下，应该使用RDBMS或其他数据库系统。</p><p id="bf6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Redis是一个非关系数据库，不适合为关系数据服务。为了保持外键、引用完整性约束、回滚和关系数据库中的持久性等概念，您必须处理的复杂性远远超出了您应该考虑的范围，如果不是不可能的话。你可以实现其中的一些，但是需要权衡效率、复杂性和数据量。</p><p id="ee3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了了解Redis如何适应各种可用的数据库和缓存软件，您可以在下面的链接中看到一些不同类型的缓存或数据库服务器的介绍性列表:<a class="ae lo" href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-1-what-is-redis/1-1-1-redis-compared-to-other-databases-and-software/" rel="noopener ugc nofollow" target="_blank">https://Redis labs . com/ebook/part-1-getting-started/chapter-1-getting-to-know-Redis/1-1-what-is-Redis/1-1-1-Redis-comparated-to-other-databases-and-software/</a></p><h1 id="c5d0" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.4字符串数据类型:</h1><p id="3929" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">字符串是Redis的基本数据类型，用于存储:</p><ul class=""><li id="e57e" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">字符串:<a class="ae lo" href="https://redis.io/commands/append" rel="noopener ugc nofollow" target="_blank">追加</a>，<a class="ae lo" href="https://redis.io/commands/getrange" rel="noopener ugc nofollow" target="_blank">获取范围</a>，<a class="ae lo" href="https://redis.io/commands/setrange" rel="noopener ugc nofollow" target="_blank">设置范围</a>，<a class="ae lo" href="https://redis.io/commands/strlen" rel="noopener ugc nofollow" target="_blank"> STRLEN </a></li><li id="07b7" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">整数:<a class="ae lo" href="https://redis.io/commands/incr" rel="noopener ugc nofollow" target="_blank"> INCR </a>，<a class="ae lo" href="https://redis.io/commands/incrby" rel="noopener ugc nofollow" target="_blank"> INCRBY </a>，<a class="ae lo" href="https://redis.io/commands/decr" rel="noopener ugc nofollow" target="_blank"> DECR </a>，<a class="ae lo" href="https://redis.io/commands/decrby" rel="noopener ugc nofollow" target="_blank"> DECRBY </a></li><li id="5420" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">浮动:<a class="ae lo" href="https://redis.io/commands/incrbyfloat" rel="noopener ugc nofollow" target="_blank"> INCRBYFLOAT </a></li><li id="d3b4" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">位:<a class="ae lo" href="https://redis.io/commands/setbit" rel="noopener ugc nofollow" target="_blank"> SETBIT </a>，<a class="ae lo" href="https://redis.io/commands/getbit" rel="noopener ugc nofollow" target="_blank"> GETBIT </a>，<a class="ae lo" href="https://redis.io/commands/bitpos" rel="noopener ugc nofollow" target="_blank"> BITPOS </a>，<a class="ae lo" href="https://redis.io/commands/bitcount" rel="noopener ugc nofollow" target="_blank"> BITCOUNT </a>，<a class="ae lo" href="https://redis.io/commands/bitop" rel="noopener ugc nofollow" target="_blank"> BITOP </a></li></ul><p id="7e06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<a class="ae lo" href="https://redis.io/commands/set" rel="noopener ugc nofollow" target="_blank"> SET </a>命令将一个字符串值关联到一个键。例如，如果我们想为我们的聚会设置场地:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="fde5" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; SET venue:redis-porto "Porto I/O, Porto, Portugal"</span><span id="3deb" class="nb lq it mx b gy ng nd l ne nf">OK</span></pre><p id="1f14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只需使用<a class="ae lo" href="https://redis.io/commands/get" rel="noopener ugc nofollow" target="_blank"> GET </a>命令就可以检索字符串值:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="793d" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; GET venue:redis-porto</span><span id="dcf2" class="nb lq it mx b gy ng nd l ne nf">"Porto I/O, Porto, Portugal"</span></pre><p id="e3e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Redis命令返回对所有常用命令的确认。在不存在的键上执行<a class="ae lo" href="https://redis.io/commands/get" rel="noopener ugc nofollow" target="_blank"> GET </a>将返回(nil):</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="bfda" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; GET venue:redis-lisbon</span><span id="0800" class="nb lq it mx b gy ng nd l ne nf">(nil)</span></pre><p id="93aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lo" href="https://redis.io/commands/strlen" rel="noopener ugc nofollow" target="_blank"> STRLEN </a>命令返回字符串的长度。例如，如果我们想知道雷迪斯-波尔图的场地长度:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="bc9d" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; STRLEN venue:redis-porto<br/>(integer) 26</span></pre><p id="9666" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Redis提供了几个命令来操作字符串键内容，而不需要执行两个不同的操作。让我们来理解这些特性的重要性。例如，如果我们想将字符串" Europe "附加到包含redis-porto地点的字符串中，可以选择执行<a class="ae lo" href="https://redis.io/commands/get" rel="noopener ugc nofollow" target="_blank"> GET </a>，附加到客户端，并将结果设置回redis，如下图所示:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/6d96791884630a93dc262d52bd8a355f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7f5JRhdNWasOqp1F8o5DQ.png"/></div></div></figure><p id="111a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方法有几个缺点:</p><ul class=""><li id="82df" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">尽管每个操作都是原子操作，但由于GET和SET是两个不同的操作，如果有人在GET之后SET之前更改了键，这可能会导致不一致。</li><li id="2685" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">客户端上需要工作。</li></ul><p id="6d6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在单个原子操作中，有几个命令可以直接操作字符串，而不需要使用<a class="ae lo" href="https://redis.io/commands/get" rel="noopener ugc nofollow" target="_blank"> GET </a>检索值和<a class="ae lo" href="https://redis.io/commands/set" rel="noopener ugc nofollow" target="_blank"> SET </a>将其赋回，如<a class="ae lo" href="https://redis.io/commands/append" rel="noopener ugc nofollow" target="_blank"> APPEND </a>和<a class="ae lo" href="https://redis.io/commands/setrange" rel="noopener ugc nofollow" target="_blank"> SETRANGE </a>。</p><p id="2b08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lo" href="https://redis.io/commands/append" rel="noopener ugc nofollow" target="_blank"> APPEND </a>有名字点，在字符串末尾追加值。如果我们想要追加的键不存在，那么在追加操作之前，它被创建并设置为一个空字符串。<a class="ae lo" href="https://redis.io/commands/setrange" rel="noopener ugc nofollow" target="_blank"> SETRANGE </a>覆盖存储在指定键的字符串的一部分，从定义的偏移量开始，覆盖指定的长度。</p><p id="3e3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下图说明了我们如何以推荐的方式从前面的<a class="ae lo" href="https://redis.io/commands/get" rel="noopener ugc nofollow" target="_blank"> GET </a>和<a class="ae lo" href="https://redis.io/commands/set" rel="noopener ugc nofollow" target="_blank"> SET </a>中获得相同的输出(以便添加到字符串中)。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/ef284af4a36b4cae666147afa15f6854.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*4_dbvExSGnISL5epPIjANA.png"/></div></figure><h2 id="c5a1" class="nb lq it bd lr nj nk dn lv nl nm dp lz km nn no md kq np nq mh ku nr ns ml nt bi translated">2.4.1另一个原子用例，NX的原子条件集</h2><p id="4e08" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">如果已经有一个值与密钥相关联，则<a class="ae lo" href="https://redis.io/commands/set" rel="noopener ugc nofollow" target="_blank"> SET </a>命令会覆盖该值。有时，如果键存在，我们不希望盲目地覆盖值。我们可以做的一件事是在执行<a class="ae lo" href="https://redis.io/commands/set" rel="noopener ugc nofollow" target="_blank">设置</a>之前使用【T2存在】命令来测试密钥的存在，然而，如果我们在两个独立的命令中进行检查和设置，它们将不会是导致潜在的不期望状态的原子操作。</p><p id="9995" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">举个例子，假设我们有两个人在里斯本布置场地，我们已经同意只在场地还没有布置好的情况下布置场地。人员1和人员2将以相同的顺序执行以下命令。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d9fe" class="nb lq it mx b gy nc nd l ne nf">EXISTS {key}<br/>SET {key} {value}<br/>GET {key}</span></pre><p id="a512" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">人员1看到以下输出，这不是他所期望的:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ed85" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; EXISTS venue:redis-lisbon</span><span id="e29c" class="nb lq it mx b gy ng nd l ne nf">(integer) 0</span><span id="729b" class="nb lq it mx b gy ng nd l ne nf">127.0.0.1:6379&gt; SET venue:redis-lisbon "ISCTE, Lisbon, Portugal"</span><span id="6c32" class="nb lq it mx b gy ng nd l ne nf">OK</span><span id="2b6b" class="nb lq it mx b gy ng nd l ne nf">127.0.0.1:6379&gt; GET venue:redis-lisbon</span><span id="1c75" class="nb lq it mx b gy ng nd l ne nf">"Universidade NOVA de Lisboa, Lisbon, Portugal"</span></pre><p id="0266" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，第二个人看到了以下输出，这是他的预期输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="76bb" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; EXISTS venue:redis-lisbon</span><span id="1fdb" class="nb lq it mx b gy ng nd l ne nf">(integer) 0</span><span id="13c0" class="nb lq it mx b gy ng nd l ne nf">127.0.0.1:6379&gt; SET venue:redis-lisbon "Universidade NOVA de Lisboa, Lisbon, Portugal"</span><span id="3877" class="nb lq it mx b gy ng nd l ne nf">OK</span><span id="b813" class="nb lq it mx b gy ng nd l ne nf">127.0.0.1:6379&gt; GET venue:redis-lisbon</span><span id="f852" class="nb lq it mx b gy ng nd l ne nf">"Universidade NOVA de Lisboa, Lisbon, Portugal"</span></pre><p id="42ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">人员1使用<a class="ae lo" href="https://redis.io/commands/get" rel="noopener ugc nofollow" target="_blank"> GET </a>命令检索的结果不是预期的结果。这可能发生，因为在<a class="ae lo" href="https://redis.io/commands/exists" rel="noopener ugc nofollow" target="_blank">存在的时间与</a>命令由人1执行的时间和设置命令由人1执行的时间之间，有人设置了密钥。下图正好说明了这一点:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/21bac38371d722a616b77ac7b77e5a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUWzvTBoi4K8GASHzdZeAw.png"/></div></div></figure><p id="91e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Redis提供了一个命令<a class="ae lo" href="https://redis.io/commands/setnx" rel="noopener ugc nofollow" target="_blank">SETNX</a>(SET if not exists的缩写)，可以用来设置一个键的值，但是只有在键不存在的情况下，在原子操作中，如果键设置成功，返回1，如果键已经存在，返回0，所以旧值不会被覆盖。</p><p id="a240" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当人员1执行<a class="ae lo" href="https://redis.io/commands/setnx" rel="noopener ugc nofollow" target="_blank">SETNX</a>venue:redis-Lisbon将看到:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d8cb" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; SETNX venue:redis-lisbon "ISCTE, Lisbon, Portugal"</span><span id="6042" class="nb lq it mx b gy ng nd l ne nf">(integer) 1</span></pre><p id="4b92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和人员2，因为条件检查和设置是由<a class="ae lo" href="https://redis.io/commands/setnx" rel="noopener ugc nofollow" target="_blank"> SETNX </a>命令自动完成的，所以将会看到:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="384e" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; SETNX venue:redis-lisbon "Universidade NOVA de Lisboa, Lisbon, Portugal"</span><span id="0f14" class="nb lq it mx b gy ng nd l ne nf">(integer) 0</span></pre><p id="5ae1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">导致不会覆盖先前设置的密钥，如下图所示:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/8d4470ffcfba7de443e2cf4d350c699e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCe6NjHfot6Fq_7Eyry-og.png"/></div></div></figure><h2 id="2782" class="nb lq it bd lr nj nk dn lv nl nm dp lz km nn no md kq np nq mh ku nr ns ml nt bi translated">2.4.2原子、二进制安全和高性能</h2><p id="53d6" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">如果您认为redis在没有管道的情况下每秒可以处理高达<a class="ae lo" href="https://redis.io/topics/benchmarks" rel="noopener ugc nofollow" target="_blank"> 80K的事件</a>，每分钟大约5M的事件，而在有管道的情况下每秒可以处理高达400K的事件，每分钟大约24M的事件(我们将在后面看到管道的含义)，那么在一个<strong class="kd iu">单个低端、未调优的Redis服务器上，</strong>以二进制安全和原子的每操作方式，STRING数据类型有许多用例。</p><p id="a7b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">STRING数据类型非常适合将简单的字符串(如“meetup ”)存储到整个文件(如JPEG文件)的内容中，并对int、floats和bit进行简单但高吞吐量的数字运算。</p><h2 id="b09f" class="nb lq it bd lr nj nk dn lv nl nm dp lz km nn no md kq np nq mh ku nr ns ml nt bi translated">2.4.3数值运算的竞争结束条件:</h2><p id="127e" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">如前所述，Redis为数据类型字符串的数值运算提供了命令。<a class="ae lo" href="https://redis.io/commands/incr" rel="noopener ugc nofollow" target="_blank"> INCR </a>、<a class="ae lo" href="https://redis.io/commands/incrby" rel="noopener ugc nofollow" target="_blank"> INCRBY </a>、<a class="ae lo" href="https://redis.io/commands/decr" rel="noopener ugc nofollow" target="_blank"> DECR </a>和<a class="ae lo" href="https://redis.io/commands/decrby" rel="noopener ugc nofollow" target="_blank"> DECRBY </a>和<a class="ae lo" href="https://redis.io/commands/incrbyfloat" rel="noopener ugc nofollow" target="_blank"> INCRBYFLOAT </a>命令将字符串值解析为整数/浮点数，按指定值递增，最后将获得的值设置为新值，无需在客户端上进行任何数值运算，同时保持每个客户端访问的数据的良好性能和一致性。</p><p id="1784" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">针对同一个密钥发布<a class="ae lo" href="https://redis.io/commands/incr" rel="noopener ugc nofollow" target="_blank"> INCR </a>的多个客户端将永远不会进入竞争状态。例如，永远不会发生客户端1读取“10”，客户端2同时读取“10”，两者都增加到11，并将新值设置为11。最终值总是正确的，不需要对数据访问和操作进行隐式锁定。</p><h2 id="e970" class="nb lq it bd lr nj nk dn lv nl nm dp lz km nn no md kq np nq mh ku nr ns ml nt bi translated">2.4.4位和字节级操作:</h2><p id="dd20" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">位和字节级运算实现了快速和极度内存优化的数值运算。假设您想要描述二元运算(只能是真或假的东西),比如用户是否参加了meetup，或者查看了这篇中型文章。如果我们有100万用户，我们只需要122KB的RAM来表示整个数据集。</p><p id="e862" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以100万用户为例，我们可以使用<a class="ae lo" href="https://redis.io/commands/setbit" rel="noopener ugc nofollow" target="_blank"> SETBIT </a>命令，该命令将位数作为第一个参数，将该位的设置值(1或0)作为第二个参数。如果寻址位超出当前字符串长度，该命令会自动放大字符串。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0b33" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; SETBIT redis-porto:article:2 1000000 1</span><span id="08eb" class="nb lq it mx b gy ng nd l ne nf">(integer) 0</span></pre><p id="b6a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了访问指定用户的值，我们将使用<a class="ae lo" href="https://redis.io/commands/getbit" rel="noopener ugc nofollow" target="_blank"> GETBIT </a>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f472" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; GETBIT redis-porto:article:2 1000000</span><span id="a339" class="nb lq it mx b gy ng nd l ne nf">(integer) 1</span></pre><p id="175e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们想访问用户10000的值，我们将:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e28c" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; GETBIT redis-porto:article:2 10000</span><span id="811a" class="nb lq it mx b gy ng nd l ne nf">(integer) 0</span></pre><p id="2359" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">索引之外的范围(存储在目标键中的字符串长度之外)总是被认为是零。如果我们想统计已经阅读文章的用户数量，我们可以使用BITCOUNT，它报告为指定键设置为1的位数。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="272b" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; BITCOUNT redis-porto:article:2</span><span id="8e74" class="nb lq it mx b gy ng nd l ne nf">(integer) 1</span></pre><p id="fbdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了<a class="ae lo" href="https://redis.io/commands/bitcount" rel="noopener ugc nofollow" target="_blank"> BITCOUNT </a>之外，还有<a class="ae lo" href="https://redis.io/commands/bitop" rel="noopener ugc nofollow" target="_blank"> BITOP </a>可以在不同的字符串之间执行逐位运算(AND、OR、XOR和NOT)，还有<a class="ae lo" href="https://redis.io/commands/bitpos" rel="noopener ugc nofollow" target="_blank"> BITPOS </a>可以让您找到具有指定值0或1的第一位。</p><p id="8201" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Redis数据库中的任何键都可以存储高达512MB的信息(2-1位)。这意味着每个键可以设置4 294 967 295个数据点。如果把它放到用户的信息场景中，您可以在一个Redis键中表示多达40亿用户的信息。</p><h2 id="551e" class="nb lq it bd lr nj nk dn lv nl nm dp lz km nn no md kq np nq mh ku nr ns ml nt bi translated">2.4.5在Redis中字符串是如何编码的:</h2><p id="5a34" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">值得一提的是字符串在Redis对象内部是如何编码的。Redis使用三种不同的编码来存储string对象，并将自动决定每个字符串值的编码。在描述每种编码方式的同时，我们将利用命令<a class="ae lo" href="https://redis.io/commands/object" rel="noopener ugc nofollow" target="_blank">对象</a>，允许您检查Redis对象的内部:</p><ul class=""><li id="647a" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><strong class="kd iu"> REDIS_ENCODING_INT ( int )— </strong>对于表示64位有符号整数的字符串，换句话说，如果对于类型为<strong class="kd iu"> long int </strong>的对象，值被转换为最小和最大值范围内的long，则字符串可以以这种形式存储。</li></ul><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d458" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; SET key "12"</span><span id="746d" class="nb lq it mx b gy ng nd l ne nf">OK</span><span id="bb84" class="nb lq it mx b gy ng nd l ne nf">127.0.0.1:6379&gt; OBJECT encoding key</span><span id="e6af" class="nb lq it mx b gy ng nd l ne nf">"int"</span></pre><ul class=""><li id="a6ba" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><strong class="kd iu">REDIS _ ENCODING _ EMBSTR(EMBSTR)—</strong>用于长度不超过44字节的字符串，这意味着REDIS对象结构和字符串结构放在内存的单个区域，从而提高内存使用效率和性能。</li></ul><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e735" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; SET key "redis-porto"</span><span id="2057" class="nb lq it mx b gy ng nd l ne nf">OK</span><span id="c26e" class="nb lq it mx b gy ng nd l ne nf">127.0.0.1:6379&gt; OBJECT encoding key</span><span id="8f35" class="nb lq it mx b gy ng nd l ne nf">"embstr"</span></pre><ul class=""><li id="3c26" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><strong class="kd iu">REDIS _ ENCODING _ RAW</strong><strong class="kd iu">(RAW)—</strong>用于所有长度超过44字节的字符串。使用我们从SETRANGE文档中学到的知识，让我们以一种“干净”的方式创建一个大于44字节的字符串:</li></ul><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="fcd1" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; SETRANGE key 44 "redis-porto"</span><span id="ae31" class="nb lq it mx b gy ng nd l ne nf">(integer) 55</span><span id="6414" class="nb lq it mx b gy ng nd l ne nf">127.0.0.1:6379&gt; OBJECT encoding key</span><span id="d44f" class="nb lq it mx b gy ng nd l ne nf">"raw"</span></pre><h1 id="f072" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.5瞬态数据:</h1><p id="c2cf" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">在深入研究其他Redis数据结构之前，我们需要讨论另一个命令，该命令不管数据类型如何都有效，名为<strong class="kd iu">Redis</strong><a class="ae lo" href="https://redis.io/commands/expire" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">EXPIRE</strong></a>。</p><p id="862b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当Redis键上设置了超时，并且指定的生存时间(<a class="ae lo" href="https://redis.io/commands/ttl" rel="noopener ugc nofollow" target="_blank"> TTL </a>)过去时，该键会自动销毁，就像用户用该键调用<a class="ae lo" href="https://redis.io/commands/del" rel="noopener ugc nofollow" target="_blank"> DEL </a>命令一样。您可以使用<a class="ae lo" href="https://redis.io/commands/ttl" rel="noopener ugc nofollow" target="_blank"> TTL </a>来检查一个密钥的生存时间。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1cbc" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; SET "venue:redis-porto" "Porto I/O"</span><span id="c5ba" class="nb lq it mx b gy ng nd l ne nf">OK</span><span id="0278" class="nb lq it mx b gy ng nd l ne nf">127.0.0.1:6379&gt; TTL "venue:redis-porto"</span><span id="8000" class="nb lq it mx b gy ng nd l ne nf">(integer) -1</span></pre><p id="ddf8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们将120秒的生存时间应用于密钥。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="380e" class="nb lq it mx b gy nc nd l ne nf">127.0.0.1:6379&gt; EXPIRE "venue:redis-porto" 120</span><span id="109d" class="nb lq it mx b gy ng nd l ne nf">(integer) 1</span><span id="698e" class="nb lq it mx b gy ng nd l ne nf">127.0.0.1:6379&gt; TTL "venue:redis-porto"</span><span id="187c" class="nb lq it mx b gy ng nd l ne nf">(integer) 108</span></pre><p id="3024" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们想要更新密钥的生存时间，我们可以再次使用<a class="ae lo" href="https://redis.io/commands/expire" rel="noopener ugc nofollow" target="_blank"> EXPIRE </a>。</p><p id="6dc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们想完全删除生存时间，我们可以使用<a class="ae lo" href="https://redis.io/commands/persist" rel="noopener ugc nofollow" target="_blank"> PERSIST </a>。</p><h1 id="ab5a" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.6关于数据大小的考虑</h1><p id="d18a" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">当使用以太网访问redis时，将数据大小保持在以太网数据包大小(约1500字节)之下可以保持总体峰值性能，这意味着对于Redis服务器来说，处理10个字节、100个字节或1000个字节会在吞吐量方面产生几乎相同的结果。尽管如此，您应该始终考虑您自己的应用程序(进行查询的应用程序)中数据大小的影响。参见下面链接的名为“每个数据大小的吞吐量”的图表:<a class="ae lo" href="https://redis.io/topics/benchmarks" rel="noopener ugc nofollow" target="_blank">https://redis.io/topics/benchmarks</a>。</p><h1 id="2139" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.7后续步骤:</h1><p id="25f8" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">我们这一系列文章的目的是介绍一个主题和主要关注点，希望您能深入了解在<a class="ae lo" href="https://redis.io/commands" rel="noopener ugc nofollow" target="_blank">https://redis.io/commands</a>上可用和有据可查的操作范围。关于所有Redis字符串命令，请参考<a class="ae lo" href="https://redis.io/commands#string" rel="noopener ugc nofollow" target="_blank">https://redis.io/commands#string</a>。我们希望在这篇文章和我们的聚会上看到关于你最喜欢的项目和关注点的评论。</p><p id="8ffe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文的第2部分将是对Redis列表和HASHs数据类型的介绍，让您对可用的操作有一个基本的了解，以及它们如何在实际例子中有用。</p></div></div>    
</body>
</html>