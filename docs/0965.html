<html>
<head>
<title>React with(out) MobX (part 1 of 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与(out) MobX反应(第1部分，共2部分)</h1>
<blockquote>原文：<a href="https://itnext.io/react-with-out-mobx-part-1-of-2-b540a7e631a9?source=collection_archive---------4-----------------------#2018-06-25">https://itnext.io/react-with-out-mobx-part-1-of-2-b540a7e631a9?source=collection_archive---------4-----------------------#2018-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5f64" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在不“污染”您的存储和组件的情况下获得MobX的所有好处</h2></div><p id="33c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">这篇文章展示了我在开发</em><a class="ae lc" href="https://www.timefic.com" rel="noopener ugc nofollow" target="_blank"><em class="lb">【timefic.com】</em></a><em class="lb">的过程中的另一段旅程，从React components with explicit MobX inside components and stores，到React components and stores where</em><strong class="kh ir"><em class="lb">根本没有单独引用MobX</em></strong><em class="lb">，但仍然在幕后使用MobX。</em></p><p id="ef4e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你为什么要这么做？</p><p id="195a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的好处是:</p><ul class=""><li id="61ff" class="ld le iq kh b ki kj kl km ko lf ks lg kw lh la li lj lk ll bi translated">减少了样板文件，提高了代码的可读性。</li><li id="b222" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">代码中不需要装饰者。</li><li id="455b" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">组件和存储更好的可测试性。</li><li id="c8c5" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">声明性和框架不可知的代码。</li></ul><blockquote class="lr ls lt"><p id="08f0" class="kf kg lb kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated">我将向您展示的方法不仅仅是React和MobX的配方，而是一种模式，一种可以在您开发的任何应用程序中使用的设计原则！<em class="iq">💪</em></p></blockquote><h2 id="fd0a" class="lx ly iq bd lz ma mb dn mc md me dp mf ko mg mh mi ks mj mk ml kw mm mn mo mp bi translated">场景1:标准方法</h2><p id="9e9f" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">当你使用MobX和React时，你需要考虑MobX在你的应用中的两个地方:</p><ul class=""><li id="b2da" class="ld le iq kh b ki kj kl km ko lf ks lg kw lh la li lj lk ll bi translated">在组件级，其中组件观察来自商店和/或本地状态的道具。</li><li id="7484" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">在商店级别，您为组件和其他商店准备要使用的数据。</li></ul><p id="7553" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">组件级</strong></p><p id="3165" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在组件级别，您将在整个应用程序中使用mobx-react库提供的<strong class="kh ir">观察者</strong>功能:<em class="lb">这是mobx中提高性能的常见做法，因为MobX实现了自己的</em><strong class="kh ir"><em class="lb">should component update</em></strong><em class="lb">生命周期方法(</em> <a class="ae lc" href="https://mobx.js.org/best/react-performance.html" rel="noopener ugc nofollow" target="_blank"> <em class="lb">在此阅读更多信息</em> </a> <em class="lb">)。</em></p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/8b57506e1fc37ea19f5b7f7dcc42a0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBypVRdTTcnna_HGuzA-QQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">有状态React组件(观察本地状态变化)</figcaption></figure><p id="c919" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且，如果您的组件需要本地状态(不需要向外部公开的状态)，您还将使用mobx库中的<strong class="kh ir">可观察的</strong>和<strong class="kh ir">计算的</strong>函数(或装饰器，如图所示)。</p><p id="653e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在任何情况下，当观察到的任何属性发生变化时，无状态或有状态组件将自动重新呈现。</p><p id="0a13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">商店级别</strong></p><p id="e130" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个mobx商店是完整的“mobx领域”，这里没有反应。在商店里，你基本上定义了两件事:</p><ul class=""><li id="fa4c" class="ld le iq kh b ki kj kl km ko lf ks lg kw lh la li lj lk ll bi translated"><strong class="kh ir">可观察数据</strong>，形式为<em class="lb">可观察属性</em>(显式更新的原语)和<em class="lb">计算属性</em>(数据自动从原语和其他计算属性中扣除)。</li><li id="33e5" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated"><strong class="kh ir">修改数据</strong>的事件，以<em class="lb">动作</em>(通常由用户触发)或<em class="lb">反应</em>(通常由应用程序内数据的某些条件触发)的形式出现。</li></ul><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nl"><img src="../Images/e591fd25073c364e6bde2847b4910831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2QzKpgdLRUbF2suK5DBrg.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">典型的MobX商店:可观察的数据、动作和反应</figcaption></figure><p id="b586" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">那么，我的app(前端)与MobX的“妥协”程度如何？</strong>我会说<strong class="kh ir"> 70% </strong>，也就是说，前端10个文件中有7个在使用一些从mobx或者mobx-react库导入的函数。</p><blockquote class="lr ls lt"><p id="bf0f" class="kf kg lb kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated">这没有错。严格来说，场景1和场景2(我现在将向您展示)在性能方面表现相同。不同之处在于开发人员的观点:可读性、可测试性、减少的样板文件和对未来变化的更好准备。</p></blockquote><h2 id="f3ba" class="lx ly iq bd lz ma mb dn mc md me dp mf ko mg mh mi ks mj mk ml kw mm mn mo mp bi translated">场景2:“独立于MobX”的方法</h2><blockquote class="nm"><p id="c703" class="nn no iq bd np nq nr ns nt nu nv la dk translated">简而言之:想法是使用MobX，但不引用它。</p></blockquote><p id="2f7d" class="pw-post-body-paragraph kf kg iq kh b ki nw jr kk kl nx ju kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated"><strong class="kh ir">组件级</strong></p><p id="9d8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在组件级别，我们将做一个简单的调整:</p><ul class=""><li id="3889" class="ld le iq kh b ki kj kl km ko lf ks lg kw lh la li lj lk ll bi translated">将mobx <strong class="kh ir">观察器</strong>功能替换为<strong class="kh ir"> hoc </strong>(高阶组件)功能。</li></ul><p id="32d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。</p><p id="e7cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特设T17最基本的实现是这样的:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ob"><img src="../Images/8bbc15e977be20f4591a0cde40ff188c.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*yc56WlqQlryRkocxfMvyDw.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">使子组件成为观察者的hoc(高阶组件)的基本实现</figcaption></figure><p id="5421" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">看起来像个笑话，但不是</strong>:我们将构建一个特设组件，在我们的应用程序中使用。这个特设机构将赋予其子女超能力:</p><ul class=""><li id="dd30" class="ld le iq kh b ki kj kl km ko lf ks lg kw lh la li lj lk ll bi translated">会让他们成为Mobx商店的观察员。</li><li id="97f8" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">会提供商店作为道具。</li><li id="d5aa" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">将允许调用生命周期方法作为道具。</li><li id="e871" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">将允许自动调试。</li><li id="c17b" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">将使我们的组件更容易测试。</li></ul><p id="6cb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看在<a class="ae lc" href="https://www.timefic.com" rel="noopener ugc nofollow" target="_blank">timefic.com</a>中使用的这个<strong class="kh ir"> hoc </strong>的当前版本:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a29d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道这段代码可能会让你感到困惑:但是，它是从我之前向你展示的基本实现发展到这个“多用途”组件的。</p><blockquote class="lr ls lt"><p id="f29c" class="kf kg lb kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated">背后的概念很简单:使用一个单一的、多用途的、高阶的组件来“装饰”层次结构中的所有组件。您的组件需要的任何数据或行为将由这个<strong class="kh ir">特设</strong>组件提供。</p></blockquote><p id="7655" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这种方法，可以简单地忽略所有这些模式和库:</p><ul class=""><li id="d448" class="ld le iq kh b ki kj kl km ko lf ks lg kw lh la li lj lk ll bi translated">反应上下文</li><li id="06af" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">提供者/消费者模式(如MobX和Redux)</li><li id="7a71" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">将道具从父级传递到嵌套很深的子级</li><li id="7c53" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">需要定义为类的组件，因为它们有生命周期方法。</li><li id="52df" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">render方法中的本地“console.log ”,以查看某个组件在假定不进行重新渲染时是否进行了重新渲染(或者您能想到的任何其他调试功能)。</li><li id="43d5" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">用来自假冒商店的数据水化组件，测试你的组件，因为它有简单的功能(它们是！)</li></ul><blockquote class="lr ls lt"><p id="a4e7" class="kf kg lb kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated">在一个大尺寸的应用程序中，处理一些复杂的事情和许多简单的事情比处理相同数量的中等复杂程度的事情要容易得多。</p></blockquote><p id="b4b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">复杂的东西</strong>，比如这个特设功能，将成为你的工具带、模式、架构选择的一部分，甚至可能成为未来的一个框架。经过一段时间的稳定，你不会再看到这些文件。它们只会工作，不会占据你大脑的任何空间。</p><p id="acf2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">更简单的东西</strong>将成为你的应用程序的实际组成部分。你每天都会看到它们，所以越简单越好。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/ef80a92e48e42295695cba2263550fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*QmAGKnwKHLMpLc_Kr2PJwg.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">具有由特设功能提供的“超级能力”的React组件</figcaption></figure><p id="c203" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你可能注意到的，当你遵循这种模式<strong class="kh ir">时，你将导出你的应用程序的每个组件正好两次</strong>:</p><ul class=""><li id="7fb1" class="ld le iq kh b ki kj kl km ko lf ks lg kw lh la li lj lk ll bi translated"><strong class="kh ir">命名导出</strong>是一个简单的“哑”组件。它从外部接收所有的属性(特设函数)，没有生命周期方法，没有状态，没有观察者装饰器。如果您愿意，可以独立使用该组件进行快照测试(只需传递props并检查输出)。</li><li id="287b" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated"><strong class="kh ir">默认的导出</strong>是增强的组件，这个组件实际上是跨应用程序呈现的。这个增强是一个简单的“不可见的”observer装饰器(每个组件的默认设置)，加上作为props传递的所有存储(也是每个组件的默认设置)，再加上一些您可能需要的额外行为，在本例中是生命周期方法。</li></ul><p id="8ec4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以注意到:</p><ul class=""><li id="b5e3" class="ld le iq kh b ki kj kl km ko lf ks lg kw lh la li lj lk ll bi translated">组件<strong class="kh ir"/></li><li id="3d60" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">子组件<strong class="kh ir"> &lt; Cursor/ &gt; </strong>和<strong class="kh ir">&lt;slides with count down/&gt;</strong>不需要从其父组件接收任何道具。但是，因为它们也在自己的文件中定义了一个hoc，所以它们可以访问上下文中的所有内容。</li><li id="d344" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">如果需要，子组件可以从其父组件接收道具，例如在迭代循环中。所有这些道具都在一个名为“inner”的对象中传递。</li><li id="d55b" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">默认导出中的<strong class="kh ir"> DidMount </strong>属性(以及剩余的生命周期属性)也可以访问属性，这也是模块的所有上下文。</li></ul><blockquote class="lr ls lt"><p id="93e1" class="kf kg lb kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated">在timefic中，<strong class="kh ir">上下文</strong>被定义为一个对象，该对象具有:<strong class="kh ir">动作</strong>(应用在商店级别定义的所有动作；动作被传递给要附加到事件处理程序的组件)、<strong class="kh ir">数据</strong>(来自后端或仅存储在本地的应用程序数据)、<strong class="kh ir">状态</strong>(保存所有ui状态的单个存储)、<strong class="kh ir">内部</strong>(从父级显式传递的属性)和<strong class="kh ir">实用程序</strong>(设置、路由器对象和组件中可能需要的其他实用程序)。</p></blockquote><p id="4fba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在要对文章开头所做的“承诺”进行核对:</p><ul class=""><li id="4ae1" class="ld le iq kh b ki kj kl km ko lf ks lg kw lh la li lj lk ll bi translated"><strong class="kh ir">减少样板文件:</strong>只要避免从父组件向下传递道具，就可以大大减少样板文件(和错误)。它使编码变得更有趣，并鼓励开发人员尽可能多地划分组件(当您需要一直将道具传递给孩子时，划分一个组件就成了一项繁琐的任务)。</li><li id="058a" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated"><strong class="kh ir">没有装饰器/更好的可测试性:</strong>当你需要测试组件(和我们将看到的存储)时，有装饰器可能会对你使用的测试套件造成问题。只有常规的react组件更安全。</li><li id="6a32" class="ld le iq kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated"><strong class="kh ir">框架不可知代码</strong>:如果明天有比MobX更好的替代方案会怎样？请记住，因为我们只在一个文件中导入mobx，所以我们所有的代码都不知道我们使用的是什么反应式状态管理框架。其原语可以命名为<strong class="kh ir">可观察的</strong>、<strong class="kh ir">计算的</strong>、<strong class="kh ir">观察者</strong>和<strong class="kh ir">动作</strong>或<strong class="kh ir">单元格</strong>、<strong class="kh ir">公式</strong>、<strong class="kh ir">观察者</strong>和<strong class="kh ir">更新</strong>。我们应该只调整特设功能，其余的都保持不变。</li></ul><p id="ad8b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文的第二部分，我们将继续展示<strong class="kh ir">如何实现一个<em class="lb">全功能的</em> MobX存储</strong>，完全不涉及MobX。</p><p id="15f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它追求同样的好处，并使程序员的生活更加愉快😀！！</p><p id="2959" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续此处的<a class="ae lc" href="https://medium.com/@jmaguirrei/react-with-out-mobx-part-2-of-2-a927d87fcd2" rel="noopener">第二部分</a>。</p></div></div>    
</body>
</html>