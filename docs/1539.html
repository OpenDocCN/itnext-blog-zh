<html>
<head>
<title>Prometheus With AlertManager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带警报器的普罗米修斯</h1>
<blockquote>原文：<a href="https://itnext.io/prometheus-with-alertmanager-f2a1f7efabd6?source=collection_archive---------0-----------------------#2018-11-19">https://itnext.io/prometheus-with-alertmanager-f2a1f7efabd6?source=collection_archive---------0-----------------------#2018-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/92c1d570690af55e34bcd713485142f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qHCuSdfq6eKpePUX"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Hugo Jehanne 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7274" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有警报，监控是不完整的。我们已经在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/monitoring-with-prometheus-using-ansible-812bf710ef43">上一篇</a>中看过普罗米修斯的监控。在本文中，我们将讨论使用ansible设置警报和AlertManager。<a class="ae kc" href="https://prometheus.io/docs/alerting/alertmanager/" rel="noopener ugc nofollow" target="_blank"> AlertManager </a>是一个单独的二进制程序，处理Prometheus服务器发送的警报并通知最终用户。</p><p id="c9b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了防止停机发生，我们需要依靠监控和警报。监控有助于预测潜在问题或通知我们系统中的当前问题，并提供有关问题的详细信息。警报有助于在问题发生时立即发出通知。警报对于监控至关重要。它们允许团队通过电话、通知或其他媒介来识别问题，以便团队可以快速采取行动，并最大限度地减少关键系统停机时间。在任何系统中，监控和警报都应被视为一等公民。普罗米修斯中的警戒分为两部分。首先，预警规则是在Prometheus配置中定义的。如果达到任何警报条件，Prometheus将向警报管理器发送警报。其次，AlertManager通过其静默、禁止、分组和发送通知的管道来管理警报。静音是将警报静音一段时间。检查警报是否与活动的静默警报匹配，如果发现匹配，则不发送通知。抑制是指在其他警报已经触发的情况下，抑制某些警报的通知。将性质相似的组警报分组到单个通知中。这有助于防止同时触发多个通知。</p><p id="ec22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Prometheus的报警设置步骤如下:</p><ol class=""><li id="1bcd" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">设置和配置AlertManager。</li><li id="32ab" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在Prometheus上配置配置文件，以便它可以与AlertManager通信。</li><li id="a822" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在Prometheus服务器配置中定义警报规则。</li><li id="a5b4" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在AlertManager中定义警报机制，通过Slack、电子邮件、PagerDuty等发送警报。</li></ol><p id="9e8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用Ansible设置AlertManager。首先，我们需要创建“alertmanager”用户和用户组，这有助于隔离AlertManager服务的所有权并提供安全性。该用户不能修改不属于自己的数据。该用户不能登录实例，只能在实例内部使用。我们使用可变变量来提供灵活性。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="48ba" class="ly lz iq lu b gy ma mb l mc md">- name: Creating alertmanager user group<br/>  group: name="{{groupId}}"<br/>  become: true</span><span id="8f5b" class="ly lz iq lu b gy me mb l mc md">- name: Creating alertmanager user<br/>  user:<br/>    name: "{{userId}}"<br/>    group: "{{groupId}}"<br/>    system: yes<br/>    shell: "/sbin/nologin"<br/>    comment: "{{userId}} nologin User"<br/>    createhome: "no"<br/>    state: present</span></pre><p id="4492" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将下载并安装拥有AlertManager用户所有权的alertmanager。安装后，清理安装过程所需的所有临时文件。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="851d" class="ly lz iq lu b gy ma mb l mc md">- name: Download alertmanager<br/>  unarchive:<br/>    src: "<a class="ae kc" href="https://github.com/prometheus/alertmanager/releases/download/v{{" rel="noopener ugc nofollow" target="_blank">https://github.com/prometheus/alertmanager/releases/download/v{{</a> version }}/alertmanager-{{ version }}.linux-amd64.tar.gz"<br/>    dest: /tmp/<br/>    remote_src: yes</span><span id="fbe3" class="ly lz iq lu b gy me mb l mc md">- name: Copy alertmanager executable to bin<br/>  copy:<br/>    src: "/tmp/alertmanager-{{ version }}.linux-amd64/alertmanager"<br/>    dest: "/usr/local/bin/alertmanager"<br/>    owner: "{{userId}}"<br/>    group: "{{groupId}}"<br/>    remote_src: yes<br/>    mode: 0755</span><span id="c16f" class="ly lz iq lu b gy me mb l mc md">- name: Delete alertmanager tmp folder<br/>  file:<br/>    path: '/tmp/alertmanager-{{ version }}.linux-amd64'<br/>    state: absent</span></pre><p id="9d37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将把AlertManager配置文件复制到AlertManager服务使用的实例中。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="925b" class="ly lz iq lu b gy ma mb l mc md">- name: Copy config file<br/>  copy:<br/>    src: "{{ role_path }}/files/alertmanager.yml"<br/>    dest: /etc/alertmanager/alertmanager.yml</span></pre><p id="ab9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们设置好运行AlertManager的一切，我们将复制systemctl init文件来管理它。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="7699" class="ly lz iq lu b gy ma mb l mc md">- name: Copy systemd init file<br/>  template:<br/>    src: init.service.j2<br/>    dest: /etc/systemd/system/alertmanager.service<br/>  notify: systemd_reload</span></pre><p id="ab4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是启动AlertManager，这样它就可以基于更新后的配置文件工作。然后，我们通过在端口9093发出HTTP调用并确认何时收到200响应来检查它是否按预期工作。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="105f" class="ly lz iq lu b gy ma mb l mc md">- name: Start alertmanager service<br/>  service:<br/>    name: alertmanager<br/>    state: started<br/>    enabled: yes</span><span id="ab28" class="ly lz iq lu b gy me mb l mc md">- name: Check if alertmanager is accessible<br/>  uri:<br/>    url: <a class="ae kc" href="http://localhost:9093" rel="noopener ugc nofollow" target="_blank">http://localhost:9093</a><br/>    method: GET<br/>    status_code: 200</span></pre><p id="c053" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们已经在端口9093的实例上运行了AlertManager。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/1c4c24040e1138c1a30bb95ed25b0ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cbtFR0iqFzgIpVhWvuAysA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">没有要触发的警报的警报管理器</figcaption></figure><p id="efa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要配置Prometheus服务器，以便它可以与AlertManager服务对话。我们将建立一个警报规则文件，它定义了触发警报所需的所有规则。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="38ef" class="ly lz iq lu b gy ma mb l mc md">rule_files:<br/>  - alert.rules.yml</span><span id="419b" class="ly lz iq lu b gy me mb l mc md">alerting:<br/>  alertmanagers:<br/>  - static_configs:<br/>    - targets:<br/>      - 'alertmanagerIP:9093'</span></pre><p id="6be6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Prometheus服务器将跟踪传入的时间序列数据，一旦满足任何规则，就会向AlertManager服务触发警报。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="dca7" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">alert rule file</strong><br/>groups:<br/>- name: alert.rules<br/>  rules:<br/>  - alert: InstanceDown<br/>    expr: up == 0<br/>    for: 1m<br/>    labels:<br/>      severity: "critical"<br/>    annotations:<br/>      summary: "Endpoint {{ $labels.instance }} down"<br/>      description: "{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 1 minutes."</span></pre><p id="af42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的示例中，我们将创建一个警报规则来检查实例是否停机，如果停机时间超过1分钟，就会触发警报。我们可以使用Prometheus档案文件中的“<strong class="kf ir"> promtool </strong>”工具检查警报文件的语法是否正确。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="47bd" class="ly lz iq lu b gy ma mb l mc md">promtool check rules alert.rules.yml</span></pre><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/0302a047e42dd01d62afd72b9ea9efb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YzvdjPExQLsuRgzSgnQQYg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">没有激活警报的Prometheus服务器警报部分</figcaption></figure><p id="ebab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果任何被跟踪的实例停止运行，就会启动一个处于挂起状态的警报，直到它停止运行超过1分钟。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/00b8d5afef6d84709d85a7d089210035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c9yaAjYIn2xPpg2dWM9V7w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">InstanceDown警报处于挂起状态，直到它关闭超过1分钟</figcaption></figure><p id="9556" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦实例停机超过1分钟，警报就会激活并触发警报管理器。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/d8a1e2ae22777e43f214aad9a167f748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4fwtN6Wh9bInzkS2If2tA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">当实例停机超过1分钟时，将触发InstanceDown警报</figcaption></figure><p id="471d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AlertManager有自己的配置，一旦从Prometheus服务器收到警报，我们就可以触发Slack警报。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="02e4" class="ly lz iq lu b gy ma mb l mc md">global:<br/>  slack_api_url: "https://hooks.slack.com/services/SlackAPI"</span><span id="8c8f" class="ly lz iq lu b gy me mb l mc md">route:<br/>  group_by: ['instance', 'severity']<br/>  group_wait: 30s<br/>  group_interval: 5m<br/>  repeat_interval: 3h<br/>  routes:<br/>  - match:<br/>      alertname: InstanceDown<br/>  receiver: 'alert-team'</span><span id="ae99" class="ly lz iq lu b gy me mb l mc md">receivers:<br/>- name: 'alert-team'<br/>  slack_configs:<br/>  - channel: "#webhook-channel"<br/>    text: "summary: {{ .CommonAnnotations.summary }}\ndescription: {{ .CommonAnnotations.description }}"</span></pre><p id="51a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个配置中，我们定义了在触发警报时需要触发的slack webhook URL。创建webhook URL的说明可以在<a class="ae kc" href="https://api.slack.com/incoming-webhooks" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们定义“<strong class="kf ir"> group_by </strong>”，它对相似的警报进行分组。我们添加了“<strong class="kf ir"> group_wait </strong>”，它为特定的警报组设置发送警报的等待时间。"<strong class="kf ir"> group_interval </strong>"定义在发送有关添加到警报组的新警报之前等待的持续时间。"<strong class="kf ir"> repeat_interval </strong>"定义在触发已经发送的警报之前等待的持续时间。"<strong class="kf ir">匹配</strong>"检查警报名称，并根据该名称选择要使用的接收器。在这种情况下，我们使用slack作为警报接收者，并定义了webhook URL。</p><p id="580f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦从Prometheus服务器收到警报，它将等待group_wait时间，然后将其发送给slack webhook。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/556e4aab21fa1225ade31fe7eab163fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ssuZnJhN0glOPnvn8LGRA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">AlertManager收到来自Prometheus服务器的警报</figcaption></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/3f9c38c5075e33f6b346c91e944db27f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhwHLy-LJsS0oHUljJEopw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">从AlertManager收到时差警报</figcaption></figure><p id="8cc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的代码可以在这个git存储库中找到:<a class="ae kc" href="https://github.com/MiteshSharma/PrometheusAlertManagerWithAnsible" rel="noopener ugc nofollow" target="_blank">https://github . com/MiteshSharma/PrometheusAlertManagerWithAnsible</a></p><p id="f64e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="ml"> PS:如果你喜欢这篇文章，请鼓掌支持</em> </strong>👏<strong class="kf ir"> <em class="ml">。欢呼</em> </strong></p></div></div>    
</body>
</html>