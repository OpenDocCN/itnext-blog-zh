# 掌握 JavaScript 中的类型

> 原文：<https://itnext.io/mastering-types-in-javascript-66c43338a274?source=collection_archive---------0----------------------->

![](img/7f988dfbadba6bfa2353113911312e21.png)

讨厌别人用与主体无关的图像，smh-)

*读完这篇文章后，你会:*

*   *懂得如何用复杂的 JavaScript 来管理类型* *。*
*   *不再向用户显示******Null****或****undefined****。***
*   ***学习如何* ***类型检查*** *各种数据类型包括* ***整数*** *和* ***浮点数*** *。***

**除了基础知识之外，这里还有你在现实世界中构建可靠的关键业务应用程序所需要知道的关于 JavaScript 类型的一切。**

> **如果和平，就在战时**

# ****本文的先决条件****

**可选地[析构](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring)以使类型检查更具可读性。即**

***is("yo "，" yo") === Object.is("yo "，" yo")***

**在你玩之前，复制并粘贴到你的开发工具中:**

# **类型错误最常见的原因**

> ****TL；避免对**博士的 **if** 和**三元**语句进行隐式强制；总是比较。**

**依赖**隐式强制**获取条件会导致耗时的后果。因为它在大多数情况下都有效，所以需要训练来重新连接你的大脑以避免它。这样做可以避免将来浪费大量的调试时间。**

## **千万不要这样**

*   *****if(值)*** | *问题:0，null，“”，未定义，强制值，NaN === false。可以看出，对于非布尔型来说，这是一条危险的捷径。***
*   *****if(type of value = = = " object ")***|*Null 是对象，数组是对象***
*   ****如果(expectedNumberValue)** | *再次 0，NaN 将要挟为假***
*   ****if(type of expected number = = = " number ")**|*NaN 是一个数字***
*   ****if(isNaN(value))** | *避免因 isNaN 执行不熟悉的胁迫***

## **总是这样做**

*   ***显式布尔条件* ***if(值===真)****|****if(值===假)*****
*   ***显式函数条件****if(type of value = = = " function ")*****
*   ***显式空条件****if(value = = = " ")*****
*   ***显式零条件****if(value = = = 0)*****
*   ***显式空条件****if(value = = = null)*****
*   ***显式未定义条件****if(value = = = undefined)*****
*   ***显式 NaN 条件****if(is(parse float(value)，NaN))*****
*   ***是安全的，建议使用****null****，* ***未定义*** *和* ***NAN*****
*   **使用=== over ==。 **==不是更快**，===是显式，==是隐式**

## **一个例外**

**对于与条件相同范围内的**无限布尔值**和**的表达式，下面的 yes 仍然是显式类型检查。****

**结论:**用你所有的条件逻辑明确**。**

# **预防+治疗:何时“必须”执行检查？**

## **预防**

**N e *ar 你认为是一个* ***抽象层*** *或者* ***关注*** *的开始那就是接收数据。您不必对抽象中的每个函数进行类型检查，但至少要检查入口点。***

## **疗法**

***在* ***return 语句*** *的最后一个阶段* ***抽象层*** *或* ***关注点*** *即专门向另一层、服务器或用户等提供数据。不需要对抽象中的每个 return 语句进行类型检查。***

## **在中间**

**使用你的判断力来决定什么时候需要特定的类型检查，但是如果你发现你自己对每件事都进行类型检查，这很明显是因为你没有完全理解你的应用程序的整体情况。了解常见的 [*数据类型*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures) *并熟悉* [*强制*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness) *会有所帮助。***

## **纯函数**

**不惜一切代价避免副作用。在可行的情况下使用 *Object.freeze* 、 *Object.seal* 和 *const* 。**

**是的，预防比治疗更可取。但是 cure 给了你保护和选择其他结局的选择。两者兼得。**

# **类型检查器**

**您很少需要下面列出的大多数“自定义助手”。管理 JS 动态类型最重要的方面是有条件地**显式**，正如反复提到的。**

## **排列**

*   ***isArray(值)***

## **布尔代数学体系的**

*   ***值类型***

## **日期**

*   ***` $ { value } ` = = = ` $ { new Date(value . value of())} `***

## **错误**

1.  ***value.toString()。包含("错误")***
2.  ***` $ { value } ` . includes(" Error ")***

> **#2 没有调用内部 Object.prototype.toString 方法，而是调用值的。如果值恰好是错误的，则引发 toString 方法。**

## **功能**

*   ***值类型***

## **空**

1.  ***值===空***
2.  ***是(值，空)***

> **众所周知，typeof null === "object "**

## **数量:包括南**

*   ***值类型***

## **编号:隐楠**

*   ***！is(parseFloat(value)，NaN)***

> **该值将被强制为浮点数或 NaN。这通常比显式 NaN 类型检查更实用。以“0x”开头的字符串值。？？?"将被强制为预期的数字。**

## **数字:显式 NaN**

*   ***是(值，楠)***

> **没有强制，是直接检查值是否等于 NaN。这比伊斯南更符合。例如**是南({})** //真，**是({}，南)** //假。isNaN 执行不一致的强制，并且 NaN 不使用比较运算符(===)，因此始终使用 Object.is 进行直接的 no BS NaN 比较。**

## **数量:整数**

*   ***isInteger(值)***

> **在运行时，以非 10 为基数表示的值在算术上被视为以 10 为基数，并且由于整数本质上是浮点型的，因此会进行有意义的处理。**

## **数字:小数**

*   ***(数字(值)+" ")。包括(".")***

> **这并不是检查一个数字是否是浮点数，因为所有的 JavaScript 数字都是浮点数(因此 isFloat()解析所有数字)。所以我们检查一个数是否是小数，因为它在真实世界的应用中更有用。**
> 
> **该值被强制转换为数字，然后被强制转换为字符串。这确保了小数来自最终数值。**

## **目标**

*   **typeof value === "object" &&！isArray(value) &&！为(值，null)**

> **有经验的开发人员“通常”避免使用原型链或。用于检查对象类型的构造函数，因为它们很容易被重新赋值。**

## **正则表达式**

*   **is(正则表达式(值)，值)**

## **线**

*   **值的类型**

## **标志**

*   **值的类型**

## **不明确的**

1.  ***未定义===未定义***
2.  ***是(值，未定义)***

> **在 ES6 中，Undefined 是不可变的，而在 ES5 中，使用“use strict”是安全的。**

**下面是上面列出的所有非内置助手:**

**看着不太吓人吧，而且太容易解剖了*(上房)***

*****isObject*** 和 ***isANaN*** *可能是典型应用中最常用的。使用原始类型的* ***显式*** *将极大地减少对这些函数的需求。***

> **事实:我的名字来源于朱利叶斯·凯撒(他显然是个混蛋)。本文的主题是“入乡随俗”，因为这是 JavaScript 而不是 Java，所以不要偷懒，让我们继续一些动态类型的解决方案；)**

# **重新分类对象**

**您可以使用***symbol . tostring tag***对可重写对象进行重新分类。把它想象成复杂的鸭子打字。**

**这里显然没有真正的“类型检查”本身，但这是一种标记对象而不污染其属性集合(如果有的话)的方法。**

# **原始包装对象**

***以下是有用的数据类型:***

**一些开发人员认为他们的存在是一个错误，但这实际上是 ECMAScript 规范的一部分。**

***出于可移植性的原因，您可以自由地向这些类型添加属性:***

***并且在不改变内部值的情况下随意使用它们:***

***之后你仍然可以像普通的原始变量一样使用这个对象:***

**当你玩够了，你可以强迫包装者变成它的内在自我。无附带条件(眨眨眼):**

****没人告诉你的是，你可以很容易地检查他们的内在灵魂:****

**![](img/5ed054d978e813d77e40ff85de4da999.png)**

**[“你不知道，矮子就是一串！”](https://www.youtube.com/watch?v=SFHi-Ik8-Wg) —桁条铃**

**我撒谎了吗？即使是 20 多年的 JS 开发者也能从这篇文章中学到一些新东西。**

**原始对象包装上的最终势利眼。**

> **它们的存在并不意味着你需要过度使用它们。规矩点，有点礼貌。**

# **toString 型跳棋**

**这是 ECMAScript 规范的一部分，它允许您检查对象的类的标记，如前面的示例所示。我编造了第二个例子，但它通常做同样的事情，但有重要的优点和缺点:**

***toString 类型检查对于以下数据类型是可靠的:* ***数组、布尔、日期、错误、函数、Null、数字、对象、正则表达式、字符串、*** *和* ***未定义的*** *。其他数据类型可能在不同的浏览器和 JS 实现中不一致。***

**尽管这种方法看起来像是一种捷径，但并不完全如此，因为它不能区分 NaN、整数或小数。没有放之四海而皆准的解决方案，所有解决方案都一样有用。**

# **安全措施**

## **TL；博士；医生**

> ****没有回退值，不向用户输出任何内容。****

**看到 ***空，总:$南*** *或者* ***未定义****2018 年还在网站上显示*真是可悲。开发人员通常将这些缺陷归咎于语言，但我可以向你保证这是 100%的人为疏忽。**

## **保护是最佳实践**

**这会让你在最不经意的时候免于尴尬。**

> **始终为用户可能看到的所有动态内容提供一个/多个回退值。**

**在内容被呈现给*(例如)*DOM 之前立即这么做是很重要的。你不应该在保护之后操纵一个值。**

## **保护字符串值**

## **保护数字值**

## **保护图像路径**

# **打破神话:**

**尽管有些人声称，没有类型系统可以让 JavaScript 执行得更快。所有类型系统 *(TypeScript，PureScript，Flow)在运行时都使用动态类型*。**

**在大型代码库中，对类型的过度检查实际上会对性能产生负面影响(可能可以忽略不计)。**

**动态类型在 JavaScript 中一点也不慢。V8 引擎有许多优化，你可以在上阅读[。](https://blog.ghaiklor.com/optimizations-tricks-in-v8-d284b6c8b183)**

# **结论**

**让我们回顾一下:**

*   ***我们解决了 JavaScript 中* ***类型*** ***错误*** *的最常见原因。***
*   ***一头扎进一个简单的* ***预防+治疗*** *策略，在现实世界的代码基础上进行理想的动态类型检查。***
*   ***查看了* ***类型检查器*** *用于检查包括整数和 f̶l̶o̶a̶t̶s 小数在内的各种数据类型。(花车被点击-诱饵，我的坏)***
*   ***被认为是* ***对对象进行重分类*** *一种对对象进行分类而不污染其键的方法。***
*   ***发现* ***原始包装对象*** *并不是错误，你可以很容易地检查它们的类型。***
*   ***看了看* ***toString 类型的 Checkers*** *因为它们是专门为返回对象的内部分类而构建的，但是我们也知道它们对于检查内置对象是不可靠的。***
*   ***发现* ***安全保护*** *并承诺不再向用户显示 null、NaN 或 undefined。画十字，希望数学。圆周率***

**虽然您可能不会在网上找到太多展示本文中提到的实践的例子，但是如果您很聪明，您可能已经得出结论，JavaScript 是一种被极度误解的语言，并且许多人鄙视的一些怪癖中有一种美丽的艺术。**

**我在本文中创建了助手来解决生产应用程序中常见的问题，但是记住“最好的代码是没有代码”——有人在 Twitter 上说。**

**![](img/61765ee83caa0b7ffc4b2003d316ccb4.png)**

**当心这些可疑的打字者；-)**

**我创建了一个 JavaScript 类型检查器，但是从那以后我的理念已经改变了，你真的不需要一个库来检查 JavaScript 类型，函数是如此的小和少，创建一个[要点](https://gist.github.com/)然后就到此为止。**

## **感谢阅读；-)**

***彼此明确——比尔&泰德；——)***