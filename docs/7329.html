<html>
<head>
<title>Multi-Cloud Strategies Using Microservices Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用微服务架构的多云策略</h1>
<blockquote>原文：<a href="https://itnext.io/multi-cloud-strategies-using-microservices-architecture-8320aa708c37?source=collection_archive---------1-----------------------#2022-08-23">https://itnext.io/multi-cloud-strategies-using-microservices-architecture-8320aa708c37?source=collection_archive---------1-----------------------#2022-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fc9038e94cc40a399bc158105a065036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RXx3j19IfS80RU8PVl06w.jpeg"/></div></div></figure><h1 id="af1b" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">遵循这份在Azure、AWS和Google Cloud中构建微服务的完整指南，构建高可用性、可伸缩性和高性能的应用。</h1><p id="e7cc" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">2005年，Peter Rodgers博士在web Services Edge会议的一次演讲中谈到了微Web服务，当时第一代微Web服务是基于<a class="ae lx" href="https://www.redhat.com/en/topics/cloud-native-apps/what-is-service-oriented-architecture" rel="noopener ugc nofollow" target="_blank">面向服务的架构</a> (SOA)。SOA是作为任务执行的“自包含”软件模块，这允许服务基于SOAP(简单对象访问协议)进行通信。SOAP的主要思想是，“尽可能做最简单的事情。”</p><p id="8c00" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">如今，在架构呼叫期间，没有任何选项可以避免谈论微服务，尤其是如果您想要设计云或多云、模块化、可扩展和多用户应用程序。在本文中，我将解释微服务以及如何基于多云场景设计应用程序。我将带您了解微服务设计模式，并将这些信息包装到一个架构示例中。</p><blockquote class="md me mf"><p id="0d43" class="kz la mg lb b lc ly le lf lg lz li lj mh ma lm ln mi mb lq lr mj mc lu lv lw im bi translated"><em class="it">这是DZone 2022微服务和容器化趋势报告中的一篇文章。更多:</em> <a class="ae lx" href="https://dzone.com/trendreports/microservices-and-containerization" rel="noopener ugc nofollow" target="_blank"> <em class="it">阅读报道</em> </a></p></blockquote><h1 id="0cda" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">微服务和多云环境</h1><p id="33a6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在我们进入微服务架构、模式以及如何构建支持多云部署的基于微服务的应用之前，让我们先定义一下术语。微服务是一种架构模式，它允许应用程序由松散耦合的模块组成。然而，微服务设计应遵循以下规则:</p><ul class=""><li id="980e" class="mk ml it lb b lc ly lg lz lk mm lo mn ls mo lw mp mq mr ms bi translated">每个模块或微服务都有自己的数据，因此应该有独立的数据库。</li><li id="2dba" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">每个微服务都应该由自己的团队开发。这并不意味着基于微服务的应用不能由一个团队开发，然而，每个微服务有一个团队显示了微服务可以多么独立。</li><li id="2ff4" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">微服务应该有独立的部署流程。</li><li id="296f" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">微服务应该能够更好地控制资源和计算能力，以便您可以根据服务需求独立扩展每项服务。</li><li id="e6fc" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">微服务可以用不同的语言编写，但是要用像<a class="ae lx" href="https://dzone.com/refcardz/rest-foundations-restful" rel="noopener ugc nofollow" target="_blank"> REST </a>这样的单一协议进行通信。</li></ul><p id="788c" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">多云(即混合云)意味着有两种不同的方法来通过多个云提供商传播应用程序。例如，我们可以在AWS中构建核心应用程序，还有一些部分可以部署到Azure和Google Cloud。另一个多云的例子是，为一个云设计的应用程序只需稍加修改就可以迁移到另一个云。</p><h1 id="04cf" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">微服务与整体服务</h1><p id="bfea" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在开始举例之前，我们先来看一下微服务和整体架构的优缺点:</p><h2 id="96d7" class="my kc it bd kd mz na dn kh nb nc dp kl lk nd ne kp lo nf ng kt ls nh ni kx nj bi translated">优点:微型服务</h2><ul class=""><li id="478d" class="mk ml it lb b lc ld lg lh lk nk lo nl ls nm lw mp mq mr ms bi translated"><strong class="lb iu">可扩展性</strong> —由于我们拥有所有独立的服务，我们可以独立扩展每项服务。</li><li id="2e92" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated"><strong class="lb iu">隔离</strong> —当一个服务停止时，一个大型项目可能不会受到影响。</li><li id="fd7a" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated"><strong class="lb iu">灵活性</strong> —你可以使用不同的语言和技术，因为所有的服务都是独立的。我们可以将整个项目分成微服务，每个微服务将由单独的团队开发和支持。</li><li id="daf2" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated"><strong class="lb iu"> DevOps独立</strong> —所有微服务独立；因此，我们可以为每个微服务实现独立的部署流程。</li></ul><h2 id="248d" class="my kc it bd kd mz na dn kh nb nc dp kl lk nd ne kp lo nf ng kt ls nh ni kx nj bi translated">缺点:</h2><ul class=""><li id="35de" class="mk ml it lb b lc ld lg lh lk nk lo nl ls nm lw mp mq mr ms bi translated"><strong class="lb iu">复杂性</strong> —对于大型企业级公司和平台来说，微服务架构是一个不错的选择。以网飞为例。在那里，你可以将域和子域划分给不同的服务和团队。然而，对于小型公司来说，分离可能会增加多余的复杂性。此外，将小项目分成微服务也是不可能的。</li><li id="57a8" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated"><strong class="lb iu">测试</strong> —测试微服务应用可能是一项艰巨的任务，因为您可能需要运行其他服务。</li><li id="d6ac" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated"><strong class="lb iu">调试</strong> —调试微服务可能是一项痛苦的任务；它可能包括运行几个微服务。此外，我们需要不断地调查日志。这个问题可以通过集成监控平台来部分解决。</li></ul><p id="a25f" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">当我开始设计一个解决方案时，我总是将单片架构作为起点。使用这种方法，我们可以实现以下目标:</p><ul class=""><li id="4a4d" class="mk ml it lb b lc ly lg lz lk mm lo mn ls mo lw mp mq mr ms bi translated">在设计和实现期间，我们已经可以看到我们的应用程序是否可以迁移到微服务。</li><li id="f771" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">我们可以通过一步一步的方法确定可以迁移到微服务的整体应用。</li></ul><h2 id="3233" class="my kc it bd kd mz na dn kh nb nc dp kl lk nd ne kp lo nf ng kt ls nh ni kx nj bi translated">赞成:整体</h2><ul class=""><li id="3c24" class="mk ml it lb b lc ld lg lh lk nk lo nl ls nm lw mp mq mr ms bi translated"><strong class="lb iu">简单性</strong> —单片架构相对简单，可用作基础架构或微服务的第一步。</li><li id="7fd3" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated"><strong class="lb iu">简单的开发运维</strong> —开发运维流程可以很简单，因为我们可能需要自动化一个简单的应用。</li></ul><h2 id="0ca2" class="my kc it bd kd mz na dn kh nb nc dp kl lk nd ne kp lo nf ng kt ls nh ni kx nj bi translated">缺点:</h2><ul class=""><li id="ee59" class="mk ml it lb b lc ld lg lh lk nk lo nl ls nm lw mp mq mr ms bi translated"><strong class="lb iu">供应商锁定</strong> —对于整体架构，我们可能会被一家供应商/云提供商锁定。整体架构中的所有模块彼此紧密相连。很难将它们分散到不同的供应商。</li><li id="2045" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated"><strong class="lb iu">不灵活的开发运维</strong> —一个企业级整体应用的开发运维流程可能会花费大量时间，因为我们需要等待所有模块构建完成并经过测试。</li><li id="f869" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated"><strong class="lb iu">坚持使用一种编程语言/技术</strong>——整体架构不太灵活——你需要坚持使用一种技术/编程语言。否则，你必须重写整个应用程序来改变核心技术。</li></ul><p id="64ac" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在图1中，你可以看到一个典型的旅行系统模块化整体架构的例子。它允许乘客找到司机，预订，并加入旅行。</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/b66e95db858151735b58f364f7da3fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4yDabqYzXUutho1HokG8Q.jpeg"/></div></div></figure><p id="4b62" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="mg">图1:旅游预订应用</em></p><p id="db10" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">该系统由几个模块组成:</p><ul class=""><li id="8032" class="mk ml it lb b lc ly lg lz lk mm lo mn ls mo lw mp mq mr ms bi translated">用户界面/前端</li><li id="500c" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">应用程序接口</li><li id="e6d4" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">SQL适配器</li><li id="8e3b" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">处理支付的条带适配器</li><li id="3f8c" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">发送网格来管理电子邮件</li><li id="9b81" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">Twillio适配器，能够通过电话进行通信(通话、短信、视频)</li></ul><p id="abe0" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这种整体架构可以迁移到微服务架构。每个服务都可以独立运行，并且可以将状态保存在自己的数据库中。</p><p id="97b7" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">上面解释的解决方案非常简单，可以转化为微服务，没有很多问题。然而，当涉及到企业级别时，这种迁移要复杂得多，就像在网飞这样的大公司中看到的那样。</p><h1 id="366e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">用于构建微服务架构的云组件和服务</h1><p id="52fd" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在本节中，我们将了解一些可用于构建微服务架构的云服务，以便我们知道在微服务架构设计和实施期间选择什么服务或云组件。</p><h1 id="f5d7" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">集装箱发动机</h1><p id="8448" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">容器引擎对于构建微服务至关重要，因为它们允许在不同的云提供商中分离、编排和管理微服务。Docker 是一个广泛使用的容器引擎，它允许人们将每个微服务包装到一个容器中，并将其放入基于云的容器编排系统，如Kubernetes (AKS，EKS)或直接启动应用程序。Containerd 与Docker相同，但具有轻量级和更安全的架构。</p><h1 id="298b" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">管弦乐演奏家</h1><p id="0735" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">Kubernetes是一个流行的开源系统，用于编排、自动化部署和扩展容器应用。它包含并自动化了部署。<a class="ae lx" href="https://docs.microsoft.com/en-us/azure/aks/" rel="noopener ugc nofollow" target="_blank"> Azure </a>、<a class="ae lx" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank"> AWS </a>和<a class="ae lx" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> Google Cloud </a>拥有自己的托管编排服务，这些服务已经包括负载平衡、自动扩展、工作负载管理、监控和一个<a class="ae lx" href="https://docs.microsoft.com/de-de/azure/aks/open-service-mesh-about" rel="noopener ugc nofollow" target="_blank">服务网格</a>。</p><p id="e6eb" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><a class="ae lx" href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview" rel="noopener ugc nofollow" target="_blank"> Azure Service Fabric </a>是一个编排微服务的分布式平台。几年来，我们的主要目标是为。基于NET Core/Framework和Windows的微服务；我们可以在<a class="ae lx" href="https://docs.microsoft.com/en-us/azure/architecture/guide/technology-choices/images/compute-choices.png" rel="noopener ugc nofollow" target="_blank">选择服务流程图</a>中看到。微软声称Service Fabric也支持其他语言和平台，比如Linux。</p><h1 id="4e65" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">消息总线</h1><p id="5c17" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><a class="ae lx" href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29" rel="noopener ugc nofollow" target="_blank">队列</a>是一种基于FIFO(先进先出)原则的服务。所有的消息总线系统都基于这个服务。例如，Azure有包含简单业务逻辑的<a class="ae lx" href="https://docs.microsoft.com/en-us/azure/storage/queues/storage-queues-introduction" rel="noopener ugc nofollow" target="_blank">队列存储</a>。如果您有一个需要集中消息存储的简单体系结构，您可以依赖队列。AWS和Google Cloud也分别有<a class="ae lx" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank">简单队列服务</a>和<a class="ae lx" href="https://cloud.google.com/tasks/docs/comp-pub-sub" rel="noopener ugc nofollow" target="_blank"> GC Pub/Sub </a>。这些允许您在微服务和软件组件之间发送、存储和接收消息。</p><p id="2a71" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><a class="ae lx" href="https://www.enterpriseintegrationpatterns.com/MessageBus.html" rel="noopener ugc nofollow" target="_blank">服务总线/消息总线</a>基于与队列相同的方法。然而，消息总线有更多的特性——它包含死信队列、预定交付、消息延迟、事务、重复检测和许多其他特性。例如，<a class="ae lx" href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-overview" rel="noopener ugc nofollow" target="_blank"> Azure Service Bus </a>和<a class="ae lx" href="https://aws.amazon.com/msk/" rel="noopener ugc nofollow" target="_blank"> AWS Managed Kafka service </a>是企业级应用程序的高可用性消息代理，可以处理成千上万的消息。</p><h1 id="3f72" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">无服务器</h1><p id="3723" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">无服务器允许我们纯粹通过事件驱动的方法来构建微服务架构。它是一个按需提供的云服务单元，旨在直接在云中构建微服务，而无需考虑应该使用什么容器引擎、orchestrator或云服务。AWS和Azure分别有<a class="ae lx" href="https://docs.aws.amazon.com/whitepapers/latest/serverless-multi-tier-architectures-api-gateway-lambda/microservices-with-lambda.html" rel="noopener ugc nofollow" target="_blank"> Lambda </a>和<a class="ae lx" href="https://docs.microsoft.com/en-us/azure/azure-functions/" rel="noopener ugc nofollow" target="_blank"> Azure函数</a>。<a class="ae lx" href="https://cloud.google.com/blog/products/serverless/serverless-from-the-ground-up-building-a-simple-microservice-with-cloud-functions-part-1" rel="noopener ugc nofollow" target="_blank">谷歌云功能</a>遵循同样的原理。</p><h1 id="11c0" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">基本微服务设计模式</h1><p id="4caa" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在我们了解了微服务架构，可以开始使用微服务开发应用程序了。我们也了解使用微服务的好处，以及如何重构应用程序来支持这种架构。构建应用程序的最佳起点是了解微服务设计模式。</p><h1 id="467c" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">领域微服务</h1><p id="6ba0" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">微服务领域模型(<a class="ae lx" href="https://martinfowler.com/bliki/DomainDrivenDesign.html" rel="noopener ugc nofollow" target="_blank">领域驱动设计</a>的一部分)不仅仅是一个模式——它是一组设计和界定微服务的原则。应使用以下规则设计微服务域:</p><ul class=""><li id="5eed" class="mk ml it lb b lc ly lg lz lk mm lo mn ls mo lw mp mq mr ms bi translated">单个微服务应该是独立的业务功能。因此，整个服务应该局限于单个业务概念。</li><li id="8748" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">业务逻辑应该封装在基于REST的API中。</li></ul><h1 id="deb0" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">反腐败层</h1><p id="b931" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">遗留系统可能有不可维护的代码和总体不佳的设计，但是我们仍然依赖来自这个模块的数据。反腐败层提供了新微服务架构和传统架构之间的外观或桥梁。因此，它允许我们远离操纵遗留代码，专注于特性开发。</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/14624d2f12caa2e31cddcd50af93e943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJlPjebyn77DBuzNWxh_ew.jpeg"/></div></div></figure><p id="4a78" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="mg">图2:防腐层</em></p><h1 id="eb7c" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">断路器</h1><p id="2415" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">断路器提供了阻止级联失效并自动恢复到正常状态的机制。假设我们有服务A和服务B，它们依赖于来自服务C的数据。我们在服务C中引入了一个影响服务A和B的错误。在一个设计良好的微服务架构中，每个服务都应该相互独立。</p><p id="b97e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">然而，从整体到微服务的重构过程中可能会出现依赖性。在这种情况下，您需要实现一个断路器来预测级联故障。断路器充当状态机。他们监控大量最近的故障，并决定下一步做什么。它们可以允许运行(<strong class="lb iu">关闭</strong>状态)或返回异常(<strong class="lb iu">打开</strong>或<strong class="lb iu">半开</strong>状态)。</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/05c614c5c8b569deb5f52ed1fb823b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAzNz1sqY3TrB19wzugD-g.jpeg"/></div></div></figure><p id="2f74" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="mg">图3:断路器状态</em></p><h1 id="91f9" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">服务网格</h1><p id="4ed9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">服务网格实现微服务架构的通信层。它确保服务请求的交付，提供负载平衡，加密数据(使用TLS)，并提供其他服务的发现。服务网格还:</p><ul class=""><li id="539a" class="mk ml it lb b lc ly lg lz lk mm lo mn ls mo lw mp mq mr ms bi translated">提供断路器逻辑</li><li id="7120" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">提供管理流量控制、网络弹性、安全性和身份验证的流程</li><li id="5223" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">有一个代理，它使用sidecar模式与微服务集成</li></ul><p id="4366" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">它不仅允许您管理服务，还允许您收集遥测数据并将其发送到控制平面。我们实现了一个服务网格，如<a class="ae lx" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>，这是Kubernetes中最流行的管理微服务的服务网格框架。</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/05c614c5c8b569deb5f52ed1fb823b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAzNz1sqY3TrB19wzugD-g.jpeg"/></div></div></figure><p id="41b9" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="mg">图4:服务网格算法</em></p><h1 id="4929" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">边车</h1><p id="6e96" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">Sidecar是与主服务一起部署的实用程序。边车有助于:</p><ul class=""><li id="7883" class="mk ml it lb b lc ly lg lz lk mm lo mn ls mo lw mp mq mr ms bi translated">收集日志</li><li id="7472" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">管理配置</li><li id="a5ea" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated">控制与服务的连接</li></ul><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/374aecc9a03869f1391de888386e1268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w873C8HpYBJODjPS74ySZw.jpeg"/></div></div></figure><p id="7c54" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="mg">图5:边车</em></p><h1 id="21a4" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">微服务在行动</h1><p id="5899" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了展示微服务的威力，我们将把我们的单片旅行应用程序(见图1)迁移到微服务架构。</p><p id="9fd0" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们将使用无服务器方法和Azure云。</p><ul class=""><li id="9004" class="mk ml it lb b lc ly lg lz lk mm lo mn ls mo lw mp mq mr ms bi translated"><strong class="lb iu"> API网关</strong> —使用API管理来公开后端服务的端点，以便客户端应用程序可以安全地使用它们。</li><li id="3dec" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated"><strong class="lb iu">入口点</strong> —客户端应用程序将使用的面向公众的API，由响应HTTP请求的Azure函数提供支持。</li><li id="0f2a" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated"><strong class="lb iu">异步队列</strong> —消息服务处理服务间的相互通信，并在不同的服务间传递信息和数据，由Azure Event Grid表示。</li><li id="f347" class="mk ml it lb b lc mt lg mu lk mv lo mw ls mx lw mp mq mr ms bi translated"><strong class="lb iu">后端服务</strong> —直接与数据层和解决方案的其他组件一起操作的服务，与其他服务隔离，并且在需要时可以轻松替换。</li></ul><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fc9038e94cc40a399bc158105a065036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RXx3j19IfS80RU8PVl06w.jpeg"/></div></div></figure><p id="b729" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="mg">图6:旅游预订微服务</em></p><h1 id="a7e6" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="8ba2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">构建高可用性、可伸缩性和高性能的应用程序具有挑战性。微服务架构让我们不仅可以构建独立的服务，还可以创建几个团队来支持每项服务，并引入DevOps方法。微服务和所有流行的云提供商允许我们构建多云微服务架构。这样可以省钱，因为有些服务有不同的定价策略。但是一定要选择最适合特定微服务领域的服务。例如，我们可以将<a class="ae lx" href="https://www.boriszaikin.com/ms-ignite-2021-top-5-valuable-azure-services-quick-start" rel="noopener ugc nofollow" target="_blank"> AKS与集成服务网格</a>一起使用，或者使用基于<a class="ae lx" href="https://github.com/skarlekar/faces" rel="noopener ugc nofollow" target="_blank"> AWS Lambdas </a>的无服务器方法。多重云允许我们应用云原生开发运维来独立交付服务。</p><blockquote class="md me mf"><p id="f505" class="kz la mg lb b lc ly le lf lg lz li lj mh ma lm ln mi mb lq lr mj mc lu lv lw im bi translated"><em class="it">这是来自DZone 2022</em><a class="ae lx" href="https://dzone.com/trendreports/microservices-and-containerization" rel="noopener ugc nofollow" target="_blank"><em class="it">微服务和容器化趋势报告</em> </a> <em class="it"> t. </em>的一篇文章</p></blockquote></div></div>    
</body>
</html>