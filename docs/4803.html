<html>
<head>
<title>Storing Time Series in RocksDB: A Cookbook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在RocksDB中存储时间序列:指南</h1>
<blockquote>原文：<a href="https://itnext.io/storing-time-series-in-rocksdb-a-cookbook-e873fcb117e4?source=collection_archive---------1-----------------------#2020-09-22">https://itnext.io/storing-time-series-in-rocksdb-a-cookbook-e873fcb117e4?source=collection_archive---------1-----------------------#2020-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8e0eba80f7c95ed337da6467a687e80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FDpLNY6uLZTfCGbc"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kc" href="https://unsplash.com/@aronvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aron视觉</a>拍摄的照片</figcaption></figure><p id="40e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般认为K/V存储不适合时间序列(TS)数据。原因是大量的写入和时间序列隐含的大量数据。但是常识有时可能是错误的。今天我们将讨论在来自脸书的嵌入式键/值(K/V)存储<a class="ae kc" href="https://rocksdb.org/" rel="noopener ugc nofollow" target="_blank"> RocksDB </a>之上构建(相对)高效的TS存储的方法。RocksDB非常适合我们的需求，因为它已经可以投入生产，维护良好，并且由于采用了<a class="ae kc" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree" rel="noopener ugc nofollow" target="_blank"> LSM树</a>数据结构，它提供了稳定的写入速度。使用该方法构建的TS存储应该能够显示良好的读/写吞吐量，以及适当的数据压缩率。</p><p id="41d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">免责声明</strong>。在我们进一步讨论之前，我需要说，在可以使用现有TS数据库的情况下，您当然应该使用它。但有时您可能需要一个嵌入式TS存储，然后选项列表几乎是空的。</p><p id="d506" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇博客文章是对这种方法的简短总结，在我不久前的这个<a class="ae kc" href="https://youtu.be/1fzae--iHYU" rel="noopener ugc nofollow" target="_blank">演讲</a>中有更详细的描述。虽然那次谈话的重点是Hazelcast管理中心的需求，并包括一些Java代码片段，但我将尽可能保持这篇文章的简短和语言无关性。</p><p id="925c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的最终目标是充分阐明这个想法，以便任何开发人员都可以用任何流行的编程语言在RocksDB(或任何其他K/V存储)之上构建嵌入式TS存储。</p><p id="2b3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从进一步解释所必需的术语和假设开始。出于可读性的考虑，我将对代码片段使用TypeScript。</p><h1 id="7631" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">术语</h1><p id="6d73" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">“指标”——可以在特定时间测量的数值，具有现实意义。示例:CPU负载、已用堆内存。由一个名称和一组标签唯一表征。</p><p id="37b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“数据点”(又名“样本”)—在给定时间测量的度量值。以度量、时间戳(Unix时间)和值为特征。</p><p id="6e2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“时间序列”——属于同一指标的一系列数据点，具有单调递增的时间戳。</p><p id="904b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据点可以用下面的接口来描述。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9bf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是真实世界数据点的样子。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/105b0a3093b66f39a5c638eec9564ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rlPhv-r4Xc568YYrqmGbmg.png"/></div></div></figure><p id="e034" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">存储本身可以用下面的接口表示。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="359a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，公共API非常简单，提供了存储数据点列表和查询单个时间序列(即单个指标)的方法。这就是这里使用术语“存储”的原因:它不是一个TS数据库，因为它缺少查询语言和由指标元数据索引支持的执行引擎、聚合API以及其他一些模块。另一方面，其中许多功能可以构建在存储之上，但这超出了我们今天的主题。</p><h1 id="a71a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">假设</h1><p id="fbf9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">所有TS数据库和存储器都对时间序列数据的形状做出假设，我们也是如此。</p><p id="c1b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们假设时间戳具有一秒的粒度，即每个时间戳对应于一秒的开始。正如我们将在后面看到的，这种假设为基于位图的数据压缩提供了机会。</p><p id="325e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，数据点值必须是整数。这种假设也允许我们使用某些压缩技术，但这并不是必须的，也可以通过使用不同的压缩算法来支持浮点数。</p><p id="ffdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们更好地了解我们的需求时，我们来讨论K/V数据布局。</p><h1 id="bd07" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">键值布局</h1><p id="03bb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这里的主要思想对于时间序列是非常自然的，并且可以在大多数(如果不是全部)TS数据库中找到。为了减少K/V条目的数量并启用压缩数据的方法，我们将时间序列存储在分钟桶中。选择一分钟作为时间间隔是持久性(更小的时间间隔，更频繁的磁盘持久性)和整体存储效率(桶中更多的数据点，更好的压缩和读/写吞吐量)之间的折衷。</p><p id="a62f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二步，我们还将指标提取到一个单独的K/V存储(RocksDB称之为“数据库”)中，并分配整数标识符。这样，主存储中的每个数据点记录都包含标识符，而不是冗长的指标描述。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/55547f913b22b5a78666bde3eab229cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6GQ61IC1T4vu7RchKKp-VQ.png"/></div></div></figure><p id="6c6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保存分钟时段的主K/V商店的布局如下所示。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/923e32069b816f13acfe29d8cee776e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rEW2StypawyJ5hV7ZWA46w.png"/></div></div></figure><p id="2de4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，该值包含一个字节缓冲区(一个blob ),其中包含压缩的分时段数据。</p><p id="9a6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能已经猜到了，下一个主题是数据压缩。</p><h1 id="e1c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据点压缩</h1><p id="48b6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在我们的设计中，每个分钟时段可以容纳多达60个数据点。实际上，它们中的一些可能会丢失，或者数据收集间隔可能会大于一秒。最直接的方法是将整个桶存储在一个包含60个元素的数字数组中，并且可能用一种或另一种算法压缩它。但是我们要尽量避免储存“洞”，所以我们需要更聪明的东西。</p><p id="7272" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们已经在键中存储了分钟开始的时间戳，所以我们只需要存储每个数据点的相应分钟开始的偏移量。接下来是位图编码，我们将使用的第一种压缩技术。使用位图，我们只需要64位来编码所有偏移。让我们称blob的这一部分为“数据点布局”。</p><p id="3e1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至于值(“有效载荷”)，我们可以将它们放在一个数组中，并用一个结合了增量编码和游程编码的简单算法对它们进行压缩。我们不打算讨论精确算法的所有细节，但是如果你想了解更多，这篇<a class="ae kc" href="https://blog.timescale.com/blog/time-series-compression-algorithms-explained/" rel="noopener ugc nofollow" target="_blank">博客文章</a>将是一个很好的起点。</p><p id="640a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此图说明了每个分钟时段的布局。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/ee33dca0c4fde64a794aea608a64e7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_24OQlwlkwh93EzryRFxRg.png"/></div></div></figure><p id="5ccc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是时候讨论这些构件如何作为一个整体一起工作了。</p><h1 id="39eb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">时序存储设计</h1><p id="12da" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们从高级设计的角度来看一下实现可能是什么样子。</p><p id="3843" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注</strong>。下面的设计假设您正在使用RocksDB JNI绑定或任何类似的绑定来支持您选择的语言，并且不想同时用Java和C++编写代码。您可能还希望能够禁用存储中的持久性。如果不是这样，您可以考虑使用<a class="ae kc" href="https://github.com/facebook/rocksdb/wiki/Merge-Operator" rel="noopener ugc nofollow" target="_blank">合并操作符</a>，它将接受输入的数据点，将它们与相应的分钟桶合并，压缩桶，并将结果就地存储。这样设计会变得更简单，因为你不需要内存存储和桶累加逻辑。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/d8ba8264c8c688cfda96ca0aa2c4417e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VY7uSpz4TcT12Yg-RSkXAg.png"/></div></div></figure><p id="7bb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，Metrics Registry代表包含指标到标识符对的K/V存储，持久性存储保存分钟存储桶，内存存储充当写后缓存。</p><p id="12d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次写入都要经过以下流程。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/5af6bfd7cac6821564ad48a0724e8769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGjotlgXyHVx_GjfExsuYQ.png"/></div></div></figure><p id="3ffc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每次<code class="fe mp mq mr ms b">store()</code>调用时，数据点在存储在缓存中的分钟时段中累积，而磁盘上的持久性在后台作业中定期发生。作业的每次运行都会遍历所有缓存的存储桶，并持久保存那些至少累积了一分钟的存储桶。作为拼图的最后一块，压缩应该在持久化存储桶之前应用。</p><p id="3ac1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们将数据点分组到桶中，并从数据压缩和批量写入中受益。</p><p id="a36d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如下所示，读取流时间序列要简单得多。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/8e990d387b7f599fe6db9cce35c253c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O8edwRIRAdwfOKOB_Y76Cg.png"/></div></div></figure><p id="9bf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当读取数据点时，我们首先检查Metrics Registry以找到标识符(提示:内存缓存肯定会加快这个步骤)。然后我们检查内存中的存储，试图找到桶，只有这样我们才从磁盘(更准确地说，从RocksDB)中读取它。通过这种方式，我们可以确保对最近数据点的查询将会很快，这对于许多用例来说是有价值的，比如在UI中显示最新的数据。</p><p id="9819" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这基本上是整个方法。祝贺你获得了新知识！</p><p id="7da0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管这一理论很有价值，但毫无疑问，你们中的一些人可能想知道TS存储的具体实现的特征。</p><h1 id="377e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">潜在特征</h1><p id="4554" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">不久前，我们为管理中心开发了一款嵌入式TS存储，这是一款针对<a class="ae kc" href="https://hazelcast.org/imdg/" rel="noopener ugc nofollow" target="_blank"> Hazelcast IMDG </a>的集群管理和监控应用。存储是在RocksDB之上用Java编写的，并遵循了上述设计。</p><p id="59e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了其他类型的测试，我们还对存储进行了基准测试，以了解其性能特征。基准测试模拟了10个集群节点，每3秒钟报告12万个指标。0-1，000范围内的随机整数被用作数据点值。因此，在采用SATA III连接SSD的像样硬件上，存储显示每秒40万数据点写入和每秒19万分钟系列(物理)读取的吞吐量。这些数字可以称得上足够好了，至少满足了我们的需求。</p><p id="9a69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">更新</strong>。最近，我们在存储方面做了一些改进实验(批量写入、手动WAL刷新、用自定义缓存库替换第三方缓存库),并且能够实现大约每秒2M数据点的写入。</p><p id="194b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至于压缩效率，平均每个数据点的存储开销约为5.25字节。原始数据点数据占用16个字节，所以压缩比在x3左右。这个结果比独立TS数据库通常<a class="ae kc" href="https://prometheus.io/docs/prometheus/1.8/storage/#chunk-encoding" rel="noopener ugc nofollow" target="_blank">显示的</a>差，但并不可怕，对于许多用例来说可能已经足够了，尤其是考虑到存储是多么简单的时候。</p><h1 id="a6ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="dc7e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我有意将额外的挑战，比如潜在的增强和技术限制，排除在这篇博文的范围之外，但是你可能会在演讲中发现它们。此外，这种设计并不是一成不变的，因此有很大的变化空间。</p><p id="d27f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的主要意图是展示一个简单但足够好的时间序列存储可以很容易地构建在RocksDB或任何其他合适的K/V存储之上。所以，如果你打算写一个，那么祝你好运，祝你编码愉快！</p></div></div>    
</body>
</html>