<html>
<head>
<title>Hiding properties in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中隐藏属性</h1>
<blockquote>原文：<a href="https://itnext.io/hidden-properties-in-javascript-73b52def1589?source=collection_archive---------6-----------------------#2018-06-05">https://itnext.io/hidden-properties-in-javascript-73b52def1589?source=collection_archive---------6-----------------------#2018-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8633" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有时候，你想在一个对象上定义一个属性，这个属性不容易被你没有写的代码访问。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e6f728e35a6cc3ca93ec79289aab425e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zl6-ITHZpfsjG9qzG7spKw.png"/></div></div></figure><p id="e65e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有几种方法可以创建所谓的“隐藏属性”，而不需要查看由闭包封闭的变量之类的东西，这些东西受到范围规则的限制。</p><h1 id="c2ea" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">Now-classic，不可枚举属性</h1><p id="dc08" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">您可以使用<code class="fe mk ml mm mn b">Object.defineProperty</code>来创建未标记为<code class="fe mk ml mm mn b">enumerable</code>的属性。这使得当你用某些方法枚举对象的属性时，比如<code class="fe mk ml mm mn b">for ... in</code>循环和<code class="fe mk ml mm mn b">Object.keys</code>函数，这个属性不会显示出来。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="da62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，您仍然可以使用<code class="fe mk ml mm mn b">Object.getOwnPropertyNames</code>函数找到它，该函数甚至返回不可枚举的属性。当然，你仍然可以通过它的键访问属性，理论上，它只是一个任何人都可以构建的字符串。</p><h2 id="7434" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw lz le mx my mb li mz na md nb bi translated">笔记</h2><ol class=""><li id="a609" class="nc nd iq kt b ku mf kx mg la ne le nf li ng lm nh ni nj nk bi translated">属性实际上并没有隐藏，只是没有出现在某些属性列表中。</li><li id="c6cc" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">对于哪些属性应该是不可枚举的，哪些不应该是不可枚举的，并没有真正的约定。</li><li id="24de" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">在运行时检查期间看到该属性的人不一定知道它应该是隐藏的或者是不可枚举的。</li></ol><h1 id="1a85" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><code class="fe mk ml mm mn b">symbol</code>一个(不可枚举)属性</h1><p id="6d16" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在ES6中，可以使用一种新的原始类型的键来创建属性。Javascript本身使用这种类型通过一个<code class="fe mk ml mm mn b">for ... of</code>循环来枚举一个对象，库编写者也使用这种类型来做其他各种事情。</p><p id="8901" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">Symbols</code>具有描述性文本，但它们是具有唯一标识的引用类型。它们不像字符串，如果它们有相同的值，它们就是相等的。要使两个符号相等，它们必须是对同一事物的两个引用。</p><p id="6a12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe mk ml mm mn b">Symbol</code>函数创建一个<code class="fe mk ml mm mn b">symbol</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6ff6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以使用<code class="fe mk ml mm mn b">Object.defineProperty</code>功能定义以符号为关键字的属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5f51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除非有人获得对该符号对象的引用，否则他们无法通过键来查找属性值。</p><p id="a3ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是您也可以使用常规语法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="38d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">具有这种键类型的属性永远不会出现在<code class="fe mk ml mm mn b">for ... in</code>循环或类似的循环中，但仍然可以是可枚举的和不可枚举的，因为像<code class="fe mk ml mm mn b">Object.assign</code>这样的函数对于不可枚举的属性有不同的工作方式。</p><p id="f8ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">Object.getOwnPropertyNames</code>不会给你对象的<code class="fe mk ml mm mn b">symbol</code>键，但是名字相似的<code class="fe mk ml mm mn b">Object.getOwnPropertySymbols</code>会给你。</p><h2 id="087c" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw lz le mx my mb li mz na md nb bi translated">笔记</h2><ol class=""><li id="87fa" class="nc nd iq kt b ku mf kx mg la ne le nf li ng lm nh ni nj nk bi translated">财产没有完全隐藏。您仍然可以使用专门的方法获得符号密钥。</li><li id="8fff" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">在运行时检查对象的人将能够知道该属性应该是隐藏的。符号属性通常保留给人们不应该接触的实现细节。</li><li id="aff1" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">需要支持ES2015才能工作。</li></ol><h1 id="ca1f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">弱映射</h1><p id="c019" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">隐藏对象上的属性的最强方法是根本不在对象上存储它。在ES6之前，这有点棘手，但现在我们有弱地图。</p><p id="b8d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">弱映射基本上是一个<code class="fe mk ml mm mn b">Map</code>，即一个键值存储，它不保存对键的(强)引用，所以它们可以被垃圾收集。弱映射是非常有限的，并且不允许您枚举它的键(这是由设计决定的)。但是，如果您获得了对映射的一个键的引用，您就可以获得与之相关的值。</p><p id="9c90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它们主要被设计成允许扩展对象而不实际修改它们。</p><p id="fd0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本思想是创建一个弱映射:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4fb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并使用想要扩展的对象作为键。那么这些值将是属性集，或者是以<code class="fe mk ml mm mn b">{}</code>对象的形式，或者是以<code class="fe mk ml mm mn b">Map</code>数据结构的形式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d5bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法的优点是，有人需要获得对您的<code class="fe mk ml mm mn b">weakMap</code>实例<strong class="kt ir">和</strong>键的引用，以便获取值，或者甚至知道它们的存在，这是无法避免的。所以是100%，保证安全。以这种方式隐藏属性可以确保没有用户会发现它们，您的web应用程序也不会被黑客攻击。*</p><h2 id="75ee" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw lz le mx my mb li mz na md nb bi translated">笔记</h2><ol class=""><li id="92c9" class="nc nd iq kt b ku mf kx mg la ne le nf li ng lm nh ni nj nk bi translated">完全隐藏。您需要引用弱映射来恢复属性值。</li><li id="9185" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">不是实际属性，所以不参与原型链之类的。</li><li id="8949" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">需要ES2015才能工作。</li></ol><p id="aa4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(*)这是骗人的。</p></div></div>    
</body>
</html>