<html>
<head>
<title>Angular Component Portals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角形组件入口</h1>
<blockquote>原文：<a href="https://itnext.io/angular-component-portals-28ddd860c22c?source=collection_archive---------2-----------------------#2020-08-22">https://itnext.io/angular-component-portals-28ddd860c22c?source=collection_archive---------2-----------------------#2020-08-22</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/384b8e20ca25d217ed404ea302a5d725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4THZycRNWBQ6Dd0o.jpg"/></div></div></figure><p id="ac76" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">围绕Angular Ivy有很多谈论和宣传，它被誉为Angular生态系统未来许多事情的救星，这包括能够在运行时使用import语法惰性地加载单个组件，而不需要NgModule本身。</p><pre class="la lb lc ld gu le lf lg lh aw li bi"><span id="aa36" class="lj lk iu lf b gz ll lm l ln lo">this.foo = await import(`./foo.component`)<br/> .then(({ FooComponent }) =&gt; FooComponent);</span></pre><p id="797e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><a class="lp lq ep" href="https://medium.com/u/b889ae02aa26?source=post_page-----28ddd860c22c--------------------------------" rel="noopener" target="_blank"> Netanel Basal </a>写了一篇关于这个主题的精彩文章，涵盖了延迟加载单个组件的所有细节以及如何使用它们(见下面的链接)。</p><blockquote class="lr"><p id="aaf7" class="ls lt iu bd lu lv lw lx ly lz ma kz dk translated">我们到底为什么想要这个？有什么大惊小怪的？</p></blockquote><p id="e4c5" class="pw-post-body-paragraph kc kd iu ke b kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz in bi translated">如果拿一个典型的管理应用程序的仪表板来说。有许多不同的方面，主要是向用户显示分析数据，并且这些面板中的每一个都可以是来自各种模块的组件，但是如何按需加载这些组件，或者甚至如何由最终用户自己定制和动态加载面板。</p><figure class="la lb lc ld gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj mg"><img src="../Images/7b88cdb48d259a136df3847cfede4de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k394JrO_LUl-nijSBK1GhA.png"/></div></div></figure><p id="a67c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">对于这些类型的场景，通过角度路由加载仪表板是不可能的，因为仪表板将位于一条单独的路径上，这条路径被标记为<em class="mh"> /home </em>或<em class="mh"> /dashboard </em>。</p><blockquote class="lr"><p id="1fcc" class="ls lt iu bd lu lv lw lx ly lz ma kz dk translated">但是，如果您可以延迟加载一个NgModule并实例化该模块中的任何组件，而不直接引用组件类型，会怎么样呢？</p></blockquote><h2 id="6b5f" class="lj lk iu bd mi mj mk dn ml mm mn dp mo kn mp mq mr kr ms mt mu kv mv mw mx my bi translated">组件门户简介</h2><p id="0cfc" class="pw-post-body-paragraph kc kd iu ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz in bi translated">组件门户提供了通过使用字符串标识符实例化任何组件的能力，并且组件被神奇地实例化了。也许没有魔法，但你明白我的意思。</p><p id="a363" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这种模式几乎可以轻松地应用到任何现有的应用程序中。</p><p id="ad5e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">组件门户的部分灵感来自于<a class="lp lq ep" href="https://medium.com/u/9af1d23366c8?source=post_page-----28ddd860c22c--------------------------------" rel="noopener" target="_blank"> Wes </a> Grimes(见下面的链接),我花了一些时间将它作为公共npm包发布，最棒的是它甚至不需要Angular Ivy，当前的视图引擎工作得非常好。</p><h2 id="c2cb" class="lj lk iu bd mi mj ne dn ml mm nf dp mo kn ng mq mr kr nh mt mu kv ni mw mx my bi translated">我们开始吧</h2><p id="ee16" class="pw-post-body-paragraph kc kd iu ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz in bi translated">首先，我们需要安装组件门户库，它负责组件注册的所有繁重工作。使用以下命令安装库:</p><pre class="la lb lc ld gu le lf lg lh aw li bi"><span id="5f29" class="lj lk iu lf b gz ll lm l ln lo">npm install @codethatstack/portals</span></pre><p id="dd3f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">安装后，将<code class="fe nj nk nl lf b">CtsPortalsModule</code>导入应用程序根NgModule:</p><figure class="la lb lc ld gu jv"><div class="bz fq l di"><div class="nm nn l"/></div></figure><h2 id="30df" class="lj lk iu bd mi mj ne dn ml mm nf dp mo kn ng mq mr kr nh mt mu kv ni mw mx my bi translated">注册组件</h2><p id="220d" class="pw-post-body-paragraph kc kd iu ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz in bi translated">像通常使用NgModule一样创建和注册任何组件:</p><figure class="la lb lc ld gu jv"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="7dc4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">下一步是向ComponentRegistry注册组件:</p><figure class="la lb lc ld gu jv"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="2409" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这一步很重要，这是将组件类型和NgModule绑定到字符串组件标识符的神奇胶水。这只注册了具体的组件类型，现在我们需要在根NgModule中将它缝合在一起。</p><h2 id="7ca0" class="lj lk iu bd mi mj ne dn ml mm nf dp mo kn ng mq mr kr nh mt mu kv ni mw mx my bi translated">注册门户模块</h2><p id="ec88" class="pw-post-body-paragraph kc kd iu ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz in bi translated">为每个将被延迟加载的NgModule定义一个模块标识符(moduleId)。这与延迟加载子路由使用相同的语法。</p><figure class="la lb lc ld gu jv"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="4ba2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">接下来使用注入令牌<code class="fe nj nk nl lf b">PORTAL_MODULE_TOKEN</code>注册<code class="fe nj nk nl lf b">PortalModules</code>。</p><figure class="la lb lc ld gu jv"><div class="bz fq l di"><div class="nm nn l"/></div></figure><h2 id="bd30" class="lj lk iu bd mi mj ne dn ml mm nf dp mo kn ng mq mr kr nh mt mu kv ni mw mx my bi translated">注册门户组件</h2><p id="2bc6" class="pw-post-body-paragraph kc kd iu ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz in bi translated">使用上面定义的字符串标识符定义每个组件，将它链接到上面的模块标识符。</p><figure class="la lb lc ld gu jv"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="d940" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">通过分离出模块加载定义，这避免了为同一个NgModule注册多个组件时的重复。</p><p id="e854" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">接下来是使用注入令牌<code class="fe nj nk nl lf b">PORTAL_COMPONENTS_TOKEN</code>注册<code class="fe nj nk nl lf b">PortalComponents</code>。</p><figure class="la lb lc ld gu jv"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="5420" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">哇，那是很多管道工程。</p><h2 id="3a93" class="lj lk iu bd mi mj ne dn ml mm nf dp mo kn ng mq mr kr nh mt mu kv ni mw mx my bi translated">准备，就位，开始</h2><p id="8f63" class="pw-post-body-paragraph kc kd iu ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz in bi translated">要在应用程序中的任何地方实例化一个组件，使用指令<code class="fe nj nk nl lf b">ctsComponentPortal</code>，指定组件的字符串标识符名称。</p><figure class="la lb lc ld gu jv"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="48bb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><strong class="ke iv">就是这样！</strong>模块将被加载，组件将在当前ViewContainer中实例化。</p><p id="847e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果需要，您甚至可以挂钩到<em class="mh">激活的</em>和<em class="mh">去激活的</em>事件来处理任何额外的逻辑。</p><h1 id="c91d" class="no lk iu bd mi np nq nr ml ns nt nu mo nv nw nx mr ny nz oa mu ob oc od mx oe bi translated">奖金</h1><p id="50f6" class="pw-post-body-paragraph kc kd iu ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz in bi translated">最近，Nir Kaufman向我介绍了心灵传输的概念。这个概念非常简单。在您的应用程序中注册一个插座，然后将一个模板附加到该插座，但是对于组件门户，它将是一个组件。</p><p id="610f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在应用程序中的某个位置注册门户网站，并提供一个唯一的名称。</p><figure class="la lb lc ld gu jv"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="17ef" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后使用属性<code class="fe nj nk nl lf b">ctsComponentPortalAttachTo</code>来指定组件将连接到哪个插座。</p><figure class="la lb lc ld gu jv"><div class="bz fq l di"><div class="nm nn l"/></div></figure><h1 id="5fea" class="no lk iu bd mi np nq nr ml ns nt nu mo nv nw nx mr ny nz oa mu ob oc od mx oe bi translated">概括起来</h1><p id="8406" class="pw-post-body-paragraph kc kd iu ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz in bi translated">通过一点魔法，一个组件可以在任何地方被实例化，只需要一个字符串标识符。</p><p id="1bad" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">点击查看演示<a class="ae of" href="https://codethatstack.github.io/platform/" rel="noopener ugc nofollow" target="_blank">。</a></p><div class="og oh gq gs oi oj"><a href="https://github.com/codethatstack/platform/blob/master/libs/portals/README.md" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">代码堆栈/平台</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">组件门户提供了延迟加载一个NgModule和实例化包含在任何…</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ka oj"/></div></div></a></div><h2 id="8025" class="lj lk iu bd mi mj ne dn ml mm nf dp mo kn ng mq mr kr nh mt mu kv ni mw mx my bi translated">额外资源</h2><div class="og oh gq gs oi oj"><a href="https://netbasal.com/welcome-to-the-ivy-league-lazy-loading-components-in-angular-v9-e76f0ee2854a" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">欢迎来到常春藤联盟:Angular v9中的延迟加载组件</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">用Ivy延迟加载组件</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">netbasal.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ka oj"/></div></div></a></div><div class="og oh gq gs oi oj"><a href="https://netbasal.com/dynamically-creating-components-with-angular-a7346f4a982d" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">使用角度动态创建组件</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">在本文中，我们将学习如何在Angular中动态创建组件。</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">netbasal.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox ka oj"/></div></div></a></div><div class="og oh gq gs oi oj"><a href="https://medium.com/angular-in-depth/building-an-aot-friendly-dynamic-content-outlet-in-angular-59c1a96171a" rel="noopener follow" target="_blank"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">在Angular建立一个AOT友好的动态内容出口</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">构建一个具有动态组件出口的特殊模块</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">medium.com</p></div></div><div class="os l"><div class="pa l ou ov ow os ox ka oj"/></div></div></a></div><div class="og oh gq gs oi oj"><a href="https://github.com/nirkaufman/teleport" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">尼尔考夫曼/传送</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">此项目是使用Angular CLI版本9.0.6生成的。为开发服务器运行ng serve。导航到…</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">github.com</p></div></div><div class="os l"><div class="pb l ou ov ow os ox ka oj"/></div></div></a></div></div></div>    
</body>
</html>