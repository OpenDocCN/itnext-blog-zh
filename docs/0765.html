<html>
<head>
<title>Building a GraphQL API using GraphQL-yoga, Lambda, and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL-yoga、Lambda和MongoDB构建GraphQL API</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-graphql-api-using-graphql-yoga-lambda-and-mongodb-c0c195621f47?source=collection_archive---------3-----------------------#2018-05-23">https://itnext.io/building-a-graphql-api-using-graphql-yoga-lambda-and-mongodb-c0c195621f47?source=collection_archive---------3-----------------------#2018-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq gh gi paragraph-image"><div class="ab gu cl jr"><img src="../Images/a096fd35169acadc529228f6b9b03f48.png" data-original-src="https://miro.medium.com/v2/format:webp/1*RiEzZRJuIuurCJnAphLxHA.png"/></div></figure><p id="2768" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大多数GraphQL文档倾向于通过一些关于部署API的额外博客文章来解决查询和变异的基础问题。我最近遇到的问题是试图在AWS Lambda上实现GraphQL-yoga，而不是由DynamoDB支持。这个项目将专注于实现一个mongo数据库托管在MLab上，并与Mongoose连接。</p><h1 id="e0ef" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">开始</h1><p id="ad9f" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">如果你想看看这个项目的完成代码，请查看https://github.com/resputin/yoga-serverless-mongo的<a class="ae lv" href="https://github.com/resputin/yoga-serverless-mongo" rel="noopener ugc nofollow" target="_blank"/>。要在本地运行项目:</p><ul class=""><li id="9301" class="lw lx iq jw b jx jy kb kc kf ly kj lz kn ma kr mb mc md me bi translated">克隆https://github.com/resputin/yoga-serverless-mongo<a class="ae lv" href="https://github.com/resputin/yoga-serverless-mongo" rel="noopener ugc nofollow" target="_blank"/></li><li id="64f9" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated"><code class="fe mk ml mm mn b">yarn install</code></li><li id="b212" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">为<code class="fe mk ml mm mn b">MONGO_DB_URL</code>和<code class="fe mk ml mm mn b">SESSION_SECRET</code>配置环境变量</li><li id="85da" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated"><code class="fe mk ml mm mn b">yarn start</code></li><li id="49f7" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">转到<code class="fe mk ml mm mn b">localhost:3000</code>，这个项目将启动到graphql-playground来玩。schema选项卡将包含构建查询和变异的相关信息。</li></ul><h2 id="4398" class="mo kt iq bd ku mp mq dn ky mr ms dp lc kf mt mu lg kj mv mw lk kn mx my lo mz bi translated">该模式</h2><p id="dc62" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">这将是一个待办事项应用程序的简单实现。我们的模式将如下所示</p><pre class="na nb nc nd gt ne mn nf ng aw nh bi"><span id="5f71" class="mo kt iq mn b gy ni nj l nk nl">type User {</span><span id="901d" class="mo kt iq mn b gy nm nj l nk nl">  _id: ID!</span><span id="53b9" class="mo kt iq mn b gy nm nj l nk nl">  email: String!</span><span id="8858" class="mo kt iq mn b gy nm nj l nk nl">  todos: [Todo!]!</span><span id="d859" class="mo kt iq mn b gy nm nj l nk nl">}</span><span id="d93e" class="mo kt iq mn b gy nm nj l nk nl">type Todo {</span><span id="ded9" class="mo kt iq mn b gy nm nj l nk nl">  _id: ID!</span><span id="35d3" class="mo kt iq mn b gy nm nj l nk nl">  content: String!</span><span id="dd58" class="mo kt iq mn b gy nm nj l nk nl">}</span><span id="424f" class="mo kt iq mn b gy nm nj l nk nl">type AuthPayload {</span><span id="4814" class="mo kt iq mn b gy nm nj l nk nl">  token: String!</span><span id="e52d" class="mo kt iq mn b gy nm nj l nk nl">  user: User</span><span id="a287" class="mo kt iq mn b gy nm nj l nk nl">}</span></pre><p id="55b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将建立我们的数据模型。我们有一个<em class="nn">用户</em>，我们可以在上面查询<em class="nn"> id、</em>和<em class="nn">待办事项</em>。我们有一个<em class="nn">待办事项</em>，可以查询<em class="nn"> id </em>和<em class="nn">内容。</em>最后，我们有一个<em class="nn"> AuthPayload </em>，我们可以查询一个JWT和一个<em class="nn">用户</em>。</p><pre class="na nb nc nd gt ne mn nf ng aw nh bi"><span id="ecc0" class="mo kt iq mn b gy ni nj l nk nl">type Query {</span><span id="6cb7" class="mo kt iq mn b gy nm nj l nk nl">  todos: [Todo!]!</span><span id="3bc0" class="mo kt iq mn b gy nm nj l nk nl">  todo(_id: ID!): Todo!</span><span id="9feb" class="mo kt iq mn b gy nm nj l nk nl">}</span><span id="f182" class="mo kt iq mn b gy nm nj l nk nl">type Mutation {</span><span id="3cd3" class="mo kt iq mn b gy nm nj l nk nl">  signup(email: String!, password: String!): AuthPayload</span><span id="7bac" class="mo kt iq mn b gy nm nj l nk nl">  login(email: String!, password: String!): AuthPayload</span><span id="77c1" class="mo kt iq mn b gy nm nj l nk nl">  createTodo(content: String!): Todo!</span><span id="6552" class="mo kt iq mn b gy nm nj l nk nl">}</span></pre><p id="1768" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于我们的根级查询，我们可以查询<em class="nn"> allTodos </em>，它将返回一个待办事项列表，或者查询<em class="nn"> todo </em>，它将从其id返回一个特定的待办事项。</p><p id="ff95" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个模式将被导入到yoga的GraphQLServerLambda类的<code class="fe mk ml mm mn b">handler</code>文件中。这个类将把我们的模式和解析器转换成一个与Lambda接口的graphQL服务器。</p><pre class="na nb nc nd gt ne mn nf ng aw nh bi"><span id="e631" class="mo kt iq mn b gy ni nj l nk nl">const lambda = new GraphQLServerLambda({</span><span id="87ba" class="mo kt iq mn b gy nm nj l nk nl">  typeDefs: './schema.graphql'<br/>  // more here later</span><span id="988e" class="mo kt iq mn b gy nm nj l nk nl">});</span></pre><h2 id="ac5c" class="mo kt iq bd ku mp mq dn ky mr ms dp lc kf mt mu lg kj mv mw lk kn mx my lo mz bi translated">下决心者</h2><p id="c2c5" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们的解决方案也相对简单。Yoga将自动处理我们简单的查询解析器，所以我们需要担心的只是我们的Todo和用户认证。</p><p id="278e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的Todo查询很简单</p><pre class="na nb nc nd gt ne mn nf ng aw nh bi"><span id="c1cf" class="mo kt iq mn b gy ni nj l nk nl">const todos = async (parent, args, context) =&gt; {<br/>  const userId = authenticate(context);</span><span id="d9eb" class="mo kt iq mn b gy nm nj l nk nl">  try {<br/>    const user = await User.findOne({ _id: userId }).lean()   <br/>    return user.todos;<br/>  } catch (err) {<br/>    throw new Error(err);<br/>  }<br/>};</span><span id="a59e" class="mo kt iq mn b gy nm nj l nk nl">const todo = async (parent, { _id }, context) =&gt; {<br/>  const userId = authenticate(context);<br/>  try {<br/>    const user = await User.findOne({ _id: userId }).lean();<br/>    const todo = await user.todos.find(<br/>      todo =&gt; todo._id.toString() === _id<br/>    );    <br/>    return todo;<br/>  } catch (err) {<br/>    throw new Error(err);<br/>  }<br/>};</span></pre><p id="6d2b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些查询已经过验证，我们可以在<code class="fe mk ml mm mn b">utils</code>中看到。</p><pre class="na nb nc nd gt ne mn nf ng aw nh bi"><span id="0ddc" class="mo kt iq mn b gy ni nj l nk nl">const authenticate = context =&gt; {<br/>  const Authorization = context.event.headers.Authorization;</span><span id="929b" class="mo kt iq mn b gy nm nj l nk nl">if (Authorization) {<br/>    const token = Authorization.replace('Bearer ', '');<br/>    const { userId } = jwt.verify(token, config.SESSION_SECRET);<br/>    return userId;<br/>  }</span><span id="e940" class="mo kt iq mn b gy nm nj l nk nl">throw new Error('Not authorized');<br/>};</span></pre><p id="e140" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里需要注意的一点是，我们将把我们的请求附加到我们的上下文对象中，以便从我们的头中获取不记名令牌，所以现在让我们在<code class="fe mk ml mm mn b">handler</code>中完成这项工作</p><pre class="na nb nc nd gt ne mn nf ng aw nh bi"><span id="a8fc" class="mo kt iq mn b gy ni nj l nk nl">const lambda = new GraphQLServerLambda({<br/>  typeDefs: './schema.graphql',<br/>  context: req =&gt; ({ ...req })<br/>});</span></pre><p id="aa15" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的突变也很简单</p><pre class="na nb nc nd gt ne mn nf ng aw nh bi"><span id="5546" class="mo kt iq mn b gy ni nj l nk nl">const createTodo = async (_, { content }, context) =&gt; {<br/>  const userId = authenticate(context);<br/>  try {<br/>    const user = await User.findOne({ _id: userId });<br/>    const newTodo = { _id: new ObjectId(), content };<br/>    user.todos.push(newTodo);<br/>    await user.save();<br/>    return newTodo;<br/>  } catch (err) {<br/>    throw new Error(err);<br/>  }<br/>};</span><span id="7291" class="mo kt iq mn b gy nm nj l nk nl">const signup = async (_, { email, password }) =&gt; {<br/>  try {<br/>    let user = await User.findOne({ email }).lean();</span><span id="9c3f" class="mo kt iq mn b gy nm nj l nk nl">    if (user) {<br/>      throw new Error('Email is already taken');<br/>    }</span><span id="56fb" class="mo kt iq mn b gy nm nj l nk nl">    const _password = await bcrypt.hash(password, 10);<br/>    user = await new User({ email, password: _password }).save();</span><span id="77fa" class="mo kt iq mn b gy nm nj l nk nl">    const token = jwt.sign({ userId: user._id }, config.SESSION_SECRET);</span><span id="3031" class="mo kt iq mn b gy nm nj l nk nl">    return { token, user };<br/>  } catch (err) {<br/>    throw new Error(err);<br/>  }<br/>};</span><span id="1f11" class="mo kt iq mn b gy nm nj l nk nl">const login = async (_, { email, password }) =&gt; {<br/>  try {<br/>    const user = await User.findOne({ email }).lean();<br/>    if (!user) {<br/>      throw new Error('No such user found');<br/>    }</span><span id="2775" class="mo kt iq mn b gy nm nj l nk nl">    const valid = await bcrypt.compare(password, user.password);<br/>    if (!valid) {<br/>      throw new Error('Invalid password');<br/>    }</span><span id="c079" class="mo kt iq mn b gy nm nj l nk nl">    user.password = undefined;</span><span id="a50c" class="mo kt iq mn b gy nm nj l nk nl">    return {<br/>      token: jwt.sign({ userId: user._id }, config.SESSION_SECRET),<br/>      user<br/>    };<br/>  } catch (err) {<br/>    throw new Error(err);<br/>  }<br/>};</span></pre><p id="c758" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">解析器完成后，我们可以将它们添加到我们的<code class="fe mk ml mm mn b">handler</code>中，并拥有一个完整的GraphQL服务器(尽管没有功能)</p><pre class="na nb nc nd gt ne mn nf ng aw nh bi"><span id="a1e4" class="mo kt iq mn b gy ni nj l nk nl">const resolvers = {<br/>  Query,<br/>  Mutation<br/>};</span><span id="58fe" class="mo kt iq mn b gy nm nj l nk nl">const lambda = new GraphQLServerLambda({<br/>  typeDefs: './schema.graphql',<br/>  resolvers,<br/>  context: req =&gt; ({ ...req })<br/>});</span></pre><h2 id="fe2f" class="mo kt iq bd ku mp mq dn ky mr ms dp lc kf mt mu lg kj mv mw lk kn mx my lo mz bi translated">猫鼬</h2><p id="d623" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">对于mongoose，我们只需要定义一个与我们的GraphQL模式匹配的用户模型，只需添加密码</p><pre class="na nb nc nd gt ne mn nf ng aw nh bi"><span id="7954" class="mo kt iq mn b gy ni nj l nk nl">const userSchema = new mongoose.Schema({<br/>  email: { type: String, unique: true },<br/>  password: { type: String, select: false },<br/>  todos: [<br/>    {<br/>      content: { type: String, required: true }<br/>    }<br/>  ]<br/>});</span><span id="1ed9" class="mo kt iq mn b gy nm nj l nk nl">const User = mongoose.model('User', userSchema);</span></pre><h1 id="8c04" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">无服务器乐趣</h1><p id="40d1" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">设置完成后，让我们开始构建我们的Mongo连接并部署到Lambda。在<code class="fe mk ml mm mn b">handler</code>中，我们需要连接到我们的数据库，该数据库将为我们向端点发出的所有后续请求保持“预热”。</p><pre class="na nb nc nd gt ne mn nf ng aw nh bi"><span id="0bab" class="mo kt iq mn b gy ni nj l nk nl">async function start() {<br/>  const mongoClient = await mongoose.connect(config.MONGO_DB_URL);<br/>  mongoose.connection.on('error', function(err) {<br/>    console.log('Mongoose default connection error: ' + err);<br/>  });<br/>  return true;<br/>}</span></pre><p id="cf9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在是我们的λ函数。Yoga已经提供了这里的大部分逻辑，我们只需要添加一些东西来确保连接到我们的数据库，因为我们将有一个到我们的数据库的持续连接，我们还需要告诉Lambda不要在返回值之前等待我们的事件循环为空。</p><pre class="na nb nc nd gt ne mn nf ng aw nh bi"><span id="a8f0" class="mo kt iq mn b gy ni nj l nk nl">exports.playground = async (event, context, callback) =&gt; {<br/>  context.callbackWaitsForEmptyEventLoop = false;<br/>  await start();<br/>  return lambda.playgroundHandler(event, context, callback);<br/>};</span><span id="34ba" class="mo kt iq mn b gy nm nj l nk nl">exports.server = async (event, context, callback) =&gt; {<br/>  context.callbackWaitsForEmptyEventLoop = false;<br/>  await start();<br/>  return lambda.graphqlHandler(event, context, callback);<br/>};</span></pre><p id="1859" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您已经用AWS Lambda设置了无服务器，那么您可以运行<code class="fe mk ml mm mn b">yarn deploy</code>并在您的AWS端点上探索graphQL-playground！</p><p id="e26b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">设置无服务器CLI: <code class="fe mk ml mm mn b">yarn global add serverless</code></p><p id="a83d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后你可以用这个教程设置你的无服务器凭证:<a class="ae lv" href="https://serverless.com/framework/docs/providers/aws/guide/credentials/" rel="noopener ugc nofollow" target="_blank">https://server less . com/framework/docs/providers/AWS/guide/credentials/</a></p></div></div>    
</body>
</html>