<html>
<head>
<title>Serialize Deserialize Video in fabric JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在fabric JS中序列化反序列化视频</h1>
<blockquote>原文：<a href="https://itnext.io/video-element-serialization-and-deserialization-of-canvas-fc5dbf47666d?source=collection_archive---------3-----------------------#2018-02-19">https://itnext.io/video-element-serialization-and-deserialization-of-canvas-fc5dbf47666d?source=collection_archive---------3-----------------------#2018-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c37756918ac6873d63a74aa383b6e10e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Pgh5_xtHkyIhoypRslJ6YQ.gif"/></div></figure><p id="d450" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我是<a class="ae ks" href="http://fabricjs.com/" rel="noopener ugc nofollow" target="_blank"> fabric.js </a>的忠实粉丝，我发现它是可用于HTML5 canvas的最强大的js。</p><p id="4159" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我很难将视频渲染到画布上，然后将其保存为JSON对象，并使用<strong class="jw ir"> loadFromJson </strong>再次渲染到画布上</p><p id="c4ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于没有官方方法来序列化和反序列化视频元素<a class="ae ks" href="https://github.com/kangax/fabric.js/issues/3697" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">问题#3697 </strong> </a></p><p id="01b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="http://fabricjs.com/video-element" rel="noopener ugc nofollow" target="_blank">你现在可以使用fabric js渲染视频元素</a>，未来的版本可能会有这个功能，但不确定。</p><div class="kt ku kv kw gt ab cb"><figure class="kx jr ky kz la lb lc paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><img src="../Images/41b893bdf554e7d1d0576a690e7dcb71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*nPn75MWfBWxuasWDO5QqmQ.png"/></div></figure><figure class="kx jr lh kz la lb lc paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><img src="../Images/ff7ea51d7acb7b5122e8a4a290f938a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*Vlt-uhDZe17fa2mVk_fXZA.png"/></div></figure></div><h1 id="c4aa" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">我是这样做的</h1><h2 id="7b72" class="mg lj iq bd lk mh mi dn lo mj mk dp ls kf ml mm lw kj mn mo ma kn mp mq me mr bi translated">#第一步</h2><p id="6dcf" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">将一个视频元素渲染到画布上，下面这段代码将把一个视频元素渲染到画布上。</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="e4c8" class="mg lj iq my b gy nc nd l ne nf"><strong class="my ir">function </strong>getVideoElement(url) {<br/>    <strong class="my ir">var </strong>videoE = document.createElement('video');<br/>    videoE.width = 530;<br/>    videoE.height = 298;<br/>    videoE.muted = <strong class="my ir">true</strong>;<br/>    videoE.crossOrigin = "anonymous";<br/>    <strong class="my ir">var </strong>source = document.createElement('source');<br/>    source.src = url;<br/>    source.type = 'video/mp4';<br/>    videoE.appendChild(source);<br/>    <strong class="my ir">return </strong>videoE;<br/>}</span><span id="0d6a" class="mg lj iq my b gy ng nd l ne nf"><strong class="my ir">var</strong> canvas = new fabric.Canvas('c');</span><span id="da87" class="mg lj iq my b gy ng nd l ne nf"><strong class="my ir">var </strong>url_mp4 = 'http://www.quirksmode.org/html5/videos/big_buck_bunny.mp4';<br/><br/><strong class="my ir">var </strong>videoE = getVideoElement(url_mp4);<br/><strong class="my ir">var </strong>fab_video = <strong class="my ir">new </strong>fabric.Image(videoE, {left: 0,   top: 0});</span><span id="36f8" class="mg lj iq my b gy ng nd l ne nf">canvas.add(fab_video);<br/>fab_video.getElement().play();</span><span id="e568" class="mg lj iq my b gy ng nd l ne nf">fabric.util.requestAnimFrame(<strong class="my ir">function </strong>render() {<br/>   canvas.renderAll();<br/>   fabric.util.requestAnimFrame(render);<br/>});</span></pre><p id="8d65" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，如果您将画布导出为JSON</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="d18b" class="mg lj iq my b gy nc nd l ne nf">canvas.toJSON();</span></pre><p id="6959" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你会看到JSON对象中有很多属性，但是主要关注的属性是<code class="fe nh ni nj my b">src</code>和<code class="fe nh ni nj my b">type</code></p><blockquote class="nk nl nm"><p id="4c72" class="ju jv nn jw b jx jy jz ka kb kc kd ke no kg kh ki np kk kl km nq ko kp kq kr ij bi translated"><em class="iq"> {"objects": [{"src ":"，" top": 0，" left": 0，" type": "image "，…}，{}]，" version": "2.0.0-rc.4" } </em></p></blockquote><p id="1727" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">注:</strong> <code class="fe nh ni nj my b">src</code>为<strong class="jw ir">空白</strong>，<code class="fe nh ni nj my b">type</code>为<strong class="jw ir">图像，</strong>表示织物将视频保存为图像对象，但无法分配视频来源</p><h2 id="ef54" class="mg lj iq bd lk mh mi dn lo mj mk dp ls kf ml mm lw kj mn mo ma kn mp mq me mr bi translated">#第二步</h2><p id="2d74" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">为了保存视频元素的<code class="fe nh ni nj my b">src</code>，你需要给fabric对象添加一个自定义属性，为此你需要覆盖<strong class="jw ir"> fabric </strong> <strong class="jw ir">对象</strong>。</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="88b2" class="mg lj iq my b gy nc nd l ne nf">fabric.Object.prototype.toObject = (<strong class="my ir">function </strong>(toObject) {<br/>    <strong class="my ir">return function </strong>(propertiesToInclude) {<br/>        propertiesToInclude = (propertiesToInclude || []).concat(<br/>            ['video_src']<br/>        );<br/>        <strong class="my ir">return </strong>toObject.apply(<strong class="my ir">this</strong>, [propertiesToInclude]);<br/>    };<br/>})(fabric.Object.prototype.toObject);</span></pre><p id="c38e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的代码在导出的时候会给JSON对象添加一个自定义属性<code class="fe nh ni nj my b">video_src</code>，你可以对它进行全局初始化。</p><blockquote class="nk nl nm"><p id="a3e6" class="ju jv nn jw b jx jy jz ka kb kc kd ke no kg kh ki np kk kl km nq ko kp kq kr ij bi translated"><strong class="jw ir">注意:</strong>在将视频元素添加到画布之前设置<code class="fe nh ni nj my b">video_src</code>属性</p></blockquote><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="bd56" class="mg lj iq my b gy nc nd l ne nf"><strong class="my ir">var </strong>fab_video = <strong class="my ir">new </strong>fabric.Image(videoE, {left: 0,   top: 0});</span><span id="7107" class="mg lj iq my b gy ng nd l ne nf">fab_video.set('video_src', url_mp4);</span><span id="9039" class="mg lj iq my b gy ng nd l ne nf">canvas.add(fab_video);</span></pre><p id="6ab9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您将看到导出的对象为:</p><blockquote class="nk nl nm"><p id="0bab" class="ju jv nn jw b jx jy jz ka kb kc kd ke no kg kh ki np kk kl km nq ko kp kq kr ij bi translated"><em class="iq"> {"objects": [{"src ":"，" video _ src ":"</em>http://www.quirksmode.org/html5/videos/big_buck_bunny.mp4<em class="iq">，" top": 0，" left": 0，" type": "image "，…}，{}]，" version": "2.0.0-rc.4" } </em></p></blockquote><h2 id="bdfe" class="mg lj iq bd lk mh mi dn lo mj mk dp ls kf ml mm lw kj mn mo ma kn mp mq me mr bi translated"><strong class="ak">#第三步</strong></h2><p id="ee45" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">您已成功将视频src保存到JSON对象。现在我们需要使用<strong class="jw ir"> loadFromJSON </strong>再次渲染它</p><blockquote class="nk nl nm"><p id="69e6" class="ju jv nn jw b jx jy jz ka kb kc kd ke no kg kh ki np kk kl km nq ko kp kq kr ij bi translated"><strong class="jw ir"> loadFromJSON </strong>方法，用于将JSON对象转换为实际的fabric对象，并将它们加载到画布上。</p></blockquote><p id="4cb7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在的问题是，它将如何理解自定义属性<code class="fe nh ni nj my b">video_src</code>，答案是，它不会，我们需要再次创建一个视频元素并手动渲染它。</p><p id="282c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为此，我们需要在loadFromJSON 的回调方法上循环遍历对象，找出视频对象并手动处理它，其余的对象，即<em class="nn">文本、图像</em>将被正确渲染。</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="0ae7" class="mg lj iq my b gy nc nd l ne nf"><strong class="my ir">var</strong> data = <em class="nn">{“objects”: [{“src”: “”, “video_src”: “</em>http://www.quirksmode.org/html5/videos/big_buck_bunny.mp4<em class="nn">”, “top”: 0, “left”: 0, “type”: “image”, …}, {}], “version”: “2.0.0-rc.4” }</em></span><span id="254e" class="mg lj iq my b gy ng nd l ne nf"><strong class="my ir">var </strong>canvas = canvas.loadFromJSON(JSON.stringify(data), canvasLoaded , <strong class="my ir">function</strong>(o, object) {<br/>    fabric.log(o, object);<br/>});</span><span id="cd72" class="mg lj iq my b gy ng nd l ne nf"><strong class="my ir">function </strong>canvasLoaded(){      <br/>   canvas.renderAll.bind(canvas);<br/>   <strong class="my ir">var </strong>objs = data['objects'];      <br/>   <strong class="my ir">for</strong>(<strong class="my ir">var </strong>i=0; i&lt; objs.length; i++){<br/>      <strong class="my ir">if</strong>(objs[i].hasOwnProperty('video_src')){<br/>         <strong class="my ir">var </strong>videoE = getVideoElement(objs[i]['video_src']); <br/>         <strong class="my ir">var </strong>fab_video = <strong class="my ir">new </strong>fabric.Image(videoE, {left: objs[i]['left'], top: objs[i]['top']} );                   <br/>         canvas.add(fab_video);<br/>         fab_video.getElement().play();                 <br/>         fabric.util.requestAnimFrame(<strong class="my ir">function </strong>render() {                      <br/>            canvas.renderAll();                     <br/>            fabric.util.requestAnimFrame(render);                <br/>         });<br/>      }<br/>   }<br/>}</span></pre><p id="8237" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个使用fabric来序列化和反序列化视频元素的解决方法。</p><p id="33b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="nn">(通过给别人</em>帮助别人在Medium上找到我的文章)👏🏽<em class="nn">下图。)</em></p></div></div>    
</body>
</html>