<html>
<head>
<title>Generic Map, Filter and Reduce in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的通用映射、过滤和减少</h1>
<blockquote>原文：<a href="https://itnext.io/generic-map-filter-and-reduce-in-go-3845781a591c?source=collection_archive---------0-----------------------#2022-07-26">https://itnext.io/generic-map-filter-and-reduce-in-go-3845781a591c?source=collection_archive---------0-----------------------#2022-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a57c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用泛型在Go中实现高阶函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68702d2a19aa0e77f94fc63bd5265efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7VGUBgCYJksbByk--D4PA.png"/></div></div></figure><p id="3bca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">有了泛型，增加对高阶函数的支持突然变得容易多了，比如Go中的<code class="fe lz ma mb mc b">Map</code>、<code class="fe lz ma mb mc b">Filter</code>和<code class="fe lz ma mb mc b">Reduce</code>。然而，围绕这些功能应该如何实现存在很多分歧。</p><p id="9601" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我认为这种困惑部分源于这样一个事实，即许多Go开发者来自Java和C#背景。他们已经在主导这些语言的编程社区的面向对象编程思想上投入了大量资金。这导致了将<code class="fe lz ma mb mc b">Map</code>、<code class="fe lz ma mb mc b">Filter</code>和<code class="fe lz ma mb mc b">Reduce</code>定义为方法的尝试。让我们来看一次这样失败的尝试，将<code class="fe lz ma mb mc b">Reduce</code>作为一个方法添加到一个定制的集合类型<code class="fe lz ma mb mc b">Array</code>。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="a26f" class="mh mi it mc b gy mj mk l ml mm">package main<br/><br/>import "fmt"<br/><br/>type Array[V any] struct {<br/>	elements []V<br/>}<br/><br/>type Reducer[T, V any] func(accum T, value V) T<br/><br/>func (xs Array[V]) Reduce[T any](f Reducer[T, V]) T {<br/>	var accum T<br/>	for _, x := range xs.elements {<br/>		accum = f(accum, x)<br/>	}<br/>	return accum<br/>}<br/><br/>func adder(accum, x int) int {<br/>	return accum + x<br/>}<br/><br/>func main() {<br/>	numbers := Array{[]int{1, 2, 3, 4, 5}}<br/>	total := numbers.Reduce(adder)<br/><br/>	fmt.Println(total)<br/>}</span></pre><p id="502c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">程序将无法编译，并显示错误消息:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="4121" class="mh mi it mc b gy mj mk l ml mm">reducer.go:11:26: syntax error: method must have no type parameters</span></pre><p id="0106" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原因是我们在<code class="fe lz ma mb mc b">Reduce</code>方法上引入了一个类型参数<code class="fe lz ma mb mc b">T</code>。Go不允许向方法中引入新的类型参数。你必须使用在你的集合上定义的类型参数，比如<code class="fe lz ma mb mc b">V</code>。一个可能的解决方案是在<code class="fe lz ma mb mc b">Array</code>参数类型的定义中添加一个额外的类型参数<code class="fe lz ma mb mc b">T</code>。</p><p id="c387" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我认为这样的解决方案是一个丑陋的黑客，违背了优秀go编程的哲学，也是一个糟糕的软件工程选择。让我引用一位核心围棋设计师的话:</p><blockquote class="mn"><p id="8996" class="mo mp it bd mq mr ms mt mu mv mw lp dk translated">对于通用数据类型，最好使用函数，而不是编写需要方法的约束。</p><p id="6552" class="mo mp it bd mq mr ms mt mu mv mw lp dk translated">伊恩·兰斯·泰勒</p></blockquote><p id="446f" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">方法被过度使用，Go不鼓励它们的使用实际上是一件好事。这不仅仅是像Ian Lance Taylor这样的围棋设计者的信念，也是C++社区中一些杰出人士的信念。</p><blockquote class="mn"><p id="32a2" class="mo mp it bd mq mr ms mt mu mv mw lp dk translated">有效C++第23条:比起成员函数，更喜欢非成员非友元函数</p><p id="25e9" class="mo mp it bd mq mr ms mt mu mv mw lp dk translated">—斯科特·梅耶斯</p></blockquote><p id="adab" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">Go中的I/O系统给出了一个很好的例子，说明为什么自由函数在大多数情况下比方法好得多。Go有许多类型的I/O对象，如管道、文件、套接字和字符串缓冲区。所有这些I/O对象都支持这两个简单的Go接口:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="802a" class="mh mi it mc b gy mj mk l ml mm">type Reader interface {<br/>    Read(buf []byte) (n int, err error)<br/>}<br/><br/>type Writer interface {<br/>    Write(p []byte) (n int, err error)<br/>}</span></pre><p id="dc75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go提供了许多免费的功能，可以使用这些接口。例如，您可以用<code class="fe lz ma mb mc b">Fprintf</code>函数将格式化的文本输出写到<code class="fe lz ma mb mc b">Writer</code>对象。因此，您可以使用此函数写入您已打开的文件:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="26d4" class="mh mi it mc b gy mj mk l ml mm">file, err := os.Create("message.txt")<br/>if err != nil {<br/>	panic(err)<br/>}<br/>defer file.Close()<br/><br/>fmt.Fprintf(file, "Hello %s!", name)</span></pre><p id="ec91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">添加<code class="fe lz ma mb mc b">Fprintf</code>作为方法不是更好更面向对象吗？</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="ae6a" class="mh mi it mc b gy mj mk l ml mm">file.Fprintf(file, "Hello %s!", name)</span></pre><p id="5741" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不，这种方法不是一个好的解决方案。这种方法意味着每一个 I/O类型都需要添加一个<code class="fe lz ma mb mc b">Fprintf</code>方法到<em class="nc">中。来自面向对象编程爱好者的反对意见是<code class="fe lz ma mb mc b">Fprintf</code>应该被添加到一个基类中，所有的I/O对象都必须继承这个基类。这是一个糟糕的解决方案，原因有几个:</em></p><ul class=""><li id="a75a" class="nd ne it kw b kx ky la lb ld nf lh ng ll nh lp ni nj nk nl bi translated">继承产生了紧密耦合。对基类的更改会破坏子类。阅读关于<a class="ae nm" href="https://en.wikipedia.org/wiki/Fragile_base_class" rel="noopener ugc nofollow" target="_blank">脆弱基类问题</a>。</li><li id="ea82" class="nd ne it kw b kx nn la no ld np lh nq ll nr lp ni nj nk nl bi translated">I/O库的设计者必须预测子类需要的所有可能的功能。</li><li id="ae5e" class="nd ne it kw b kx nn la no ld np lh nq ll nr lp ni nj nk nl bi translated">Go不支持继承。</li></ul><p id="fdab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将功能添加为独立包中的免费功能，我们可以扩展现有类型的功能，而不必编辑基类的源代码。Swift、Objective-C和Smalltalk等语言通过引入类别的概念解决了这个问题:添加到现有类中的方法集合。</p><p id="ff56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，像类别这样的解决方案需要动态语言，其中类是可以在运行时修改的对象。在运行时修改类型会导致自身的一系列问题。</p><p id="a4a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，好的软件设计迫使我们保持接口最少的类型。类型应该只具有实现类型的最基本功能所需的最少数量的方法。其他功能应该作为免费功能提供。这种策略允许我们将类型的功能扩展组织成包。每个包都有明确的用法，给我们一个更加模块化的代码。</p><h2 id="bf4a" class="mh mi it bd ns nt nu dn nv nw nx dp ny ld nz oa ob lh oc od oe ll of og oh oi bi translated">将映射、过滤和减少实现为自由函数</h2><p id="d10e" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">实现<code class="fe lz ma mb mc b">Map</code>、<code class="fe lz ma mb mc b">Filter</code>和<code class="fe lz ma mb mc b">Reduce</code>的正确方法是将它们定义为<em class="nc">自由函数</em>。将它们转换成方法是一个糟糕的选择，因为这意味着在多个类型中重新实现相同的方法。即使Go支持继承，但事实上它并不支持，我们也会被让每个集合类型继承相同的基本接口的要求所困扰。我们最终会得到一个紧密耦合且脆弱的设计。</p><p id="5ae6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种简单的方法是实现这些函数来直接处理集合类型:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="51be" class="mh mi it mc b gy mj mk l ml mm">// Don't do this<br/>func Reduce[T, V any](xs Array[V], f Reducer[T, V]) T {<br/>	var accum T<br/>	for _, x := range xs.elements {<br/>		accum = f(accum, x)<br/>	}<br/>	return accum<br/>}</span></pre><p id="db62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么这个解决方案是个坏主意？它有一些与早期解决方案相同的缺陷，也有一些新的缺陷:</p><ul class=""><li id="3ed1" class="nd ne it kw b kx ky la lb ld nf lh ng ll nh lp ni nj nk nl bi translated">我们必须为每个集合类型实现相同的<code class="fe lz ma mb mc b">Reduce</code>函数，导致代码重复。</li><li id="bc05" class="nd ne it kw b kx nn la no ld np lh nq ll nr lp ni nj nk nl bi translated">Go不支持函数重载，所以即使你尝试了，这种方法实际上也不会起作用。</li></ul><p id="d808" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该认识到的关键点是，您希望对任何集合类型执行相同的基本操作。我们必须抽象出不同集合类型之间的区别，并与接口而不是具体的集合类型对话。</p><p id="095f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决方案是使用迭代器而不是具体的类。使用迭代器，我们可以实现像<code class="fe lz ma mb mc b">Map</code>、<code class="fe lz ma mb mc b">Filter</code>和<code class="fe lz ma mb mc b">Reduce</code>这样的算法，这样它们就可以应用于任何可以通过迭代器访问的集合类型。</p><h2 id="fe50" class="mh mi it bd ns nt nu dn nv nw nx dp ny ld nz oa ob lh oc od oe ll of og oh oi bi translated">定义集合的迭代器接口</h2><p id="922d" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">我们希望我们的算法能和抽象迭代器一起工作。算法不需要知道它们是否在二叉树、字典、数组或集合上迭代。我已经在Go <code class="fe lz ma mb mc b">Scanner</code>类型如何工作的基础上建模了我的迭代器接口，它有一个类似迭代器的接口。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="8ded" class="mh mi it mc b gy mj mk l ml mm">type Iterator[T any] interface {<br/>	Next() bool<br/>	Value() T<br/>}</span></pre><p id="8039" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个接口是专门设计的，因此您应该能够使用for循环轻松地迭代集合:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="eb8d" class="mh mi it mc b gy mj mk l ml mm">// print out every value in the collection iterated over<br/>for iter.Next() {<br/>    fmt.Println(iter.Value())<br/>}</span></pre><p id="be62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以创建这个迭代器接口的一些具体实现。能够迭代一个常规的Go切片将非常有用:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="0204" class="mh mi it mc b gy mj mk l ml mm">type SliceIterator[T any] struct {<br/>	Elements []T<br/>	value    T<br/>	index    int<br/>}<br/><br/>// Create an iterator over the slice xs<br/>func NewSliceIterator[T any](xs []T) Iterator[T] {<br/>	return &amp;SliceIterator[T]{<br/>		Elements: xs,<br/>	}<br/>}<br/><br/>// Move to next value in collection<br/>func (iter *SliceIterator[T]) Next() bool {<br/>	if iter.index &lt; len(iter.Elements) {<br/>		iter.value = iter.Elements[iter.index]<br/>		iter.index += 1<br/>		return true<br/>	}<br/><br/>	return false<br/>}<br/><br/>// Get current element<br/>func (iter *SliceIterator[T]) Value() T {<br/>	return iter.value<br/>}</span></pre><p id="edab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在有足够的实现来允许对一部分数字进行迭代:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="27a2" class="mh mi it mc b gy mj mk l ml mm">var numbers []int = []int{1, 2, 3, 4, 5}<br/><br/>iter := NewSliceIterator(numbers)<br/>for iter.Next() {<br/>	fmt.Println(iter.Value())<br/>}</span></pre><h2 id="b62c" class="mh mi it bd ns nt nu dn nv nw nx dp ny ld nz oa ob lh oc od oe ll of og oh oi bi translated">使用迭代器实现算法</h2><p id="1811" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">现在我们已经定义了迭代器，我们可以使用这些迭代器来定义算法。我们返回一个新的迭代器，而不是收集值并在集合中返回它们。通过返回一个迭代器，我们可以灵活地链接这些高阶函数，并将输出写入任何我们喜欢的数据结构。在查看算法实现之前，我想向您展示一旦实现后如何使用它们:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="b98a" class="mh mi it mc b gy mj mk l ml mm">var numbers []int = []int{1, 2, 3, 4, 5}<br/><br/>// Create iterator over a slice of integers<br/>iter := NewSliceIterator(numbers)<br/><br/>// Pick values larger than 3<br/>filtered := Filter(iter, func(x int) bool {<br/>	return x &gt; 3<br/>})<br/><br/>// Square all values<br/>mapped := Map(filtered, func(x int) int {<br/>	return x * x<br/>})<br/><br/>// Collect result from collection<br/>result := Collect(mapped)<br/><br/>for _, x := range result {<br/>	fmt.Println(x)<br/>}</span></pre><p id="5eaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lz ma mb mc b">Map</code>和<code class="fe lz ma mb mc b">Filter</code>以迭代器作为输入，产生迭代器作为输出。这种设计选择的效果是我们模仿了懒惰评估。当调用<code class="fe lz ma mb mc b">Map</code>时，集合的值实际上并没有立即被映射。这种策略的一个好处是，如果我们在同一个集合上执行许多算法，我们可以避免大量的内存分配，这可能会降低性能。在上面的例子中，在调用<code class="fe lz ma mb mc b">Collect</code>之前，不要为结果分配任何内存。</p><p id="93ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个特殊的例子中，调用<code class="fe lz ma mb mc b">Collect</code>是不必要的，因为我们只是打印出每个值。相反，我们可以直接访问for循环中的迭代器:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="fa40" class="mh mi it mc b gy mj mk l ml mm">for mapped.Next() {<br/>	fmt.Println(mapped.Value())<br/>}</span></pre><h2 id="ae3c" class="mh mi it bd ns nt nu dn nv nw nx dp ny ld nz oa ob lh oc od oe ll of og oh oi bi translated">地图功能实现</h2><p id="e29b" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">让我们看看要实现的最简单的函数，<code class="fe lz ma mb mc b">Map</code>。大多数功能实际上都在特殊的迭代器对象中，<code class="fe lz ma mb mc b">mapIterator</code>返回。实际的值映射发生在<code class="fe lz ma mb mc b">Value</code>方法中。迭代器存储映射函数<code class="fe lz ma mb mc b">mapper</code>和迭代器<code class="fe lz ma mb mc b">source</code>到底层集合。</p><p id="9e9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lz ma mb mc b">Map</code>函数本身非常愚蠢，它只是构造了一个<code class="fe lz ma mb mc b">mapIterator</code>并返回它。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="4bcf" class="mh mi it mc b gy mj mk l ml mm">type mapIterator[T any] struct {<br/>	source Iterator[T]<br/>	mapper func(T) T<br/>}<br/><br/>// advance to next element<br/>func (iter *mapIterator[T]) Next() bool {<br/>	return iter.source.Next()<br/>}<br/><br/>func (iter *mapIterator[T]) Value() T {<br/>	value := iter.source.Value()<br/>	return iter.mapper(value)<br/>}<br/><br/>func Map[T any](iter Iterator[T], f func(T) T) Iterator[T] {<br/>	return &amp;mapIterator[T]{<br/>		iter, f,<br/>	}<br/>}</span></pre><h2 id="6674" class="mh mi it bd ns nt nu dn nv nw nx dp ny ld nz oa ob lh oc od oe ll of og oh oi bi translated">过滤功能实现</h2><p id="a65e" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated"><code class="fe lz ma mb mc b">Filter</code>函数被设计成只保留那些与提供的<em class="nc">谓词</em>相匹配的值。谓词是一个函数，它将一个元素作为输入，并根据所提供的元素是否匹配过滤标准来返回<code class="fe lz ma mb mc b">true</code>或<code class="fe lz ma mb mc b">false</code>。一些例子可能是奇数或偶数。如果谓词是奇数，那么只返回奇数。</p><p id="11d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lz ma mb mc b">Filter</code>的实现与<code class="fe lz ma mb mc b">Map</code>略有不同。在这种情况下，功能主要在<code class="fe lz ma mb mc b">Next</code>方法中，而不是在<code class="fe lz ma mb mc b">Value</code>方法中。我们不改变任何值，而是故意跳过不匹配谓词的值。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="9c79" class="mh mi it mc b gy mj mk l ml mm">type filterIterator[T any] struct {<br/>	source Iterator[T]<br/>	pred   func(T) bool<br/>}<br/><br/>func (iter *filterIterator[T]) Next() bool {<br/>	for iter.source.Next() {<br/>		if iter.pred(iter.source.Value()) {<br/>			return true<br/>		}<br/>	}<br/>	return false<br/>}<br/><br/>func (iter *filterIterator[T]) Value() T {<br/>	return iter.source.Value()<br/>}<br/><br/>func Filter[T any](iter Iterator[T], pred func(T) bool) Iterator[T] {<br/>	return &amp;filterIterator[T]{<br/>		iter, pred,<br/>	}<br/>}</span></pre><h2 id="23ec" class="mh mi it bd ns nt nu dn nv nw nx dp ny ld nz oa ob lh oc od oe ll of og oh oi bi translated">收集结果</h2><p id="d6e0" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">迟早，我们需要从我们对输入数据执行的所有转换中获得结果。这就是<code class="fe lz ma mb mc b">Collect</code>功能的用途。它接受一个迭代器作为输入，并用迭代器中的值填充一个片。</p><p id="74ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">人们可以想象出<code class="fe lz ma mb mc b">Collect</code>功能的许多不同变体。我们可以有将输出写到另一个迭代器的变体。在这种情况下，我们需要一个支持设置值的输出迭代器接口。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="a66a" class="mh mi it mc b gy mj mk l ml mm">func Collect[T any](iter Iterator[T]) []T {<br/>	var xs []T<br/><br/>	for iter.Next() {<br/>		xs = append(xs, iter.Value())<br/>	}<br/><br/>	return xs<br/>}</span></pre><h2 id="83ab" class="mh mi it bd ns nt nu dn nv nw nx dp ny ld nz oa ob lh oc od oe ll of og oh oi bi translated">将输入值缩减为单个值</h2><p id="3c5d" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">最后是<code class="fe lz ma mb mc b">Reduce</code>函数，这个函数让无数Go程序员挠头，因为我们要处理两个不同的类型参数。我们需要为数组中的每个元素指定一种类型，在本例中，我们将调用<code class="fe lz ma mb mc b">V</code>来指定值。此外，我们需要不同类型的累计值。在这个例子中，我调用类型参数<code class="fe lz ma mb mc b">T</code>。</p><p id="5fe5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使代码更加清晰，我选择给reducer函数一个单独的名字，<code class="fe lz ma mb mc b">Reducer.</code>它是一个二元函数(有两个参数),返回一个值。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="b8f5" class="mh mi it mc b gy mj mk l ml mm">type Reducer[T, V any] func(accum T, value V) T<br/><br/>// Reduce values iterated over to a single value<br/>func Reduce[T, V any](iter Iterator[V], f Reducer[T, V]) T {<br/>	var accum T<br/>	for iter.Next() {<br/>		accum = f(accum, iter.Value())<br/>	}<br/>	return accum<br/>}</span></pre><p id="9592" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">许多人对reduce函数感到困惑，所以让我给你一个我们如何使用它的例子。示例代码使用加法减少了输入。您可以用乘法替换加号来计算所提供数字的乘积。</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="c72e" class="mh mi it mc b gy mj mk l ml mm">var numbers []int = []int{1, 2, 3, 4, 5}<br/>iter := NewSliceIterator(numbers)<br/><br/>result := Reduce(iter, func(accum, x int) int {<br/>	return accum + x<br/>})<br/><br/>fmt.Println(result)</span></pre><h2 id="0081" class="mh mi it bd ns nt nu dn nv nw nx dp ny ld nz oa ob lh oc od oe ll of og oh oi bi translated">替代迭代器实现</h2><p id="ca6f" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">我在这里定义的迭代器接口受到了我在Go标准库中看到的类似迭代器的功能的启发，比如<a class="ae nm" href="https://pkg.go.dev/go/scanner" rel="noopener ugc nofollow" target="_blank"> Scanner </a>。我的实现非常简单，可以想象会有很多改进，比如存储迭代过程中可能遇到的错误。例如，如果我们将文件访问和从文件中读取行表示为迭代，这可能是有用的。</p><p id="f0af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">区分用于读取的迭代器和用于写入的迭代器也很有用。在许多方面，这种需求与Go标准库中普遍存在的<code class="fe lz ma mb mc b">Reader</code>和<code class="fe lz ma mb mc b">Writer</code>接口非常相似。编写器界面可能如下所示:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="f81f" class="mh mi it mc b gy mj mk l ml mm">type OutputIterator[T any] interface {<br/>	Iterator[T]<br/>	SetValue(x T) <br/>}</span></pre><p id="aaea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个有用的迭代器设计是由<a class="ae nm" href="https://pkg.go.dev/google.golang.org/api/iterator" rel="noopener ugc nofollow" target="_blank"> Google Cloud客户端库</a>使用的。这些迭代器是在泛型之前制造的，但是可以作为创建基于模板的迭代器的模板。下面是一个用法示例:</p><pre class="kj kk kl km gt md mc me mf aw mg bi"><span id="41ad" class="mh mi it mc b gy mj mk l ml mm">it := client.Books(ctx, shelfName)<br/>for {<br/>	book, err := it.Next()<br/>	if err == iterator.Done {<br/>		break<br/>	}<br/>	if err != nil {<br/>		return err<br/>	}<br/>	process(book)<br/>}</span></pre><p id="0908" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就我个人而言，我不知道是否要采用这种方法。一方面，这是谷歌做的，谷歌也做围棋。那一定有意义。另一方面，这种设计看起来与Go标准库中的迭代方式大相径庭。对我来说，将迭代结束视为错误条件似乎有点奇怪。我更喜欢<code class="fe lz ma mb mc b">Scanner</code>有一个独立的错误字段，你可以在迭代结束时读取。</p><h2 id="bf78" class="mh mi it bd ns nt nu dn nv nw nx dp ny ld nz oa ob lh oc od oe ll of og oh oi bi translated">在Go中应该使用迭代器吗？</h2><p id="5f0e" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">实际上，我对实现和使用这些迭代器的实用性持怀疑态度。那你为什么要花一整篇文章来描述如何去做呢？我绝对认为这个想法值得追求，但我不认为你应该仅仅因为有可能就去做某件事。</p><blockquote class="mn"><p id="d9b5" class="mo mp it bd mq mr ms mt mu mv mw lp dk translated">Go不是为这里描述的那种高级函数式编程而设计的。目的是用简单的循环编写枯燥、简单的代码。</p></blockquote><p id="4ae2" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">我不禁想起我过去在C++中使用这种高级结构的经历。起初，我满怀信心地接受了它们，但后来发现我从使用它们中获益甚少。例如，简单的for循环更容易调试。通过大量迭代器和闭包完成的处理将更难调试。</p><p id="da38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，我每天都使用很多函数式编程，但那是在Julia中，它更适合这种编程。Julia提供了一个交互式的REPL环境，其中每个值都有一个默认的、合理的文本表示。这意味着，在Julia中，在调试解决方案并检查其功能时，开发一个非常实用的解决方案是毫不费力的。Go编程不是基于REPL或非常实用的。在为函数式编程设计的语言中，几乎所有东西都是表达式，而不是语句。</p><p id="9cb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我坚信应该按照语言的本意来使用它们。我使用Objective-C很长时间了，还记得由于iOS，这个市场被拥有Java、JavaScript和Ruby背景的人所淹没。他们带走了许多在客观世界中毫无意义的习语。使用Objective-C代码工作一点也不好玩，有人曾试图把它当成Java来编程。</p><p id="a600" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，试图把Go当成某种Haskell或OCaml来编程也不是个好主意。围棋有自己的成语。Go编程的一个非常核心的部分是goroutines和channels。我认为对于人们在其他语言中使用的高阶函数，如map、filter和reduce，通道通常是Go中更好的抽象。</p><p id="14fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可行的方法是以简单直接的方式构建东西。如果你发现你得到了很多样板文件和重复的代码，那么你会考虑使用更多的抽象。不要为了解决某个问题而发明大量花哨的抽象概念。那不是正确的方法。围棋道枯燥又简单。</p></div></div>    
</body>
</html>