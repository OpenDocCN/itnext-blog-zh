<html>
<head>
<title>How to build a simple Vue CLI plugin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建一个简单的Vue CLI插件</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-a-simple-vue-cli-plugin-a2e1323de1a0?source=collection_archive---------1-----------------------#2018-10-15">https://itnext.io/how-to-build-a-simple-vue-cli-plugin-a2e1323de1a0?source=collection_archive---------1-----------------------#2018-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3618ce233d15563ee87dab29952766e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bgft1jE3SrNlllxL0IJKYg.png"/></div></div></figure><div class=""/><p id="6782" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你正在使用Vue框架，你可能已经知道什么是Vue CLI。这是一个用于快速Vue.js开发的完整系统，提供项目脚手架和原型。</p><p id="d0f9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">cli的一个重要部分是CLI插件。他们可以修改内部webpack配置，并向<code class="fe kw kx ky kz b">vue-cli-service</code>注入命令。一个很好的例子是一个<code class="fe kw kx ky kz b">@vue/cli-plugin-typescript</code>:当你调用它时，它会给你的项目添加一个<code class="fe kw kx ky kz b">tsconfig.json</code>并将<code class="fe kw kx ky kz b">App.vue</code>改为有类型，所以你不需要手动操作。</p><p id="5e89" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">插件非常有用，现在有很多插件用于不同的情况——<a class="ae la" href="https://github.com/Akryum/vue-apollo" rel="noopener ugc nofollow" target="_blank">graph QL+Apollo</a>支持,<a class="ae la" href="https://github.com/nklayman/vue-cli-plugin-electron-builder" rel="noopener ugc nofollow" target="_blank">electronic builder</a>添加UI库，如<a class="ae la" href="https://github.com/vuetifyjs/vue-cli-plugin-vuetify" rel="noopener ugc nofollow" target="_blank"> Vuetify </a>或<a class="ae la" href="https://github.com/ElementUI/vue-cli-plugin-element" rel="noopener ugc nofollow" target="_blank"> ElementUI </a> …但是如果你想为某个特定的库安装一个插件，而它并不存在呢？这是我的案子😅…我决定自己动手建造。</p><p id="4098" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将构建一个<a class="ae la" href="https://github.com/NataliaTepluhina/vue-cli-plugin-rx" rel="noopener ugc nofollow" target="_blank"> vue-cli-plugin-rx </a>。它允许我们向我们的项目添加一个<code class="fe kw kx ky kz b">vue-rx</code>库，并在我们的Vue应用程序中获得RxJS支持。</p><h1 id="3e89" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">🎛️ Vue-cli插件结构</h1><p id="5dc7" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">首先，什么是CLI插件？只是一个有一定结构的npm包。关于<a class="ae la" href="https://cli.vuejs.org/dev-guide/plugin-dev.html#core-concepts" rel="noopener ugc nofollow" target="_blank">文档</a>，它<strong class="ka jc">必须</strong>有一个服务插件作为它的主要导出，<strong class="ka jc">可以</strong>有额外的特性，如生成器和提示文件。</p><blockquote class="me mf mg"><p id="b086" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">现在还不清楚什么是服务插件或生成器，但是不用担心——稍后会解释的！</p></blockquote><p id="cad9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，像任何npm包一样，CLI插件的根文件夹中必须有一个<code class="fe kw kx ky kz b">package.json</code>，最好有一个带描述的<code class="fe kw kx ky kz b">README.md</code>。</p><p id="bc2b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，让我们从下面的结构开始:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="ef2f" class="mt lc jb kz b gy mu mv l mw mx">.<br/>├── README.md<br/>├── index.js      # service plugin<br/>└── package.json</span></pre><p id="aca9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看可选部分。一个<strong class="ka jc">生成器</strong>可以将额外的依赖项或字段注入到<code class="fe kw kx ky kz b">package.json</code>中，并将文件添加到项目中。我们需要它吗？当然，我们希望将<code class="fe kw kx ky kz b">rxjs</code>和<code class="fe kw kx ky kz b">vue-rx</code>添加为我们的依赖项！更确切地说，如果用户想在插件安装期间添加组件，我们想创建一些示例组件。因此，我们需要添加<code class="fe kw kx ky kz b">generator.js</code>或<code class="fe kw kx ky kz b">generator/index.js</code>。我更喜欢第二种方式。现在结构看起来像这样:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="4510" class="mt lc jb kz b gy mu mv l mw mx">.<br/>├── README.md<br/>├── index.js      # service plugin<br/>├── generator<br/>│   └── index.js  # generator<br/>└── package.json</span></pre><p id="3cbc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一点要添加的是一个提示文件:我希望我的插件询问用户是否想要一个示例组件。我们需要在根文件夹中有一个<code class="fe kw kx ky kz b">prompts.js</code>文件来实现这个行为。因此，现在的结构如下所示:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="44ab" class="mt lc jb kz b gy mu mv l mw mx">├── README.md<br/>├── index.js      # service plugin<br/>├── generator<br/>│   └── index.js  # generator<br/>├── prompts.js    # prompts file<br/>└── package.json</span></pre><h1 id="f191" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">⚙️服务插件</h1><p id="bd2c" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">服务插件应该导出一个接收两个参数的函数:一个PluginAPI实例和一个包含项目本地选项的对象。它可以扩展/修改不同环境的内部webpack配置，并向<code class="fe kw kx ky kz b">vue-cli-service</code>注入额外的命令。让我们思考一下:我们是想以某种方式改变webpack配置还是创建一个额外的npm任务？答案是<strong class="ka jc">否</strong>，如果有必要，我们只想添加一些依赖项和示例组件。所以我们在<code class="fe kw kx ky kz b">index.js</code>中需要改变的是:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="71f0" class="mt lc jb kz b gy mu mv l mw mx">module.exports = (api, opts) =&gt; {}</span></pre><p id="e845" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的插件需要更改webpack配置，请阅读官方Vue CLI文档中的<a class="ae la" href="https://cli.vuejs.org/dev-guide/plugin-dev.html#service-plugin" rel="noopener ugc nofollow" target="_blank">这一节</a>。</p><h1 id="dd5d" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">🛠️通过生成器添加依赖项</h1><p id="957c" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">如上所述，CLI插件生成器帮助我们添加依赖项和更改项目文件。所以，我们需要做的第一步是让我们的插件增加两个依赖项:<code class="fe kw kx ky kz b">rxjs</code>和<code class="fe kw kx ky kz b">vue-rx</code>:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="330d" class="mt lc jb kz b gy mu mv l mw mx">module.exports = (api, options, rootOptions) =&gt; {<br/>  api.extendPackage({<br/>    dependencies: {<br/>      'rxjs': '^6.3.3',<br/>      'vue-rx': '^6.0.1',<br/>    },<br/>  });<br/>}</span></pre><p id="bce6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生成器应该导出一个接收三个参数的函数:一个GeneratorAPI实例，生成器选项，如果用户使用某个预置创建一个项目，整个预置将作为第三个参数传递。</p><p id="2ad9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">api.extendPackage</code>方法扩展了项目的<code class="fe kw kx ky kz b">package.json</code>。嵌套字段是深度合并的，除非您将<code class="fe kw kx ky kz b">{ merge: false }</code>作为参数传递。在我们的例子中，我们向<code class="fe kw kx ky kz b">dependencies</code>部分添加了两个依赖项。</p><p id="ac2e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要改变一个<code class="fe kw kx ky kz b">main.js</code>文件。为了让RxJS在Vue组件内部工作，我们需要导入一个<code class="fe kw kx ky kz b">VueRx</code>并调用<code class="fe kw kx ky kz b">Vue.use(VueRx)</code></p><p id="c0be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们创建一个要添加到主文件中的字符串:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="caf9" class="mt lc jb kz b gy mu mv l mw mx">let rxLines = `\nimport VueRx from 'vue-rx';\n\nVue.use(VueRx);`;</span></pre><p id="22d0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将使用<code class="fe kw kx ky kz b">api.onCreateComplete</code> hook。当文件被写入磁盘时，它被调用。</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="78bb" class="mt lc jb kz b gy mu mv l mw mx">api.onCreateComplete(() =&gt; {<br/>    // inject to main.js<br/>    const fs = require('fs');<br/>    const ext = api.hasPlugin('typescript') ? 'ts' : 'js';<br/>    const mainPath = api.resolve(`./src/main.${ext}`);<br/>};</span></pre><p id="a296" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们寻找主文件:如果它是一个TypeScript项目，它将是一个<code class="fe kw kx ky kz b">main.ts</code>，否则它将是一个<code class="fe kw kx ky kz b">main.js</code>文件。<code class="fe kw kx ky kz b">fs</code>这里是一个文件系统。</p><p id="56d2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们改变文件内容</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="bda6" class="mt lc jb kz b gy mu mv l mw mx">api.onCreateComplete(() =&gt; {<br/>    // inject to main.js<br/>    const fs = require('fs');<br/>    const ext = api.hasPlugin('typescript') ? 'ts' : 'js';<br/>    const mainPath = api.resolve(`./src/main.${ext}`);</span><span id="6582" class="mt lc jb kz b gy my mv l mw mx">    // get content<br/>    let contentMain = fs.readFileSync(mainPath, { encoding: 'utf-8' });<br/>    const lines = contentMain.split(/\r?\n/g).reverse();</span><span id="fc8a" class="mt lc jb kz b gy my mv l mw mx">    // inject import<br/>    const lastImportIndex = lines.findIndex(line =&gt; line.match(/^import/));<br/>    lines[lastImportIndex] += rxLines;</span><span id="6b5b" class="mt lc jb kz b gy my mv l mw mx">    // modify app<br/>    contentMain = lines.reverse().join('\n');<br/>    fs.writeFileSync(mainPath, contentMain, { encoding: 'utf-8' });<br/>  });<br/>};</span></pre><p id="743e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生了什么事？我们正在读取主文件的内容，将它分成几行并恢复它们的顺序。然后，我们搜索带有<code class="fe kw kx ky kz b">import</code>语句的第一行(这将是第二次还原后的最后一行),并在那里添加我们的<code class="fe kw kx ky kz b">rxLines</code>。在这之后，我们反转行的数组并保存文件。</p><h1 id="911a" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">💻在本地测试cli插件</h1><p id="0fea" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">让我们在<code class="fe kw kx ky kz b">package.json</code>中添加一些关于我们插件的信息，并试着安装到本地进行测试。最重要的信息通常是插件名称和版本(将插件发布到npm时需要这些字段)，但是可以随意添加更多信息！<code class="fe kw kx ky kz b">package.json</code>字段的完整列表可以在<a class="ae la" href="https://docs.npmjs.com/files/package.json" rel="noopener ugc nofollow" target="_blank">这里</a>找到。以下是我的文件:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="cf43" class="mt lc jb kz b gy mu mv l mw mx">{<br/>  "name": "vue-cli-plugin-rx",<br/>  "version": "0.1.5",<br/>  "description": "Vue-cli 3 plugin for adding RxJS support to project using vue-rx",<br/>  "main": "index.js",<br/>  "repository": {<br/>    "type": "git",<br/>    "url": "git+https://github.com/NataliaTepluhina/vue-cli-plugin-rx.git"<br/>  },<br/>  "keywords": [<br/>    "vue",<br/>    "vue-cli",<br/>    "rxjs",<br/>    "vue-rx"<br/>  ],<br/>  "author": "Natalia Tepluhina &lt;my@mail.com&gt;",<br/>  "license": "MIT",<br/>  "homepage": "https://github.com/NataliaTepluhina/vue-cli-plugin-rx#readme"<br/>}</span></pre><p id="a886" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是时候检查我们的插件是如何工作的了！为此，让我们创建一个简单的基于vue-cli的项目:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="235e" class="mt lc jb kz b gy mu mv l mw mx">vue create test-app</span></pre><p id="e0d9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">转到项目文件夹，安装我们新创建的插件:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="691f" class="mt lc jb kz b gy mu mv l mw mx">cd test-app<br/>npm install --save-dev file:/full/path/to/your/plugin</span></pre><p id="2030" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">插件安装后，您需要调用它:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="4aa9" class="mt lc jb kz b gy mu mv l mw mx">vue invoke vue-cli-plugin-rx</span></pre><p id="b08e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果您尝试检查<code class="fe kw kx ky kz b">main.js</code>文件，您可以看到它发生了变化:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="5e35" class="mt lc jb kz b gy mu mv l mw mx">import Vue from 'vue'<br/>import App from './App.vue'<br/>import VueRx from 'vue-rx';</span><span id="849d" class="mt lc jb kz b gy my mv l mw mx">Vue.use(VueRx);</span></pre><p id="99fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，你可以在你的测试应用<code class="fe kw kx ky kz b">package.json</code>的<code class="fe kw kx ky kz b">devDependencies</code>部分找到你的插件。</p><h1 id="3974" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">📂使用生成器创建新组件</h1><p id="0836" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">太好了，一个插件工作了！是时候扩展一下它的功能，让它能够创建一个示例组件了。生成器API为此使用了一个<code class="fe kw kx ky kz b">render</code>方法。</p><p id="4157" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们创建这个示例组件。它应该是位于项目<code class="fe kw kx ky kz b">src/components</code>文件夹中的<code class="fe kw kx ky kz b">.vue</code>文件。在<code class="fe kw kx ky kz b">generator</code>文件夹中创建一个<code class="fe kw kx ky kz b">template</code>文件夹，然后在其中模仿整个结构:</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a6ba0206291bb92d5b6afbc3076d4cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*6DvgakVrMu0gOjYf.png"/></div></figure><p id="4676" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的示例组件应该是…嗯，只是一个Vue单文件组件！在本文中，我不会深入RxJS的解释，但是我创建了一个简单的基于RxJS的点击计数器，它有两个按钮:</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/d249b0b12d0fe9149c81bf8c4dd37ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iPcuMhIyCGNdYreo.png"/></div></div></figure><p id="0747" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它的源代码可以在这里找到<a class="ae la" href="https://github.com/NataliaTepluhina/vue-cli-plugin-rx/blob/master/generator/template/src/components/RxExample.vue" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="28fc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要指示插件在调用时呈现这个组件。为此，让我们将这段代码添加到<code class="fe kw kx ky kz b">generator/index.js</code>:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="d01e" class="mt lc jb kz b gy mu mv l mw mx">api.render('./template', {<br/>  ...options,<br/>});</span></pre><p id="7e0f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将渲染整个<code class="fe kw kx ky kz b">template</code>文件夹。现在，当插件被调用时，一个新的<code class="fe kw kx ky kz b">RxExample.vue</code>将被添加到<code class="fe kw kx ky kz b">src/components</code>文件夹中。</p><blockquote class="me mf mg"><p id="7ce7" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">我决定不覆盖一个 <code class="fe kw kx ky kz b"><em class="jb">App.vue</em></code> <em class="jb">，让用户自己添加一个示例组件。但是，您可以替换部分现有文件，参见文档</em> 中的 <a class="ae la" href="https://cli.vuejs.org/dev-guide/plugin-dev.html#generator" rel="noopener ugc nofollow" target="_blank"> <em class="jb">示例</em></a></p></blockquote><h1 id="7753" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">⌨️用提示处理用户选择</h1><p id="9c59" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">如果用户不想要一个示例组件呢？让用户在插件安装过程中决定这一点不是很明智吗？这就是提示存在的原因！</p><p id="cbd9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之前我们已经在插件根文件夹中创建了<code class="fe kw kx ky kz b">prompts.js</code>文件。这个文件应该包含一个问题数组:每个问题都是一个具有特定字段集的对象，如<code class="fe kw kx ky kz b">name</code>、<code class="fe kw kx ky kz b">message</code>、<code class="fe kw kx ky kz b">choices</code>、<code class="fe kw kx ky kz b">type</code>等。</p><blockquote class="me mf mg"><p id="e1f9" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">名称很重要:我们稍后将在generator中使用它来创建一个呈现示例组件的条件！</p></blockquote><p id="dff8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提示可以有<a class="ae la" href="https://github.com/SBoudrias/Inquirer.js#prompt-types" rel="noopener ugc nofollow" target="_blank">不同的类型</a>，但是在CLI中使用最广泛的是<code class="fe kw kx ky kz b">checkbox</code>和<code class="fe kw kx ky kz b">confirm</code>。我们将使用后者来创建一个带有是/否答案的问题。</p><p id="9438" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我们把我们的提示码加到<code class="fe kw kx ky kz b">prompts.js</code>里吧！</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="a0c2" class="mt lc jb kz b gy mu mv l mw mx">module.exports = [<br/>  {<br/>    name: `addExample`,<br/>    type: 'confirm',<br/>    message: 'Add example component to components folder?',<br/>    default: false,<br/>  },<br/>];</span></pre><p id="bba5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个<code class="fe kw kx ky kz b">addExample</code>提示，询问用户是否想要添加一个组件到组件文件夹。默认答案是<code class="fe kw kx ky kz b">No</code>。</p><p id="58b8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到生成器文件并做一些修正。将<code class="fe kw kx ky kz b">api.render</code>调用替换为</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="bb1d" class="mt lc jb kz b gy mu mv l mw mx">if (options.addExample) {<br/>    api.render('./template', {<br/>      ...options,<br/>    });<br/>}</span></pre><p id="0e19" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在检查<code class="fe kw kx ky kz b">addExample</code>是否有肯定的答案，如果有，组件将被渲染。</p><blockquote class="me mf mg"><p id="9b05" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">不要忘记在每次修改后重新安装并测试你的插件！</p></blockquote><h1 id="035d" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">📦公之于众！</h1><p id="0125" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">重要提示:在发布你的插件之前，请检查它的名字是否与模式<code class="fe kw kx ky kz b">vue-cli-plugin-&lt;YOUR-PLUGIN-NAME&gt;</code>匹配。这允许你的插件被<code class="fe kw kx ky kz b">@vue/cli-service</code>发现并通过<code class="fe kw kx ky kz b">vue add</code>安装。</p><p id="e357" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还希望我的插件在Vue CLI UI中有一个漂亮的外观，所以我给<code class="fe kw kx ky kz b">package.json</code>添加了描述、标签和库名，并创建了一个徽标。Logo图片应该命名为<code class="fe kw kx ky kz b">logo.png</code>，放在插件根文件夹中。因此，我的插件在UI插件列表中看起来是这样的:</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/6098406612aa2a15dac94ee04074f259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RAeuVpjYsqVUcYZ7.png"/></div></div></figure><p id="7478" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们准备出版了。你需要注册一个npmjs.com<a class="ae la" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"/>，显然你应该安装npm。</p><p id="393e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要发布一个插件，进入插件根文件夹，在终端输入<code class="fe kw kx ky kz b">npm publish</code>。瞧，你刚刚发布了一个npm包！</p><p id="9cf0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这时你应该可以用<code class="fe kw kx ky kz b">vue add</code>命令安装插件了。试试看！</p><p id="b90b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，本文中描述的插件是非常基础的，但我希望我的说明能帮助某人开始cli插件开发。</p><p id="4f77" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你缺少哪种命令行界面插件？请在评论中分享你的想法🤗</p></div></div>    
</body>
</html>