<html>
<head>
<title>Go Reactive with RXJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对RXJS做出反应</h1>
<blockquote>原文：<a href="https://itnext.io/go-reactive-with-rxjs-c07dd3964cf2?source=collection_archive---------6-----------------------#2018-03-10">https://itnext.io/go-reactive-with-rxjs-c07dd3964cf2?source=collection_archive---------6-----------------------#2018-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/5849357f039550eb923672437aa36930.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*W32jm0SciWZTwPA1zDwK6Q.jpeg"/></div></figure><div class=""/><p id="e7d2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fgo-reactive-with-rxjs-c07dd3964cf2" rel="noopener ugc nofollow" target="_blank"> <em class="kt">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="2299" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我用反应式的方式编程已经快两年了，如果没有它，我几乎无法思考。反应式编码方式更清晰地代表了真实世界的场景。</p><p id="c8e2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我想写这篇文章作为一个引子，与那些想将他们的范式转换到反应式编码方式的人分享我的经验。</p><blockquote class="ku kv kw"><p id="5916" class="ju jv kt jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated">在计算领域，<strong class="jw iy">反应式编程</strong>是一种声明式<strong class="jw iy">编程</strong>范例，关注数据流和变化的传播。(来源维基百科)</p></blockquote><h2 id="a486" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">先决条件</h2><ul class=""><li id="8e65" class="lt lu ix jw b jx lv kb lw kf lx kj ly kn lz kr ma mb mc md bi translated">Javascript(如果你懂javascript会更好)</li><li id="1c5a" class="lt lu ix jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">节点和国家预防机制</li><li id="efab" class="lt lu ix jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">HTTP和Rest API</li><li id="dbe4" class="lt lu ix jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">Javascript框架(在本文中我将使用angular 2x)</li></ul><h2 id="7b67" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">异步和反应式编程</h2><blockquote class="ku kv kw"><p id="5c6f" class="ju jv kt jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated">异步编程是并行编程的一种形式，它允许一个工作单元独立于主应用程序线程运行。当工作完成时，它通知主线程(以及工作是完成还是失败)。使用它有许多好处，例如提高应用程序性能和增强响应能力。(来源stackify.com)</p></blockquote><p id="d1a9" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">简而言之，这就是异步编程。所以最初当我开始编码时，前端只是html页面。异步很好，但是当我转向Angular js并开始使用<strong class="jw iy"> ng-repeat时，</strong>事情开始变得混乱。因为我的角度代码没有等待我的异步调用完成，我的页面只是空白…..真扫兴。</p><p id="0bcc" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后我们开始使用回调。回调只是代码，在特定操作完成后执行，就像ajax调用一样。</p><p id="eb9b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">随着应用程序的进一步增长，这种方法无法扩展。现在，我们有依赖操作链，这导致了回调地狱。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mj"><img src="../Images/0d0e5f883ef70d0483cdb915f3dfc467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-OlfkC2Y1zg9m8S4rUlWQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">搞什么鬼！….回调地狱</figcaption></figure><p id="93be" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我们进一步试图解决这个承诺。它们只是回调的更酷版本，带有一些定义良好的api，如<code class="fe mw mx my mz b">then</code>和<code class="fe mw mx my mz b">catch</code>。</p><p id="73f7" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个<code class="fe mw mx my mz b">Promise</code>代表一个在承诺产生时不一定知道的价值。它允许您将处理程序与异步操作的最终成功值或失败原因相关联。这使得异步方法像同步方法一样返回值:异步方法不是立即返回最终值，而是返回一个<em class="kt">承诺</em>在将来的某个时间提供该值。(<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><p id="830f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mw mx my mz b">Promise</code>处于以下状态之一:</p><ul class=""><li id="db85" class="lt lu ix jw b jx jy kb kc kf na kj nb kn nc kr ma mb mc md bi translated"><em class="kt">待定</em>:初始状态，既未履行也未拒绝。</li><li id="927a" class="lt lu ix jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated"><em class="kt">完成</em>:表示操作成功完成。</li><li id="5c1f" class="lt lu ix jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated"><em class="kt">拒绝</em>:表示操作失败。</li></ul><p id="819d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在行业进一步发展之前，承诺是伟大的，现在是现实世界应用的时候了。我们需要持续的更新，而不仅仅是一次，就像承诺，发生一次就结束了。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/3f4e0eb36d47c8b9ecfb5f3c0c4610ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*CIQAqr4x809t3A7HlDL5cA.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">承诺只会发生一次</figcaption></figure><p id="9f6b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么，接下来是<strong class="jw iy">可观察的，</strong>只是可重用的承诺，在then方法之后继续监听。这就好像你甚至可以从可观察的事物中获取价值，如果被激发一次，可观察的事物发出新的价值。唯一的区别是observable方法拥有subscribe方法，而不是then方法。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/45a54b326d400cb7f85e6ab71fe26448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*63_b8U7sa8gEbxzCXH8V4Q.jpeg"/></div></figure><h2 id="d48f" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">观察者模式</h2><p id="374f" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>是一种软件设计模式，其中一个名为subject的对象维护一个名为observer的依赖者列表，并自动通知它们任何状态变化，通常是通过调用它们的方法之一。它主要用于实现分布式事件处理系统。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ni"><img src="../Images/aa217c494dc680ff815c1d8bd3f1fac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdC2c3tmeC1C4TcyTD0NSg.png"/></div></div></figure><p id="c343" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文的其余部分，我希望您将数据可视化为一系列事件或更新。好了，现在我们理解了异步JavaScript和反应式编程的基础。我们已经了解了从回拨到承诺再到可观察的演变。我们已经了解了数据流。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nj"><img src="../Images/bfaddb92d534e6f6f107afe9881b5e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0FGuokOzQw3mf4j3fqgJXA.gif"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">数据流就是实时数据的连续流动</figcaption></figure><h1 id="a4a4" class="nk lb ix bd lc nl nm nn lf no np nq li nr ns nt ll nu nv nw lo nx ny nz lr oa bi translated">让我们写一些代码</h1><h2 id="6b50" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">设置角度项目</h2><p id="6efe" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated">如果你已经熟悉angular，你会知道我们现在有cli来自动引导我们的项目。如果你没有它，你可以在你的终端上运行下面的命令来安装它。</p><pre class="mk ml mm mn gt ob mz oc od aw oe bi"><span id="bb72" class="la lb ix mz b gy of og l oh oi">sudo npm install -g @angualar/cli<br/>ng new ngrxjs<br/>cd ngrxjs<br/>ng serve</span></pre><p id="6954" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，您可以访问<a class="ae ks" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200 </a>来查看您的angular项目是否准备好并提供服务(请等待上述任务完成后再进行导航)</p><h2 id="ee67" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">创造一个可观察的</h2><p id="5ced" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated">现在我们将创建我们的第一个可观察对象，使用最基本的操作符create(这里有更详细的解释<a class="ae ks" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-create" rel="noopener ugc nofollow" target="_blank"/>)。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oj"><img src="../Images/a2de09cb111dbdd1c8863c160387cc6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqJcYhtGjQKr2pGsARgmrg.png"/></div></div></figure><p id="6563" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请在新创建的项目中的src/app/app.component.ts文件中编写以下代码。</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="c43e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在第16行，我们创建了一个新的可观测值。简单地说，observable是观察者设计模式中的主题，我们观察它们以发出任何更新。</p><p id="c8c0" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在第23行，我们通过向它传递一个包含三个函数的observer对象来表示这是可观察的。</p><ul class=""><li id="229d" class="lt lu ix jw b jx jy kb kc kf na kj nb kn nc kr ma mb mc md bi translated">然后</li><li id="597b" class="lt lu ix jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">错误</li><li id="939c" class="lt lu ix jw b jx me kb mf kf mg kj mh kn mi kr ma mb mc md bi translated">完成</li></ul><p id="2cf1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里将它们作为三个函数传递，这与在observer对象中传递这三个函数几乎相同。如果你回到第17行，我们触发next()几次，所以每次我们在observer上触发next时，我们都会在subscription next中得到一个更新，这是第24行的方法，最后当observer上调用complete时，调用第三个方法来打印“这是结束”。</p><p id="09e7" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果一切正常，并且您的服务器正在运行http://localhost:4200 ，您应该会在浏览器控制台中看到下面的控制台日志输出。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi om"><img src="../Images/fcd2ab35fd011844cd289c22b119ff97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTR05GPgV3VzsQ-1UfZvlw.png"/></div></div></figure><h2 id="02f4" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">科目</h2><p id="7689" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated">关于observable的一个重要的事情是，每次你创建它的一个实例。这意味着您不能共享或重用observer。每个新的可观察对象将包含它自己的观察者，这些观察者不能相互作用。</p><p id="6422" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以多次订阅同一个可观察对象，但每次订阅都是一个单独的实例，它们不会互相了解。</p><p id="1b28" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，在上面的代码中，如果你想跳出代码块16–21，你不能执行observer.next()。但是如果你想这样做，也就是说，想在任何时候触发next。</p><p id="b0a0" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为此，我们有<strong class="jw iy">主题，</strong>他们就像观察员，除了你可以在我们想下一个开火的时候开火。他们都是可观察的和观察者，所以你可以订阅并对他们开火。</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="a36a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的代码中，你可以看到我们在第17行做了一个订阅，然后在它之外，我们下一个要发射。Subject可以很方便地在我们需要的时候向所有观察者广播更新的值。</p><h2 id="82a2" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">行为主体</h2><p id="68c6" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated">行为主体就像带有额外特性的主体，在被实例化时需要一个初始值。在第一次订阅时，您可以获得该值，而在订阅后，您必须至少启动一次next才能获得订阅值</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="cd2a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以现在在第18行，订阅将得到一个初始值100，甚至没有发出第一个下一个值。</p><h2 id="0bf8" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">重播主题</h2><p id="1129" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated">这看起来很好，但是在行为主体和主体中，你只能得到一个最新的值，但是如果你需要主体从一开始传递的所有值呢？不用担心，我们有ReplaySubject，replaysubject会保存所有的值，并在每个订阅中给出，即使replaysubject已完成。</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="908c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在代码中，当我们通过在第17、18行触发next来发出值时，我们将在第16行打印这些值，但是对于第19行的主题或行为主题，我们将仅获得4个值，因为它们仅给出最新的值，但是在replaysubject中，我们将获得保存在replay subject中的所有以前的值。</p><h1 id="90b9" class="nk lb ix bd lc nl nm nn lf no np nq li nr ns nt ll nu nv nw lo nx ny nz lr oa bi translated">经营者</h1><p id="9e62" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated">到目前为止，我们采用的用例非常简单，但在实时情况下，我们可能需要改变或操纵从可观测值中获得的值。这里有一个问题，如果我们想从可观察的事物中获得价值，我们必须订阅它，一旦订阅，你的可观察的事物就失去了。然后，我们需要再次将该值包装在可观察值中并返回。哦，废话，对于同样的问题，它太复杂和容易出错了，我们有操作者操纵可观察的输出，并把它包装在新的可观察的自身中。</p><blockquote class="ku kv kw"><p id="e925" class="ju jv kt jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated">操作者就像瑞士军刀</p></blockquote><h2 id="7fc7" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">拿</h2><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="cedd" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的代码中，我们使用了take操作符，这是最简单的操作符之一。在这里，我们的可观察对象将在每1秒后发出下一个数字(由于创建可观察对象的间隔方式)，但take将只取前5个，然后停止，否则你的浏览器迟早会崩溃。</p><h2 id="d095" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">地图</h2><p id="8376" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated">现在，是我最喜欢的运营商，地图的时候了。如果你曾经使用过Array.prototype.map，它几乎就是这样。只不过它映射了每个发出的可观察值，而不是数组元素，并将处理过的值包装在新的可观察值中。</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="be1e" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">过滤器</h2><p id="8a80" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated">Filter再次类似于Array.prototype.filter，只是它只发出那些通过filter操作符中传递的filter函数的值。</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="16b2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的代码中，我们将只在订阅中获得偶数的值，这就是filter operator所做的。</p><h2 id="5813" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">合并地图</h2><p id="431a" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated">到目前为止，我们只讨论了一个可观测的数据流，但是如果我们想要合并两个数据流呢？有很多操作符可以做到这一点，但是最简单的是merge map。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi on"><img src="../Images/92f0d998e739acc4d6d8c148804a8a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHcLBRUluyC8omEd7YivRQ.png"/></div></div></figure><p id="2a36" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在大理石图中检查这一点，看看两个数据流是如何合并成一个的，这就是合并图所做的。</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="7026" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个例子中，我们创建了两个observables:一个立即发出字母，另一个每秒发出新的数字。因此，它接受每个发出的数值，并与数值的最新值合并。</p><h2 id="0df8" class="la lb ix bd lc ld le dn lf lg lh dp li kf lj lk ll kj lm ln lo kn lp lq lr ls bi translated">开关图</h2><p id="9a29" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated">可能有这样一种情况，你想要两个值，但是你不想为每一个单独的值激发可观察的。用例:当你在数据库中搜索一个字符串，但同时你改变了这个字符串。在这种情况下，您必须取消旧的请求并启动新的请求。除了取消之前的请求之外，用法与mergemap完全相同。</p><h1 id="4f3f" class="nk lb ix bd lc nl nm nn lf no np nq li nr ns nt ll nu nv nw lo nx ny nz lr oa bi translated">结论</h1><p id="f016" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ij bi translated">这是所有的乡亲。还有很多运营商你可以上他们的官方<a class="ae ks" href="http://reactivex.io/rxjs/" rel="noopener ugc nofollow" target="_blank">网站</a>看看。这篇文章背后的主要思想是通过向开发人员介绍这个伟大的库来启发他们接受功能反应式编码方式。它真的可以让你的应用对实时数据更加敏感，并且高度可扩展。</p></div></div>    
</body>
</html>