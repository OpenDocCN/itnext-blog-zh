<html>
<head>
<title>Unit-Testing Sequelize Models Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试变得简单</h1>
<blockquote>原文：<a href="https://itnext.io/unit-testing-sequelize-models-made-easy-108f079f1e38?source=collection_archive---------3-----------------------#2018-06-23">https://itnext.io/unit-testing-sequelize-models-made-easy-108f079f1e38?source=collection_archive---------3-----------------------#2018-06-23</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><figure class="iq ir gq gs is it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj ip"><img src="../Images/4d56c60d547dad9661dac3677403d710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OzdQYLybKG6PPUBBYziOjg.jpeg"/></div></div><figcaption class="ja jb gk gi gj jc jd bd b be z dk translated">图片改编自Jaro Larnos 的<a class="ae je" href="https://www.flickr.com/photos/jlarnos/40950601550" rel="noopener ugc nofollow" target="_blank">微型城市和铁路，并在</a><a class="ae je" href="https://creativecommons.org/licenses/by/2.0/" rel="noopener ugc nofollow" target="_blank">许可</a>条款下使用。</figcaption></figure><div class=""/><p id="5b13" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">对于使用关系数据库的<code class="fe lc ld le lf b">NodeJS</code>开发人员来说，<code class="fe lc ld le lf b"><a class="ae je" href="http://docs.sequelizejs.com" rel="noopener ugc nofollow" target="_blank">Sequelize</a></code>是首选的对象关系映射工具。然而，对<code class="fe lc ld le lf b">Sequelize</code>模型进行有效的单元测试，不需要调用底层数据库的连接，会带来一些挑战。</p><p id="19cc" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">为了帮助解决这个问题，我写了一个名为<code class="fe lc ld le lf b"><a class="ae je" href="https://www.npmjs.com/package/sequelize-test-helpers" rel="noopener ugc nofollow" target="_blank">sequelize-test-helpers</a></code>的小工具套件。</p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="c919" class="lo lp jh lf b gz lq lr l ls lt">npm i -D sequelize-test-helpers</span></pre></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><figure class="lg lh li lj gu it gi gj paragraph-image"><div class="gi gj mb"><img src="../Images/f379f81c1709f6192a1760be805c8c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*ZPhwoy-rdr_HhPGpyIY5mA.gif"/></div></figure><h1 id="500f" class="mc lp jh bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">定义和导入模型</h1><p id="4aa2" class="pw-post-body-paragraph ke kf jh kg b kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx nd kz la lb ik bi translated">定义和导入序列模型遵循一个非常可预测的模式。</p><p id="296b" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">你写一个<code class="fe lc ld le lf b">Model</code>定义文件比如:</p><p id="b44b" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe lc ld le lf b">src/models/Simple.js</code></p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="9fc1" class="lo lp jh lf b gz lq lr l ls lt">const model = (sequelize, DataTypes) =&gt; {<br/>  const Simple = sequelize.define('Simple', {<br/>    name: DataTypes.STRING,<br/>    email: DataTypes.STRING<br/>  })</span><span id="e24b" class="lo lp jh lf b gz ne lr l ls lt">  return Simple<br/>}</span><span id="58e4" class="lo lp jh lf b gz ne lr l ls lt">module.exports = model</span></pre><p id="2891" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">并添加一个索引文件<code class="fe lc ld le lf b">src/models/index.js</code></p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="257f" class="lo lp jh lf b gz lq lr l ls lt">const fs = require('fs')<br/>const path = require('path')<br/>const Sequelize = require('sequelize')</span><span id="8139" class="lo lp jh lf b gz ne lr l ls lt">const {<br/>  dbName,<br/>  dbUser,<br/>  dbPass,<br/>  options<br/>} = require('../utils/dbConfig')</span><span id="0ffd" class="lo lp jh lf b gz ne lr l ls lt">const basename = path.basename(module.filename)<br/>const sequelize = new Sequelize(dbName, dbUser, dbPass, options)<br/>const db = { Sequelize, sequelize }</span><span id="a47a" class="lo lp jh lf b gz ne lr l ls lt">const onlyModels = file =&gt;<br/>  file.indexOf('.') !== 0 &amp;&amp;<br/>  file !== basename &amp;&amp;<br/>  file.slice(-3) === '.js'</span><span id="56fc" class="lo lp jh lf b gz ne lr l ls lt">const importModel = file =&gt; {<br/>  const modelPath = path.join(__dirname, file)<br/>  const model = sequelize.import(modelPath)<br/>  db[model.name] = model<br/>}</span><span id="0acd" class="lo lp jh lf b gz ne lr l ls lt">const associate = modelName =&gt; {<br/>  if (typeof db[modelName].associate === 'function')<br/>    db[modelName].associate(db)<br/>}</span><span id="6394" class="lo lp jh lf b gz ne lr l ls lt">fs.readdirSync(__dirname)<br/>  .filter(onlyModels)<br/>  .forEach(importModel)</span><span id="4251" class="lo lp jh lf b gz ne lr l ls lt">Object.keys(db).forEach(associate)</span><span id="082a" class="lo lp jh lf b gz ne lr l ls lt">module.exports = db</span></pre><p id="3669" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这个<code class="fe lc ld le lf b">index.js</code>文件:</p><ol class=""><li id="1a81" class="nf ng jh kg b kh ki kl km kp nh kt ni kx nj lb nk nl nm nn bi translated">创建到数据库的连接，</li><li id="9010" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb nk nl nm nn bi translated">遍历本地文件夹并在每个模型文件上调用<code class="fe lc ld le lf b"><a class="ae je" href="http://docs.sequelizejs.com/manual/tutorial/models-definition.html#import" rel="noopener ugc nofollow" target="_blank">sequelize.import</a></code>,</li><li id="746e" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb nk nl nm nn bi translated">通过其<code class="fe lc ld le lf b">name</code>存储相关模型，</li><li id="0717" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb nk nl nm nn bi translated">然后，对于每个带有<code class="fe lc ld le lf b">associate</code>函数的模型，调用该函数将模型连接在一起。</li></ol><p id="4d42" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这几乎是所有使用Sequelize的项目从单个模型文件中预加载模型的方式。</p><h1 id="a0d4" class="mc lp jh bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">单元测试模型</h1><p id="8a8c" class="pw-post-body-paragraph ke kf jh kg b kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx nd kz la lb ik bi translated">只要您的代码第一次调用<code class="fe lc ld le lf b">require('src/models')</code>该行</p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="f50d" class="lo lp jh lf b gz lq lr l ls lt">const sequelize = new Sequelize(dbName, dbUser, dbPass, options)</span></pre><p id="e1e6" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">会被调用，并试图连接到您的数据库。这不仅很慢，而且，如果您实际上没有运行数据库，很可能会导致连接错误。</p><p id="0f51" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">因此，在我们的测试中，我们希望完全避免<code class="fe lc ld le lf b">require('src/models')</code>。我们可以将测试集中在我们想要测试的特定模型上:</p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="fac1" class="lo lp jh lf b gz lq lr l ls lt">const SimpleModel = require('src/models/Simple')</span></pre><p id="976a" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">但是为了使用它，我们需要向它传递一个实例化的<code class="fe lc ld le lf b">sequelize</code>对象和一个<code class="fe lc ld le lf b">Sequelize</code> <code class="fe lc ld le lf b">DataTypes</code>对象。</p><p id="5c51" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe lc ld le lf b">sequelize-test-helpers</code>库提供了一个<em class="nt">模拟</em>序列实例和一整套序列数据类型。</p><h2 id="478b" class="lo lp jh bd md nu nv dn mh nw nx dp ml kp ny nz mp kt oa ob mt kx oc od mx oe bi translated">单元测试模型的名称和属性</h2><p id="f8ff" class="pw-post-body-paragraph ke kf jh kg b kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx nd kz la lb ik bi translated"><code class="fe lc ld le lf b">test/unit/models/Simple.spec.js</code></p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="7250" class="lo lp jh lf b gz lq lr l ls lt">const {<br/>  sequelize,<br/>  dataTypes,<br/>  checkModelName,<br/>  checkPropertyExists<br/>} = require('sequelize-test-helpers')</span><span id="6246" class="lo lp jh lf b gz ne lr l ls lt">const SimpleModel = require('../../../src/models/Simple')</span><span id="1ce4" class="lo lp jh lf b gz ne lr l ls lt">describe('src/models/Simple', () =&gt; {<br/>  const Model = SimpleModel(sequelize, dataTypes)<br/>  const instance = new Model()</span><span id="e6d4" class="lo lp jh lf b gz ne lr l ls lt">  checkModelName(Model)('Simple')</span><span id="69f0" class="lo lp jh lf b gz ne lr l ls lt">  context('properties', () =&gt; {<br/>    ;['name', 'email'].forEach(checkPropertyExists(instance))<br/>  })<br/>})</span></pre><p id="9c6d" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这测试了模型的<code class="fe lc ld le lf b">name</code>是我们期望的名字，并且模型具有我们期望的属性。</p><h2 id="7a57" class="lo lp jh bd md nu nv dn mh nw nx dp ml kp ny nz mp kt oa ob mt kx oc od mx oe bi translated">单元测试关联</h2><p id="2b31" class="pw-post-body-paragraph ke kf jh kg b kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx nd kz la lb ik bi translated"><code class="fe lc ld le lf b">sequelize-test-helpers</code>库还提供了允许我们测试关联的工具。</p><p id="7085" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">让我们假设上面的<code class="fe lc ld le lf b">Simple</code>模型与一个<code class="fe lc ld le lf b">OtherModel</code>相关联。</p><p id="65bd" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">mock <code class="fe lc ld le lf b">sequelize</code>对象使用<code class="fe lc ld le lf b"><a class="ae je" href="http://sinonjs.org" rel="noopener ugc nofollow" target="_blank">sinon</a></code>将<code class="fe lc ld le lf b"><a class="ae je" href="http://sinonjs.org/releases/v6.0.0/spies/" rel="noopener ugc nofollow" target="_blank">spies</a></code>附加到Sequelize的每个关联类型，这意味着您可以通过在<code class="fe lc ld le lf b">before</code>块中调用<code class="fe lc ld le lf b">Model.associate</code>来测试它们，然后使用<code class="fe lc ld le lf b">sinon</code>的<code class="fe lc ld le lf b">calledWith</code>函数来检查它是否被正确调用。</p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="e2d3" class="lo lp jh lf b gz lq lr l ls lt">context('check associations', () =&gt; {<br/>  const OtherModel = 'some other model' // it doesn't matter what</span><span id="5543" class="lo lp jh lf b gz ne lr l ls lt">  before(() =&gt; {<br/>    Model.associate({ OtherModel })<br/>  }</span><span id="16da" class="lo lp jh lf b gz ne lr l ls lt">  it('defined a belongsTo association with OtherModel', () =&gt; {<br/>    expect(Simple.belongsTo).to.have.been.calledWith(OtherModel)<br/>  })<br/>}</span></pre><p id="f84a" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">您可以对所有的<code class="fe lc ld le lf b">belongsTo</code>、<code class="fe lc ld le lf b">hasOne</code>、<code class="fe lc ld le lf b">hasMany</code>和<code class="fe lc ld le lf b">belongsToMany</code>执行此操作。</p><h2 id="f350" class="lo lp jh bd md nu nv dn mh nw nx dp ml kp ny nz mp kt oa ob mt kx oc od mx oe bi translated">单元测试挂钩</h2><p id="902f" class="pw-post-body-paragraph ke kf jh kg b kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx nd kz la lb ik bi translated">通常你会在一个模型中定义<a class="ae je" href="http://docs.sequelizejs.com/manual/tutorial/hooks.html" rel="noopener ugc nofollow" target="_blank">钩子</a>，比如<code class="fe lc ld le lf b">beforeValidate</code>或者<code class="fe lc ld le lf b">afterCreate</code>，并且<code class="fe lc ld le lf b">Sequelize</code>提供了三种不同的方法来定义这些钩子。这里有一个简单而荒谬的模型，它定义了三个钩子，每个钩子都有不同的定义。</p><p id="720b" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe lc ld le lf b">src/models/HasHooks.js</code></p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="1863" class="lo lp jh lf b gz lq lr l ls lt">const model = (sequelize, DataTypes) =&gt; {<br/>  const HasHooks = sequelize.define(<br/>    'HasHooks',<br/>    {<br/>      name: DataTypes.STRING<br/>    },<br/>    {<br/>      hooks: {<br/>        beforeValidate: hooker =&gt; {<br/>          hooker.name = 'Alice'<br/>        }<br/>      }<br/>    }<br/>  )</span><span id="8086" class="lo lp jh lf b gz ne lr l ls lt">  HasHooks.hook('afterValidate', hooker =&gt; {<br/>    hooker.name = 'Bob'<br/>  })</span><span id="17d4" class="lo lp jh lf b gz ne lr l ls lt">  HasHooks.addHook('afterCreate', 'removeMe', hooker =&gt; {<br/>    hooker.name = 'Carla'<br/>  })</span><span id="a258" class="lo lp jh lf b gz ne lr l ls lt">  return HasHooks<br/>}</span><span id="cb85" class="lo lp jh lf b gz ne lr l ls lt">module.exports = model</span></pre><p id="f69c" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe lc ld le lf b">sequelize-test-helpers</code>库提供了一个助手，允许我们测试钩子，不管它们是如何定义的(或者它们有多愚蠢)。)</p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="4b00" class="lo lp jh lf b gz lq lr l ls lt">const {<br/>  sequelize,<br/>  dataTypes,<br/>  checkHookDefined<br/>} = require('sequelize-test-helpers')</span><span id="41ec" class="lo lp jh lf b gz ne lr l ls lt">const HasHooksModel = require('../../src/models/HasHooks')</span><span id="2ab6" class="lo lp jh lf b gz ne lr l ls lt">describe('src/models/HasHooks', () =&gt; {<br/>  const Model = HasHooksModel(sequelize, dataTypes)<br/>  const instance = new Model()</span><span id="d2d7" class="lo lp jh lf b gz ne lr l ls lt">  context('hooks', () =&gt; {<br/>    ;[<br/>      'beforeValidate',<br/>      'afterValidate',<br/>      'afterCreate'<br/>    ].forEach(checkHookDefined(instance))<br/>  })<br/>})</span></pre><h2 id="2666" class="lo lp jh bd md nu nv dn mh nw nx dp ml kp ny nz mp kt oa ob mt kx oc od mx oe bi translated">单元测试索引</h2><p id="e2cc" class="pw-post-body-paragraph ke kf jh kg b kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx nd kz la lb ik bi translated">您可以使用各种<code class="fe lc ld le lf b">check*Index</code>功能来检查一系列不同的<code class="fe lc ld le lf b">index</code>类型。</p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="a99c" class="lo lp jh lf b gz lq lr l ls lt">context('indexes', () =&gt; {<br/>  ;['email', 'token'].forEach(checkUniqueIndex(instance))<br/>})</span></pre><p id="f178" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">您可以检查以下<code class="fe lc ld le lf b">index</code>类型:</p><ul class=""><li id="f697" class="nf ng jh kg b kh ki kl km kp nh kt ni kx nj lb of nl nm nn bi translated"><code class="fe lc ld le lf b">checkUniqueIndex</code>:检查是否定义了特定的<code class="fe lc ld le lf b">unique index</code>，</li><li id="06ff" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb of nl nm nn bi translated"><code class="fe lc ld le lf b">checkNonUniqueIndex</code>:检查是否定义了特定的<code class="fe lc ld le lf b">non-unique index</code>，以及</li><li id="b0bb" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb of nl nm nn bi translated"><code class="fe lc ld le lf b">checkUniqueCompoundIndex</code>:检查是否定义了特定的<code class="fe lc ld le lf b">unique compound index</code>。</li></ul><p id="7d78" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这些<code class="fe lc ld le lf b">check*</code>函数一起允许你独立地对大多数种类的序列模型进行全面的单元测试。</p></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><h1 id="9cf5" class="mc lp jh bd md me og mg mh mi oh mk ml mm oi mo mp mq oj ms mt mu ok mw mx my bi translated">依赖于模型的单元测试代码</h1><p id="1663" class="pw-post-body-paragraph ke kf jh kg b kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx nd kz la lb ik bi translated">除了对模型本身进行单元测试之外，当然也有必要对使用这些模型的功能进行单元测试。同样，我们并不想真的接近我们的数据库，我们只是想测试单独使用模型的代码。为此，我们需要一组<code class="fe lc ld le lf b">mockModels</code>。</p><p id="82ff" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe lc ld le lf b">sequelize-test-helpers</code>库为此提供了一个名为<code class="fe lc ld le lf b">makeMockModels</code>的工具。</p><h2 id="ae76" class="lo lp jh bd md nu nv dn mh nw nx dp ml kp ny nz mp kt oa ob mt kx oc od mx oe bi translated">简单的保存功能</h2><p id="63f8" class="pw-post-body-paragraph ke kf jh kg b kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx nd kz la lb ik bi translated">让我们测试以下代码:</p><p id="69bc" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe lc ld le lf b">src/utils/save.js</code></p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="00a7" class="lo lp jh lf b gz lq lr l ls lt">const { User } = require('../models')</span><span id="88fb" class="lo lp jh lf b gz ne lr l ls lt">const save = async ({ id, ...data }) =&gt; {<br/>  const user = await User.findOne({ where: { id } })<br/>  if (user) return await user.update(data)<br/>  return null<br/>}</span><span id="18c1" class="lo lp jh lf b gz ne lr l ls lt">module.exports = save</span></pre><p id="d56b" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe lc ld le lf b">save</code>函数接受一些<code class="fe lc ld le lf b">data</code>，使用提供的<code class="fe lc ld le lf b">id</code>查找一个<code class="fe lc ld le lf b">User</code>，如果找到了，用提供的<code class="fe lc ld le lf b">data</code>更新找到的<code class="fe lc ld le lf b">user</code>，并返回更新的<code class="fe lc ld le lf b">user</code>模型。如果没有找到，函数返回<code class="fe lc ld le lf b">null</code>。</p><h2 id="a6cf" class="lo lp jh bd md nu nv dn mh nw nx dp ml kp ny nz mp kt oa ob mt kx oc od mx oe bi translated">对保存功能进行单元测试</h2><p id="330f" class="pw-post-body-paragraph ke kf jh kg b kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx nd kz la lb ik bi translated">为了单独测试这一点，我们可以使用几个实用程序。</p><ul class=""><li id="1033" class="nf ng jh kg b kh ki kl km kp nh kt ni kx nj lb of nl nm nn bi translated"><code class="fe lc ld le lf b"><a class="ae je" href="http://sinonjs.org" rel="noopener ugc nofollow" target="_blank">sinon</a></code>:剔除功能，</li><li id="878e" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb of nl nm nn bi translated"><code class="fe lc ld le lf b"><a class="ae je" href="https://github.com/thlorenz/proxyquire" rel="noopener ugc nofollow" target="_blank">proxyquire</a></code>:注入我们自己的模拟模型来代替真实模型的工具，以及</li><li id="5b4c" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb of nl nm nn bi translated"><code class="fe lc ld le lf b"><a class="ae je" href="https://www.npmjs.com/package/sequelize-test-helpers" rel="noopener ugc nofollow" target="_blank">sequelize-test-helpers</a></code>:提供<code class="fe lc ld le lf b">makeMockModels</code>实用程序。</li></ul><p id="98e2" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe lc ld le lf b">test/unit/utils/save.spec.js</code></p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="ae33" class="lo lp jh lf b gz lq lr l ls lt">const { expect } = require('chai')<br/>const sinon = require('sinon')<br/>const proxyquire = require('proxyquire')</span><span id="69e9" class="lo lp jh lf b gz ne lr l ls lt">const { makeMockModels } = require('sequelize-test-helpers')</span><span id="3535" class="lo lp jh lf b gz ne lr l ls lt">const mockModels = makeMockModels({ User: { findOne: sinon.stub() } })</span><span id="a13c" class="lo lp jh lf b gz ne lr l ls lt">const save = proxyquire('../../../src/utils/save', {<br/>  '../models': mockModels<br/>})</span><span id="3670" class="lo lp jh lf b gz ne lr l ls lt">const fakeUser = { update: sinon.stub() }</span><span id="3c17" class="lo lp jh lf b gz ne lr l ls lt">describe('src/utils/save', () =&gt; {<br/>  const data = {<br/>    firstname: 'Testy',<br/>    lastname: 'McTestface',<br/>    email: 'testy.mctestface@test.tes',<br/>    token: 'some-token'<br/>  }</span><span id="96aa" class="lo lp jh lf b gz ne lr l ls lt">  const resetStubs = () =&gt; {<br/>    mockModels.User.findOne.resetHistory()<br/>    fakeUser.update.resetHistory()<br/>  }</span><span id="1627" class="lo lp jh lf b gz ne lr l ls lt">  let result</span><span id="43e8" class="lo lp jh lf b gz ne lr l ls lt">  context('user does not exist', () =&gt; {<br/>    before(async () =&gt; {<br/>      mockModels.User.findOne.resolves(undefined)<br/>      result = await save(data)<br/>    })</span><span id="83e8" class="lo lp jh lf b gz ne lr l ls lt">    after(resetStubs)</span><span id="687d" class="lo lp jh lf b gz ne lr l ls lt">    it('called User.findOne', () =&gt; {<br/>      expect(mockModels.User.findOne).to.have.been.called<br/>    })</span><span id="f601" class="lo lp jh lf b gz ne lr l ls lt">    it("didn't call user.update", () =&gt; {<br/>      expect(fakeUser.update).not.to.have.been.called<br/>    })</span><span id="b5b2" class="lo lp jh lf b gz ne lr l ls lt">    it('returned null', () =&gt; {<br/>      expect(result).to.be.null<br/>    })<br/>  })</span><span id="d448" class="lo lp jh lf b gz ne lr l ls lt">  context('user exists', () =&gt; {<br/>    before(async () =&gt; {<br/>      fakeUser.update.resolves(fakeUser)<br/>      mockModels.User.findOne.resolves(fakeUser)<br/>      result = await save(data)<br/>    })</span><span id="0b09" class="lo lp jh lf b gz ne lr l ls lt">    after(resetStubs)</span><span id="272a" class="lo lp jh lf b gz ne lr l ls lt">    it('called User.findOne', () =&gt; {<br/>      expect(mockModels.User.findOne).to.have.been.called<br/>    })</span><span id="2001" class="lo lp jh lf b gz ne lr l ls lt">    it('called user.update', () =&gt; {<br/>      expect(fakeUser.update).to.have.been.calledWith(<br/>        sinon.match(data))<br/>    })</span><span id="f3ad" class="lo lp jh lf b gz ne lr l ls lt">    it('returned the user', () =&gt; {<br/>      expect(result).to.deep.equal(fakeUser)<br/>    })<br/>  })<br/>})</span></pre><p id="131a" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe lc ld le lf b">makeMockModels</code>函数为我们做了一些事情。</p><ol class=""><li id="f5ed" class="nf ng jh kg b kh ki kl km kp nh kt ni kx nj lb nk nl nm nn bi translated">首先，它在项目的根目录下检查一个<code class="fe lc ld le lf b">.sequelizerc</code>文件，如果找到了，它使用在那里定义的<code class="fe lc ld le lf b">models-path</code>来查找模型所在的文件夹。</li><li id="30c2" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb nk nl nm nn bi translated">如果它找不到一个<code class="fe lc ld le lf b">.sequelizerc</code>文件，那么它就在<code class="fe lc ld le lf b">src/models</code>中查找。</li><li id="56b0" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb nk nl nm nn bi translated">如果在那里找不到任何模型，它将抛出一个错误。在这种情况下，您还可以选择将models文件夹的路径传递给<code class="fe lc ld le lf b">makeMockModels</code>。</li><li id="12c0" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb nk nl nm nn bi translated">一旦找到模型，它就会模拟通常在<code class="fe lc ld le lf b">src/models/index.js</code>中的sequelize <code class="fe lc ld le lf b">import</code>代码，将所有的模型名加载到一个对象中。</li><li id="1aa1" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb nk nl nm nn bi translated">最后，它将<code class="fe lc ld le lf b">@noCallThru: true</code>附加到末尾，告诉<code class="fe lc ld le lf b">proxyquire</code>根本不要导入真实的模型文件。这很重要，因为否则真实的模型文件仍然会尝试连接到数据库。</li><li id="0663" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb nk nl nm nn bi translated">一旦构建了这个对象，<code class="fe lc ld le lf b">makeMockModels</code>就会用您提供的任何模型存根覆盖任何默认模型。</li></ol><p id="6b71" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">所以在上面的例子中，<code class="fe lc ld le lf b">mockModels</code>最终包含了</p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="c502" class="lo lp jh lf b gz lq lr l ls lt">{<br/>  User: { update: sinon.stub() },<br/>  Company: 'Company',<br/>  '@noCallThru': true<br/>}</span></pre><p id="9e09" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">然后我们使用proxyquire在真实模型的位置插入<code class="fe lc ld le lf b">mockModels</code>。</p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="9cd1" class="lo lp jh lf b gz lq lr l ls lt">const save = proxyquire('../../../src/utils/save', {<br/>  '../models': mockModels<br/>})</span></pre><p id="4989" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">然后就用西农的存根照常测试。</p><p id="6bc8" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">通过使用<code class="fe lc ld le lf b">makeMockModels</code>,你可以对所有依赖于你的模型的代码进行单元测试，而不需要接近你的数据库。这使您的测试保持隔离和快速。</p></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><h1 id="da04" class="mc lp jh bd md me og mg mh mi oh mk ml mm oi mo mp mq oj ms mt mu ok mw mx my bi translated">结论</h1><p id="b460" class="pw-post-body-paragraph ke kf jh kg b kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx nd kz la lb ik bi translated">使用诸如<code class="fe lc ld le lf b">sequelize-test-helpers</code>、<code class="fe lc ld le lf b">sinon</code>和<code class="fe lc ld le lf b">proxyquire</code>这样的实用程序，您可以全面地测试序列化模型和使用这些模型的代码，而不必连接到实际的数据库。</p><p id="01e7" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">目前<code class="fe lc ld le lf b">sequelize-test-helpers</code>被设计为与<code class="fe lc ld le lf b">Chai</code>和<code class="fe lc ld le lf b">Sinon</code>一起工作，并假设您正在使用<code class="fe lc ld le lf b">Node version 10</code>或更好的版本。</p><p id="f89c" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">当然，单元测试不能代替集成测试。</p><p id="f3d3" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">当编写依赖于各种数据库模型之间的交互的代码时，重要的是你也要编写打开数据库连接的测试，并检查你的代码<em class="nt">确实做了你期望的</em>。</p><p id="4380" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">也就是说，我喜欢先写我的单元测试，因为我用这种方式抓住了大多数最愚蠢的错误，并且它迫使我用奖励干燥和简单的方式写我的代码。</p><p id="7a72" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">正确完成的单元测试的优点是运行速度非常快，通常在几毫秒内，并且您不需要任何外部基础设施。需要外部依赖的测试，如数据库、消息队列等，必然需要更长的运行时间。</p></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><h1 id="3e47" class="mc lp jh bd md me og mg mh mi oh mk ml mm oi mo mp mq oj ms mt mu ok mw mx my bi translated">链接</h1><ul class=""><li id="06e9" class="nf ng jh kg b kh mz kl na kp ol kt om kx on lb of nl nm nn bi translated"><code class="fe lc ld le lf b"><a class="ae je" href="http://docs.sequelizejs.com" rel="noopener ugc nofollow" target="_blank">Sequelize</a></code>:最广泛用于<code class="fe lc ld le lf b">NodeJS</code>项目的ORM。</li><li id="60e9" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb of nl nm nn bi translated"><code class="fe lc ld le lf b"><a class="ae je" href="https://www.npmjs.com/package/sequelize-test-helpers" rel="noopener ugc nofollow" target="_blank">sequelize-test-helpers</a></code>:一组帮助单元测试<code class="fe lc ld le lf b">Sequelize</code>模型的工具。</li><li id="269a" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb of nl nm nn bi translated"><code class="fe lc ld le lf b"><a class="ae je" href="http://sinonjs.org" rel="noopener ugc nofollow" target="_blank">sinon</a></code>:广泛使用的<code class="fe lc ld le lf b">NodeJS</code>存根库。</li><li id="c9eb" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb of nl nm nn bi translated"><code class="fe lc ld le lf b"><a class="ae je" href="https://github.com/thlorenz/proxyquire" rel="noopener ugc nofollow" target="_blank">proxyquire</a></code>:一个广泛使用的<code class="fe lc ld le lf b">NodeJS</code>模仿库，允许你将你自己的模仿注入到你正在测试的代码中。</li><li id="5615" class="nf ng jh kg b kh no kl np kp nq kt nr kx ns lb of nl nm nn bi translated"><code class="fe lc ld le lf b"><a class="ae je" href="http://www.chaijs.com" rel="noopener ugc nofollow" target="_blank">chai</a></code>:一种用于编写测试的非常有表现力的语法。适用于大多数<code class="fe lc ld le lf b">NodeJS</code>测试框架。</li></ul><p id="9ee9" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi">—</p><p id="f5f2" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">像这样但不是订户？你可以通过<a class="ae je" href="https://davesag.medium.com/membership" rel="noopener">davesag.medium.com</a>加入来支持作者。</p></div></div>    
</body>
</html>