<html>
<head>
<title>TypeScript with Promises, Async/Await, and Generator Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有承诺、异步/等待和生成器函数的类型脚本</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-with-promises-and-async-await-63623b8e5e2a?source=collection_archive---------3-----------------------#2020-07-20">https://itnext.io/typescript-with-promises-and-async-await-63623b8e5e2a?source=collection_archive---------3-----------------------#2020-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b97d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">寻找一个伟大的(仅远程)反应开发？或者只是想聊聊天？访问LinkedIn上的<a class="ae ko" href="https://www.linkedin.com/in/bengrunfeld/" rel="noopener ugc nofollow" target="_blank">我的个人资料</a>并问好！😃</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/51780f5445cf7005f4f1bfc4ac151c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eN1f7qWSFg5AH0EmfyezIw.png"/></div></div></figure><p id="00dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出于某种奇怪的原因，TypeScript <a class="ae ko" href="https://www.typescriptlang.org/docs/handbook" rel="noopener ugc nofollow" target="_blank">文档</a>没有解释如何实现承诺、异步/等待或生成器函数的类型检查。</p><h1 id="e50b" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">承诺</h1><p id="02ca" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">解决方案非常简单。基本上，承诺的返回类型是紧接在关键字<code class="fe me mf mg mh b">Promise</code>之后定义的。例如</p><pre class="kq kr ks kt gt mi mh mj mk aw ml bi"><span id="3202" class="mm lc it mh b gy mn mo l mp mq">const p = new Promise&lt;boolean | string&gt;((resolve, reject) =&gt; {<br/>    const random = Math.random() * 10;</span><span id="2eae" class="mm lc it mh b gy mr mo l mp mq">if (random &gt; 5) {<br/>      resolve(true);<br/>      return;<br/>    }</span><span id="414d" class="mm lc it mh b gy mr mo l mp mq">reject("It was lower than 5");<br/>  });</span><span id="2f62" class="mm lc it mh b gy mr mo l mp mq">p.catch(err =&gt; console.log("ERROR - ", err));</span></pre><p id="762a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意<code class="fe me mf mg mh b">reject</code>是如何返回一个字符串的？嗯，我们只是在承诺的类型声明中添加了一个联合类型，这样,<code class="fe me mf mg mh b">resolve</code>和<code class="fe me mf mg mh b">reject</code>的返回类型都是可以接受的。</p><h1 id="aa11" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步/等待</h1><p id="c73e" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">用<code class="fe me mf mg mh b">async/await</code>实现TypeScript非常类似于一个承诺。</p><pre class="kq kr ks kt gt mi mh mj mk aw ml bi"><span id="9107" class="mm lc it mh b gy mn mo l mp mq">const randomAboveFive = () =&gt;<br/>    new Promise&lt;boolean | string&gt;((resolve, reject) =&gt; {<br/>      const random = Math.floor(Math.random() * 15);</span><span id="31da" class="mm lc it mh b gy mr mo l mp mq">    if (random &gt; 5) {<br/>      resolve(true);<br/>      return;<br/>    }</span><span id="d639" class="mm lc it mh b gy mr mo l mp mq">    reject("It was lower than 5");<br/>});</span><span id="4102" class="mm lc it mh b gy mr mo l mp mq">const checkRandomNumber = async (): Promise&lt;boolean | string&gt; =&gt; {<br/>    let result;</span><span id="c537" class="mm lc it mh b gy mr mo l mp mq">    try {<br/>      result = await randomAboveFive();<br/>    } catch (err) {<br/>      console.log("ERROR -- ", err);<br/>      result = err;<br/>    }</span><span id="c3fe" class="mm lc it mh b gy mr mo l mp mq">    console.log("-----&gt;&gt;&gt;", result);</span><span id="4b05" class="mm lc it mh b gy mr mo l mp mq">    return result;<br/>};</span><span id="80ea" class="mm lc it mh b gy mr mo l mp mq">checkRandomNumber();</span></pre><p id="1101" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，我们声明了一个承诺，它可能以任何一种方式出现—如果生成的随机值大于<code class="fe me mf mg mh b">5</code>，我们解析<code class="fe me mf mg mh b">true</code>，如果不是，我们用一个解释错误的字符串<code class="fe me mf mg mh b">reject</code>。</p><p id="dc0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们用<strong class="js iu"> Async/Await </strong>设置一个等待<strong class="js iu">承诺</strong>的函数，并处理它的成功或失败。</p><p id="f3f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们用<code class="fe me mf mg mh b">Promise&lt;boolean | string&gt;</code>设置异步/等待操作的返回类型。</p><h1 id="15cc" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">发电机功能</h1><p id="d920" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">下面是我们如何用<code class="fe me mf mg mh b">function*</code>实现TypeScript，也称为生成器函数:</p><pre class="kq kr ks kt gt mi mh mj mk aw ml bi"><span id="3f50" class="mm lc it mh b gy mn mo l mp mq">function* genCounter(i: number): IterableIterator&lt;number&gt; {<br/>  while (true) {<br/>    yield i--;</span><span id="50aa" class="mm lc it mh b gy mr mo l mp mq">    if (i === 0) return;<br/>  }<br/>}</span><span id="5346" class="mm lc it mh b gy mr mo l mp mq">const count = genCounter(4);</span><span id="d4a3" class="mm lc it mh b gy mr mo l mp mq">let keepGoing = true;</span><span id="231b" class="mm lc it mh b gy mr mo l mp mq">while (keepGoing) {<br/>  const { value, done } = count.next();<br/>  console.log("=&gt;", value, done);</span><span id="21ab" class="mm lc it mh b gy mr mo l mp mq">  if (done) {<br/>    keepGoing = false;<br/>  }<br/>}</span></pre><p id="2239" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主要的要点是，要使<strong class="js iu">生成器函数</strong>与<strong class="js iu">类型脚本</strong>配合良好，您必须设置一个返回值<code class="fe me mf mg mh b">IterableIterator&lt;number&gt;</code>，其中<code class="fe me mf mg mh b">number</code>是它返回的任何基本类型脚本类型。</p><h2 id="41fa" class="mm lc it bd ld ms mt dn lh mu mv dp ll kb mw mx lp kf my mz lt kj na nb lx nc bi translated">上面的代码是怎么回事:</h2><p id="8f4b" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们声明一个生成器函数，它接受一个<code class="fe me mf mg mh b">number</code>，然后在每次调用<code class="fe me mf mg mh b">count.next()</code>时递减它。如果数字达到零，我们返回并停止循环，退出生成器函数。</p><p id="0fa7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们声明另一个循环，该循环一直调用<code class="fe me mf mg mh b">count.next()</code>并记录输出，直到<code class="fe me mf mg mh b">count.next().done</code>为<code class="fe me mf mg mh b">true</code>。</p><p id="05ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你知道了！</p></div></div>    
</body>
</html>