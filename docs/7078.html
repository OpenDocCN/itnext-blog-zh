<html>
<head>
<title>Rust vs Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust vs Scala</h1>
<blockquote>原文：<a href="https://itnext.io/rust-vs-scala-513ebf92bd4a?source=collection_archive---------0-----------------------#2022-06-05">https://itnext.io/rust-vs-scala-513ebf92bd4a?source=collection_archive---------0-----------------------#2022-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6f7d317fabbc1d3b5b0845d37be6c7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7hDOuo8jwIYbFjeW"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@jayrheike?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰伊·海克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="617a" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="fe40" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我使用<a class="ae kf" href="https://scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Scala </strong> </a>已经有几年了，构建了广泛的应用，从流处理到<strong class="lg iu">数据管道</strong>；与此同时，我一直听到很多关于<a class="ae kf" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">锈</strong> </a>的好消息，所以最近我决定花时间学习<strong class="lg iu">锈</strong>。</p><p id="e42d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">尽管这两种语言是为实现不同的目标而创造的，但它们有一些相似之处。在过去的几个月里，我一直在记笔记，试图将我的未来围绕在每种语言都更适合的用例上。这篇文章是这项研究的高潮。我的目标是从不同的角度对两种语言进行比较，这样任何人，无论其角色如何，都可以对每种语言的异同有一个完整的了解。</p><p id="31d5" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这两种语言都是伟大的语言，可以为并发应用程序实现巨大的性能，但是它们的设计非常不同。Scala是一种更古老、更成熟的编程语言，在并发编程和大数据处理等领域找到了自己的位置。另一方面，Rust是一种较新的语言，是为了克服对C++的批评而创建的，因为它是新的，它采用了其他语言的许多结构，同时解决了旧语言的许多问题。</p><p id="9995" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> Scala </strong>基于JVM，被认为是<a class="ae kf" href="https://en.wikipedia.org/wiki/General-purpose_programming_language" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">通用编程语言</strong> </a>。<a class="ae kf" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Rust </strong> </a>另一方面，是一种<a class="ae kf" href="https://en.wikipedia.org/wiki/System_programming_language" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">系统编程语言</strong> </a>，它是为了解决C++的内存安全问题和其他问题而创建的，同时保持C++以其惊人的<strong class="lg iu">性能</strong>。</p><p id="96ce" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在这篇文章中，我将试着给你一个两种语言的快速概述，它们的<strong class="lg iu">优点和缺点</strong>，并回顾一些真实的单词用例，我们将推荐一种语言而不是另一种。</p><h1 id="e6a3" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">简单来说Scala</h1><p id="7926" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Scala </strong> </a>是学者们创造的编程语言，它是运行在<strong class="lg iu"> </strong> <a class="ae kf" href="https://en.wikipedia.org/wiki/Java_virtual_machine" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> JVM </strong> </a>上的<strong class="lg iu"> Java </strong>的第一个替代品。它将自己定义为:</p><blockquote class="mh"><p id="766f" class="mi mj it bd mk ml mm mn mo mp mq mb dk translated">Scala是一种现代的多范例编程语言，旨在以简洁、优雅和类型安全的方式表达常见的编程模式。[1] </p></blockquote><p id="47f8" class="pw-post-body-paragraph le lf it lg b lh ms lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx mw lz ma mb im bi translated">Scala兼具功能性和面向对象性，提供了两者的优势。它有一种灵活的方式来定义你的程序，由你来决定如何描述它们:从纯粹的函数式编程到纯粹的面向对象编程。</p><p id="192b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">和Java一样，Scala也是面向对象的:</p><blockquote class="mh"><p id="6a2e" class="mi mj it bd mk ml mm mn mo mp mq mb dk translated"><em class="mr"> Scala是一种纯粹的面向对象语言，因为</em> <a class="ae kf" href="https://docs.scala-lang.org/tour/unified-types.html" rel="noopener ugc nofollow" target="_blank"> <em class="mr">每个值都是一个对象</em> </a> <em class="mr">。对象的类型和行为由</em> <a class="ae kf" href="https://docs.scala-lang.org/tour/classes.html" rel="noopener ugc nofollow" target="_blank"> <em class="mr">类</em> </a> <em class="mr">和</em> <a class="ae kf" href="https://docs.scala-lang.org/tour/traits.html" rel="noopener ugc nofollow" target="_blank"> <em class="mr">特征</em> </a> <em class="mr">描述。[1] </em></p></blockquote><p id="2387" class="pw-post-body-paragraph le lf it lg b lh ms lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx mw lz ma mb im bi translated">它还提供了对<a class="ae kf" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">功能编程</a>和一个强大的<a class="ae kf" href="https://en.wikipedia.org/wiki/Static_typing" rel="noopener ugc nofollow" target="_blank">静态</a> <a class="ae kf" href="https://en.wikipedia.org/wiki/Type_system" rel="noopener ugc nofollow" target="_blank">类型系统</a>的支持。与Java不同，Scala拥有<a class="ae kf" href="https://en.wikipedia.org/wiki/Scheme_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Scheme </a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Standard_ML" rel="noopener ugc nofollow" target="_blank"> Standard ML </a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Haskell_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Haskell </a>等<a class="ae kf" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>语言的诸多特性，包括<a class="ae kf" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">curry</a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Type_inference" rel="noopener ugc nofollow" target="_blank">类型推理</a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Immutability" rel="noopener ugc nofollow" target="_blank">不变性</a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="noopener ugc nofollow" target="_blank">懒求值</a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Pattern_matching" rel="noopener ugc nofollow" target="_blank">模式匹配</a>。它还有一个高级类型系统，支持<a class="ae kf" href="https://en.wikipedia.org/wiki/Algebraic_data_type" rel="noopener ugc nofollow" target="_blank">代数数据类型</a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" rel="noopener ugc nofollow" target="_blank">协方差和逆变</a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Higher-order_type_operator" rel="noopener ugc nofollow" target="_blank">高阶类型</a>(但不支持<a class="ae kf" href="https://en.wikipedia.org/wiki/Parametric_polymorphism" rel="noopener ugc nofollow" target="_blank">高阶类型</a>)和<a class="ae kf" href="https://en.wikipedia.org/wiki/Anonymous_type" rel="noopener ugc nofollow" target="_blank">匿名类型</a>。</p><blockquote class="mx my mz"><p id="f79a" class="le lf na lg b lh mc lj lk ll md ln lo nb me lr ls nc mf lv lw nd mg lz ma mb im bi translated">Scala也是一种函数式语言，因为每个函数都是一个值。Scala提供了定义匿名函数的<a class="ae kf" href="https://docs.scala-lang.org/tour/basics.html#functions" rel="noopener ugc nofollow" target="_blank">轻量级语法</a>，支持<a class="ae kf" href="https://docs.scala-lang.org/tour/higher-order-functions.html" rel="noopener ugc nofollow" target="_blank">高阶函数</a>，允许函数<a class="ae kf" href="https://docs.scala-lang.org/tour/nested-functions.html" rel="noopener ugc nofollow" target="_blank">嵌套</a>，支持<a class="ae kf" href="https://docs.scala-lang.org/tour/multiple-parameter-lists.html" rel="noopener ugc nofollow" target="_blank">curry</a>。[1]</p></blockquote><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/379c711581d57c7422f3d0334432b5e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qvJSZjQekZaFEIK_"/></div></div></figure><p id="97d3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Java中没有的Scala的其他特性包括<a class="ae kf" href="https://en.wikipedia.org/wiki/Operator_overloading" rel="noopener ugc nofollow" target="_blank">操作符重载</a>、可选参数、<a class="ae kf" href="https://en.wikipedia.org/wiki/Named_parameter" rel="noopener ugc nofollow" target="_blank">命名参数</a>和<a class="ae kf" href="https://en.wikipedia.org/wiki/Raw_string" rel="noopener ugc nofollow" target="_blank">原始字符串</a>。相反，Scala中没有的Java的一个特性是<a class="ae kf" href="https://en.wikipedia.org/wiki/Checked_exception" rel="noopener ugc nofollow" target="_blank">检查异常</a>，这已经被证明是有争议的。</p><p id="cde4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> Scala在大数据</strong>和其他用例中被大量使用。Twitter等公司转向Scala，特别是因为更好的并发支持。Scala很强大，但是很难学，并且仍然存在一些与Java的兼容性问题。</p><p id="bea7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Scala使用的两个关键驱动因素是基于actor系统的用于并发编程的<a class="ae kf" href="https://akka.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Akka </strong> </a>框架和用于大数据<strong class="lg iu"/>的<a class="ae kf" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Spark </strong> </a>处理引擎。由于其学术性质，除了Akka或Spark之外，Scala在现实世界中没有找到太多的用法。虽然在金融机构大量使用。</p><h1 id="34d1" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Scala Pros</h1><ul class=""><li id="c7c6" class="nj nk it lg b lh li ll lm lp nl lt nm lx nn mb no np nq nr bi translated">运行在<a class="ae kf" href="https://en.wikipedia.org/wiki/Java_virtual_machine" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> JVM </strong> </a>上。它附带了多年来构建的所有JVM优化，并且与Java兼容。</li><li id="209d" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">非常简洁，与Java或GO相比，它需要更少的样板代码。</li><li id="f885" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><strong class="lg iu">功能性和面向对象</strong>。</li><li id="b971" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><a class="ae kf" href="https://dzone.com/articles/scala-type-system-in-depth" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">型系统</strong> </a>非常强大。您可以为您的库构建自定义DSL，在编译时执行检查等等。它还支持<a class="ae kf" href="https://docs.scala-lang.org/scala3/book/types-adts-gadts.html" rel="noopener ugc nofollow" target="_blank"> ADTs </a>。</li><li id="c9fb" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">函数式编程的所有<a class="ae kf" href="https://medium.com/@devisha.singh/7-unbeatable-advantages-of-functional-programming-b5d1af1edbe1" rel="noopener"> <strong class="lg iu">优点</strong> </a>。</li><li id="2243" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">基于actor模型的Akka生态系统使其成为并发系统的最佳选择。</li><li id="20eb" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">强大的<a class="ae kf" href="https://www.scala-sbt.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">构建</strong> </a>工具。</li><li id="3614" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><strong class="lg iu">多才多艺</strong>。Scala可以用来表达任何类型的问题。</li></ul><h1 id="91a9" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Scala Cons</h1><ul class=""><li id="1bbf" class="nj nk it lg b lh li ll lm lp nl lt nm lx nn mb no np nq nr bi translated"><strong class="lg iu">复杂。</strong>难学难精通。通常由高级程序员使用。</li><li id="5209" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><strong class="lg iu">太宽泛</strong>，同样的事情有一百种表达方式，每个Scala开发者都有自己的风格，在大型项目中很难保持代码的一致性。</li><li id="3b2a" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">一些<strong class="lg iu">与Java </strong>的兼容性问题；同样，如果你需要使用Java库，它会剥夺Scala的优势。</li><li id="43d7" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><strong class="lg iu">慢编译器。虽然有像Bloop这样的工具可以缓解这些问题。</strong></li><li id="6d9d" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><strong class="lg iu">它继承了云原生应用程序的JVM问题</strong>，如容器尺寸大、启动时间慢、难以调优、部署慢等。</li><li id="383b" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">尽管Scala非常通用，但它只是找到了某些利基市场，并没有被广泛采用。</li></ul><h1 id="73e4" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">用例</h1><ul class=""><li id="974e" class="nj nk it lg b lh li ll lm lp nl lt nm lx nn mb no np nq nr bi translated"><strong class="lg iu">大数据和分析</strong>。由于其强大的类型系统和可扩展性，大数据世界中很多工具如<a class="ae kf" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Spark </strong> </a>都使用Scala。它是数据工程师和大规模流和批处理引擎的首选语言。</li><li id="059f" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><strong class="lg iu">并发系统和实时应用</strong>。<a class="ae kf" href="https://akka.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Akka </strong> </a>框架因其对并发系统的可伸缩性而闻名，并广泛应用于交易服务和其他使用JVM的高并发系统。</li><li id="23cb" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><strong class="lg iu">高并发API</strong>。<a class="ae kf" href="https://www.playframework.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Play框架</strong> </a>提供了一个高度并发的web框架来构建由<strong class="lg iu"> Akka </strong>支持的应用和API。</li><li id="79c5" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><strong class="lg iu">独石</strong>。Scala是大型整体应用的绝佳选择，甚至是分布式应用。使用Akka集群，你可以在一个应用中创建高度分布式的应用。</li><li id="fc4b" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">一般来说，Scala是用来为特定领域构建框架和库的，就像Akka或Spark一样。</li></ul><h1 id="6987" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">简而言之就是生锈</h1><p id="c17c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Rust_(programming_language)" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Rust </strong> </a>是一个<strong class="lg iu">新的</strong> <strong class="lg iu">语言</strong>，它早在2006年就在<a class="ae kf" href="https://www.mozilla.org/en-US/about/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Mozilla </strong> </a>中开始使用，但直到2015年才首次稳定发布。Rust自发布以来越来越受欢迎，特别是在过去5年里，许多公司如<a class="ae kf" href="https://firecracker-microvm.github.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"/></a>、微软、<a class="ae kf" href="https://serokell.io/blog/rust-companies" rel="noopener ugc nofollow" target="_blank">脸书</a>、Mozilla、<a class="ae kf" href="https://www.dropbox.com/" rel="noopener ugc nofollow" target="_blank"> Dropbox </a>或<a class="ae kf" href="https://github.com/cloudflare" rel="noopener ugc nofollow" target="_blank"> Cloudfare </a>。自2016年以来，Rust每年都在<a class="ae kf" href="https://en.wikipedia.org/wiki/Stack_Overflow" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Stack Overflow</strong></a>开发者调查中被评为<em class="na">“最受欢迎的编程语言”</em>，没有其他语言达到过这一水平，因此它很受欢迎</p><blockquote class="mx my mz"><p id="b516" class="le lf na lg b lh mc lj lk ll md ln lo nb me lr ls nc mf lv lw nd mg lz ma mb im bi translated"><strong class="lg iu"> Rust </strong>是一种<a class="ae kf" href="https://en.wikipedia.org/wiki/Multi-paradigm_programming_language" rel="noopener ugc nofollow" target="_blank">多范式</a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/General-purpose_programming_language" rel="noopener ugc nofollow" target="_blank">通用编程语言</a>，是为<a class="ae kf" href="https://en.wikipedia.org/wiki/Computer_performance" rel="noopener ugc nofollow" target="_blank">性能</a>和安全，尤其是安全<a class="ae kf" href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)" rel="noopener ugc nofollow" target="_blank">并发</a>而设计的。<a class="ae kf" href="https://en.wikipedia.org/wiki/Rust_(programming_language)#cite_note-15" rel="noopener ugc nofollow" target="_blank">【12】</a><a class="ae kf" href="https://en.wikipedia.org/wiki/Rust_(programming_language)#cite_note-Rust_Project_FAQ-16" rel="noopener ugc nofollow" target="_blank">【13】</a>Rust<a class="ae kf" href="https://en.wikipedia.org/wiki/Syntax_(programming_languages)" rel="noopener ugc nofollow" target="_blank">在语法上</a>类似于<a class="ae kf" href="https://en.wikipedia.org/wiki/C%2B%2B" rel="noopener ugc nofollow" target="_blank"> C++ </a>，<a class="ae kf" href="https://en.wikipedia.org/wiki/Rust_(programming_language)#cite_note-17" rel="noopener ugc nofollow" target="_blank">【14】</a>但是可以通过使用<em class="it">借用检查器</em>来验证<a class="ae kf" href="https://en.wikipedia.org/wiki/Reference_(computer_science)" rel="noopener ugc nofollow" target="_blank">引用</a>来保证<a class="ae kf" href="https://en.wikipedia.org/wiki/Memory_safety" rel="noopener ugc nofollow" target="_blank">内存安全</a>。<a class="ae kf" href="https://en.wikipedia.org/wiki/Rust_(programming_language)#cite_note-unsafe-18" rel="noopener ugc nofollow" target="_blank">【15】</a>Rust无需<a class="ae kf" href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" rel="noopener ugc nofollow" target="_blank">垃圾收集</a>即可实现内存安全，<a class="ae kf" href="https://en.wikipedia.org/wiki/Reference_counting" rel="noopener ugc nofollow" target="_blank">引用计数</a>可选。<a class="ae kf" href="https://en.wikipedia.org/wiki/Rust_(programming_language)#cite_note-19" rel="noopener ugc nofollow" target="_blank">【16】</a><a class="ae kf" href="https://en.wikipedia.org/wiki/Rust_(programming_language)#cite_note-20" rel="noopener ugc nofollow" target="_blank">【17】</a>Rust一直被称为<a class="ae kf" href="https://en.wikipedia.org/wiki/Systems_programming" rel="noopener ugc nofollow" target="_blank">系统编程</a>语言，除了<a class="ae kf" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>等高级功能外，它还提供了<a class="ae kf" href="https://en.wikipedia.org/wiki/Low-level_programming_language" rel="noopener ugc nofollow" target="_blank">低级</a> <a class="ae kf" href="https://en.wikipedia.org/wiki/Memory_management" rel="noopener ugc nofollow" target="_blank">内存管理</a>的机制。— <a class="ae kf" href="https://en.wikipedia.org/wiki/Rust_(programming_language)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="2644" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Rust最初是为了取代c++(T1)而开发的，目的是让开发者更容易使用它，同时保持与T2相同的性能(T3)。C++已经存在了将近50年，它被用于开发视频游戏、操作系统、实时系统等等的低级编程。C语言的问题在于它很难使用，特别是，它不是内存安全的，会产生许多最著名的错误和安全漏洞。c开发人员需要确保程序是内存安全的，这在生产级应用中很难实现，这意味着在生产中经常会发现bug，从而产生巨大的问题。这些限制导致了以控制和性能为代价的垃圾收集通用语言，如Java。</p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/3757e204cdf56c5256348562ff5b6f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wUivtzuk20uMn5qMDbRUw.png"/></div></div></figure><p id="244b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">因此，在Rust出现之前，程序员不得不在一种古老而危险的语言(C++)和一种较慢的通用语言(如Java)之间做出艰难的选择。随着我们继续构建更大、更复杂的应用程序，垃圾收集语言在性能方面开始落后，因为它们没有从底层硬件榨取所有的能力。随着多核处理器的推出，需要优化接近硬件的代码，以制作更快、更便宜的程序。</p><p id="fce9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><em class="na">那么，如果Rust是C++的替代品，为什么我们要把它和</em> <strong class="lg iu"> <em class="na"> Scala </em> </strong> <em class="na">做比较呢？</em>在过去的10年里，Rust有了很大的发展，许多库和工具被创造出来，以改善开发者的体验，让开发者更容易使用它，并扩展Rust适用的用例的数量。这意味着Rust已经从一个利基市场取代C++作为系统级编程，走向一种高性能的通用语言，能够与Go、Python或<strong class="lg iu"> Scala </strong>竞争。与其他语言相比，Rust将性能、低资源消耗和小二进制代码提升到了一个新的水平。</p><p id="5241" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在前端，<a class="ae kf" href="https://en.wikipedia.org/wiki/WebAssembly" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> WebAssembly </strong> </a>将Rust置于聚光灯下。<a class="ae kf" href="https://en.wikipedia.org/wiki/WebAssembly" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>试图通过创建在浏览器上运行的高性能应用程序来克服浏览器中的JavaScript限制，Rust是WebAssembly中的主要语言。</p><p id="cc66" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在<a class="ae kf" href="https://llvm.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> LLVM </strong> </a>的帮助下，源代码被编译成本地代码，因此它可以在所有LLVM支持的平台上使用，这使得它非常具有可移植性，但不如c。Rust是一个真正的<strong class="lg iu">开源</strong>项目，拥有一个非常强大和开放的社区，这是它成功和快速扩展的关键。</p><h2 id="3b6b" class="ny kh it bd ki nz oa dn km ob oc dp kq lp od oe ku lt of og ky lx oh oi lc oj bi translated">生锈特征</h2><p id="3c90" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因为Rust是一种新语言，它没有C++或Java等其他语言的历史影响力，这意味着它是根据其他语言的最佳实践和经验设计的。</p><p id="061d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Rust的特性非常丰富，它有丰富的语法和强大的构造，如traits、强大的<a class="ae kf" href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html" rel="noopener ugc nofollow" target="_blank">类型系统</a>、<a class="ae kf" href="https://doc.rust-lang.org/book/ch19-05-advanced-functions-and-closures.html" rel="noopener ugc nofollow" target="_blank">闭包</a>、泛型、集合、模式匹配、<a class="ae kf" href="https://learning-rust.github.io/docs/e6.combinators.html" rel="noopener ugc nofollow" target="_blank">组合子</a>、选项等。你可以在其他强大的语言中看到，比如Scala。</p><p id="7b98" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">最重要的是，它有优秀的开箱即用的工具。<a class="ae kf" href="https://doc.rust-lang.org/cargo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Cargo </strong> </a>可能是最好的软件包管理器，对mono库有很大的支持。它快速、可靠且易于使用。编译器很棒，信息非常清晰，大多数时候它会准确地告诉你需要做什么。</p><p id="a586" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我第二喜欢的特性是<a class="ae kf" href="https://docs.rust-embedded.org/book/static-guarantees/zero-cost-abstractions.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">零成本抽象</strong> </a>，它非常强大。这意味着您可以创建抽象来开发易于使用的API和库，同时保持相同的性能，编译器将解析您的代码，并将其翻译成不会产生任何开销的高效代码。这意味着您可以使用更高级的编程概念，如泛型、集合等，但它们不会带来运行时成本，只有编译器时间成本，因此您可以保持代码整洁，同时仍能获得最高性能。</p><p id="48f2" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Rust <strong class="lg iu">型系统</strong>也极其强大，类似于<strong class="lg iu"> Scala </strong>。Rust支持<a class="ae kf" href="http://blog.madhukaraphatak.com/rust-scala-part-4/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">代数数据类型</strong> </a> <strong class="lg iu"> (ADTs) </strong>得益于其强大的<code class="fe ok ol om on b">enums</code>，也支持高级<a class="ae kf" href="https://doc.rust-lang.org/book/ch18-00-patterns.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">模式匹配</strong> </a>。这些特性通常只在高级函数式编程语言中可用，Rust将这些高级特性带到了低级编程中。</p><p id="5e00" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">但是使<strong class="lg iu"> Rust </strong>区别于其他语言的最具<strong class="lg iu">创新性的</strong>和<strong class="lg iu">独特的</strong> <strong class="lg iu">特性</strong>是<a class="ae kf" href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">所有权模型</strong> </a>，它允许Rust在编译时是内存安全的，允许您编写高效的内存安全代码，而无需显式分配和取消分配内存。</p><p id="19f3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在Rust出现之前，您必须在低级编程语言之间做出选择，您负责管理内存并确保它是安全的，或者使用垃圾收集语言，如Java或Go，这会导致性能下降和更大的二进制文件大小。Rust为编译时的内存安全引入了一个新的范例。</p><blockquote class="mx my mz"><p id="ceac" class="le lf na lg b lh mc lj lk ll md ln lo nb me lr ls nc mf lv lw nd mg lz ma mb im bi translated"><strong class="lg iu"> <em class="it">所有权</em> </strong>是一组<strong class="lg iu">规则</strong>，这些规则<strong class="lg iu">管理一个Rust程序如何管理内存。所有程序在运行时都必须管理它们使用计算机内存的方式。一些语言有垃圾收集，在程序运行时不断寻找不再使用的内存；在其他语言中，程序员必须显式地分配和释放内存。<strong class="lg iu"> Rust </strong>使用了一种<strong class="lg iu">第三种</strong>第三种<strong class="lg iu">方法</strong>:内存是通过一个拥有一套规则的所有权系统来管理的，编译器会检查这些规则。如果违反了任何规则，程序就无法编译。所有权的任何特性都不会降低你的程序运行速度。—<a class="ae kf" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" rel="noopener ugc nofollow" target="_blank">https://doc . rust-lang . org/book/ch04-01-what-is-ownership . html</a></strong></p></blockquote><p id="8a86" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">简而言之，这些是规则:</p><ul class=""><li id="5249" class="nj nk it lg b lh mc ll md lp oo lt op lx oq mb no np nq nr bi translated">Rust中的每个值都有一个变量，称为它的<em class="na">所有者</em>。</li><li id="0e32" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">一次只能有一个所有者。</li><li id="be6c" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">当所有者超出范围时，该值将被丢弃。</li></ul><p id="864a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">有了这3条简单的规则，Rust编译器就可以施展它的“魔法”，确保你的程序是安全的，在生产中不会有意外。</p><p id="41e7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">虽然<strong class="lg iu"> Scala/Java </strong>使用<strong class="lg iu">垃圾收集器</strong>解决了内存安全问题，但是<strong class="lg iu"> Rust </strong>决定使用这种新模式来创建更小更快的程序。</p><p id="c763" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这个新模型的主要问题是<strong class="lg iu">需要时间来适应</strong>它，作为一个开发者你需要花时间来很好地理解这个模型，以避免无尽的挫折，这就是为什么Rust的学习曲线比其他语言如Go高得多，但类似于<strong class="lg iu"> Scala </strong>。</p><h1 id="5094" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Rust Pros</h1><ul class=""><li id="f4f9" class="nj nk it lg b lh li ll lm lp nl lt nm lx nn mb no np nq nr bi translated">极其<strong class="lg iu">快速</strong>和<strong class="lg iu">高效。</strong></li><li id="0fad" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><strong class="lg iu">特性丰富</strong>:闭包、模式匹配、集合、泛型等。</li><li id="26df" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">简洁易读。</li><li id="9481" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/WebAssembly" rel="noopener ugc nofollow" target="_blank">腹板装配</a>支架。</li><li id="58d0" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><a class="ae kf" href="https://doc.rust-lang.org/cargo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Cargo </strong> </a>是一个优秀的包装经理。</li><li id="1007" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">它与C兼容，可以与现有的C程序交互。</li><li id="7f57" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">真正的开源和充满活力的社区。</li><li id="a17b" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><a class="ae kf" href="https://thenewstack.io/which-programming-languages-use-the-least-electricity/" rel="noopener ugc nofollow" target="_blank">低能耗</a>低成本。</li><li id="a0aa" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">出色的成长和知名度的提高。</li><li id="70ed" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">出色的错误处理。</li></ul><h1 id="5d05" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">防锈产品</h1><ul class=""><li id="da7f" class="nj nk it lg b lh li ll lm lp nl lt nm lx nn mb no np nq nr bi translated"><strong class="lg iu">不成熟</strong>，还很新。在生产环境中运行的生产级应用程序并不多，尽管其增长速度很快。</li><li id="5993" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">有点<strong class="lg iu">难学</strong>，特别是<strong class="lg iu">所有权模式</strong>需要一些时间来适应。</li><li id="d4b6" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">编写Rust程序比其他语言如Go要花更长的时间，这是因为你需要遵循编译器设定的严格规则。</li><li id="7dcb" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><strong class="lg iu">没有对并发</strong>、异步编程和绿色线程的本地支持。这是由设计决定的，Rust对操作系统线程有基本的支持，但是对于真实世界的异步编程，你需要使用库。<a class="ae kf" href="https://github.com/rust-lang/futures-rs" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> futures-rs </strong> </a>库包括零成本异步编程的基础。它包括像<code class="fe ok ol om on b">Stream</code>这样的关键特征定义，以及像<code class="fe ok ol om on b">join!</code>、<code class="fe ok ol om on b">select!</code>这样的实用程序，以及各种支持表达性异步控制流的未来组合器方法。还有许多可用于并发编程的库和引擎，其中最著名和最强大的是<a class="ae kf" href="https://tokio.rs/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Tokio </strong> </a>。</li></ul><h1 id="5a12" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Rust用例</h1><ul class=""><li id="c60b" class="nj nk it lg b lh li ll lm lp nl lt nm lx nn mb no np nq nr bi translated"><strong class="lg iu"> CPU </strong> <strong class="lg iu">密集型</strong>应用如游戏、操作系统等。</li><li id="b9b6" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">嵌入式系统</li><li id="a8cc" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">应用程序运行时。比如Node.js的创建者已经创建了<a class="ae kf" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Deno </strong> </a>作为新一代的JavaScript运行时，这是用Rust写的。</li><li id="ed62" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><strong class="lg iu">微服务:API</strong>如<strong class="lg iu"> REST </strong>端点。Rust有一些<strong class="lg iu">最快的web框架</strong>比如<a class="ae kf" href="https://actix.rs/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Actix </strong> </a>。</li><li id="ad41" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/WebAssembly" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> WebAssembly </strong> </a>在浏览器中执行高效代码。它还可以用来在服务网格中编写高效的过滤器，如Istio、Istio、T37、T38、T40。</li><li id="778f" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated"><a class="ae kf" href="https://yew.rs/" rel="noopener ugc nofollow" target="_blank">网页开发</a></li><li id="e675" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">加密货币。</li></ul><p id="84ab" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">因为它的复杂性，我不会用Rust来创建CLI和简单的脚本，但这是可能的。</p><h1 id="e1be" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Rust vs Scala</h1><p id="dcd4" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">机器人编程语言是强类型的，它们是安全的，高度并发的，每秒可以处理数百万条记录。</p><p id="36a3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">对于大数据/数据处理，Scala是最佳选择</strong>。Rust在大数据领域仍处于起步阶段；尽管有一些非常有趣的项目正在开发中，而且发展速度很快。<a class="ae kf" href="https://github.com/apache/arrow-datafusion" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">数据融合</strong> </a>是一个有趣的项目，旨在取代<strong class="lg iu"> Spark </strong>进行基于<a class="ae kf" href="https://arrow.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Arrow </a>的超快速并行数据处理。欲了解更多信息，请查看此<a class="ae kf" href="https://towardsdatascience.com/data-processing-in-rust-with-datafusion-arrow-56df5432de68" rel="noopener" target="_blank"> <strong class="lg iu">文章</strong> </a>。</p><p id="c773" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">对于流处理，Scala拥有更广阔的生态系统。</strong> <strong class="lg iu"> Akka </strong>本身就是一个怪兽，可以自己管理大量的请求，没有任何依赖性，它还提供了更多的特性，比如<strong class="lg iu">背压。</strong>在Rust中，你有<a class="ae kf" href="https://tokio.rs/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Tokio </strong> </a>，它也支持<a class="ae kf" href="https://tokio.rs/tokio/tutorial/streams" rel="noopener ugc nofollow" target="_blank">流处理</a>，但没有相同级别的特性，因为它比基于<a class="ae kf" href="https://en.wikipedia.org/wiki/Actor_model" rel="noopener ugc nofollow" target="_blank">演员模型</a>的<strong class="lg iu"> Akka </strong>生态系统级别低。尽管如此，<strong class="lg iu"> Tokio </strong>比<strong class="lg iu"> Akka </strong>快得多，因为它没有管理演员的额外开销。在<strong class="lg iu"> Rust </strong>中也有一个actor库叫做<a class="ae kf" href="https://github.com/actix/actix" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Actix </strong> </a>是它基于actor的web框架<a class="ae kf" href="https://github.com/actix/actix-web" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Actix-web</strong></a>Rust中最知名的库之一，因为它是市场上最快的HTTP服务器之一，远远胜过任何Scala HTTP服务器。</p><p id="c1d9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">对于web应用</strong>,<strong class="lg iu">Scala</strong><a class="ae kf" href="https://www.playframework.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Play Framework</strong></a>更适合于有状态的web应用或者有足够时间让JVM优化应用的长期应用。Scala非常适合小型服务或大型平台。如果需要和Akka集成也是不错的选择。另一方面，<strong class="lg iu"> Rust更适合需要高性能的微服务和云原生应用</strong>，但由于其可扩展的<strong class="lg iu"> </strong> <a class="ae kf" href="https://learning-rust.github.io/docs/d5.workspaces.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">工作空间</strong> </a> <strong class="lg iu">，也可用于单片..</strong>这种<strong class="lg iu">锈</strong> <a class="ae kf" href="https://rocket.rs/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">火箭</strong> </a>或<a class="ae kf" href="https://github.com/actix/actix-web" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Actix-web </strong> </a>功能极其强大且易于使用。</p><p id="b915" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> Scala是一种高级语言</strong>，它是在学术界创建的，不是为了解决任何特殊或特定的问题，而是从头开始创建一种非常丰富的语言<strong class="lg iu">它可以利用JVM的功能，包括其可移植性和性能优化，但它也承载了影响性能的JVM及其垃圾收集器的重量。<strong class="lg iu"> Rust </strong>另一方面是一种<a class="ae kf" href="https://en.wikipedia.org/wiki/System_programming_language" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">系统编程语言</strong> </a>专注于性能、低资源使用和低级细节。<strong class="lg iu"> Rust </strong>旨在通过创造一种更简单更新的编程语言来完全取代C++。此外，Rust <a class="ae kf" href="https://docs.rust-embedded.org/book/static-guarantees/zero-cost-abstractions.html" rel="noopener ugc nofollow" target="_blank">的零成本抽象</a>特性和惊人的<a class="ae kf" href="https://doc.rust-lang.org/cargo/reference/workspaces.html" rel="noopener ugc nofollow" target="_blank">构建系统</a>允许开发人员创建易于使用但仍然高性能的库，用于通用任务，如REST APIs、流处理等等，这使得Rust可以与Scala竞争。</strong></p><p id="f59b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> Scala在几个方面比Rust </strong>更成熟，就<strong class="lg iu">函数式编程而言</strong> Scala比Rust更先进，但<strong class="lg iu"> Rust </strong>也不甘落后，它只是缺少一些功能<a class="ae kf" href="https://www.baeldung.com/scala/higher-kinded-types" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">更高级的类型</strong> </a>或检查尾部递归，但它们很快就会推出。</p><p id="1808" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> Rust </strong>在概念上是纯粹的，因为<strong class="lg iu"> Scala </strong>已经被改造成了<strong class="lg iu"> JVM </strong>，所以它有它的局限性，并且为你的心智模型增加了一个额外的抽象层。<strong class="lg iu"> WebAssembly </strong>是为在web和嵌入式系统中运行而从头开始构建的，它是现代的、安全的和轻量级的。它甚至打算不仅取代JVM，而且完全取代容器T21。Rust对WebAssembly有一流的支持，它是WebAssembly的主要语言。</p><p id="135a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Rust是系统编程、微服务、CPU密集型任务、web等等的更好选择。<strong class="lg iu"> Scala </strong>对于<strong class="lg iu">大数据</strong> (Spark和Hadoop生态系统)来说会更好，主要是因为相比Rust来说工具更加丰富和成熟。</p><h1 id="3ccb" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">表演</h1><p id="6a9c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Rust将在所有领域胜过Scala，这是因为Rust是为速度而生，作为C的替代品，而Scala只是专注于语言本身。</p><p id="e939" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">对于某些应用程序，<strong class="lg iu"> JVM </strong>实时(<a class="ae kf" href="https://www.geeksforgeeks.org/just-in-time-compiler/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> JIT </strong> </a>)编译器可以执行优化，从而提高运行时的性能，Rust是提前编译的，因此不会发生这种情况。这意味着<strong class="lg iu"> Scala </strong>可能需要时间预热以达到一定的性能水平，而Rust从一开始就会表现良好，这是运行<strong class="lg iu">无服务器</strong>函数(<a class="ae kf" href="https://www.ibm.com/cloud/learn/faas" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">【FaaS】</strong></a>)时的优势。</p><p id="c3d9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在<strong class="lg iu"> Rust </strong>中，编译器将指导你确保编写安全的代码，并提示你获得良好的性能，但仍然相对容易编写性能比Scala更差的糟糕的Rust代码，这就是为什么正确学习语言、理解所有权模型和内存如何工作很重要，这样你就不会陷入克隆数据的坏习惯，这会增加内存使用量并降低性能；但是总的来说，<strong class="lg iu">仅仅通过在Rust中重写你的代码，你应该会得到很大的性能提升。</strong></p><p id="ff40" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> Scala </strong>具有使用JVM优化和丰富生态系统的优势，例如<a class="ae kf" href="https://akka.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Akka </strong> </a>框架具有许多Rust所缺乏的流处理和并发编程的特性和优化，可以帮助您轻松构建高性能应用。</p><p id="d0d3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">最后，Rust的CPU、内存和二进制文件的大小将大大降低，从而成为一种更节能、成本更低的语言，这将减少您的云账单。</p><h1 id="b134" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">推荐</h1><h1 id="35b3" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">如果你是开发人员…</h1><ul class=""><li id="a462" class="nj nk it lg b lh li ll lm lp nl lt nm lx nn mb no np nq nr bi translated">如果你是一名高级Java开发人员，想转向更高级的语言，学习Scala。</li><li id="ae98" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果您已经使用了JVM和/或在本地运行，请学习Scala。</li><li id="6432" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果你正在使用Akka和Spark寻找高薪工作，学习Scala。</li><li id="20cf" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果你在大数据方面投入很大，学习Scala。</li><li id="2de8" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果你想在金融机构等更传统的行业工作，学习Scala。</li><li id="0c5f" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果你想进入加密货币领域，就要学习Rust。</li><li id="f419" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果你是高级开发人员和/或C开发人员，请学习Rust。</li><li id="f675" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果你想找高薪工作，但不是很多，那就学会生锈吧。</li><li id="e0e2" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果你想在嵌入式系统或<strong class="lg iu"> WebAssembly </strong>和其他现代工具上工作，学习Rust。</li><li id="a978" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果你想用超快的代码打动你的老板，那就学习Rust吧。</li><li id="284f" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果您想使用<a class="ae kf" href="http://blog.madhukaraphatak.com/rust-scala-part-4/" rel="noopener ugc nofollow" target="_blank"> ADTs </a>和高级类型构建复杂的应用程序，请学习Rust。</li><li id="3b7b" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果你想在云中工作，在初创企业和酷项目中工作，就要学习Rust。</li></ul><p id="d28d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这两种语言都很复杂，需要一点学习过程。</p><p id="f24a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> Scala </strong>很有趣，<strong class="lg iu">很复杂</strong>很有挑战性，但也很有价值，报酬很高，也更有声望，尤其是在大数据领域。</p><p id="1a11" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Rust<strong class="lg iu">是<strong class="lg iu">复杂的</strong>，具有挑战性，但也是值得的，报酬很高，也有声望。</strong></p><p id="91ea" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Rust的发展速度比Scala快得多，趋势表明Scala的使用正在随着时间的推移而减少，因为Rust和Golang等其他语言接管了Scala中的一些用例，Java增加了Scala中的一些功能。</p><h1 id="62dc" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">如果你是技术主管…</h1><ul class=""><li id="ae61" class="nj nk it lg b lh li ll lm lp nl lt nm lx nn mb no np nq nr bi translated">如果你依赖JVM或者你的开发团队已经熟悉Java，那么使用Scala。</li><li id="381a" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">对于利用JVM优化的高并发分布式系统，使用Scala。</li><li id="996e" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">大数据用Scala，特别是Spark。</li><li id="5b59" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果您的Java应用程序有伸缩问题，请使用Scala。</li><li id="340e" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果您的团队已经了解C，并且您想编写更安全的代码，请使用Rust。</li><li id="5773" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">将Rust用于高度并发的复杂分布式系统，这些系统可以充分利用硬件资源并提供可预测的性能。</li><li id="f300" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">使用Rust来重写你的应用程序中需要高性能的部分，你可以用另一种语言来写剩下的部分。</li><li id="2c57" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">用Rust远离C，两者兼容。</li><li id="63cc" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果你在一家生产bug非常昂贵的公司工作，比如医疗保健、航空等，就使用Rust。</li><li id="5177" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果你的问题可以用现有的成熟库解决，比如<a class="ae kf" href="https://tokio.rs/" rel="noopener ugc nofollow" target="_blank"> Tokio </a>、<a class="ae kf" href="https://rocket.rs/" rel="noopener ugc nofollow" target="_blank"> Rocket </a>、<a class="ae kf" href="https://actix.rs/" rel="noopener ugc nofollow" target="_blank"> Actix </a>等，就使用Rust。不需要太多的努力，你就会得到很好的表现。</li><li id="f2f4" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">使用Rust生成最少的二进制文件以部署在edge或嵌入式系统上。</li><li id="b092" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">对大型或单一项目使用Rust</li><li id="450d" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">模块化是关键的大代码库的用户信任</li></ul><p id="d4b0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">总之，这两种语言都可以用于<strong class="lg iu">单片</strong>和<strong class="lg iu">微服务</strong>，并且都可以用于<strong class="lg iu">并发</strong>编程，性能非常好。Rust 更擅长运行并行任务和优化资源，使其更加高效和廉价，它还创建了一个更小的二进制文件。对于<strong class="lg iu">无服务器</strong>和<strong class="lg iu"> Kubernetes </strong>和<strong class="lg iu"> Rust </strong>将更容易、更快、更高效。Scala有更成熟的库，特别是大数据。</p><h1 id="caa2" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">如果你是经理…</h1><ul class=""><li id="f347" class="nj nk it lg b lh li ll lm lp nl lt nm lx nn mb no np nq nr bi translated">将Scala用于传统的关键并发应用、单片或实时系统。</li><li id="1595" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">大数据使用<strong class="lg iu">Scala</strong>。</li><li id="3ef8" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">如果您已经在使用Java，并且您的组织中的改变很困难且需要时间，请使用Scala。</li><li id="3842" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">将Rust用于<strong class="lg iu">新的</strong>关键并发应用、单片或实时系统。</li><li id="1bbd" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">用铁锈建造<a class="ae kf" href="https://thenewstack.io/which-programming-languages-use-the-least-electricity/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">更环保的</strong> </a>项目。</li><li id="3cb9" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">使用Rust或Scala吸引高技能开发人员。</li><li id="87fe" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">对大型代码库和复杂项目使用Rust或Scala。</li><li id="b1cb" class="nj nk it lg b lh ns ll nt lp nu lt nv lx nw mb no np nq nr bi translated">对Kubernetes或Serverless中的微服务使用Rust。</li></ul><p id="05b7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">简而言之，<strong class="lg iu"> Rust </strong>运行成本更低，性能更好，而且Rust的程序员非常优秀，如果你使用Rust，你会吸引人才。问题是Rust的开发者并不多，而且很难找到他们。<strong class="lg iu"> Scala </strong>非常适合大型项目和<strong class="lg iu">大数据</strong>。如果你在使用Java的JVM上投入了大量资金，那么Scala是一个常见的下一步选择，而不是Rust。</p><h1 id="c0c8" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="f379" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Rust是我最喜欢的新语言，它是新的、令人耳目一新的、高性能的、丰富的和可扩展的。习惯它需要一些时间，你可能会因为所有权模型而对编译器感到沮丧，但是一旦你习惯了它并理解了规则，它就变得容易了。</p><p id="9a6d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">对于我个人来说，<strong class="lg iu">关于<strong class="lg iu"> Rust </strong>最好的一点</strong>就是它的<a class="ae kf" href="https://thenewstack.io/which-programming-languages-use-the-least-electricity/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">低能耗</strong> </a>，JVM几乎翻倍消耗。随着我们星球上人口的增长和气候变化成为一个问题，我们应该努力提高能源效率，减少我们的碳足迹。软件几乎无处不在，运行软件所需的能量对地球有着毁灭性的影响；减少能源消耗将对我们的星球产生巨大的影响(也包括你的云账单！)，而且这个很重要。作为开发者，我们应该意识到这一点，并努力学习更多的<strong class="lg iu">节能语言</strong>，以便为创造一个更加<strong class="lg iu">可持续发展的</strong>星球做出贡献。</p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi or"><img src="../Images/d3989be16f916f2d90257ab7f6e233cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DSsGLLU4HQPfrNUw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">与C语言一样，Rust是最有效的语言</figcaption></figure><p id="1fe1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">作为一名开发人员，<strong class="lg iu">我喜欢用Scala解决问题，</strong>，<strong class="lg iu">它相当优雅、简洁、强大；和一乐使用</strong>；然而，对于真实世界的场景，我发现很难证明Scala 的使用是正确的，它像Rust一样难学，它更慢，而且它承载了JVM的重量:垃圾收集导致低效的性能、高内存消耗、安全漏洞、大尺寸容器等等。最重要的是，<strong class="lg iu"> Java </strong>也在迎头赶上，增加了Scala中的许多可用特性。这意味着对于不太复杂的应用来说，<strong class="lg iu"> Java将是一个很好的选择</strong>，你将拥有比Scala或Rust更多的开发人员。对于高性能代码，Rust优于Scala所以<strong class="lg iu">我发现除了大数据项目，很难找到Scala是第一选择的新项目用例。</strong></p><p id="4c22" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我相信<a class="ae kf" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> WebAssembly </strong> </a>是未来，从长远来看，它可能会完全取代集装箱。Rust + WebAssembly是一个强大的、可移植的轻量级解决方案。</p><p id="cf78" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我认为使用<strong class="lg iu"> Rust </strong>的唯一<strong class="lg iu">风险</strong>，是<strong class="lg iu">不成熟</strong>，仍然没有官方的异步编程API/库，一些函数构造如更高级的类型仍在开发中。除此之外，我认为<strong class="lg iu"> Rust已经找到了编程语言的甜蜜点，这要归功于所有权模型</strong>创建了一种丰富但低水平/高性能的语言，每个人都可以使用。</p><p id="7981" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Rust正以指数速度增长，特别是它的社区在短短一年内增长了300%,成为发展最快的语言。</p><p id="209f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果您正在使用Scala，并且没有性能瓶颈，那么就没有必要迁移到Rust。Scala是一门伟大的语言，特别是对于大数据，但是对于新项目，请考虑Rust。</p><p id="d3c1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我喜欢这个事实，Rust非常具有互操作性，所以你可以只移植你的部分代码T21。使用不同的编程语言是可以的。许多公司将Rust用于性能很重要的核心组件，将其他编程语言用于其他用例。我认为这是正确的做法。<strong class="lg iu">从重写Rust中的核心组件开始，并根据需要继续重构</strong>，记住，如果某个东西有效，就没有必要去改变它！</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><p id="cb66" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><em class="na">记得来</em> <strong class="lg iu"> <em class="na">拍拍</em> </strong> <em class="na">如果你喜欢这篇文章</em> <a class="ae kf" href="https://javier-ramos.medium.com/subscribe" rel="noopener"> <em class="na"> </em> <strong class="lg iu"> <em class="na">关注</em></strong><em class="na"/><strong class="lg iu"><em class="na">me</em></strong></a><em class="na">或</em> <a class="ae kf" href="https://javier-ramos.medium.com/membership" rel="noopener"> <strong class="lg iu"> <em class="na">订阅</em> </strong> </a> <em class="na">获取更多更新！</em></p><p id="fb3d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://javier-ramos.medium.com/subscribe" rel="noopener"> <strong class="lg iu">订阅</strong> </a>获得<strong class="lg iu">通知</strong>当我发表一篇文章<a class="ae kf" href="https://javier-ramos.medium.com/membership" rel="noopener"> <strong class="lg iu">加入Medium.com</strong></a>访问数百万或文章！</p></div></div>    
</body>
</html>