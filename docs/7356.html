<html>
<head>
<title>Merge GraphQL Schemas using Apollo Server and Koa</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Apollo服务器和Koa合并GraphQL模式</h1>
<blockquote>原文：<a href="https://itnext.io/merge-graphql-schemas-using-apollo-server-and-koa-346019e6945f?source=collection_archive---------2-----------------------#2022-08-30">https://itnext.io/merge-graphql-schemas-using-apollo-server-and-koa-346019e6945f?source=collection_archive---------2-----------------------#2022-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f048b68d5b7a9d6558164ba543e940f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-ho31Jc-Ka8OwiVvvgTZA.jpeg"/></div></div></figure><p id="7d72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，在我们现代的开发人员世界中，完全无法想象没有React、Node JS、GraphQL等技术的生活。他们拥有坚实的队伍，在数据交付方面处于领先地位。我遇到的70%的案例都是与GraphQL集成或者即将迁移到它的项目。越来越多的公司倾向于使用Graphql数据查询语法，如今它已经成为必备知识。</p><p id="e24a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> GraphQL </strong> </a>是一种针对API的查询型语言，广泛用于从服务器端向客户端请求数据的优化素材。客户端使用类型化模式准确地请求它们需要的内容。它允许您只发送所请求的内容，而不是固定的数据集。</p><p id="5ec3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.apollographql.com/docs/apollo-server/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Apollo Server </strong> </a>为您提供了发送客户端请求响应的工具。Apollo客户端提供了使用Graphql API的能力，包括缓存和链接。</p><h2 id="6d5b" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">是关于什么的？</h2><p id="d4ff" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我们将创建两个Apollo服务器来处理Graphql模式合并。在这种情况下，一些外部服务器使用Graphql API进行响应，而其他一些服务使用自己的Graphql模式，包括外部模式。在节点层，我们将把来自外部服务器的结果打包到一个模式中，并发送给客户端。实际上，我们将把两个模式合并成一个并发送给客户端。</p><h2 id="d98c" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">让我们深入研究代码</h2><p id="9637" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">对于实现，我们将使用Node JS环境、Koa中间件和带有GraphQL工具的Apollo服务器。</p><p id="0cc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们必须运行两台服务器。两者都必须有一个GraphQL阿波罗服务器。这是图表。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/7b84fbc1186928bd3f3888d5cbc0e26e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IuuSV7Fukkdh-CzlJe_vRg.jpeg"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">图表模式合并</figcaption></figure><p id="1d4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是时候创建样板文件并运行它们了。为此，我们需要创建两个文件夹，并将其中一个文件夹命名为:<code class="fe me mf mg mh b">boilerplate-raphql-koa-server-external</code>，将第二个文件夹命名为:<code class="fe me mf mg mh b">boilerplate-graphql-koa-server</code></p><p id="3c99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开始之前，请看看两个项目中的文件夹结构。很简单。这两个回购协议的区别在于代码。</p><pre class="lw lx ly lz gt mi mh mj mk aw ml bi"><span id="5e20" class="kx ky iq mh b gy mm mn l mo mp">├── package.json<br/>└── src<br/>    ├── index.js<br/>    ├── resolvers.js<br/>    └── schema.js</span></pre><h2 id="4e07" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">外部GraphQL服务器</h2><p id="7814" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">现在，让我们设置一下<code class="fe me mf mg mh b">boilerplate-graphql-koa-server-external</code></p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><code class="fe me mf mg mh b">boilerplate-graphql-koa-server-external</code>的package.json</figcaption></figure><p id="7a52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后让我们创建服务器本身。在<code class="fe me mf mg mh b">src</code>文件夹的<code class="fe me mf mg mh b">index.js</code>中添加服务器设置:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><code class="fe me mf mg mh b">boilerplate-graphql-koa-server-external</code>的index.js</figcaption></figure><p id="747c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">异步函数<code class="fe me mf mg mh b">server</code>将负责koa应用程序本身，我们将创建带有可执行模式的apollo服务器，其中我们必须提供来自模式和解析器的类型。从<a class="ae kw" href="https://www.apollographql.com/docs/apollo-server/integrations/middleware/#apollo-server-koa" rel="noopener ugc nofollow" target="_blank">正式文件</a>来看，我们必须在<code class="fe me mf mg mh b">apolloServer.applyMiddleware</code>之前提前调用<code class="fe me mf mg mh b">apopServer.start()</code>。它允许识别潜在的问题，并在Apollo服务器启动过程崩溃的情况下采取行动，而不是开始服务请求。</p><p id="7a92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二部分是<code class="fe me mf mg mh b">boilerplate-graphql-koa-server-external</code>让我们建立模式和解析器。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><code class="fe me mf mg mh b">boilerplate-graphql-koa-server-external</code>的schema.js</figcaption></figure><p id="37b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">架构的解析器。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><code class="fe me mf mg mh b">boilerplate-graphql-koa-server-external</code>的resolvers.js</figcaption></figure><p id="1bb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是检查服务器响应的时候了。在此之前，不要忘记安装软件包:<code class="fe me mf mg mh b">npm i</code>，然后运行命令<code class="fe me mf mg mh b">npm run start</code>，并在Chrome浏览器中放置URL: <code class="fe me mf mg mh b"><a class="ae kw" href="http://localhost:4000/api/v1/graphql." rel="noopener ugc nofollow" target="_blank">http://localhost:4000/api/v1/graphql</a></code>。点击“查询你的服务器”按钮，就可以得到apollographql的界面。它允许您查看来自服务器的请求模式。打开<a class="ae kw" href="https://studio.apollographql.com/sandbox/schema/sdl" rel="noopener ugc nofollow" target="_blank">自检模式</a>页面。你会看到我们的模式:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/a0517bee6eda4effe51200f65e4e47b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2I4a9A000PQa1z0xzOB8A.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">Apollo GraphQL Studio中的自省模式视图</figcaption></figure><p id="0f2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您能够自省模式，那么这意味着我们完成了我们的<code class="fe me mf mg mh b">boilerplate-graphql-koa-server-external</code></p><h2 id="bff7" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">用于合并模式的GraphQL服务器</h2><p id="b880" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">现在让我们转到<code class="fe me mf mg mh b">boilerplate-graphql-koa-server</code>设置。在<code class="fe me mf mg mh b">package.json</code>和<code class="fe me mf mg mh b">external</code>中几乎所有的东西都是一样的，除了附加的包和不同的<code class="fe me mf mg mh b">PORT</code>，名称和描述。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><code class="fe me mf mg mh b">boilerplate-graphql-koa-server</code>的package.json</figcaption></figure><p id="75e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们马上建立新的模式。模式中有很多相同但稍有不同的数据。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><code class="fe me mf mg mh b">boilerplate-graphql-koa-server</code>的schema.json</figcaption></figure><p id="5b67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和解析器:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><code class="fe me mf mg mh b">boilerplate-graphql-koa-server</code>的resolvers.js</figcaption></figure><p id="7705" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们来看看服务器文件。你会发现除了几行代码之外，其他都差不多。首先，我们使用<code class="fe me mf mg mh b">loadSchema</code>是为了通过来自<code class="fe me mf mg mh b">EXTERNAL_ENDPOINT</code>的请求获得外部模式，T1是我们第一个启动的服务器，也是模式<code class="fe me mf mg mh b">UrlLoader</code>的加载器。</p><p id="f134" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最重要是，我们必须确保我们的模式已经被加载，且外部服务器没有抛出任何错误。我们必须抓住这种情况。正如您在代码中看到的，我们得到的只是一个模式数组。默认情况下，我们只有自己的<code class="fe me mf mg mh b">internalSchema</code>，然后，如果有外部服务器可用，我们会将数据推送到那个数组<code class="fe me mf mg mh b">externalSchema</code>，然后使用工具<code class="fe me mf mg mh b">mergeSchemas</code>，它有助于将合并的模式直接提供给<code class="fe me mf mg mh b">ApolloServer</code></p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">合并模式的Apollo服务器设置</figcaption></figure><p id="b49e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装所有软件包并运行将在<code class="fe me mf mg mh b">PORT=3000</code>上可用的服务器。让我们转到apollographql的同一个接口，但是URL必须使用正确的端口:<code class="fe me mf mg mh b"><a class="ae kw" href="http://localhost:4000/api/v1/graphql." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/v1/graphql</a></code>。现在，如果我们打开<a class="ae kw" href="https://studio.apollographql.com/sandbox/schema/sdl" rel="noopener ugc nofollow" target="_blank">自省模式</a>页面，我们将能够看到合并的模式。一个来自外部，另一个来自最后创建的服务器。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/38a3040d6c3556c2bbeb5b53d3dc8508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*td3pqtkEwUYRE9H2_u5EsQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">Apollo GraphQL Studio中的自省模式视图</figcaption></figure><p id="6886" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，如果您的一些服务器将获得相同的字段，GraphQL服务器将产生如下错误:</p><pre class="lw lx ly lz gt mi mh mj mk aw ml bi"><span id="6325" class="kx ky iq mh b gy mm mn l mo mp">Error: Unable to merge GraphQL type “Query”: Field “getFakeDataExample” already defined with a different type. Declared as “DataExample”, but you tried to override with “DataExternalExample”</span></pre><p id="2013" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着在GraphQL模式中，我们必须非常小心我们的字段和类型定义，以免在类型或字段已经存在时陷入尴尬的境地。</p><p id="228d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">GitHub Repos</strong><br/><a class="ae kw" href="https://github.com/antonkalik/boilerplate-graphql-koa-server" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Anton kalik/boilerplate-graph QL-KOA-server</a><br/><a class="ae kw" href="https://github.com/antonkalik/boilerplate-graphql-koa-server-external" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Anton kalik/boilerplate-graph QL-KOA-server-external</a></p><p id="a0a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">模式加载文档</strong>【https://www.graphql-tools.com/docs/schema-loading】<a class="ae kw" href="https://www.graphql-tools.com/docs/schema-loading" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="8946" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">结论</h2><p id="fed5" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">许多公司正在转向微服务架构，并试图隔离数据流的逻辑。我在上面描述的这种方法适用于公司中的微服务之间的通信情况，此时存在某种具有默认模式的全局服务和具有附加字段的小型微服务，这些字段将来会被客户端使用。</p><p id="a201" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的关注。</p></div></div>    
</body>
</html>