<html>
<head>
<title>Reddit’s Voting UI in Vanilla vs React vs Vue vs Hyperapp: shedding light on the purpose of front-end frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Reddit的投票用户界面Vanilla vs React vs Vue vs Hyperapp:阐明前端框架的目的</h1>
<blockquote>原文：<a href="https://itnext.io/reddits-voting-ui-in-vanilla-vs-react-vs-vue-vs-hyperapp-shedding-light-on-the-purpose-of-spa-ee6b6ac9a8cc?source=collection_archive---------0-----------------------#2018-07-18">https://itnext.io/reddits-voting-ui-in-vanilla-vs-react-vs-vue-vs-hyperapp-shedding-light-on-the-purpose-of-spa-ee6b6ac9a8cc?source=collection_archive---------0-----------------------#2018-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/cd3164612b0e7334848a910e4e7eb1f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/1*fVromziN2ouLssCCQMsYLw.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Reddit投票用户界面</figcaption></figure><p id="fd5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">许多初学者可能想知道SPA(单页应用程序)库/框架的目的是什么。为什么他们不能使用普通的旧JavaScript，因为它可以实现同样的事情而不会膨胀？它们的目的是什么，为什么被如此炒作？</p><p id="efb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从本质上讲，这些库旨在简化交互式web应用程序的构建。用户经常以喜欢帖子、上传图片、与朋友聊天、发表评论等形式与网站互动。这种交互性包括在用户与页面交互时更新DOM元素以反映新数据。</p><p id="2f9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，“喜欢”按钮可能有两种JavaScript状态:不喜欢和喜欢。它可能还定义了CSS状态，比如:hover，:active和:focus。CSS状态很容易管理，但是JavaScript状态可能会很棘手。为了让用户知道他们成功地按下了“喜欢”，按钮会永久地改变外观，不管他们是悬停在它上面、按下它还是聚焦它。他们还需要能够撤销这个操作，同时将数据发送到服务器，让应用程序知道用户做了什么。这种更新元素的过程通常很耗时，而且容易出错，尤其是在大中型应用程序中。</p><p id="ac11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，你不能只相信我的话。你需要通过实例体验才能真正理解<em class="kw">为什么</em>。这就是这篇文章的内容！此外，还将对这些库进行比较，看它们如何实现相同的目标，以及哪一个最出色🌟。</p><h1 id="4acc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">香草</h1><p id="6e2d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们从一个实际的例子开始，从我们可靠的原生库Vanilla.js开始。</p><p id="8380" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">reddit.com网站有一个投票界面，由两个按钮和一个分数组成:一个向上投票按钮将分数增加1，一个向下投票按钮将分数减少1。分数是由用户投票给帖子或评论的数字，作为其质量的指标。这个UI元素背后的逻辑实际上比您最初设想的要复杂。为了简单起见，这个UI的服务器请求方面将被省略。</p><p id="f2e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在最基本的情况下，HTML标记可能如下所示:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/15be4d031ed5e086099e8d63ab1ebd43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1KiJmSsEExhmZd0KIo1Bg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Reddit投票标记</figcaption></figure><p id="f85d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户按下upvote按钮时，我们希望<code class="fe mj mk ml mm b">h1</code>元素中的文本增加1。相反，当他们按下downvote按钮时，我们希望它减少1。</p><p id="18f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要对这些元素做任何事情，我们需要使用<code class="fe mj mk ml mm b">document.querySelector()</code>选择它们，这样我们就可以在JavaScript代码中使用它们。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mn"><img src="../Images/55c5dc9a352b1e8d894214d4fe646e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cli2stnW365hEtldn6gtkQ.png"/></div></div></figure><p id="4213" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们想在用户点击按钮时做出反应。为此，我们需要向它们添加一些事件侦听器。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mo"><img src="../Images/9e99f7e1f9a8b442620d3afda32b3d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Ej75d8vs6r0h8MJGTaPWA.png"/></div></div></figure><p id="97c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，这些侦听器函数中应该包含什么？为了理解，让我们来分解一下当我们与UI交互时会发生什么。</p><p id="4517" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个得分为<code class="fe mj mk ml mm b">0</code>的帖子。</p><ul class=""><li id="45b4" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">我们按下upvote。会发生什么？现在比分是<code class="fe mj mk ml mm b">1</code>。</li><li id="0e74" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir">我们再次按下up vote</strong>会发生什么？比分现在是<code class="fe mj mk ml mm b">0</code>。为什么？因为我们不能像计数器一样永远向上投票。再次按下它意味着我们正在“撤销”我们的投票，重新设置它。</li><li id="76cf" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">这次我们按下反对票。会发生什么？现在比分是<code class="fe mj mk ml mm b">-1</code>。</li><li id="3a82" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">我们再次投票。会发生什么？比分现在是<code class="fe mj mk ml mm b">1</code>。注意分数增加了<code class="fe mj mk ml mm b">2</code>，从<code class="fe mj mk ml mm b">-1</code>到<code class="fe mj mk ml mm b">1</code>。这部分可能有点棘手。</li></ul><p id="c5c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在整个交互过程中，我们需要保持两个变量:分数和用户自己的投票。这两个值共同决定了当他们按下其中一个按钮时会发生什么。这个概念被称为<strong class="ka ir">状态，</strong>，它描述了我们的应用程序的数据或内存。事情如何运作取决于应用程序的当前状态。</p><h2 id="d598" class="nd ky iq bd kz ne nf dn ld ng nh dp lh kj ni nj ll kn nk nl lp kr nm nn lt no bi translated">逻辑🔮</h2><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi np"><img src="../Images/06c07f92ee1bced7f91910e02e021adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GIRyLkz0XLRCLyOrYSbC6g.png"/></div></div></figure><p id="9ac4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在这就像一个计数器，但是我们会慢慢开始。我们通过将<code class="fe mj mk ml mm b">scoreHeading</code>元素的<code class="fe mj mk ml mm b">textContent</code>抛出到<code class="fe mj mk ml mm b">Number()</code>构造函数中来获得当前分数，这确保了我们有一个与数学运算符<code class="fe mj mk ml mm b">+</code>和<code class="fe mj mk ml mm b">-</code>一起工作的数字。然后我们将<code class="fe mj mk ml mm b">textContent</code>设置为当前分数加1或减1，这取决于我们点击了哪个按钮。</p><p id="348a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这还不是我们想要的😢。</p><p id="64bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要能够“撤销”我们投票表决的内容。这就是国家发挥作用的地方。我们需要一些“真实”的来源来告诉我们应用程序的当前状态。使用vanilla，这通常是通过将数据存储在DOM本身来实现的，通常作为一个类。那么，为什么不呢？</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nq"><img src="../Images/6c1b6e84771c6ed950b2362eed69b08c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWIYGAq5i2OcEigJw-iPVQ.png"/></div></div></figure><p id="a3cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用类<code class="fe mj mk ml mm b">active</code>来确定按钮是否被按下，以及是否是用户当前的投票。</p><p id="b669" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果按钮的<code class="fe mj mk ml mm b">class</code>包含<code class="fe mj mk ml mm b">active</code>，那么我们知道他们在撤销他们的投票，所以我们需要把<code class="fe mj mk ml mm b">1</code>去掉。如果没有，我们知道他们还没按，我们就加课，把<code class="fe mj mk ml mm b">1</code>加到分数上。</p><p id="57ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是拼图的第二块。当他们已经投票了，但现在选择了相反的投票，我们该如何处理？如前所述，这会导致分数相差2分。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nr"><img src="../Images/cf99deb1a5c00c2d0ec5a24e3cc3956d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13yoaGJtc96wEu39oe9UKw.png"/></div></div></figure><p id="be1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们需要另一个分支来检查对面的按钮当前是否处于活动状态。如果是，我们需要删除它的类，将添加到我们的upvote中，然后将<code class="fe mj mk ml mm b">2</code>添加到分数中。我们还需要以相反的方式对downvote按钮重复这一过程，最终我们会得到这段很长的代码。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ns"><img src="../Images/a04f345ceb8c73423120a8448ac5a0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZZQBhYVL8BJgACK5V4vjFg.png"/></div></div></figure><p id="3b8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，那有很多代码，而且是重复的。我们不能把它弄干(不要重复你的话)吗？是的。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nt"><img src="../Images/663ad8bcc93f296a92df161bc1ccc872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4UM7hbBugFaqwh1CfaTrw.png"/></div></div></figure><p id="a03a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们的全部代码，干干净净的(除了重复<code class="fe mj mk ml mm b">active</code>类)。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">普通Reddit投票用户界面</figcaption></figure><p id="fb3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能想知道这有什么不好。许多软件开发人员认为这种被称为<strong class="ka ir">命令式编程</strong>的方法远不如它的表亲<strong class="ka ir">声明式编程</strong>。这些看起来像是花哨的术语，但实际上并非如此:</p><ul class=""><li id="3936" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated"><strong class="ka ir">命令式编程</strong>:如何用涉及到的步骤做一些事情。</li><li id="318f" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir">声明式编程</strong>:某样东西应该是什么或者做什么。这些步骤被抽象掉了。</li></ul><p id="c59b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，我们的方法属于前一类，因为我们必须在用户与按钮交互时手动更新DOM元素，以反映这些变化。这是一个循序渐进的过程，涉及大量的人工检查和分配。这种类型的编程会导致更多的错误，因为有更多的工作要做。</p><p id="85fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们可以说，“当某些变量是这些值时，我们希望UI看起来像这样”，这不是很好吗？您已经用CSS做到了这一点。</p><pre class="mb mc md me gt nw mm nx ny aw nz bi"><span id="0c76" class="nd ky iq mm b gy oa ob l oc od">transition: opacity 0.5s;</span></pre><p id="419d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你所需要做的就是声明你想让元素的不透明度属性在它改变值的时候转换半秒钟。就像那样，它工作了。你不需要用某种补间算法和<code class="fe mj mk ml mm b">requestAnimationFrame</code>来手动更新不透明度。浏览器为你做了所有艰苦的工作，你不需要担心任何事情(除了有浏览器错误的时候，可悲的是这些年已经有很多了)。</p><h1 id="1711" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">反应，Vue，Hyperapp等。</h1><p id="9039" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">回到这些事情上。他们如何使我们的代码更具声明性，这样我们在更新数据时就不需要接触DOM了？了解API🤓。</p><p id="9ba5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在每一个中，都有四个基本概念被它们的API所掩盖:</p><ul class=""><li id="d6be" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated"><strong class="ka ir">状态</strong>:包含我们app的数据/内存/原始信息的对象。</li><li id="fb3f" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir">动作</strong>:更新状态的函数或方法。</li><li id="3f3e" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir">视图:</strong>呈现给用户的状态的UI或可视化表示。</li><li id="44ae" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir"> DOM生命周期:</strong>我们的应用程序被挂载到DOM，当用户与应用程序交互时，元素会发生变化(创建、更新、销毁)。每当状态改变时，视图就会更新，DOM也需要改变来反映它。</li></ul><p id="0c62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经有了这些核心概念，让我们直接进入投票UI的React版本，因为根据npm下载量，这是最受欢迎的。</p><h1 id="0f66" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">反应</h1><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oe"><img src="../Images/ecd9d5dd1b7bd1bbe37a6ef451c8b9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfQdbgDik0JPs4d2uTXzbQ.png"/></div></div></figure><p id="38e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导入必要的React模块后，我们创建一个类并初始化组件的状态。</p><ul class=""><li id="3e92" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated"><code class="fe mj mk ml mm b">vote</code>是用户当前的投票。<code class="fe mj mk ml mm b">0</code>无票，<code class="fe mj mk ml mm b">-1</code>投反对票，<code class="fe mj mk ml mm b">1</code>投赞成票。</li><li id="a4d6" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><code class="fe mj mk ml mm b">score</code>是帖子的配乐。</li></ul><p id="8601" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在有了一个表示应用程序的状态对象，但是我们没有办法向用户显示它。让我们使用React组件的<code class="fe mj mk ml mm b">render()</code>方法。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi of"><img src="../Images/cf3fd85938e935f0f59818a9775221eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIcUUtKOvGNRqKWM9Vj27w.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">进行析构是为了最小化演示的线宽，这并不是真正必要的。</figcaption></figure><p id="261f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React有一些特性，比如在JavaScript中使用类似HTML的语法，称为JSX，并使用DOM属性名，如<code class="fe mj mk ml mm b">className</code>而不是<code class="fe mj mk ml mm b">class</code>。这是因为那些小小的HTML标签实际上是伪装的JavaScript🤡。现在，您不需要知道为什么，我们稍后会谈到这一点。</p><p id="234c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可能看起来有点奇怪:</p><p id="e46c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">className={vote === 1 ? 'active' : undefined}</code></p><p id="1502" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它包含了一个重要的概念:基于状态，按钮的<code class="fe mj mk ml mm b">class</code>是一些字符串。我们使用一个三元运算符，如果用户的投票与按钮匹配，那么这个类就是<code class="fe mj mk ml mm b">'active'</code>，或者根本没有类，因为它的值是<code class="fe mj mk ml mm b">undefined</code>。这是声明性的，因为我们描述的是基于状态的类，而不是如何手动更新它。</p><p id="bf28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，一旦我们将组件安装到DOM中，这样我们就可以实际看到它了，我们将会看到熟悉的景象。除了什么也没发生，因为我们没有互动！我们还没有向按钮添加事件监听器，当用户按下按钮时，事件监听器会改变按钮的状态，这是关键所在。</p><p id="3b25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要在React中添加一个事件监听器，您可以在我们的sneaky HTML元素上使用一个属性，其形式为<code class="fe mj mk ml mm b">onEvent</code>。在我们的例子中，我们关心的是<code class="fe mj mk ml mm b">click</code>，所以我们想要<code class="fe mj mk ml mm b">onClick</code>。这是语义上的，所以它是这样写的，“在[用户]点击时，运行这个功能来做一些事情”。在我们的例子中,“某物”是一个改变投票组件状态的函数，我们的UI将把它反映给用户。</p><p id="897a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要给我们的组件添加一个名为<code class="fe mj mk ml mm b">vote()</code>的方法，这是一个很好的描述正在发生什么的动词。我们应该将一个<code class="fe mj mk ml mm b">onClick</code>侦听器绑定到我们的元素，该元素将调用这个方法并传入一个值，要么是代表向上投票的<code class="fe mj mk ml mm b">1</code>，要么是代表向下投票的<code class="fe mj mk ml mm b">-1</code>。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi og"><img src="../Images/2de6d1fc0b03055e172311827eca446b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhYsRLpkjBzoPHkRIDo8uw.png"/></div></div></figure><p id="69a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更新状态，反过来总是更新UI，我们使用了一个继承自<code class="fe mj mk ml mm b">React.Component</code>的方法，名为<code class="fe mj mk ml mm b">setState()</code>(这就是我们扩展组件的原因)。当我们调用这个函数并传入一个对象时，它会将其与当前状态对象合并以产生一个新的状态。在我们的例子中，我们传入一个返回新的部分状态对象的函数，因为这样访问当前状态是最可靠的。</p><h2 id="a514" class="nd ky iq bd kz ne nf dn ld ng nh dp lh kj ni nj ll kn nk nl lp kr nm nn lt no bi translated">解释逻辑</h2><p id="dc78" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">设置<code class="fe mj mk ml mm b">state.vote</code>:</p><pre class="mb mc md me gt nw mm nx ny aw nz bi"><span id="558e" class="nd ky iq mm b gy oa ob l oc od">vote: state.vote === type ? 0 : type</span></pre><p id="9fe1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe mj mk ml mm b">type</code>(我们<code class="fe mj mk ml mm b">vote()</code>方法的参数)总是<code class="fe mj mk ml mm b">1</code>(向上投票)或者<code class="fe mj mk ml mm b">-1</code>(向下投票)。而<code class="fe mj mk ml mm b">vote</code>是描述用户当前投票的状态属性，可以是三个值:<code class="fe mj mk ml mm b">0</code>如果没有投票，<code class="fe mj mk ml mm b">1</code>如果他们已经投了赞成票，以及<code class="fe mj mk ml mm b">-1</code>如果他们已经投了反对票。</p><p id="872a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到<em class="kw">当前的</em>状态，我们希望将<code class="fe mj mk ml mm b">state.vote</code>设置为一个新值。如果当前的投票与我们刚刚传递给该方法的投票相同，这意味着用户正在撤销他们的投票，因此应该将其重置回<code class="fe mj mk ml mm b">0</code>以指示他们不再拥有投票。否则，我们应该将它设置为那个值。</p><p id="0732" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过将他们的投票加到原始分数上，我们得到了分数的最终结果+他们影响分数的投票。</p><p id="0d9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这留给我们相对简洁的代码，我们的投票组件是完整的。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">React Reddit投票用户界面</figcaption></figure><h1 id="8535" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">某视频剪辑软件</h1><p id="9f5f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在转到Vue。尽管它的基本概念与React相同，但它的工作方式却有点不同。</p><p id="8129" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们已经使用React示例一步一步地介绍了这些概念，所以我将直接展示整个Vue实例。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oh"><img src="../Images/6228cec0f64fc7d905d3c51ff548324c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_PqRo8QC49MeeeloA4_JQ.png"/></div></div></figure><p id="5435" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vue不使用类语法，而是使用普通对象。在我们的例子中，我们将对象直接传递给<code class="fe mj mk ml mm b">Vue()</code>构造函数，而不是用<code class="fe mj mk ml mm b">Vue.component()</code>指定组件或使用单文件组件。不管怎样，核心意识形态保持不变。</p><ul class=""><li id="2742" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated"><code class="fe mj mk ml mm b">data</code>相当于<code class="fe mj mk ml mm b">state</code>。它包含的原始信息可以转换成漂亮的用户界面。</li><li id="e8ef" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><code class="fe mj mk ml mm b">methods</code>是一个包含用于更新数据的函数的对象。在React中，您可以将它们定义为类本身的方法。</li><li id="e6e0" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><code class="fe mj mk ml mm b">template</code>相当于<code class="fe mj mk ml mm b">render()</code>。它是UI——数据的一种表示。然而，核心的区别在于，Vue的是一个包含带有Vue插件的HTML的字符串模板，而React的实际上是伪装成HTML的JavaScript函数调用，基本上是React插件。这样做的结果是Vue使用像<code class="fe mj mk ml mm b">@</code>这样的特殊属性来添加事件监听器。在React中，JavaScript表达式放在花括号<code class="fe mj mk ml mm b">{}</code>中，而在Vue中，表达式与绑定属性<code class="fe mj mk ml mm b">:</code>一起存在，并放在属性的字符串内容中。</li><li id="adaf" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><code class="fe mj mk ml mm b">el</code>是安装应用程序的元素。这个语法比必须调用<code class="fe mj mk ml mm b">ReactDOM.render()</code>要简洁得多，但是它们服务于相同的目的。</li></ul><p id="d333" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了模板的不同，您还会注意到<code class="fe mj mk ml mm b">vote()</code>方法的不同。</p><pre class="mb mc md me gt nw mm nx ny aw nz bi"><span id="d29e" class="nd ky iq mm b gy oa ob l oc od">vote(type) {<br/>  this.voteType = this.voteType === type ? 0 : type<br/>}</span></pre><p id="c9a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它与我们的React组件基本上是相同的逻辑，只是包装在不同的涂层中。你会注意到Vue依赖于<strong class="ka ir">突变</strong>。它使用“watchers”(getter/setter)来确定对象的属性何时改变。我们没有像React那样调用一个叫做<code class="fe mj mk ml mm b">setState()</code>的特殊方法，而是直接对实例本身进行变异。</p><p id="b015" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们不能只使用<code class="fe mj mk ml mm b">vote</code>作为我们的数据属性名，因为我们的<code class="fe mj mk ml mm b">vote()</code>方法在实例的名称空间中占用了它。Vue将所有数据属性和方法都放在实例的同一个顶级名称空间中。这其实没什么大不了的，但这仍然是一个你需要注意的名称冲突。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Vue Reddit投票用户界面</figcaption></figure><h1 id="38e5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">超app</h1><p id="6007" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最后但同样重要的是。(我知道还有很多其他的，但这一个值得关注)。</p><p id="1263" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Hyperapp是一个新的SPA框架，其第一个版本于2017年初发布。与React (2013)和Vue (2014)相比，它相当新，还没有获得那么多的社区关注。但是对于寻求漂亮的API和简洁的软件开发体验的人来说，Hyperapp是构建web应用程序的最佳体验之一。</p><p id="3b87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Hyperapp的核心是一种功能性的、几乎纯粹的构建web应用程序的方法。没有有状态或类组件——它们没有自己的本地状态(它们像React的功能组件一样工作)。应用程序的整个状态由一个普通的JavaScript对象描述，在整个应用程序中全局表示。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oi"><img src="../Images/c3df229635d48f4429f658af4cf7ef4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2KNyWIUGxv1UkPlKghrn1A.png"/></div></div></figure><p id="8552" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再一次，Reddit投票UI的逻辑基本上是一样的，只是裹上了一层新的油漆。</p><p id="d7e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序的状态和用来更新它的动作都是普通的JavaScript对象。视图是一个接收状态和关联动作的函数(调用它们会导致视图更新)。因此，没有使用在作用域之外定义的变量。</p><p id="914f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该视图使用了React之类的JSX，但试图通过偏爱<code class="fe mj mk ml mm b">class</code>而不是<code class="fe mj mk ml mm b">className</code>、<code class="fe mj mk ml mm b">onclick</code>而不是<code class="fe mj mk ml mm b">onClick</code>等来更接近实际的HTML。虽然像React一样，JSX实际上并不是必需的，但通常更受欢迎，因为React比<code class="fe mj mk ml mm b">React.createElement()</code>更推崇它。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Hyperapp Reddit投票用户界面</figcaption></figure><h2 id="a3eb" class="nd ky iq bd kz ne nf dn ld ng nh dp lh kj ni nj ll kn nk nl lp kr nm nn lt no bi translated">全局与本地状态</h2><p id="e45c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">与React和Vue不同，Hyperapp中没有“本地状态”的概念。它是全局状态驱动的:你不能创建一个组件的多个实例，它们都有自己的封装数据。</p><p id="dc2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Hyperapp避免了这种隐藏状态。它希望应用程序中的所有内容都清晰可见。它通过使用全局状态来实现这一点。这有两个后果:</p><ul class=""><li id="7b1d" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated"><strong class="ka ir">全知视图</strong>:视图中任何地方的组件在任何给定时间都知道应用程序状态的任何部分。组件之间的状态通信没有问题，因为它们都有相同的知识。</li><li id="5104" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir">状态驱动:</strong>在React和Vue中，你通常只需在应用程序中的任何地方放置一个组件，它就会因为本地状态而工作。在Hyperapp中，在将组件放到某个地方之前，您需要确保在全局状态中定义了它的状态。</li></ul><h1 id="2045" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><ul class=""><li id="a696" class="mp mq iq ka b kb lv kf lw kj oj kn ok kr ol kv mu mv mw mx bi translated">普通技术涉及预先存在的元素或SSR元素，这些元素由JavaScript选择，并被赋予“钩子”(事件监听器)以进行反应。元素被强制更新以匹配新的状态，状态存储在DOM本身中。另一种方法是使用普通JS创建元素，拥有一个状态对象等，但是您很快就会意识到使用<code class="fe mj mk ml mm b">Element.append()</code>构建视图是冗长的，并且您会失去所有声明性的好处。</li><li id="7e24" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">React，Vue和Hyperapp都有一个相似的思想:状态驱动的应用程序，当状态改变时，UI由库自动有效地更新。不再需要强制操作DOM元素来匹配状态。</li><li id="31e6" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">React和Hyperapp有相似之处，比如使用普通的JavaScript(函数调用，通常用JSX)来构造视图。这给了您JavaScript表达式和逻辑的全部自由。另一方面，Vue选择了自己的模板语言，使用HTML模板中的指令来决定视图应该是什么样子，这让初学者感觉更传统、更容易理解。</li><li id="c61e" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">React和Hyperapp鼓励不变性，而Vue鼓励突变。众所周知，不可变操作比可变操作更可靠，导致的错误也更少，所以这是Vue最大的缺陷之一。尤其是新手，当他们的视图似乎没有更新时，可能会花几个小时挠头。</li><li id="e6fc" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">React和Vue允许本地状态——封装的数据不影响其他组件实例，并对其他组件隐藏。另一方面，Hyperapp只有代表整个视图的全局状态。使用这种方法，状态管理变得更加容易，但是当需要更新单个项目的状态时，您可能会发现管理列表之类的东西很困难。</li></ul></div></div>    
</body>
</html>