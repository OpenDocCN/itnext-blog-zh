<html>
<head>
<title>React/Redux Integration Tests with Jest &amp; Enzyme</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest &amp; Enzyme进行React/Redux集成测试</h1>
<blockquote>原文：<a href="https://itnext.io/react-redux-integration-tests-with-jest-enzyme-df9aa6effd13?source=collection_archive---------0-----------------------#2019-06-12">https://itnext.io/react-redux-integration-tests-with-jest-enzyme-df9aa6effd13?source=collection_archive---------0-----------------------#2019-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5ebb1a2ec37d4537e386d65ad9b181a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t9DlG8XRRquSbzGl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@realaxer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">田宽</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="b949" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">我们到底为什么要写测试呢？</h1><p id="3a36" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我写测试是因为我想对两件事有信心:</p><ol class=""><li id="3d03" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">我没有违反任何现有的准则。(拯救现有的测试)。</li><li id="a48f" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">我的新代码能正常工作。(与新特性一起编写的新测试是我在这里的保证)。</li></ol><p id="c4d1" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">哪种类型的测试让我们最有信心/最划算？</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="8673" class="kd ke iq bd kf kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la bi translated">测试类型</h1><p id="76f5" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有许多不同类型的测试，但主要是端到端、集成和单元测试。</p><p id="40c3" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">端到端</strong> —在浏览器中全面测试用户流量。</p><ul class=""><li id="5d78" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly ne mh mi mj bi translated">这些测试由最小的模拟组成(也就是说——您实际上正在构建用户将要使用的所有服务)。</li></ul><p id="823a" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">集成</strong> —测试多个服务/组件之间的交互。</p><ul class=""><li id="8afe" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly ne mh mi mj bi translated">“集成测试”是一个臃肿且经常含糊不清的术语。例如，设置一个测试来验证多个服务(例如，一个api和一个数据库)之间的交互，其开销接近于编写一个完整的E2E测试。另一方面，编写一个多个react组件在redux环境中一起工作的测试，其复杂性更接近于单元测试。请继续阅读，找出原因；)</li></ul><p id="fa08" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">单元</strong> —单独测试单个部件/功能。</p><ul class=""><li id="d895" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly ne mh mi mj bi translated">单元测试本质上是测试输入和输出。没有比这更容易推理的了。</li></ul><p id="05df" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">一些其他类型的测试:</p><p id="e564" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">手动</strong> —一个人在真实设备上实际经历和验证一个流程。</p><p id="3f17" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">快照</strong> —验证组件的渲染输出。</p><p id="8448" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">静态</strong> —测试预编译时(<a class="ae kc" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>，<a class="ae kc" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>)</p><p id="530d" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">跨浏览器/可视化回归</strong> — Jest在node中运行，使用jsdom，模拟一个dom环境，就好像你在浏览器中一样。有很多方法可以测试代码在真正的浏览器中运行，但是大多数跨浏览器JS的问题已经成为过去，因为我们使用了现代的框架和transpilers，比如Babel。CSS是一个不同的故事，像saucelabs这样的服务允许你测试布局在多种浏览器中是否好看。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="1342" class="kd ke iq bd kf kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la bi translated">决定选择哪种测试时要考虑的事情</h1><p id="1dcb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">单位→→→→→集成→ → → → →E2E</p><p id="74c8" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">潜在故障点</strong>:小→ → → →大</p><ul class=""><li id="ea6f" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly ne mh mi mj bi translated">当一个单元测试失败时，你确切地知道去哪里找。当使用E2E测试结账流程时，有许多不同的服务可能会产生错误。</li></ul><p id="aae8" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">工程时间</strong>:最小值→ → → →最大值</p><ul class=""><li id="224e" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly ne mh mi mj bi translated">与确保util功能正常工作相比，确保跨多个回购的E2E测试在CI中有效工作需要更多的时间。</li></ul><p id="e157" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">成本</strong>:最小→ → → →最大</p><ul class=""><li id="020f" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly ne mh mi mj bi translated">有一个与E2E测试相关的实际金额(例如——saucelabs、circleci parallelism等)。</li></ul><p id="e3c0" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">速度</strong>:小→ → → →大</p><ul class=""><li id="6088" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly ne mh mi mj bi translated">构建一系列服务需要时间。验证add(2，2) === 4不会。</li></ul><p id="7dd4" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">如果这就是我们要考虑的全部，那么单元测试无疑是我们要走的路。然而，还有一些其他的东西要看。</p><p id="2202" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">测试代码</strong>:最小值→ → → →最大值</p><ul class=""><li id="aa58" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly ne mh mi mj bi translated">从本质上来说，单元测试只是测试一件事情。本质上，E2E测试就是测试特定流中的所有东西。</li></ul><p id="9f32" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">所需测试次数</strong>:最大值→ → → →最小值</p><ul class=""><li id="77a4" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly ne mh mi mj bi translated">如果你试图努力获得大量的代码覆盖率，即使是一个小的应用程序，那么你将不得不编写大量的单元测试。另一方面，一些E2E测试可能就是你所需要的，你可以确信你的主流工作正常。</li></ul><p id="666f" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">置信度</strong>:最小值→ → → →最大值</p><ul class=""><li id="acf3" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly ne mh mi mj bi translated">最后也是最重要的要考虑的是自信。我可以100%确信，我的单元测试验证了我的util库运行良好。然而，如果我不测试它在我自己的应用程序中是如何使用的，这基本上没有任何意义。</li></ul></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="7e93" class="kd ke iq bd kf kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la bi translated">集成测试</h1><p id="d27b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">正如我们已经看到的，每种类型的测试都有许多权衡。关键是最大化你的自信水平，同时最小化所有其他不利因素。出于这个原因，集成测试是一个很好的妥协。<em class="nf">尤其是</em>测试独立前端应用时。</p><p id="31a0" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">那么如何入门呢？</p><p id="43e1" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">我记得当我在2015年左右第一次开始学习测试React &amp; Redux应用程序时。我谷歌了一下，最后上了redux官方网站。这是我看到的:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/9148a2f6c6668092452b22e3e00bd209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YPqLEe-2b0-ntXRPGxlPw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">测试redux操作</figcaption></figure><p id="dfdf" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">我想，“好吧！我明白了。爽！”所以我开始为大约20个不同的动作编写这样的测试。在编写完每个测试之后，我会激活测试运行程序，并看到一个绿色的复选标记。令人上瘾。这也毫无意义。</p><p id="cbaf" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">上面的测试基本上是验证一个对象的属性没有改变。但是如果你把那个键改成<code class="fe nl nm nn no b">textContent</code>而不是<code class="fe nl nm nn no b">text</code>呢？假设您在任何地方都更新了它，应用程序正常工作——但是您忘记了更新您的测试，您的测试失败了。当你重构和测试中断时，假设你的应用程序真的工作，这意味着你正在测试<em class="nf">实现细节。</em></p><p id="bec4" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">让我们看另一个例子。在写这篇文章的时候，我搜索了“用Jest和Enzyme测试React组件”,在google的首页上找到了一篇文章，上面有数千个包含这个片段的掌声:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/e2f76c3e21709433d52f2d3c592741b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3NZOTmuEIqcKLGCpUUKWg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">测试道具</figcaption></figure><p id="1014" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">这个测试本质上是测试React。我们不需要测试当我们给一个组件一个叫做<em class="nf"> x </em>的道具时，它确实有一个叫做<em class="nf"> x </em>的道具。</p><p id="517d" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">旁注——测试API和测试应用程序之间有很大的区别。当测试一个API时，比方说一个共享的组件库，你<em class="nf">应该</em>测试像prop名称这样的内部组件，因为你不知道你的库将如何被使用，你想确保一个名为<em class="nf"> x </em>的prop是产生预期结果的prop。</p><p id="e801" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">但是我假设95%以上的人在谷歌上搜索“用Jest和Enzyme测试React组件”是在测试应用程序，你的测试越接近你的软件实际使用的方式，他们就会给你越多的信心。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="237e" class="kd ke iq bd kf kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la bi translated">演示应用程序</h1><p id="221f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">请随意跟随github 上的<a class="ae kc" href="https://github.com/qaiken/react-redux-integration-tests" rel="noopener ugc nofollow" target="_blank">代码。</a></p><p id="1732" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">这是一个非常愚蠢的应用程序。</p><p id="9cd2" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">当你启动并运行应用程序后，你可以导航到<code class="fe nl nm nn no b">/choose-your-pokemon</code>，看到一个类似这样的屏幕:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/56406cb49786b47ddeffe68dff5125a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2D1YjZNhiWuoAReozkTMQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">史上最佳应用</figcaption></figure><p id="65ea" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">当你点击按钮时，你将被重定向到<code class="fe nl nm nn no b">/selected</code>，并为你选择一个随机的口袋妖怪。</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/48d30842ee2f27903a3bd3251f689159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*TFWUmJXl0UQqxuRjEXFPXg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">皮德格托！</figcaption></figure><p id="332a" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">如果刷新页面，您将被重定向到主页。</p><p id="0a44" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">就像我说的，一个很傻的应用。</p><p id="849a" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">那么应该测试什么呢？大概是:</p><ol class=""><li id="1e85" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">当我们导航到<code class="fe nl nm nn no b">/choose-your-pokemon</code>时，我们可以点击一个按钮，得到一个口袋妖怪。</li><li id="a45a" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">当我们在<code class="fe nl nm nn no b">/selected</code>刷新页面时，我们没有选择口袋妖怪，我们被重定向到主页。</li></ol><p id="96d5" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">如果这两个测试都通过了，那么我对这个应用程序非常有信心。</p><p id="6634" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">为了做到这一点，我编写了2个集成测试和3个快照测试，并获得了100%的测试覆盖率。</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/bed3a95635346ffe7db20f4eaf24c087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECrbQb9geqNdDWKYqKASCg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">测试覆盖率</figcaption></figure><p id="32db" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">我所有的路线、动作、减速器和组件都在短短几个测试中得到了测试。</p><p id="6989" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">旁注——争取100%的测试覆盖率是一场失败的游戏。如果你对你的测试覆盖率有信心，当它达到70%的时候，那就这样吧。当你的主要目标变成增加测试覆盖率时，你很可能会开始花时间测试那些并不真正需要测试的东西，这些东西给你的回报是递减的。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="0c9b" class="kd ke iq bd kf kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la bi translated">测试工具</h1><p id="5f33" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们从分解<code class="fe nl nm nn no b">/test-utils</code>开始</p><p id="fbf9" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">makemountdrender—</strong>一个接受组件和一些默认属性的实用函数。我们返回一个函数，这样我们就可以根据需要覆盖默认的属性。这个函数使用<a class="ae kc" href="https://airbnb.io/enzyme/docs/api/ReactWrapper/mount.html" rel="noopener ugc nofollow" target="_blank">酶的挂载</a>返回一个react包装器。因为我们对集成测试感兴趣，所以我们对完整的DOM呈现感兴趣，这更接近于实际用户将如何使用应用程序。我选择<a class="ae kc" href="https://kentcdodds.com/blog/why-i-never-use-shallow-rendering" rel="noopener ugc nofollow" target="_blank">从不使用浅渲染</a>。</p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="cbae" class="nx ke iq no b gy ny nz l oa ob">import { mount } from 'enzyme';<br/></span><span id="1575" class="nx ke iq no b gy oc nz l oa ob">export const makeMountRender = (Component, defaultProps = {}) =&gt; {</span><span id="c1b3" class="nx ke iq no b gy oc nz l oa ob">  return (customProps = {}) =&gt; {</span><span id="1523" class="nx ke iq no b gy oc nz l oa ob">    const props = {</span><span id="2cb6" class="nx ke iq no b gy oc nz l oa ob">      ...defaultProps,</span><span id="6159" class="nx ke iq no b gy oc nz l oa ob">      ...customProps<br/>    };</span><span id="906f" class="nx ke iq no b gy oc nz l oa ob">    return mount(&lt;Component {...props} /&gt;);</span><span id="f952" class="nx ke iq no b gy oc nz l oa ob">  };</span><span id="b2fb" class="nx ke iq no b gy oc nz l oa ob">};</span></pre><p id="0670" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir"> makeStore </strong> —一个实用函数，用于创建一个新的redux存储。我们从实际的应用程序中导入rootReducer和createStoreWithMiddleWare函数，这使得创建用于测试目的的新存储变得容易。</p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="1a03" class="nx ke iq no b gy ny nz l oa ob">import { mergeDeepRight } from 'ramda';</span><span id="c3d2" class="nx ke iq no b gy oc nz l oa ob">import rootReducer from '../reducer';</span><span id="f28c" class="nx ke iq no b gy oc nz l oa ob">import { createStoreWithMiddleWare } from '../store';<br/></span><span id="77ed" class="nx ke iq no b gy oc nz l oa ob">export const makeStore = (customState = {}) =&gt; {</span><span id="9ab0" class="nx ke iq no b gy oc nz l oa ob">  const root = rootReducer({}, { type: '@@INIT' });</span><span id="d6ed" class="nx ke iq no b gy oc nz l oa ob">  const state = mergeDeepRight(root, customState);</span><span id="bfa5" class="nx ke iq no b gy oc nz l oa ob">  return createStoreWithMiddleWare(rootReducer, state);</span><span id="448a" class="nx ke iq no b gy oc nz l oa ob">};</span></pre><p id="af26" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir"> reduxify </strong> —一个util函数获取一个组件、props和一个初始redux状态，并返回一个新的react组件，该组件在redux环境中呈现传入的组件。</p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="2275" class="nx ke iq no b gy ny nz l oa ob">import { ConnectedRouter } from 'connected-react-router';</span><span id="77df" class="nx ke iq no b gy oc nz l oa ob">import React from 'react';</span><span id="2054" class="nx ke iq no b gy oc nz l oa ob">import { Provider } from 'react-redux';</span><span id="659a" class="nx ke iq no b gy oc nz l oa ob">import history from '../history';<br/></span><span id="f5f1" class="nx ke iq no b gy oc nz l oa ob">export const reduxify = (Component, props = {}, state = {}) =&gt; {</span><span id="c2ec" class="nx ke iq no b gy oc nz l oa ob">  return function reduxWrap() {</span><span id="56fe" class="nx ke iq no b gy oc nz l oa ob">    return (</span><span id="9ee3" class="nx ke iq no b gy oc nz l oa ob">      &lt;Provider store={makeStore(state)}&gt;</span><span id="2418" class="nx ke iq no b gy oc nz l oa ob">        &lt;ConnectedRouter history={history}&gt;</span><span id="b390" class="nx ke iq no b gy oc nz l oa ob">          &lt;Component {...props} /&gt;</span><span id="aa3b" class="nx ke iq no b gy oc nz l oa ob">        &lt;/ConnectedRouter&gt;</span><span id="7fa5" class="nx ke iq no b gy oc nz l oa ob">      &lt;/Provider&gt;</span><span id="321d" class="nx ke iq no b gy oc nz l oa ob">    );</span><span id="bbe5" class="nx ke iq no b gy oc nz l oa ob">  }</span><span id="b4bc" class="nx ke iq no b gy oc nz l oa ob">};</span></pre><p id="79f1" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir"> snapshotify </strong> —一个util函数，它接受一个enzyme react包装器，并调用它的<a class="ae kc" href="https://airbnb.io/enzyme/docs/api/ReactWrapper/html.html" rel="noopener ugc nofollow" target="_blank"> html方法</a>，返回一个html字符串。</p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="92cc" class="nx ke iq no b gy ny nz l oa ob">export const snapshotify = reactWrapper =&gt; {</span><span id="1b29" class="nx ke iq no b gy oc nz l oa ob">  return reactWrapper.html();</span><span id="123d" class="nx ke iq no b gy oc nz l oa ob">};</span></pre><p id="db4a" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">快照测试不应该测试实现细节。这个util函数做的不多，但是它抽象了html调用，并提醒我们快照测试应该返回HTML。</p><p id="eefa" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">如果我们使用<a class="ae kc" href="https://www.npmjs.com/package/jest-serializer-html" rel="noopener ugc nofollow" target="_blank"> jest-serializer-html </a>，那么我们最终会得到漂亮的快照:</p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="6766" class="nx ke iq no b gy ny nz l oa ob">exports[`&lt;ChooseYourPokemon /&gt; matches snapshot 1`] = `<br/>&lt;div&gt;<br/>  &lt;p&gt;<br/>    Pokem ipsum dolor sit amet Mime Jr Mime Jr Watchog Nidoran Professor Oak Pichu. Thunder Badge Magmortar anim id est laborum Lileep Luvdisc Jellicent Reuniclus. Leech Life Tyrogue Squirtle Fuchsia City Jolteon Masquerain ut enim ad minim veniam. Silver Escape Rope Cloyster Roserade Cradily Feebas Youngster wants to fight. Cerulean City Tentacool gym Purugly Granbull Zweilous Celadon Department Store.<br/>  &lt;/p&gt;<br/>  &lt;button data-test-id="choose-pokemon"&gt;<br/>    Choose!<br/>  &lt;/button&gt;<br/>&lt;/div&gt;<br/>`;</span></pre><p id="68e7" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">下面是一个<em class="nf">坏</em>快照的示例:</p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="c2fe" class="nx ke iq no b gy ny nz l oa ob">exports[`&lt;ChooseYourPokemon /&gt; matches snapshot 1`] = `<br/>&lt;Provider<br/>  store={<br/>    Object {<br/>      "dispatch": [Function],<br/>      "getState": [Function],<br/>      "replaceReducer": [Function],<br/>      "subscribe": [Function],<br/>      Symbol(observable): [Function],<br/>    }<br/>  }<br/>&gt;<br/>  &lt;Connect(ConnectedRouterWithContext)<br/>    history={<br/>      Object {<br/>        "action": "POP",<br/>        "block": [Function],<br/>        "createHref": [Function],<br/>        "go": [Function],<br/>        "goBack": [Function],<br/>        "goForward": [Function],<br/>        "length": 1,<br/>        "listen": [Function],<br/>        "location": Object {<br/>          "hash": "",<br/>          "pathname": "/",<br/>          "search": "",<br/>          "state": undefined,<br/>        },<br/>        "push": [Function],<br/>        "replace": [Function],<br/>      }<br/>    }<br/>  &gt;<br/>    &lt;Connect(ChooseYourPokemon) /&gt;<br/>  &lt;/Connect(ConnectedRouterWithContext)&gt;<br/>&lt;/Provider&gt;<br/>`;</span></pre><p id="cfd5" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">这是一个极端的例子，也是一个非常糟糕的快照，但却是一个很好的例子。</p><p id="7125" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">实际的快照测试如下所示:</p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="a7b3" class="nx ke iq no b gy ny nz l oa ob">import { makeMountRender, reduxify, snapshotify } from '../../test-utils';</span><span id="d817" class="nx ke iq no b gy oc nz l oa ob">import ChooseYourPokemon from './';<br/></span><span id="ef6e" class="nx ke iq no b gy oc nz l oa ob">it('matches snapshot', function() {</span><span id="b2c3" class="nx ke iq no b gy oc nz l oa ob">  const wrapper = makeMountRender(reduxify(ChooseYourPokemon))();</span><span id="d53c" class="nx ke iq no b gy oc nz l oa ob">  expect(snapshotify(wrapper)).toMatchSnapshot();</span><span id="4cf2" class="nx ke iq no b gy oc nz l oa ob">});</span></pre><p id="5619" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">我们将组件传递给<strong class="ld ir"> reduxify </strong>，然后将它传递给<strong class="ld ir">makemountdrender，</strong>调用它。结果是一个可以传递给<strong class="ld ir"> snapshotify </strong>的酶反应包装器。</p><p id="a7a6" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">为了生成第二个快照，我所做的只是将<strong class="ld ir">makemountdrender</strong>改为使用<a class="ae kc" href="https://airbnb.io/enzyme/docs/api/ShallowWrapper/shallow.html" rel="noopener ugc nofollow" target="_blank"> enzyme的shallow </a>，并将<strong class="ld ir"> snapshotify </strong>改为返回传入的react包装器。</p><p id="3c2b" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">如果您的快照包含了props和component名称，那么当您更改或重构它们时，您的测试将会中断，即使您可能已经在任何地方正确地更新了它们。你在测试<em class="nf">实现细节</em>。实际呈现的HTML是我们感兴趣的。这样，您可以根据自己的意愿重构组件树，并且您的测试仍然会通过。</p><p id="ffd4" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">模仿器</strong> —一个util函数，它接受api模仿并返回一个带有模仿API调用的方法的对象。我使用的是<a class="ae kc" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>和<a class="ae kc" href="https://github.com/ctimmerm/axios-mock-adapter" rel="noopener ugc nofollow" target="_blank"> axios-mock-adapter </a>，但是还有很多其他的。</p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="434e" class="nx ke iq no b gy ny nz l oa ob">export const mockData = {</span><span id="7c75" class="nx ke iq no b gy oc nz l oa ob">  pokemon: {</span><span id="3b8e" class="nx ke iq no b gy oc nz l oa ob">    id: 26,</span><span id="d2fd" class="nx ke iq no b gy oc nz l oa ob">    species: { name: 'raichu' },</span><span id="826b" class="nx ke iq no b gy oc nz l oa ob">    sprites: {</span><span id="e2a9" class="nx ke iq no b gy oc nz l oa ob">      front_default: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/26.png'</span><span id="3123" class="nx ke iq no b gy oc nz l oa ob">    }</span><span id="98f6" class="nx ke iq no b gy oc nz l oa ob">  }</span><span id="584c" class="nx ke iq no b gy oc nz l oa ob">};<br/></span><span id="0145" class="nx ke iq no b gy oc nz l oa ob">export const mocker = apiMock =&gt; ({</span><span id="d76c" class="nx ke iq no b gy oc nz l oa ob">  fetchRandomPokemon() {</span><span id="fb58" class="nx ke iq no b gy oc nz l oa ob">    apiMock</span><span id="f408" class="nx ke iq no b gy oc nz l oa ob">      .onGet(/https:\/\/pokeapi.co\/api\/v2\/pokemon\/\d+/)</span><span id="a230" class="nx ke iq no b gy oc nz l oa ob">      .reply(config =&gt; {</span><span id="4c32" class="nx ke iq no b gy oc nz l oa ob">        const numberCheck = RegExp(/pokemon\/(\d+)/);</span><span id="d32d" class="nx ke iq no b gy oc nz l oa ob">        const pokemonInt = Number(numberCheck.exec(config.url)[1]);</span><span id="8ec6" class="nx ke iq no b gy oc nz l oa ob">        if (pokemonInt &gt; 151) {</span><span id="a8ae" class="nx ke iq no b gy oc nz l oa ob">          return [500];</span><span id="3bba" class="nx ke iq no b gy oc nz l oa ob">        }</span><span id="a4ab" class="nx ke iq no b gy oc nz l oa ob">        return [200, mockData.pokemon];</span><span id="cdcb" class="nx ke iq no b gy oc nz l oa ob">      });</span><span id="1c2b" class="nx ke iq no b gy oc nz l oa ob"><br/>    return this;</span><span id="c3fb" class="nx ke iq no b gy oc nz l oa ob">  }</span><span id="cf4a" class="nx ke iq no b gy oc nz l oa ob">});</span></pre><p id="ed5b" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">这是我们<em class="nf">唯一的</em>模拟<em class="nf">。</em></p><p id="aaf5" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir"> ticks </strong> —一个util函数，它接受一组异步执行的回调。通过这种方式，我们可以在测试中触发异步代码，然后在测试代码结束运行时将回调推送到要调用的队列。</p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="b248" class="nx ke iq no b gy ny nz l oa ob">export const ticks = (<em class="nf">callbacks</em> = []) =&gt; {</span><span id="2bc6" class="nx ke iq no b gy oc nz l oa ob">  if (callbacks.length &lt; 1) {</span><span id="8862" class="nx ke iq no b gy oc nz l oa ob">    return null;</span><span id="7e6c" class="nx ke iq no b gy oc nz l oa ob">  }<br/></span><span id="34f3" class="nx ke iq no b gy oc nz l oa ob">  setTimeout(() =&gt; {</span><span id="c26c" class="nx ke iq no b gy oc nz l oa ob">    const cb = callbacks.shift();</span><span id="3072" class="nx ke iq no b gy oc nz l oa ob">    if (cb) {</span><span id="14ea" class="nx ke iq no b gy oc nz l oa ob">      cb();</span><span id="79bf" class="nx ke iq no b gy oc nz l oa ob">    }</span><span id="b8b3" class="nx ke iq no b gy oc nz l oa ob">    ticks(callbacks);</span><span id="2933" class="nx ke iq no b gy oc nz l oa ob">  });</span><span id="9487" class="nx ke iq no b gy oc nz l oa ob">};</span></pre></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="2291" class="kd ke iq bd kf kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la bi translated">把所有的放在一起</h1><p id="87b1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们来看看其中一个集成测试，并对其进行分解！</p><p id="ebf5" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">完整的测试文件如下所示:</p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="5a82" class="nx ke iq no b gy ny nz l oa ob">import history from '../../history';</span><span id="67ad" class="nx ke iq no b gy oc nz l oa ob">import Routes from '../../Routes';</span><span id="825d" class="nx ke iq no b gy oc nz l oa ob">import apiService from '../../services/api-service';</span><span id="3510" class="nx ke iq no b gy oc nz l oa ob">import {</span><span id="84e6" class="nx ke iq no b gy oc nz l oa ob">makeMountRender,</span><span id="6db2" class="nx ke iq no b gy oc nz l oa ob">mocker,</span><span id="e20a" class="nx ke iq no b gy oc nz l oa ob">reduxify,</span><span id="7b31" class="nx ke iq no b gy oc nz l oa ob">snapshotify,</span><span id="d6da" class="nx ke iq no b gy oc nz l oa ob">ticks</span><span id="e7e2" class="nx ke iq no b gy oc nz l oa ob">} from '../../test-utils';</span><span id="8f3d" class="nx ke iq no b gy oc nz l oa ob">import ChooseYourPokemon from './';</span><span id="2cbe" class="nx ke iq no b gy oc nz l oa ob">describe('&lt;ChooseYourPokemon /&gt;', function() {</span><span id="0835" class="nx ke iq no b gy oc nz l oa ob">  const apiMock = apiService.mock();</span><span id="95a6" class="nx ke iq no b gy oc nz l oa ob">  beforeEach(() =&gt; {</span><span id="d86b" class="nx ke iq no b gy oc nz l oa ob">    mocker(apiMock).fetchRandomPokemon();</span><span id="b4d8" class="nx ke iq no b gy oc nz l oa ob">  });</span><span id="124a" class="nx ke iq no b gy oc nz l oa ob">  afterEach(() =&gt; {</span><span id="ba30" class="nx ke iq no b gy oc nz l oa ob">    apiMock.reset();</span><span id="4680" class="nx ke iq no b gy oc nz l oa ob">  });</span><span id="b24d" class="nx ke iq no b gy oc nz l oa ob">  it('matches snapshot', function() {</span><span id="36d6" class="nx ke iq no b gy oc nz l oa ob">    const wrapper = makeMountRender(reduxify(ChooseYourPokemon))();</span><span id="ded1" class="nx ke iq no b gy oc nz l oa ob">    expect(snapshotify(wrapper)).toMatchSnapshot();</span><span id="0d61" class="nx ke iq no b gy oc nz l oa ob">  });</span><span id="f26e" class="nx ke iq no b gy oc nz l oa ob">  it('allows users to select a random pokemon', function(done) {</span><span id="42e4" class="nx ke iq no b gy oc nz l oa ob">    const wrapper = makeMountRender(reduxify(Routes))();</span><span id="4fd7" class="nx ke iq no b gy oc nz l oa ob">    history.push('/choose-your-pokemon');</span><span id="24e3" class="nx ke iq no b gy oc nz l oa ob">    wrapper.update();</span><span id="9828" class="nx ke iq no b gy oc nz l oa ob">    wrapper.find(<br/>      '[data-test-id="choose-pokemon"]'<br/>    ).simulate('click');</span><span id="5613" class="nx ke iq no b gy oc nz l oa ob"><br/>    ticks([</span><span id="69a3" class="nx ke iq no b gy oc nz l oa ob">      () =&gt; {</span><span id="cc6b" class="nx ke iq no b gy oc nz l oa ob">        wrapper.update();</span><span id="ca6e" class="nx ke iq no b gy oc nz l oa ob">        expect(<br/>          window.location.href<br/>        ).toBe('http://localhost/selected');</span><span id="33dd" class="nx ke iq no b gy oc nz l oa ob">        expect(snapshotify(wrapper)).toMatchSnapshot();</span><span id="9c99" class="nx ke iq no b gy oc nz l oa ob">        done();</span><span id="ccf2" class="nx ke iq no b gy oc nz l oa ob">      }</span><span id="af39" class="nx ke iq no b gy oc nz l oa ob">    ]);</span><span id="1eaa" class="nx ke iq no b gy oc nz l oa ob">  });</span><span id="0536" class="nx ke iq no b gy oc nz l oa ob">});</span></pre><p id="00a4" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">模仿API调用</strong></p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="1971" class="nx ke iq no b gy ny nz l oa ob">const apiMock = apiService.mock();</span><span id="1c99" class="nx ke iq no b gy oc nz l oa ob">beforeEach(() =&gt; {</span><span id="a960" class="nx ke iq no b gy oc nz l oa ob">  mocker(apiMock).fetchRandomPokemon();</span><span id="477a" class="nx ke iq no b gy oc nz l oa ob">});</span><span id="78aa" class="nx ke iq no b gy oc nz l oa ob">afterEach(() =&gt; {</span><span id="de4b" class="nx ke iq no b gy oc nz l oa ob">  apiMock.reset();</span><span id="de81" class="nx ke iq no b gy oc nz l oa ob">});</span></pre><p id="69ad" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">在每次测试之前，我们模拟端点来获取一个口袋妖怪。每次测试后，我们重置模拟，这意味着我们重置端点被调用的次数等信息。</p><p id="87ec" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">我们已经看过快照测试，接下来让我们看看集成测试。</p><p id="3f7d" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir">集成测试</strong></p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="3441" class="nx ke iq no b gy ny nz l oa ob">const wrapper = makeMountRender(reduxify(Routes))();</span><span id="960f" class="nx ke iq no b gy oc nz l oa ob">history.push('/choose-your-pokemon');</span><span id="7ef9" class="nx ke iq no b gy oc nz l oa ob">wrapper.update();</span><span id="4003" class="nx ke iq no b gy oc nz l oa ob">wrapper.find(<br/>  '[data-test-id="choose-pokemon"]'<br/>).simulate('click');</span></pre><p id="fc67" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">首先，我们将应用程序路径的子集传递给<strong class="ld ir"> reduxify </strong>和<strong class="ld ir">makemountdrender</strong>。</p><p id="29ea" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">然后我们导航到<code class="fe nl nm nn no b">/choose-your-pokemon</code>。</p><p id="2967" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">然后，我们用<a class="ae kc" href="https://airbnb.io/enzyme/docs/api/ReactWrapper/update.html" rel="noopener ugc nofollow" target="_blank"> enzyme的更新</a>重新渲染react包装器，因为我们导航到了不同的路线。</p><p id="7c12" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">我们找到按钮(使用<code class="fe nl nm nn no b">data-test-*</code>属性为我们的选择器提供上下文，并将它们与CSS或JS变化隔离开),然后单击它。这触发了一个API调用，所以我们需要使用我们的<strong class="ld ir"> ticks </strong> util函数来等待，直到模拟出的异步代码完成。</p><pre class="nh ni nj nk gt nt no nu nv aw nw bi"><span id="5c75" class="nx ke iq no b gy ny nz l oa ob">ticks([</span><span id="423c" class="nx ke iq no b gy oc nz l oa ob">  () =&gt; {</span><span id="ba58" class="nx ke iq no b gy oc nz l oa ob">    wrapper.update();</span><span id="666c" class="nx ke iq no b gy oc nz l oa ob">    expect(<br/>      window.location.href<br/>    ).toBe('http://localhost/selected');</span><span id="ef93" class="nx ke iq no b gy oc nz l oa ob">    expect(snapshotify(wrapper)).toMatchSnapshot();</span><span id="bd27" class="nx ke iq no b gy oc nz l oa ob">    done();</span><span id="a3a9" class="nx ke iq no b gy oc nz l oa ob">  }</span><span id="c3f7" class="nx ke iq no b gy oc nz l oa ob">]);</span></pre><p id="6cc2" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">这个函数将在我们的API回调解析后执行。因此，我们然后重新呈现react包装器，并确保我们的路由已经改变。然后，我们验证我们的快照看起来像预期的那样(我们确保我们看到呈现的HTML声明我们得到了模拟API调用返回的pokemon)。</p><p id="79e9" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">这个单一测试测试我们的商店，减速器，行动，路线，选择器和我们的组件。像这样的测试可以让我们很快获得信心，我们的应用程序正在工作，因为他们测试了这么多的代码，而且编写起来非常简单有趣。不再测试每个单独的动作创建者。</p><p id="6c65" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">有问题吗？评论？在推特上联系我！</p><p id="a390" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">附注——我发布了一个关于<a class="ae kc" href="https://quintonaiken.gumroad.com/l/developing-a-technical-interview-mindset" rel="noopener ugc nofollow" target="_blank">掌握技术面试</a>的课程。看看吧！</p></div></div>    
</body>
</html>