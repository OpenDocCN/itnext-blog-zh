<html>
<head>
<title>Exploring the Go language as a medium for creative programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索作为创造性编程媒介的Go语言</h1>
<blockquote>原文：<a href="https://itnext.io/exploring-the-go-language-as-a-medium-for-creative-programming-ef0fd4372b61?source=collection_archive---------0-----------------------#2022-07-07">https://itnext.io/exploring-the-go-language-as-a-medium-for-creative-programming-ef0fd4372b61?source=collection_archive---------0-----------------------#2022-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c8bb965d5d30182166671e5950a379b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Az0On_t-W6N1BI8ririnJg.png"/></div></div></figure><p id="cdb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">他的文章是关于探索Go语言及其在生成性和创造性编码、可视化编程、web汇编、人脸检测和图像处理等领域的能力，这些领域对于普通的Go开发者来说可能看起来很奇怪或不寻常；考虑到大多数Go开发人员选择使用这种语言是因为它的简单性、对并发原语的广泛支持，这些因素使得它对于云计算和DevOps相关的工作非常方便。这些都是围棋擅长的领域，但我们正试图证明相反的情况，即。这种语言可以作为一种通用语言使用，也可能吸引有创造力的头脑，尽管围绕它构建的有限的创造性框架和库可能需要更多的工作和毅力。</p><p id="c15d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将是非常技术性的写作，这意味着除了了解Go语言之外，还需要了解一些HTML5 Canvas API，一些Webassembly概念，以及最基本的Javascript知识。在此过程中，我们将展示一些实时演示，并附有一些代码摘录，以便更好地理解。所以让我们开始吧。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h2 id="92e4" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated"><strong class="ak">在Go中使用web assembly</strong></h2><p id="47a0" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">作为<a class="ae mk" href="https://github.com/esimov/pigo" rel="noopener ugc nofollow" target="_blank"> Pigo </a>计算机视觉库的作者，我需要证明它的实时能力，但不幸的是，围棋生态系统缺少一个用于访问网络摄像头的跨平台库。还有<a class="ae mk" href="https://gocv.io/" rel="noopener ugc nofollow" target="_blank"> GoCV </a>，它是OpenCV的包装器，和大多数C绑定一样，它带来了不可忽视的性能代价。Pigo是100%用go编写的，基于像素强度比较的物体检测纸(<a class="ae mk" href="https://arxiv.org/pdf/1305.4537.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1305.4537.pdf</a>)，速度很快。因此，为了访问网络摄像头，我选择将其移植到Webassembly。对于不知道什么是Webassembly(缩写Wasm)的人来说，<em class="ml">它是一种基于堆栈的虚拟机的二进制指令格式。Wasm被设计为C/C++/Rust </em>等高级语言编译的可移植目标。</p><p id="1b5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于所有的现代网络浏览器已经集成了WASM，这也意味着我们可以访问网络摄像头。让我们看看如何在Go中访问它。请记住，在使用生成的wasm二进制文件之前，我们需要使用一些针对Webassembly的特定Go build指令来构建程序。一方面，在每个Go文件的顶部，我们必须提供<code class="fe mm mn mo mp b">// +build js,wasm</code> <em class="ml"> </em>指令，另一方面，在构建应用程序时，我们应该指定目标操作系统和架构。常规的构建命令应该如下所示:</p><blockquote class="mq mr ms"><p id="3084" class="jy jz ml ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated"><code class="fe mm mn mo mp b">$ GOOS=js GOARCH=wasm go build -o lib.wasm main.go</code></p></blockquote><p id="231b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简化构建过程，我们可以创建一个<em class="ml"> Makefile </em>，通过一个简单的命令，我们就可以构建wasm文件，生成一个新的web服务器，并在浏览器中运行web应用程序。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9b5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行make命令将把<code class="fe mm mn mo mp b">wasm_exec.js</code>文件从Go source目录复制到我们本地的js文件夹。这一点很重要，因为我们必须确保我们使用的是最新版本的<code class="fe mm mn mo mp b">wasm_exec.js</code>文件(当我们运行web服务器时将提供该文件)，否则，由于不同版本之间的代码变更，一些功能可能会过时。</p><p id="af7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看如何在一个简单的Webassembly程序中访问网络摄像头。由于这是一个独立的web应用程序，一些静态资产需要通过web服务器提供服务。这些静态资产中的一些是上面提到的<em class="ml"> wasm_exec.js </em>文件和生成的<em class="ml"> wasm </em>二进制文件。因此，提供这些文件就像将它们包含在静态html文件中一样简单。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f418" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，每次我们执行<em class="ml"> make </em>命令时，它都会构建wasm文件，并在特定的IP地址和端口上运行web服务器。这是示例应用程序的基本框架，但是如果您现在运行它，应该不会发生任何事情。我们需要创建主要的Go应用程序，以便有一个全功能的程序来访问网络摄像头和处理提供的原始数据。</p><p id="c0ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> main.go </strong>文件的API非常直观:我们正在创建一个新的Canvas，它在下面访问HTML5 Canvas API。一旦发现一个摄像头，我们就调用<code class="fe mm mn mo mp b">Render</code>方法，这个方法产生一个新的goroutine并运行，直到它没有被<code class="fe mm mn mo mp b">cancelAnimationFrame</code> JS方法终止。这看起来很容易，但现实要复杂一点。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c444" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我在文章的第一部分提到的，我的意图是探索Go作为创造性编程的媒介，所以给你一个关于用于WASM集成的<a class="ae mk" href="https://pkg.go.dev/syscall/js" rel="noopener ugc nofollow" target="_blank"> syscall/js </a>包的技术描述不在本文的范围之内。因此，让我们继续前进，发现一些真实的用例。</p><h2 id="35c9" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated"><strong class="ak">人脸检测</strong></h2><p id="8250" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">所有将在下一节展示的演示都有一个共同点:它们需要在处理提供的原始数据之前检测人脸。<strong class="ka ir"> Pigo </strong>人脸检测库只是为了以一种非常轻量级的方式来做这件事，因为它不需要任何第三方模块或外部库。它可以检测人脸，但也能够检测瞳孔/眼睛和面部标志点。因此，我们已经具备了制作一些令人惊叹的创意作品所需的所有要素。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/677661c0b7df67b06415e378e9a5c106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4TGQQbwm3UBjtVySQlvZcQ.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">使用Pigo库进行面部检测、瞳孔/眼睛定位和面部标志点检测。</figcaption></figure><h2 id="f9f4" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">在Go中使用HTML5画布API</h2><p id="c233" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">作为第一个演示，我们希望模糊检测到的面部，但由于Pigo只返回检测坐标和尺寸(通常是正方形)，我们需要将其转换为椭圆，因此我们必须在获得的矩形上应用椭圆公式。期望的最终结果应该是一个椭圆形状的模糊面具，层叠在检测到的人脸上，边缘逐渐变得透明。下面是我们想要达到的效果的快照。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/81b8eadcc2928e60c0f61ad5b6316722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*hs08ecMj0s7HBk55DYkcEQ.gif"/></div></figure><p id="d489" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了达到预期的效果，计划很简单:检索检测到的人脸的坐标，减去图像，并在其上应用模糊蒙版。我们有Pigo用于人脸检测，<a class="ae mk" href="https://github.com/esimov/stackblur-go" rel="noopener ugc nofollow" target="_blank"> stackblur-go </a>用于模糊检测到的人脸区域，但问题是我们应该只模糊人脸(自然是椭圆形的)而不是整个区域。下面是一步一步的可视化过程。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/87958be63f83b413eea484474d9610b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gQxJiGvL3JUuZxUI7kdOhw.jpeg"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">第一步:检测人脸。第二步:模糊脸部区域。步骤3:应用椭圆渐变叠加蒙版检测到的脸。</figcaption></figure><h2 id="670e" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated"><strong class="ak">初试</strong></h2><p id="eed1" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">作为一个起点，我选择在Go中直接整合椭圆公式，然后应用渐变叠加。事实证明，这是完全低效的，因为在每个帧速率上，我们必须将检测到的面部区域减去到子图像，将像素数据转换为图像，并在减去的图像上绘制椭圆梯度掩模。罪魁祸首不一定是图像减法，而是我们必须在每一帧上创建一个新的渐变遮罩的想法。</p><p id="06ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，为什么我们需要一个覆盖掩模呢？答案是因为<a class="ae mk" href="https://pkg.go.dev/image/draw" rel="noopener ugc nofollow" target="_blank"> image/draw </a>包的Draw方法可以通过将绘制在图像顶部的遮罩作为输入，对源图像应用复合操作，以创建所需的最终图像。下面这篇文章将对此进行更详细的解释:<a class="ae mk" href="https://go.dev/blog/image-draw" rel="noopener ugc nofollow" target="_blank">https://go.dev/blog/image-draw</a>。</p><blockquote class="mq mr ms"><p id="dc56" class="jy jz ml ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated">合成是按照Plan 9图形库和X Render扩展的样式逐像素执行的。该模型基于波特和达夫的经典论文“合成数字图像”，增加了一个遮罩参数:<code class="fe mm mn mo mp b"><em class="iq">dst = (src IN mask) OP dst</em></code>。对于完全不透明的掩模，这简化为原始的波特-达夫公式:<code class="fe mm mn mo mp b"><em class="iq">dst = src OP dst</em></code>。</p><p id="2370" class="jy jz ml ka b kb kc kd ke kf kg kh ki mt kk kl km mu ko kp kq mv ks kt ku kv ij bi translated">Porter-Duff的论文提出了12种不同的复合操作符，但是有了显式掩码，实际上只需要其中的两种:source-over-destination和source。</p></blockquote><p id="d46c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为<code class="fe mm mn mo mp b">draw.Drawmask</code>方法需要一个<code class="fe mm mn mo mp b"><a class="ae mk" href="https://pkg.go.dev/syscall/js" rel="noopener ugc nofollow" target="_blank">image.Image</a></code>作为第三个参数，而且这是一个<strong class="ka ir"> <em class="ml">接口</em> </strong>，这也意味着我们可以编写自己的图像类型，唯一的条件是实现由<code class="fe mm mn mo mp b">Image</code>接口定义的方法。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">椭圆公式的Go实现。</figcaption></figure><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/b46e85afae6d8d4ecb1d22ea220b9771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doObHJ2QQYMs3P7PGIyszw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">图像所需的方法。图像界面。</figcaption></figure><p id="959a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们有了由椭圆公式定义的自定义图像类型，我们可以将它作为第三个参数应用于<code class="fe mm mn mo mp b">draw.DrawMask</code>方法。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">将定义为自定义图像的椭圆公式应用到减去的面区域。</figcaption></figure><p id="81be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但不幸的是，结果并不是我们所期望的:椭圆渐变遮罩并没有向边缘淡出。我们得到的是一个统一的，简单模糊的面具，看起来有点尴尬。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/d317fd8922096a0710c2607bed6694f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhQSI866Hh5gC4h6XmXMEQ.jpeg"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">椭圆遮罩边缘不会淡出。</figcaption></figure><p id="68f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是创建一个渐变叠加，并用它作为椭圆遮罩的填充。我这里不贴升级后的渐变椭圆蒙版的实现，但是你可以在这里找到<a class="ae mk" href="https://github.com/esimov/pigo-wasm-demos/blob/833c0dba2e15840d96a63d9bb975559fe14c99cf/draw/gradient.go" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到<a class="ae mk" href="https://github.com/esimov/pigo-wasm-demos/blob/833c0dba2e15840d96a63d9bb975559fe14c99cf/draw/ellipse.go" rel="noopener ugc nofollow" target="_blank">。表演完全令人失望，所以我也放弃了这个版本。我们还能尝试什么来获得令人满意的表现呢？</a></p><h2 id="c0f6" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">另一种尝试:使用Javascript Canvas API</h2><p id="2740" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">HTML5 Canvas API有一个<code class="fe mm mn mo mp b"><a class="ae mk" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation" rel="noopener ugc nofollow" target="_blank">globalCompositeOperation</a></code>属性，它的作用与上面介绍的<code class="fe mm mn mo mp b">draw.Draw</code>函数完全相同:它对一个形状应用合成操作。使用来自<code class="fe mm mn mo mp b">syscall/js</code>包的<a class="ae mk" href="https://pkg.go.dev/syscall/js#Value.Call" rel="noopener ugc nofollow" target="_blank">调用</a>方法，我们可以调用本地Javascript方法。这是我们的营救计划。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/739ef003cff359a0f3d22ff80d4ba7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdLAc0s0BOlww_KxGCT31Q.png"/></div></div></figure><p id="b50b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们来看看如何应用渐变叠加蒙版在减去的面部区域。首先，我们需要创建椭圆径向梯度。有一个<code class="fe mm mn mo mp b"><a class="ae mk" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createRadialGradient" rel="noopener ugc nofollow" target="_blank">createRadialGradient</a></code> HTML5 Canvas方法，创建径向渐变，但不是椭圆形。HTML5标准中没有本地椭圆渐变方法，但是我们可以很容易地创建一个。我们只需要把椭圆公式代入这种方法。该方法按以下方式定义:</p><pre class="mw mx my mz gt nm mp nn no aw np bi"><span id="7581" class="lm ln iq mp b gy nq nr l ns nt">createRadialGradient(x0, y0, r0, x1, y1, r1)</span></pre><p id="d711" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<code class="fe mm mn mo mp b">(x0,y0)</code>是起点圆的<code class="fe mm mn mo mp b">x</code>和<code class="fe mm mn mo mp b">y</code>坐标，<code class="fe mm mn mo mp b">r0</code>是半径，<code class="fe mm mn mo mp b">(x1,y1)</code>是半径为<code class="fe mm mn mo mp b">r1</code>的终点圆。</p><p id="ea75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在椭圆渐变代码中，渐变的中心放在位置<code class="fe mm mn mo mp b">(cx, cy)</code>，渐变的大小由两个半径定义:<code class="fe mm mn mo mp b">rx</code>和<code class="fe mm mn mo mp b">ry</code>。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/8ee381d395cf34b154a7c3c1b8d148b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*e5Nh6X6yR7xADQdq.jpg"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">椭圆</figcaption></figure><p id="dd1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以将其转换成如下所示的真实代码:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/e342e80e9f405d2b7d60710014f8d8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kb9LNj0mus-EhViFbAsx4A.png"/></div></div></figure><p id="ee80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">酷，我们得到了一个好看的渐变叠加椭圆，但是从下面的图片中可以看出，它缺少了一些东西。解决方案非常简单:我们必须将<code class="fe mm mn mo mp b">globalCompositeOperation</code> canvas属性设置为<code class="fe mm mn mo mp b">destination-atop</code>。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/42f8415348f53b42fdfe43f020ce7628.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*YHydL_01S5e5LfMbWgpR1Q.png"/></div></figure><h2 id="b760" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">其他有趣的实验</h2><p id="7a90" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">接下来的演示遵循相同的概念，只是有些不同。创建一个类似缩放的背景模糊效果怎么样？</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/ce8a0d65597ac4c5b02e11a0934d03be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OKA3U-08nsyS1Hxih8E34A.gif"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">类似背景模糊效果的缩放</figcaption></figure><p id="6710" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可能看起来与早期的实验完全相同，但它有一个主要的技术差异:在模糊背景之前，我们需要将网络摄像头帧的原始像素数据绘制到一个单独的画布上下文中，然后才调用人脸检测算法。一步一步的过程如下:</p><ol class=""><li id="17a8" class="ny nz iq ka b kb kc kf kg kj oa kn ob kr oc kv od oe of og bi translated">将网络摄像头帧绘制到屏幕外的画布环境中。</li><li id="766e" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv od oe of og bi translated">获取转换为图像的原始像素数据。这是必需的，因为Pigo人脸检测库处理的是图像而不是像素值。我们可以很容易地将图像转换成像素阵列，反之亦然(见下文)。</li><li id="1f1a" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv od oe of og bi translated">减去检测到的人脸区域下的图像，并将其转换为前面给出的椭圆。</li><li id="d4f8" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv od oe of og bi translated">模糊画在屏幕外画布上的摄像头画面。这些是作为原始像素数据存储的，因此需要将其转换为图像。</li><li id="300e" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv od oe of og bi translated">将模糊的画布与存储检测到的面部区域的画布合并在一起。</li><li id="9332" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv od oe of og bi translated">使用<code class="fe mm mn mo mp b">destination-in</code>作为值应用<code class="fe mm mn mo mp b">globalCompositeOperation</code>。</li></ol><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">将图像转换为像素阵列，反之亦然。</figcaption></figure><h2 id="7078" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">关键要点</h2><p id="46b5" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">当我们与<strong class="ka ir"> syscall/js </strong>包和<strong class="ka ir">html 5 Canvas API</strong>:<strong class="ka ir"/><code class="fe mm mn mo mp b">getImageData</code>Canvas方法返回的值属于<code class="fe mm mn mo mp b">Uint8ClampedArray</code>类型时，有一件重要的事情我们需要记住。这些需要被转换成<code class="fe mm mn mo mp b">Uint8Array</code>，以便通过<code class="fe mm mn mo mp b"><a class="ae mk" href="https://pkg.go.dev/syscall/js#CopyBytesToGo" rel="noopener ugc nofollow" target="_blank">js.CopyBytesToGo</a></code>方法从JS转换到Go。否则会恐慌。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">Uint8ClampedArray到Uint8Array的转换。</figcaption></figure><p id="7667" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，<code class="fe mm mn mo mp b">putImageData</code> Canvas方法要求第一个参数是类型<code class="fe mm mn mo mp b">Uint8ClampedArray</code>，这意味着类型<code class="fe mm mn mo mp b">Uint8Array</code>的像素数组需要转换成所请求的类型。我们可以通过以下方式轻松做到这一点:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">Uint8Array到Uint8ClampedArray的转换。</figcaption></figure><p id="415e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再来看最后一个例子:人脸三角剖分。这个例子使用了<a class="ae mk" href="https://github.com/esimov/triangle" rel="noopener ugc nofollow" target="_blank"> ▲三角形</a>库。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f83884fcd2177cf38c05e03370d99505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*rtGG-YbAg6KGHgK26QL9sw.gif"/></div></figure><p id="aab1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个演示的范围是对检测到的人脸进行三角测量，给它们一些很酷的美学外观，同时也匿名化一个人的脸。和其他演示一样，有些部分可以重用，我们只需要插入图像三角测量过程。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8147" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们减去检测到的面部区域，我们称之为<a class="ae mk" href="https://pkg.go.dev/github.com/esimov/triangle/v2#Image.Draw" rel="noopener ugc nofollow" target="_blank">三角形。Draw </a>方法，该方法返回三角化的图像以及一个错误和一些其他值，这些对于我们的例子并不重要。</p><p id="52b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为最后一个操作，我们需要将生成的图像转换成一个像素数组(使用前面介绍的实用函数)，因为我们必须将这些像素拉回画布上下文，并对保存三角化图像的椭圆渐变应用相同的复合操作。</p><h2 id="8e04" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">最终注释</h2><p id="743a" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">如您所见，整个过程看起来可能很复杂，但实际上可以简化为几件事:</p><ul class=""><li id="9899" class="ny nz iq ka b kb kc kf kg kj oa kn ob kr oc kv om oe of og bi translated">图像到像素的转换。</li><li id="e6fc" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv om oe of og bi translated">使用不同的画布层，并使用复合操作将它们合并在一起。</li><li id="97d7" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv om oe of og bi translated">以<strong class="ka ir"> syscall/js </strong>包请求的方式使用Javascript和HTML5 Canvas API。</li><li id="10a5" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv om oe of og bi translated">将Javascript数组转换成Go字节片，反之亦然:将字节片转换成Javascript数组。</li></ul><p id="aaca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以通过以下链接查看Github上演示的源代码:<a class="ae mk" href="https://github.com/esimov/pigo-wasm-demos" rel="noopener ugc nofollow" target="_blank">https://github.com/esimov/pigo-wasm-demos</a></p><h2 id="88da" class="lm ln iq bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">有用的资源</h2><ul class=""><li id="b263" class="ny nz iq ka b kb mf kf mg kj on kn oo kr op kv om oe of og bi translated"><a class="ae mk" href="https://github.com/esimov/pigo" rel="noopener ugc nofollow" target="_blank">https://github.com/esimov/pigo</a></li></ul><p id="3188" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你感兴趣，下面是一些关于Pigo人脸检测库的文章和演示。</p><ul class=""><li id="9b0c" class="ny nz iq ka b kb kc kf kg kj oa kn ob kr oc kv om oe of og bi translated"><a class="ae mk" href="https://www.infoq.com/news/2020/02/go-wasm-port-face-detection/" rel="noopener ugc nofollow" target="_blank">https://www . infoq . com/news/2020/02/go-wasm-port-face-detection/</a></li><li id="9e52" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv om oe of og bi translated"><a class="ae mk" href="https://esimov.com/2019/07/pigo-face-detection-library" rel="noopener ugc nofollow" target="_blank">https://esimov.com/2019/07/pigo-face-detection-library</a></li><li id="c16d" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv om oe of og bi translated"><a class="ae mk" href="https://esimov.com/2019/11/pupilseyes-localization-in-the-pigo-face-detection-library" rel="noopener ugc nofollow" target="_blank">https://ESI mov . com/2019/11/pupilseyes-localization-in-the-pigo-face-detection-library</a></li><li id="c92b" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv om oe of og bi translated"><a class="ae mk" href="https://esimov.com/2020/01/pigo-wasm" rel="noopener ugc nofollow" target="_blank">https://esimov.com/2020/01/pigo-wasm</a></li><li id="6cc6" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv om oe of og bi translated"><a class="ae mk" href="https://www.youtube.com/watch?v=S7TzgIpAZLU" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=S7TzgIpAZLU</a></li><li id="b8fb" class="ny nz iq ka b kb oh kf oi kj oj kn ok kr ol kv om oe of og bi translated">https://www.youtube.com/watch?v=bdwNM8gbIGg<a class="ae mk" href="https://www.youtube.com/watch?v=bdwNM8gbIGg" rel="noopener ugc nofollow" target="_blank"/></li></ul></div></div>    
</body>
</html>