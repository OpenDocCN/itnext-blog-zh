<html>
<head>
<title>React Performance Optimization: 9 Techniques to Boost Application Speed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React性能优化:提高应用速度的9项技术</h1>
<blockquote>原文：<a href="https://itnext.io/react-performance-optimization-9-techniques-to-boost-application-speed-223c6b73dcab?source=collection_archive---------1-----------------------#2022-02-28">https://itnext.io/react-performance-optimization-9-techniques-to-boost-application-speed-223c6b73dcab?source=collection_archive---------1-----------------------#2022-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eb5e1928016992a85c2f6b03ee240058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6yFob39HGQ_mYuoZrilXw.png"/></div></div></figure><p id="89e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管React提供了许多优势，但优化React应用程序的性能可能很棘手。在本帖中，我们将介绍提高React应用程序速度的九种技术。</p><h1 id="e492" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">避免多余的渲染</h1><p id="215e" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">冗余渲染是React中的一个典型问题，它会迅速降低应用程序的性能。</p><p id="bd71" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据我的经验，务实地规划状态流在大多数时候有助于避免多余的渲染。在编写使用应用程序状态的组件时，需要记住以下几点。</p><h2 id="cc42" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">尽可能使用派生状态</h2><p id="6142" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">避免使用状态来存储您可以动态派生的数据。这样做可以简化数据同步，因为派生变量会在源发生变化时自动重新计算。</p><p id="f088" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想了解更多关于这个技巧的内容，可以看看我在<a class="ae mo" href="https://isamatov.com/react-derived-state/" rel="noopener ugc nofollow" target="_blank">上发表的关于在React </a>中派生状态的帖子。</p><h2 id="59d7" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">对组件要决定的事情要有选择性</h2><p id="0c73" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">请记住您提供给组件的信息。您传递给它们的每个状态片段都可能导致重新呈现。因此，请确保只传递组件运行所需的信息。定期清理或重构你不使用的道具。</p><h2 id="e981" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">传递扁平的道具和基本体</h2><p id="0be5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">不要提供整个对象作为道具，尝试传递扁平和简化的版本。提供复杂、深度嵌套的对象作为道具可能会导致意外的副作用和组件渲染。</p><p id="2265" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用展平的对象和基本体作为道具简化了将来组件性能的优化。</p><h2 id="1db4" class="mc la it bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">使用备忘录、使用备忘录和使用回调</h2><p id="2055" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated"><code class="fe mp mq mr ms b">memo</code>、<code class="fe mp mq mr ms b">useMemo</code>和<code class="fe mp mq mr ms b">useCallback</code>是用于记忆组件和减少渲染数量的反应效用函数。这三个函数是优化React性能的主要工具。</p><p id="50a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是要注意在代码中如何以及在哪里应用它们。有时，应用这些功能并没有什么好处。例如，如果您的重新渲染是由频繁更新的上下文引起的，那么用<code class="fe mp mq mr ms b">memo</code>包装您的组件将无助于减少重新渲染的次数。</p><p id="5fdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想了解更多关于<a class="ae mo" href="https://isamatov.com/react-avoid-redundant-renders/" rel="noopener ugc nofollow" target="_blank">优化React组件</a>中冗余渲染数量的信息，请查看这篇文章。</p><h1 id="f662" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">有条件地呈现组件，而不是用CSS隐藏它们</h1><p id="384f" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这是我最常看到新React开发人员犯的错误。如果他们有需要对用户隐藏组件的用例，他们会使用CSS道具，比如<code class="fe mp mq mr ms b">opacity</code>或<code class="fe mp mq mr ms b">visibility</code>来实现这个目的。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="8e59" class="mc la it ms b gy nb nc l nd ne">const Sample = ({ hidden }) =&gt; {<br/>  const visibility = hidden ? "hidden" : "visible";</span><span id="477c" class="mc la it ms b gy nf nc l nd ne">  return &lt;div style={{ visibility }}&gt;Hello there&lt;/div&gt;;<br/>};</span></pre><p id="9e30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这样做在性能方面是次优的。即使对用户不可见，组件仍然存在于DOM中。相反，使用条件逻辑来避免完全呈现组件。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="7bd9" class="mc la it ms b gy nb nc l nd ne">const Sample2 = ({ hidden }) =&gt; {<br/>  if (hidden) return null;</span><span id="2faa" class="mc la it ms b gy nf nc l nd ne">  return &lt;div&gt;Hello there &lt;/div&gt;;<br/>};</span></pre><h1 id="3d35" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用React探查器</h1><p id="7169" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">React Profiler是一个性能工具，允许您收集有关组件的计时信息。</p><p id="6e25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以通过安装<a class="ae mo" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" rel="noopener ugc nofollow" target="_blank"> React开发工具</a>来使用React Profiler。<br/>分析器将向你展示应用程序中每个组件渲染的频率以及每次渲染需要多长时间。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/397133248fda036d0331c0083ff13473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nM4JnKWCFRSKNI2PwPr8uA.png"/></div></div></figure><p id="5cce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，您可以使用此信息来优化性能，方法是记住昂贵的组件或完全避免不必要的渲染。</p><p id="c238" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要了解React Profiler的更多信息，请查看React docs 中的<a class="ae mo" href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" rel="noopener ugc nofollow" target="_blank">这篇文章。</a></p><h1 id="0d74" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">本地状态vs Redux</h1><p id="b4c6" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Redux是一个用于管理应用程序状态的强大库。但是，注意不要过度使用。Redux非常适合真正的全球数据，如用户会话或应用程序主题。</p><p id="eab2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然Redux做了一些事情来优化它的性能，但如果你将它用于频繁的事件，如跟踪用户输入，它仍然会对你的应用程序产生影响。</p><p id="9c61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">全局状态总是比本地状态慢，所以尽可能使用本地状态。使用本地状态带来正确钻探问题通常可以通过组件组合来解决。如果你感兴趣，这里有一个帖子，我会更详细地介绍React 的<a class="ae mo" href="https://isamatov.com/react-component-composition/" rel="noopener ugc nofollow" target="_blank">组件组成。</a></p><h1 id="f574" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">乐观的回应</h1><p id="174d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">乐观的反应是当您不等待API响应将更改传播到您的UI时。这是提高应用程序感知性能的最佳方式之一。</p><p id="ebf5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">主要思想是发出一个异步请求，同时更新本地状态数据，就好像已经收到了响应一样。</p><p id="35e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实现这种方法通常会增加状态管理的复杂性。所以首先要考虑复杂度和性能之间的权衡是否值得。</p><p id="23b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有些API库提供乐观响应特性，例如<a class="ae mo" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>。Apollo是一个GraphQL客户端，具有内置的状态管理和缓存功能。</p><h1 id="bd51" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">网络工作者</h1><p id="3342" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Web Worker API 允许独立于主线程运行计算量大的操作。</p><p id="6571" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您的应用程序需要运行一个繁重的序列化功能。由于JavaScript运行时的单线程特性，运行它会冻结或严重降低应用程序的性能。</p><p id="4f27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相反，您可以使用web worker运行您的函数。</p><p id="bc37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个很好的例子就是处理媒体文件。通常，您希望在保存图像之前对其进行一些处理。也许你想在将用户头像上传到你的云存储之前减小它们的大小，以节省计算成本。像<a class="ae mo" href="https://github.com/lovell/sharp" rel="noopener ugc nofollow" target="_blank"> sharp </a>这样强大的图像处理库经常会冻结你的主执行线程，所以最好在单独的web worker中运行它们。</p><h1 id="c055" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">虚拟列表</h1><p id="f5ca" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">当处理大量表格数据时，虚拟列表特别有用。</p><p id="4c38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虚拟列表背后的想法是只呈现需要在屏幕视图内的项目。把它想象成一个即时渲染:</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c55bb994b5f01666a0fc23b5410b0e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/1*9lnWfM9wl4C2eMa0zeVBvQ.gif"/></div></figure><p id="126a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">即使你的列表包含数百个项目，应用程序一次也只会呈现十个，当用户滚动时，这些项目会在视图中出现和消失。</p><p id="30b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">react-virtualized 是react中实现虚拟列表的一个流行选项。</p><h1 id="e5d7" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">动态导入</h1><p id="3d6d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">动态导入是如何将代码分割添加到应用程序中的。代码分割是一种性能优化技术，用于仅在需要时加载代码片段。代码分割由捆绑器处理，如Webpack或Browserify。</p><p id="6f5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">动态导入的基本语法如下:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="e925" class="mc la it ms b gy nb nc l nd ne">import("./math").then(math =&gt; {<br/>  console.log(math.add(16, 26));<br/>});</span><span id="8584" class="mc la it ms b gy nf nc l nd ne">console.log(add(16, 26));</span></pre><p id="7987" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当Webpack遇到这种语法时，它会自动开始对你的应用程序进行代码拆分。</p><p id="8f76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用动态导入语法将React组件拆分成单独的包。这样，Webpack将只加载需要在当前视图中呈现的组件。</p><p id="dc68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mp mq mr ms b">React.lazy</code>还提供了一种React特有的方式来对你的应用进行代码拆分。它允许按需延迟加载React组件，并暂停呈现组件，直到它们准备好被呈现。</p><p id="697e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">决定在应用程序中的什么地方引入代码分割可能很棘手。您希望选择能够平均分割捆绑包但不会破坏用户体验的位置。</p><p id="5bf1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个好的起点是路线。人们习惯了页面之间的等待时间。按路径分割代码将有助于减少页面加载时间，而不会对用户体验产生负面影响。</p><p id="1f26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要了解关于代码分割和动态导入的更多信息，请查看React docs 中关于代码分割的这篇文章<a class="ae mo" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="c1cf" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用片段</h1><p id="6807" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">React片段允许您对一系列子节点进行分组，而无需向DOM添加额外的节点。React要求每个组件都有一个根节点。很多人默认使用div来实现这个目的，但这并不总是最好的选择。大量的div会阻碍你的应用程序的性能。</p><p id="5afa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">片段允许您将多个React节点分组，而无需向DOM添加额外的节点，从而让您避开了这个问题。React在渲染过程中将片段合并到父DOM中。</p><h1 id="8446" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="4d32" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">React性能优化可能很棘手，但是遵循这些简单的技术将帮助您提高应用程序的速度。</p><p id="3f84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想获得更多的网络开发、反馈和打字技巧，可以考虑<a class="ae mo" href="https://twitter.com/IskanderSamatov" rel="noopener ugc nofollow" target="_blank">在Twitter </a>上关注我，我在那里分享我学到的东西。<br/>编码快乐！</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="17d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">原载于2022年2月28日</em><a class="ae mo" href="https://isamatov.com/react-optimizing-performance/" rel="noopener ugc nofollow" target="_blank"><em class="np"/></a><em class="np">。</em></p></div></div>    
</body>
</html>