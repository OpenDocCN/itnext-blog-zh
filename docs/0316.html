<html>
<head>
<title>Deploy and scale a multi-env service on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上部署和扩展多环境服务</h1>
<blockquote>原文：<a href="https://itnext.io/deploy-and-scale-a-multi-env-service-on-kubernetes-d2bc52c7575c?source=collection_archive---------3-----------------------#2018-02-16">https://itnext.io/deploy-and-scale-a-multi-env-service-on-kubernetes-d2bc52c7575c?source=collection_archive---------3-----------------------#2018-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e901821c24c8c44a37a9d6f81a40958b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6F-M9Xy6qvvqBrJb.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自Datadog <a class="ae kc" href="https://www.datadoghq.com/blog/monitoring-kubernetes-era/" rel="noopener ugc nofollow" target="_blank">文章</a>。</figcaption></figure><p id="5878" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在之前的<a class="ae kc" href="http://pstylianides.com/a-go-microservice-using-grpc-and-mongodb/" rel="noopener ugc nofollow" target="_blank">帖子</a>中，我们使用<a class="ae kc" href="https://grpc.io/docs/quickstart/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>框架创建了一个<code class="fe lb lc ld le b">Go</code>微服务，并将其打包成一个<a class="ae kc" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank"> Docker </a>容器映像。现在，我们将尝试发布我们的容器，并使其在云中的某个公开位置高度可用。假设我们计划在不久的将来添加一些互连的容器化应用程序，并且需要一种编排平台来轻松管理它们。</p><p id="611d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kubernetes是一个开源系统，最初由Google设计，也是最受欢迎的选择之一。目前可用的一些替代(在某些方面)容器编排引擎有:<a class="ae kc" href="http://mesos.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Mesos </a>、<a class="ae kc" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>、<a class="ae kc" href="https://www.nomadproject.io/" rel="noopener ugc nofollow" target="_blank"> HashiCorp Nomad </a>和其他一些。</p><p id="17fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将使用<code class="fe lb lc ld le b">Kubernetes</code>——因为这是我个人最喜欢的，但在未来的文章中，我们将与<code class="fe lb lc ld le b">Mesos</code>实现类似的目标——也许比较两者并确定它们的优势。</p><p id="571f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的项目源代码可以从这个<a class="ae kc" href="https://github.com/stphivos/todo-api-go-grpc" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>下载。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="3f43" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">先决条件</h1><p id="125e" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">假设您已经对使用<a class="ae kc" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank"> Docker </a>的容器和基本的<code class="fe lb lc ld le b">Kubernetes</code>概念有所了解，因为我们不会在本文中详细讨论它们。</p><p id="eefb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，确保您已经安装了所需的工具，并且在您的<code class="fe lb lc ld le b">PATH</code>中:</p><ul class=""><li id="a27e" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">码头工人cli</li><li id="3069" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">Kubernetes cli</li></ul><p id="7034" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，您需要有一个Kubernetes集群设置。根据您打算使用的提供程序，这里有几个如何做到这一点的选项:</p><ul class=""><li id="a21b" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">对于GCP，安装<a class="ae kc" href="https://cloud.google.com/sdk/downloads" rel="noopener ugc nofollow" target="_blank"> Google Cloud SDK </a>并遵循这个<a class="ae kc" href="https://cloud.google.com/kubernetes-engine/docs/how-to/creating-a-container-cluster" rel="noopener ugc nofollow" target="_blank">指南</a>。</li><li id="458f" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">对于AWS，安装<a class="ae kc" href="https://github.com/kubernetes/kops/blob/master/docs/install.md" rel="noopener ugc nofollow" target="_blank"> Kops </a>并遵循此<a class="ae kc" href="https://github.com/kubernetes/kops/blob/master/docs/aws.md" rel="noopener ugc nofollow" target="_blank">指南</a>。</li><li id="98aa" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">对于AKS，安装<a class="ae kc" href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest" rel="noopener ugc nofollow" target="_blank"> Azure CLI </a>并遵循本<a class="ae kc" href="https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough#create-aks-cluster" rel="noopener ugc nofollow" target="_blank">指南</a></li><li id="fcf7" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">对于本地，安装<a class="ae kc" href="https://github.com/kubernetes/minikube#installation" rel="noopener ugc nofollow" target="_blank"> Minikube </a>并遵循本<a class="ae kc" href="https://github.com/kubernetes/minikube#quickstart" rel="noopener ugc nofollow" target="_blank">指南</a>。</li></ul><p id="5d49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意</strong>:为了能够模拟大量并发用户，请选择一种节点配置，其中核心总数至少达到8个vCPUs。我使用了2个集群节点，每个节点有4个vCPUs。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="fe5d" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">目标</h1><ul class=""><li id="8d4e" class="mp mq iq kf b kg mk kk ml ko nd ks ne kw nf la mu mv mw mx bi translated">为部署编写基本的Kubernetes清单</li><li id="7e0e" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">使用<a class="ae kc" href="https://github.com/joho/godotenv" rel="noopener ugc nofollow" target="_blank"> GoDotEnv </a>从. Env文件管理项目全局变量</li><li id="e68e" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">将<a class="ae kc" href="https://github.com/stphivos/bg-kube" rel="noopener ugc nofollow" target="_blank"> bg-kube </a>用于多环境部署工作流</li><li id="9e02" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">使用<a class="ae kc" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank"> Locust </a>来定义负载测试和grpc客户端</li><li id="d357" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">创建一个<a class="ae kc" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">水平Pod自动缩放器</a>，启动负载测试并观察指标</li></ul></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="271b" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Kubernetes载货清单</h1><p id="7cbe" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在已经有了一个Kubernetes集群，我们继续编写第一个清单。</p><p id="11c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<code class="fe lb lc ld le b">Deployment</code>清单描述了<a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" rel="noopener ugc nofollow" target="_blank">容器</a>和<a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" rel="noopener ugc nofollow" target="_blank">复制集</a>的期望状态。Pod是Kubernetes中最小的可部署单元，并且知道如何运行容器。ReplicaSet将确保在任何给定时间，指定数量的pod在可用的集群工作节点上运行。因此简单地说，部署允许我们定义所需的Pod副本数量，每个副本运行我们的容器的一个实例。</p><p id="999f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能希望指定多个副本的一个原因是为了实现水平扩展，以便在求助于更多或更高容量的虚拟机之前更好地利用分配的节点，这一过程称为垂直扩展。如需了解更多信息，请查看Kubernetes中的<a class="ae kc" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">水平Pod自动缩放器(HPA) </a>，它会自动执行此操作。我们得到的一些其他好处是负载平衡和高度可用的服务。</p><p id="2c0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">支持我们的<a class="ae kc" href="http://pstylianides.com/a-go-microservice-using-grpc-and-mongodb/" rel="noopener ugc nofollow" target="_blank"> Go服务</a>的部署清单如下所示:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cbba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于上面的<code class="fe lb lc ld le b">yaml</code>配置文件的几个亮点是:</p><ul class=""><li id="9e35" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">我们使用动态变量，即<code class="fe lb lc ld le b">$IMAGE_NAME</code>，在部署过程中注入来自<code class="fe lb lc ld le b">.env</code>文件的实际值。</li><li id="5206" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">我们使用<a class="ae kc" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" rel="noopener ugc nofollow" target="_blank">标签和选择器</a>对与我们相关的对象进行分组，以便根据环境/角色等来区分相似的对象。</li></ul><p id="e8da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们继续看<code class="fe lb lc ld le b">Service</code>清单，它描述了Kubernetes神器作为我们的吊舱的负载平衡器。它随时都知道有多少个和哪些单元在运行服务，并且只向这些单元转发流量。与可以被新服务终止和替换的pod不同，服务意味着是公开其功能的可靠抽象。</p><p id="bfa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种服务清单的示例如下所示:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f7e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你可能已经注意到的，一个<code class="fe lb lc ld le b">Service</code>使用<a class="ae kc" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" rel="noopener ugc nofollow" target="_blank">标签选择器</a>来确定哪些pod属于它的集合。</p><p id="236c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，它可能使用不同于我们的容器实例所使用的端口来公开自己。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="42d0" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">。环境文件</h1><p id="1dd4" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated"><a class="ae kc" href="http://pstylianides.com/a-go-microservice-using-grpc-and-mongodb/#entry-point" rel="noopener ugc nofollow" target="_blank">之前的</a>，在<code class="fe lb lc ld le b">main.go</code>的函数<code class="fe lb lc ld le b">getConfig</code>中，我们使用<a class="ae kc" href="https://github.com/jinzhu/configor" rel="noopener ugc nofollow" target="_blank"> configor </a>库从<code class="fe lb lc ld le b">config.yaml</code>文件中加载应用变量。</p><p id="8c68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该库还支持由我们的<a class="ae kc" href="https://github.com/stphivos/todo-api-go-grpc/blob/master/models/models.go#L8" rel="noopener ugc nofollow" target="_blank"> Config </a> struct中定义的环境变量覆盖它们的值。现在，我们将根据我们打算部署的环境来设置它们。我们将为每个环境创建一个<code class="fe lb lc ld le b">.env</code>文件，即<code class="fe lb lc ld le b">.env.dev</code>、<code class="fe lb lc ld le b">.env.prod</code>甚至<code class="fe lb lc ld le b">.env.staging</code>。</p><p id="6399" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设生产环境将托管在<a class="ae kc" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> Google Kubernetes引擎</a>上，这里有一个<strong class="kf ir"> .env.prod </strong>文件:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="11b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更新<code class="fe lb lc ld le b">CLUSTER_NAME</code>和<code class="fe lb lc ld le b">CLUSTER_ZONE</code>以匹配您的Kubernetes集群。同样更新<code class="fe lb lc ld le b">IMAGE_NAME</code>以反映如下形式的容器注册:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="355c" class="nq ln iq le b gy nr ns l nt nu">&lt;hostname&gt;/&lt;project-id&gt;/todo-api-go-grpc</span></pre><p id="a729" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您使用<a class="ae kc" href="https://docs.docker.com/machine/" rel="noopener ugc nofollow" target="_blank"> Docker Machine </a>在Mac或Windows上运行Docker，请将<code class="fe lb lc ld le b">DOCKER_MACHINE_NAME</code>更新为您的虚拟机名称。</p><p id="69e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，使用<a class="ae kc" href="https://github.com/joho/godotenv" rel="noopener ugc nofollow" target="_blank"> GoDotEnv </a>库更新<code class="fe lb lc ld le b">main.go</code>以添加对<code class="fe lb lc ld le b">.env</code>文件的支持:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="28d3" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">部署工作流程</h1><p id="b138" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们将使用<a class="ae kc" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">Helm</a>——Kubernetes的一个包管理器，第一次设置我们的<a class="ae kc" href="https://github.com/stphivos/todo-api-go-grpc" rel="noopener ugc nofollow" target="_blank">应用程序</a>使用的MongoDB。按照<a class="ae kc" href="https://docs.helm.sh/using_helm/#installing-helm" rel="noopener ugc nofollow" target="_blank">文档</a>将其安装到您的机器上。</p><p id="dc0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是通过安装<code class="fe lb lc ld le b">Tiller</code>将<code class="fe lb lc ld le b">Helm</code>初始化到我们的Kubernetes集群中。负责管理图表发布(通过Helm安装软件包):</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="13aa" class="nq ln iq le b gy nr ns l nt nu">helm init</span></pre><p id="f88a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将在默认的<code class="fe lb lc ld le b">Helm</code>存储库<code class="fe lb lc ld le b">stable</code>下安装<code class="fe lb lc ld le b">mongodb</code>图表，并将发布版本命名为<code class="fe lb lc ld le b">todo-api</code>:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="8239" class="nq ln iq le b gy nr ns l nt nu">helm install stable/mongodb --name todo-api</span></pre><p id="bbb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证部署箱是否准备就绪:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="8139" class="nq ln iq le b gy nr ns l nt nu">$ kubectl get deployment todo-api-mongodb<br/>NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>todo-api-mongodb   1         1         1            1           1m</span></pre><p id="3e18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://github.com/stphivos/bg-kube" rel="noopener ugc nofollow" target="_blank"> bg-kube </a>是我写的一个开源工具，它简化了Kubernetes上的多环境蓝绿部署。它可以轻松地将数据库迁移和冒烟测试集成到自动化发布工作流中。使用Python <a class="ae kc" href="https://pip.pypa.io/en/stable/installing/" rel="noopener ugc nofollow" target="_blank"> PIP </a>安装:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="1692" class="nq ln iq le b gy nr ns l nt nu">pip install bg-kube</span></pre><p id="7d3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lb lc ld le b">bg-kube</code>，我们只需要从项目根目录运行这个命令:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="07df" class="nq ln iq le b gy nr ns l nt nu">bg-kube publish --env-file .env.prod</span></pre><p id="4492" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">publish</code>命令将执行以下步骤:</p><ol class=""><li id="70f4" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la nv mv mw mx bi translated">使用项目的<code class="fe lb lc ld le b">Dockerfile</code>构建一个容器映像，并在提供的<code class="fe lb lc ld le b">.env</code>文件中用指定的<code class="fe lb lc ld le b">IMAGE_NAME</code>变量标记它。</li><li id="674f" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nv mv mw mx bi translated">将映像推送到指定的容器注册表。</li><li id="4d31" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nv mv mw mx bi translated">创建/更新在<code class="fe lb lc ld le b">deployment.yaml</code>中定义的<code class="fe lb lc ld le b">Deployment</code>资源，并根据目标(当前不活动)环境将其标记为<code class="fe lb lc ld le b">blue</code>或<code class="fe lb lc ld le b">green</code>。</li><li id="3b08" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nv mv mw mx bi translated">如果服务是第一次部署，它还将创建一个<code class="fe lb lc ld le b">Job</code>资源，如<code class="fe lb lc ld le b">db-seed.yaml</code>中所定义的，该资源将用种子数据填充数据库。</li><li id="df88" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nv mv mw mx bi translated">运行提供的冒烟测试命令，验证最新的<code class="fe lb lc ld le b">Deployment</code>功能是否符合预期。(我们跳过了这一步)</li><li id="f098" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nv mv mw mx bi translated">创建/更新在<code class="fe lb lc ld le b">service.yaml</code>中定义的<code class="fe lb lc ld le b">Service</code>资源，并指向将处理即将到来的流量的最新<code class="fe lb lc ld le b">Deployment's</code>pod。</li></ol><p id="16f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您希望在不安装<code class="fe lb lc ld le b">bg-kube</code>的情况下继续操作，您仍然可以使用<a class="ae kc" href="https://www.gnu.org/software/gettext/manual/html_node/envsubst-Invocation.html" rel="noopener ugc nofollow" target="_blank"> envsubst </a>来替换Kubernetes清单中的环境变量，并通过管道将其传输到<code class="fe lb lc ld le b">kubectl</code>，如下所示:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="938e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，您可以直接在清单中硬编码这些值，但是这意味着您将需要每个环境的不同副本。</p><p id="4d01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证部署箱是否准备就绪:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="2b6f" class="nq ln iq le b gy nr ns l nt nu">$ kubectl get deployment todo-api-blue<br/>NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>todo-api-blue   1         1         1            1           57s</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="34cb" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">定义负载测试</h1><p id="f28a" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated"><a class="ae kc" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank"> Locust </a>是一个负载测试库，它让我们可以很容易地使用Python声明性语法模拟大量并发用户。</p><p id="8316" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要做的第一件事是编写一个<a class="ae kc" href="https://docs.locust.io/en/latest/writing-a-locustfile.html" rel="noopener ugc nofollow" target="_blank"> locustfile </a>来定义我们的测试以及这些测试如何访问公开的服务。由于没有内置的gRPC客户端，我们将编写自己的程序，但是不要担心<code class="fe lb lc ld le b">Locust</code>会让我们很容易。</p><p id="ad0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先添加一个公共的<code class="fe lb lc ld le b">GrpcClient</code>类，它负责建立与gRPC服务器的“通道”,并拦截对gRPC服务的调用，以便能够发出<code class="fe lb lc ld le b">Locust</code>成功/失败事件。</p><p id="d981" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们添加另一个类<code class="fe lb lc ld le b">GrpcLocust</code>，代表访问服务并使用之前的客户端调用其方法的蝗虫群(用户)——在我们的例子中，在<a class="ae kc" href="https://github.com/stphivos/todo-api-go-grpc/blob/master/server/grpc/todos.proto" rel="noopener ugc nofollow" target="_blank"> todos.proto </a>中定义的唯一RPC方法是<code class="fe lb lc ld le b">GetTodos</code>。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4aaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能已经注意到了，我们正在导入Python模块<code class="fe lb lc ld le b">todos_pb2</code>和<code class="fe lb lc ld le b">todos_pb2_grpc</code>，它们是使用<a class="ae kc" href="https://github.com/grpc/grpc/tree/master/tools/distrib/python/grpcio_tools" rel="noopener ugc nofollow" target="_blank"> gRPC Python工具包</a>中的协议缓冲编译器生成的。如果您希望重新生成Python接口和存根运行:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="5dfe" class="nq ln iq le b gy nr ns l nt nu"># Install the grpcio-tools package<br/>$ python -m pip install grpcio-tools</span><span id="9673" class="nq ln iq le b gy nw ns l nt nu"># Run the protobuf compiler<br/>$ python -m grpc_tools.protoc \<br/>   -I ./server/grpc \<br/>   --python_out=./loadtest/locust-tasks \<br/>   --grpc_python_out=./loadtest/locust-tasks \<br/>   ./server/grpc/todos.proto</span></pre><p id="1110" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">./loadtest</code>目录也已经包含了以下文件:</p><ul class=""><li id="6a14" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated"><strong class="kf ir"> deployment.yaml </strong>:描述<code class="fe lb lc ld le b">locust-master</code>和<code class="fe lb lc ld le b">locust-slaves</code>节点。</li><li id="1fa7" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kf ir"> service.yaml </strong>:通过<a class="ae kc" href="https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer" rel="noopener ugc nofollow" target="_blank">负载均衡器</a>服务公开以上内容。</li><li id="eaba" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kf ir"> Dockerfile </strong>:为<code class="fe lb lc ld le b">locust-master</code>和<code class="fe lb lc ld le b">locust-slaves</code>构建一个单独的图像。</li><li id="456c" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kf ir">. env . dev/. env . prod</strong>:<code class="fe lb lc ld le b">.env</code>文件，带有用于<code class="fe lb lc ld le b">dev</code>和<code class="fe lb lc ld le b">prod</code>环境的变量。</li><li id="e907" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kf ir"> run.sh </strong>:在主/从模式下运行容器映像的Shell脚本。</li></ul><p id="06eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的目的是<a class="ae kc" href="https://docs.locust.io/en/latest/running-locust-distributed.html" rel="noopener ugc nofollow" target="_blank">运行Locust distributed </a>，这样我们就可以产生大量的客户端请求。那么为什么不依靠Kubernetes <code class="fe lb lc ld le b">ReplicaSet</code>资源来处理呢？使用<code class="fe lb lc ld le b">bg-kube</code>，让我们通过运行与之前相同的命令将蝗虫主服务器&amp;从服务器部署到Kubernetes，但是从<code class="fe lb lc ld le b">./loadtest</code>目录:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="900d" class="nq ln iq le b gy nr ns l nt nu">bg-kube publish --env-file .env.prod</span></pre><p id="e062" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证部署箱是否准备就绪:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="55b9" class="nq ln iq le b gy nr ns l nt nu">$ kubectl get deployment -l role=load-tests<br/>NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>locust-master   1         1         1            1           2m<br/>locust-worker   14        14        14           14          2m</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="cc68" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">启动负载测试</h1><p id="2901" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">首先，为展开设置一个<a class="ae kc" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">水平吊舱自动缩放器</a>:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="dcf3" class="nq ln iq le b gy nr ns l nt nu">kubectl autoscale deployment todo-api-blue \<br/>   --min=1 --max=10 --cpu-percent=80</span></pre><p id="18fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后启动<code class="fe lb lc ld le b">Locust</code> web界面:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="313a" class="nq ln iq le b gy nr ns l nt nu">open "http://`kubectl get service locust-master \<br/>   -o jsonpath='{$.status.loadBalancer.ingress[0].ip}'`:8089"</span></pre><p id="621b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择模拟<code class="fe lb lc ld le b">10,000 users</code>，产卵率为<code class="fe lb lc ld le b">1000 users p/s</code>，点击<code class="fe lb lc ld le b">Start swarming</code>。</p><p id="a643" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们观察自动缩放如何对我们的负载测试做出反应，使用如下:</p><pre class="ng nh ni nj gt nm le nn no aw np bi"><span id="5b68" class="nq ln iq le b gy nr ns l nt nu">watch kubectl describe hpa todo-api-blue</span></pre><p id="321b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的例子中，我让<code class="fe lb lc ld le b">Locust</code>运行了大约20分钟。</p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/6f66245bc26d34db59ea6dfb38ac34b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Xz4Im5HIfsZ1es4D.png"/></div></div></figure><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/1720e836ab3b23ba111c8ce1922d6a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y9WXVQVMAvLRBLGB.png"/></div></div></figure><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/9750a5422d671c91a40d32a5417f1a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QJerVV-eCnGTAzC4.png"/></div></div></figure><p id="a053" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">副本的数量从<code class="fe lb lc ld le b">1</code>稳步上升到<code class="fe lb lc ld le b">4</code>，并且稳定在那里，因为CPU利用率保持在<code class="fe lb lc ld le b">69%</code>左右，同时平均每秒处理大约700个请求。</p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/f6a739ddf1eb2fb5f2e916b5b2b720cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*acnAI4NKEBBltNjQ.png"/></div></div></figure><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/ebf46b4234503894653e2bfcb3f46861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Uz7EGCSyyHFDp2lJ.png"/></div></div></figure><p id="4507" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您从下面的汇总统计数据中看到的，在测试期间，我们总共服务了<code class="fe lb lc ld le b">791,711</code>个<code class="fe lb lc ld le b">0 failures</code>请求，平均响应时间为<code class="fe lb lc ld le b">19ms</code>:</p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/179de570ef9bdb684365df827e996d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Uw0O7Q4YwxTTba3k.png"/></div></div></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="7e88" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">总结</h1><p id="9ff6" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">如果你有任何问题，请在下面留下评论或使用本报告的<a class="ae kc" href="https://github.com/stphivos/todo-api-go-grpc/issues" rel="noopener ugc nofollow" target="_blank"> Github问题跟踪器</a>。</p><p id="4ea3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读，希望这篇帖子对你有所帮助！</p><p id="793d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="od">原载于【pstylianides.com】<a class="ae kc" href="http://pstylianides.com/deploy-and-scale-a-multi-env-service-on-kubernetes/" rel="noopener ugc nofollow" target="_blank"><em class="od"/></a><em class="od">。</em></em></p></div></div>    
</body>
</html>