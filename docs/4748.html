<html>
<head>
<title>React Native security: SSL Pinning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应本机安全性:SSL锁定</h1>
<blockquote>原文：<a href="https://itnext.io/react-native-security-ssl-pinning-cde086210d58?source=collection_archive---------0-----------------------#2020-09-07">https://itnext.io/react-native-security-ssl-pinning-cde086210d58?source=collection_archive---------0-----------------------#2020-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/46c7b6527456d599448e490260e4d889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7mirxFyrmwwpT4DqnOoCA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">反应本机安全性— SSL锁定</figcaption></figure><h1 id="45a2" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">介绍</h1><p id="2271" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在本文中，我们将了解如何在React Native <strong class="lc ir"> iOS </strong>和<strong class="lc ir"> Android </strong>应用中实现<strong class="lc ir"> SSL Pinning </strong>，以保护其免受<a class="ae ly" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank">中间人</a>攻击。互联网上有大量精彩的文章深入讨论SSL证书锁定和移动安全的内部工作原理，因此我们不会讨论其原因或试图说服您为什么需要在您的应用程序中使用它。很有可能，你们大多数人在这里是因为你的项目需要它，所以让我们直接跳到好的部分😉</p><blockquote class="lz ma mb"><p id="ee76" class="la lb mc lc b ld md lf lg lh me lj lk mf mg ln lo mh mi lr ls mj mk lv lw lx ij bi translated">本指南中的示例代码<a class="ae ly" href="https://github.com/ywongweb/BlogReactNativeSSLPinning" rel="noopener ugc nofollow" target="_blank">可从Github </a>获得。克隆这个项目并遵循它可能会对您有所帮助。</p></blockquote><h1 id="a5e8" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">提取证书的公钥</h1><p id="0b42" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在设置SSL锁定逻辑之前，我们首先需要检索服务器证书的<strong class="lc ir">公钥</strong>。打开一个终端会话，输入下面的命令，用您的名字替换<code class="fe ml mm mn mo b">server domain</code>名。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="4f44" class="mx kd iq mo b gy my mz l na nb">openssl s_client -servername busdue.com -connect busdue.com:443 | openssl x509 -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64</span></pre><p id="1ff2" class="pw-post-body-paragraph la lb iq lc b ld md lf lg lh me lj lk ll mg ln lo lp mi lr ls lt mk lv lw lx ij bi translated">如果成功，您应该会看到类似下面的输出。复制base64 <strong class="lc ir">公钥</strong>，我们将在接下来的步骤中用到它。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="f7a9" class="mx kd iq mo b gy my mz l na nb">...<br/>depth=0 CN = <a class="ae ly" href="http://www.busdue.com" rel="noopener ugc nofollow" target="_blank">www.busdue.com</a><br/>verify return:1<br/><strong class="mo ir">dz0GbS1i4LnBsJwhRw3iuZmVcgqpn+AlxSBRxUbOz0k=</strong></span></pre><h1 id="5fe5" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> iOS </strong></h1><p id="dc80" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><em class="mc">(特别大喊到</em><a class="ae ly" href="https://www.linkedin.com/in/daniel-imber-3066858/" rel="noopener ugc nofollow" target="_blank"><em class="mc">Daniel Imber</em></a><em class="mc">与我分享他关于这个话题的大量iOS知识)</em></p><p id="0e88" class="pw-post-body-paragraph la lb iq lc b ld md lf lg lh me lj lk ll mg ln lo lp mi lr ls lt mk lv lw lx ij bi translated">对于我们的iOS版本，我们将使用一个流行的名为<a class="ae ly" href="https://github.com/datatheorem/TrustKit" rel="noopener ugc nofollow" target="_blank"> TrustKit </a>的本地库来处理SSL锁定和验证。首先进入React本地项目的<code class="fe ml mm mn mo b">src/ios</code>文件夹，将下面的<code class="fe ml mm mn mo b">TrustKit</code>条目添加到<code class="fe ml mm mn mo b">Podfile</code></p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="e497" class="mx kd iq mo b gy my mz l na nb">...<br/>target 'MediumSSLPinning' do<br/>  <em class="mc">config </em>= use_native_modules!<br/><br/>  use_react_native!(:path =&gt; <em class="mc">config</em>["reactNativePath"])<br/><strong class="mo ir">  pod 'TrustKit', '1.6.5'<br/>  </strong>...</span></pre><p id="3bcb" class="pw-post-body-paragraph la lb iq lc b ld md lf lg lh me lj lk ll mg ln lo lp mi lr ls lt mk lv lw lx ij bi translated">做一个<code class="fe ml mm mn mo b">pod install</code>,让库正确的链接到你的项目。</p><h2 id="c5ee" class="mx kd iq bd ke nc nd dn ki ne nf dp km ll ng nh kq lp ni nj ku lt nk nl ky nm bi translated"><strong class="ak"> 1。在AppDelegate.m中设置SSL固定</strong></h2><p id="2453" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在XCode和<code class="fe ml mm mn mo b">AppDelegate.m</code>中打开项目，将<a class="ae ly" href="https://github.com/ywongweb/BlogReactNativeSSLPinning/commit/be2871eae4f4fe7ab45b7c43d31086e89f8f653e#diff-032da2fda8147e17cc00fe6a2f310de8" rel="noopener ugc nofollow" target="_blank">这些TrustKit设置代码</a>复制到React本地应用程序初始化方法的开头。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/3cf0176cf96d48de5e92ca0402f31793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ccuTDyJYPcJvbRl4f3RJA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">你可以从这个GitHub提交中抓取这些代码</figcaption></figure><h2 id="d687" class="mx kd iq bd ke nc nd dn ki ne nf dp km ll ng nh kq lp ni nj ku lt nk nl ky nm bi translated"><strong class="ak"> 2。关于iOS方法Swizzling的快速说明</strong></h2><p id="c3e1" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在上面的提交中，你可能已经注意到我们已经启用了<strong class="lc ir">方法swizzling。</strong></p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="dc59" class="mx kd iq mo b gy my mz l na nb">kTSKSwizzleNetworkDelegates: @YES,</span></pre><p id="2a1c" class="pw-post-body-paragraph la lb iq lc b ld md lf lg lh me lj lk ll mg ln lo lp mi lr ls lt mk lv lw lx ij bi translated">原因是，为了拦截网络连接并向我们的应用程序流量添加SSL公钥验证步骤，我们需要访问React Native的<code class="fe ml mm mn mo b">NSURLConnection</code>和<code class="fe ml mm mn mo b">NSURLSession</code>委托。不幸的是，<a class="ae ly" href="https://github.com/facebook/react-native/pull/27701" rel="noopener ugc nofollow" target="_blank">在撰写本文时，这在iOS上还无法实现</a>。因此，我们将利用iOS <strong class="lc ir">方法Swizzling </strong>来改变运行时的<code class="fe ml mm mn mo b">NSURLConnection</code>和<code class="fe ml mm mn mo b">NSURLSession</code>。</p><blockquote class="lz ma mb"><p id="42a5" class="la lb mc lc b ld md lf lg lh me lj lk mf mg ln lo mh mi lr ls mj mk lv lw lx ij bi translated">根据你的应用程序的组成，<strong class="lc ir">方法重组可能不适合你</strong>。如果是这种情况，查看库文档中的<a class="ae ly" href="https://datatheorem.github.io/TrustKit/documentation/Global%20Configuration%20Keys.html#/c:@kTSKSwizzleNetworkDelegates" rel="noopener ugc nofollow" target="_blank">其他建议</a>。</p></blockquote><h2 id="4f22" class="mx kd iq bd ke nc nd dn ki ne nf dp km ll ng nh kq lp ni nj ku lt nk nl ky nm bi translated"><strong class="ak"> 3。确认SSL固定正在工作</strong></h2><p id="1345" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">如果您正在使用<a class="ae ly" href="https://github.com/ywongweb/BlogReactNativeSSLPinning" rel="noopener ugc nofollow" target="_blank">演示应用代码</a>，现在运行它并按下<strong class="lc ir">测试按钮</strong>。您应该看到固定检查通过，并且屏幕上显示一条成功消息。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/8d5119b4defa98b80436fbcac7edbe71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ht9B0R4ZDovzEhhpQ7cT_A.png"/></div></div></figure><h2 id="b7da" class="mx kd iq bd ke nc nd dn ki ne nf dp km ll ng nh kq lp ni nj ku lt nk nl ky nm bi translated">4.测试失败案例和一个陷阱！</h2><p id="152a" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">好吧，现在你可能会问:</p><blockquote class="lz ma mb"><p id="3bb2" class="la lb mc lc b ld md lf lg lh me lj lk mf mg ln lo mh mi lr ls mj mk lv lw lx ij bi translated">看到连接通过并不能证明安全性在起作用，我们需要测试失败的情况。SSL固定安全性的全部目的是在证书不匹配时阻止连接。</p></blockquote><p id="b10f" class="pw-post-body-paragraph la lb iq lc b ld md lf lg lh me lj lk ll mg ln lo lp mi lr ls lt mk lv lw lx ij bi translated">你是对的！因此，让我们用一个无效的公钥替换我们的工作公钥。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="4440" class="mx kd iq mo b gy my mz l na nb">@"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",</span></pre><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/95ba63018e61af02fce0940029e05a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LCB-lFT1rQo3LZ1c0ip9tA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用假的密钥替换当前的工作密钥</figcaption></figure><p id="8a62" class="pw-post-body-paragraph la lb iq lc b ld md lf lg lh me lj lk ll mg ln lo lp mi lr ls lt mk lv lw lx ij bi translated">重新构建应用程序并再次运行。知道了我们的假的<code class="fe ml mm mn mo b">AAAA</code>键应该没有通过锁定检查，你现在可能会期待在屏幕上看到一些错误信息。但是很有可能，你还在盯着同样的<strong class="lc ir">成功</strong>消息，有点迷茫。别担心，你没做错什么，继续读下去。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/628fa0261b2d5f3f1ab1cc4a28cc8819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKOt967XwlLycRBSjOi8KA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">啊啊啊啊啊啊！</figcaption></figure><h2 id="5106" class="mx kd iq bd ke nc nd dn ki ne nf dp km ll ng nh kq lp ni nj ku lt nk nl ky nm bi translated"><strong class="ak"> 5。问题是:为什么即使密钥无效，连接仍然被允许？</strong></h2><p id="b13c" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">造成这种混乱的原因是因为iOS <strong class="lc ir"> NSURLSession维护自己的TLS会话缓存</strong>。因此，即使我们在上一步中替换了密钥，缓存仍然没有获得更改。在开发期间强制缓存重置的一种方法是简单地从模拟器中删除应用程序，然后重新构建它。完成后，再次按下<strong class="lc ir">测试按钮</strong>，我们现在应该会看到预期的<strong class="lc ir">连接被拒绝</strong>消息。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/3fcf0592129ce1e9b24f41e12fb58ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jshRolGFHepFA7EuXteb1w.png"/></div></div></figure><p id="4fea" class="pw-post-body-paragraph la lb iq lc b ld md lf lg lh me lj lk ll mg ln lo lp mi lr ls lt mk lv lw lx ij bi translated">这就是本指南iOS部分的全部内容。</p><h1 id="29ff" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">安卓，简单多了</strong><strong class="ak">。</strong></h1><p id="c449" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在Android方面，事情要简单得多，因为React原生Android已经公开了启用SSL锁定所需的方法。此外，React原生Android使用OKHttp进行网络调用，这个库带有官方的SSL pin支持。</p><h2 id="5a91" class="mx kd iq bd ke nc nd dn ki ne nf dp km ll ng nh kq lp ni nj ku lt nk nl ky nm bi translated">1.使用SSL固定创建OkHttpClientFactory</h2><p id="e911" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在与您的Android应用程序的<code class="fe ml mm mn mo b">MainApplication.java</code>文件相同的文件夹中，创建一个新的Java文件并命名为<code class="fe ml mm mn mo b">SSLPinnerFactory.java</code>，粘贴<a class="ae ly" href="https://github.com/ywongweb/BlogReactNativeSSLPinning/commit/7ca12ad8100ef8dd86e0d7e089935bfac397cda5#diff-538b54548ab8353cbc639d28933dcff4" rel="noopener ugc nofollow" target="_blank"> this commit </a>的内容。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/25247a5016658d9a79a4248c7c271742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5QvPNm5vkO46uDuRhgqlg.png"/></div></div></figure><p id="3f38" class="pw-post-body-paragraph la lb iq lc b ld md lf lg lh me lj lk ll mg ln lo lp mi lr ls lt mk lv lw lx ij bi translated">在OkHttp上启用SSL固定只是在客户端构建器构造器期间提供一个<code class="fe ml mm mn mo b">CertificatePinner</code>配置的问题(参见L19)。</p><p id="5660" class="pw-post-body-paragraph la lb iq lc b ld md lf lg lh me lj lk ll mg ln lo lp mi lr ls lt mk lv lw lx ij bi translated">我想在上面的代码中强调的一点是<a class="ae ly" href="https://github.com/ywongweb/BlogReactNativeSSLPinning/commit/7ca12ad8100ef8dd86e0d7e089935bfac397cda5#diff-538b54548ab8353cbc639d28933dcff4R17" rel="noopener ugc nofollow" target="_blank">第17行</a>，我们将使用React Native <code class="fe ml mm mn mo b">OkHttpClientProvider</code>上公开的一个公共方法，返回一个<code class="fe ml mm mn mo b">OkHttpClientBuilder</code> <a class="ae ly" href="https://github.com/facebook/react-native/blob/9b34aa261c272d96829c9a7d5b166594b3162f9d/ReactAndroid/src/main/java/com/facebook/react/modules/network/OkHttpClientProvider.java#L62" rel="noopener ugc nofollow" target="_blank">和所有默认的</a>，而不是通过提供确切的起始值来构建我们自己的<code class="fe ml mm mn mo b">OKHttpClient</code>构建器。这使得我们的代码更加经得起未来的考验，因为未来React本机版本中的任何更改都将自动包含在内。</p><h2 id="b439" class="mx kd iq bd ke nc nd dn ki ne nf dp km ll ng nh kq lp ni nj ku lt nk nl ky nm bi translated">2.指示React Native使用我们增强的OkHttpClient</h2><p id="f4a8" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在<code class="fe ml mm mn mo b">MainApplication.java</code>的<code class="fe ml mm mn mo b">OnCreate()</code>方法中，添加来自<a class="ae ly" href="https://github.com/ywongweb/BlogReactNativeSSLPinning/commit/7ca12ad8100ef8dd86e0d7e089935bfac397cda5#diff-03011bf906df867defe5a8b6e38b95ddR49" rel="noopener ugc nofollow" target="_blank">的代码，this commit </a>和React Native <a class="ae ly" href="https://github.com/facebook/react-native/blob/9b34aa261c272d96829c9a7d5b166594b3162f9d/ReactAndroid/src/main/java/com/facebook/react/modules/network/OkHttpClientProvider.java#L56" rel="noopener ugc nofollow" target="_blank">现在将使用</a>提供的客户端工厂来代替。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="f21e" class="mx kd iq mo b gy my mz l na nb">OkHttpClientProvider.setOkHttpClientFactory(new SSLPinnerFactory());</span></pre><p id="2bc4" class="pw-post-body-paragraph la lb iq lc b ld md lf lg lh me lj lk ll mg ln lo lp mi lr ls lt mk lv lw lx ij bi translated">现在运行并测试应用程序，就像我们对iOS版本所做的那样，一切都应该正常工作。Android HTTP客户端没有与iOS相同的SSL会话缓存问题，因此无需在每次更改后删除应用程序，只需从Android Studio重新运行应用程序即可。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/916abbf733e4d21f95240e9e20804087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlbEubpsAQeqkV-_Qg0EQw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Android SSL固定</figcaption></figure><h1 id="396d" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">你已经到达文章的结尾。</h1><p id="d0c1" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">谢谢你看完。如果你觉得这个指南有用，请留下几个(或50个)掌声👏这样就能接触到更多的人。欢迎所有的意见和建议，保持安全和快乐的编码！</p></div></div>    
</body>
</html>