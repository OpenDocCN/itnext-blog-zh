<html>
<head>
<title>OpenShift Service Mesh essentials — Part III — Data Plane</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenShift服务网格基础—第三部分—数据平面</h1>
<blockquote>原文：<a href="https://itnext.io/openshift-service-mesh-essentials-part-iii-data-plane-341ce477c269?source=collection_archive---------0-----------------------#2020-10-19">https://itnext.io/openshift-service-mesh-essentials-part-iii-data-plane-341ce477c269?source=collection_archive---------0-----------------------#2020-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ffc23474f60c944b8b8b90dfd244bb02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x551pAkumNDg6sPEh_mvww.jpeg"/></div></div></figure><p id="e875" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener">上一篇文章</a>中，我们已经看到了一些最重要的服务网格控制平面方面，现在是数据平面的时候了。</p><p id="fda0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想查看控制平面部分，请跳转到:</p><div class="kx ky gp gr kz la"><a href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener follow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">OpenShift服务网格基础—第二部分—控制平面</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">在第二篇文章中，我们将介绍OpenShift服务网格控制平面的准备和部署。</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">luis-javier-arizmendi-alonso.medium.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jw la"/></div></div></a></div><p id="4a01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者如果你想从头开始:</p><div class="kx ky gp gr kz la"><a href="https://medium.com/swlh/openshift-service-mesh-essentials-part-i-the-why-and-what-of-it-a3ef09bf8aa8" rel="noopener follow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">open shift Service Mesh Essentials—第一部分—原因和内容</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">在这第一篇文章中，我们将讨论一些关于OpenShift服务网格的介绍性问题，包括它的特性…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">medium.com</p></div></div><div class="lj l"><div class="lp l ll lm ln lj lo jw la"/></div></div></a></div><p id="3cef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者从展示服务网格功能的一些示例开始:</p><div class="kx ky gp gr kz la"><a href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-iv-features-routing-3189dae64615" rel="noopener follow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">OpenShift服务网格基础—第四部分—功能:路由</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">了解如何使用高级路由来修改应用程序的行为，而不包括API网关或…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">luis-javier-arizmendi-alonso.medium.com</p></div></div><div class="lj l"><div class="lq l ll lm ln lj lo jw la"/></div></div></a></div><p id="7048" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将探索OpenShift服务网格数据平面。这里的想法是通过展示如何发布服务网格应用程序来了解数据平面，但不使用扩展的Istio特性(即智能路由、控制策略等)，因此我们将获得标准OpenShift SDN功能，但使用服务网格。Istio特性的解释将在以后的文章中完成。</p><h1 id="5a89" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">特使边车集装箱</h1><p id="f6df" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">在这一节中，我们将检查特使边车是如何注入到吊舱中的，以及当你包括它时有什么含义(即。流量重定向、多点注释移除等)。</p><h2 id="a935" class="mu ls iq bd lt mv mw dn lx mx my dp mb kj mz na mf kn nb nc mj kr nd ne mn nf bi translated">边车容器注射</h2><p id="4514" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">如果你阅读官方Istio文档，你会发现<a class="ae kw" href="https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/" rel="noopener ugc nofollow" target="_blank">有两种方法可以在应用程序盒</a>中注入代理边车:手动和自动注入。</p><p id="43b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在OpenShift服务网格中，我们也有这两个选项，但是正如在<a class="ae kw" href="https://medium.com/@luis.ariz/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener"> OpenShift服务网格要点—第二部分—控制平面</a>文章中所述，Istio文档所提出的内容与OpenShift中自动边车注入的方式之间有一个主要区别，而默认的Istio配置将边车注入到任何带有<code class="fe ng nh ni nj b">istio-injection=enabled </code>标签的命名空间中的pod中。 在OpenShift服务网格中，该标签不包含在名称空间中，而是包含在部署对象的注释中，这提供了额外的灵活性，同时将服务网格内部和外部的应用程序包含在同一个名称空间中，例如，防止构建或部署pod也与sidecar一起注入。</p><p id="873a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自动注入非常棒，因为它不仅简化了部署，还处理了额外的Envoy代理容器生命周期。假设有一个新版本的OpenShift服务Mesh Envoy sidecar代理。如果您使用自动注入，sidecar升级将像重新启动pod一样简单(服务网格操作符中的自动更新策略将升级控制平面，但它不会自动重新启动pod以升级sidecar，确保它不会影响您的应用程序)，但如果您使用手动注入，您将需要逐个更改Envoy sidecar容器映像的部署定义，这就是为什么自动注入是在您的pod中包含sidecar代理的推荐方法。</p><p id="93f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能想知道自动边车注射是如何工作的？注射是由准入控制器触发的，但是……什么是准入控制器？…让我们过一遍…</p><p id="4827" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<a class="ae kw" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" rel="noopener ugc nofollow" target="_blank">准入控制器是Kubernetes API服务器代码</a>的一部分，它可以在请求被集群执行之前，但在请求被认证和授权之后拦截API请求，因此它就像是集群做您想要做的事情之前要跨越的最后一个堡垒。Kubernetes 内置了<a class="ae kw" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do" rel="noopener ugc nofollow" target="_blank">多个准入控制器，例如，如果您已经阅读了我关于</a><a class="ae kw" href="https://medium.com/@luis.ariz/security-zones-in-openshift-worker-nodes-part-i-introduction-4f85762962d7" rel="noopener">如何在单个OpenShift集群</a>中配置不同安全区域的文章，您会记得在上一部分中，当我们<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/security-zones-in-openshift-worker-nodes-part-iv-user-restrictions-and-recap-5ec0ba7bdaf9">通过在Kubernetes对象中包含额外的注释来修改包含白名单容忍</a>的默认名称空间创建模板时，我们实际上使用的是<a class="ae kw" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#podtolerationrestriction" rel="noopener ugc nofollow" target="_blank">podcallationrestriction准入控制器</a>。</p><p id="15e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是也有一种通过使用webhooks 来包含额外控制器的方法，你可以有两种类型的准入控制器:</p><ul class=""><li id="4654" class="nk nl iq ka b kb kc kf kg kj nm kn nn kr no kv np nq nr ns bi translated"><strong class="ka ir">验证准入webhook，</strong>允许在验证您的请求期间实施自定义管理策略。</li><li id="5c4a" class="nk nl iq ka b kb nt kf nu kj nv kn nw kr nx kv np nq nr ns bi translated"><strong class="ka ir">变异准入webhook </strong>:允许您更改请求以实施自定义默认值。</li></ul><p id="d465" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如这里提到的<a class="ae kw" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks" rel="noopener ugc nofollow" target="_blank"/>，为了注册准入webhooks，你必须创建<code class="fe ng nh ni nj b">MutatingWebhookConfiguration</code>或<code class="fe ng nh ni nj b">ValidatingWebhookConfiguration</code> API对象。</p><p id="669a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们用来在POD中自动注入sidecar代理的是一个变异准入webhook，所以我们可以看一下<em class="ny">变异Webhookconfiguration </em>对象，您将看到每个控制平面名称空间至少有一个这样的对象，另外还有一个由Maistra操作符使用:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/6ce81f0e88aa07abd046a2965620e3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*o1fn5I5VO2lWlOu6qv7TsQ.gif"/></div></div></figure><p id="4c03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以打开一个边车注射器webhook，看看YAML定义文件，你会看到一个“<em class="ny"> webhooks </em>”部分，如下所示:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/cce4bf48503568a7e62f4c3125646329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*1O4xEWm0TPZJy6HEx8F1zg.png"/></div></figure><p id="236b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当apiserver接收到一个与<code class="fe ng nh ni nj b">rules</code>之一匹配的请求时，apiserver向webhook发送一个<code class="fe ng nh ni nj b">admissionReview</code>请求，如<code class="fe ng nh ni nj b">clientConfig</code>中所指定的。在我们的准入控制器定义中，当我们试图创建一个POD时，我们强制从您的控制平面名称空间调用<code class="fe ng nh ni nj b">istio-sidecar-injector</code>服务的<code class="fe ng nh ni nj b">/inject</code>端点。如果部署包含<code class="fe ng nh ni nj b">sidecar.isito.io/inject="true"</code>注释，这将最后“添加”和配置(如果您使用<code class="fe ng nh ni nj b">sidecar.maistra.io/proxyEnv</code>注释，您也可以将环境变量注入到Envoy代理中)您试图创建的POD中的附加代理sidecar容器。</p><p id="e880" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在一个测试应用程序中注入sidecar。首先，我们将部署应用程序，我将使用这个部署:</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="c002" class="mu ls iq nj b gy oj ok l ol om">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: hello<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: hello<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: hello<br/>    spec:<br/>      containers:<br/>      - name: hello<br/>        image: openshift/hello-openshift<br/>        ports:<br/>        - containerPort: 8080</span></pre><p id="6086" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将在位于名称空间<em class="ny"> istio-system </em>中的<em class="ny"> project-a1 </em>中创建该应用程序，该名称空间包含在OpenShift服务网格<em class="ny">控制平面-a </em>(还记得我们在上一篇文章中创建的<em class="ny"> ServiceMeshMemberRoll </em>对象)中，因此，如果您检查该控制平面的Kiali接口，您应该会看到该应用程序正在运行，但是您会看到一条消息，指出此类工作负载没有所需的代理</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/941f5ee0c43785046556c20efb02a06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vECy7SOVsC5hVBfI_Af8jA.gif"/></div></div></figure><blockquote class="on oo op"><p id="c20e" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated">注意:除了部署标准的Kubernetes对象，OpenShift还提供了DeploymentConfig对象，它带来了一些扩展功能。如果您使用DeploymentConfigs而不是deployment，您需要知道我在Kiali中发现的行为(在最新版本中，如OpenShift 4.5中的1.12)是它只显示基本的Kubernetes对象，如部署、构建、服务等，而不显示OpenShift特定的对象(即DeploymentConfigs)作为UI中的工作负载。</p><p id="ff5c" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated">如果您使用部署或部署配置，服务网格(包括边卡自动注入)将独立工作(目前在此版本中),唯一会失去的是工作负载Kiali可见性。如果您想查看这一点，可以部署相同的应用程序，但使用DeploymentConfig对象:</p></blockquote><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="d9f0" class="mu ls iq nj b gy oj ok l ol om">apiVersion: apps.openshift.io/v1<br/>kind: DeploymentConfig<br/>metadata:<br/>  name: helloDC<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>      app: helloDC<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: helloDC<br/>    spec:<br/>      containers:<br/>      - name: helloDC<br/>        image: openshift/hello-openshift<br/>        ports:<br/>        - containerPort: 8080</span></pre><p id="8003" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在让我们使用<em class="ny">sidecar.istio.io/inject:“真”</em>注释注入边车。您应该以这种方式在部署中包含注释(检查粗体文本):</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="50bc" class="mu ls iq nj b gy oj ok l ol om">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: hello<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: hello<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: hello<br/><strong class="nj ir">      annotations:<br/>        sidecar.istio.io/inject: "true"</strong><br/>    spec:<br/>      containers:<br/>      - name: hello<br/>        image: openshift/hello-openshift<br/>        ports:<br/>        - containerPort: 8080</span></pre><p id="cd75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以检查在包含注释之后，与部署相关联的窗格将如何拥有一个附加的"<em class="ny"> istio-proxy </em>"容器，该容器是特使代理边车:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/10450558ab3806a9b2ee311f02ac19d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_g1tJL-TXRrgUU6OFHgPXA.gif"/></div></div></figure><p id="ce01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以检查一旦完成，Kiali界面上的“丢失边车”信息就消失了。</p><p id="2365" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于边车的另一件事，你还记得在上一篇文章中的<a class="ae kw" href="https://medium.com/@luis.ariz/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener">吗，当我们创建控制平面-服务网状配置时，我们包括了我们的边车的请求和限制。(检查以下内容)</a></p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="74e9" class="mu ls iq nj b gy oj ok l ol om">apiVersion: maistra.io/v1<br/>kind: ServiceMeshControlPlane<br/>metadata:<br/>  name: controlplane-A<br/>  namespace: istio-system<br/>spec:<br/>  version: v1.1<br/>  istio:<br/>    global:<br/>      proxy:<br/>        resources:<br/>          requests:<br/>            cpu: 20m<br/>            memory: 200Mi<br/>          limits:<br/>            cpu: 3000m<br/>            memory: 2048Mi<br/> ...</span></pre><p id="0310" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以检查容器中是否通知了QoS策略:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/9ee2563260fbde1721142c3b64f69302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*QvcRVLX55rSG509JlbIvDQ.png"/></div></figure><p id="d255" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回顾一下，如果我们将我们的应用程序部署在与另一个已经部署的服务网格控制平面(controlplane-b)关联的名称空间(<em class="ny"> project-b1 </em>)中，而我们没有设置QoS值，会发生什么情况:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/39081a46803598369edbb72feaaf8573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NVpjb8XXSAFuja5OTedwVg.gif"/></div></div></figure><p id="8b8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，有一个默认设置已经被应用在这种情况下，没有限制的边车容器。</p><h2 id="95fe" class="mu ls iq bd lt mv mw dn lx mx my dp mb kj mz na mf kn nb nc mj kr nd ne mn nf bi translated">自动将POD流量重定向到特使代理</h2><p id="f81a" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">现在，我们的应用程序容器和新的sidecar容器一起在POD中运行，我们如何确保流量是由这个新的sidecar而不是我们自己的容器管理的呢？好消息是，一切都是自动为您设置的，您不必担心这一点，但如果您关心它实际上是如何工作的，您就在正确的位置，因为我们将探索它。</p><blockquote class="on oo op"><p id="aabc" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated">注意:自动流量重定向到特使代理容器使代理侧柜对您的应用程序透明…嗯，几乎透明，因为这种强制重定向意味着在特使代理启动之前，POD将无法获得连接，请考虑这一点，因为我发现一些应用程序需要在第一(子)秒内连接到其他地方才能工作，如果应用程序容器在POD上的特使代理之前启动，前者将无法在此期间访问外部资源</p></blockquote><p id="88b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上一篇文章中，我描述了<a class="ae kw" href="https://medium.com/@luis.ariz/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener"> OpenShift服务网格控制平面，</a>您看到了Maistra操作符(服务网格操作符)如何在<em class="ny"> openshift-operators </em>名称空间中部署一个名为“<em class="ny"> istio-node </em>的DaemonSet，它在每个节点中部署了一个<em class="ny"> istio-cni </em> POD，用于监视该节点中是否调度了服务网格工作负载，并在这种情况下修改节点<em class="ny"> iptables现在我们来看看那些<em class="ny"> iptable </em>规则。</em></p><p id="afa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ny"> istio-cni </em>资源在POD运行的网络名称空间内配置<em class="ny"> iptables </em>规则，因此它仅影响该POD上的入/出流量，而不是节点中的全局流量。如果我们想检查<em class="ny"> istio-cni </em>正在做什么，我们需要一种方法来检查网络名称空间内的<em class="ny"> iptable </em>规则。我来自OpenStack世界，在那里我们曾经通过使用<code class="fe ng nh ni nj b"><strong class="ka ir">ip netns exec</strong></code>命令在特定的网络名称空间中运行Linux命令，但是如果您曾经处理docker容器，您可能已经使用过<code class="fe ng nh ni nj b"><strong class="ka ir">nsenter</strong></code>命令，因为<code class="fe ng nh ni nj b"><strong class="ka ir">ip netns exec</strong></code>命令只对在<em class="ny"> /var/run/netns </em>中列出的名称空间有用，docker默认不会将其名称空间放在那里。</p><p id="2b48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，在这里我们可以使用<code class="fe ng nh ni nj b"><strong class="ka ir">ip netns exec</strong></code>或<code class="fe ng nh ni nj b"><strong class="ka ir">nsenter</strong></code>命令，我会告诉你怎么做。</p><p id="bf38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步是常见的，我们需要知道在我们的节点上运行的任何POD容器id(在我们的示例中，我们有两个容器在我们的POD中运行，app容器和sidecar容器，因此将有两个不同的容器id绑定到这个POD)。该信息包含在我们的POD的描述中(查找“<strong class="ka ir"> cri-o </strong>”，作为CRIO容器运行时)</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/cfd434629004e566a64467ab0e684df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KkiV9JSXoyo8Zi-hebLkHg.gif"/></div></div></figure><p id="5883" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要知道这个容器ID的详细信息。为此，我们需要跳转到POD正在运行的节点，并运行以下命令:</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="2f86" class="mu ls iq nj b gy oj ok l ol om">crictl inspect --output json &lt;container ID&gt;</span></pre><p id="8990" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这会给我们很多有用的信息，但我们只需要关注一件事。根据您是否想要使用<code class="fe ng nh ni nj b"><strong class="ka ir">ip netns exec</strong></code>或<code class="fe ng nh ni nj b"><strong class="ka ir">nsenter</strong></code>命令，您将需要与容器相关联的网络名称空间ID或进程ID，因此这里的最佳想法是，如果您打算使用<code class="fe ng nh ni nj b"><strong class="ka ir">ip netns exec</strong></code>，则使用“<em class="ny"> netns </em>进行grep，如果您打算使用<code class="fe ng nh ni nj b"><strong class="ka ir">nsenter</strong></code>，则使用“<em class="ny"> pid </em></p><p id="a694" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦获得了网络名称空间id或进程id，就可以在名称空间中运行所需的命令。</p><p id="7a80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用<code class="fe ng nh ni nj b"><strong class="ka ir">ip netns exec</strong></code>你可以跑</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="e131" class="mu ls iq nj b gy oj ok l ol om">ip netns exec &lt;namespace id&gt; &lt;my command&gt;</span></pre><p id="f3b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe ng nh ni nj b"><strong class="ka ir">nsenter</strong></code>，您的命令将是(<code class="fe ng nh ni nj b"><strong class="ka ir">-n</strong></code>意味着该命令将在进程正在使用的网络名称空间中运行):</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="b62b" class="mu ls iq nj b gy oj ok l ol om">nsenter -t &lt;pid&gt; -n &lt;my command&gt;</span></pre><p id="3932" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们想要检查iptables NAT规则，所以“我的命令”是:</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="47bc" class="mu ls iq nj b gy oj ok l ol om">iptables -t nat -S</span></pre><p id="6145" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回顾一个使用这两个命令的端到端示例，从<code class="fe ng nh ni nj b"><strong class="ka ir">ip netns exec</strong></code>命令开始:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/e07ea1b6b89b243e0ab98f7291cb8cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VOxTh2qzBrnnpKH7ElaaaQ.gif"/></div></div></figure><p id="a156" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在有了<code class="fe ng nh ni nj b"><strong class="ka ir">nsenter</strong></code></p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/3f13aedcec05600dc0d0b0a68c727f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jWMY_BK67A03NmIRoLpzCA.gif"/></div></div></figure><p id="3fd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两个命令都提供了以下输出:</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="6295" class="mu ls iq nj b gy oj ok l ol om">-P PREROUTING ACCEPT<br/>-P INPUT ACCEPT<br/>-P POSTROUTING ACCEPT<br/>-P OUTPUT ACCEPT<br/>-N ISTIO_REDIRECT<br/>-N ISTIO_IN_REDIRECT<br/>-N ISTIO_INBOUND<br/>-N ISTIO_OUTPUT<br/>-A PREROUTING -p tcp -j ISTIO_INBOUND<br/>-A OUTPUT -p tcp -j ISTIO_OUTPUT<br/><strong class="nj ir">-A ISTIO_REDIRECT -p tcp -j REDIRECT --to-ports 15001<br/></strong>-A ISTIO_IN_REDIRECT -p tcp -j REDIRECT --to-ports 15001<br/><strong class="nj ir">-A ISTIO_INBOUND -p tcp -m tcp --dport 8080 -j ISTIO_IN_REDIRECT</strong><br/>-A ISTIO_OUTPUT -s 127.0.0.6/32 -o lo -j RETURN<br/>-A ISTIO_OUTPUT ! -d 127.0.0.1/32 -o lo -j ISTIO_IN_REDIRECT<br/>-A ISTIO_OUTPUT -m owner --uid-owner 1000710001 -j RETURN<br/>-A ISTIO_OUTPUT -m owner --gid-owner 1000710001 -j RETURN<br/>-A ISTIO_OUTPUT -d 127.0.0.1/32 -j RETURN<br/>-A ISTIO_OUTPUT -j ISTIO_REDIRECT</span></pre><p id="d064" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些规则使得所有进出应用程序容器的流量都被重定向到pod的端口15001，在本例中，我们的应用程序"<em class="ny"> hello </em>"正在侦听端口8080，但是您可以看到8080最终是如何被重定向到15001的…但是在POD的那个端口上侦听的是什么呢？</p><p id="53bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您检查POD YAML定义，您将不会找到任何对端口15001的引用，这是因为在本地侦听POD，它不会“暴露”在外部。您可以通过在POD网络名称空间中运行以下命令来检查端口是否正在监听POD和与其相关联的进程(记住如何使用<code class="fe ng nh ni nj b"><strong class="ka ir">ip netns exec</strong></code>或<code class="fe ng nh ni nj b"><strong class="ka ir">nsenter</strong></code>命令)</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="3881" class="mu ls iq nj b gy oj ok l ol om">ss -nlp | grep 15001</span></pre><p id="f140" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是使用<code class="fe ng nh ni nj b"><strong class="ka ir">nsenter</strong></code>命令的输出</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="0094" class="mu ls iq nj b gy oj ok l ol om">sh-4.4# nsenter -t 1765412 -n ss -nlp | grep 15001</span><span id="b2ed" class="mu ls iq nj b gy ou ok l ol om">tcp                LISTEN              0                    128                                                                                         0.0.0.0:15001              0.0.0.0:*      users:(("envoy",<strong class="nj ir">pid=1765590</strong>,fd=63))</span></pre><p id="8783" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到PID 1765590是如何侦听该端口的，让我们看看使用<code class="fe ng nh ni nj b"><strong class="ka ir">ps aux</strong></code>的节点上是什么:</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="fe5c" class="mu ls iq nj b gy oj ok l ol om">sh-4.4# ps aux | grep 1765590</span><span id="d112" class="mu ls iq nj b gy ou ok l ol om">1000710+ 1765590  0.1  0.2 173012 49724 ?        Sl   08:45   0:16 <strong class="nj ir">/usr/local/bin/envoy</strong> -c /etc/istio/proxy/envoy-rev0.json --restart-epoch 0 --drain-time-s 45 --parent-shutdown-time-s 60 --service-cluster hello.project-a1 --service-node sidecar~10.129.2.106~hello-7d55b4456d-sv6lw.project-a1~project-a1.svc.cluster.local --max-obj-name-len 189 --local-address-ip-version v4 --log-format [Envoy (Epoch 0)] [%Y-%m-%d %T.%e][%t][%l][%n] %v -l warning --component-log-level misc:error --concurrency 2</span><span id="3654" class="mu ls iq nj b gy ou ok l ol om">root     2313349  0.0  0.0   9180  1084 ?        S+   11:21   0:00 grep 1765590</span></pre><p id="8390" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想完全确定PID与我们的POD的sidecar容器相关联，我们可以按照上面提到的过程获取该容器的根PID(但是获取的是<em class="ny"> istio-proxy </em>容器的CRIO ID，而不是<em class="ny"> hello </em>容器的CRIO ID ),您将会看到(在我的例子中是1765517)…哦，令人惊讶的是，这不是侦听15001端口的同一个PID (1765590 ),这是一个</p><p id="105c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为<em class="ny"> istio-proxy </em>容器的根进程，即您使用CRIO ID (1765517)找到的那个，是“主”进程(<em class="ny"> pilot-agent </em>)的根进程，但是该进程启动了另一个子进程，即与envoy命令关联的PID (1765590)。通过使用<code class="fe ng nh ni nj b"><strong class="ka ir">pstree</strong></code>命令和您在端口15001上监听的PID，您可以很容易地知道这一点，格式如下:</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="b44f" class="mu ls iq nj b gy oj ok l ol om">pstree -p -s &lt;envoy process ID listening on 15001&gt;</span></pre><p id="9842" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将为您提供所有父节点的视图，在那里您肯定会找到从CRIO ID inspect中获得的根PID(在我的例子中是1765517)。这是我的输出(忘记“+”下面的流程，那些是具有相同分支的<a class="ae kw" href="https://linux.die.net/man/1/pstree" rel="noopener ugc nofollow" target="_blank">流程):</a></p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ov"><img src="../Images/5061a0bc866b52109789368dd9c7b05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATUMPitNzcCPO6rnO8xawQ.png"/></div></div></figure><p id="98e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，现在您可以完全确定，您的所有POD流量都是由您注入的边车容器管理的(如果您不相信我在此测试之前提到的话)</p><h2 id="ae96" class="mu ls iq bd lt mv mw dn lx mx my dp mb kj mz na mf kn nb nc mj kr nd ne mn nf bi translated">Multus和自动Istio边车注射</h2><p id="a4f8" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">您可能还记得在<a class="ae kw" href="https://medium.com/@luis.ariz/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener">上一篇文章中，当我介绍不同的控制平面配置选项</a>时，Multus注释在默认情况下不会被automatic Envoy sidecar注入器保存，但是您有一个控制平面配置变量(<em class="ny"> sidecarInjectorWebhook </em>)允许维护它们。我们在<em class="ny">控制平面-a </em>中配置了该选项，但在<em class="ny">控制平面-b </em>中没有，所以让我们检查一下这是否可行。</p><blockquote class="on oo op"><p id="1202" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong> : Multus接口不会是服务网格的一部分，它将是应用程序的一个额外网络访问，但服务网格功能不能在那里使用。</p></blockquote><p id="963d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要在集群中配置额外的网络，并测试其工作情况。在我之前的一个博客系列中，特别是在OpenShift worker nodes中的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/security-zones-in-openshift-worker-nodes-part-iii-network-configuration-3a887854a4d">安全区域—第三部分—网络配置</a>文章中，我们回顾了在OpenShift中创建网络设置的不同方式。在当前版本OpenShift 4.5中，我们仍然没有默认可用的<a class="ae kw" href="https://github.com/nmstate/kubernetes-nmstate" rel="noopener ugc nofollow" target="_blank"> <em class="ny"> nmstate </em> </a>对象(在路线图上)，因此我可以在我的集群中安装OpenShift虚拟化来访问该API，或者使用“标准”方法修改网络集群操作符对象。在这种情况下，我将使用后者。</p><p id="1d4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的工作节点中，我有两个接口，一个由OpenShift SDN使用，另一个我将使用Multus提供对我的pod的直接网络访问。您可以使用具有<em class="ny"> clusteradmin </em>权限的OpenShift控制台检查节点中的可用接口。在我的例子中，<em class="ny"> ens3 </em>是SDN的集群网络，而<em class="ny"> ens4 </em>将是Multus使用的网络(该节点已经有了一个IP，因为DHCP在该接口上启用):</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/801bdb41f8a51d1bf0cc78298154799b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9njwsMW4oEHbESxXVIbw1A.gif"/></div></div></figure><p id="5be6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，在OpenShift中启用附加网络的方法是修改网络集群操作符。</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="bd98" class="mu ls iq nj b gy oj ok l ol om">apiVersion: operator.openshift.io/v1<br/>kind: Network<br/>...<br/>spec:<br/>...<br/>  additionalNetworks:<br/>    - name: prov-net<br/>      namespace: project-a1<br/>      rawCNIConfig: '{ "cniVersion": "0.3.1", "type": "macvlan", "capabilities": { "ips": true }, "master": "ens4", "mode": "bridge", "ipam": { "type": "dhcp" } }'<br/>      type: Raw<br/>    - name: prov-net<br/>      namespace: project-b1<br/>      rawCNIConfig: '{ "cniVersion": "0.3.1", "type": "macvlan", "capabilities": { "ips": true }, "master": "ens4", "mode": "bridge", "ipam": { "type": "dhcp" } }'<br/>      type: Raw<br/>...</span></pre><p id="fb64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">紧接着，一个新的<em class="ny">NetworkAttachmentDefinition</em>被自动创建在每个已配置的名称空间中(在本例中为<em class="ny"> project-a1 </em>和<em class="ny"> project-b1 </em>)，该名称空间可用于向pod分配额外的网络</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/a49ace9c27c1050d989b6e9513b68286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PeTgjdx9cB24OWKOjep7Bg.gif"/></div></div></figure><p id="5046" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试Multus配置，您可以创建一个带有附加NIC的POD并测试连接性(我ping我的默认网关192.168.100.1):</p><blockquote class="on oo op"><p id="ba3a" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated">注意:我在这里使用centos/tools容器映像，这样我就可以使用POD bash来运行一些测试(openshift/hello-openshift没有终端)</p></blockquote><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="11f9" class="mu ls iq nj b gy oj ok l ol om">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: multus-test<br/><strong class="nj ir">  annotations:<br/>    k8s.v1.cni.cncf.io/networks: '[<br/>        {<br/>                "name": "prov-net"<br/>        }<br/>    ]'</strong><br/>spec:<br/>  containers:<br/>  - name: example-pod<br/>    command: ["/bin/bash", "-c", "sleep 99999999999"]<br/>    image: centos/tools</span></pre><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/67c4b55e82b602d720efbba1bd8e4e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XNxtYp6GO7eBzd47cVLIMQ.gif"/></div></div></figure><p id="7817" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在我们确信multus正在工作，所以让我们创建两个部署，包括sidecar注入和Multus注释，一个在<em class="ny">项目-a1 </em>(连接到<em class="ny">控制平面-a </em>，其中选项应该保留Multus注释)中，另一个在<em class="ny">项目-b1中。</em>您将看到附加接口仅在前一种情况下是如何配置的，此时Multus注释被保留。</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="0ab8" class="mu ls iq nj b gy oj ok l ol om">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: test-sidecar-multus<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: test-sidecar-multus<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: test-sidecar-multus<br/><strong class="nj ir">      annotations:<br/>        sidecar.istio.io/inject: "true"<br/>        k8s.v1.cni.cncf.io/networks: '[<br/>            {<br/>              "name": "prov-net"<br/>            }<br/>          ]'</strong><br/>    spec:<br/>      containers:<br/>      - name: test-sidecar-multus<br/>        command: ["/bin/bash", "-c", "sleep 99999999999"]<br/>        image: centos/tools</span></pre><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/89b8b0187085bccd600b6fb1e9ab99bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*24p0TP9yHFLjuimhDw245A.gif"/></div></div></figure><h1 id="9320" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">从群集外部访问应用程序</h1><p id="0b5e" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">我们的服务网格上运行着“Hello World”应用程序，现在我们想从OpenShift集群外部访问它。</p><h2 id="7bc2" class="mu ls iq bd lt mv mw dn lx mx my dp mb kj mz na mf kn nb nc mj kr nd ne mn nf bi translated">服务</h2><p id="cb26" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">Istio创建了自己的服务注册中心，其中自动填充了安装它的OpenShift/Kubernetes集群提供的信息，特别是服务对象(以及相关的端点)。所以为了让Istio了解一个服务，我们需要创建一个标准的“服务”Kubernetes对象。</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="941a" class="mu ls iq nj b gy oj ok l ol om">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: hello<br/>  labels:<br/>    app: hello<br/>spec:<br/>  ports:<br/>  - port: 8080<br/>    name: http<br/>  selector:<br/>    app: hello</span></pre><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/8cb710738dfffa1758074358bd60c1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EqgXxD1bhsWFEcRWA3SG_Q.gif"/></div></div></figure><p id="4abb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您没有删除我们创建的用于显示Multus with sidecar container injection的POD，您可以测试该服务是否工作正常(记住使用正确的服务端口，在本例中为8080)</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/1c89c11e275ee0635edaa52854041a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*B2o4kuQCtAjw4ssyNLSi_w.gif"/></div></div></figure><p id="c9b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们创建了OpenShift服务，Istio也会知道它。您可以查看Kiali是如何为其专门开辟一个部分的:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/e793586d762e6946c6ef49db634390b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZIvuG36Crnlatp-o0Smqhg.png"/></div></div></figure><p id="d448" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">使用常规路由</strong>在“<em class="ny"> Istio名称空间</em>中公开服务</p><p id="11a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们仍然没有使用任何特定的Istio对象(我们使用了一个Kubernetes服务对象)，如果我们希望继续使用“常规”对象来公开此服务(考虑到我们将失去Istio功能)，我们现在将创建一个路由/入口来公开集群外部的内部服务…让我们尝试一下:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/cb82d5357d8fcc9bfb289809c34d0043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bv9jF4xQMjBbtouoWzL3xQ.gif"/></div></div></figure><p id="b0b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“常规”路由对象不起作用，为什么？因为您不应该使用该标准对象来公开您的服务网格应用程序。如果您还记得上一篇文章中的<a class="ae kw" href="https://medium.com/@luis.ariz/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener">，作为服务网格运营商引入的修改的一部分，当您将名称空间作为特定服务网格控制平面的一部分时，会有一系列网络策略来阻止不是来自Istio入口网关的入站流量， 这是网格的预期入口点，您必须记住，您的应用程序应该使用服务网格，因为它位于附属于服务网格的名称空间中(在配置控制平面时，我们使用<em class="ny"> ServiceMeshMemberRoll </em>对象来配置它)。</a></p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/4f4ad035e987744aeaf4de0ebb09a3e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*r5f7LAMAnqt0Xd8mpkvmMw.png"/></div></figure><blockquote class="on oo op"><p id="08e0" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:记住<em class="iq"> istio-mesh </em>网络策略只允许同一个mesh中的流量(应用之间以及应用和网关之间)。这包括连接到同一控制平面的所有名称空间，这意味着，如果没有修改，默认情况下，您将能够看到部署在网格中的所有服务，如果它们是同一网格的一部分，则独立于您的应用程序运行的名称空间。该网络策略不仅会拒绝任何不通过入口的外部访问，还会阻止从网格外部直接访问内部Kubernetes服务</p></blockquote><p id="a1b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果作为一个需求，我需要在一个连接到网格的名称空间内运行一个应用程序，但是我想使用常规的Route对象将它发布到该网格之外(这样就失去了一些主要的Istio功能)，会发生什么呢？</p><p id="46b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你需要允许从路由器到pod的流量…但是您不需要接触网络策略，因为已经为这种情况准备了一个规则。</p><p id="fefc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在<em class="ny"> istio-expose-route </em>网络策略(上面列表中的第一个)中看到的，如果流量来自带有标签<code class="fe ng nh ni nj b"><strong class="ka ir">network.openshift.io/policy-group=ingress </strong></code>的名称空间，并且到达带有标签<code class="fe ng nh ni nj b"><strong class="ka ir">maistra.io/expose-route: "true"</strong></code>的pod，它就会允许流量</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/0fd2626d47c36c7d763ba668e6d5e9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ht2EnAPzb6gd-8CPUliqcQ.png"/></div></figure><p id="958a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以检查路由器运行的名称空间(<em class="ny"> openshift-ingress </em>)已经包含标签<code class="fe ng nh ni nj b"><strong class="ka ir">network.openshift.io/policy-group=ingress</strong></code></p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/7b4e36fc89ef45a179f0153aec138d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zxUbSnYsf9aqJFQrajGDOQ.gif"/></div></div></figure><p id="b6db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么剩下的唯一事情就是给我们的豆荚加上标签<code class="fe ng nh ni nj b"><strong class="ka ir">maistra.io/expose-route: "true"</strong></code>。让我们尝试一下，我将创建一个新的应用程序来添加该标签:</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="cfed" class="mu ls iq nj b gy oj ok l ol om">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: hello-noistio<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: hello-noistio<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: hello-noistio<br/>        <strong class="nj ir">maistra.io/expose-route: "true"</strong><br/>      annotations:<br/>        sidecar.istio.io/inject: "true"<br/>    spec:<br/>      containers:<br/>      - name: hello-noistio<br/>        image: openshift/hello-openshift<br/>        ports:<br/>        - containerPort: 8080</span></pre><p id="b629" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还将创建一个关联的服务:</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="a782" class="mu ls iq nj b gy oj ok l ol om">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: hello-noistio<br/>  labels:<br/>    app: hello-noistio<br/>spec:<br/>  ports:<br/>  - port: 8080<br/>    name: http-noistio<br/>  selector:<br/>    app: hello-noistio</span></pre><p id="e6e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这应该足够了，所以我将尝试使用常规路由来公开新服务:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/94f94717f4a3c9ff5d63a954c1d64190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Mk12GBVpL9T2a1P_9tPljA.gif"/></div></div></figure><p id="fdb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它仍然不工作！为什么？…如果我包括了网络策略期望的标签。</p><blockquote class="on oo op"><p id="ce0d" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:它可能对你有用…这取决于你的底层环境，继续阅读了解为什么</p></blockquote><p id="128e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您已经阅读了OpenShift worker nodes-Part III-Network Configuration一文中的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/security-zones-in-openshift-worker-nodes-part-iii-network-configuration-3a887854a4d">安全区域，您可能知道原因…入口控制器/路由器以不同的方式发布，具体取决于open shift运行的平台(<em class="ny">endpoint publishingstrategy</em>)，例如，如果您在公共云中运行，路由器将使用a <code class="fe ng nh ni nj b"><strong class="ka ir">LoadBalancerService</strong></code>，但是如果您使用裸机节点，它们将使用<code class="fe ng nh ni nj b"><strong class="ka ir">HostNetwork</strong></code>发布方法。</a></p><p id="8d24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您使用对网络策略如何影响您的路由器有一些影响的<code class="fe ng nh ni nj b"><strong class="ka ir">HostNetwork</strong></code>发布方法，因为来自入口控制器的流量被分配了<code class="fe ng nh ni nj b">netid:0</code>虚拟网络ID (VNID)。该VNID被附加到<code class="fe ng nh ni nj b">default</code>名称空间，因此在网络策略中使用的任何您想要暗示路由器/入口控制器的名称空间标签必须被分配到<code class="fe ng nh ni nj b">default</code>名称空间。</p><p id="929b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之，如果您正在使用裸机部署(像我在这个例子中一样)，从网络策略的角度来看，您的路由器将“使用”名称空间<code class="fe ng nh ni nj b">default</code>，而不是<code class="fe ng nh ni nj b">openshift-ingress</code>。</p><blockquote class="on oo op"><p id="d487" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated">仅当您的入口控制器在裸机上部署时使用<em class="iq">主机网络</em> <em class="iq">端点发布策略</em>时，才需要以下步骤(作为我的示例)，如果您在公共云上部署了OCP，则端点发布策略将是<em class="iq">负载平衡器</em>，然后您不需要在默认名称空间中添加任何标签。</p></blockquote><p id="f53a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您仔细检查<code class="fe ng nh ni nj b">default</code>命名空间上的标签，您将不会找到所需的标签<code class="fe ng nh ni nj b"><strong class="ka ir">network.openshift.io/policy-group=ingress </strong></code>，我们已经在<code class="fe ng nh ni nj b">openshift-ingress</code>命名空间中拥有该标签，并且该网络策略需要该标签来允许流量……因此，这里的解决方案是将该标签添加到<code class="fe ng nh ni nj b">default</code>命名空间</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/b8ad0f3706ffbd7e8ffbc3b3a94f9201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ePGzER2gjxIsprPe3N5LJQ.gif"/></div></div></figure><p id="f626" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有用！因此，从现在开始，在这个集群中，如果您希望通过常规路由公开，您只需将标签<code class="fe ng nh ni nj b"><strong class="ka ir">maistra.io/expose-route: "true"</strong></code>添加到部署中，即使您使用“裸机”方法部署了OpenShift集群(因为现在<em class="ny">默认的</em>命名空间具有“右”标签)。</p><p id="c434" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，足够的“非istio的东西”，让我们进入Istio入口网关对象。</p><blockquote class="on oo op"><p id="c196" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated">注意:我已经删除了我在本节中创建的路由和非istio服务和部署，因此您在以后的屏幕截图中不会再看到它们</p></blockquote><p id="5273" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">使用Istio入口网关公开应用</strong></p><p id="3386" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经看到了如何使用常规的OpenShift/Kubernetes对象在与服务网格相关联的名称空间中公开服务，但是如果您已经部署了服务网格，是因为您想要利用它的特性，并且为了获得许多好处，您的流量必须使用Istio入口网关作为入口点。</p><p id="ef0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://medium.com/@luis.ariz/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener">在上一篇文章</a>中，我们回顾了入口网关是如何在服务网格控制平面名称空间上运行并通过标准OpenShift路由对外发布的pod(实际上它们也是特使代理，作为边车容器)。现在，我们将了解如何配置它们，以公开在与该控制平面相关联的任何名称空间中运行的服务。</p><p id="cd7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当在与控制平面相关联的任何命名空间中创建新的“网关”对象时，位于控制平面命名空间中的入口网关被自动配置，让我们创建一个:</p><blockquote class="on oo op"><p id="8b74" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated">注意:请包括你的申请子域名，如apps.ocp.domain.com的<domain/></p></blockquote><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="6f36" class="mu ls iq nj b gy oj ok l ol om">apiVersion: networking.istio.io/v1alpha3<br/>kind: Gateway<br/>metadata:<br/>  name: hello-gateway<br/>spec:<br/>  selector:<br/>    istio: ingressgateway<br/>  servers:<br/>  - port:<br/>      number: 80<br/>      name: http<br/>      protocol: HTTP<br/>    hosts:<br/>    - "hello.&lt;domain&gt;"</span></pre><blockquote class="on oo op"><p id="38d2" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated">注意:在我的示例测试中，我在<em class="iq"> project-a1 </em>名称空间中创建了这个对象，它与运行在<em class="iq"> istio-system </em>名称空间上的控制平面相关联</p></blockquote><p id="4ea3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该对象将入口网关配置为接受主机名为"<em class="ny"> hello "的端口80上的连接。&lt;域&gt;</em>“……但它还包含一个<em class="ny">选择器</em>，为什么？</p><p id="2bf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个服务网格中，我们只部署了一个入口网关。这是很常见的(你必须认为你可以在同一个Openshift集群中部署多个不同的服务网格，正如我们在上一篇文章中描述的<a class="ae kw" href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener">，以便区分/隔离流量和配置)，但是也有可能在同一个服务网格控制平面中部署多个网关(入口或出口)，在这种情况下，你可以使用这个网关<em class="ny">选择器</em>选择你想要配置的网关..</a></p><p id="c184" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何在同一个服务网格中部署多个网关？(首先，我要说的是，根据您的使用情况，考虑一下拥有多个控制平面……但是如果您真的想这么做……)</p><p id="fb25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了部署多个网关，您需要在服务网格控制平面定义中包括这样的配置，例如，假设我想在<em class="ny">控制平面中配置辅助入口和出口网关，这是我们在上一篇文章中<a class="ae kw" href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener">创建的</a></em>控制平面，我应该在这里包括粗体文本标记的行:</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="8ac7" class="mu ls iq nj b gy oj ok l ol om">apiVersion: maistra.io/v1<br/>kind: ServiceMeshControlPlane<br/>metadata:<br/>  name: controlplane-A<br/>  namespace: istio-system<br/>spec:<br/>  version: v1.1<br/>  istio:<br/>    global:<br/>      proxy:<br/>        resources:<br/>          requests:<br/>            cpu: 20m<br/>            memory: 200Mi<br/>          limits:<br/>            cpu: 3000m<br/>            memory: 2048Mi<br/>    gateways:<br/>      istio-egressgateway:<br/>        enabled: true<br/>        autoscaleEnabled: true<br/>        autoscaleMin: 1<br/>        autoscaleMax: 3<br/>      istio-ingressgateway:<br/>        enabled: true<br/>        autoscaleEnabled: true<br/>        autoscaleMin: 2<br/>        autoscaleMax: 3<br/>        ior_enabled: true<br/><strong class="nj ir">      istio-secondary-egressgateway:<br/>        enabled: true<br/>        autoscaleEnabled: false<br/>        labels: <br/>          istio: secondary-egressgateway<br/>        ports:<br/>          - name: http2<br/>            protocol: TCP<br/>            port: 80<br/>            targetPort: 8080<br/>          - name: https<br/>            protocol: TCP<br/>            port: 443<br/>            targetPort: 8443<br/>          - name: tls<br/>            protocol: TCP<br/>            port: 15443<br/>            targetPort: 15443<br/>      istio-secondary-ingressgateway:<br/>        enabled: true<br/>        autoscaleEnabled: false<br/>        ior_enabled: false<br/>        resources:<br/>          requests:<br/>            cpu: 100m<br/>            memory: 128Mi<br/>        labels: <br/>          istio: secondary-ingressgateway<br/>        ports:<br/>          - name: status-port<br/>            protocol: TCP<br/>            port: 15020<br/>            targetPort: 15020<br/>          - name: http2<br/>            protocol: TCP<br/>            port: 80<br/>            targetPort: 8080<br/>          - name: https<br/>            protocol: TCP<br/>            port: 443<br/>            targetPort: 8443<br/>          - name: tls<br/>            protocol: TCP<br/>            port: 15443<br/>            targetPort: 15443</strong><br/>    pilot:<br/>      traceSampling: 10.0    <br/>    sidecarInjectorWebhook:<br/>      injectPodRedirectAnnot: true<br/>    tracing:<br/>      jaeger:<br/>        template: production-elasticsearch<br/>        elasticsearch:<br/>          nodeCount: 1<br/>          resources:<br/>            requests:<br/>              cpu: "500m"<br/>              memory: "1Gi"<br/>            limits:<br/>              cpu: "1000m"<br/>              memory: "2Gi"</span></pre><p id="d866" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您需要在“<em class="ny">网关</em>”部分下添加条目。正如你所看到的，你可以为它们定制配置(IOR设置、资源、自动缩放等)，但是你需要在每一个里面添加一个新的"<em class="ny"> ports </em>"部分。</p><p id="d20a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该配置将用于创建与新网关PODs相关联的Kubernetes服务(我从我们已经部署的入口和出口网关复制粘贴了相同的端口)。默认情况下，服务是使用"<em class="ny"> type: ClusterIP </em>创建的，但是您可以在控制平面配置中添加<em class="ny"> type: LoadBalancer </em>(与<em class="ny">端口</em>或<em class="ny">标签</em>处于同一级别)，并且如果您的OpenShift集群部署支持该类型的服务，运营商将配置该类型的服务。</p><p id="20b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，您可以看到在控制面板上的配置被修改后创建的网关单元，如上所示。</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/b642e4feb972c04d6526c0ae9f483afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*Hdcbbxerwd5QvIq61Eeueg.png"/></div></figure><p id="7f82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个新网关中的另一个重要设置是<em class="ny">标签</em>，因为我们可以在<em class="ny">网关</em>对象的<em class="ny">选择器</em>字段中使用这些标签来选择正确的入口网关。如果您检查新的辅助网关上的标签，您将看到<em class="ny">istio = secondary-egress gateway</em>标签已设置</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/2172759b6fc4903887f2513ce740485b.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*2aa8WG1-C8cJdDgqK5c5XA.png"/></div></figure><p id="a52c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后您可以在您的<em class="ny">选择器</em>中使用它，设置您的<em class="ny">网关</em>对象:</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="f696" class="mu ls iq nj b gy oj ok l ol om">apiVersion: networking.istio.io/v1alpha3<br/>kind: Gateway<br/>metadata:<br/>  name: hello-secondary-gateway<br/>spec:<br/><strong class="nj ir">  selector:<br/>    istio: secondary-ingressgateway</strong><br/>  servers:<br/>  - port:<br/>      number: 80<br/>      name: http<br/>      protocol: HTTP<br/>    hosts:<br/>    - "hello-secondary.&lt;domain&gt;"</span></pre><p id="71fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，配置是在<em class="ny">二级Ingres gateway</em>单元中完成的，而不是在<em class="ny">Ingres gateway</em>单元中完成的，但是为什么这样做有用呢？</p><p id="6ec1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了每个网关“类型”有不同的配置之外，我们可以使用配置的标签并在专用节点中运行新的Istio网关POD，这样我们就可以在新旧网关之间分流流量。除此之外，如果我们配置具有路由分片的专用入口控制器(请记住，在一天结束时，我们在Istio网关前配置“常规”OpenShift路由，因此在分流流量时，您也应该考虑这一点)，我们可以为我们的服务网格输入/输出创建差异化的“区域”。</p><p id="fcd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不知道我在说什么，我建议你看一看OpenShift worker nodes博客系列中的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/security-zones-in-openshift-worker-nodes-part-i-introduction-4f85762962d7">安全区域，更具体地说是网络配置文章:</a></p><div class="kx ky gp gr kz la"><a rel="noopener  ugc nofollow" target="_blank" href="/security-zones-in-openshift-worker-nodes-part-iii-network-configuration-3a887854a4d"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">OpenShift工作节点中的安全区域—第三部分—网络配置</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">在本帖中，我们将重点讨论在我们的安全系统中分离入站和出站流量所需的网络配置…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">itnext.io</p></div></div><div class="lj l"><div class="pb l ll lm ln lj lo jw la"/></div></div></a></div><p id="25af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谈到在我们的Istio入口网关前面配置的路由器，如果您还记得上一篇文章中的<a class="ae kw" href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener">，在控制平面网关定义上有一个设置，它执行“路由同步”:IOR。</a></p><p id="b17d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="ny">控制平面-a </em>中，我们启用了IOR，并在<em class="ny">控制平面-b </em>中保持禁用状态，让我们探究一下这到底意味着什么。如果您看到当我在与启用了IOR的<em class="ny"> controlplane-a </em>相关联的一个名称空间中创建如上所示的网关对象时发生了什么，您将会注意到在控制平面名称空间中如何自动创建具有已配置主机名的新路由:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/2304503d59cbb52a54eddfd3c2f07be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Uu9sy4rVedPJqNhpvwFV2w.gif"/></div></div></figure><p id="d9b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">启用IOR后，您可以立即配置Istio入口网关，以接受主机名和必须放在它前面的OpenShift路由，从而将连接重定向到正确的Istio入口网关。</p><p id="e17a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您看一下路由定义，您会发现该路由正在将流量发送回一个名为<em class="ny">istio-Ingres Gateway</em>的服务，该服务是带有标签<em class="ny">app = Istio-Ingres Gateway</em>和<em class="ny">Istio = Ingres Gateway</em>的负载平衡PODs，这是我们的(主要，而不是我们刚刚配置的辅助)Istio入口网关PODs(有两个，因为我们在控制平面定义中配置了最少两个):</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/11719e44e1ab5ce815795db3b3ff198e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KGJvVD6UPB_e85SPDaAMuA.gif"/></div></div></figure><p id="7474" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您在与禁用IOR的<em class="ny"> controlplane-b </em>关联的名称空间中创建网关，您会发现在您的控制平面中没有任何路由:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/cad9964312b4873682d803f940952ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BHhPp9RGJeGu6Nj_UHQCaw.gif"/></div></div></figure><p id="1408" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以手动创建一个指向正确入口网关服务的路由条目，否则，您在网关对象中配置的特定主机名的用户请求将在OpenShift入口控制器级别被丢弃，因此它甚至不会到达Istio入口网关。在这种标准设置中，Istio入口网关使用路由来获取流量，但如果您可以使用其他服务设计(非ClusterIP)来发布它们，从而可以在不使用入口控制器的情况下访问pod，则您可以使流量到达Istio入口网关，而无需OpenShift路由(在这种情况下，IOR禁用可能有意义)。</p><p id="996a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经看到了如何公开HTTP服务，但是HTTPS呢？我们将在下一篇文章的“安全特性”一节中讨论这个问题。</p><p id="5c3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，我们讨论了许多事情，但是我们没有检查我们的路由在创建“网关”Istio对象(在本例中是由IOR sync创建的OpenShift路由)后是否工作:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/aa6936fb9012bc05c7ee588798cff453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UWc_wdAjXGqbzuuNIJg97g.gif"/></div></div></figure><p id="3d32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">….它不起作用…不要惊慌，这是因为，如果你看一下网关定义，我们没有在任何地方包括我们创建的用于访问我们的应用程序的Kubernetes服务名称对象，所以Istio入口网关不能配置到它的内部路由。</p><p id="23f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">入口网关并不像我们看到的那样自动意识到它们必须使用的服务。为了使入口网关知道网格中的服务，必须定义一个<a class="ae kw" href="https://istio.io/latest/docs/reference/config/networking/virtual-service/" rel="noopener ugc nofollow" target="_blank">虚拟服务</a>并将其应用于网关对象。</p><p id="46d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">虚拟服务</strong></p><p id="0a7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虚拟服务对象可用于配置路由，包括不同的高级设置(默认情况下，入口网关使用循环模式在每个服务的负载平衡池中分配流量)，这将在另一篇文章中讨论(与其他额外的对象一起作为“目的地规则”)。在这里，我们只关注为网格中的应用程序提供外部连接，没有任何额外的设置。</p><p id="2446" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看一个基本的虚拟服务对象定义:</p><pre class="oa ob oc od gt of nj og oh aw oi bi"><span id="09d7" class="mu ls iq nj b gy oj ok l ol om">apiVersion: networking.istio.io/v1alpha3<br/>kind: VirtualService<br/>metadata:<br/>  name: hello-vs<br/>spec:<br/>  hosts:<br/>  - "hello.&lt;domain&gt;"<br/>  gateways:<br/>  - hello-gateway<br/>  http:<br/>  - route:<br/>    - destination:<br/>        host: hello<br/>        port:<br/>          number: 8080</span></pre><p id="c4a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虚拟服务对象绑定了网关(<em class="ny"> hello-gateway </em>)和在网关(<em class="ny"> hello)中配置的一个主机(在我们的示例中，我们只配置了一个，但是可以包含多个主机定义)。&lt;域&gt; </em>)以及目的地Kubernetes服务(<em class="ny"> hello </em>)及其端口号。一旦创建了绑定，您就可以测试您最终是否能够从集群外部访问应用程序:</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/adf9490b090cb1e8787dacc61d78d7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RadPyRAsHmJhv6xL88vK6w.gif"/></div></div></figure><blockquote class="on oo op"><p id="1e29" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated">注意:如果您发现这不起作用，请查看一下Kiali UI，因为如果您错误地配置了服务名，您在创建虚拟服务时不会得到任何错误，但是您会在Kiali中看到一条消息:</p></blockquote><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/d94abe427b3df5d214483204d8d71db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ju4jQJn7oQQlRy71Cui6ZA.png"/></div></div></figure><h1 id="a7fa" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">出口流量</h1><p id="6e01" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">这里的第一个问题是，默认情况下，服务网格如何处理传出流量？</p><p id="d51e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能认为您会有与非服务网格传出流量相同的默认行为，即使用运行它的节点的IP，让我们检查一下:</p><blockquote class="on oo op"><p id="64ec" class="jy jz ny ka b kb kc kd ke kf kg kh ki oq kk kl km or ko kp kq os ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:如果你不知道如何在CoreOS中使用tcpdump，我建议你看看我的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/security-zones-in-openshift-worker-nodes-part-i-introduction-4f85762962d7">关于OpenShift worker节点的安全区域</a>系列，在那里，你可以看到关于在节点上使用非预安装rpm的解释，以及其他技巧</p></blockquote><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/2be9ac44e24d699ea616c9acc93097be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Dy0Uo6XyCKOPtuiqb9XRwg.gif"/></div></div></figure><p id="9ba9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在上面看到的，默认情况下，POD使用节点IP，那么，为什么我们有出口网关呢？您可以使用它们，但是您需要为这样的事情配置您的服务机制，在另一篇文章的服务网格路由特性回顾中，将会显示该配置以及其他配置。</p><figure class="oa ob oc od gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pd"><img src="../Images/1f95795dbec7d3550a4c3983b60a0575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OIsdm7PFnRtM6PWZ.png"/></div></div></figure><blockquote class="pe"><p id="d3c5" class="pf pg iq bd ph pi pj pk pl pm pn kv dk translated">既然我们已经回顾了控制平面和数据平面，在本系列的下一篇文章中，我们将开始研究一些服务网格特性。我希望你觉得它有用…当它完成时。</p><p id="09de" class="pf pg iq bd ph pi po pp pq pr ps kv dk translated">以下是与OpenShift服务网格系列相关的其余文章:</p></blockquote><div class="pt pu pv pw px la"><a href="https://medium.com/swlh/openshift-service-mesh-essentials-part-i-the-why-and-what-of-it-a3ef09bf8aa8" rel="noopener follow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">open shift Service Mesh Essentials—第一部分—原因和内容</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">在这第一篇文章中，我们将讨论一些关于OpenShift服务网格的介绍性问题，包括它的特性…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">medium.com</p></div></div><div class="lj l"><div class="lp l ll lm ln lj lo jw la"/></div></div></a></div><div class="kx ky gp gr kz la"><a href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-ii-control-plane-9c76a35936b5" rel="noopener follow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">OpenShift服务网格基础—第二部分—控制平面</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">在第二篇文章中，我们将介绍OpenShift服务网格控制平面的准备和部署。</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">luis-javier-arizmendi-alonso.medium.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jw la"/></div></div></a></div><div class="kx ky gp gr kz la"><a href="https://luis-javier-arizmendi-alonso.medium.com/openshift-service-mesh-essentials-part-iv-features-routing-3189dae64615" rel="noopener follow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">OpenShift服务网格基础—第四部分—功能:路由</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">了解如何使用高级路由来修改应用程序的行为，而不包括API网关或…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">luis-javier-arizmendi-alonso.medium.com</p></div></div><div class="lj l"><div class="lq l ll lm ln lj lo jw la"/></div></div></a></div></div></div>    
</body>
</html>