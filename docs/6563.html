<html>
<head>
<title>Hacking the Python syntax: Ternary operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解Python语法:三元运算符</h1>
<blockquote>原文：<a href="https://itnext.io/hacking-the-python-syntax-part-1-ternary-operator-bbcb04aa6ecb?source=collection_archive---------1-----------------------#2021-12-19">https://itnext.io/hacking-the-python-syntax-part-1-ternary-operator-bbcb04aa6ecb?source=collection_archive---------1-----------------------#2021-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7954775e7158b20a151f2a854d0ad2c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cr-is5ewZxlZA5-iuzOqdQ.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">在<a class="ae jg" href="https://unsplash.com/s/photos/jenga?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae jg" href="https://unsplash.com/@ourlifeinpixels?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">用像素拍摄的</a>我们的生活</figcaption></figure><div class=""/><div class=""><h2 id="c38b" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">在5行代码中</h2></div><p id="e2da" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://remykarem.medium.com/hacking-the-python-syntax-part-0-introduction-9a1c054ec1e6" rel="noopener">简介</a> | <strong class="la jk">三元运算符</strong> | <a class="ae jg" href="https://remykarem.medium.com/hacking-the-python-syntax-alternate-lambda-syntax-c87c383dd1a3" rel="noopener">交替lambda语法</a> |函数中无返回关键字(即将推出)|列表理解++(即将推出)</p><p id="de37" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">变更日志:<br/>2022年12月31日—使用Medium的新代码块突出显示语法<br/>2022年1月5日—修复错别字并提高清晰度</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="66c5" class="mc md jj bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">目录</h2><ol class=""><li id="6dee" class="mv mw jj la b lb mx le my lh mz ll na lp nb lt nc nd ne nf bi translated"><a class="ae jg" href="#f4de" rel="noopener ugc nofollow">三元运算符</a></li><li id="bed0" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated"><a class="ae jg" href="#3961" rel="noopener ugc nofollow">当前语法</a></li><li id="fa2e" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated"><a class="ae jg" href="#f48a" rel="noopener ugc nofollow">目标语法</a></li><li id="38d8" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated"><a class="ae jg" href="#ad57" rel="noopener ugc nofollow">添加令牌</a></li><li id="0e92" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated"><a class="ae jg" href="#a7ee" rel="noopener ugc nofollow">改变语法</a></li><li id="1145" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated"><a class="ae jg" href="#fd1c" rel="noopener ugc nofollow">例题</a></li></ol><p id="809e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于环境设置，请阅读<em class="lu">第0部分—简介</em>。完整的代码，看我的分叉<a class="ae jg" href="https://github.com/remykarem/cpython/tree/ternary-operator" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f4de" class="nl md jj bd me nm nn no mh np nq nr mk kp ns kq mn ks nt kt mq kv nu kw mt nv bi translated">1.三元运算符</h1><p id="8044" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/%3F:" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">三元运算符</strong> </a>在很多语言中都很常见。它用于简洁地表达一个简单的条件表达式，通常在一行中。</p><h1 id="3961" class="nl md jj bd me nm nz no mh np oa nr mk kp ob kq mn ks oc kt mq kv od kw mt nv bi translated">2.当前语法</h1><p id="0ae9" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">在Python中，我们已经有了<strong class="la jk">条件表达式</strong>:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="4cc2" class="on md jj oj b be oo op l oq or">"good" if x==100 else "bad"</span></pre><p id="a10b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这符合规则</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="df52" class="on md jj oj b be oo op l oq or">&lt;consequent&gt; if &lt;test&gt; else &lt;alternative&gt;</span></pre><p id="c8bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不喜欢以这种方式阅读条件表达式。</p><p id="9a62" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我更喜欢先阅读条件/测试，然后一起阅读2个结果。(我是在了解了JavaScript的三元运算符后才意识到这一点的。)</p><h1 id="f48a" class="nl md jj bd me nm nz no mh np oa nr mk kp ob kq mn ks oc kt mq kv od kw mt nv bi translated">3.目标语法</h1><p id="f37f" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">因此，条件表达式中的三元运算符如下所示:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="041b" class="on md jj oj b be oo op l oq or">score&gt;=50 ? "pass" : "fail"</span></pre><p id="45f4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在规则变成了</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="ec6a" class="on md jj oj b be oo op l oq or">&lt;test&gt; ? &lt;consequent&gt; : &lt;alternative&gt;</span></pre><p id="53d4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个很好的语法，因为我认为它更具可读性——首先，提出一个是-否问题，其次，用<code class="fe os ot ou oj b">?</code>(在大多数自然语言中，这在语义上意味着一个问题)表示它，最后给出两种不同的结果，用冒号<code class="fe os ot ou oj b">:</code>分隔。</p><p id="25e1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实现这种三元运算符语法的一些语言包括C、Java、JavaScript和Swift。</p><h1 id="ad57" class="nl md jj bd me nm nz no mh np oa nr mk kp ob kq mn ks oc kt mq kv od kw mt nv bi translated">4.添加令牌</h1><p id="9480" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">从Python v3.11.0a2开始，<code class="fe os ot ou oj b">?</code>不是现有的<em class="lu">令牌</em>。</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/c8304f7da0c075cce4b16106215b5bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSS5LYxOox9RFs20xLieOw@2x.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">布雷特·乔丹在<a class="ae jg" href="https://unsplash.com/s/photos/letters?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="ow ox oy"><p id="662a" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">📜</em> <strong class="la jk"> <em class="jj">源代码编译:生成令牌</em> </strong></p><p id="27b4" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">在</em> <a class="ae jg" href="https://en.wikipedia.org/wiki/Lexical_analysis" rel="noopener ugc nofollow" target="_blank"> <em class="jj">词法分析</em> </a> <em class="jj">中，一个</em> <strong class="la jk"> <em class="jj">记号</em> </strong> <em class="jj">是一个字符序列(</em> <strong class="la jk"> <em class="jj">记号值</em> </strong> <em class="jj">))归于一个赋值的意义(</em> <strong class="la jk"> <em class="jj">记号名</em> </strong> <em class="jj">)。</em></p><p id="73ef" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><strong class="la jk"> <em class="jj">记号化</em> </strong> <em class="jj">是从一串输入字符中识别记号的过程。它是编译我们Python源代码的第一步(见</em> <a class="ae jg" href="https://devguide.python.org/compiler/" rel="noopener ugc nofollow" target="_blank"> <em class="jj">此处</em> </a> <em class="jj">)。</em></p></blockquote><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/7d20aded935e43b8bbd71b03b828ebc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gY9hHu4X4mCoKct5s9s8HQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">令牌文件的代码片段，其中包括令牌名称，如数字、字符串、LPAR和RPAR</figcaption></figure><p id="4dc5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe os ot ou oj b">Grammar/Tokens</code>文件定义了Python中允许的所有标记。以下是一些令牌示例:</p><ul class=""><li id="a68b" class="mv mw jj la b lb lc le lf lh pd ll pe lp pf lt pg nd ne nf bi translated">令牌名称:<code class="fe os ot ou oj b">NUMBER</code>；令牌值是数字文字，如<code class="fe os ot ou oj b">123</code>和<code class="fe os ot ou oj b">0xff</code></li><li id="c9ed" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt pg nd ne nf bi translated">令牌名称:<code class="fe os ot ou oj b">STRING</code>；令牌值是字符串文字，如<code class="fe os ot ou oj b">"hello!"</code>和<code class="fe os ot ou oj b">'hello!'</code></li><li id="e259" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt pg nd ne nf bi translated">令牌名:<code class="fe os ot ou oj b">LPAR</code>；令牌值:<code class="fe os ot ou oj b">'('</code></li><li id="98aa" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt pg nd ne nf bi translated">令牌名称:<code class="fe os ot ou oj b">RPAR</code>；令牌值:<code class="fe os ot ou oj b">')'</code></li></ul><p id="6714" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">三元运算符有两个符号:<code class="fe os ot ou oj b">?</code>和<code class="fe os ot ou oj b">:</code>。<code class="fe os ot ou oj b">:</code>是<code class="fe os ot ou oj b">COLON</code>的标记值，但是问号<code class="fe os ot ou oj b">?</code>不是Python中的现有标记，所以让我们将它添加到现有标记列表的下面</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="2ae8" class="on md jj oj b be oo op l oq or">QUESTIONMARK            '?'</span></pre><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/e0b0d6695276c633bee730850d29e3ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g__CWG_6dKkF1muJPpkkaw.png"/></div></div></figure><p id="4864" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后运行<code class="fe os ot ou oj b">make regen-token</code>重新生成令牌。</p><blockquote class="ow ox oy"><p id="a278" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><strong class="la jk">T13】💡 </strong> <code class="fe os ot ou oj b"><strong class="la jk">make regen-token</strong></code> <strong class="la jk"> <em class="jj">是干什么的？</em>T19】</strong></p><p id="bfbf" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">这个命令运行一个Python脚本(是的，一个Python脚本！)读取</em> <code class="fe os ot ou oj b">Grammar/Tokens</code> <em class="jj">文件并生成几个文件，包括</em> <code class="fe os ot ou oj b">token.c</code> <em class="jj">文件。C文件稍后会被编译并在标记化过程中使用。</em></p><p id="0b38" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">要了解更多，先从</em> <code class="fe os ot ou oj b">./Makefile</code> <em class="jj">文件中的</em> <code class="fe os ot ou oj b">regen-token</code> <em class="jj">目标开始。</em></p><p id="2439" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">要了解更多的Makefiles，</em> <a class="ae jg" href="https://opensource.com/article/18/8/what-how-makefile" rel="noopener ugc nofollow" target="_blank"> <em class="jj">这里的</em> </a> <em class="jj">就是一个很好的介绍。</em></p></blockquote><h1 id="a7ee" class="nl md jj bd me nm nz no mh np oa nr mk kp ob kq mn ks oc kt mq kv od kw mt nv bi translated">5.改变语法</h1><p id="b67a" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated"><em class="lu">在这一部分，我们将介绍以下内容:</em></p><p id="5626" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> 5.1增加一个替代方案</em></p><p id="28e4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> 5.2更新变量和语法动作</em></p><p id="fce6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> 5.3(可选)条件表达式AST节点</em></p><p id="4042" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> 5.4如何引发错误</em></p><p id="b0aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> 5.5改进错误信息</em></p><p id="6a8c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经添加了令牌，让我们更改Python的语法，以包含用于条件表达式的三元运算符语法。</p><p id="eca0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">等等…什么是<em class="lu">语法</em>？</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/4011a5f8e3edfccf05842ef62a0f248a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwVL-apx5IpEtuHyz9vLCw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@brett_jordan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae jg" href="https://unsplash.com/s/photos/grammar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1943" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Formal_grammar" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">语法</strong> </a>是一组规则，定义了在语言中被认为是正确的记号的组合。</p><p id="a8e7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们想定义在现有的规则集中编写正确的三元运算符语法意味着什么。</p><p id="2cb4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看语法文件<code class="fe os ot ou oj b">Grammar/python.gram</code>。在这个文件中，您看到的是大量的规则、一些看起来很有趣的语法和一些熟悉的关键字，如<code class="fe os ot ou oj b">'return'</code>。</p><p id="113e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们正在处理具有<code class="fe os ot ou oj b">if</code>和<code class="fe os ot ou oj b">else</code>关键字的条件表达式，所以让我们使用regex: <code class="fe os ot ou oj b">'if'.*'else'</code>来找到它(因为这样做很酷，否则你可以对<code class="fe os ot ou oj b">'if'</code>使用Cmd+F)。</p><p id="b190" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe os ot ou oj b">python.gram</code>文件中:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="557e" class="on md jj oj b be oo op l oq or">expression[expr_ty] (memo):<br/><br/>    | invalid_expression<br/><br/>    | a=disjunction 'if' b=disjunction 'else' c=expression { <br/>        _PyAST_IfExp(b, a, c, EXTRA) }<br/><br/>    | disjunction<br/><br/>    | lambdef</span></pre><p id="87cf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们发现if-else规则停在<code class="fe os ot ou oj b">expression</code>下面。</p><p id="cd40" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个<code class="fe os ot ou oj b">expression</code>被定义为以下五种情况之一(<strong class="la jk">选择</strong>):</p><ol class=""><li id="57cc" class="mv mw jj la b lb lc le lf lh pd ll pe lp pf lt nc nd ne nf bi translated"><code class="fe os ot ou oj b">invalid_expression</code>(暂时忽略这一点)</li><li id="1f9b" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated"><code class="fe os ot ou oj b">invalid_legacy_expression</code>(暂时忽略这一点)</li><li id="b019" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated"><code class="fe os ot ou oj b">a=disjunction 'if' b=disjunction 'else' c=expression ...</code>(我们要从什么开始！)</li><li id="fb70" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated"><code class="fe os ot ou oj b">disjunction</code>(暂时忽略这个)</li><li id="9669" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated"><code class="fe os ot ou oj b">lambdef</code>(暂时忽略这个)</li></ol><p id="06ca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<code class="fe os ot ou oj b">|</code>表示“或”</p><h2 id="0e31" class="mc md jj bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">5.1添加替代方案</h2><p id="4765" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">要为三元运算符添加一个条件表达式，让我们匆忙复制当前的条件表达式，只需将<code class="fe os ot ou oj b">'if'</code>替换为<code class="fe os ot ou oj b">'?'</code>，将<code class="fe os ot ou oj b">'else'</code>替换为<code class="fe os ot ou oj b">':'</code>。那我们就看看会怎样。</p><p id="5eb4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">添加以下规则</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="81ab" class="on md jj oj b be oo op l oq or">a=disjunction '?' b=disjunction ':' c=expression {<br/>  _PyAST_IfExp(b, a, c, EXTRA) }</span></pre><p id="0196" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe os ot ou oj b">expression[expr_ty]</code>中:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="b1b1" class="on md jj oj b be oo op l oq or">expression[expr_ty] (memo):<br/><br/>    | invalid_expression<br/><br/>    | a=disjunction 'if' b=disjunction 'else' c=expression { <br/>        _PyAST_IfExp(b, a, c, EXTRA) }<br/><br/>    | a=disjunction '?' b=disjunction ':' c=expression { <br/>        _PyAST_IfExp(b, a, c, EXTRA) }<br/><br/>    | disjunction<br/><br/>    | lambdef</span></pre><p id="2350" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe os ot ou oj b">make regen-pegen &amp;&amp; make -j4</code>重新运行。</p><blockquote class="ow ox oy"><p id="ca90" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">💡</em><strong class="la jk"><em class="jj"/></strong><code class="fe os ot ou oj b"><strong class="la jk">make regen-pegen</strong></code><strong class="la jk"><em class="jj">是干什么的？<br/> </em> </strong> <em class="jj">该命令重新生成解析器源代码，即</em> <code class="fe os ot ou oj b">parser.c</code> <em class="jj">文件，该文件稍后将被编译并用于解析我们的Python代码。</em></p><p id="6b2e" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj"/><code class="fe os ot ou oj b">parser.c</code><em class="jj">是如何生成的？</em> <em class="jj">有一个Python模块</em> <code class="fe os ot ou oj b">Tools/peg_generator/pegen</code> <em class="jj">读取</em> <code class="fe os ot ou oj b">python.gram</code> <em class="jj">文件，最后生成</em> <code class="fe os ot ou oj b">parser.c</code> <em class="jj">。</em></p><p id="0441" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">要了解更多，从看</em> <code class="fe os ot ou oj b">./Makefile</code> <em class="jj">中的regen-pegen目标开始。</em></p></blockquote><p id="f1f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们通过运行<code class="fe os ot ou oj b">./python.exe</code>可执行文件在REPL中尝试一些东西，并使用三元运算符测试我们的条件表达式:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="e1cf" class="on md jj oj b be oo op l oq or">&gt;&gt;&gt; x = 100<br/>&gt;&gt;&gt; x&gt;=50 ? "pass" : "fail"<br/>"fail"</span></pre><p id="4178" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它工作了🎉！</p><p id="aa6d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只是…我们期待的是<code class="fe os ot ou oj b">"pass"</code>而不是<code class="fe os ot ou oj b">"fail"</code>😞。这就把我们带到了下一节。</p><h2 id="6b12" class="mc md jj bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">5.2更新变量和语法动作</h2><p id="106a" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">回想一下，之前的条件表达式和我们的版本唯一的区别就是<code class="fe os ot ou oj b">&lt;consequent&gt;</code>和<code class="fe os ot ou oj b">&lt;test&gt;</code>的位置。</p><p id="738e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当前条件表达式:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="5d21" class="on md jj oj b be oo op l oq or">a=&lt;consequent&gt; if b=&lt;test&gt; else c=&lt;alternative&gt;</span></pre><p id="2a14" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用三元运算符的条件表达式:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="5902" class="on md jj oj b be oo op l pj or">a=&lt;test&gt; ? b=&lt;consequent&gt; : c=&lt;alternative&gt;</span></pre><p id="7cbb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们添加的替代方案中，让我们将“函数参数”中的<code class="fe os ot ou oj b">b</code>和<code class="fe os ot ou oj b">a</code>的位置从</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="0c1e" class="on md jj oj b be oo op l oq or">_PyAST_IfExp(b, a, EXTRA)</span></pre><p id="851a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="cfe4" class="on md jj oj b be oo op l oq or">_PyAST_IfExp(a, b, EXTRA)</span></pre><p id="6e28" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最终的<code class="fe os ot ou oj b">expression[expr_ty]</code>应该是这样的:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="d379" class="on md jj oj b be oo op l oq or">expression[expr_ty] (memo):<br/><br/>    | invalid_expression<br/><br/>    | a=disjunction 'if' b=disjunction 'else' c=expression { <br/>        _PyAST_IfExp(b, a, c, EXTRA) }<br/><br/>    | a=disjunction '?' b=disjunction ':' c=expression { <br/>        _PyAST_IfExp(a, b, c, EXTRA) }<br/><br/>    | disjunction<br/><br/>    | lambdef</span></pre><p id="32bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并重新运行<code class="fe os ot ou oj b">make -j4 &amp;&amp; ./python.exe</code>。</p><p id="517a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在蟒蛇REPL:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="de47" class="on md jj oj b be oo op l oq or">&gt;&gt;&gt; x = 100<br/>&gt;&gt;&gt; x==100 ? "good" : "bad"<br/>"good"</span></pre><p id="20db" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">咻，成功了🎉🎉！但是为什么会起作用呢？</p><p id="5100" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们先从高层次上理解<em class="lu">语法变量</em>和<em class="lu">语法动作</em>，然后看看它们与<em class="lu"> AST </em>和<code class="fe os ot ou oj b">_PyAST_IfExp</code>的关系。</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="5d26" class="on md jj oj b be oo op l oq or">expression[expr_ty] (memo):<br/><br/>    | invalid_expression<br/><br/>    | invalid_legacy_expression<br/><br/>    | a=disjunction 'if' b=disjunction 'else' c=expression {<br/>        _PyAST_IfExp(b, a, c, EXTRA) }<br/><br/>    | disjunction<br/><br/>    | lambdef</span></pre><p id="7570" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们添加的替代方案中，我们有</p><ul class=""><li id="e571" class="mv mw jj la b lb lc le lf lh pd ll pe lp pf lt pg nd ne nf bi translated"><code class="fe os ot ou oj b">a=</code>、<code class="fe os ot ou oj b">b=</code>和<code class="fe os ot ou oj b">c=</code>，以及</li><li id="e65c" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt pg nd ne nf bi translated">花括号<code class="fe os ot ou oj b">{ ... }</code>包含某种带有参数<code class="fe os ot ou oj b">a</code>、<code class="fe os ot ou oj b">b</code>和<code class="fe os ot ou oj b">c</code>的函数<code class="fe os ot ou oj b">_PyAST_IfExp</code>。</li></ul><p id="4ea0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该规则中的<code class="fe os ot ou oj b">a</code>、<code class="fe os ot ou oj b">b</code>和<code class="fe os ot ou oj b">c</code>是<a class="ae jg" href="https://devguide.python.org/parser/#variables-in-the-grammar" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">变量</strong> </a>，用于捕捉(通过<code class="fe os ot ou oj b">=</code>分配的)内容。这些变量用于语法动作<em class="lu">。</em></p><p id="e503" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个<a class="ae jg" href="https://devguide.python.org/parser/#grammar-actions" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">语法动作</strong> </a>告诉解析器，如果替换被成功解析，将生成什么<em class="lu"> AST </em> <em class="lu">节点</em>。</p><blockquote class="ow ox oy"><p id="134c" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">📜</em> <strong class="la jk"> <em class="jj">源代码编译:生成ASTs </em> </strong></p><p id="20ae" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"><strong class="la jk"><em class="jj">AST</em></strong></a><em class="jj">代表抽象语法树，是你的源代码在树形数据结构中的高级表示。</em></p><p id="6135" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated">生成ASTs是源代码编译的第二步。</p><p id="404e" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">生成的AST节点的例子有_PyAST_IfExp等。</em></p><p id="7538" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">📜</em> <strong class="la jk"> <em class="jj">源代码编译:超越ASTs </em> </strong></p><p id="9477" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">AST生成后会发生什么？它被转换成表示程序流程的图形数据结构。基于这个图数据结构，发出字节码指令。</em></p></blockquote><p id="c497" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总而言之，一旦我们成功地解析了三元运算符替代项，我们将为条件表达式生成一个AST节点，通过语法动作称为<code class="fe os ot ou oj b">_PyAST_IfExp</code>。</p><h2 id="e099" class="mc md jj bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">5.3(可选)条件表达式AST节点</h2><p id="1f1f" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">我们说过<code class="fe os ot ou oj b">_PyAST_IfExp</code>是“某种功能”嗯，确实是C函数！</p><p id="84dd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在头文件<code class="fe os ot ou oj b">Include/internal/pycore_ast.h</code>中，我们看到了它的函数声明:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="a213" class="on md jj oj b be oo op l oq or">expr_ty _PyAST_IfExp(expr_ty test, expr_ty body, expr_ty orelse, <br/>                     int lineno, int col_offset, int end_lineno, <br/>                     int end_col_offset, PyArena *arena);</span></pre><blockquote class="ow ox oy"><p id="6981" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">💡</em> <strong class="la jk"> <em class="jj"> C头文件</em> </strong> <em class="jj"> <br/>在C和C++中，有一个</em> <strong class="la jk"> <em class="jj">头文件</em> </strong> <em class="jj">是定义函数签名的地方，不用它们的体。</em></p></blockquote><p id="271c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在函数声明中，前3个参数按以下顺序表示我们在语法文件中所写的内容:</p><ol class=""><li id="7b88" class="mv mw jj la b lb lc le lf lh pd ll pe lp pf lt nc nd ne nf bi translated"><code class="fe os ot ou oj b">test</code> —病情，</li><li id="c036" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated"><code class="fe os ot ou oj b">body</code> —条件为真时的结果，以及</li><li id="6675" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated"><code class="fe os ot ou oj b">orelse</code> —条件为假时的结果。</li></ol><p id="0b8a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其余的参数由<code class="fe os ot ou oj b">EXTRA</code>宏注入。这些就是作者所说的<a class="ae jg" href="https://devguide.python.org/parser/#automatic-variables" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">自动变量</strong> </a>。变量_start_line_no等。是由解析器自动注入的。</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="aae4" class="on md jj oj b be oo op l oq or">#define EXTRA _start_lineno, _start_col_offset, \<br/>              _end_lineno, _end_col_offset, p-&gt;arena</span></pre><blockquote class="ow ox oy"><p id="f082" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">💡</em> <strong class="la jk"> <em class="jj"> C宏</em> </strong> <em class="jj"> <br/>在C和C++中，一个</em> <strong class="la jk"> <em class="jj">宏</em> </strong> <em class="jj">被松散地定义为“搜索和替换”这里，每次在C源代码中遇到</em> <code class="fe os ot ou oj b">EXTRA</code> <em class="jj">，都会展开为</em> <code class="fe os ot ou oj b"><em class="jj">_</em>start_lineno, _start_col_offset<em class="jj">, _end_lineno, _end_col_offset, p-&gt;arena</em></code> <em class="jj">。</em></p></blockquote><h2 id="c62a" class="mc md jj bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">5.4如何引发错误</h2><p id="369f" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">现在让我们通过编写一个不完整的条件表达式来测试我们在REPL中的语法:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="838c" class="on md jj oj b be oo op l oq or">&gt;&gt;&gt; x = 100<br/>&gt;&gt;&gt; x==100 ? "good"<br/>SyntaxError: invalid syntax</span></pre><p id="af90" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了！它像预期的那样抛出了一个<code class="fe os ot ou oj b">SyntaxError</code>，但是错误信息只是说… <code class="fe os ot ou oj b">invalid syntax</code>？那是…不是一个有用的错误信息。给出更多有用的消息来帮助程序员调试总是一个好主意。</p><blockquote class="ow ox oy"><p id="62e5" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><em class="jj">💡</em><strong class="la jk"><em class="jj">Python 3.10中更好的错误消息<br/></em></strong><em class="jj">Python 3.10版本的一个特点就是针对语法、缩进、属性、变量名相关的错误，为用户提供更有用的错误消息(甚至给出可能的建议！).参见</em> <a class="ae jg" href="https://docs.python.org/3/whatsnew/3.10.html#better-error-messages" rel="noopener ugc nofollow" target="_blank"> <em class="jj">此处</em> </a> <em class="jj">的发布说明。</em></p></blockquote><p id="4f01" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以现在的问题是…我们可以在解析时提出错误吗？是的，我们可以！这是通过<code class="fe os ot ou oj b">invalid_expression</code>替代的。</p><p id="e69b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是你可能会想，等等…这是什么规则？</p><p id="5810" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还记得我们之前说过语法动作在成功解析后会生成AST节点吗？嗯……还有一点。</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/13e3c2ac5a15891e444d18477228d089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9jjZMRg3H1Qun4P24lgzQ@2x.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">python.gram:无效的表达式规则</figcaption></figure><p id="9725" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看一下<code class="fe os ot ou oj b">invalid_expression</code>规则。注意，每个选项中的语法动作都是<code class="fe os ot ou oj b">RAISE_SYNTAX_ERROR_KNOWN_RANGE</code>。如果你查看所有其他以<code class="fe os ot ou oj b">invalid_</code>开头的规则，你会发现它们的语法行为是<code class="fe os ot ou oj b">RAISE_*_ERROR_*</code>。</p><p id="77d6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，为了引发语法错误，我们定义了一个替代方法，它将引发一个错误(而不是创建一个AST节点)。</p><blockquote class="ow ox oy"><p id="db5a" class="ky kz lu la b lb lc kk ld le lf kn lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><strong class="la jk">T24】💡语法错误是如何产生的<br/>  </strong> <em class="jj">阅读</em> <a class="ae jg" href="https://devguide.python.org/parser/#how-syntax-errors-are-reported" rel="noopener ugc nofollow" target="_blank"> <em class="jj">此处</em> </a> <em class="jj">阅读更多关于语法错误是如何产生的。</em></p></blockquote><h2 id="754c" class="mc md jj bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">5.5改进错误消息</h2><p id="5fc0" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">因此，我们不只是告诉程序员他们的语法是错误的，而是让他们放心，嘿，没什么大不了的，你只是忘记了一个冒号。</p><p id="0b14" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们在<code class="fe os ot ou oj b">invalid_expression</code>规则下添加以下选项:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="f049" class="on md jj oj b be oo op l oq or">| a=disjunction '?' b=disjunction !':' {<br/>  RAISE_SYNTAX_ERROR_KNOWN_RANGE(<br/>  b, a, "expected ':' after '?' expression") }</span></pre><p id="c388" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe os ot ou oj b">invalid_expression</code>应该是这样的:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="a488" class="on md jj oj b be oo op l oq or">invalid_expression:<br/>    # !(NAME STRING) is not matched so we don't show this error with some invalid string prefixes like: kf"dsfsdf"<br/>    # Soft keywords need to also be ignored because they can be parsed as NAME NAME<br/>   | !(NAME STRING | SOFT_KEYWORD) a=disjunction b=expression_without_invalid {<br/>        _PyPegen_check_legacy_stmt(p, a) ? NULL : p-&gt;tokens[p-&gt;mark-1]-&gt;level == 0 ? NULL :<br/>        RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "invalid syntax. Perhaps you forgot a comma?") }<br/>   | a=disjunction 'if' b=disjunction !('else'|':') { <br/>        RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "expected 'else' after 'if' expression") }<br/>   | a=disjunction '?' b=disjunction !':' { <br/>        RAISE_SYNTAX_ERROR_KNOWN_RANGE(b, a, "expected ':' after '?' expression") }</span></pre><p id="b23d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们编译<code class="fe os ot ou oj b">make -j4 &amp;&amp; ./python.exe</code>并在REPL中运行以下代码:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="6ba6" class="on md jj oj b be oo op l oq or">&gt;&gt;&gt; 10&gt;2 ? "correct"<br/><br/>  File "&lt;stdin&gt;", line 1<br/>    10&gt;2 ? "correct"<br/>           ^<br/>SyntaxError: expected ':' after '?' expression</span></pre><p id="de61" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">瞧啊。我们得到一个更有意义的错误信息！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fd1c" class="nl md jj bd me nm nn no mh np nq nr mk kp ns kq mn ks nt kt mq kv nu kw mt nv bi translated">6.例子</h1><p id="b364" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">return语句中的三元运算符:</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="ffd6" class="on md jj oj b be oo op l oq or">&gt;&gt;&gt; def evaluate(score):<br/>...     return score &gt;= 50 ? "pass" : "fail"<br/>&gt;&gt;&gt; evaluate(100)<br/>"pass"</span></pre><p id="71aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">列表理解中的三元运算符</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="1549" class="on md jj oj b be oo op l oq or">&gt;&gt;&gt; [x%2 ? "odd" : "even" for x in range(5)]<br/>['even', 'odd', 'even', 'odd', 'even']</span></pre><p id="9ea7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不带括号的f字符串中的三元运算符</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="256f" class="on md jj oj b be oo op l oq or">&gt;&gt;&gt; score = 100<br/>&gt;&gt;&gt; f'{score &gt;= 50 ? "pass" : "fail"}'<br/>  File "sdin&gt;, line 1<br/>    (score &gt;= 50 ? 'pass' )<br/>                   ^<br/>SyntaxError: f-string: expected ':' after '?' expression</span></pre><p id="35e5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">带括号的f字符串中的三元运算符</p><pre class="oe of og oh gt oi oj ok bn ol om bi"><span id="198e" class="on md jj oj b be oo op l oq or">&gt;&gt;&gt; score = 100<br/>&gt;&gt;&gt; f'{(score &gt;= 50 ? "pass" : "fail")}'<br/>"pass"</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="073b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">伙计们，现在就到这里吧！请继续关注更多，如<strong class="la jk">替代lambda语法</strong>、<strong class="la jk">函数中没有返回关键字</strong>和<strong class="la jk">列表理解++ </strong>！</p><p id="cd1e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">我发表关于人工智能、机器学习、编程语言和生产力的文章。</em></p><p id="be4d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">如果你喜欢阅读更多关于编程语言的内容，你可以通过我的推荐链接</em> <a class="ae jg" href="https://remykarem.medium.com/subscribe" rel="noopener"> <em class="lu">订阅</em> </a> <em class="lu">随时接收更新或者</em> <a class="ae jg" href="https://remykarem.medium.com/membership" rel="noopener"> <em class="lu">注册</em> </a> <em class="lu">！请注意，您的会员费的一部分将作为介绍费分摊给我。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5d85" class="nl md jj bd me nm nn no mh np nq nr mk kp ns kq mn ks nt kt mq kv nu kw mt nv bi translated">参考</h1><ul class=""><li id="4a0d" class="mv mw jj la b lb mx le my lh mz ll na lp nb lt pg nd ne nf bi translated">CPython编译器的设计(<a class="ae jg" href="https://devguide.python.org/compiler/" rel="noopener ugc nofollow" target="_blank">devguide.python.org</a>)</li><li id="d36f" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt pg nd ne nf bi translated">改变CPython的语法(<a class="ae jg" href="https://devguide.python.org/grammar/" rel="noopener ugc nofollow" target="_blank">devguide.python.org</a>)</li><li id="446a" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt pg nd ne nf bi translated">CPython解析器指南(<a class="ae jg" href="https://devguide.python.org/parser/" rel="noopener ugc nofollow" target="_blank">devguide.python.org</a>)</li><li id="628f" class="mv mw jj la b lb ng le nh lh ni ll nj lp nk lt pg nd ne nf bi translated">CPython内部(<a class="ae jg" href="https://realpython.com/products/cpython-internals-book/" rel="noopener ugc nofollow" target="_blank">realpython.com</a></li></ul><p id="f70f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[1]<a class="ae jg" href="https://www.python.org/download/alternatives/" rel="noopener ugc nofollow" target="_blank">https://www.python.org/download/alternatives/</a></p><p id="7037" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">大声喊出来，给本尼迪克特评这篇文章！</em></p><p id="d83d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章并不完美(我花了几个星期才写完😮‍💨)所以如果你看到任何错误，请在下面留下评论！</p></div></div>    
</body>
</html>