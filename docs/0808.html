<html>
<head>
<title>Deep dive into how Kubernetes REST API works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探究Kubernetes REST API的工作原理</h1>
<blockquote>原文：<a href="https://itnext.io/deep-dive-into-how-kubernetes-rest-api-works-517c86f1640b?source=collection_archive---------1-----------------------#2018-06-01">https://itnext.io/deep-dive-into-how-kubernetes-rest-api-works-517c86f1640b?source=collection_archive---------1-----------------------#2018-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0657" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我们一直在研究Kubernetes REST API是如何工作的，以找出如下问题的答案:</p><p id="76be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-如何/在哪里定义从REST路径到处理REST调用的函数的映射？</p><p id="6958" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-与etcd的交互发生在哪里？</p><p id="113c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-从客户端发出请求到对象保存在etcd中，端到端路径是什么样的？</p><p id="3c1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章试图回答这些问题。Kubernetes的代码相当复杂，所以这里的演示是我们目前理解的最好的。</p><p id="2174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes REST实现可以大致分为三个部分，如下图所示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0dc147c13710d2d5f51aa5706c38f907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFcm0EtfDOKfZWLZVgAE1g.jpeg"/></div></div></figure><p id="be1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户机/服务器功能是通过k8s.io包中的各种库实现的。服务器端的实现分布在几个包中。服务器端的主包是“apiserver”。其中的重要包是“端点”、“服务器”、“注册表”和“存储”。客户端在client-go包中实现。其中的主包是“rest”。</p><p id="367d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在详细介绍这些包之前，这里有一些您应该记住的关键Kubernetes术语/概念。</p><ol class=""><li id="496a" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">group:Kubernetes REST API以“/API”为根组织在一个层次结构中。一个组为这个根下的一组REST资源定义了一个逻辑名。API组的一个例子是“应用程序”，它在层次结构中表示为“/API/应用程序”。您可以使用以下命令检查所有可用的API组:</li></ol><pre class="km kn ko kp gt lg lh li lj aw lk bi"><span id="3598" class="ll lm iq lh b gy ln lo l lp lq">kubectl get --raw /apis | python -mjson.tool</span></pre><p id="5940" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2)版本:Kubernetes REST APIs有版本。版本名用于定义在一个组中一起发展的REST资源端点。典型的版本名称有:v1、v1alpha1、v1beta1等。您可以使用以下命令找到API组的所有可用版本:kubectl get — raw /apis/ <group-name>示例:</group-name></p><pre class="km kn ko kp gt lg lh li lj aw lk bi"><span id="31eb" class="ll lm iq lh b gy ln lo l lp lq">kubectl get --raw /apis/apps | python -mjson.tool</span></pre><p id="d0cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3)类型:表示概念的命名实体(例如:Pod、部署、服务等)。).</p><p id="3e9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4)种类:Kubernetes类型的JSON/YAML表示。</p><p id="7dc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5)资源:处理特定类型的REST请求的端点/路径。资源在api层次结构中表示如下:/APIs/<group>/<version>/namespaces/<namespace>/<kind-plural>(例如:/APIs/apps/v1/namespaces/default/deployments)</kind-plural></namespace></version></group></p><p id="da25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lr">服务器端:</em></p><p id="d144" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当研究服务器端时，我们着重回答以下问题:a)资源安装在服务器的什么位置？b)与etcd的交互发生在哪里？</p><p id="333d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1) genericapiserver.go:该文件定义了<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go#L49" rel="noopener ugc nofollow" target="_blank"> APIGroupInfo类型</a>，用于保存关于API组的信息，例如存在哪些版本，以及在那些版本中定义了哪些资源。它定义了<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go#L75" rel="noopener ugc nofollow" target="_blank"> GenericAPIServer类型</a>，该类型实现了为API组安装REST端点的<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go#L357" rel="noopener ugc nofollow" target="_blank"> InstallAPIGroup方法</a>。这个方法<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go#L328" rel="noopener ugc nofollow" target="_blank">在内部调用api groupversion实例上的InstallREST方法</a>。为了开始运行服务器，GenericAPIServer包含Run()方法。</p><p id="b869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2) groupversion.go:该文件定义了<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/endpoints/groupversion.go#L41" rel="noopener ugc nofollow" target="_blank"> apiGroupVersion类型</a>，该类型用于保存关于API组的特定版本的信息，例如对提供实际REST端点实现(store.go)的对象的引用。它还定义了InstallREST方法，该方法<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/endpoints/groupversion.go#L98" rel="noopener ugc nofollow" target="_blank">在内部调用installer </a>上的Install方法来为该版本安装REST资源。</p><p id="a88c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3) installer.go:这个文件定义了APIInstaller类型，它实现了<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/endpoints/installer.go#L94" rel="noopener ugc nofollow" target="_blank">安装方法</a>。该方法使用GroupVersion实例中的REST实现对象(参见第2点)在<a class="ae ls" href="https://github.com/emicklei/go-restful" rel="noopener ugc nofollow" target="_blank"> go-restful库</a>中安装REST路径到处理函数的映射。使用这个库时的模式是<a class="ae ls" href="http://ernestmicklei.com/2012/11/go-restful-first-working-example/" rel="noopener ugc nofollow" target="_blank">定义一个‘处理程序’函数，为一个特定的REST路径</a>调用。该模式在installer.go中用于设置对应于不同资源端点的处理程序。例子:<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/endpoints/installer.go#L583" rel="noopener ugc nofollow" target="_blank"> ws。获取(行动。路径)。</a>至(处理程序)。这里的“handler”是从GroupVersion实例的REST实现对象中获得的函数。它被定义为在处理对“action”的GET请求时被调用。路径。</p><p id="035e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4) master.go:这个文件定义了master类型，它保存了指向GenericAPIServer实例的指针。它定义了<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/pkg/master/master.go#L404" rel="noopener ugc nofollow" target="_blank"> InstallAPIs方法</a>，该方法通过<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/pkg/master/master.go#L432" rel="noopener ugc nofollow" target="_blank">调用genericapiserver的InstallAPIGroup方法</a>来启动注册工作流。当创建Master的新实例时，将调用InstallAPIs方法。</p><p id="ed88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5) registry/rest/rest.go:这个文件定义了各种接口，任何想要提供类似Kubernetes的rest端点的后端都应该实现这些接口。该文件中的关键接口有:<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/registry/rest/rest.go#L55" rel="noopener ugc nofollow" target="_blank">存储</a>和<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/registry/rest/rest.go#L270" rel="noopener ugc nofollow" target="_blank">标准存储</a>。groupversion.go中由APIGroupVersion维护的对rest实现对象的<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/endpoints/groupversion.go#L42" rel="noopener ugc nofollow" target="_blank">引用属于REST类型。存储接口。</a></p><p id="80bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6)registry/generic/registry/Store . go:该文件定义了实现其余部分的<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go#L80" rel="noopener ugc nofollow" target="_blank">存储类型</a>。标准存储接口。方法实现对由存储类型维护的<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go#L176" rel="noopener ugc nofollow" target="_blank">存储对象</a>进行调用。该对象属于存储类型。界面(见下文)。</p><p id="bcdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">7) storage/interfaces.go:这个文件定义了一个名为“Interface”的接口<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/interfaces.go#L115" rel="noopener ugc nofollow" target="_blank">，它包含了我们希望用于实际持久性的任何存储应该实现的方法。关于这个接口中的方法的一个关键点是，它们只返回一个“错误”而不返回其他任何东西。如果某个方法需要返回任何数据，它会通过一个对象返回，该对象的指针作为参数传递给该方法。例如，检查Get方法</a>的<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/interfaces.go#L151" rel="noopener ugc nofollow" target="_blank">签名。</a></p><p id="fb8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">8) storage/etcd3/store.go:该文件定义了实现storage.Interface的<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go#L62" rel="noopener ugc nofollow" target="_blank">存储类型</a>，使用etcd <a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go#L129" rel="noopener ugc nofollow" target="_blank"> clientv3库</a>与etcd3交互。</p><p id="0184" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lr">客户端:</em></p><p id="b549" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在客户端，我们重点回答以下问题REST调用是如何进行的？</p><p id="7482" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1) request.go:这个文件定义了<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/rest/request.go#L80" rel="noopener ugc nofollow" target="_blank">请求类型</a>，它实现了对资源进行REST调用的方法。进行调用的模式是首先创建一个NewRequest对象，然后使用<a class="ae ls" href="https://github.com/kubernetes/client-go/blob/master/rest/request_test.go#L1044" rel="noopener ugc nofollow" target="_blank">流畅风格的方法链接来调用REST方法</a> (GET、POST、PUT、DELETE)。资源的名称和命名空间对于创建完整的端点至关重要，它们是通过链接的方法调用来定义的。</p><p id="c575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2) client.go:该文件定义了一个名为<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/rest/client.go#L43" rel="noopener ugc nofollow" target="_blank">‘Interface’</a>的接口，该接口包含返回请求对象指针(在request.go中定义)的REST方法包装器。它还定义了实现这个接口的<a class="ae ls" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/rest/client.go#L61" rel="noopener ugc nofollow" target="_blank"> RESTClient类型</a>。进行REST调用的模式是首先创建一个NewRESTClient，并通过REST方法包装器之一获得一个NewRequest对象。一旦NewRequest对象可用，REST调用就使用方法链进行，如上所述。</p><p id="dcbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lr">观察:</em></p><p id="abbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">a) Kubernetes代码被广泛记录。这有助于弄清楚一段代码中发生了什么。</p><p id="1038" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">b)有些地方类型隐式地实现了方法。在接口中收集这样的方法会很好。这将使该类型实现什么方法变得显而易见。(注册表包很好地做到了这一点，但installer.go是一个不会发生这种情况的例子。)</p><p id="900b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">c) Golang导入别名可以帮助判断一个方法来自哪个包。虽然代码确实使用了别名，但是还有更广泛地使用它们的余地。</p><p id="f81e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lr">结论:</em></p><p id="c8a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes代码库很大。在这篇文章中，我们试图了解它的一个方面REST API。在以后的文章中，我们可能会对Kubernetes的其他部分进行类似的深入研究。如果您对任何特定部分感兴趣，请随时在回复中告诉我们。</p><p id="7b41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ls" href="http://www.cloudark.io/" rel="noopener ugc nofollow" target="_blank"> www.cloudark.io </a></p></div></div>    
</body>
</html>