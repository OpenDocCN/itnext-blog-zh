<html>
<head>
<title>"Who's There": Simple Swift app for chatting with colleagues around</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“谁在那里”:用于与周围同事聊天的简单Swift应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/whos-there-simple-swift-app-for-chatting-with-colleagues-around-a88ff765736f?source=collection_archive---------1-----------------------#2017-07-18">https://itnext.io/whos-there-simple-swift-app-for-chatting-with-colleagues-around-a88ff765736f?source=collection_archive---------1-----------------------#2017-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3ad7c1003a6d01a9b545ce266eebef7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjuh1euzlFSLJ0nv_CP4_g.png"/></div></div></figure><p id="dc2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在熟悉了<a class="ae kw" href="https://developer.apple.com/documentation/corebluetooth" rel="noopener ugc nofollow" target="_blank">核心蓝牙(CB) </a>框架之后，我们决定构建一个简单的iOS( <a class="ae kw" href="https://www.apple.com/swift/" rel="noopener ugc nofollow" target="_blank"> Swift) </a> app，提供附近设备之间的通信。虽然我们可以通过这个框架访问所有蓝牙低能耗(BLE)设备，但我们只对安装我们应用的设备感兴趣。</p><p id="851e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CB框架遵循BLE协议和蓝牙4.0规范。有两个主要玩家作为<strong class="ka ir">中央</strong>和<strong class="ka ir">外围。</strong>在本教程中，每个设备都充当中央设备和外围设备。</p><p id="2c3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在下面找到源代码</p><div class="kx ky gp gr kz la"><a href="https://github.com/LINKIT-Group/who-is-there" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">联系小组/谁在那里</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">Blutooth Low Energy的游乐场，找到附近的同事并进行简单的交流</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">github.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jw la"/></div></div></a></div><p id="c362" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1。注册我们的设备</strong></p><p id="b1b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个应用程序从一个注册屏幕开始，在这里你可以选择一个头像，选择一种颜色并输入一个名字。这部分与核心蓝牙框架无关；这只是一个简单的收集一些信息的屏幕。在下面的屏幕中，我们将<a class="ae kw" href="https://developer.apple.com/documentation/corebluetooth/cbperipheralmanager/1393252-startadvertising" rel="noopener ugc nofollow" target="_blank">将此信息作为<strong class="ka ir">外围设备</strong>和<strong class="ka ir">进行广告</strong></a>，作为<strong class="ka ir">中央设备</strong>扫描其他外围设备。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/340b7cda2df49f37acfbf49fc1ff4855.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*evjcbdXk1XJTP4EoCg1-8Q.png"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">注册我们的用户</figcaption></figure><p id="1ff4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。将其他设备作为中心进行扫描</strong></p><p id="9f38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们的设备将既是<strong class="ka ir">外围设备</strong>又是<strong class="ka ir">中心设备</strong>，所以让我们在<code class="fe ly lz ma mb b">viewDidLoad</code>方法中创建<code class="fe ly lz ma mb b">CBCentralManager</code>和<code class="fe ly lz ma mb b">CBPeripheralManager</code>。</p><pre class="lq lr ls lt gt mc mb md me aw mf bi"><span id="fe95" class="mg mh iq mb b gy mi mj l mk ml">centralManager = CBCentralManager(delegate: self, queue: DispatchQueue.main)</span><span id="009c" class="mg mh iq mb b gy mm mj l mk ml">peripheralManager = CBPeripheralManager(delegate: self, queue: nil)</span></pre><p id="ad4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们用扩展定义必要的委托，可读性会更好。我们需要实现的第一个委托是<code class="fe ly lz ma mb b">CBCentralManagerDelegate</code>。当调用<code class="fe ly lz ma mb b">centralManagerDidUpdateState</code>方法时，我们需要检查状态是否为<code class="fe ly lz ma mb b">.poweredOn</code>。在这里，我们将扫描其他外设。为此，我们使用一个特定于我们应用的UUID来过滤掉所有其他BLE设备。要生成一个随机的唯一id，您可以在终端中运行<code class="fe ly lz ma mb b">uuidgen</code>命令。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b8de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦发现一个外设，就调用<code class="fe ly lz ma mb b">didDiscover</code>方法。我们通过键<code class="fe ly lz ma mb b">CBAdvertisementDataLocalNameKey</code>读取由每个外围设备发送的广告数据，并列出所有可用的设备。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/4735d66015d14e1e7f66bcb3e93d76e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*0wBTu6Opcco3lbZcod0V7Q.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">找到了附近的同事</figcaption></figure><p id="f8c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。作为外设的广告信息</strong></p><p id="ea76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要实现的第二个委托是<code class="fe ly lz ma mb b">CBPeripheralManagerDelegate</code>。类似于centralManager，我们等待调用<code class="fe ly lz ma mb b">peripheralManagerDidUpdateState</code>方法，并检查状态是否为<code class="fe ly lz ma mb b">.poweredOn</code>。然后，我们开始宣传从注册屏幕上收集的信息。在公布数据时，我们还需要使用之前生成的相同的UUID。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0e37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。背景模式</strong></p><p id="261f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与核心蓝牙框架相关的后台执行模式有两种，<code class="fe ly lz ma mb b">bluetooth-central</code>和<code class="fe ly lz ma mb b">bluetooth-peripheral</code>。当应用程序在后台时，我们对扫描蓝牙设备不感兴趣。所以我们只用<code class="fe ly lz ma mb b">bluetooth-peripheral</code>。为了启用该模式，从项目导航器中单击您的项目名称，选择您的目标，在Capabilities下，滚动到后台模式并选择<code class="fe ly lz ma mb b">Act as a Bluetooth LE accessory</code>。之后，打开你的。plist文件并检查所需的后台模式键是否已经存在，如果没有，为键<code class="fe ly lz ma mb b">Required background modes.</code>添加<code class="fe ly lz ma mb b">App shares data using CoreBluetooth</code></p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/49e689d505ce4e55fa082bb5844f13d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*hXTxZlCDlrEtI99g_39unA.png"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">当用户使用应用程序时，他们会收到关于这种背景模式的通知。</figcaption></figure><p id="ea59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于在背景中做广告的一个障碍是，当外围设备在背景中时，我们不能做额外信息的广告。</p><p id="7757" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自<a class="ae kw" href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/CoreBluetoothBackgroundProcessingForIOSApps/PerformingTasksWhileYourAppIsInTheBackground.html" rel="noopener ugc nofollow" target="_blank">苹果文件</a>:</p><blockquote class="mq mr ms"><p id="0e30" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">CBAdvertisementDataLocalNameKey广告密钥被忽略，并且不广告外围设备的本地名称</p></blockquote><p id="49f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在后台我们只获得外围设备的CBUUID。这也不是可靠的唯一id，因为一旦设备的蓝牙被关闭并再次打开，这个id就不再是相同的了。解决这个问题超出了本教程的范围。</p><p id="09a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 4。与同事聊天</strong></p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/ed9e060bb4b99db336f7f46ef718a7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*GeFdQuptRj4guZZpfoAXmw.png"/></div></figure><p id="17bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一部分是给我们的同事发信息<strong class="ka ir">。</strong>如前所述，我们的设备既是<strong class="ka ir">中央</strong>又是<strong class="ka ir">外围。</strong>因此，<strong class="ka ir"> </strong>对于两种角色，我们需要实现的东西是不同的。先说外围部分。</p><p id="744b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">初始化外围设备的服务和特性</strong></p><p id="473c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ly lz ma mb b">peripheralManagerDidUpdateState</code>方法上，在开始广告之前，我们初始化外围设备的服务和特性，以便将值从中央写入外围设备。同样，我们为这个特征生成一个随机UUID。因此，当作为中心写入时，我们只写入这个特定的标识符。</p><pre class="lq lr ls lt gt mc mb md me aw mf bi"><span id="0f92" class="mg mh iq mb b gy mi mj l mk ml">let WR_UUID = CBUUID(string: "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX")<br/>let WR_PROPERTIES: CBCharacteristicProperties = .write<br/>let WR_PERMISSIONS: CBAttributePermissions = .writeable</span></pre><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2697" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ly lz ma mb b">CBPeripheralManagerDelegate</code>的第二种方法是接收中央写的消息。将响应和成功结果一起发送回中心也是一个很好的做法。</p><p id="4836" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">从中央写入数值</strong></p><p id="5a11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们能够写出我们想要的东西之前，我们需要采取几个步骤。第一件事是连接到目标外设。在输入我们的消息并按下发送按钮后，我们尝试连接到外围设备。</p><pre class="lq lr ls lt gt mc mb md me aw mf bi"><span id="4769" class="mg mh iq mb b gy mi mj l mk ml">centralManager?.connect(selectedPeripheral!, options: nil)</span></pre><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a25d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦<code class="fe ly lz ma mb b">didConnect</code>方法被调用，我们就调用外设的<code class="fe ly lz ma mb b">discoverServices</code>方法。从这一点，我们得到了<code class="fe ly lz ma mb b">CBPeripheralDelegate</code>的方法。当调用<code class="fe ly lz ma mb b">didDiscoverServices</code>方法时，操作链继续为每个服务调用<code class="fe ly lz ma mb b">discoverCharacteristics</code>。最后，当我们在<code class="fe ly lz ma mb b">didDiscoverCharacteristicsFor</code>方法中获得特性时，我们只为我们之前提到的特定特性将值写入目标外设。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d626" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 5。改进</strong></p><p id="b173" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一些可以改进的地方没有包含在本教程中，例如:</p><ul class=""><li id="d669" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">检索时缓存扫描的外围设备的信息，甚至当外围设备上的应用程序进入后台时也显示该信息</li><li id="71d9" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">当应用程序在后台时向设备发送消息(目前，只有当两个应用程序都在前台时，才能从中央向外围设备写入值)</li><li id="7669" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">让此应用程序与Android设备通信</li></ul><p id="6a6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个简短的介绍旨在探索我们可以通过核心蓝牙框架实现什么。我们希望本教程将是你进一步实现的一步。</p></div></div>    
</body>
</html>