<html>
<head>
<title>Testing your JavaScript in a browser with Jest, Puppeteer, Express, and Webpack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jest、Puppeteer、Express和Webpack在浏览器中测试您的JavaScript</h1>
<blockquote>原文：<a href="https://itnext.io/testing-your-javascript-in-a-browser-with-jest-puppeteer-express-and-webpack-c998a37ef887?source=collection_archive---------2-----------------------#2018-06-13">https://itnext.io/testing-your-javascript-in-a-browser-with-jest-puppeteer-express-and-webpack-c998a37ef887?source=collection_archive---------2-----------------------#2018-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6cdd21433dec0d4265a3d06f795b9d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RU9kQbtTj6AV6XcWBu2wYA.png"/></div></div></figure><div class=""/><p id="02cb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">更新(2019/04/17): </strong> <em class="kw">重新格式化测试服务器代码，以涵盖更多一般情况。还包括关于设置jest-puppeter . config . js的信息</em></p><p id="51d0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在最近的几个项目中，我发现自己不得不测试只能在浏览器中运行的代码。有很多方法可以做到这一点，但我找到了大多数关于<a class="ae kx" href="https://github.com/smooth-code/jest-puppeteer" rel="noopener ugc nofollow" target="_blank">Jest-puppet er</a>的文档，它基于<a class="ae kx" href="https://facebook.github.io/jest/en" rel="noopener ugc nofollow" target="_blank"> Jest </a>，脸书的JavaScript测试框架，和<a class="ae kx" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank">puppet er</a>，官方的headless Google Chrome API。本文将演示如何开始使用jest-puppet er，以及如何通过<a class="ae kx" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>轻松使用它。</p><p id="3964" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://github.com/czycha/example-jest-puppeteer-webpack" rel="noopener ugc nofollow" target="_blank">你可以在GitHub </a>上看到完整的示例源代码。</p><h1 id="b583" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">示例项目</h1><p id="6f96" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">经过几个月的思考和研究，您已经提出了热门的新Node.js库:<em class="kw"> foo </em>。<em class="kw"> foo </em>是一个创新的新函数，调用时返回字符串<em class="kw"> bar </em>。惊人！</p><p id="552f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是<em class="kw"> foo: </em>的起始目录结构</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="fa1f" class="mk kz jb mg b gy ml mm l mn mo">foo/<br/>| index.js<br/>| package.json</span></pre><p id="38e6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://github.com/czycha/example-jest-puppeteer-webpack/blob/master/index.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> index.js </strong> </a></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0000" class="mk kz jb mg b gy ml mm l mn mo">function foo() {<br/> return 'bar';<br/>}</span><span id="8de0" class="mk kz jb mg b gy mp mm l mn mo">module.exports = foo;</span></pre><h1 id="d561" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤1:安装</h1><p id="4f38" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在Node.js项目中，您需要安装如下模块:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e3ba" class="mk kz jb mg b gy ml mm l mn mo">yarn add -D express jest jest-cli jest-puppeteer puppeteer webpack webpack-dev-middleware</span></pre><p id="63d5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e57d" class="mk kz jb mg b gy ml mm l mn mo">npm i -D express jest jest-cli jest-puppeteer puppeteer webpack webpack-dev-middleware</span></pre><h2 id="e5bb" class="mk kz jb bd la mq mr dn le ms mt dp li kj mu mv lm kn mw mx lq kr my mz lu na bi translated">每个模块的功能</h2><ul class=""><li id="a412" class="nb nc jb ka b kb lw kf lx kj nd kn ne kr nf kv ng nh ni nj bi translated">jest和jest-cli: 这是我们要用来测试程序逻辑的东西。</li><li id="ff64" class="nb nc jb ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">这将允许我们像一个用户一样与网页互动。它还可以注入脚本运行到网页中，这可以根据我们正在制作的程序类型派上用场。</li><li id="7f28" class="nb nc jb ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">小丑和木偶师的结合。为测试浏览器代码添加了自动安装和拆卸Puppeteer和可选的本地服务器。</li><li id="d848" class="nb nc jb ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><a class="ae kx" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">Express</strong></a><strong class="ka jc">:</strong>Express将是我们作为本地测试服务器所使用的。</li><li id="a90f" class="nb nc jb ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><strong class="ka jc"> webpack和</strong><a class="ae kx" href="https://github.com/webpack/webpack-dev-middleware" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">web pack-dev-middleware</strong></a><strong class="ka jc">:</strong>我们可以使用这些模块自动为我们的测试服务器网页提供浏览器编译的JavaScript。</li></ul><h1 id="1505" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤2: Webpack设置</h1><p id="855a" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">接下来，如果您还没有为您的项目安装Webpack，那么您应该这样做。这里不需要发生什么特别的事情——只需根据您的需要进行配置。</p><p id="e908" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://github.com/czycha/example-jest-puppeteer-webpack/blob/master/webpack.config.js" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">web pack . config . js</strong></a></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="87fc" class="mk kz jb mg b gy ml mm l mn mo">module.exports = {<br/>  entry: './index.js',<br/>  output: {<br/>    filename: 'index.min.js',<br/>    library: 'foo'<br/>  },<br/>  mode: 'production'<br/>}</span></pre><h1 id="ea8e" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤3:服务器设置</h1><p id="8b9b" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">接下来，您需要设置您的测试服务器。首先，在项目中创建一个名为<code class="fe np nq nr mg b">test</code>的目录。在这个文件夹中，创建一个名为<code class="fe np nq nr mg b">server.js</code>的JavaScript文件。</p><p id="fd94" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们一步一步地构建这个文件(<a class="ae kx" href="https://github.com/czycha/example-jest-puppeteer-webpack/blob/master/test/server.js" rel="noopener ugc nofollow" target="_blank">你可以在GitHub </a>上看到完整的文件)。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="1d34" class="mk kz jb mg b gy ml mm l mn mo">const express = require('express')<br/>const webpack = require('webpack')<br/>const middleware = require('webpack-dev-middleware')</span></pre><p id="01c2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要Express作为我们的web服务器、Webpack和webpack-dev-middleware，用于将我们编译的脚本注入页面。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="953b" class="mk kz jb mg b gy ml mm l mn mo">const compiler = webpack(require('../webpack.config.js'))</span></pre><p id="3b20" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们基于<em class="kw"> webpack.config.js </em>文件初始化一个Webpack编译器。如果需要，我们也可以省去中间人，只在这里定义设置。这将允许我们对测试环境进行单独的设置。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7b3a" class="mk kz jb mg b gy ml mm l mn mo">// Turns input into an array if not one already<br/>function normalizeArray (arr) {<br/>  return Array.isArray(arr) ? arr : [arr]<br/>}</span><span id="8ee9" class="mk kz jb mg b gy mp mm l mn mo">// Gets all the Javascript paths that Webpack has compiled, across chunks<br/>function getAllJsPaths (webpackJson) {<br/>  const { assetsByChunkName } = webpackJson<br/>  return Object.values(assetsByChunkName).reduce((paths, assets) =&gt; {<br/>    for (let asset of normalizeArray(assets)) {<br/>      if (asset != null &amp;&amp; asset.endsWith('.js')) {<br/>        paths.push(asset)<br/>      }<br/>    }<br/>    return paths<br/>  }, [])<br/>}</span><span id="2c1f" class="mk kz jb mg b gy mp mm l mn mo">// Optionally, just get the Javascript paths from specific chunks<br/>function getJsPathsFromChunks (webpackJson, chunkNames) {<br/>  const { assetsByChunkName } = webpackJson<br/>  chunkNames = normalizeArray(chunkNames)<br/>  return chunkNames.reduce((paths, name) =&gt; {<br/>    if (assetsByChunkName[name] != null) {<br/>      for (let asset of normalizeArray(assetsByChunkName[name])) {<br/>        if (asset != null &amp;&amp; asset.endsWith('.js')) {<br/>          paths.push(asset)<br/>        }<br/>      }<br/>    }<br/>    return paths<br/>  }, [])<br/>}</span></pre><p id="3db2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一节中，我将定义一些有用的函数来处理webpack-dev-middleware的输出。<code class="fe np nq nr mg b">getAllJsPaths</code>将返回由中间件生成的所有JavaScript文件的路径数组。<code class="fe np nq nr mg b">getJsPathsFromChunks</code>将只返回属于第二个参数中定义的块的JavaScripts路径。请随意选择一个或根据自己的标准进行调整！</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="98e2" class="mk kz jb mg b gy ml mm l mn mo">let port = 4444<br/>const index = Math.max(process.argv.indexOf('--port'), process.argv.indexOf('-p'))<br/>if (index !== -1) {<br/>  port = +process.argv[index + 1] || port<br/>}</span><span id="62aa" class="mk kz jb mg b gy mp mm l mn mo">const app = express()<br/>  .use(middleware(compiler, { serverSideRender: true }))<br/>  .use((req, res) =&gt; {<br/>    const webpackJson = res.locals.webpackStats.toJson()<br/>    const paths = getAllJsPaths(webpackJson)<br/>    res.send(<br/>      `&lt;!DOCTYPE html&gt;<br/>      &lt;html&gt;<br/>        &lt;head&gt;<br/>          &lt;title&gt;Test&lt;/title&gt;<br/>        &lt;/head&gt;<br/>        &lt;body&gt;<br/>          &lt;div id="root"&gt;&lt;/div&gt;<br/>          ${paths.map((path) =&gt; `&lt;script src="${path}"&gt;&lt;/script&gt;`).join('')}<br/>        &lt;/body&gt;<br/>      &lt;/html&gt;`<br/>    )<br/>  })<br/>  .listen(port, () =&gt; {<br/>    console.log(`Server started at <a class="ae kx" href="http://localhost:${port}/`" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}/`</a>)<br/>  })</span></pre><p id="42b4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生了一些事情。在第一位，我们确定端口号，以防它通过<code class="fe np nq nr mg b">--port</code>或<code class="fe np nq nr mg b">-p</code>传入。默认情况下，端口为<code class="fe np nq nr mg b">4444</code>。</p><p id="175e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们定义了Express服务器，并将webpack-dev-middleware附加到它上面。然后我们使用<code class="fe np nq nr mg b">getAllJsPaths</code>函数处理它的输出，用JavaScript生成我们的测试网页。最后，服务器被告知监听之前定义的端口号。</p><p id="3974" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请随意调整HTML以适应您项目的需要。你甚至可以使用模板引擎，如<a class="ae kx" href="https://pugjs.org/" rel="noopener ugc nofollow" target="_blank"> Pug </a>来生成你的HTML。对于更全面的测试，您可以使用<a class="ae kx" href="https://expressjs.com/en/guide/routing.html" rel="noopener ugc nofollow" target="_blank"> routing </a>为不同的测试创建不同的页面。</p><p id="dcb4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您应该进入您的<a class="ae kx" href="https://github.com/czycha/example-jest-puppeteer-webpack/blob/master/package.json" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> package.json </em> </a>文件并添加一个脚本来启动您的服务器，如下所示:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c558" class="mk kz jb mg b gy ml mm l mn mo">{<br/>  ...<br/>  "scripts": {<br/>    "serve": "node test/server.js"<br/>  },<br/>  ...<br/>}</span></pre><p id="e212" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以通过<code class="fe np nq nr mg b">yarn serve</code>(或<code class="fe np nq nr mg b">npm run serve</code>)来运行。然后你可以在<code class="fe np nq nr mg b"><a class="ae kx" href="http://localhost:4444" rel="noopener ugc nofollow" target="_blank">http://localhost:4444</a></code>访问该页面。</p><h1 id="f1d2" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤4:笑话设置</h1><p id="5678" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">快到了！现在我们需要把jest和Jest木偶师分清楚。</p><p id="7081" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要么通过你的<em class="kw"> package.json </em>要么通过<em class="kw"> jest.config.js </em>，<a class="ae kx" href="https://facebook.github.io/jest/docs/en/configuration.html" rel="noopener ugc nofollow" target="_blank">配置Jest </a>。</p><p id="1729" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://github.com/czycha/example-jest-puppeteer-webpack/blob/master/package.json" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> package.json示例</strong> </a></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0c52" class="mk kz jb mg b gy ml mm l mn mo">{<br/>  ...<br/>  "jest": {<br/>    "preset": "jest-puppeteer",<br/>    "globals": {<br/>      "PATH": "<a class="ae kx" href="http://localhost:4444" rel="noopener ugc nofollow" target="_blank">http://localhost:4444</a>"<br/>    },<br/>    "testMatch": [<br/>      "**/test/**/*.test.js"<br/>    ]<br/>  },<br/>  ...<br/>}</span></pre><p id="73bb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> jest.config.js示例</strong></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4501" class="mk kz jb mg b gy ml mm l mn mo">module.exports = {<br/>  preset: "jest-puppeteer",<br/>  globals: {<br/>    PATH: "<a class="ae kx" href="http://localhost:4444" rel="noopener ugc nofollow" target="_blank">http://localhost:4444</a>"<br/>  },<br/>  testMatch: [<br/>    "**/test/**/*.test.js"<br/>  ]<br/>}</span></pre><p id="33b5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的具体配置可能需要与此不同，但至少应该将<code class="fe np nq nr mg b">"jest-puppeteer"</code>设置为<code class="fe np nq nr mg b">preset</code>。在这里，我还添加了服务器地址作为一个全局变量，并更改了测试匹配模式，这样它就不会匹配<em class="kw"> test/server.js </em>。</p><p id="e8bb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还需要通过定义一个<a class="ae kx" href="https://github.com/czycha/example-jest-puppeteer-express-webpack/blob/master/jest-puppeteer.config.js" rel="noopener ugc nofollow" target="_blank"><em class="kw">jest-puppeter . config . js</em></a>文件(<a class="ae kx" href="https://github.com/smooth-code/jest-puppeteer#jest-puppeteerconfigjs" rel="noopener ugc nofollow" target="_blank">官方文档</a>)来配置jest-puppeter:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c50b" class="mk kz jb mg b gy ml mm l mn mo">module.exports = {<br/>  server: {<br/>    command: 'npm run serve',<br/>    port: 4444<br/>  }<br/>}</span></pre><p id="5167" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还应该在您的<em class="kw"> package.json </em>中添加Jest作为脚本:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9942" class="mk kz jb mg b gy ml mm l mn mo">{<br/>  ...<br/>  "scripts": {<br/>    "serve": "node test/server.js",<br/>    <strong class="mg jc">"test": "jest"</strong><br/>  },<br/>  ...<br/>}</span></pre><h1 id="b056" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤5:创建您的测试</h1><p id="de7a" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">你猜怎么着！我们差不多完成了。现在您只需要编写您的测试！参考<a class="ae kx" href="https://facebook.github.io/jest/docs/en/getting-started.html" rel="noopener ugc nofollow" target="_blank"> Jest </a>、<a class="ae kx" href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md" rel="noopener ugc nofollow" target="_blank">木偶师</a>和<a class="ae kx" href="https://github.com/smooth-code/jest-puppeteer#api" rel="noopener ugc nofollow" target="_blank">Jest-木偶师</a>文档来构建您的测试用例。下面是我们惊人的<em class="kw"> foo </em>模块的测试用例示例。</p><p id="48d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://github.com/czycha/example-jest-puppeteer-webpack/blob/master/test/foo.test.js" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">test/foo . test . js</strong></a></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ba01" class="mk kz jb mg b gy ml mm l mn mo">describe('foo', () =&gt; {<br/>  beforeEach(async () =&gt; {<br/>    await page.goto(PATH, { waitUntil: 'load' })<br/>  })<br/>  test('should return bar', async () =&gt; {<br/>    const foo = await page.evaluate(() =&gt; {<br/>      console.log('foo');<br/>      return foo();<br/>    })<br/>    expect(foo).toBe('bar')<br/>  })<br/>})</span></pre><p id="6ca1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个测试用例从导航到<code class="fe np nq nr mg b">localhost:4444</code>(我们的<code class="fe np nq nr mg b">PATH</code>)开始，一直等到加载时间。这将在每次测试前导航，以便重新初始化页面。将<code class="fe np nq nr mg b">beforeEach</code>与<code class="fe np nq nr mg b">beforeAll</code>交换将使测试框架只导航一次，所有后续测试都在同一个页面实例上运行。</p><p id="8528" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个实例中的单个测试用例在页面的上下文中异步运行一个脚本，以发挥<em class="kw"> foo的魔力。然后，它使用Jest的匹配器框架来确保结果是预期的。</em></p><h1 id="a83a" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤6:运行您的测试</h1><p id="ba82" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">你所需要做的就是在命令行中运行<code class="fe np nq nr mg b">yarn test</code>(或者<code class="fe np nq nr mg b">npm test</code>)！</p><h1 id="0500" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">进一步阅读</h1><p id="3a74" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这只是一个起点。我建议仔细阅读所使用的各种模块，这样你就可以定制它们来适应你的项目。</p><p id="8efd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，如果你想用一个真正的模块在实践中看到这一点，请查看<a class="ae kx" href="https://github.com/czycha/alchemize" rel="noopener ugc nofollow" target="_blank"> Alchemize </a>的源代码。正是从这个项目中，我获得了示例存储库和这个分步文档。</p><h1 id="f33d" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">可供选择的事物</h1><p id="9af4" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我能找到的唯一一个100%覆盖上述过程的值得注意的替代方法是<a class="ae kx" href="https://github.com/developit/karmatic" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> Karmatic </strong> </a>。Karmatic是一个零配置测试框架，将Karma、Webpack、Jasmine、&amp;puppet er封装在一个模块中。</p><p id="51da" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以替换掉其中的一些关键模块(Jest、Puppeteer、Express、Webpack等。)只要你保持概念和过程不变。</p><p id="a2e7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请随意在评论中分享你正在使用的任何你觉得非常有效的替代方案！</p></div></div>    
</body>
</html>