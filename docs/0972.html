<html>
<head>
<title>GraphQL data hiding using Apollo stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Apollo栈的GraphQL数据隐藏</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-data-hiding-using-apollo-stack-ad1ea92fa85c?source=collection_archive---------2-----------------------#2018-06-26">https://itnext.io/graphql-data-hiding-using-apollo-stack-ad1ea92fa85c?source=collection_archive---------2-----------------------#2018-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn"><p id="4959" class="jo jp iq bd jq jr js jt ju jv jw jx dk translated">如果你的网站有一个私有的GraphQL API，而你不希望人们在浏览器中看到普通的查询和响应，那么下面是你如何使用Apollo栈库来破坏流量。</p></blockquote><h2 id="e321" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">为什么需要隐藏GraphQL流量？</h2><p id="e302" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">如你所知，当浏览器发送HTTP请求时，你的用户只需在浏览器的开发工具中打开网络标签就能看到它们。发送和接收的数据都是纯文本。很容易对你网站的私有API进行逆向工程。有些人可能会出于有害的原因这样做。</p><p id="c222" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">例如，这里有一页来自惊人的<em class="lt">光谱。聊天</em>:<a class="ae lu" href="https://spectrum.chat/explore" rel="noopener ugc nofollow" target="_blank">https://spectrum.chat/explore</a></p><p id="db10" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">下面是他们的GraphQL请求在Chrome DevTools中的样子:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/3e223fbe9a24d4611019aeafd5210d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czUrCrXQGlFXSyjZY7LN1Q.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated"><strong class="bd ka">请求负载</strong>的屏幕截图</figcaption></figure><p id="86de" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">回应是:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ml"><img src="../Images/133e049dcfe8a10bf8e3b24aefecc5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zolAztGeREJwgpElWlvp7Q.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated"><strong class="bd ka">响应预览截图</strong></figcaption></figure><p id="4b8b" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">作者有意让API保持开放。但是当你开发一个高度安全的软件时，你会想要保护自己免受一系列黑客的攻击并隐藏那些数据。</p><h1 id="1499" class="mm jz iq bd ka mn mo mp kd mq mr ms kg mt mu mv kk mw mx my ko mz na nb ks nc bi translated">这个想法</h1><p id="43d7" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">对发送和接收的GraphQL数据进行编码或加密。</p><p id="c8a4" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">下文假设:</p><ul class=""><li id="a905" class="nd ne iq kw b kx lo lb lp kh nf kl ng kp nh jx ni nj nk nl bi translated">您使用的是GraphQL Apollo服务器(但是，您可以将代码应用于任何其他服务器)</li><li id="02a8" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">您使用HTTP POST请求来发送和接收数据(当然，您可以将下面的代码用于所有其他协议)。</li><li id="4052" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">您在客户端使用的是Apollo Client(但是，您当然可以将下面的代码应用于任何其他客户端模块)。</li></ul><p id="b8f8" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">我们将:</p><ul class=""><li id="f844" class="nd ne iq kw b kx lo lb lp kh nf kl ng kp nh jx ni nj nk nl bi translated">劫持发送的Apollo客户端请求，</li><li id="80c4" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">将JSON字符串转换成二进制缓冲区，</li><li id="fd05" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">加密缓冲区<strong class="kw ir">(可选)</strong>，</li><li id="14fe" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">将其序列化为base64，</li><li id="3622" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">将<code class="fe nr ns nt nu b">Content-Type</code> HTTP报头从<code class="fe nr ns nt nu b">application/json</code>更改为<code class="fe nr ns nt nu b">text/plain</code>，</li><li id="8285" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">添加<a class="ae lu" href="https://www.w3.org/Protocols/rfc1341/5_Content-Transfer-Encoding.html" rel="noopener ugc nofollow" target="_blank">标准</a> <code class="fe nr ns nt nu b">Content-Transfer-Encoding: base64</code> HTTP头、</li><li id="e940" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">并将其发送到服务器。</li></ul><p id="d557" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">在服务器端，我们将:</p><ul class=""><li id="0a9d" class="nd ne iq kw b kx lo lb lp kh nf kl ng kp nh jx ni nj nk nl bi translated">在Apollo GraphQL服务器中间件之前添加我们的中间件，</li><li id="bd18" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">使用<code class="fe nr ns nt nu b">Content-Transfer-Encoding</code>头来检测主体是否需要解密，</li><li id="5986" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">将base64字符串转换为二进制缓冲区，</li><li id="603a" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">解密缓冲区<strong class="kw ir">(可选)</strong>，</li><li id="92bb" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">将其作为UTF-8序列化为JSON字符串，</li><li id="eb13" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">将HTTP头<code class="fe nr ns nt nu b">Content-Type</code>改写为<code class="fe nr ns nt nu b">application/json</code>，</li><li id="9b34" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">将请求传递给阿波罗服务器。</li></ul><p id="06ef" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">对服务器回复进行相反的操作——在服务器上劫持和编码，在客户端劫持和解码。</p><h2 id="9253" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">下降趋势</h2><p id="8eaf" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">请注意以下几点:</p><ul class=""><li id="90c1" class="nd ne iq kw b kx lo lb lp kh nf kl ng kp nh jx ni nj nk nl bi translated"><strong class="kw ir">这不是真正的数据保护。不可能在客户端AFAIK上安全地加密数据，因为私钥将保存在浏览器JavaScript代码中。这种方法很适合混淆GraphQL请求和反混淆响应。</strong></li><li id="3508" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">对于本地开发，您可能希望关闭它，而只在生产/暂存环境中启用。(见下文。)</li></ul><h2 id="ca6d" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">编码算法</h2><p id="20ec" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">如果你决定不加密你的数据，那么跳过这一段。但是如果你要进行额外的数据隐藏，那么你需要在服务器端和客户端使用相同的算法。</p><p id="c77f" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">下面是现代浏览器能做的事情的列表(可能列表不完整):<a class="ae lu" href="https://github.com/diafygi/webcrypto-examples" rel="noopener ugc nofollow" target="_blank">https://github.com/diafygi/webcrypto-examples</a></p><p id="e9a6" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">Web Crypto API得到了很好的支持，甚至在IE11中也是如此。就用这个垫片:<a class="ae lu" href="https://github.com/vibornoff/webcrypto-shim" rel="noopener ugc nofollow" target="_blank">https://github.com/vibornoff/webcrypto-shim</a></p><p id="7410" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">下面是node.js的相同webcrypto API实现:<a class="ae lu" href="https://github.com/anvilresearch/webcrypto" rel="noopener ugc nofollow" target="_blank">https://github.com/anvilresearch/webcrypto</a></p><p id="30bb" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">您需要选择node.js和浏览器都支持的算法。</p><h1 id="19cd" class="mm jz iq bd ka mn mo mp kd mq mr ms kg mt mu mv kk mw mx my ko mz na nb ks nc bi translated">实现客户端</h1><h2 id="2db6" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">拦截传出的请求</h2><p id="4ae2" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated"><a class="ae lu" href="https://www.apollographql.com/docs/link/" rel="noopener ugc nofollow" target="_blank"> Apollo文档</a>提供了这段代码，作为如何创建客户端对象的示例:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="7e35" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">import</strong> { ApolloLink } <strong class="nu ir">from</strong> '<em class="lt">apollo-link</em>';<br/><strong class="nu ir">import</strong> { ApolloClient } <strong class="nu ir">from</strong> '<em class="lt">apollo-client</em>';<br/><strong class="nu ir">import</strong> { InMemoryCache } <strong class="nu ir">from</strong> '<em class="lt">apollo-cache-inmemory</em>';<br/><strong class="nu ir">import</strong> { HttpLink } <strong class="nu ir">from</strong> '<em class="lt">apollo-link-http</em>';<br/><br/><strong class="nu ir">const</strong> client = <strong class="nu ir">new</strong> ApolloClient({<br/>  link: <strong class="nu ir">new</strong> HttpLink({ uri: '<em class="lt">http://api.githunt.com/graphql</em>' }),<br/>  cache: <strong class="nu ir">new</strong> InMemoryCache()<br/>});</span></pre><p id="ac54" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">我发现劫持传出请求和传入响应的最简单方法是覆盖可以传递给<code class="fe nr ns nt nu b">HttpLink</code>构造函数的<code class="fe nr ns nt nu b">fetch</code>选项:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="62b5" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">new</strong> HttpLink({<br/>  uri: '<em class="lt">http://api.githunt.com/graphql</em>',<br/>  fetch: myFetchImplementation <strong class="nu ir"><em class="lt">// overwriting the fetch function</em></strong><br/>})</span></pre><p id="cd18" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">让我们从上面实施<code class="fe nr ns nt nu b">myFetchImplementation</code>。</p><h2 id="3e2e" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">覆盖HTTP头</h2><p id="66b8" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">以由<a class="oi oj ep" href="https://medium.com/u/30b8f5921914?source=post_page-----ad1ea92fa85c--------------------------------" rel="noopener" target="_blank">杰森·米勒</a>—<a class="ae lu" href="https://github.com/developit/unfetch/blob/master/src/index.js" rel="noopener ugc nofollow" target="_blank">解锁</a>模块实现的非常简单的获取功能为例。它在引擎盖下用的是<code class="fe nr ns nt nu b">XMLHttpRequest</code>，对老浏览器支持也不错。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="4604" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">function</strong> <!-- -->myFetchImplementation(url, options) {<br/>  <!-- -->options = options || {};</span><span id="3697" class="jy jz iq nu b gy ok of l og oh">...</span></pre><p id="5126" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">检查此请求是否应被破坏:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="10d5" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">const </strong>isEncoding = shouldEncode(url, options);</span></pre><p id="40b2" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">哪里的<code class="fe nr ns nt nu b">shouldEncode()</code>由你来实施。此外，这也是在本地开发中跳过数据隐藏的好地方。例如:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="660e" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">export</strong> <strong class="nu ir">function</strong> shouldEncode(url, options) {<br/>  <strong class="nu ir">if</strong> (process.env.NODE_ENV === "<em class="lt">development</em>") <strong class="nu ir">return false</strong>;</span><span id="0e77" class="jy jz iq nu b gy ok of l og oh">  <strong class="nu ir">if</strong> (!options.method || options.method.toLowerCase() !== "<em class="lt">post</em>")<br/>    <strong class="nu ir">return false</strong>;</span><span id="e6db" class="jy jz iq nu b gy ok of l og oh">  url = url.split("<em class="lt">?</em>")[0].split("<em class="lt">#</em>")[0];<br/>  <strong class="nu ir">if</strong> (!url.endsWith("<em class="lt">/graphql</em>")) <strong class="nu ir">return false</strong>;</span><span id="c9b7" class="jy jz iq nu b gy ok of l og oh">  <strong class="nu ir">return true</strong>;<br/>}</span></pre><p id="b50e" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">让我们开始重新实现<code class="fe nr ns nt nu b">fetch</code>。</p><p id="3708" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated"><code class="fe nr ns nt nu b">fetch</code>应回承诺:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="fde2" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">return new </strong>Promise(<strong class="nu ir">async </strong>(resolve, reject) =&gt; {<br/>  <strong class="nu ir">let </strong>req = <strong class="nu ir">new </strong>XMLHttpRequest();<br/>  req.open(options.method || "<em class="lt">get</em>", url);</span></pre><p id="ab9c" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">是时候添加上面指定的标题了。</p><p id="6e78" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">我们将检查<code class="fe nr ns nt nu b">isEncoding</code>变量，并根据我们的喜好覆盖HTTP头(如上面的<strong class="kw ir">想法</strong>部分所述)。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="b4a7" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">for </strong>(<strong class="nu ir">let </strong>i <strong class="nu ir">in </strong>options.headers) {<br/>  <strong class="nu ir">if </strong>(isEncoding &amp;&amp; i.toLowerCase() === "<em class="lt">content-type</em>") {<br/>    req.setRequestHeader(i, "<em class="lt">text/plain; charset=UTF-8</em>");<br/>    req.setRequestHeader("<em class="lt">Content-Transfer-Encoding</em>", "<em class="lt">base64</em>");<br/>  } <strong class="nu ir">else </strong>{<br/>    req.setRequestHeader(i, options.headers[i]);<br/>  }<br/>}</span><span id="45a6" class="jy jz iq nu b gy ok of l og oh"><em class="lt">// Some additional necessary bits of the fetch() standard function</em><br/>req.withCredentials = options.credentials == "<em class="lt">include</em>";<br/>req.onload = () =&gt; {<br/>    resolve(response());<br/>};<br/>req.onerror = reject;</span></pre><h2 id="066a" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">编码GraphQL请求</h2><p id="3ea0" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">我们的<code class="fe nr ns nt nu b">fetch()</code>函数实现中的下一行只是发送数据:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="ce49" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">let</strong> body = options.body;<br/>req.send(isEncoding ? <strong class="nu ir">await </strong>encodeTextBody(body) : body);</span></pre><p id="7a09" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">现在我们需要实现<code class="fe nr ns nt nu b">encodeTextBody</code>功能。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="86a8" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">function</strong> encodeTextBody(text) {</span><span id="3ca2" class="jy jz iq nu b gy ok of l og oh">  ...</span><span id="6c4e" class="jy jz iq nu b gy ok of l og oh">  <strong class="nu ir">return</strong> encodedText;<br/>}</span></pre><p id="7d12" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">如果您不想加密，那么这里是您需要的实现。它将UTF-8字符串转换为二进制缓冲区，然后转换为base64编码的文本。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="b664" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">let</strong> buffer = <strong class="nu ir">new </strong>Uint8Array(<strong class="nu ir">new </strong>TextEncoder().encode(text));<br/><strong class="nu ir">const</strong> encodedText = btoa(String.fromCharCode.apply(<strong class="nu ir">null</strong>, buffer));</span></pre><h2 id="42af" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">加密GraphQL请求(可选)</h2><p id="07e9" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">如果你想要额外的安全层，那么这里是你如何从上面加密二进制文件<code class="fe nr ns nt nu b">buffer</code>。</p><ol class=""><li id="9918" class="nd ne iq kw b kx lo lb lp kh nf kl ng kp nh jx ol nj nk nl bi translated">创建加密密钥。</li><li id="5ec4" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ol nj nk nl bi translated">用它来加密缓冲区。</li></ol><p id="e752" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">密钥创建可以是这样的。但是您可以从<a class="ae lu" href="https://github.com/diafygi/webcrypto-examples" rel="noopener ugc nofollow" target="_blank">这里</a>选择您的实现:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="ffdd" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">const </strong>key = <strong class="nu ir">await </strong>self.crypto.subtle.importKey(<br/>  "<em class="lt">jwk</em>",<br/>  {<br/>    kty: "<em class="lt">oct</em>",<br/>    k: "<em class="lt">MY SHARED KEY</em>",<br/>    alg: "<em class="lt">A256GCM</em>",<br/>    ext: <strong class="nu ir">true<br/>  </strong>},<br/>  {<br/>    name: "<em class="lt">AES-GCM</em>"<br/>  },<br/>  <strong class="nu ir">false</strong>,<br/>  ["<em class="lt">encrypt</em>", "<em class="lt">decrypt</em>"]<br/>);</span></pre><p id="945d" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">服务器端和客户端的<code class="fe nr ns nt nu b">“<em class="lt">MY SHARED KEY</em>”</code>字符串应该是相同的。您可能想要为每个用户创建一个，或者只是硬编码它。</p><p id="4a32" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">创建一次<code class="fe nr ns nt nu b">key</code>变量(每个浏览器/用户会话)并重用。</p><p id="4502" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">确保在服务器端和客户端使用相同的<code class="fe nr ns nt nu b">iv</code>。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="4cc6" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">const</strong> iv = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);</span></pre><p id="ee68" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">加密缓冲区。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="2f67" class="jy jz iq nu b gy oe of l og oh">buffer = <strong class="nu ir">await </strong>self.crypto.subtle.encrypt(<br/>  {<br/>    name: "<em class="lt">AES-GCM</em>",<br/>    iv,<br/>    tagLength: 128<br/>  },<br/>  key<strong class="nu ir">,</strong><br/>  buffer<br/>);</span></pre><p id="6a19" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated"><code class="fe nr ns nt nu b">buffer</code>现在已经加密了。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi om"><img src="../Images/90a2f2dfaa29bffe56edeb0d85b35e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*iVRDMDwkjU_WBcplBd86ww.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">Chrome DevTools中编码的HTTP请求体示例</figcaption></figure><h2 id="380d" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">解码接收到的响应</h2><p id="e4be" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">下面是我们剩下的<code class="fe nr ns nt nu b">myFetchImplementation</code>。参见<a class="ae lu" href="https://github.com/developit/unfetch/blob/master/src/index.js" rel="noopener ugc nofollow" target="_blank">解锁</a>源代码。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="d5d7" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">function </strong>response() {<br/>  <strong class="nu ir">let </strong>keys = [], all = [], headers = {}, header;<br/><br/>  req.getAllResponseHeaders().<br/>  replace(<em class="lt">/^(.*?):\s*([\s\S]*?)$/gm</em>, (m, key, value) =&gt; {<br/>      keys.push((key = key.toLowerCase()));<br/>      all.push([key, value]);<br/>      header = headers[key];<br/>      headers[key] = header ? `<em class="lt">${header},${value}</em>` : value;<br/>  });<br/><br/>  <strong class="nu ir">return </strong>{<br/>    ok: ((req.status / 200) | 0) == 1<br/>    status: req.status,<br/>    statusText: req.statusText,<br/>    url: req.responseURL,<br/>    clone: response,<br/>    text: <strong class="nu ir">async </strong>() =&gt; (isCrypting ? <br/>      <strong class="nu ir">await </strong>decodeTextBody(req.responseText) : <strong class="nu ir"><em class="lt">// decoding</em></strong><br/>      req.responseText<br/>    ),<br/>    json: <strong class="nu ir">async </strong>() =&gt; JSON.parse(isCrypting ? <br/>      <strong class="nu ir">await </strong>decodeTextBody(req.responseText) : <strong class="nu ir"><em class="lt">// decoding</em></strong><br/>      req.responseText<br/>    ),<br/>    blob: () =&gt; Promise.resolve(<strong class="nu ir">new </strong>Blob([req.response])),<br/>    headers: {<br/>      keys: () =&gt; keys,<br/>      entries: () =&gt; all,<br/>      get: n =&gt; headers[n.toLowerCase()],<br/>      has: n =&gt; n.toLowerCase() <strong class="nu ir">in </strong>headers<br/>    }<br/>  };<br/>}</span></pre><p id="2078" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">唯一剩下的位就是上面的<code class="fe nr ns nt nu b">decodeTextBody()</code>函数。这很简单。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="c284" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">function</strong> decodeTextBody(text) {</span><span id="4ed3" class="jy jz iq nu b gy ok of l og oh">  ...</span><span id="4489" class="jy jz iq nu b gy ok of l og oh"><strong class="nu ir">  return</strong> decodedText;<br/>}</span></pre><p id="41cd" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">如果您不想加密，那么这里是您需要的实现。它将base64字符串转换为二进制缓冲区，然后转换为UTF 8文本。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="7d9f" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">let</strong> buffer = <strong class="nu ir">new </strong>Uint8Array(<br/>  [...atob(text)].map(char =&gt; char.charCodeAt(0))<br/>);<br/><strong class="nu ir">const</strong> decodedText = <strong class="nu ir">new </strong>TextDecoder().decode(buffer);</span></pre><h2 id="47ea" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">解密GraphQL响应(可选)</h2><ol class=""><li id="efc7" class="nd ne iq kw b kx ky lb lc kh on kl oo kp op jx ol nj nk nl bi translated">使用与上述加密功能相同的<code class="fe nr ns nt nu b">key</code>和<code class="fe nr ns nt nu b">iv</code>。</li><li id="f3a7" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ol nj nk nl bi translated">解密缓冲区。</li></ol><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="c37f" class="jy jz iq nu b gy oe of l og oh">buffer = <strong class="nu ir">await </strong>self.crypto.subtle.decrypt(<br/>  {<br/>    name: "<em class="lt">AES-GCM</em>",<br/>    iv,<br/>    tagLength: 128<br/>  },<br/>  key,<br/>  buffer<br/>);</span></pre><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/c72a1977ec941936d64144508c343705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*lGOKlCeFQUM3uapmxSt2_g.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">Chrome DevTools中编码的HTTP响应体示例</figcaption></figure><h1 id="cba7" class="mm jz iq bd ka mn mo mp kd mq mr ms kg mt mu mv kk mw mx my ko mz na nb ks nc bi translated">实现服务器端</h1><h2 id="8783" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">拦截传入的请求</h2><p id="1fd6" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated"><a class="ae lu" href="https://www.apollographql.com/docs/apollo-server/servers/express.html" rel="noopener ugc nofollow" target="_blank"> Apollo documentation </a>提供了这段代码，作为如何将GraphQL中间件添加到Express.js服务器应用程序的示例:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="7092" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">const</strong> bodyParser = require('<em class="lt">body-parser</em>');<strong class="nu ir"><br/>const</strong> { graphqlExpress } = require('<em class="lt">apollo-server-express</em>');</span><span id="aead" class="jy jz iq nu b gy ok of l og oh">app.use(<br/>  '<em class="lt">/graphql</em>',<br/>  bodyParser.json(),<br/>  graphqlExpress({ schema: myGraphQLSchema })<br/>);</span></pre><p id="9b2b" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">在一些node.js框架中，劫持请求和响应很容易。例如，在<code class="fe nr ns nt nu b">koa</code>和<code class="fe nr ns nt nu b">hapi</code>中，您可以拥有预处理程序中间件(用于传入请求)和后处理程序中间件(用于传出响应)。</p><p id="4f5a" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">Express.js更难。我发现劫持Express.js中的传入请求和传出响应的最简单方法是覆盖整个<code class="fe nr ns nt nu b">graphqlExpress</code>函数。好的一面是——它的<a class="ae lu" href="https://github.com/apollographql/apollo-server/blob/master/packages/apollo-server-express/src/expressApollo.ts" rel="noopener ugc nofollow" target="_blank">源代码</a>相当小。甚至比极简的<code class="fe nr ns nt nu b">unfetch</code>模块还要小。感谢阿波罗团队！</p><p id="7979" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">这只是您的中间件的一种表现形式:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="e11c" class="jy jz iq nu b gy oe of l og oh">app.use(<br/>  <em class="lt">'/graphql'</em>, <br/>  require(<em class="lt">"body-parser"</em>).text(),<br/>  graphqlDecode,<br/>  myGraphqlExpressImplementation<br/>);</span></pre><p id="0747" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated"><code class="fe nr ns nt nu b">require(<em class="lt">“body-parser”</em>).text()</code>将创建一个字符串形式的<code class="fe nr ns nt nu b">req.body</code>属性。</p><p id="22bc" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">如果需要的话，<code class="fe nr ns nt nu b">graphqlDecode</code>只是简单地解码请求。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="5175" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">async function </strong>graphqlDecode(req, res, next) {<br/>  <strong class="nu ir">try </strong>{<br/>    <strong class="nu ir">if </strong>(req.get("<em class="lt">content-transfer-encoding</em>") === <em class="lt">"base64"</em>) {<br/>      <strong class="nu ir">const </strong>str = <strong class="nu ir">await </strong>decodeTextBody(req.body); <strong class="nu ir"><em class="lt">// decoding</em></strong><br/>      req.body = JSON.parse(str);<br/>      req.headers[<em class="lt">"content-type"</em>] = <em class="lt">"application/json"</em>;<br/>      req.graphqlWasEncoded = <strong class="nu ir">true</strong>;<br/>    }<br/>    next();<br/>  } <strong class="nu ir">catch </strong>(e) {<br/>    next(e);<br/>  }<br/>}</span></pre><p id="dcbc" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">如您所见，我们检查了“Content-Transfer-Encoding”头，解码了主体，为请求添加了<code class="fe nr ns nt nu b">graphqlWasEncoded</code>标志，并将“Content-Type”重写回“application/json ”,以便Apollo engine可以正确处理它。</p><p id="a2b4" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">而<code class="fe nr ns nt nu b">myGraphqlExpressImplementation</code>就是重新实现的阿波罗<code class="fe nr ns nt nu b">graphqlExpress</code>。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="94aa" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">const </strong>{ runHttpQuery } = require(<em class="lt">"apollo-server-core"</em>);</span><span id="412e" class="jy jz iq nu b gy ok of l og oh"><strong class="nu ir">async function </strong>myGraphqlExpressImplementation(req, res, next) {<br/>  <strong class="nu ir">try </strong>{<br/>    <strong class="nu ir">let </strong>gqlResponse = <strong class="nu ir">await </strong>runHttpQuery([req, res], {<br/>      method: req.method,<br/>      options: {<br/>        schema: mySchema,<br/>        validationRules: myValidationRulesArray<br/>      },<br/>      query: req.method === "<em class="lt">POST</em>" ? req.body : req.query<br/>    });</span><span id="ca6a" class="jy jz iq nu b gy ok of l og oh"><strong class="nu ir">    let </strong>type = <em class="lt">"application/json"</em>;<br/>    <strong class="nu ir">if </strong>(req.graphqlWasEncoded) {<br/>      gqlResponse = <strong class="nu ir">await </strong>encodeTextBody(gqlResponse); <strong class="nu ir"><em class="lt">// encoding</em></strong><br/>      type = <em class="lt">"text/plain"</em>;<br/>      res.setHeader(<em class="lt">"content-transfer-encoding"</em>, <em class="lt">"base64"</em>);<br/>    }</span><span id="85d2" class="jy jz iq nu b gy ok of l og oh">    res.setHeader(<em class="lt">"content-type"</em>, type);<br/>    res.setHeader(<br/>      <em class="lt">"content-length"</em>,<br/>      Buffer.byteLength(gqlResponse, <em class="lt">"utf8"</em>).toString()<br/>    );<br/>    res.write(gqlResponse);<br/>    res.end();<br/>  } <strong class="nu ir">catch </strong>(error) {<br/>    <strong class="nu ir">if </strong>(error.name !== "HttpQueryError") {<br/>      <strong class="nu ir">return </strong>next(error);<br/>    }</span><span id="da95" class="jy jz iq nu b gy ok of l og oh">    res.setHeader(<em class="lt">"Content-Type"</em>, <em class="lt">"application/json"</em>);<br/>    res.setHeader(<br/>      <em class="lt">"Content-Length"</em>,<br/>      Buffer.byteLength(gqlResponse, <em class="lt">"utf8"</em>).toString()<br/>    );<br/>    res.write(gqlResponse);<br/>    res.end();<br/>  }<br/>}</span></pre><p id="c89e" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">在上面的代码中，我们检查了<code class="fe nr ns nt nu b">req.graphqlWasEncoded</code>标志，并对发出的请求进行了编码。简单！</p><p id="4bca" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">剩下的两位是<code class="fe nr ns nt nu b">decodeTextBody</code>和<code class="fe nr ns nt nu b">encodeTextBody</code>函数。</p><h2 id="e7f9" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">解码GraphQL请求</h2><p id="9f30" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">在node.js中将base64转换成utf8非常简单。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="fe94" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">async </strong>decodeTextBody(text) {<br/>  <strong class="nu ir">let</strong> buffer = Buffer.from(text, <em class="lt">"base64"</em>);<br/>  <strong class="nu ir">return </strong>Buffer.from(buffer).toString(<em class="lt">"utf8"</em>);<br/>}</span></pre><h2 id="aab2" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">解密传入的GraphQL请求(可选)</h2><p id="ab95" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">如果您选择进行加密，那么您需要遵循与客户端相同的路径—创建密钥、创建iv、解密。</p><p id="e6df" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">首先导入<code class="fe nr ns nt nu b">webcrypto</code>模块:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="1e24" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">const </strong>webcrypto = require(<em class="lt">"@trust/webcrypto"</em>);</span></pre><p id="af5b" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">创建相同的密钥。使用相同的<code class="fe nr ns nt nu b"><em class="lt">“MY SHARED KEY”</em></code>字符串。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="4b89" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">const </strong>key = <strong class="nu ir">await </strong>webcrypto.subtle.importKey(<br/>  "<em class="lt">jwk</em>",<br/>  {<br/>    kty: "<em class="lt">oct</em>",<br/>    k: "<em class="lt">MY SHARED KEY</em>",<br/>    alg: "<em class="lt">A256GCM</em>",<br/>    ext: <strong class="nu ir">true<br/>  </strong>},<br/>  {<br/>    name: "<em class="lt">AES-GCM</em>"<br/>  },<br/>  <strong class="nu ir">false</strong>,<br/>  ["<em class="lt">encrypt</em>", "<em class="lt">decrypt</em>"]<br/>);</span></pre><p id="5556" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">然后创建与客户端相同的<code class="fe nr ns nt nu b">iv</code>:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="f770" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">const</strong> iv = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);</span></pre><p id="88c0" class="pw-post-body-paragraph ku kv iq kw b kx lo kz la lb lp ld le kh lq lg lh kl lr lj lk kp ls lm ln jx ij bi translated">解密:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="0760" class="jy jz iq nu b gy oe of l og oh">buffer = <strong class="nu ir">await </strong>webcrypto.subtle.decrypt(<br/>  {<br/>    name: "<em class="lt">AES-GCM</em>",<br/>    iv,<br/>    tagLength: 128<br/>  },<br/>  key,<br/>  buffer<br/>);</span></pre><h2 id="7246" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">对传出响应进行编码</h2><p id="3aaf" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">将utf8转换为base64。</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="71ab" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">async</strong> encodeTextBody(text) {<br/>  <strong class="nu ir">let</strong> buffer = Buffer.from(text, <em class="lt">"utf8"</em>);<br/>  <strong class="nu ir">return </strong>Buffer.from(buffer).toString(<em class="lt">"</em>base64<em class="lt">"</em>);<br/>}</span></pre><h2 id="7e17" class="jy jz iq bd ka kb nv dn kd ke nw dp kg kh nx kj kk kl ny kn ko kp nz kr ks kt bi translated">加密GraphQL响应(可选)</h2><p id="d83f" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln jx ij bi translated">同样，代码与客户端相同:</p><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="46c4" class="jy jz iq nu b gy oe of l og oh">buffer = <strong class="nu ir">await </strong>webcrypto.subtle.encrypt(<br/>  {<br/>    name: "<em class="lt">AES-GCM</em>",<br/>    iv,<br/>    tagLength: 128<br/>  },<br/>  key<strong class="nu ir">,</strong><br/>  buffer<br/>);</span></pre><h1 id="2763" class="mm jz iq bd ka mn mo mp kd mq mr ms kg mt mu mv kk mw mx my ko mz na nb ks nc bi translated">结论</h1><ul class=""><li id="39fd" class="nd ne iq kw b kx ky lb lc kh on kl oo kp op jx ni nj nk nl bi translated">隐藏GraphQL请求和响应数据是可能的。</li><li id="fe8c" class="nd ne iq kw b kx nm lb nn kh no kl np kp nq jx ni nj nk nl bi translated">Apollo工具足够灵活，允许您劫持服务器端和客户端的请求和响应。尽管如此，更简单的解决方案会更好。</li></ul><blockquote class="or os ot"><p id="fbdb" class="ku kv lt kw b kx lo kz la lb lp ld le ou lq lg lh ov lr lj lk ow ls lm ln jx ij bi translated"><strong class="kw ir">提示。</strong>为了对外界隐藏你的GraphQL模式，把这个函数添加到Apollo的<code class="fe nr ns nt nu b">validationRules</code>数组中(见上文)。</p></blockquote><pre class="lw lx ly lz gt oa nu ob oc aw od bi"><span id="dd43" class="jy jz iq nu b gy oe of l og oh"><strong class="nu ir">const </strong>{ createError } = require(<em class="lt">"apollo-errors"</em>);<br/><strong class="nu ir">const </strong>ForbiddenError = createError(<em class="lt">"ForbiddenError"</em>, { message: <em class="lt">"Forbidden"</em> });</span><span id="f1a8" class="jy jz iq nu b gy ok of l og oh"><strong class="nu ir">function </strong>NoIntrospection(context) {<br/>  <strong class="nu ir">return </strong>{<br/>    Field(node) {<br/>      <strong class="nu ir">const </strong>nodeValue = node.name.value;<br/>      <strong class="nu ir">if </strong>(nodeValue === <em class="lt">"__schema"</em> || nodeValue === <em class="lt">"__type"</em>) {<br/>        context.reportError(<strong class="nu ir">new </strong>ForbiddenError());<br/>      }<br/>    }<br/>  };<br/>}</span></pre></div></div>    
</body>
</html>