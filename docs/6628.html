<html>
<head>
<title>The best database pagination technique is …</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最好的数据库分页技术是…</h1>
<blockquote>原文：<a href="https://itnext.io/the-best-database-pagination-technique-is-530abf2aab51?source=collection_archive---------0-----------------------#2022-01-10">https://itnext.io/the-best-database-pagination-technique-is-530abf2aab51?source=collection_archive---------0-----------------------#2022-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a84412bdb7f9f52407aacb3a2999316c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNIQ-nr-F_GzNbRWZB7PdQ.jpeg"/></div></div></figure><div class=""/><h1 id="f1bd" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">👋介绍</h1><p id="c839" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">数据库是每个应用程序的基石之一。在这里，您可以存储应用程序需要记住、稍后计算或在线显示给其他用户的所有内容。这一切都很有趣，直到数据库增长，应用程序开始滞后，因为您试图一次获取并呈现1，000个帖子。你是个聪明的工程师，对吧？你可以用一个<code class="fe lu lv lw lx b">Show more</code>按钮快速修补。几周后，你会看到一个新的<code class="fe lu lv lw lx b">Timeout error</code>！您发现堆栈溢出，但很快意识到<code class="fe lu lv lw lx b">Ctrl</code>和<code class="fe lu lv lw lx b">V</code>由于过度使用已经停止工作🤦没有更多的选择，您实际上开始调试，并意识到每次用户打开您的应用程序时，数据库都会返回超过50，000个帖子！我们现在要干嘛？</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ly"><img src="../Images/0addfb2f847d25f8ab6bd8644c2003f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o_K9UcXZHNRJDP1j.jpg"/></div></div></figure><p id="ad15" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">为了防止这些可怕的场景，我们应该从一开始就意识到风险，因为一个准备充分的开发人员永远不会冒险。本文将帮助您使用<strong class="ky jc">偏移和光标分页</strong>来解决与数据库相关的性能问题。</p><blockquote class="mi mj mk"><p id="a296" class="kw kx ml ky b kz md lb lc ld me lf lg mm mf lj lk mn mg ln lo mo mh lr ls lt ij bi translated">一盎司的预防抵得上一磅的治疗 —本杰明·富兰克林</p></blockquote><h1 id="289f" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">📚什么是分页？</h1><p id="1266" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">分页是在查询任何包含数百条记录以上的数据集时使用的一种策略。多亏了分页，我们可以将大型数据集分割成块(或页),然后逐渐获取并显示给用户，从而减少数据库的负载。分页还解决了客户端和服务器端的许多性能问题！如果没有分页，您必须加载整个聊天历史，以便阅读发送给您的最新消息。</p><p id="3788" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">如今，分页几乎已经成为一种必须，因为每个应用程序都很可能处理大量的数据。这些数据可以是用户生成的内容、管理员或编辑添加的内容，也可以是自动生成的审核和日志。一旦您的列表增长到超过几千个条目，您的数据库将花费很长时间来处理每个请求，并且您的前端的速度和可访问性将受到影响。至于你的用户，他们的体验会是这样的。</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/567e37840b175f594068c6711c4c441c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*JO_Or31pNRUaYfUoi5aJ9Q.gif"/></div></figure><p id="6d90" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">现在我们知道了什么是分页，那么我们实际上如何使用它呢？为什么有必要？</p><h1 id="a85a" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">🔍分页的类型</h1><p id="a642" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有两种广泛使用的分页策略— <strong class="ky jc">偏移</strong>和<strong class="ky jc">光标</strong>。在深入挖掘和了解关于它们的一切之前，我们先来看看一些使用它们的网站。</p><p id="5a47" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">首先，让我们访问GitHub的<a class="ae mq" href="https://github.com/appwrite/appwrite/stargazers" rel="noopener ugc nofollow" target="_blank">观星页面</a>并注意标签是如何显示<code class="fe lu lv lw lx b">5,000+</code>而不是一个绝对数字？此外，他们使用<code class="fe lu lv lw lx b">Previous</code>和<code class="fe lu lv lw lx b">Next</code>按钮，而不是标准页码。</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ly"><img src="../Images/5d6aea6c73770694bb6b62e2a6056236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KhxX1cCjSHEkjCW-.png"/></div></div></figure><p id="5ac5" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">现在，让我们切换到<a class="ae mq" href="https://www.amazon.com/s?k=microwave" rel="noopener ugc nofollow" target="_blank">亚马逊的产品列表</a>并注意结果的确切数量<code class="fe lu lv lw lx b">364</code>，以及你可以通过<code class="fe lu lv lw lx b">1 2 3 ... 20</code>点击的所有页码的标准分页。</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ly"><img src="../Images/804a27d86cb13c3975471e2f99d475d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n4GV1-rTQC-JjBTG.png"/></div></div></figure><p id="c276" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">很明显，两个科技巨头无法就哪个解决方案更好达成一致！为什么？嗯，我们需要用一个开发者讨厌的答案，<code class="fe lu lv lw lx b">Because it depends</code>。让我们研究这两种方法，以了解它们的优点、局限性和性能影响。</p><h1 id="7c22" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">偏移分页</h1><p id="be76" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">大多数网站使用偏移分页是因为它的简单性和对用户来说的直观性。为了实现偏移分页，我们通常需要两条信息:</p><ul class=""><li id="640a" class="mr ms jb ky b kz md ld me lh mt ll mu lp mv lt mw mx my mz bi translated"><code class="fe lu lv lw lx b">limit</code> -从数据库中提取的行数</li><li id="0b88" class="mr ms jb ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated"><code class="fe lu lv lw lx b">offset</code> -要跳过的行数。偏移就像一个页码，但它周围有一些数学(<code class="fe lu lv lw lx b">offset = (page-1) * limit</code>)</li></ul><p id="aeda" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">为了获得数据的第一页，我们将limit设置为10(因为我们希望页面上有10个项目)，offset设置为0(因为我们希望从第0个项目开始计算10个项目)。结果，我们将得到十行。</p><p id="c96e" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">为了获得第二页，我们将限制保持在10(这不会改变，因为我们希望每页包含10行)，并将offset设置为10(返回从第10行开始的结果)。我们继续这种方法，从而允许最终用户通过结果分页，并看到他们的所有内容。</p><p id="aba0" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">在SQL世界中，这样的查询应该写成<code class="fe lu lv lw lx b">SELECT * FROM posts OFFSET 10 LIMIT 10</code>。</p><p id="804f" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">有些实现偏移分页的网站还会显示最后一页的页码。他们是怎么做到的？除了每页的结果，它们还倾向于返回一个<code class="fe lu lv lw lx b">sum</code>属性，告诉您总共有多少行。使用<code class="fe lu lv lw lx b">limit</code>、<code class="fe lu lv lw lx b">sum</code>和一些数学知识，你可以使用<code class="fe lu lv lw lx b">lastPage = ceil(sum / limit)</code>计算最后一页的页码</p><p id="db63" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">虽然这个特性对用户来说很方便，但是开发人员很难扩展这种类型的分页。查看<code class="fe lu lv lw lx b">sum</code>属性，我们已经可以看到，将数据库中的所有行计数到准确的数目需要相当长的时间。<strong class="ky jc">除此之外，数据库中的</strong> <code class="fe lu lv lw lx b"><strong class="ky jc">offset</strong></code> <strong class="ky jc">是以循环遍历行的方式实现的，以了解应该跳过多少行。这意味着我们的偏移量越高，我们的数据库查询将花费越长的时间。</strong></p><p id="5a84" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">偏移分页的另一个缺点是，它不能很好地处理实时数据或经常变化的数据。Offset表示我们希望跳过多少行，但不考虑行删除或新行创建。这种偏移会导致显示重复数据或某些数据丢失。</p><h1 id="23f9" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">光标分页</h1><p id="792a" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">游标是偏移量的继承者，因为它们解决了偏移量分页所具有的所有问题—性能、丢失数据和数据重复，因为它不像偏移量分页那样依赖于行的相对顺序。相反，它依赖于由数据库创建和管理的索引。要实现游标分页，我们需要以下信息:</p><ul class=""><li id="3139" class="mr ms jb ky b kz md ld me lh mt ll mu lp mv lt mw mx my mz bi translated"><code class="fe lu lv lw lx b">limit</code> -和以前一样，我们希望在一页上显示的行数</li><li id="f6a4" class="mr ms jb ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated"><code class="fe lu lv lw lx b">cursor</code> -列表中参考元素的ID。如果您正在查询<strong class="ky jc">上一个</strong>页面，这可以是<strong class="ky jc">第一项</strong>，如果您正在查询<strong class="ky jc">下一个</strong>页面，这可以是<strong class="ky jc">最后一项</strong>。</li><li id="7a7b" class="mr ms jb ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated"><code class="fe lu lv lw lx b">cursorDirection</code> -如果用户点击了<code class="fe lu lv lw lx b">Next</code>或<code class="fe lu lv lw lx b">Previous</code> ( <code class="fe lu lv lw lx b">after</code>或<code class="fe lu lv lw lx b">before</code>)</li></ul><p id="8510" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">在请求第一页的时候，我们不需要提供任何东西，只需要限制<code class="fe lu lv lw lx b">10</code>，说我们想要得到多少行。结果，我们得到了十行。</p><p id="d9f0" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">为了得到下一页，我们使用最后一行的ID作为<code class="fe lu lv lw lx b">cursor</code>，并将<code class="fe lu lv lw lx b">cursorDirection</code>设置为<code class="fe lu lv lw lx b">after</code>。</p><p id="66d5" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">类似地，如果我们想转到上一页，我们使用第一行的ID作为<code class="fe lu lv lw lx b">cursor</code>，并将方向设置为<code class="fe lu lv lw lx b">before</code>。</p><p id="b4b2" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">相比之下，在SQL世界中，我们可以将查询写成<code class="fe lu lv lw lx b">SELECT * FROM posts WHERE id &gt; 10 LIMIT 10 ORDER BY id DESC</code>。</p><p id="3d68" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky jc">使用游标而不是偏移量的查询性能更高，因为</strong> <code class="fe lu lv lw lx b"><strong class="ky jc">WHERE</strong></code> <strong class="ky jc">查询有助于跳过不需要的行，而</strong> <code class="fe lu lv lw lx b"><strong class="ky jc">OFFSET</strong></code> <strong class="ky jc">需要迭代这些行，从而导致全表扫描。如果你在你的id上设置了正确的索引，使用<code class="fe lu lv lw lx b">WHERE</code>跳过行可以变得更快。默认情况下，索引是在主键的情况下创建的。</strong></p><p id="1e36" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">不仅如此，您不再需要担心行被插入或删除。如果您使用的偏移量为10，那么您会期望在当前页面之前正好出现10行。如果不满足这个条件，您的查询将返回不一致的结果，导致数据重复，甚至丢失行。如果删除了当前页面前面的任何行或添加了新行，就会发生这种情况。游标分页通过使用您获取的最后一行的索引来解决这个问题，当您请求更多时，它确切地知道从哪里开始查找。</p><p id="8447" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">不全是阳光和彩虹。如果您需要自己在后端实现游标分页，这确实是一个复杂的问题。为了实现游标分页，您将需要查询中的<code class="fe lu lv lw lx b">WHERE</code>和<code class="fe lu lv lw lx b">ORDER BY</code>子句。此外，您还需要<code class="fe lu lv lw lx b">WHERE</code>子句来根据您需要的条件进行筛选。这可能很快变得非常复杂，最终可能会得到一个巨大的嵌套查询。除此之外，您还需要为需要查询的所有列创建索引。</p><p id="73d5" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">太好了！我们通过切换到游标分页消除了重复和丢失的数据！但是我们还有一个问题。由于不应该向用户公开增量数字ID(出于安全原因)，所以现在必须维护每个ID的散列版本。每当您需要查询数据库时，您可以通过查看保存这些对的表，将这个字符串ID转换为它的数字ID。如果这一行丢失了怎么办？如果点击<code class="fe lu lv lw lx b">Next</code>按钮，获取最后一行的ID，请求下一页，但是数据库找不到ID怎么办？</p><p id="8b42" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">这是一种非常罕见的情况，只有当您要用作游标的行的ID刚刚被删除时才会发生。我们可以通过尝试以前的行或重新获取以前请求的数据来用新的ID更新最后一行来解决这个问题，但所有这些都带来了全新的复杂性，开发人员需要理解一系列新概念，如递归和适当的状态管理。幸运的是，像<a class="ae mq" href="https://appwrite.io/" rel="noopener ugc nofollow" target="_blank"> Appwrite </a>这样的服务会处理好这一点，所以您可以简单地将光标分页作为一个特性来使用。</p><h1 id="6b41" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">🚀Appwrite中的分页</h1><p id="3d64" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="ae mq" href="https://appwrite.io/" rel="noopener ugc nofollow" target="_blank"> Appwrite </a>是开源的后端即服务，它通过为您提供一组REST APIs来满足您的核心后端需求，从而抽象出构建现代应用程序所涉及的所有复杂性。Appwrite处理用户认证和授权、数据库、文件存储、云功能、webhooks等等！如果有任何遗漏，你可以使用你最喜欢的后端语言来扩展Appwrite。</p><p id="483d" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">Appwrite数据库允许您存储任何需要在用户之间共享的基于文本的数据。Appwrite的数据库允许您创建多个集合(表)并在其中存储多个文档(行)。每个集合都配置了属性(列),以便为数据集提供适当的模式。您还可以配置索引以提高搜索查询的性能。在读取数据时，您可以使用大量强大的查询，对它们进行过滤、排序、限制结果的数量，并对它们进行分页。所有这些都是开箱即用的！</p><p id="1d7a" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">使Appwrite数据库更好的是Appwrite的分页支持，因为我们同时支持偏移量和游标分页！假设我们有一个ID为<code class="fe lu lv lw lx b">articles</code>的集合，我们可以从这个集合中获取带有偏移量或光标分页的文档:</p><pre class="lz ma mb mc gt nf lx ng nh aw ni bi"><span id="7f8e" class="nj jz jb lx b gy nk nl l nm nn">// Setup<br/>import { Appwrite, Query } from "appwrite";<br/>const sdk = new Appwrite();</span><span id="3140" class="nj jz jb lx b gy no nl l nm nn">sdk<br/>    .setEndpoint('https://demo.appwrite.io/v1') // Your API Endpoint<br/>    .setProject('articles-demo') // Your project ID<br/>;</span><span id="f853" class="nj jz jb lx b gy no nl l nm nn">// Offset pagination<br/>sdk.database.listDocuments(<br/>    'articles', // Collection ID<br/>    [ Query.equal('status', 'published') ], // Filters<br/>    10, // Limit<br/>    500, // Offset, amount of documents to skip<br/>).then((response) =&gt; {<br/>    console.log(response);<br/>});</span><span id="c58a" class="nj jz jb lx b gy no nl l nm nn">// Cursor pagination<br/>sdk.database.listDocuments(<br/>    'articles', // Collection ID<br/>    [ Query.equal('status', 'published') ], // Filters<br/>    10, // Limit<br/>    undefined, // Not using offset<br/>    '61d6eb2281fce3650c2c' // ID of document I want to paginate after<br/>).then((response) =&gt; {<br/>    console.log(response);<br/>});</span></pre><p id="cb19" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">首先，我们导入Appwrite SDK库，并设置一个连接到特定Appwrite实例和特定项目的实例。然后，我们列出10个使用偏移分页的文档，同时使用一个过滤器只显示那些已发布的文档。紧接着，我们编写完全相同的列表文档查询，但是这次使用游标而不是偏移分页。</p><h1 id="af9d" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">📊基准</h1><p id="d20a" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们在本文中经常使用<em class="ml">性能</em>这个词，但没有提供任何实际数字，所以让我们一起创建一个基准吧！我们将使用Appwrite作为我们的后端服务器，因为它支持偏移和光标分页和节点。JS来编写基准测试脚本。毕竟，Javascript很容易理解。</p><blockquote class="mi mj mk"><p id="d01b" class="kw kx ml ky b kz md lb lc ld me lf lg mm mf lj lk mn mg ln lo mo mh lr ls lt ij bi translated"><em class="jb">你可以找到完整的源代码为</em> <a class="ae mq" href="https://github.com/Meldiron/pagination-benchmark" rel="noopener ugc nofollow" target="_blank"> <em class="jb"> GitHub资源库</em> </a> <em class="jb">。</em></p></blockquote><p id="3e0e" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">首先，我们设置Appwrite，注册一个用户，创建一个项目并创建一个名为<code class="fe lu lv lw lx b">posts</code>的集合，集合级别的权限和读取权限设置为<code class="fe lu lv lw lx b">role:all</code>。要了解有关此过程的更多信息，请访问<a class="ae mq" href="https://appwrite.io/docs" rel="noopener ugc nofollow" target="_blank"> Appwrite文档</a>。我们现在应该已经准备好使用Appwrite了。</p><p id="d818" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">我们还不能进行基准测试，因为我们的数据库是空的！让我们用一些数据填充表格。我们使用以下脚本将数据加载到MariadDB数据库中，并为基准测试做准备。</p><pre class="lz ma mb mc gt nf lx ng nh aw ni bi"><span id="079e" class="nj jz jb lx b gy nk nl l nm nn">const config = {};<br/>// Don't forget to fill config variable with secret information</span><span id="aa40" class="nj jz jb lx b gy no nl l nm nn">console.log("🤖 Connecting to database ...");</span><span id="75f4" class="nj jz jb lx b gy no nl l nm nn">const connection = await mysql.createConnection({<br/>    host: config.mariadbHost,<br/>    port: config.mariadbPost,<br/>    user: config.mariadbUser,<br/>    password: config.mariadbPassword,<br/>    database: `appwrite`,<br/>});</span><span id="7b8d" class="nj jz jb lx b gy no nl l nm nn">const promises = [];</span><span id="a2f8" class="nj jz jb lx b gy no nl l nm nn">console.log("🤖 Database connection established");<br/>console.log("🤖 Preparing database queries ...");</span><span id="fc90" class="nj jz jb lx b gy no nl l nm nn">let index = 1;<br/>for(let i = 0; i &lt; 100; i++) {<br/>    const queryValues = [];</span><span id="0db1" class="nj jz jb lx b gy no nl l nm nn">    for(let l = 0; l &lt; 10000; l++) {<br/>        queryValues.push(`('id${index}', '[]', '[]')`);<br/>        index++;<br/>    }</span><span id="44d9" class="nj jz jb lx b gy no nl l nm nn">    const query = `INSERT INTO _project_${config.projectId}_collection_posts (_uid, _read, _write) VALUES ${queryValues.join(", ")}`;<br/>    promises.push(connection.execute(query));<br/>}</span><span id="d883" class="nj jz jb lx b gy no nl l nm nn">console.log("🤖 Pushing data. Get ready, this will take quite some time ...");</span><span id="7567" class="nj jz jb lx b gy no nl l nm nn">await Promise.all(promises);</span><span id="70a1" class="nj jz jb lx b gy no nl l nm nn">console.error(`🌟 Successfully finished`);</span></pre><blockquote class="mi mj mk"><p id="4b40" class="kw kx ml ky b kz md lb lc ld me lf lg mm mf lj lk mn mg ln lo mo mh lr ls lt ij bi translated"><em class="jb">我们使用两层循环来提高脚本的速度。第一个for循环创建需要等待的查询执行，第二个循环创建包含多个插入请求的长查询。理想情况下，我们希望在一个请求中包含所有内容，但是由于MySQL的配置，这是不可能的，所以我们将它分成100个请求。</em></p></blockquote><p id="5679" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">我们在不到一分钟的时间内插入了100万个文档，我们已经准备好开始我们的基准测试了。在这个演示中，我们将使用<a class="ae mq" href="https://k6.io/" rel="noopener ugc nofollow" target="_blank"> k6 </a>负载测试库。</p><p id="5726" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">让我们首先对众所周知且广泛使用的偏移分页进行基准测试。在每个测试场景中，我们尝试从数据集的不同部分获取包含10个文档的页面。我们将从偏移量0开始，以100k为增量，一直到偏移量900k。基准是以这样一种方式编写的，它一次只发出一个请求，以尽可能保持其准确性。我们还将运行相同的基准十次，并测量平均响应时间，以确保统计显著性。我们将使用k6的HTTP客户端向Appwrite的REST API发出请求。</p><pre class="lz ma mb mc gt nf lx ng nh aw ni bi"><span id="f86d" class="nj jz jb lx b gy nk nl l nm nn">// script_offset.sh</span><span id="35a5" class="nj jz jb lx b gy no nl l nm nn">import http from 'k6/http';</span><span id="432b" class="nj jz jb lx b gy no nl l nm nn">// Before running, make sure to run setup.js<br/>export const options = {<br/>    iterations: 10,<br/>    summaryTimeUnit: "ms",<br/>    summaryTrendStats: ["avg"]<br/>};</span><span id="c3e9" class="nj jz jb lx b gy no nl l nm nn">const config = JSON.parse(open("config.json"));</span><span id="3d0c" class="nj jz jb lx b gy no nl l nm nn">export default function () {<br/>    http.get(`${config.endpoint}/database/collections/posts/documents?offset=${__ENV.OFFSET}&amp;limit=10`, {<br/>        headers: {<br/>            'content-type': 'application/json',<br/>            'X-Appwrite-Project': config.projectId<br/>        }<br/>    });<br/>}</span></pre><p id="881e" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">为了使用不同的偏移配置运行基准测试，并将输出存储在CSV文件中，我创建了一个简单的bash脚本。这个脚本执行k6十次，每次使用不同的偏移配置。输出将作为控制台输出提供。</p><pre class="lz ma mb mc gt nf lx ng nh aw ni bi"><span id="3809" class="nj jz jb lx b gy nk nl l nm nn">#!/bin/bash<br/># benchmark_offset.sh</span><span id="9aea" class="nj jz jb lx b gy no nl l nm nn">k6 -e OFFSET=0 run script.js<br/>k6 -e OFFSET=100000 run script.js<br/>k6 -e OFFSET=200000 run script.js<br/>k6 -e OFFSET=300000 run script.js<br/>k6 -e OFFSET=400000 run script.js<br/>k6 -e OFFSET=500000 run script.js<br/>k6 -e OFFSET=600000 run script.js<br/>k6 -e OFFSET=700000 run script.js<br/>k6 -e OFFSET=800000 run script.js<br/>k6 -e OFFSET=900000 run script.js</span></pre><p id="212f" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">不到一分钟，所有的基准测试都完成了，并为我提供了每个偏移配置的平均响应时间。结果正如预期的那样，但一点也不令人满意。</p><figure class="lz ma mb mc gt is"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ly"><img src="../Images/b992d9b022ab6444fdc8869e88ec233c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0K9aOqJQihxN62eB.png"/></div></div></figure><p id="bf7e" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">正如我们所见，offset 0非常快，响应时间不到4毫秒。我们的第一次跳跃是偏移100k，变化很大，响应时间增加到52毫秒。随着偏移量的每次增加，持续时间也会增加，导致在偏移量为900k的文档之后，几乎需要500ms才能获得10个文档。这太疯狂了。</p><p id="2aac" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">现在让我们更新我们的脚本来使用光标分页。我们将更新我们的脚本以使用游标代替偏移量，并更新我们的bash脚本以提供游标(文档ID)代替偏移量。</p><pre class="lz ma mb mc gt nf lx ng nh aw ni bi"><span id="cdc9" class="nj jz jb lx b gy nk nl l nm nn">// script_cursor.js<br/>import http from 'k6/http';</span><span id="515a" class="nj jz jb lx b gy no nl l nm nn">// Before running, make sure to run setup.js<br/>export const options = {<br/>    iterations: 10,<br/>    summaryTimeUnit: "ms",<br/>    summaryTrendStats: ["avg"]<br/>};</span><span id="86be" class="nj jz jb lx b gy no nl l nm nn">const config = JSON.parse(open("config.json"));</span><span id="e2db" class="nj jz jb lx b gy no nl l nm nn">export default function () {<br/>    http.get(`${config.endpoint}/database/collections/posts/documents?cursor=${__ENV.CURSOR}&amp;cursorDirection=after&amp;limit=10`, {<br/>        headers: {<br/>            'content-type': 'application/json',<br/>            'X-Appwrite-Project': config.projectId<br/>        }<br/>    });<br/>}</span><span id="4b57" class="nj jz jb lx b gy no nl l nm nn">#!/bin/bash<br/># benchmark_cursor.sh</span><span id="8e20" class="nj jz jb lx b gy no nl l nm nn">k6 -e CURSOR=id1 run script_cursor.js<br/>k6 -e CURSOR=id100000 run script_cursor.js<br/>k6 -e CURSOR=id200000 run script_cursor.js<br/>k6 -e CURSOR=id300000 run script_cursor.js<br/>k6 -e CURSOR=id400000 run script_cursor.js<br/>k6 -e CURSOR=id500000 run script_cursor.js<br/>k6 -e CURSOR=id600000 run script_cursor.js<br/>k6 -e CURSOR=id700000 run script_cursor.js<br/>k6 -e CURSOR=id800000 run script_cursor.js<br/>k6 -e CURSOR=id900000 run script_cursor.js</span></pre><p id="5a39" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">运行该脚本后，我们已经可以看出性能得到了提升，因为响应时间有了明显的不同。我们将结果放入一个表中，以便并排比较这两种分页方法。</p><figure class="lz ma mb mc gt is"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ly"><img src="../Images/ede122b937dd4bea8fd8d22525cb2303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GZTcw7hE9PB5u0Mh.png"/></div></div></figure><p id="c2e2" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">哇！光标分页摇滚！该图显示，游标分页不关心偏移量大小，每个查询的性能都与第一个或最后一个查询一样。你能想象重复加载一个庞大列表的最后一页会造成多大的危害吗？😬</p><p id="183c" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">如果您对在自己的机器上运行测试感兴趣，您可以找到完整的源代码，如<a class="ae mq" href="https://github.com/Meldiron/pagination-benchmark" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。存储库包括<code class="fe lu lv lw lx b">README.md</code>解释安装和运行脚本的整个过程。</p><h1 id="75df" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">👨‍🎓摘要</h1><p id="f24e" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">偏移分页提供了一种众所周知的分页方法，在这种方法中，您可以查看页码并单击它们。这种直观的方法有很多缺点，比如高偏移带来的糟糕性能，以及数据重复和丢失的可能性。</p><p id="4061" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">游标分页解决了所有这些问题，并带来了一个可靠的分页系统，它速度很快，可以处理实时(经常变化)数据。游标分页的缺点是不显示页码，实现起来很复杂，还需要克服一系列新的挑战，比如缺少游标ID。</p><p id="9ecd" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">现在让我们回到最初的问题，为什么GitHub使用光标分页，而Amazon决定使用偏移分页？性能并不总是关键…用户体验比您的企业必须支付多少服务器的费用更有价值。</p><p id="5fb8" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">我相信亚马逊决定采用胶印，因为它可以提高UX，但这是另一项研究的主题。我们已经可以注意到，如果我们访问<code class="fe lu lv lw lx b">amazon.com</code>并搜索一个<code class="fe lu lv lw lx b">pen</code>，它说有<em class="ml">正好是</em> <code class="fe lu lv lw lx b">10 000</code>结果，但你只能访问前七页(350个结果)。</p><p id="42bf" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">首先，有远远超过10k的结果，但亚马逊限制了它。其次，反正前七页都可以访问。如果你试图访问第8页，它显示404错误。正如我们所看到的，Amazon意识到了偏移分页的性能，但仍然决定保留它，因为他们的用户群更喜欢看到页码。他们不得不包括一些限制，但谁会去搜索结果的第100页。？🤷</p><p id="deb7" class="pw-post-body-paragraph kw kx jb ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">你知道什么比阅读分页更好吗？尝试一下！我会鼓励你尝试这两种方法，因为这是获得第一手经验的最好方法。设置Appwrite只需要不到几分钟的时间，您可以开始使用这两种分页方法。如果您有任何问题，也可以通过<a class="ae mq" href="https://appwrite.io/discord" rel="noopener ugc nofollow" target="_blank">我们的不和谐服务器</a>联系我们。</p><h1 id="67a7" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">🔗资源</h1><ul class=""><li id="ec55" class="mr ms jb ky b kz la ld le lh nr ll ns lp nt lt mw mx my mz bi translated"><a class="ae mq" href="https://uxdesign.cc/why-facebook-says-cursor-pagination-is-the-greatest-d6b98d86b6c0" rel="noopener" target="_blank">偏移分页死了吗？为什么光标分页正在接管</a></li><li id="449f" class="mr ms jb ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated"><a class="ae mq" href="https://stackoverflow.com/questions/55744926/offset-pagination-vs-cursor-pagination" rel="noopener ugc nofollow" target="_blank">偏移分页与光标分页</a></li><li id="6ba4" class="mr ms jb ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated"><a class="ae mq" href="https://stackoverflow.com/questions/18314687/how-to-implement-cursors-for-pagination-in-an-api" rel="noopener ugc nofollow" target="_blank">如何在api中实现分页光标</a></li><li id="7bc2" class="mr ms jb ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated"><a class="ae mq" href="https://medium.com/swlh/how-to-implement-cursor-pagination-like-a-pro-513140b65f32" rel="noopener">如何像专业人员一样实现光标分页</a></li></ul></div></div>    
</body>
</html>