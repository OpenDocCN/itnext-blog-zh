<html>
<head>
<title>How to approach multi-language Gatsby apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用多语言Gatsby应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/techniques-approaches-for-multi-language-gatsby-apps-8ba13ff433c5?source=collection_archive---------0-----------------------#2020-03-28">https://itnext.io/techniques-approaches-for-multi-language-gatsby-apps-8ba13ff433c5?source=collection_archive---------0-----------------------#2020-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9233b3fa735ef49d3006937e4810defd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZPDmVJnYqJjQMXKziiAO2Q.png"/></div></div></figure><p id="38e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近必须实现一个多语言静态网站，所以我认为盖茨比将是一个有趣的选择；人们肯定有很多关于如何做的指南。事实证明，用简单的方法实现它很容易，但是如果你想通过自动化过程减少手工工作和简化翻译，事情会变得困难。在本文中，我将尝试展示我所面临的问题、我最终使用的解决方案以及每种方法的优势。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="122e" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">介绍</h1><p id="dc1f" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">最初，内部化似乎是一项简单的任务。收到请求后，检查请求的语言，用正确的数据预先填充文档，然后将HTML返回给浏览器。你可能忘了，盖茨比没有配备服务器。与NextJS不同，Gatsby输出一组静态资产，通常由Netlify或S3等静态网站主机自动提供服务(打开网站配置)。手动设置&amp;配置服务器来提供适当的内容，这完全违背了使用Gatsby的初衷。因此，尽管内部化被认为是服务器端渲染世界中一个“已解决”的问题，但它突然在<strong class="ka ir">现代静态文件服务世界</strong>中变得有趣起来。</p><p id="5264" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望实现以下目标:</p><ul class=""><li id="d143" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">我们支持的每种语言的每个页面的输出变化。</li><li id="b9ad" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">用正确的语言预渲染每个输出的页面。</li><li id="f37f" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">在每个输出的页面上添加适当的SEO内在化标签。</li><li id="951c" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">实现一个语言选择器来改变语言。</li><li id="2ad1" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">基于访问用户的语言环境添加适当的服务器端重定向。</li></ul><p id="5d51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同时，该项目应受以下技术要求的约束:</p><ul class=""><li id="64d8" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">有一个集中处理翻译的方法。</li><li id="294c" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">自动创建每个页面的本地化版本(即每个页面只需编写一次代码)</li><li id="de84" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">自动添加适当的搜索引擎优化标签到每个页面。</li><li id="0d29" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">自动添加基于地区的服务器端重定向。</li><li id="c71b" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">自动创建智能语言选择器和语言感知链接。</li></ul><p id="b016" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哦，天啊，你一定会喜欢的。我们开始吧！</p><h1 id="9469" class="ld le iq bd lf lg mu li lj lk mv lm ln lo mw lq lr ls mx lu lv lw my ly lz ma bi translated">集中翻译</h1><p id="6850" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">第一件事是决定如何处理翻译。通常，你要做的是保存一个JSON文件，里面有你的网站的所有短语或单词的变体。是为所有内容保留一个JSON文件，还是将它分割成每页独立的JSON文件，这实际上取决于用例。如果您的网站足够小，并且只支持少数几种语言，那么一个单一的JSON文件(即使只有几百kb)可能是最好的解决方案。另一方面，如果你有一个多语言的网站，支持任意数量的页面(例如，一个有很多产品的网上商店)，那么生成多个翻译文档通常会更好。通常，在React项目中，您有以下选项:</p><ul class=""><li id="dcc7" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">在开始处加载单个翻译文档<strong class="ka ir">一次</strong> <strong class="ka ir">，然后自由导航&amp;切换语言。</strong></li><li id="0d3b" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">按需延迟加载</strong>翻译文档，并在请求翻译文档时使用<code class="fe mz na nb nc b">&lt;React.Suspense&gt;</code>回退。</li></ul><p id="801c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于本文，我们将继续使用单文档方法，利用<a class="ae nd" href="https://github.com/i18next/react-i18next" rel="noopener ugc nofollow" target="_blank"> i18next </a>库。我们将首先配置一个翻译模块(即如何加载文档、备用语言是什么、如何处理翻译请求)，然后通过<code class="fe mz na nb nc b">React.Context</code>将其传递到组件链。这将包含有用的方法，允许我们改变语言和翻译某些文本。</p><p id="99de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个<code class="fe mz na nb nc b">i18next</code>库的实例，并将其配置为使用在<code class="fe mz na nb nc b">translations.json</code>下找到的翻译:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">i18next的翻译文档示例</figcaption></figure><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">i18的配置示例接下来</figcaption></figure><p id="087d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导出的模块具有我们需要的方法，以便更改语言或执行翻译。让我们通过上下文提供者，通过安装<code class="fe mz na nb nc b">react-i18next</code>(即<code class="fe mz na nb nc b">i18next</code>的react-binding)及其<code class="fe mz na nb nc b">I18nextProvider</code>模块，将它公开给我们的React组件。然后，组件可以使用同一个包中的<code class="fe mz na nb nc b">useTranslation</code>钩子，以便访问翻译功能:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">翻译示例</figcaption></figure><p id="6444" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，现在我们有了集中翻译的方法。让我们看看如何在《盖茨比》中运用这一点。</p><h1 id="06ad" class="ld le iq bd lf lg mu li lj lk mv lm ln lo mw lq lr ls mx lu lv lw my ly lz ma bi translated">自动化页面本地化</h1><p id="5271" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">因为我们输出静态资产，所以我们需要用每种可用的语言为每个页面创建一个HTML文档。当然，我们可以像过去一样，手动为每种语言编写不同的HTML文档，但是我们正在使用现代工具，所以我们应该寻找现代的解决方案。</p><p id="e230" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在其国际化文档中，Gatsby提到了<a class="ae nd" href="https://github.com/angeloocana/gatsby-plugin-i18n" rel="noopener ugc nofollow" target="_blank"> gatsby-plugin-18n </a>，它将所有<code class="fe mz na nb nc b">src/pages/about.en.js</code>文件转换为<code class="fe mz na nb nc b">/en/about/</code>URL。不幸的是，这对我们不起作用，因为这意味着我们实际上需要创建与我们支持的语言数量一样多的<code class="fe mz na nb nc b">about.{LOCALE}.js</code>文件。我们想要的是编写一个单独的<code class="fe mz na nb nc b">src/pages/about.js</code>文件，并自动为我们所有支持的语言生成<code class="fe mz na nb nc b">/en/about</code>、<code class="fe mz na nb nc b">/el/about</code>、<code class="fe mz na nb nc b">/fr/about</code>。通过利用<a class="ae nd" href="https://www.gatsbyjs.org/docs/node-apis/" rel="noopener ugc nofollow" target="_blank"> Gatsby节点API</a>，这非常容易实现。</p><p id="91ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要做的是使用<code class="fe mz na nb nc b">onCreatePage</code>钩子自动创建在<code class="fe mz na nb nc b">pages</code>文件夹中找到的每个页面的新的本地化版本(在正确的路径上)。为此，我们将以下内容添加到位于项目目录顶层的<code class="fe mz na nb nc b">gatsby-node.js</code>文件中:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">帮助我们动态创建页面的Gatsby节点API</figcaption></figure><p id="af25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我在<code class="fe mz na nb nc b">gatsby-config.js</code>中添加了可用的语言环境作为键。<code class="fe mz na nb nc b">supportedLanguages</code>的值将是一个类似于<code class="fe mz na nb nc b">['en', 'el', 'fr']</code>的字符串区域的简单数组。</p><p id="ec92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您试图构建您的Gatsby项目(通过<code class="fe mz na nb nc b">gatsby build</code>，您会看到HTML页面已经创建，但是内容没有翻译。这是因为我们还没有告诉我们的页面他们正在实现什么语言，或者他们应该翻译什么东西。让我们解决这个问题。</p><p id="f469" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们在根组件中添加<code class="fe mz na nb nc b">&lt;I18NextProvider&gt;</code>，这样页面就可以使用<code class="fe mz na nb nc b">useTranslation()</code>钩子。为此，我们像这样编辑我们的<code class="fe mz na nb nc b">gatsby-browser.js</code>和<code class="fe mz na nb nc b">gatsby-ssr.js</code>:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">gatsby-ssr用提供者包装根元素。gatsby-browser只是输出ssr所做的一切。</figcaption></figure><p id="576b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在pages可以翻译他们的文本。缺少的是语言。每个页面<strong class="ka ir">都不知道</strong>应该翻译成哪种语言。当然，我们可以通过路径来推断(即<code class="fe mz na nb nc b">/en/about</code>有一个<code class="fe mz na nb nc b">en</code>的语言)，但这有点站不住脚，容易出错。相反，我们要做的是，通过在创建过程中显式地传递给它，使每个页面知道它的位置。在Gatsby中，这意味着在页面创建期间向页面传递一个<code class="fe mz na nb nc b">context</code>。这个<code class="fe mz na nb nc b">context</code>是一个对象，其内容由页面组件作为<code class="fe mz na nb nc b">props</code>接收。因为我们可能在一个页面中的多个其他组件中需要它，所以我们将它添加到一个<code class="fe mz na nb nc b">React.Context</code>中，以便从任何子组件中读取它。</p><p id="e763" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们需要将之前的<code class="fe mz na nb nc b">gatsby-node.js</code>文件修改如下:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">gatsby-node为每个生成的页面添加顶级道具</figcaption></figure><p id="9eae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个<code class="fe mz na nb nc b">PageContext</code>(和<code class="fe mz na nb nc b">usePageContext</code>钩子)将这些<code class="fe mz na nb nc b">context</code>道具传递给页面中的任何React组件:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">一个允许我们将这些顶级道具(包含在“pageContext”中)传递给链中任何组件的上下文。我们还在这里为整个页面及其组件设置了正确的语言。我们不能在反应效果中添加“更改语言”。</figcaption></figure><p id="8322" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后修改<code class="fe mz na nb nc b">gatsby-ssr.js</code>和<code class="fe mz na nb nc b">gatsby-browser.js</code>，用<code class="fe mz na nb nc b">PageContext.Provider</code>包装每一页，这样我们就可以“读取”通过<code class="fe mz na nb nc b">gatsby-node.js</code>文件传递的数据。同时，我们确保在服务器端渲染时设置正确的语言(因为我们现在知道每个页面的语言)，以便<code class="fe mz na nb nc b">useTranslation()</code>的<code class="fe mz na nb nc b">t</code>方法可以知道翻译成哪种语言。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">传承“页面上下文”道具</figcaption></figure><h1 id="8f3c" class="ld le iq bd lf lg mu li lj lk mv lm ln lo mw lq lr ls mx lu lv lw my ly lz ma bi translated">自动化添加基于区域设置的重定向的过程。</h1><p id="91bd" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">所以一切都很完美！现在，每一页都有正确的翻译，一切都很好。如果你通过<code class="fe mz na nb nc b">gatsby develop</code>启动一个开发服务器，你会看到<code class="fe mz na nb nc b">localhost:8000/</code>返回一个404，因为<code class="fe mz na nb nc b">/</code>页面只存在于它的本地化版本中(即<code class="fe mz na nb nc b">/en/</code>)。我们应该做的是添加一个从<code class="fe mz na nb nc b">/</code>到默认/备用区域的重定向。事实上，我们应该对每个页面都这样做。理想情况下，我们会希望根据用户的语言偏好将他们重定向到正确的语言环境，或者如果我们不支持他们偏好的任何语言，则返回到英语。</p><p id="487c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是“服务器的事情”,与解析<code class="fe mz na nb nc b">Accept-Language</code>头并从中创建适当的重定向规则有关。Gatsby不能单独处理它，因为，如前所述，它没有服务器的概念。有趣的是，Gatsby有一个用于创建重定向的API，叫做<code class="fe mz na nb nc b">createRedirect()</code>，我们可以在<code class="fe mz na nb nc b">gatsby-node.js</code>中使用它。我们可以使用这个API来“发布”我们创建从一个页面到另一个页面的重定向的意图。这取决于服务器端技术来“订阅”这些意图并创建重定向规则。简而言之，Gatsby说“当开发人员想要创建重定向时，我会记录日志”，而其他人必须说“我会读取那些日志并创建重定向规则”。像<a class="ae nd" href="https://www.gatsbyjs.org/packages/gatsby-plugin-netlify/" rel="noopener ugc nofollow" target="_blank"> gatsby-plugin-netlify </a>或<a class="ae nd" href="https://www.gatsbyjs.org/packages/gatsby-plugin-s3/" rel="noopener ugc nofollow" target="_blank"> gatsby-plugin-s3 </a>这样的插件就是这么做的。Netlify在您的构建目录中创建一个<code class="fe mz na nb nc b">_redirects</code>文件，其中包含所有的重定向规则(通过您的<code class="fe mz na nb nc b">gatsby-node.js</code>中的<code class="fe mz na nb nc b">createRedirect</code>调用读取)，Netlify能够理解这些规则。我们将利用它为生产网站创建服务器端重定向，同时为开发创建浏览器端javascript重定向，以便<code class="fe mz na nb nc b">localhost:8000/about</code>可以正确地重定向到<code class="fe mz na nb nc b">localhost:8000/en/about</code>。为此，我们将<code class="fe mz na nb nc b">gatsby-plugin-netlify</code>添加到<code class="fe mz na nb nc b">gatsby-config.js</code>，并将<code class="fe mz na nb nc b">gatsby-node.js</code>修改如下:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">基于接受语言添加重定向</figcaption></figure><p id="6fb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在确保根据用户的区域设置自动将用户重定向到正确的页面版本，如果没有匹配的区域设置，则返回默认语言(通常是<code class="fe mz na nb nc b">en</code>)。Netlify按顺序解析重定向，所以如果在此之前没有其他匹配，它将只到达最后一个(我们的默认语言)。位于<code class="fe mz na nb nc b">/build/_redirects</code>的输出类似于:</p><pre class="ne nf ng nh gt no nc np nq aw nr bi"><span id="6439" class="ns le iq nc b gy nt nu l nv nw">/about /en/about/ 301 Language=en<br/>/about /fr/about/ 301 Language=fr<br/>/about /en/about/ 301</span></pre><p id="e4f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想知道为什么我们需要服务器端重定向而不仅仅是浏览器端重定向，那是因为我们不想依赖定制的Javascript代码来为我们执行它。用户可能会禁用脚本或互联网连接不良，这可能会导致后期重定向。此外，我们不能为重定向设置状态代码，因此搜索引擎将不能正确地索引这个动作。出于开发目的依赖JS是好的，但是对于生产来说是不允许的。</p><h1 id="fa2c" class="ld le iq bd lf lg mu li lj lk mv lm ln lo mw lq lr ls mx lu lv lw my ly lz ma bi translated">自动化的过程中添加适当的搜索引擎优化标签到每个页面。</h1><p id="5b6b" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">每个页面都有自己的区域设置，但不幸的是谷歌并不知道这一点。让我们通过在每个页面中添加适当的SEO标签来帮助解决这个问题。遵循<a class="ae nd" href="https://www.gatsbyjs.org/docs/add-seo-component/" rel="noopener ugc nofollow" target="_blank">官方惯例</a>，让我们创建一个SEO组件，它将通过我们在上面创建的<code class="fe mz na nb nc b">usePageContext</code>钩子读取区域信息。然后，它将使用<a class="ae nd" href="https://github.com/nfl/react-helmet" rel="noopener ugc nofollow" target="_blank">react-头盔</a>向文档添加适当的HTML标签(确保添加<a class="ae nd" href="https://www.gatsbyjs.org/packages/gatsby-plugin-react-helmet/" rel="noopener ugc nofollow" target="_blank">Gatsby-plugin-react-头盔</a>)。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">包含电池的SEO组件</figcaption></figure><p id="a790" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们做的第一件事是向<code class="fe mz na nb nc b">gatsby-config</code>查询可用的语言(即一个地区字符串列表)和基本URL(即<code class="fe mz na nb nc b">https://example.com</code>)，以便构建必要的<code class="fe mz na nb nc b">&lt;meta&gt;</code>属性。下一件事是获取与当前本地化页面相关联的当前语言，以及页面在未本地化时的原始路径。有了这些信息，我们可以:</p><ul class=""><li id="dfa1" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">给<code class="fe mz na nb nc b">&lt;html&gt;</code>标签添加一个<code class="fe mz na nb nc b">lang</code>属性。</li><li id="c4cd" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">生成一个<code class="fe mz na nb nc b">og:locale</code> <code class="fe mz na nb nc b">&lt;meta&gt;</code>标签。</li><li id="c002" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">为标签<code class="fe mz na nb nc b">description</code> <code class="fe mz na nb nc b">&lt;meta&gt;</code>添加回退，如果用户没有为当前页面提交回退。</li><li id="8e2c" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">为当前页面添加<code class="fe mz na nb nc b">&lt;meta rel="canonical" … /&gt;</code>。</li><li id="2e50" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">为当前页面的所有本地化版本添加<code class="fe mz na nb nc b">&lt;meta rel="alternate" … /&gt;</code>。</li></ul><p id="9375" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这有助于谷歌显示正确的本地化搜索结果。基于用户的语言偏好。只要确保所有页面都添加了一个<code class="fe mz na nb nc b">&lt;SEO /&gt;</code>组件。我们不会自动包含它，因为它的属性可能会因页面而异。</p><h1 id="ad04" class="ld le iq bd lf lg mu li lj lk mv lm ln lo mw lq lr ls mx lu lv lw my ly lz ma bi translated">创建智能语言选择器组件</h1><p id="09fb" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">难题的最后一部分是允许用户正确地浏览网站并在语言之间切换。</p><p id="52b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户是英国人时，标题中出现的所有链接都应该有<code class="fe mz na nb nc b">/en/</code>前缀。当它们是法语时，那么导航中的所有页面都应该以<code class="fe mz na nb nc b">/fr/</code>为前缀。这对我们来说应该是自动完成的，根本不用考虑语言环境。让我们创建一个新的<code class="fe mz na nb nc b">Link</code>组件，基于当前活动的语言，通过向路径添加地区前缀来扩展Gatsby one。看起来大概是这样的:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">阿郎感知链路组件</figcaption></figure><p id="b6dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要做的，就是在我们使用原始<code class="fe mz na nb nc b">Link</code>组件的地方使用它。有了这个组件，我们根本不用担心语言环境。我们只需编写<code class="fe mz na nb nc b">&lt;Link to="/about/"&gt;About&lt;/Link&gt;</code>,适当的区域设置就会自动为我们加上前缀，确保用户在浏览时总是停留在相同的区域设置。</p><p id="ba21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，让我们给他们改变语言的能力。每个本地化页面都有自己的URL，因此更改语言只不过是更改页面。诀窍在于，我们不仅希望自动创建这个选择器，还希望确保将用户重定向到他们所在的页面。例如，如果他们在<code class="fe mz na nb nc b">/en/about/</code>上，他们将语言改为法语，我们希望将他们重定向到<code class="fe mz na nb nc b">/fr/about</code>。这意味着我们的语言选择器应该是一组链接，其<code class="fe mz na nb nc b">href</code>属性在用户每次改变页面时都会改变。</p><p id="901e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以利用我们的<code class="fe mz na nb nc b">usePageContext</code>来读取当前页面的<code class="fe mz na nb nc b">originalPath</code>并创建一个链接列表，每个区域都有前缀<code class="fe mz na nb nc b">originalPath</code>。一个无样式的实现应该是这样的:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">一个简单的自动生成的语言选择器</figcaption></figure><p id="49c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，每种新的语言都会自动添加到选择器中，同时确保更改语言会让用户停留在同一页面。</p><h1 id="fe42" class="ld le iq bd lf lg mu li lj lk mv lm ln lo mw lq lr ls mx lu lv lw my ly lz ma bi translated">结束语</h1><p id="a829" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">哇，太多了。总而言之，我们:</p><ul class=""><li id="297e" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">设置一种为所有地区自动生成HTML文档的方法。</li><li id="83e0" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">处理生产中的服务器端重定向和开发中的客户端重定向。</li><li id="b664" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">为每个页面设置语言，并使用<code class="fe mz na nb nc b">React.Context</code>将其传递给子组件。</li><li id="c8df" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">设置一个<code class="fe mz na nb nc b">&lt;SEO /&gt;</code>组件，它读取每个页面的语言并创建必要的i18n元标签。</li><li id="2ab5" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">创建了一个有用的语言感知<code class="fe mz na nb nc b">&lt;Link&gt;</code>组件。</li><li id="094e" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">创建了一个动态和智能的语言选择器组件来切换语言。</li></ul><p id="d9e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还实现了一个完全模仿生产环境的本地化开发环境。这一切的目的都是为了自动化Gatsby网站的本地化，同时对开发人员隐藏其复杂性&amp;公开的组件API。无论如何，请随意提出替代方案或事情，这些方案或事情本可以使这一切变得简单得多。我真的很想了解他们。</p><p id="df57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还发布了一组实现上述所有内容的工具。它包括:</p><ul class=""><li id="8700" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">用作新的多语言Gatsby应用程序样板的入门工具</li><li id="6598" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">一个主题(不包括样式)来帮助将现有的gatsby应用程序迁移到多语言应用程序</li><li id="3ad5" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">当你想使用自己的翻译框架，但仍然需要自动生成本地化页面(包括SEO标签)时，这个插件可以提供帮助</li></ul><p id="5470" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在此查看所有内容:</p><p id="6ad2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nd" href="https://github.com/3nvi/gatsby-intl/" rel="noopener ugc nofollow" target="_blank">https://github.com/3nvi/gatsby-intl</a></p><p id="486f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读:)</p><p id="5ba4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="nx"/></strong>👋<strong class="ka ir"> <em class="nx">嗨，我是</em></strong><a class="ae nd" href="https://aggelos.dev" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nx">Aggelos</em></strong></a><strong class="ka ir"><em class="nx">！如果你喜欢这个，考虑一下</em> </strong> <a class="ae nd" href="https://twitter.com/AggArvanitakis" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="nx">在twitter上关注我</em> </strong> </a> <strong class="ka ir"> <em class="nx">并与你的朋友分享这个故事</em>😀</strong></p></div></div>    
</body>
</html>