<html>
<head>
<title>Infrastructure as Code (IaC) with Terraform &amp; Azure DevOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有Terraform和Azure DevOps的基础设施即代码(IaC)</h1>
<blockquote>原文：<a href="https://itnext.io/infrastructure-as-code-iac-with-terraform-azure-devops-f8cd022a3341?source=collection_archive---------2-----------------------#2020-04-13">https://itnext.io/infrastructure-as-code-iac-with-terraform-azure-devops-f8cd022a3341?source=collection_archive---------2-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b55c22490bbb45e03e69d07dc7bfee47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mMdLiPuxKf0ktbEB"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="0c74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">本文是Azure DevOps和Terraform系列文章的第一部分。</em></p><p id="9c70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">过去，我曾在不同的地点以不同的方式部署过Terraform:</p><ol class=""><li id="bfb4" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">从我的笔记本电脑😬</li><li id="de51" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">从运行Bash步骤的Jenkins服务器😐</li><li id="0dee" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">从Jenkins服务器使用Jenkinsfiles👍</li><li id="6314" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">来自团队城市💩</li><li id="c79b" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">来自Azure DevOps💯 👍 🔥</li></ol><p id="f668" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近，我们的团队有了一个令人兴奋的机会，可以从头开始重新构建我们的管道，这意味着我们可以重新访问我们的Terraform，并学习Azure DevOps中的YAML管道语法。如果你正在寻找将你的Terraform管道迁移到Azure DevOps，或者你还没有将它们集成到CI/CD平台中，并且想知道如何集成，那么请继续阅读！在以后的博文中，我将介绍一些更高级的管道YAML语法，并展示我们是如何处理多区域部署、模板化任务和其他各种技巧的。</p><h1 id="4e1d" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">先决条件:首先对您的Terraform代码进行优化和重复数据删除</h1><p id="ea19" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">不言而喻:<strong class="ki iu">如果您正在考虑将您的管道迁移到另一个平台，请抓住这个机会使您的代码更加精简和高效。花时间将臃肿、重复的代码转换成精简的组件和模块。迁移破损或笨拙的代码绝对没有价值。你的平台应该在运营成熟度等级3或4左右运行，相信我，如果你现在做这一步，开发管道将变得轻而易举。</strong></p><p id="7bda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，我想借此机会澄清我在Terraform中提到<em class="le">组件</em>时的意思，以及我正在使用的文件夹结构。我们在Azure(或AWS/GCP/etc)中部署的每个解决方案(通常是核心网络/存储、数据库和计算的组合)都可以在Terraform中拆分成相同的三个(ish)组件。下面是简化的文件夹结构示例:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="4fcd" class="nf lu it nb b gy ng nh l ni nj">terraform/src<br/>├── backends<br/>│   ├── dev<br/>│   │   ├── common.tfvars<br/>│   │   ├── core.tfvars<br/>│   │   └── cluster.tfvars<br/>│   └── production<br/>│       ├── common.tfvars<br/>│       ├── core.tfvars<br/>│       └── cluster.tfvars<br/>├── cluster<br/>│   ├── main.tf<br/>│   ├── remote.tf<br/>│   ├── data.tf<br/>│   ├── resource_locks.tf<br/>│   ├── variables.tf<br/>│   └── versions.tf<br/>├── common<br/>│   ├── cosmosdb.tf<br/>│   ├── data.tf<br/>│   ├── main.tf<br/>│   ├── remote.tf<br/>│   ├── resource_locks.tf<br/>│   ├── variables.tf<br/>│   └── versions.tf<br/>├── core<br/>│   ├── container_registry.tf<br/>│   ├── main.tf<br/>│   ├── dns.tf<br/>│   ├── notification_hubs.tf<br/>│   ├── outputs.tf<br/>│   ├── remote.tf<br/>│   ├── resource_groups.tf<br/>│   ├── resource_locks.tf<br/>│   ├── storage.tf<br/>│   ├── variables.tf<br/>│   └── versions.tf<br/>└── environment<br/>    ├── dev.tfvars<br/>    └── production.tfvars</span></pre><p id="cf9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的文件夹结构中，我们有以下顶级文件夹:</p><ol class=""><li id="c7aa" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated"><strong class="ki iu">后端:</strong>这个文件夹存放了填充Terraform远程状态文件的tfvar文件。我们没有硬编码这些，而是在运行管道时使用<code class="fe nk nl nm nb b">-backend-config</code>参数来动态填充远程状态</li><li id="be6c" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="ki iu">组件集群、公共和核心:</strong>这些是我们的组件。在部署之前，我们的环境需要一些核心基础设施；然后部署共享(公共)资源，接着是AKS集群本身。不需要用AKS，也不总是需要三个组件。</li><li id="5655" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">环境:最后一个文件夹包含我们的tfvar文件。每一个都是特定于环境的，包含满足开发或生产环境运行<code class="fe nk nl nm nb b">terraform plan</code>和<code class="fe nk nl nm nb b">terraform apply</code>所需的所有变量。</li></ol><p id="f4a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑到这一切，让我们建立一些管道！</p><h1 id="e936" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">1.在Azure DevOps中配置凭据以向Azure进行身份验证</h1><p id="7365" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">这里你有两个选择，你如何实现它完全取决于你的组织想要在Azure DevOps中嵌入多深。您可以使用:</p><ol class=""><li id="0e54" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">一个<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/library/service-endpoints?view=azure-devops&amp;tabs=yaml#sep-azure-resource-manager" rel="noopener ugc nofollow" target="_blank"> AzureRM服务连接</a></li><li id="f520" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">使用a) Azure密钥库或b)变量组提供环境变量</li></ol><p id="8d95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们选择使用服务连接，因为这可以确保我们的服务主体凭据永远无法从Azure DevOps或Azure Key Vault中访问或检索。</p><p id="32e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您在目标Azure订阅中拥有Contributor访问权限或更高权限，则可以选择自动方法。否则，您必须提供预先存在的服务主体的凭据，并选择手动选项。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/55de401878158074a8d042015198f6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-noRCwcPb5_NVwjW_1ftA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">两个服务连接设置选项。“自动”显示在左侧(如果您在订阅中拥有必要的权限，会容易得多)，而“手动”显示在右侧。</figcaption></figure><h1 id="bc77" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">2.创建Azure DevOps环境</h1><p id="ab9c" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">现在，我们创建一个Azure DevOps环境，并添加一个手动干预步骤。Azure DevOps环境相当强大；它们跟踪您部署到的资源，并显示在这些环境中运行了哪些构建:</p><blockquote class="no np nq"><p id="0053" class="kg kh le ki b kj kk kl km kn ko kp kq nr ks kt ku ns kw kx ky nt la lb lc ld im bi translated">环境是资源的集合，可以通过管道中的部署作为目标。环境可以包括Kubernetes集群、Azure web应用、虚拟机、数据库。环境名称的典型示例有开发、测试、QA、试运行和生产。</p></blockquote><p id="34d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的环境名例子正是我们所使用的，但是在这个例子中，我创建了一个名为<code class="fe nk nl nm nb b">terraform</code>的环境，只是为了说明环境是如何工作的。我们将在我们的YAML管道中参考这种环境，以确保每次运行<code class="fe nk nl nm nb b">terraform plan</code>时，我们都会在运行<code class="fe nk nl nm nb b">terraform apply</code>之前暂停，等待有人批准计划。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/f960d4833627e695da0841ec3acbeb02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4pcobNzwYlijBuObrukAw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">1.在Azure DevOps 2中使用环境刀片中的+图标创建环境。选择汉堡菜单，然后选择批准和检查3。添加批准检查4。输入批准人(您可以有任意多的批准人)，设置高级选项和超时。</figcaption></figure><h1 id="7509" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">3.创建一个基本的YAML管道</h1><p id="66f9" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">上周，我无意中发现了<a class="nv nw ep" href="https://medium.com/u/5629e51c3c01?source=post_page-----f8cd022a3341--------------------------------" rel="noopener" target="_blank">James R Counts</a>‘优秀<em class="le"> </em>的博客文章，标题为<a class="ae kf" href="http://jamesrcounts.com/2019/10/14/azdo-safe-terraform-pipelines.html" rel="noopener ugc nofollow" target="_blank">使用Azure DevOps安全铺设管道</a>。在这里，我将效仿他的例子，做一些调整，使我们的管道<em class="le">更加安全，</em>也许启动起来更快一点。我将在这里构建的管道将由一些简单的任务组成，这些任务由阶段分开。在后面的博客文章中，我将向您展示如何将所有这些任务模板化，以使YAML在管道之间更加可移植。</p><h1 id="5f0c" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">任务#1:缓存任务</h1><p id="0033" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">当我们在本地运行Terraform时，我们通常会运行<code class="fe nk nl nm nb b">terraform init</code>一次，然后<code class="fe nk nl nm nb b">terrform plan</code>和<code class="fe nk nl nm nb b">terraform apply</code>都在<em class="le">相同的机器</em>上，具有<em class="le">相同的文件系统</em>。Azure DevOps将不同的阶段放在不同的代理上。这意味着我们丢失了包含提供者插件、后端和子模块的初始化的<code class="fe nk nl nm nb b">.terraform</code>目录。我们将使用缓存任务来缓存整个工作目录并在以后恢复它，而不是在不同阶段之间重复这个过程。</p><p id="e0e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不会在这里使用发布工件任务，因为任何登录Azure DevOps的人都可以访问工件。存储在我们的tfvars或Terraform存储库中的任何秘密或敏感数据都会被暴露，这是我们绝对要防止的。缓存任务的范围是当前正在运行的作业和分配给它的代理，因此不能被在任何其他代理上运行的其他作业或登录到DevOps控制台或CLI的任何用户访问。你可以在这里阅读更多关于安全和缓存任务的信息。</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Azure DevOps中的缓存任务</figcaption></figure><p id="9899" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设置好缓存后，我们将在托管的DevOps代理上安装Terraform并运行<code class="fe nk nl nm nb b">terraform init</code>，为任务提供服务连接和后端配置细节。这利用了Microsoft DevLabs Terraform扩展，您可以在您的组织中安装该扩展<a class="ae kf" href="https://marketplace.visualstudio.com/items?itemName=ms-devlabs.custom-terraform-tasks" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安装和初始化Terraform</figcaption></figure><p id="95af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们的Terraform被初始化，我们就继续执行一个计划，确保指定了<code class="fe nk nl nm nb b">-out</code> arg，这样这个计划就被保存到包含我们所有Terraform代码的目录中的一个文件中:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">运行地形图</figcaption></figure><p id="8796" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦计划被批准，我们所要做的就是运行<code class="fe nk nl nm nb b">terraform apply</code>并提供我们在第一阶段生成的计划。但是，如果作业和阶段运行在具有不同文件系统的不同DevOps代理上，我们如何从另一个代理安全地访问计划呢？我们将恢复我上面提到的缓存，并简单地运行<code class="fe nk nl nm nb b">terraform apply</code>。这样做的好处是整个目录都被缓存了；这包括<code class="fe nk nl nm nb b">.terraform</code>目录以及我们之前创建的<code class="fe nk nl nm nb b">.tfplan</code>文件，它就在根目录下。我们不需要再次<code class="fe nk nl nm nb b">init</code>，我们可以轻松地向terraform提供计划文件，这意味着我们确切地知道将应用什么，并且我们可以保证没有人能够在管道中的任何点拦截数据。</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="7de6" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">把所有的放在一起</h1><p id="0819" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">这是完整的Azure DevOps管道yaml文件。你可以看到总共还不到100行。让我们走一遍:</p><ol class=""><li id="823d" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">我们正在设置一个名为<code class="fe nk nl nm nb b">tfComponent</code>的变量，以针对位于<code class="fe nk nl nm nb b">terraform/src/cluster</code>的集群组件运行Terraform</li><li id="a77d" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">我们选择位于<code class="fe nk nl nm nb b">terraform/src/environment/dev.tfvars</code>的tfvar文件。</li><li id="32e9" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">我们没有使用<code class="fe nk nl nm nb b">terraform/src/backends</code>目录中的任何远程状态tfvar文件，因为Terraform任务为我们处理了所有这些！理论上，我们可以删除这个目录，但是我喜欢保留它以便在本地运行Terraform，以防我们想在把它推上g it之前测试一些东西。</li><li id="6f74" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">第一阶段运行Terraform Plan，缓存吞噬目录中的所有文件，并用唯一生成的密钥保存它们。</li><li id="5375" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">第二阶段仅在有人批准作业后运行。批准后，使用相同的密钥恢复缓存，然后运行Terraform Apply。</li></ol><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="7f5e" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">接下来</h1><p id="2ec9" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">在我的下一篇博文中，我将详细介绍我们如何使用模板和参数来保持管道的整洁和可重复。敬请期待！</p></div></div>    
</body>
</html>