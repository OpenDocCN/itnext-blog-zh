<html>
<head>
<title>Animating Visibility with CSS: An Example of React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用CSS制作可见性动画:React钩子的一个例子</h1>
<blockquote>原文：<a href="https://itnext.io/animating-visibility-with-css-an-example-of-react-hooks-8b15685cf7f8?source=collection_archive---------0-----------------------#2019-07-28">https://itnext.io/animating-visibility-with-css-an-example-of-react-hooks-8b15685cf7f8?source=collection_archive---------0-----------------------#2019-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="535b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为使用React挂钩构建一个可重用的、功能性的动画组件。</h2></div><p id="eba6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">动画让用户开心。从大量的文章来看，你可能会认为React Hooks让开发人员很开心。但对我来说，疲劳开始渗入我对钩子的看法。但是意外的发现救了我，因为我发现了一个与React钩子很匹配的例子，而不仅仅是“新方法”。正如您可能已经从本文的标题中猜到的那样，这个例子是一个动画。</p><p id="d999" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【freecodecamp.org】(注:本文首发于<a class="ae lc" href="https://www.freecodecamp.org/news/animating-visibility-with-css-an-example-of-react-hooks/" rel="noopener ugc nofollow" target="_blank"><em class="lb"/></a><em class="lb">)。)</em></p><p id="e401" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我当时正在开发一个React应用程序，在一个网格中使用卡片。当一个项目被删除，我想动画它的退出，就像这样。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/d07f098683086f45c3d375773a95a1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*JotFWCuxBCLNYTjXPQpw5g.gif"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">我的目标</figcaption></figure><p id="47d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，要做到这一点是有细微差别的。我的解决方案让我很好地使用了React钩子。</p><h1 id="a97d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">我们要做什么？</h1><ul class=""><li id="97b7" class="mh mi iq kh b ki mj kl mk ko ml ks mm kw mn la mo mp mq mr bi translated">从基线示例应用程序开始</li><li id="6017" class="mh mi iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">递增动画的<em class="lb">消失</em>的元素，突出一些挑战</li><li id="f2ad" class="mh mi iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">一旦我们获得了想要的动画，我们将重构一个可重用的动画组件</li><li id="fe23" class="mh mi iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">我们将使用这个组件来制作侧边栏和导航栏的动画</li><li id="78d3" class="mh mi iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">还有…(需要阅读/跳到最后)</li></ul><p id="082e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于不耐烦的人，这里是这个项目中代码的<a class="ae lc" href="https://github.com/csepulv/animated-visibility" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。每一步都有标签。(请参阅自述文件，了解每个标签的链接和说明。)</p><div class="mx my gp gr mz na"><a href="https://github.com/csepulv/animated-visibility" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd ir gy z fp nf fr fs ng fu fw ip bi translated">CSE pulv/动画-可见性</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">用CSS制作可见性动画:React Hooks的一个例子</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">github.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no lj na"/></div></div></a></div><h1 id="d2b8" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">基线</h1><p id="4424" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko np kq kr ks nq ku kv kw nr ky kz la ij bi translated">我已经创建了一个简单的应用程序，使用了<a class="ae lc" href="https://facebook.github.io/create-react-app/" rel="noopener ugc nofollow" target="_blank"><em class="lb">create-react-app</em></a><em class="lb">。它有一个由简单卡片组成的格子。您可以隐藏单张卡片。</em></p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/3e5820ec44a3b7ec27fd2e8e251ac873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*gc9DaxhZ-z-fpHsKPgWGXg.gif"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">无动画-项目消失得太快</figcaption></figure><p id="c1d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的代码很简单，结果也没什么意思。当用户点击<em class="lb">眼睛</em>图标按钮时，我们改变该项目的<code class="fe ns nt nu nv b">display</code>属性。</p><pre class="le lf lg lh gt nw nv nx ny aw nz bi"><span id="8c45" class="oa lq iq nv b gy ob oc l od oe"><strong class="nv ir">function </strong><em class="lb">Box</em>({ word }) {<br/>  <strong class="nv ir">const </strong>color = colors[<strong class="nv ir"><em class="lb">Math</em></strong>.floor(<strong class="nv ir"><em class="lb">Math</em></strong>.random() * 9)];<br/>  <strong class="nv ir">const </strong>[visible, setVisible] = <em class="lb">useState</em>(<strong class="nv ir">true</strong>);<br/><br/>  <strong class="nv ir">function </strong><em class="lb">hideMe</em>(){<br/>    setVisible(<strong class="nv ir">false</strong>);<br/>  }<br/><br/>  <strong class="nv ir">let </strong>style = { <strong class="nv ir">borderColor</strong>: color, <strong class="nv ir">backgroundColor</strong>: color };<br/>  <strong class="nv ir">if </strong>(!visible) style.<strong class="nv ir">display </strong>= <strong class="nv ir">"none"</strong>;<br/><br/>  <strong class="nv ir">return </strong>(<br/>    &lt;<strong class="nv ir">div className="box" style=</strong>{style}&gt;<br/>      &lt;<strong class="nv ir">div className="center"</strong>&gt;{word}&lt;/<strong class="nv ir">div</strong>&gt;<br/>      &lt;<strong class="nv ir">button className="button bottom-corner" onClick=</strong>{<em class="lb">hideMe</em>}&gt;<br/>        &lt;<strong class="nv ir">i className="center far fa-eye fa-lg" </strong>/&gt;<br/>      &lt;/<strong class="nv ir">button</strong>&gt;<br/>    &lt;/<strong class="nv ir">div</strong>&gt;<br/>  );<br/>}</span></pre><p id="1867" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(是的，我在上面使用了钩子，但这不是钩子的有趣用法。)</p><h1 id="8e4f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">添加动画</h1><p id="b419" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko np kq kr ks nq ku kv kw nr ky kz la ij bi translated">我没有建立自己的动画库，而是寻找了一个类似于<a class="ae lc" href="https://daneden.github.io/animate.css/" rel="noopener ugc nofollow" target="_blank"><em class="lb">animate . CSS</em></a><em class="lb">的动画库。</em><a class="ae lc" href="https://github.com/digital-flowers/react-animated-css" rel="noopener ugc nofollow" target="_blank"><em class="lb">react-animated-CSS</em></a><em class="lb"/>是一个不错的库，它提供了一个关于<em class="lb"> animate.css. </em>的包装器</p><p id="5afe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ns nt nu nv b">npm install --save react-animated-css</code></p><p id="ea64" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<em class="lb"> animate.css </em>添加到<code class="fe ns nt nu nv b">index.html</code></p><pre class="le lf lg lh gt nw nv nx ny aw nz bi"><span id="a9ef" class="oa lq iq nv b gy ob oc l od oe">&lt;<strong class="nv ir">link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.css" </strong>/&gt;</span></pre><p id="622f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的<code class="fe ns nt nu nv b">Box</code>组件中，我们将其渲染改为</p><pre class="le lf lg lh gt nw nv nx ny aw nz bi"><span id="f4f2" class="oa lq iq nv b gy ob oc l od oe"><strong class="nv ir">return </strong>(<br/>  &lt;<strong class="nv ir">Animated animationIn="zoomIn" animationOut="zoomOut" isVisible=</strong>{visible}&gt;<br/>    &lt;<strong class="nv ir">div className="box" style=</strong>{style}&gt;<br/>      &lt;<strong class="nv ir">div className="center"</strong>&gt;{word}&lt;/<strong class="nv ir">div</strong>&gt;<br/>      &lt;<strong class="nv ir">button className="button bottom-corner" onClick=</strong>{<em class="lb">hideMe</em>}&gt;<br/>        &lt;<strong class="nv ir">i className="center far fa-eye fa-lg" </strong>/&gt;<br/>      &lt;/<strong class="nv ir">button</strong>&gt;<br/>    &lt;/<strong class="nv ir">div</strong>&gt;<br/>  &lt;/<strong class="nv ir">Animated</strong>&gt;<br/>);</span></pre><h2 id="1e0c" class="oa lq iq bd lr of og dn lv oh oi dp lz ko oj ok mb ks ol om md kw on oo mf op bi translated">不完全是我们想要的</h2><p id="0632" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko np kq kr ks nq ku kv kw nr ky kz la ij bi translated">但是<em class="lb"> animate.css </em>动画<code class="fe ns nt nu nv b">opacity</code>等css属性；您不能在<code class="fe ns nt nu nv b">display</code>属性上进行CSS转换。因此，一个不可见的对象仍然存在，它占据了文档流中的空间。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/9144f909e56c451d92ccd42fe98e85e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*00uIcG8Mc5_B9AQGYEa99w.gif"/></div></figure><p id="3ffb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你稍微谷歌一下，你会发现一些建议使用定时器在动画结束时设置T4的解决方案。</p><p id="b296" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以补充说，</p><pre class="le lf lg lh gt nw nv nx ny aw nz bi"><span id="5e77" class="oa lq iq nv b gy ob oc l od oe"><strong class="nv ir">function </strong><em class="lb">Box</em>({ word }) {<br/>  <strong class="nv ir">const </strong>color = colors[<strong class="nv ir"><em class="lb">Math</em></strong>.floor(<strong class="nv ir"><em class="lb">Math</em></strong>.random() * 9)];<br/>  <strong class="nv ir">const </strong>[visible, setVisible] = <em class="lb">useState</em>(<strong class="nv ir">true</strong>);<br/>  <strong class="nv ir">const </strong>[fading, setFading] = <em class="lb">useState</em>(<strong class="nv ir">false</strong>);<br/><br/>  <strong class="nv ir">function </strong><em class="lb">hideMe</em>() {<br/>    setFading(<strong class="nv ir">true</strong>);<br/>    <em class="lb">setTimeout</em>(() =&gt; setVisible(<strong class="nv ir">false</strong>), 650);<br/>  }<br/><br/>  <strong class="nv ir">let </strong>style = { <strong class="nv ir">borderColor</strong>: color, <strong class="nv ir">backgroundColor</strong>: color };<br/><br/>  <strong class="nv ir">return </strong>(<br/>    &lt;<strong class="nv ir">Animated<br/>      animationIn="zoomIn"<br/>      animationOut="zoomOut"<br/>      isVisible=</strong>{!fading}<br/>      <strong class="nv ir">style=</strong>{visible ? <strong class="nv ir">null </strong>: { <strong class="nv ir">display</strong>: <strong class="nv ir">"none" </strong>}}<br/>    &gt;<br/>      &lt;<strong class="nv ir">div className="box" style=</strong>{style}&gt;<br/>        &lt;<strong class="nv ir">div className="center"</strong>&gt;{word}&lt;/<strong class="nv ir">div</strong>&gt;<br/>        &lt;<strong class="nv ir">button className="button bottom-corner" onClick=</strong>{<em class="lb">hideMe</em>}&gt;<br/>          &lt;<strong class="nv ir">i className="center far fa-eye fa-lg" </strong>/&gt;<br/>        &lt;/<strong class="nv ir">button</strong>&gt;<br/>      &lt;/<strong class="nv ir">div</strong>&gt;<br/>    &lt;/<strong class="nv ir">Animated</strong>&gt;<br/>  );<br/>}</span></pre><p id="45bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(注意:默认动画时长为1000毫秒。我使用650毫秒作为超时时间，以减少设置<code class="fe ns nt nu nv b">display</code>属性之前的停顿/暂停。这是一个偏好问题。)</p><p id="99d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那会给我们想要的效果。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/8533a2526fc328384fe39081e361c442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*9gXR6QZyxAfqUjSMox3ueQ.gif"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">耶！</figcaption></figure><h1 id="d1ee" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">创建可重用组件</h1><p id="6775" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko np kq kr ks nq ku kv kw nr ky kz la ij bi translated">我们可以就此打住，但有两个问题(对我来说):</p><ol class=""><li id="ea7b" class="mh mi iq kh b ki kj kl km ko oq ks or kw os la ot mp mq mr bi translated">我不想复制/粘贴<code class="fe ns nt nu nv b">Animated</code>模块、样式和功能来重现这种效果</li><li id="f7aa" class="mh mi iq kh b ki ms kl mt ko mu ks mv kw mw la ot mp mq mr bi translated"><code class="fe ns nt nu nv b">Box</code>组件混合了不同种类的逻辑，即违反了<a class="ae lc" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> <em class="lb">关注点分离</em> </a> <em class="lb">。</em>具体来说，<code class="fe ns nt nu nv b">Box</code>的基本功能是渲染一张包含内容的卡片。但是动画细节是混在一起的。</li></ol><h2 id="8b92" class="oa lq iq bd lr of og dn lv oh oi dp lz ko oj ok mb ks ol om md kw on oo mf op bi translated">类别组件</h2><p id="3b9a" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko np kq kr ks nq ku kv kw nr ky kz la ij bi translated">我们可以创建一个传统的React类组件来管理动画的状态:切换可见性并为<code class="fe ns nt nu nv b">display</code> CSS属性设置超时。</p><pre class="le lf lg lh gt nw nv nx ny aw nz bi"><span id="daf8" class="oa lq iq nv b gy ob oc l od oe"><strong class="nv ir">class </strong>AnimatedVisibility <strong class="nv ir">extends </strong>Component {<br/>  constructor(props) {<br/>    <strong class="nv ir">super</strong>(props);<br/>    <strong class="nv ir">this</strong>.<strong class="nv ir">state </strong>= { <strong class="nv ir">noDisplay</strong>: <strong class="nv ir">false</strong>, <strong class="nv ir">visible</strong>: <strong class="nv ir">this</strong>.<strong class="nv ir">props</strong>.<strong class="nv ir">visible </strong>};<br/>  }<br/><br/>  componentWillReceiveProps(nextProps, nextContext) {<br/>    <strong class="nv ir">if </strong>(!nextProps.<strong class="nv ir">visible</strong>) {<br/>      <strong class="nv ir">this</strong>.setState({ <strong class="nv ir">visible</strong>: <strong class="nv ir">false </strong>});<br/>      <em class="lb">setTimeout</em>(() =&gt; <strong class="nv ir">this</strong>.setState({ <strong class="nv ir">noDisplay</strong>: <strong class="nv ir">true </strong>}), 650);<br/>    }<br/>  }<br/><br/>  render() {<br/>    <strong class="nv ir">return </strong>(<br/>      &lt;<strong class="nv ir">Animated<br/>        animationIn="zoomIn"<br/>        animationOut="zoomOut"<br/>        isVisible=</strong>{<strong class="nv ir">this</strong>.<strong class="nv ir">state</strong>.<strong class="nv ir">visible</strong>}<br/>        <strong class="nv ir">style=</strong>{<strong class="nv ir">this</strong>.<strong class="nv ir">state</strong>.<strong class="nv ir">noDisplay </strong>? { <strong class="nv ir">display</strong>: <strong class="nv ir">"none" </strong>} : <strong class="nv ir">null</strong>}<br/>      &gt;<br/>        {<strong class="nv ir">this</strong>.<strong class="nv ir">props</strong>.<strong class="nv ir">children</strong>}<br/>      &lt;/<strong class="nv ir">Animated</strong>&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="2800" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后使用它</p><pre class="le lf lg lh gt nw nv nx ny aw nz bi"><span id="7d4b" class="oa lq iq nv b gy ob oc l od oe"><strong class="nv ir">function </strong><em class="lb">Box</em>({ word }) {<br/>  <strong class="nv ir">const </strong>color = colors[<strong class="nv ir"><em class="lb">Math</em></strong>.floor(<strong class="nv ir"><em class="lb">Math</em></strong>.random() * 9)];<br/>  <strong class="nv ir">const </strong>[visible, setVisible] = <em class="lb">useState</em>(<strong class="nv ir">true</strong>);<br/><br/>  <strong class="nv ir">function </strong><em class="lb">hideMe</em>() {<br/>    setVisible(<strong class="nv ir">false</strong>);<br/>  }<br/><br/>  <strong class="nv ir">let </strong>style = { <strong class="nv ir">borderColor</strong>: color, <strong class="nv ir">backgroundColor</strong>: color };<br/><br/>  <strong class="nv ir">return </strong>(<br/>    &lt;<strong class="nv ir">AnimatedVisibility visible=</strong>{visible}&gt;<br/>      &lt;<strong class="nv ir">div className="box" style=</strong>{style}&gt;<br/>        &lt;<strong class="nv ir">div className="center"</strong>&gt;{word}&lt;/<strong class="nv ir">div</strong>&gt;<br/>        &lt;<strong class="nv ir">button className="button bottom-corner" onClick=</strong>{<em class="lb">hideMe</em>}&gt;<br/>          &lt;<strong class="nv ir">i className="center far fa-eye fa-lg" </strong>/&gt;<br/>        &lt;/<strong class="nv ir">button</strong>&gt;<br/>      &lt;/<strong class="nv ir">div</strong>&gt;<br/>    &lt;/<strong class="nv ir">AnimatedVisibility</strong>&gt;<br/>  );<br/>}</span></pre><p id="a4c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这确实创建了一个可重用的组件，但是有点复杂。我们可以做得更好。</p><h1 id="dc90" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">反应钩子和使用效果</h1><p id="0b8b" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko np kq kr ks nq ku kv kw nr ky kz la ij bi translated"><a class="ae lc" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>是React 16.8中的新特性。它们为React组件中的生命周期和状态管理提供了一种更简单的方法。</p><p id="e9bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lc" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> <em class="lb">使用效果</em> </a>挂钩为我们使用<code class="fe ns nt nu nv b">componentWillReceiveProps</code>提供了一个优雅的替代品。代码更简单，我们可以再次使用一个功能组件。</p><pre class="le lf lg lh gt nw nv nx ny aw nz bi"><span id="c762" class="oa lq iq nv b gy ob oc l od oe"><strong class="nv ir">function </strong><em class="lb">AnimatedVisibility</em>({ visible, children }) {<br/>  <strong class="nv ir">const </strong>[noDisplay, setNoDisplay] = <em class="lb">useState</em>(!visible);</span><span id="0a2c" class="oa lq iq nv b gy ou oc l od oe">  <em class="lb">useEffect</em>(() =&gt; {<br/>    <strong class="nv ir">if </strong>(!visible) <em class="lb">setTimeout</em>(() =&gt; setNoDisplay(<strong class="nv ir">true</strong>), 650);<br/>    <strong class="nv ir">else </strong>setNoDisplay(<strong class="nv ir">false</strong>);<br/>  }, [visible]);<br/><br/>  <strong class="nv ir">const </strong>style = noDisplay ? { <strong class="nv ir">display</strong>: <strong class="nv ir">"none" </strong>} : <strong class="nv ir">null</strong>;<br/>  <strong class="nv ir">return </strong>(<br/>    &lt;<strong class="nv ir">Animated<br/>      animationIn="zoomIn"<br/>      animationOut="zoomOut"<br/>      isVisible=</strong>{visible}<br/>      <strong class="nv ir">style=</strong>{style}<br/>    &gt;<br/>      {children}<br/>    &lt;/<strong class="nv ir">Animated</strong>&gt;<br/>  );<br/>}</span></pre><p id="8a73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">使用效果</em>挂钩有一些微妙之处。主要是为了副作用:改变状态，调用异步函数等。在我们的例子中，它基于<code class="fe ns nt nu nv b">visible.</code>的先前值设置内部<code class="fe ns nt nu nv b">noDisplay</code>布尔值</p><p id="7adc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将<code class="fe ns nt nu nv b">visible</code>添加到<code class="fe ns nt nu nv b">useEffect</code>的依赖数组中，我们的<code class="fe ns nt nu nv b">useEffect</code>钩子将只在<code class="fe ns nt nu nv b">visible</code>的值改变时被调用。</p><p id="20f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为<em class="lb"> useEffect </em>是比类组件杂乱更好的解决方案。🎉</p><h1 id="65f7" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">重用组件:侧栏和导航条</h1><p id="eefc" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko np kq kr ks nq ku kv kw nr ky kz la ij bi translated">每个人都喜欢边栏和导航条。所以我们每样加一个。</p><pre class="le lf lg lh gt nw nv nx ny aw nz bi"><span id="230a" class="oa lq iq nv b gy ob oc l od oe"><strong class="nv ir">function </strong><em class="lb">ToggleButton</em>({ label, isOpen, onClick }) {<br/>  <strong class="nv ir">const </strong>icon = isOpen ? (<br/>    &lt;<strong class="nv ir">i className="fas fa-toggle-off fa-lg" </strong>/&gt;<br/>  ) : (<br/>    &lt;<strong class="nv ir">i className="fas fa-toggle-on fa-lg" </strong>/&gt;<br/>  );<br/>  <strong class="nv ir">return </strong>(<br/>    &lt;<strong class="nv ir">button className="toggle" onClick=</strong>{onClick}&gt;<br/>      {label} {icon}<br/>    &lt;/<strong class="nv ir">button</strong>&gt;<br/>  );<br/>}<br/><br/><strong class="nv ir">function </strong><em class="lb">Navbar</em>({ open }) {<br/>  <strong class="nv ir">return </strong>(<br/>    &lt;<strong class="nv ir">AnimatedVisibility<br/>      visible=</strong>{open}<br/>      <strong class="nv ir">animationIn="slideInDown"<br/>      animationOut="slideOutUp"<br/>      animationInDuration=</strong>{300}<br/>      <strong class="nv ir">animationOutDuration=</strong>{600}<br/>    &gt;<br/>      &lt;<strong class="nv ir">nav className="bar nav"</strong>&gt;<br/>        &lt;<strong class="nv ir">li</strong>&gt;Item 1&lt;/<strong class="nv ir">li</strong>&gt;<br/>        &lt;<strong class="nv ir">li</strong>&gt;Item 2&lt;/<strong class="nv ir">li</strong>&gt;<br/>        &lt;<strong class="nv ir">li</strong>&gt;Item 3&lt;/<strong class="nv ir">li</strong>&gt;<br/>      &lt;/<strong class="nv ir">nav</strong>&gt;<br/>    &lt;/<strong class="nv ir">AnimatedVisibility</strong>&gt;<br/>  );<br/>}<br/><br/><strong class="nv ir">function </strong><em class="lb">Sidebar</em>({ open }) {<br/>  <strong class="nv ir">return </strong>(<br/>    &lt;<strong class="nv ir">AnimatedVisibility<br/>      visible=</strong>{open}<br/>      <strong class="nv ir">animationIn="slideInLeft"<br/>      animationOut="slideOutLeft"<br/>      animationInDuration=</strong>{500}<br/>      <strong class="nv ir">animationOutDuration=</strong>{600}<br/>      <strong class="nv ir">className="on-top"<br/>    </strong>&gt;<br/>      &lt;<strong class="nv ir">div className="sidebar"</strong>&gt;<br/>        &lt;<strong class="nv ir">ul</strong>&gt;<br/>          &lt;<strong class="nv ir">li</strong>&gt;Item 1&lt;/<strong class="nv ir">li</strong>&gt;<br/>          &lt;<strong class="nv ir">li</strong>&gt;Item 2&lt;/<strong class="nv ir">li</strong>&gt;<br/>          &lt;<strong class="nv ir">li</strong>&gt;Item 3&lt;/<strong class="nv ir">li</strong>&gt;<br/>        &lt;/<strong class="nv ir">ul</strong>&gt;<br/>      &lt;/<strong class="nv ir">div</strong>&gt;<br/>    &lt;/<strong class="nv ir">AnimatedVisibility</strong>&gt;<br/>  );<br/>}<br/><br/><strong class="nv ir">function </strong><em class="lb">App</em>() {<br/>  <strong class="nv ir">const </strong>[navIsOpen, setNavOpen] = <em class="lb">useState</em>(<strong class="nv ir">false</strong>);<br/>  <strong class="nv ir">const </strong>[sidebarIsOpen, setSidebarOpen] = <em class="lb">useState</em>(<strong class="nv ir">false</strong>);<br/><br/>  <strong class="nv ir">function </strong><em class="lb">toggleNav</em>() {<br/>    setNavOpen(!navIsOpen);<br/>  }<br/><br/>  <strong class="nv ir">function </strong><em class="lb">toggleSidebar</em>() {<br/>    setSidebarOpen(!sidebarIsOpen);<br/>  }<br/><br/>  <strong class="nv ir">return </strong>(<br/>    &lt;<strong class="nv ir">Fragment</strong>&gt;<br/>      &lt;<strong class="nv ir">main className="main"</strong>&gt;<br/>        &lt;<strong class="nv ir">header className="bar header"</strong>&gt;<br/>          &lt;<strong class="nv ir">ToggleButton<br/>            label="Sidebar"<br/>            isOpen=</strong>{sidebarIsOpen}<br/>            <strong class="nv ir">onClick=</strong>{<em class="lb">toggleSidebar</em>}<br/>          /&gt;<br/>          &lt;<strong class="nv ir">ToggleButton label="Navbar" isOpen=</strong>{navIsOpen} <strong class="nv ir">onClick=</strong>{<em class="lb">toggleNav</em>} /&gt;<br/>        &lt;/<strong class="nv ir">header</strong>&gt;<br/>        &lt;<strong class="nv ir">Navbar open=</strong>{navIsOpen} /&gt;<br/>        &lt;<strong class="nv ir">Boxes </strong>/&gt;<br/>      &lt;/<strong class="nv ir">main</strong>&gt;<br/>      &lt;<strong class="nv ir">Sidebar open=</strong>{sidebarIsOpen} /&gt;<br/>    &lt;/<strong class="nv ir">Fragment</strong>&gt;<br/>  );<br/>}</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/3c63ac1b153e984d3ac81ed479b3c0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*UKNZfLuC9dk9ECjCwcyEFQ.gif"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">实现重用</figcaption></figure><h1 id="8d27" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">但是我们还没完…</h1><p id="a374" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko np kq kr ks nq ku kv kw nr ky kz la ij bi translated">我们可以停在这里。但是正如我之前对<em class="lb">关注点分离</em>的评论一样，我倾向于避免在<code class="fe ns nt nu nv b">Box</code>、<code class="fe ns nt nu nv b">Sidebar</code>或<code class="fe ns nt nu nv b">Navbar</code>的渲染方法中混合<code class="fe ns nt nu nv b">AnimatedVisibility</code>组件。(也是少量重复。)</p><p id="27b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建一个特设。(其实我写过一篇关于动画和hoc的文章，<a class="ae lc" href="https://medium.com/free-code-camp/how-to-build-animated-microinteractions-in-react-aab1cb9fe7c8" rel="noopener"> <em class="lb">如何在React </em> </a> <em class="lb">中构建动画微交互。</em>)但是hoc通常涉及类组件，因为状态管理。</p><p id="2fb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是有了React钩子，我们就可以组成HOC(函数式编程方法)。</p><pre class="le lf lg lh gt nw nv nx ny aw nz bi"><span id="5de7" class="oa lq iq nv b gy ob oc l od oe">function AnimatedVisibility({<br/>  visible,<br/>  children,<br/>  animationOutDuration,<br/>  disappearOffset,<br/>  ...rest<br/>})<br/>// ... same as before</span><span id="0e5d" class="oa lq iq nv b gy ou oc l od oe">}<br/><br/><br/>function makeAnimated(<br/>  Component,<br/>  animationIn,<br/>  animationOut,<br/>  animationInDuration,<br/>  animationOutDuration,<br/>  disappearOffset<br/>) {<br/>  return function({ open, className, ...props }) {<br/>    return (<br/>      &lt;AnimatedVisibility<br/>        visible={open}<br/>        animationIn={animationIn}<br/>        animationOut={animationOut}<br/>        animationInDuration={animationInDuration}<br/>        animationOutDuration={animationOutDuration}<br/>        disappearOffset={disappearOffset}<br/>        className={className}<br/>      &gt;<br/>        &lt;Component {...props} /&gt;<br/>      &lt;/AnimatedVisibility&gt;<br/>    );<br/>  };<br/>}<br/><br/>export function makeAnimationSlideLeft(Component) {<br/>  return makeAnimated(Component, "slideInLeft", "slideOutLeft", 400, 500, 200);<br/>}<br/><br/>export function makeAnimationSlideUpDown(Component) {<br/>  return makeAnimated(Component, "slideInDown", "slideOutUp", 400, 500, 200);<br/>}<br/><br/>export default AnimatedVisibility</span></pre><p id="f067" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe ns nt nu nv b">App.js</code>中使用这些基于函数的hoc</p><pre class="le lf lg lh gt nw nv nx ny aw nz bi"><span id="71e5" class="oa lq iq nv b gy ob oc l od oe">function Navbar() {<br/>  return (<br/>    &lt;nav className="bar nav"&gt;<br/>      &lt;li&gt;Item 1&lt;/li&gt;<br/>      &lt;li&gt;Item 2&lt;/li&gt;<br/>      &lt;li&gt;Item 3&lt;/li&gt;<br/>    &lt;/nav&gt;<br/>  );<br/>}<br/><br/>function Sidebar() {<br/>  return (<br/>    &lt;div className="sidebar"&gt;<br/>      &lt;ul&gt;<br/>        &lt;li&gt;Item 1&lt;/li&gt;<br/>        &lt;li&gt;Item 2&lt;/li&gt;<br/>        &lt;li&gt;Item 3&lt;/li&gt;<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>const AnimatedSidebar = makeAnimationSlideLeft(Sidebar);<br/>const AnimatedNavbar = makeAnimationSlideUpDown(Navbar);<br/><br/>function App() {<br/>  const [navIsOpen, setNavOpen] = useState(false);<br/>  const [sidebarIsOpen, setSidebarOpen] = useState(false);<br/><br/>  function toggleNav() {<br/>    setNavOpen(!navIsOpen);<br/>  }<br/><br/>  function toggleSidebar() {<br/>    setSidebarOpen(!sidebarIsOpen);<br/>  }<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;main className="main"&gt;<br/>        &lt;header className="bar header"&gt;<br/>          &lt;ToggleButton<br/>            label="Sidebar"<br/>            isOpen={sidebarIsOpen}<br/>            onClick={toggleSidebar}<br/>          /&gt;<br/>          &lt;ToggleButton label="Navbar" isOpen={navIsOpen} onClick={toggleNav} /&gt;<br/>        &lt;/header&gt;<br/>          &lt;AnimatedNavbar open={navIsOpen} /&gt;<br/>        &lt;Boxes /&gt;<br/>      &lt;/main&gt;<br/>      &lt;AnimatedSidebar open={sidebarIsOpen} className="on-top"/&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</span></pre><p id="3257" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">冒着促进我自己工作的风险，我更喜欢干净的结果代码。</p><p id="74cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是最终结果的沙盒。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h1 id="9e64" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">现在怎么办？</h1><p id="51aa" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko np kq kr ks nq ku kv kw nr ky kz la ij bi translated">对于简单的动画，我描述的方法效果很好。对于更复杂的情况，我会使用像<a class="ae lc" href="https://github.com/chenglou/react-motion" rel="noopener ugc nofollow" target="_blank"><em class="lb">react-motion</em></a><em class="lb">这样的库。</em></p><p id="477a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是独立于动画，React钩子提供了创建可读和简单代码的机会。但是，在思维上有一个调整。像<em class="lb"> useEffect </em>这样的钩子不能直接替代所有的生命周期方法。你需要学习和实验。</p><p id="a133" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我建议看看像<a class="ae lc" href="https://usehooks.com/" rel="noopener ugc nofollow" target="_blank">useHooks.com</a>这样的网站和像<a class="ae lc" href="https://github.com/streamich/react-use" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> react这样的库——使用</em> </a>，一个针对各种用例的钩子集合。</p></div></div>    
</body>
</html>