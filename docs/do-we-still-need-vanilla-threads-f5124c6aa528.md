# 我们还需要香草线吗？

> 原文：<https://itnext.io/do-we-still-need-vanilla-threads-f5124c6aa528?source=collection_archive---------2----------------------->

![](img/5439ee8a06eb50890396d98e6c572a10.png)

无论你在哪个平台上开发 C#代码——Web、桌面、移动——你可能已经广泛使用了 *ThreadPool* ,无论是显式使用还是隐式使用。

然而，如果你仍然熟悉像今天这样的*线程池*盛行之前的时代，你很可能还记得经常处理普通的*线程*。

因此，随着所有这些便利性的改进，我最近一直在想，作为应用程序代码开发人员，我们是否真的需要访问普通的*线程*了。从现在开始，它不能仅仅是一个内部的事情吗？或者在某些情况下，我们仍然希望在这里拥有完全的访问权限？难道我们不应该默认使用一个看起来更好的抽象，来最小化使用更低级的模型可能导致的潜在问题吗？

# 基础知识

为了更好地理解这种比较，我们应该仔细看看*线程池*提供了什么，以及它如何提供一种替代方案。

顾名思义，*线程池*是一个托管*线程*的池，它提供了一个易于使用的多线程访问，而实际上不必关心应用程序中的具体*线程*。该池托管动态数量的*线程*准备好接收一个工作单元，并负责调整底层*线程*的数量，相应地清理资源。它通过基于队列的系统接受工作项目，并在相应的资源(一个*线程*)可用时处理它们。

这个池最重要的特点是，一旦一个工作完成，它不会扔掉*线程*，而是把它放回池中。

为什么这很重要？因为创建一个*线程*是**昂贵的**。由于 C#中的一个*线程*指向一个操作系统线程，因此涉及到操作系统端的大量工作，例如分配和保留内存(通常为 1MB)、注册线程等。—不断地、一遍又一遍地做这件事，涉及到大量的计算工作。*线程池*尽力避免这种计算工作。

*线程池*做了更多的工作，以确保它在最佳状态下运行，以满足您的应用对机器规格的要求。尽管很多人认为他们可以针对他们的应用程序创建一个更复杂的调度程序，但使用这个经过测试的组件几乎可以保证你会过得更好。

# 线程池的局限性

这听起来很棒。我们的应用程序可以只调用例如*任务。运行()*并利用这一切。那么，现在让我们回到最初的问题。如果*线程池*做得更好，我们还需要香草*线程*s*吗？是否应该。NET 团队只是让它们过时吗？*

不完全是。您应该知道*线程池*的一些限制:

1.  *在*线程池*上运行的线程*不适合重新配置它们的设置。
    假设你想把线程改成前台线程。前台线程本质上是让运行时在应用程序完成之前等待它完成。从技术上讲，可以将*线程池线程*设置为前台或后台线程，但这并不意味着你应该这样做。如果线被回收会发生什么？那你的设定就没了。此外，该线程上调度的下一项工作也将按配置运行，这可能不是您想要的行为。
    当改变*线程*的*优先级*以修改操作系统对其进行调度的方式，并在机器的实际 CPU 单元上确定执行顺序的优先级时，会发生完全相同的行为。
2.  由于*线程池*有一个最大数量的*线程* s，你应该**绝对**避免在*线程池*上运行工作，这将阻塞一个线程更长或不确定的时间。一旦一个*线程*被阻塞，它将不能被任何其他*线程池*消费者使用。这种效应被称为**饥饿**。因此，通过阻止一项工作，你基本上导致了其他所有人都跟着遭殃。请注意，将操作传递给*线程池*本身并不坏，线程池可能会阻塞一小段时间，因为计算密集型工作也可能会发生这种情况。这很好。但是短暂阻塞和无限锁定一个*线程*是有区别的。
3.  另一个经常被忽视的问题是:由于*线程池*可以服务于许多用户，所以无论你在上面安排什么，都不能保证马上运行。工作在池中排队，但是没有人保证队列是空的。可以忽略这种行为，但是在默认情况下，很有可能您必须等待一段时间才能开始您的工作。

还有其他几个问题，但这些(在我看来)都是次要的。可以在这里查找:[https://docs . Microsoft . com/en-us/dot net/standard/threading/the-managed-thread-pool？redirectedfrom=MSDN](https://docs.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool?redirectedfrom=MSDN)

所以，这里主要的要点是:

*   如果您的应用程序想要托管一个长时间运行(甚至可能阻塞)的后台作业，那么使用一个单独的*线程*仍然是一个好主意。
*   如果你需要以特殊的方式配置*线程*，你应该自己创建。
*   此外，如果您需要可靠和快速的多线程执行，您可能不希望完全依赖于池。

# 结论

在经历了*线程池*的特征和限制之后，可以看出它不是普通*线程*的万能替代品。常规线程仍然存在，而且肯定有它的用途。

然而，根据一般经验，*线程池*对于简单的后台调度来说是一个很好的工具，只要有可能并且合适，我都会使用它。有了异步处理，池的许多限制也暴露出来了。您的应用程序可能不再需要那个长时间运行的后台*线程*，因为定时器和异步延迟是几年前流行的同步阻塞的一个很好的替代方案。

总的来说，对普通线程的需求仍然存在，但是如果你像我一样，也很少使用它，你很可能也没有做错什么。