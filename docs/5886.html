<html>
<head>
<title>Resizing StatefulSet Persistent Volumes with zero downtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调整状态设置永久卷的大小，不停机</h1>
<blockquote>原文：<a href="https://itnext.io/resizing-statefulset-persistent-volumes-with-zero-downtime-916ebc65b1d4?source=collection_archive---------0-----------------------#2021-06-21">https://itnext.io/resizing-statefulset-persistent-volumes-with-zero-downtime-916ebc65b1d4?source=collection_archive---------0-----------------------#2021-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ecf052af53a2b90056fcbba5f476ce46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lGJGIPSpscyQeFaL6jbGQ.png"/></div></div></figure><p id="2475" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们着手调整StatefulSet持久卷的大小之前，让我们简要回顾一下什么是有状态应用程序，什么是StatefulSet，以及Kubernetes存储如何在高级别上工作。</p><h1 id="b154" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">无状态与有状态应用程序</h1><p id="4629" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">无状态应用程序既不读取也不存储关于其状态的信息。按照设计，容器最适合无状态应用程序，因为Kubernetes能够以快速和动态的方式创建和删除容器。</p><p id="1bde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，<strong class="kd iu">有状态应用</strong>将数据保存到<a class="ae mc" href="https://kubernetes.io/docs/concepts/storage" rel="noopener ugc nofollow" target="_blank">持久磁盘存储器</a>，供服务器、客户端和其他应用使用。有状态应用程序的一个例子是数据库或键值存储，其他应用程序可以在其中保存和检索数据。</p><h1 id="c4ce" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Kubernetes状态集</h1><p id="822a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated"><strong class="kd iu"> StatefulSets </strong>是用于管理有状态应用程序的对象。StatefulSets管理一组pod的部署和扩展，并提供关于这些pod的排序和唯一性的保证。</p><p id="48bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">StatefulSets对于需要以下一项或多项功能的应用程序很有价值:</p><ul class=""><li id="68bf" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">稳定、唯一的网络标识符。</li><li id="a22a" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">稳定持久的存储。</li><li id="8097" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">有序、优雅的部署和扩展。</li><li id="30b7" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">有序的自动滚动更新。</li></ul><p id="0215" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有状态集合使用某种类型的<strong class="kd iu">持久存储是很常见的。</strong></p><h1 id="224e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">库伯内特仓储公司</h1><p id="9177" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Kubernetes存储架构基于卷的抽象。卷可以是持久的，也可以是非持久的，Kubernetes允许容器使用一种叫做卷声明的机制动态地请求存储资源。</p><h2 id="681d" class="mr la it bd lb ms mt dn lf mu mv dp lj km mw mx ln kq my mz lr ku na nb lv nc bi translated"><strong class="ak">卷</strong></h2><p id="a824" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">卷是包含Pod中的容器可访问的数据的目录。目录的创建、支持目录的介质以及目录的内容由所使用的特定卷类型决定。</p><p id="228e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kubernetes支持多种类型的卷。临时卷类型具有pod的生存期，但永久卷的生存期会超过pod的生存期。当一个豆荚不复存在，Kubernetes破坏短暂的体积；但是，Kubernetes不会销毁持久性卷。对于给定pod中的任何类型的卷，数据都会在容器重新启动后保留。</p><h2 id="a063" class="mr la it bd lb ms mt dn lf mu mv dp lj km mw mx ln kq my mz lr ku na nb lv nc bi translated"><strong class="ak">持续卷(PV) </strong></h2><p id="7bb0" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">持久卷是群集中由管理员调配或使用存储类动态调配的一块存储。它是群集中的一种资源，就像一个节点一样。</p><h2 id="6b56" class="mr la it bd lb ms mt dn lf mu mv dp lj km mw mx ln kq my mz lr ku na nb lv nc bi translated"><strong class="ak">持续体积索赔(PVC) </strong></h2><p id="59d8" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">PersistentVolumeClaim是用户对存储的请求。它类似于一个豆荚。Pods消耗节点资源，PV消耗PV资源。声明可以请求特定的大小和访问模式(即ReadWriteOnce、ReadOnlyMany或ReadWriteMany)。</p><h2 id="c0b1" class="mr la it bd lb ms mt dn lf mu mv dp lj km mw mx ln kq my mz lr ku na nb lv nc bi translated"><strong class="ak">装订</strong></h2><p id="7048" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">主设备中的控制循环监视新的PV，找到匹配的PV(如果可能)，并将它们绑定在一起。如果一个PV被动态地提供给一个新的PVC，循环将总是将该PV绑定到PVC。</p><h2 id="bf81" class="mr la it bd lb ms mt dn lf mu mv dp lj km mw mx ln kq my mz lr ku na nb lv nc bi translated"><strong class="ak">存储类</strong></h2><p id="7737" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Kubernetes StorageClass对象在PersistentVolumeClaims中按名称指定，以便为存储提供一组属性。storage类本身标识将要使用的置备程序，并按照置备程序理解的术语定义属性集。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/694c7715164d5cb2b022d81411929ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Ob_uOYRiSg4YsZLf6kRUQ.png"/></div></div></figure><p id="0dd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经了解了Kubernetes存储的详细情况，让我们看看如何在不停机的情况下调整StatefulSet持久卷的大小！</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="d66f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Kubernetes v1.11之前，调整永久卷(PV)的大小非常困难。这是一个完全手动的过程，涉及一长串步骤，并且需要从快照创建新卷。你不能只是去修改PVC对象来改变索赔的大小。</p><p id="9063" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">持久卷扩展功能在Kubernetes v1.11中升级为测试版。该功能允许用户通过编辑<code class="fe np nq nr ns b">PersistentVolumeClaim</code>对象轻松调整现有卷的大小。用户不再需要手动与存储后端交互，或者删除并重新创建PV和PVC对象来增加卷的大小。但是不支持收缩持久卷。您可以在这里找到更多信息，包括支持的卷类型列表。</p><p id="8528" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然默认情况下该特性是启用的，但是集群管理员必须通过将用户的<code class="fe np nq nr ns b">StorageClass</code>对象中的<code class="fe np nq nr ns b">allowVolumeExpansion</code>字段设置为<code class="fe np nq nr ns b">true</code>来使该特性对用户可用。只有使用此设置从<code class="fe np nq nr ns b">StorageClass</code>创建的PVC才被允许触发卷扩展。</p><pre class="ne nf ng nh gt nt ns nu nv aw nw bi"><span id="4ba7" class="mr la it ns b gy nx ny l nz oa"><strong class="ns iu">allowVolumeExpansion: true</strong><br/>apiVersion: storage.k8s.io/v1<br/>kind: StorageClass<br/>metadata:<br/>  annotations:<br/>    storageclass.kubernetes.io/is-default-class: "true"<br/>  name: gp2<br/>parameters:<br/>  fsType: ext4<br/>  type: gp2<br/>provisioner: kubernetes.io/aws-ebs<br/>reclaimPolicy: Delete<br/>volumeBindingMode: Immediate</span></pre><p id="98c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以编辑由此<code class="fe np nq nr ns b">StorageClass</code>创建的任何PVC，以请求更多空间。Kubernetes将把对存储字段的更改解释为对更多空间的请求，并将触发自动调整卷大小。</p><blockquote class="ob oc od"><p id="eb6e" class="kb kc oe kd b ke kf kg kh ki kj kk kl of kn ko kp og kr ks kt oh kv kw kx ky im bi translated">您可以在此处找到支持卷扩展<a class="ae mc" href="https://kubernetes.io/docs/concepts/storage/storage-classes/#allow-volume-expansion" rel="noopener ugc nofollow" target="_blank">的卷类型列表。</a></p></blockquote><h1 id="f5f8" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">调整由StatefulSet应用程序声明的PV的大小</h1><p id="a054" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">一旦创建，除了副本数量、更新策略和对象模板之外，StatefulSets对象不能修改。如果您试图修改任何其他规范，您将得到下面的错误:</p><pre class="ne nf ng nh gt nt ns nu nv aw nw bi"><span id="35b7" class="mr la it ns b gy nx ny l nz oa"># * spec: Forbidden: updates to statefulset spec for fields other than ‘replicas’, ‘template’, and ‘updateStrategy’ are forbidden</span></pre><p id="72f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在尝试增加由Prometheus Operator管理的Prometheus实例的使用量时遇到了这个问题。尽管没有停机时间，我们还是找到了解决方法。</p><blockquote class="ob oc od"><p id="0662" class="kb kc oe kd b ke kf kg kh ki kj kk kl of kn ko kp og kr ks kt oh kv kw kx ky im bi translated">如果你还没有，看看我们的观察平台！</p></blockquote><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/observability-at-scale-52d0d9a5fb9b"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">大规模可观测性</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">如何使用普罗米修斯算子、格拉法纳和灭霸在库贝内特斯运行大规模的可观测性平台</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">itnext.io</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz jz ol"/></div></div></a></div><p id="4cb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在普罗米修斯<a class="ae mc" href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" rel="noopener ugc nofollow" target="_blank"> CRD </a> ( <code class="fe np nq nr ns b">spec.storage.VolumeClaimTemplate.spec.resources.requests.storage</code>)中直接修改存储请求将会重新创建具有新规范的StatefulSet，不幸的是，由StatefulSet管理的所有pod将会同时重新创建，从而导致停机。最重要的是，这不会修改PVC对象，存储也不会增加。</p><p id="e6a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还需要完成几个步骤，按照特定的顺序:</p><ul class=""><li id="d367" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated"><strong class="kd iu">将Prometheus Operator(或管理StatefulSet的任何操作员)部署扩展到零个副本:</strong>这意味着您可以修改Prometheus对象，而无需任何协调。如果您的StatefulSet不是由一个<a class="ae mc" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank">操作符</a>管理的，请跳过这一步。</li><li id="4e1a" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><strong class="kd iu">删除StatefulSet对象而不删除窗格:</strong>可以删除StatefulSet对象而不删除底层窗格。我们将有一段时间的孤儿舱，但我们不会有停机时间，这是这里的主要目标。</li></ul><p id="4a9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe np nq nr ns b">kubectl delete sts &lt;statefulset-name&gt; --cascade=orphan</code></p><blockquote class="ob oc od"><p id="c3ec" class="kb kc oe kd b ke kf kg kh ki kj kk kl of kn ko kp og kr ks kt oh kv kw kx ky im bi translated">确保您有办法重新创建StatefulSet对象。您可以使用<code class="fe np nq nr ns b">kubectl get sts &lt;statefulset-name&gt; -o yaml</code>生成yaml文件，并从中删除不必要的字段。</p></blockquote><ul class=""><li id="0e51" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">用所需的存储空间修改PVC对象:</li></ul><pre class="ne nf ng nh gt nt ns nu nv aw nw bi"><span id="c733" class="mr la it ns b gy nx ny l nz oa">kubectl get pvc myPVC -o yaml                                                                                                                               </span><span id="5ade" class="mr la it ns b gy pa ny l nz oa">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  annotations:<br/>...<br/>spec:<br/>  accessModes:<br/>  - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 8Gi<br/>  storageClassName: gp2<br/>  volumeMode: Filesystem<br/>  volumeName: pvc-xxxx-xxxx-xxxx-xxxx-xxxx<br/>status:<br/>  accessModes:<br/>  - ReadWriteOnce<br/>  capacity:<br/>    <strong class="ns iu">storage: 80Gi</strong><br/>  phase: Bound</span></pre><p id="9c95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">确保PVC(本例中为gp2)使用的storageClass的<code class="fe np nq nr ns b"><strong class="kd iu">allowVolumeExpansion</strong></code> <strong class="kd iu"> </strong>设置为true:</p><pre class="ne nf ng nh gt nt ns nu nv aw nw bi"><span id="dd15" class="mr la it ns b gy nx ny l nz oa">kubectl get storageclass gp2 -o yaml                                                                                                                                                     </span><span id="3c96" class="mr la it ns b gy pa ny l nz oa"><strong class="ns iu">allowVolumeExpansion: true</strong><br/>apiVersion: storage.k8s.io/v1<br/>kind: StorageClass<br/>metadata:<br/>  annotations:<br/>    storageclass.kubernetes.io/is-default-class: "true"<br/>  name: gp2<br/>parameters:<br/>  fsType: ext4<br/>  type: gp2<br/>provisioner: kubernetes.io/aws-ebs<br/>reclaimPolicy: Delete<br/>volumeBindingMode: Immediate</span></pre><ul class=""><li id="320d" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated"><strong class="kd iu">使用新的存储请求重新创建stateful set:</strong>stateful set将再次接管孤立单元，并将更新存储规范，而不重新创建它们。如果您使用Helm管理您的部署，只需使用新的存储大小运行Helm即可。如果没有，使用步骤2中生成的yaml文件(<code class="fe np nq nr ns b">kubectl apply -f &lt;file_name.yaml&gt;</code></li><li id="a11f" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><strong class="kd iu">用新的存储请求修改CRD:</strong>如果StatefulSet是由一个操作员通过CRD(在我们的例子中是Prometheus操作员)管理的，请确保您也在这个对象中进行了更改。之后，缩减操作员部署。</li></ul><h1 id="0788" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="5e59" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">尽管Kubernetes默认情况下不支持调整StatefulSet卷的大小(有一个<a class="ae mc" href="https://github.com/kubernetes/enhancements/pull/1848" rel="noopener ugc nofollow" target="_blank"> open PR </a>支持它)，但这种变通方法有助于实现零宕机的目标。如果您认为自己需要调整卷的大小，我们希望这篇文章对您有所帮助。</p></div></div>    
</body>
</html>