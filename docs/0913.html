<html>
<head>
<title>Keep your Kubernetes cluster balanced: the secret to High Availability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保持Kubernetes集群的平衡:高可用性的秘密</h1>
<blockquote>原文：<a href="https://itnext.io/keep-you-kubernetes-cluster-balanced-the-secret-to-high-availability-17edf60d9cb7?source=collection_archive---------0-----------------------#2018-06-17">https://itnext.io/keep-you-kubernetes-cluster-balanced-the-secret-to-high-availability-17edf60d9cb7?source=collection_archive---------0-----------------------#2018-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/57875250c26208594dd01f874ddfda8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdnZBbghNRa_9Ju8dUiMnQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">那些photoshop技巧有什么用处</figcaption></figure><h1 id="f234" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Kubernetes调度程序</h1><p id="e5bd" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">您可能知道，Kubernetes集群由主节点和工作节点组成。<strong class="lc ir">调度器</strong>是主节点中的一个组件，它负责决定哪个工作节点应该运行给定的pod。</p><blockquote class="ly lz ma"><p id="3fdd" class="la lb mb lc b ld mc lf lg lh md lj lk me mf ln lo mg mh lr ls mi mj lv lw lx ij bi translated">调度是一项复杂的任务，就像任何优化问题一样，你总会发现这样一种情况，在人眼看来，结果可能是次优的。</p></blockquote><p id="e427" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">尽管如此，默认调度程序做得相当不错。它遵循常识性策略，例如避免在同一节点上调度pod的多个副本，或者避免在其他节点分配不足时使一个节点过载。</p><p id="3487" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">我不熟悉默认调度程序背后的代码，但是我的观察告诉我，平衡节点工作负载比防止在同一个节点上重复运行更重要。</p><blockquote class="ly lz ma"><p id="12bf" class="la lb mb lc b ld mc lf lg lh md lj lk me mf ln lo mg mh lr ls mi mj lv lw lx ij bi translated">这意味着您可能会发现自己处于这样一种情况:一个pod的所有副本都在同一个节点上。</p></blockquote><p id="9b4c" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">因此，如果节点停机(您应该假设它会停机)，可用性将会受到影响。</p><p id="e307" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">有趣的是，Kubernetes通常通过严格执行某种状态来工作。例如，如果你说你想要三个pod<code class="fe mk ml mm mn b">A</code>，Kubernetes会立即产生新的pod，如果这个数字低于三。<strong class="lc ir">这不是调度的情况。</strong> Kubernetes在创建pod时会尝试智能地展开它们，但不会在之后主动执行良好的展开。</p><blockquote class="ly lz ma"><p id="6fd8" class="la lb mb lc b ld mc lf lg lh md lj lk me mf ln lo mg mh lr ls mi mj lv lw lx ij bi translated">调度仅发生在pod创建时。</p></blockquote><h1 id="bf0a" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">高可用性</h1><p id="30c8" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">运行一个pod的多个副本不能保证高可用性，但是没有它就无法实现高可用性。出于显而易见的原因，您不应该在同一个节点上拥有一个pod的所有副本。</p><p id="7a02" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">高可用性不是一个绝对的概念；你永远不可能100%高可用。如果所有节点同时停止运行，您的应用程序如何可用？</p><p id="0623" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">因此，您通常需要选择一个您满意的可用性级别。例如，如果您在三个独立的可用性区域中运行三个节点，您可以选择对单个节点故障进行恢复。失去两个节点可能会使您的应用程序停止运行，但是在不同的可用性区域失去两个数据中心的可能性很低。</p><blockquote class="ly lz ma"><p id="d83e" class="la lb mb lc b ld mc lf lg lh md lj lk me mf ln lo mg mh lr ls mi mj lv lw lx ij bi translated">底线是没有通用的方法；只有你能知道什么对你的企业有效，以及你认为可接受的风险水平。</p></blockquote><h1 id="7c88" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">当平衡成为一个问题时</h1><p id="b291" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">让我们来看一个场景，其中调度可能危及可用性。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/17f1d7e04f54543ceb2388beb79520d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8t5Y9IZ5FUWOyJwxxDYtdw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">理想调度</figcaption></figure><p id="b385" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">假设我们从一个理想的调度状态开始。我们有四个服务<code class="fe mk ml mm mn b">A</code>、<code class="fe mk ml mm mn b">B</code>、<code class="fe mk ml mm mn b">C</code>和<code class="fe mk ml mm mn b">D</code>，每个都可以运行三个副本。</p><p id="3859" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">如果节点3发生故障，主节点将会注意到我们只有两个服务单元。主节点将立即在剩余的健康节点上重新调度其中一个。这可能会导致:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/f14dcbb242f023c4111209e2fca2dade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQrtKrgHXA0FJXi7aVWiRQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">节点3失效，其余节点分担负载</figcaption></figure><p id="0a52" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">一段时间后(通常是几分钟)，您的云提供商将注意到一个节点关闭，并将旋转另一个节点。当该节点准备就绪时，我们最终会得到这样一个群集:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/93c0e5cf7aa6fc787f03e75643b983b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqV1Zs5pli_JUd-Wv0GyTw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">不平衡的集群</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/33a784ee90aec8f2e025616aaa9c617c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*EocdAdivYr5TQE5UcZ-0IA.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这里没什么要补充的</figcaption></figure><p id="1ebc" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">群集是不平衡的，但是可用性没有丧失，但是…如果我们失去任何节点，我们仍然有每个pod的至少一个副本在运行。</p><p id="8019" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">然而，让我们看看当我们通过发布新版本的服务<code class="fe mk ml mm mn b">A</code>开始请求调度程序时会发生什么。这通常通过<strong class="lc ir">滚动部署</strong>来完成。</p><p id="d674" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">Kubernetes将启动一个新的pod进行服务<code class="fe mk ml mm mn b">A</code>，等待pod准备好，并杀死一个旧的pod。它继续这样做，直到所有的旧荚已被取代。</p><p id="cd7a" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">因此，调度程序被要求放置一个新的<code class="fe mk ml mm mn b">A v2</code>pod——唯一可以这样做的地方是节点3。到目前为止一切顺利。但是，它应该把另外两个放在哪里呢？如上所述，调度器试图避免在同一节点上有重复，但是在这种情况下，与其他节点相比，节点3被严重利用不足。因此，所有新的<code class="fe mk ml mm mn b">A v2</code>pod都将被安排在节点3上的可能性<strong class="lc ir">很高</strong>，这将导致这种情况:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/2f7649050ec78a225693f1cb74ade994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9N2h2H2iqlxqsY0bBVoTtg.jpeg"/></div></div></figure><p id="b804" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">现在我们有一个问题:所有的<code class="fe mk ml mm mn b">A</code>吊舱都在一个节点上。如果节点3再次发生故障，我们将失去服务<code class="fe mk ml mm mn b">A</code>的可用性。</p><p id="4138" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">整个过程用这张宏伟的GIF来描述:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/3f9f87f5859129bf30586d95951d4df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*_7xi3zeFWAveLXEXhdmxow.gif"/></div></figure><h1 id="c889" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">取消调度程序</h1><p id="3ca9" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">恢复秩序的一个方法是做一点混乱工程。调度程序只能在创建pod时修复平衡问题。所以让我们用杀戮来强迫创造新的豆荚吧！</p><p id="a551" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">进入<a class="ae my" href="https://github.com/kubernetes-incubator/descheduler" rel="noopener ugc nofollow" target="_blank">解调度器</a>。这个项目作为Kubernetes <a class="ae my" href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" rel="noopener ugc nofollow" target="_blank">作业</a>运行，目的是当它认为集群不平衡时杀死pod。您可以运行它一次，或者作为<a class="ae my" href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" rel="noopener ugc nofollow" target="_blank"> Cron作业</a>定期运行它。</p><p id="3c63" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">安装非常简单，在GitHub页面上有很好的解释。</p><p id="294d" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">您可以使用多种策略来删除pod，这些策略在<a class="ae my" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" rel="noopener ugc nofollow" target="_blank">配置图</a>中定义。我们来回顾其中的两个。</p><pre class="mp mq mr ms gt mz mn na nb aw nc bi"><span id="5c5d" class="nd kd iq mn b gy ne nf l ng nh">apiVersion: "descheduler/v1alpha1"<br/>kind: "DeschedulerPolicy"<br/>strategies:<br/>  "RemoveDuplicates":<br/>     enabled: false</span></pre><p id="7b1c" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">使用<code class="fe mk ml mm mn b">RemoveDuplicates</code>策略，解调度器将在一个节点上找到相同的pod。然后它会杀死其中的一些，希望调度程序会将pod调度到另一个节点上。</p><p id="92c5" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">请注意，它不适用于上面概述的场景。这是因为我们还没有解决工作负载平衡的问题。</p><p id="f8ee" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">然而,<code class="fe mk ml mm mn b">LowNodeUtilization</code>策略对此有所帮助:</p><pre class="mp mq mr ms gt mz mn na nb aw nc bi"><span id="2be1" class="nd kd iq mn b gy ne nf l ng nh">apiVersion: "descheduler/v1alpha1"<br/>kind: "DeschedulerPolicy"<br/>strategies:<br/>  "LowNodeUtilization":<br/>     enabled: true<br/>     params:<br/>       nodeResourceUtilizationThresholds:<br/>         thresholds:<br/>           "cpu" : 20<br/>           "memory": 20<br/>           "pods": 20<br/>         targetThresholds:<br/>           "cpu" : 50<br/>           "memory": 50<br/>           "pods": 50</span></pre><p id="ebb0" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">您必须定义节点利用不足和过度利用的含义。在本例中，如果一个节点的CPU利用率<strong class="lc ir">低于20%,内存利用率</strong>低于20%<strong class="lc ir">并且</strong>的pod少于20个，则认为<strong class="lc ir">未充分利用</strong>。如果某个节点的CPU利用率超过50%<strong class="lc ir">或内存利用率超过50%<strong class="lc ir">或</strong>超过50个pod，则认为<strong class="lc ir">过度利用</strong>。</strong></p><p id="ff6f" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">为了使该策略起作用，解调度器将需要找到至少一个未充分利用的节点和一个过度利用的节点。</p><p id="1525" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">和往常一样，没有放之四海而皆准的通用利用率参数。你需要调整它们，找出最适合你的。</p><p id="408d" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">如果你真的对自己的可用性有信心，你可以每小时运行一次这个任务。否则，您可以在夜间运行，此时对交通的影响较小。在后一种情况下，连续运行几次可能会很有用。例如，您可以在每天凌晨3点、3点15分和3点30分运行它。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="913a" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">总之，请记住，如果不进行积极的测试，高可用性是不可能实现的。如果您不终止节点并测试灾难场景，您的系统<strong class="lc ir">将会经历停机</strong>。</p><p id="beef" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">保持集群的平衡并不能保证高可用性，但肯定有助于实现这一目标。</p><p id="aac4" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">如果有必要，您还可以尝试高级的日程安排技术。你可以在这里和这里找到关于这个<a class="ae my" href="https://kubernetes.io/blog/2017/03/advanced-scheduling-in-kubernetes/" rel="noopener ugc nofollow" target="_blank">和</a><a class="ae my" href="https://thenewstack.io/implementing-advanced-scheduling-techniques-with-kubernetes/" rel="noopener ugc nofollow" target="_blank">的信息。也值得看一看</a><a class="ae my" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity" rel="noopener ugc nofollow" target="_blank"> pod亲和反亲和</a>。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="be80" class="pw-post-body-paragraph la lb iq lc b ld mc lf lg lh md lj lk ll mf ln lo lp mh lr ls lt mj lv lw lx ij bi translated">https://twitter.com/cesarTronLoza我</p></div></div>    
</body>
</html>