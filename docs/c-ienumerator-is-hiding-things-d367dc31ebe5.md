# C# IEnumerator 隐藏了一些东西

> 原文：<https://itnext.io/c-ienumerator-is-hiding-things-d367dc31ebe5?source=collection_archive---------6----------------------->

![](img/630897243c0deeae4998eba4f0d9c847.png)

今天，一个同事在序列化我们的遗留应用程序的一个相当复杂的部分，做得有点过火，让序列化程序进入了未知的领域。这个应用程序在一个老式的 *IEnumerator* 实现上出现了一个不错的 *StackOverflowException* 崩溃。

崩溃发生在当前*的*实现上，看起来像这样:

发生了什么是非常明显的，最初的开发者认为它会调用当前属性的另一个实现，但是它实际上递归地调用了自己，直到栈满并且应用崩溃。通过将显式实现转移到返回*对象*的 *Current* 并保持代码的其余部分不变，这很容易纠正。

代码现在没有 bug 了(至少是那部分)，一切都很好……除了……所有这些让我思考。我们到底是怎么陷入这种境地的，这个*枚举器*在代码的某个部分经常被使用，这个应用程序又是如何不崩溃的。更重要的是，*当前*属性的每个版本何时被调用，为什么。

# 非泛型 IEnumerator 和泛型 IEnumerator

IEnumerator 和它的通用对应物 *IEnumerator < T >* 是相当老的接口，一个从那时就存在了。Net 1，其他自。Net 2(随着泛型的到来)。泛型继承了非泛型， *IEnumerator* 仍然在这里可能主要是因为兼容性的原因。这是他们的定义。

它们非常简单，不言自明。唯一有趣的是，它们都有一个名为 *Current* 的只读属性，但返回类型不同。C#不允许你通过改变返回类型来覆盖一个方法，所以…这怎么可能呢？

有可能是因为在那种情况下，不是覆盖，是*隐藏*。如果你查看类属 *IEnumerator* 中定义的*当前*，你会看到*新*关键字。以下是 [C#参考](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/new-modifier)对*新*修改器的看法。

> 当用作声明修饰符时，`new`关键字显式隐藏从基类继承的成员。隐藏继承的成员时，该成员的派生版本将替换基类版本。尽管不使用`new`修饰符也可以隐藏成员，但是会得到一个编译器警告。如果您使用`new`来显式隐藏一个成员，它会取消这个警告。

它实际上意味着什么？隐藏和覆盖有什么不同？我们来试一个小例子。

## 遗产

如果您运行这个示例，您显然会得到一个“汪汪”的输出。它是面向对象编程的基础。不管你的*狗*藏在*动物*变量里面，它还是一只狗，它会叫。

## 隐藏

现在，更令人困惑的是隐藏在*中的新*关键词。

现在，基于**变量类型**，输出是不同的。即使我们的对象仍然是一只狗，如果它所在的变量是一只*动物*，那么调用*动物*实现的*呼*方法。当它在 *Dog* 变量中时，使用的是 *Dog* 实现，因为它隐藏了*动物*one……哎哟。需要把握的一点是，我们使用**隐藏**是有原因的，在一个*狗*的对象中，**既有** *喊*的方法存在！你实际上可以通过在前面加上动物类名来访问它。

不言而喻，这是令人难以置信的混乱，应该非常谨慎地使用，你应该有一个非常好的理由这样做，比如对于 *IEnumerator < T >* 接口。

# 实现通用 IEnumerator

回到我们的 *IEnumerator…* 当我们实际实现 *IEnumerator < T >* 接口时会发生什么？

从 *IEnumerator 开始。当前*属性仅 ***隐藏****IEnumerator<T>。当前*属性，两者都存在。这意味着要实现这两个接口(因为泛型继承自非泛型，所以是强制性的)，我们需要实现*当前*属性的**两个版本**，一个具有返回类型*对象*，一个具有 *T* 。

为此，我们需要使用[显式接口实现](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation)。通过在属性名之前添加接口名，我们可以定义一个实现 *IEnumerator* 接口的属性和另一个实现 *IEnumerator < T >* 接口的属性。

在这个例子中，你可以看到我已经实现了三个版本的*当前*属性。第一个没有实现接口，它只属于 *ConfusingEnumerator* 类，如果你有一个 *ConfusingEnumerator* 类型的变量，它是唯一可用的。

第二个显式实现了*IEnumerator<string>*接口，第三个显式实现了 *IEnumerator* 接口。显式实现不能是公共的。它们仅通过接口可见。

正如您在执行结果中看到的，根据对象所在的变量类型，调用不同的实现。这使我们能够回答两个接口。

尽管您可以看到“same”*Current*属性可能有三种不同的实现，但这可能不是该接口的预期用途，泛型版本中的 new 关键字是为了避免无法用不同的返回类型覆盖。

“标准”实现是隐式实现泛型 *Current* 属性，显式实现非泛型，简单地调用隐式属性，就像这样。

# 结论

我希望我能使接口的隐藏和显式实现的概念不那么混乱，并能解释泛型 *IEnumerator 的奇怪情况。*

到目前为止，这不是唯一一个继承了。Net 框架，并且很容易错误地实现它们。

请随意添加备注或提问。