<html>
<head>
<title>Angular tutorial — Create loading indicator using NgRx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度教程-使用NgRx创建负载指示器</h1>
<blockquote>原文：<a href="https://itnext.io/angular-tutorial-create-loading-indicator-using-ngrx-687f8a66be0d?source=collection_archive---------0-----------------------#2018-09-16">https://itnext.io/angular-tutorial-create-loading-indicator-using-ngrx-687f8a66be0d?source=collection_archive---------0-----------------------#2018-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/188f925ed64a2b8cf8fb6b7faff64913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGPVzLR0e3mniO95IPvfWg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:<a class="ae kc" href="https://playtech.ro/2017/cele-mai-mari-turbine-eoliene-iti-alimenteaza-casa-dintr-o-singura-rotatie/" rel="noopener ugc nofollow" target="_blank">https://playtech . ro/2017/Cele-mai-mari-turbine-EO liene-iti-alimente aza-casa-dintr-o-singura-rotatie/</a></figcaption></figure><p id="b40d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如今，大多数应用程序执行异步请求来加载数据，所以就用户界面体验而言，向用户提供反馈是很重要的。<br/>在本文中，我将向您展示一个使用NgRx和Angular的解决方案，基于分派给商店的操作来切换装载指示器的显示。</p><p id="4c41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用redux显示负载指示器有许多不同的方法，一种常见的方法是在redux上使用一个简单的布尔值，但是当应用程序增长时，就很难管理它了。我们可以利用@ngrx/effects模块来创建一个更通用的解决方案。<br/>那么，我们开始吧！</p><h1 id="2a5d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">动作装饰师</h1><p id="4dc6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在为我们的加载指示器创建动作、减少器和效果之前，让我们看一下用于NgRx动作的两个装饰器，它们应该显示一个加载指示器。</p><p id="1513" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">decorator将向action类添加一个新的布尔属性，以便知道这个动作应该显示一个加载微调器。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9e7b" class="mq lc iq mh b gy mr ms l mt mu"><strong class="mh ir">export function </strong><em class="mv">ShowLoader</em>() {<br/>    <strong class="mh ir">return function </strong>(Class: <strong class="mh ir"><em class="mv">Function</em></strong>) {<br/>        <strong class="mh ir"><em class="mv">Object</em></strong>.defineProperty(Class.<strong class="mh ir">prototype</strong>,<strong class="mh ir">'showLoader'</strong>, {<br/>            <strong class="mh ir">value</strong>: <strong class="mh ir">true<br/>        </strong>});<br/>    }<br/>}</span></pre><p id="a181" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">HideLoader</code> decorator将向名为<code class="fe me mf mg mh b">triggerAction</code>的动作类添加一个新的字符串属性，该属性将用于加载指示器缩减器，以解决当两个相同的动作被触发但响应只针对最后一个动作时出现的问题。为了避免无限加载微调器，我们将使用此属性进行一些检查。我们稍后将讨论这个问题。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e619" class="mq lc iq mh b gy mr ms l mt mu"><strong class="mh ir">export function </strong><em class="mv">HideLoader</em>(triggerAction: <strong class="mh ir">string</strong>) {<br/>    <strong class="mh ir">return function </strong>(Class: <strong class="mh ir"><em class="mv">Function</em></strong>) {<br/>        <strong class="mh ir"><em class="mv">Object</em></strong>.defineProperty(Class.<strong class="mh ir">prototype</strong>, <strong class="mh ir">'triggerAction'</strong>, {<br/>            <strong class="mh ir">value</strong>: triggerAction<br/>        });<br/>    }<br/>}</span></pre><p id="788f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些装饰器可以像下面的例子一样使用:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c9c9" class="mq lc iq mh b gy mr ms l mt mu">import { Action } from '@ngrx/store';<br/>import { ShowLoader, HideLoader } from '../../shared/decorators';</span><span id="a707" class="mq lc iq mh b gy mw ms l mt mu">export const GET_ARTICLES = '[Article] Get Articles';<br/>export const GET_ARTICLES_SUCCESS = '[Article] Get Articles success';<br/>export const GET_ARTICLES_FAILURE = '[Article] Get Articles <br/>failure';</span><span id="f606" class="mq lc iq mh b gy mw ms l mt mu">@ShowLoader()<br/>export class GetArticles implements Action {<br/>  readonly type = GET_ARTICLES;<br/>}</span><span id="09db" class="mq lc iq mh b gy mw ms l mt mu">@HideLoader(<!-- -->GET_ARTICLES<!-- -->)<br/>export class GetArticlesSuccess implements Action {<br/>  readonly type = GET_ARTICLES_SUCCESS;<br/>  constructor(public payload?:any) {}<br/>}</span><span id="fa33" class="mq lc iq mh b gy mw ms l mt mu">@HideLoader(<!-- -->GET_ARTICLES<!-- -->)<br/>export class GetArticlesFailure implements Action {<br/>  readonly type = GET_ARTICLES_FAILURE;<br/>  constructor(public payload?:any) {}<br/>}</span><span id="19d5" class="mq lc iq mh b gy mw ms l mt mu">export type ArticleAction = GetArticles | GetArticlesSuccess | GetArticlesFailure;</span></pre><h1 id="25ab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">装载指示器—动作</h1><p id="e0ff" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们创建两个动作来显示和隐藏我们的装载指示器:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7de3" class="mq lc iq mh b gy mr ms l mt mu">import { Action } from "@ngrx/store";<br/><br/>export const SHOW_SPINNER = '[UI] Show loading spinner';<br/>export const HIDE_SPINNER = '[UI] Hide loading spinner';</span><span id="9aab" class="mq lc iq mh b gy mw ms l mt mu">export class ShowSpinner implements Action {<br/>  readonly type = SHOW_SPINNER;</span><span id="e3f5" class="mq lc iq mh b gy mw ms l mt mu">  constructor(payload?: any) {}</span><span id="8c8c" class="mq lc iq mh b gy mw ms l mt mu">}</span><span id="03a0" class="mq lc iq mh b gy mw ms l mt mu">export class HideSpinner implements Action {<br/>  readonly type = HIDE_SPINNER;</span><span id="3b2c" class="mq lc iq mh b gy mw ms l mt mu">  constructor(payload?: any) {}</span><span id="f6ee" class="mq lc iq mh b gy mw ms l mt mu">}<br/><br/>export type SpinnerAction = ShowSpinner | HideSpinner;</span></pre><h1 id="8fa9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">减速器</strong></h1><p id="bd97" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">接下来，我们将定义一个<code class="fe me mf mg mh b">reducer</code>来改变加载指示器的状态。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fd4f" class="mq lc iq mh b gy mr ms l mt mu">import * as loadingSpinner from '../actions/loading-spinner'; </span><span id="a587" class="mq lc iq mh b gy mw ms l mt mu">export interface State {  <br/>  active: number;  <br/>  actionsInProgress: any[];<br/>}</span><span id="136b" class="mq lc iq mh b gy mw ms l mt mu">const initialState: State = {  <br/>  active: 0,  <br/>  actionsInProgress: []<br/>}</span><span id="d443" class="mq lc iq mh b gy mw ms l mt mu">export function reducer(<br/>  state = initialState, <br/>  action: any): State {</span><span id="10c1" class="mq lc iq mh b gy mw ms l mt mu">   switch(action.type) {</span><span id="8d75" class="mq lc iq mh b gy mw ms l mt mu">case loadingSpinner.SHOW_SPINNER: {<br/>   <br/>        const isActionAlreadyInProgress = state.actionsInProgress<br/>             .filter((currentAction: any) =&gt; <br/>                currentAction === action.payload.type)<br/>             .length;</span><span id="3387" class="mq lc iq mh b gy mw ms l mt mu">         <strong class="mh ir">// If the action in already in progress and is registered<br/>         // we don't modify the state</strong></span><span id="0ec1" class="mq lc iq mh b gy mw ms l mt mu">        if(isActionAlreadyInProgress) {<br/>          return state;<br/>        }</span><span id="55c0" class="mq lc iq mh b gy mw ms l mt mu"><strong class="mh ir">        // Adding the action type in our actionsInProgress array</strong></span><span id="0208" class="mq lc iq mh b gy mw ms l mt mu">        const newActionsInProgress = [<br/>              ...state.actionsInProgress, <br/>              action.payload.type<br/>        ];</span><span id="6327" class="mq lc iq mh b gy mw ms l mt mu">        return Object.assign(state, {     <br/>            active: newActionsInProgress.length, <br/>            actionsInProgress: newActionsInProgress                 <br/>        });<br/>     }</span><span id="916f" class="mq lc iq mh b gy mw ms l mt mu">case loadingSpinner.HIDE_SPINNER: {</span><span id="7076" class="mq lc iq mh b gy mw ms l mt mu"><strong class="mh ir">      // We remove trigger action from <em class="mv">actionsInProgress</em> array</strong></span><span id="bb92" class="mq lc iq mh b gy mw ms l mt mu">      const <em class="mv">newActionsInProgress </em>= action.payload.triggerAction  ?<br/>              <em class="mv">state</em>.<em class="mv">actionsInProgress<br/>                 </em>.filter((currentAction: any) =&gt; <br/>                   currentAction !== action.payload.triggerAction) :<br/>              <em class="mv">state</em>.<em class="mv">actionsInProgress</em>;<br/><br/>        return Object.assign(state, {<br/>           actionsInProgress: newActionsInProgress,<br/>           active: state.active &gt; 0 ? <br/>                   newActionsInProgress.length : 0<br/>         });<br/>     }</span><span id="c765" class="mq lc iq mh b gy mw ms l mt mu">     default:      <br/>       return state;<br/>   }<br/>}</span><span id="848d" class="mq lc iq mh b gy mw ms l mt mu">export const isLoadingSpinnerActive = <br/>                (state: State) =&gt; state.active;</span></pre><p id="94f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们回顾一下我们的减速器，以了解这里发生了什么:</p><ul class=""><li id="327c" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated">我们的状态包含两个属性:<br/> <code class="fe me mf mg mh b">active</code> —这是正在进行的动作的数量。<code class="fe me mf mg mh b">active &gt; 0</code>表示我们可以显示我们的装载指示器。<br/> <code class="fe me mf mg mh b">actionsInProgress</code> —这是保存所有应该显示加载指示器的动作的数组。</li></ul><p id="b45e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> ShowSpinner </strong>和<strong class="kf ir"> HideSpinner </strong>动作的有效负载将是另一个类似<code class="fe me mf mg mh b">ShowArticles, ShowArticlesSuccess, ShowArticlesFailure.<br/></code>的动作，因此，我们可以访问由我们的decorator(<code class="fe me mf mg mh b">triggerAction</code>)添加的属性来检查我们是否应该改变状态。</p><h1 id="2408" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">选择器</h1><p id="0b6b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要从缩减器中访问<code class="fe me mf mg mh b">active</code>值，我们需要为此创建一个选择器。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="78d8" class="mq lc iq mh b gy mr ms l mt mu">import { createSelector, createFeatureSelector } from "@ngrx/store";</span><span id="def6" class="mq lc iq mh b gy mw ms l mt mu">import * as fromSpinner from './reducers/loading-spinner';</span><span id="6bee" class="mq lc iq mh b gy mw ms l mt mu">export interface State {<br/>  loading: fromSpinner.State<br/>}</span><span id="a2c9" class="mq lc iq mh b gy mw ms l mt mu">export const reducers = {<br/>  loading: fromSpinner.reducer<br/>}</span><span id="2c36" class="mq lc iq mh b gy mw ms l mt mu">export const getLoadingState = (state: State) =&gt; state.loading;</span><span id="fa9c" class="mq lc iq mh b gy mw ms l mt mu">export const isLoadingSpinnerActive = createSelector(<br/>getLoadingState,<br/>fromSpinner.isLoadingSpinnerActive<br/>);</span></pre><h1 id="5297" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">效果</h1><p id="998f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一旦我们创建了我们的动作和reducer，我们就可以实现触发<code class="fe me mf mg mh b">ShowSpinner</code>和<code class="fe me mf mg mh b">HideSpinner</code>动作的效果服务了。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f766" class="mq lc iq mh b gy mr ms l mt mu">import {Injectable} from "@angular/core";<br/>import {Actions, Effect} from "@ngrx/effects";<br/>import {filter, map} from "rxjs/operators";</span><span id="f7f6" class="mq lc iq mh b gy mw ms l mt mu">@Injectable()<br/>export class LoadingIndicatorEffects {<br/>    constructor(private actions$: Actions) {}<br/><br/>  @Effect()<br/>  showLoader$ = this.actions$.pipe(<br/>    <em class="mv">filter</em>((action: any) =&gt; action &amp;&amp; action.displayLoader ? <br/>          action : null),<br/>    <em class="mv">map</em>((action: any) =&gt; new ShowSpinner(action))<br/>  );<br/><br/>  @Effect()<br/>  hideLoader$ = this.actions$.pipe(<br/>    <em class="mv">filter</em>((action: any) =&gt; action &amp;&amp; action.triggerAction ? <br/>          action : null),<br/>    <em class="mv">map</em>((action: any) =&gt; new HideSpinner(action))<br/>  );<br/>}</span></pre><p id="856c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">showLoader$</code>将检查所有动作，如果动作包含<code class="fe me mf mg mh b">displayLoader</code>属性，将触发<strong class="kf ir"> ShowSpinner </strong>。</p><p id="daff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果动作包含<code class="fe me mf mg mh b">triggerAction</code>属性，<code class="fe me mf mg mh b">hideLoader$</code>将触发<strong class="kf ir"> HideSpinner </strong>。</p><h1 id="186f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">模板</h1><p id="eed7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在，您可以创建一个订阅<code class="fe me mf mg mh b">isLoadingSpinnerActive</code>选择器的加载组件，并在用户界面中以可视动画的形式显示它。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6e39" class="mq lc iq mh b gy mr ms l mt mu">export class LoadingComponent implements OnInit {<br/>  isLoading: Observable&lt;boolean&gt;;<br/><br/>  constructor(private store: Store&lt;AppState&gt;) {}<br/><br/>  ngOnInit() {<br/>    this.isLoading = this.store.pipe(<br/>        select(isLoadingSpinnerActive)<br/>    );<br/>  }<br/>}</span></pre><p id="1a7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是加载组件模板的片段:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0c2f" class="mq lc iq mh b gy mr ms l mt mu">&lt;ng-content *ngIf="!(isLoading | async); else spinner"&gt;&lt;/ng-content&gt;<br/>&lt;ng-template #spinner&gt;<br/>  &lt;!-- YOUR ANIMATION / SPINNER HERE --&gt;<br/>&lt;/ng-template&gt; </span></pre><h1 id="7fab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="cba1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在本文中，我利用@ngrx/effects解决了全局显示加载指示器的任务，它对我有效。但这不是唯一的解决方案，<a class="ae kc" href="http://gavinschulz.com/posts/2017-03-22-4-techniques-for-loading-states-in-redux.html" rel="noopener ugc nofollow" target="_blank">这里</a>描述了另一种可以考虑的技术。</p><h1 id="d508" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">演示</h1><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>