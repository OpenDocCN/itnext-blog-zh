<html>
<head>
<title>Spread &amp; Rest Parameters: JavaScript ES6 Feature Series (Pt 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spread &amp; Rest参数:JavaScript ES6特性系列(第4部分)</h1>
<blockquote>原文：<a href="https://itnext.io/spread-rest-parameters-javascript-es6-feature-series-pt-4-c9e9f0c0228f?source=collection_archive---------2-----------------------#2019-09-01">https://itnext.io/spread-rest-parameters-javascript-es6-feature-series-pt-4-c9e9f0c0228f?source=collection_archive---------2-----------------------#2019-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="2a98" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">语法太好了，ES6用了两次</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/cf81030f5bebfb47f5a4a0f8e014249f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNCE2qw8mumz_mhA5LSvnw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@firmbee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">威廉·艾文</a>在<a class="ae le" href="https://unsplash.com/search/photos/learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="7dac" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="a5e3" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi md translated">这些帖子背后的灵感很简单:对于很多开发人员来说，JavaScript没有任何意义——因为它的异步行为和解释语言等等。</p><p id="5329" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">再加上ECMAScript委员会发布的年度更新，有很多信息需要及时了解。🤯看看维基百科下面的统计数据。</p><blockquote class="mr ms mt"><p id="8f33" class="lf lg mu lh b li mm lk ll lm mn lo lp mv mo ls lt mw mp lw lx mx mq ma mb mc im bi translated">截至2017年5月，1000万个最受欢迎的网页中有94.5%使用了JavaScript。— JavaScript，维基百科</p></blockquote><p id="ffda" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">由于JS对web的贡献如此之大，我想提供一些我经常使用的ES6+特性的文章和例子，供其他开发人员参考。</p><p id="066a" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">我们的目标是让这些文章简短、深入地解释该语言的各种改进，我希望这些文章能启发您使用JS编写一些真正酷的东西。谁知道呢，在这个过程中你可能会学到一些新东西。😄</p><blockquote class="my"><p id="4d12" class="mz na it bd nb nc nd ne nf ng nh mc dk translated">在我的第四篇文章中，我将讨论rest参数和spread语法:轻松压缩或扩展参数、元素和对象值的最简洁的方法。</p></blockquote><h1 id="5126" class="jq jr it bd js jt ju jv jw jx jy jz ka kb nj kd ke kf nk kh ki kj nl kl km kn bi translated">…休息参数</h1><p id="26f5" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在深入研究rest参数之前，我建议您熟悉JavaScript中目前使用的三种主要函数类型:函数声明、函数表达式和箭头函数。为了快速复习，我写了一篇关于他们的博文。</p><p id="55d8" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">现在我们在同一页上，让我们进入到底什么是rest参数。</p><p id="5071" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> Rest参数</a>是一种新的语法，它允许我们将传递给函数的不定数量的参数表示为数组。有道理吗？不完全是？🤔没问题，代码示例通常也能帮助我更容易地理解概念。</p><h2 id="18a7" class="nm jr it bd js nn no dn jw np nq dp ka lq nr ns ke lu nt nu ki ly nv nw km nx bi translated">解析函数声明中的Rest参数</h2><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="a6d1" class="nm jr it nz b gy od oe l of og">function f (x, y, ...a) {<br/>  return (x + y) * a.length;<br/>}</span><span id="5da8" class="nm jr it nz b gy oh oe l of og">console.log(f( 1, 2, “hello”, true, 7)) // prints: 9</span></pre><p id="8972" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">当你看上面的例子时，除了最后一个参数声明的，参数<code class="fe oi oj ok nz b">a</code>前面有一个可疑的<code class="fe oi oj ok nz b">...</code>，其他的都和普通的函数声明<em class="mu">一样。这是一个rest参数的例子。</em></p><p id="d342" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">这意味着当函数执行时，“将传递给该函数的所有剩余参数都放入一个数组中，并按照函数体在其语句体中的指示来处理它们。”</p><p id="d789" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">这是另一个例子，但是这次使用了一个箭头函数(也很容易转换成非ES6语法中的函数表达式)。</p><h2 id="a67f" class="nm jr it bd js nn no dn jw np nq dp ka lq nr ns ke lu nt nu ki ly nv nw km nx bi translated">箭头函数中的其余参数</h2><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="5e84" class="nm jr it nz b gy od oe l of og">const product = (e, f, ...g) =&gt; {<br/>  return e * f + g.length; <br/>}</span><span id="0c51" class="nm jr it nz b gy oh oe l of og">console.log(product(4, 7, 2, 6, 3)); // prints: 31</span></pre><p id="489c" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">现在，您可能对如何使用rest参数有一些疑问，(我知道我肯定有)，所以让我为您列出规则。</p><h1 id="f9e8" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Rest参数规则、特征和用途</h1><h2 id="b7e0" class="nm jr it bd js nn no dn jw np nq dp ka lq nr ns ke lu nt nu ki ly nv nw km nx bi translated">只有最后一个参数可以有…</h2><p id="ce12" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">不，我没有失去我的思路，我说的是:只有函数中定义的最后一个参数，可以加上前缀<code class="fe oi oj ok nz b">...</code>，使它成为一个rest参数。</p><p id="ceaa" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">当最后一个参数以<code class="fe oi oj ok nz b">...</code>为前缀时，所有剩余的(用户提供的)参数都放在一个“标准”Javascript数组中。</p><p id="80eb" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">输出带有Rest参数的自变量</strong></p><p id="bd5a" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">这是当您将rest参数作为函数调用中的最后一个参数时，您将看到的输出。如您所见，传递给<code class="fe oi oj ok nz b">myNumberFunction</code>、<code class="fe oi oj ok nz b">1</code>、<code class="fe oi oj ok nz b">2</code>和<code class="fe oi oj ok nz b">3</code>的前三个参数被单独打印出来，作为函数中定义的前三个参数:<code class="fe oi oj ok nz b">a</code>、<code class="fe oi oj ok nz b">b</code>和<code class="fe oi oj ok nz b">c</code>。然而，传递给rest参数<code class="fe oi oj ok nz b">d</code>的所有剩余数字都作为数组<code class="fe oi oj ok nz b">[4, 5, 6, 7, 8]</code>打印出来。</p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="e310" class="nm jr it nz b gy od oe l of og">function myNumberFunction(a, b, c, ...d) {<br/>  console.log("a", a);  // a 1<br/>  console.log("b", b); // b 2<br/>  console.log("c", c); // c 3<br/>  console.log("...d", d); //...d [ 4, 5, 6, 7, 8]<br/>}</span><span id="18cf" class="nm jr it nz b gy oh oe l of og">myNumberFunction(1, 2, 3, 4, 5, 6, 7, 8);</span></pre><h2 id="7be3" class="nm jr it bd js nn no dn jw np nq dp ka lq nr ns ke lu nt nu ki ly nv nw km nx bi translated">Rest参数不仅仅是Arguments对象</h2><p id="25f8" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在<code class="fe oi oj ok nz b">arguments</code>对象和新的rest参数之间有三个主要区别需要了解。</p><ul class=""><li id="c5a7" class="ol om it lh b li mm lm mn lq on lu oo ly op mc oq or os ot bi translated">rest参数只是那些没有被单独命名的参数(即在函数表达式中正式定义的)，而<code class="fe oi oj ok nz b">arguments</code>对象包含传递给函数的所有参数。</li><li id="be62" class="ol om it lh b li ou lm ov lq ow lu ox ly oy mc oq or os ot bi translated"><code class="fe oi oj ok nz b">arguments</code>对象不是一个真正的数组，其余的参数都是<code class="fe oi oj ok nz b">Array</code>实例，也就是说<code class="fe oi oj ok nz b">sort()</code>、<code class="fe oi oj ok nz b">map()</code>、<code class="fe oi oj ok nz b">forEach()</code>或<code class="fe oi oj ok nz b">pop()</code>等方法可以直接应用在上面。</li><li id="1db3" class="ol om it lh b li ou lm ov lq ow lu ox ly oy mc oq or os ot bi translated"><code class="fe oi oj ok nz b">arguments</code>对象具有特定于自身的附加功能(如<code class="fe oi oj ok nz b">callee</code>属性)。</li></ul><p id="e970" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">最初引入Rest参数是为了减少由<code class="fe oi oj ok nz b">arguments</code>引起的样板代码。之前，将<code class="fe oi oj ok nz b">arguments</code>转换为“普通数组”是一大痛苦。现在，它们可以被简单地传入，然后被执行。</p><p id="2194" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">对其余参数数组的简单操作</strong></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="a60d" class="nm jr it nz b gy od oe l of og">function doubleUp(...simpleArgs){<br/>  const arr = simpleArgs;<br/>  const secondArr = arr.map(num =&gt; num * 2);<br/>  return secondArr;<br/>}</span><span id="69ac" class="nm jr it nz b gy oh oe l of og">console.log(doubleUp(2, 6, 12, 18)); // [ 4, 12, 24, 36 ]</span></pre><h2 id="0137" class="nm jr it bd js nn no dn jw np nq dp ka lq nr ns ke lu nt nu ki ly nv nw km nx bi translated">Rest参数可以被析构</h2><p id="e318" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">关于ES6，我最喜欢的新东西之一是数组和对象析构。我还没有详细介绍析构，但是在这一系列文章结束之前，我会介绍的。</p><p id="e9c7" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">简而言之，析构使得将数组中的值或对象中的属性解包到不同的变量中成为可能。如果你同时渴望了解更多，这里有一个<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">链接</a>让你更熟悉析构是如何工作的。</p><p id="ec98" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">继续讨论这篇文章的目的，这里是rest参数和析构在起作用。</p><p id="d88d" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">用Rest参数析构数组</strong></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="45ac" class="nm jr it nz b gy od oe l of og">const [captain, coCaptain, ...devs] = [ “Bridget”, “Joe”, “Kyle”, “Drew”, “Patrick”, “Francisco”];</span><span id="2f46" class="nm jr it nz b gy oh oe l of og">console.log(captain); // ‘Bridget’<br/>console.log(coCaptain); // ‘Joe’<br/>console.log(devs); // [ ‘Kyle’, ‘Drew’, ‘Patrick’, ‘Francisco’ ]</span></pre><p id="de1f" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">在上面声明的变量数组<code class="fe oi oj ok nz b">captain</code>、<code class="fe oi oj ok nz b">coCaptain</code>、<code class="fe oi oj ok nz b">devs</code>中，其余的参数应用于<code class="fe oi oj ok nz b">devs</code>，所以当数组名传入时，<code class="fe oi oj ok nz b">'Bridget'</code>变成了<code class="fe oi oj ok nz b">captain</code>、<code class="fe oi oj ok nz b">'Joe'</code>是<code class="fe oi oj ok nz b">coCaptain</code>、<code class="fe oi oj ok nz b">devs</code>是<code class="fe oi oj ok nz b">[ 'Kyle', 'Drew', 'Patrick', 'Francisco' ]</code>。</p><p id="88e6" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">得心应手，对吧？想象一下您遇到的场景，您要么需要取出数组的各个部分，要么需要将其他部分放在一起。相信我，当你这么做的时候，你会非常感谢析构和休息参数。</p><p id="03e9" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">同样的事情也可以用对象析构来完成。</p><p id="26c7" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">使用剩余参数进行对象析构</strong></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="5932" class="nm jr it nz b gy od oe l of og">const {pm1, pm2, ...restOfTeam} = {<br/>  pm1: "Jeremy",<br/>  pm2: "Tung",<br/>  developer1: "Casey",<br/>  developer2: "Mark",<br/>  ux: "Christina"<br/>};</span><span id="12e8" class="nm jr it nz b gy oh oe l of og">console.log(pm1); // Jeremy<br/>console.log(pm2); // Tung<br/>console.log(restOfTeam); // { developer1: 'Casey', developer2: 'Mark', ux: 'Christina' }</span></pre><p id="2b31" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">本例从对象中的其余团队成员中解构出<code class="fe oi oj ok nz b">pm1</code>和<code class="fe oi oj ok nz b">pm2</code>，其余的对象属性:<code class="fe oi oj ok nz b">developer1</code>、<code class="fe oi oj ok nz b">developer2</code>和<code class="fe oi oj ok nz b">ux</code>被组合在一个名为<code class="fe oi oj ok nz b">restOfTeam</code>的新对象变量中。</p><p id="3b9d" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">再一次，考虑使用这种类型的语法来创建新的变量、对象，将对象属性分成单独的部分，等等。</p><p id="851c" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">这些是您需要了解的关于rest参数的主要内容。至此，我们可以继续讨论JavaScript中<code class="fe oi oj ok nz b">...</code>的另一种用法，即spread语法。</p><h1 id="e10f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">展开语法…</h1><p id="cf04" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">虽然它与rest参数非常相似，但是spread语法有着完全不同的用途。</p><p id="665a" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展语法</a>允许在需要零个或多个参数(用于函数调用)或元素(用于数组文字)的地方扩展一个可迭代对象，或者在需要零个或多个键值对(用于对象文字)的地方扩展一个对象表达式。</p><p id="be89" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">呃…现在怎么办？</p><p id="00b9" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">好吧，这个定义听起来很专业，我知道，相信我。但这在实践中意味着什么:</p><blockquote class="my"><p id="9851" class="mz na it bd nb nc nd ne nf ng nh mc dk translated">如果你有一个字符串、一个数组或一个对象，并且你想使用所有的值，你可以用一个非常简洁的语法把所有的值<em class="ni">分散到函数调用、新数组或新对象中。</em></p></blockquote><h2 id="5e59" class="nm jr it bd js nn oz dn jw np pa dp ka lq pb ns ke lu pc nu ki ly pd nw km nx bi translated">函数、数组、字符串和对象中的展开语法</h2><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="90bb" class="nm jr it nz b gy od oe l of og">// For function calls:<br/>function multiply(x, y, z) {<br/>  return x * y * z;<br/>}<br/>const args = [1, 2, 3];<br/>console.log(multiply(...args)); // 6</span><span id="e493" class="nm jr it nz b gy oh oe l of og">// For array literals or strings:<br/>const iterableObj = [ {protein: "steak"}, {carb: "potato"}, 'milkshake'];<br/>const randomList = [...iterableObj, '4', 'five', 6];<br/>console.log(randomList); // [ { protein: 'steak' }, { carb: 'potato' }, 'milkshake', '4', 'five', 6 ]</span><span id="133e" class="nm jr it nz b gy oh oe l of og">const str = "foo"<br/>const chars = [ ...str ] <br/>console.log(chars); // [ "f", "o", "o" ]</span><span id="0ee6" class="nm jr it nz b gy oh oe l of og">// For object literals (new in ECMAScript 2018):<br/>const powerTool = { skuNumber: ‘996655’, skuDescription: ‘Drill Bit’ };</span><span id="bb81" class="nm jr it nz b gy oh oe l of og">let secondPowerTool = { ...powerTool, toolDepartment: 25, toolClass: 7 };<br/>console.log(secondPowerTool); // { skuNumber: ‘996655’, skuDescription: ‘Drill Bit’, toolDepartment: 25, toolClass: 7 }</span></pre><p id="b6d4" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">上面不同的例子显示了当你分散不同的物品时会发生什么。</p><p id="1464" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">对于第一个例子，即<code class="fe oi oj ok nz b">multiply()</code>函数，我将我的<code class="fe oi oj ok nz b">args</code>数组扩展到函数调用中，该函数调用简单地从数组中取出三个值(<code class="fe oi oj ok nz b">1</code>、<code class="fe oi oj ok nz b">2</code>和<code class="fe oi oj ok nz b">3</code>)，并将它们放在函数接受的参数<code class="fe oi oj ok nz b">x</code>、<code class="fe oi oj ok nz b">y</code>和<code class="fe oi oj ok nz b">z</code>的位置。</p><p id="803e" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">在第二个和第三个例子中，扩展数组和字符串，原始列表<code class="fe oi oj ok nz b">iterableObj</code>和原始字符串<code class="fe oi oj ok nz b">"foo"</code>都被分别扩展到新变量<code class="fe oi oj ok nz b">randomList</code>和<code class="fe oi oj ok nz b">chars</code>中。</p><p id="4331" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><code class="fe oi oj ok nz b">iterableObj</code>中的所有值与专门分配给<code class="fe oi oj ok nz b">randomList</code>的新值一起被添加到新的<code class="fe oi oj ok nz b">randomList</code>数组中。并且原来的字符串<code class="fe oi oj ok nz b">"foo"</code>被一个字符一个字符地分散到新的<code class="fe oi oj ok nz b">chars</code>数组中。</p><p id="84aa" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">最后一个例子，自ECMAScript 2018发布以来唯一可能的，是将对象<code class="fe oi oj ok nz b">powerTool</code>的属性扩展到一个名为<code class="fe oi oj ok nz b">secondPowerTool</code>的新对象中，并向该对象添加两个新属性:<code class="fe oi oj ok nz b">toolDepartment</code>和<code class="fe oi oj ok nz b">toolClass</code>。</p><h1 id="5f14" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">传播语法规则、特征和用途</h1><p id="6576" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">就像rest参数一样，spread语法是一种语法糖，它取代了复杂的方法和充满样板代码的做事方式，而这些应该是相对容易的。</p><p id="6a4d" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">也就是说，你需要知道一些关于传播的事情。</p><h2 id="a7a0" class="nm jr it bd js nn no dn jw np nq dp ka lq nr ns ke lu nt nu ki ly nv nw km nx bi translated">函数调用中的Spread替换Apply</h2><p id="4fd5" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">到目前为止，在您想要使用数组元素作为函数参数的情况下，使用<code class="fe oi oj ok nz b">Function.prototype.apply()</code>是很常见的。</p><p id="0106" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">在函数调用</strong>中使用 <code class="fe oi oj ok nz b"><strong class="lh iu">apply()</strong></code> <strong class="lh iu">给数组元素赋值</strong></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="c94e" class="nm jr it nz b gy od oe l of og">function myFunction(x, y, z) { }<br/>var args = [0, 1, 2];<br/>myFunction.apply(null, args);</span></pre><p id="5eb9" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">有了spread，语法就干净多了。</p><p id="0be4" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">将数组元素列表展开成函数调用</strong></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="667e" class="nm jr it nz b gy od oe l of og">function myFunction(x, y, z) { }<br/>var args = [0, 1, 2];<br/>myFunction(...args);</span></pre><p id="c378" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">还有一件很酷的事情:参数列表中的任何参数都可以使用spread语法，并且可以多次使用。</p><p id="e5c8" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">单个函数调用中的多次扩展</strong></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="4eb1" class="nm jr it nz b gy od oe l of og">function myFunction(v, w, x, y, z) { }<br/>var args = [0, 1];<br/>myFunction(-1, ...args, 2, ...[3]);</span></pre><h2 id="0c5a" class="nm jr it bd js nn no dn jw np nq dp ka lq nr ns ke lu nt nu ki ly nv nw km nx bi translated">扩展语法可以与new关键字一起使用</h2><p id="de94" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">不像使用<code class="fe oi oj ok nz b">new</code>调用构造函数时，不能直接使用数组，而使用<code class="fe oi oj ok nz b">apply</code>，使用<code class="fe oi oj ok nz b">new</code>可以很容易地使用数组。</p><p id="d704" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">展开语法同</strong> <code class="fe oi oj ok nz b"><strong class="lh iu">new</strong></code> <strong class="lh iu">构造函数</strong></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="27a3" class="nm jr it nz b gy od oe l of og">var dateFields = [1989, 3, 13];<br/>var d = new Date(...dateFields);</span><span id="2ad5" class="nm jr it nz b gy oh oe l of og">console.log(d); // 13 Apr 1989</span></pre><h2 id="9756" class="nm jr it bd js nn no dn jw np nq dp ka lq nr ns ke lu nt nu ki ly nv nw km nx bi translated">在数组文字中展开</h2><p id="85ae" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Spread使得数组操作变得更加容易，像<code class="fe oi oj ok nz b">push()</code>、<code class="fe oi oj ok nz b">concat()</code>和<code class="fe oi oj ok nz b">splice()</code>这样的方法也变得不那么必要了。让我们来看看它能帮你做什么。</p><p id="df4b" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">创建新的数组文字很容易</strong></p><p id="f3f1" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">使用现有数组作为其一部分来创建新数组，不需要像过去那样使用额外的数组方法。</p><p id="de64" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">将一个数组扩展到另一个新数组</strong></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="3f9b" class="nm jr it nz b gy od oe l of og">const fruits = ['watermelon', 'peaches'];<br/>const fruitBasket = ['apples', 'grapes', ...fruits, 'bananas', 'kiwis', 'mango'];</span><span id="6dc7" class="nm jr it nz b gy oh oe l of og">console.log(fruitBasket); // [ 'apples', 'grapes', 'watermelon', 'peaches', 'bananas', 'kiwis', 'mango' ]</span></pre><p id="580b" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">将<code class="fe oi oj ok nz b">fruits</code>数组添加到<code class="fe oi oj ok nz b">fruitsBasket</code>有多简单？超级简单。</p><p id="c6ce" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">复制数组也是轻而易举的事情</strong></p><p id="ce25" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">使用spread，将一个数组的值复制到另一个数组是小菜一碟。然后，您可以继续修改新复制的数组，而不会影响原始数组(这非常适合不可变的函数式编程风格，这种风格在React等框架和Redux等状态管理工具中非常流行)。</p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="bd13" class="nm jr it nz b gy od oe l of og">const arr1 = [1, 2, 3];<br/>const arr2 = [...arr1];</span><span id="51ae" class="nm jr it nz b gy oh oe l of og">console.log(arr2); // [1, 2, 3]</span><span id="3871" class="nm jr it nz b gy oh oe l of og">arr2.push(4);</span><span id="905f" class="nm jr it nz b gy oh oe l of og">console.log(arr1); // [1, 2, 3]<br/>console.log(arr2); // [1, 2, 3, 4]</span></pre><p id="2c0b" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">在我把<code class="fe oi oj ok nz b">4</code>推到<code class="fe oi oj ok nz b">arr2</code>之前，当数值打印出来的时候，和<code class="fe oi oj ok nz b">arr1</code>一模一样。同样，即使在<code class="fe oi oj ok nz b">4</code>添加到<code class="fe oi oj ok nz b">arr2</code>之后，<code class="fe oi oj ok nz b">arr1</code>也保持不变。</p><p id="39b4" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">注意:</strong> Spread语法仅在复制数组时才有效。因此，它可能不适合复制多维数组，因为它使用了类似lodash的<a class="ae le" href="https://lodash.com/docs/4.17.15#cloneDeep" rel="noopener ugc nofollow" target="_blank">这样的函数。推荐cloneDeep() </a>。</p><p id="1043" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">串联数组从未如此简单过</strong></p><p id="9f48" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><code class="fe oi oj ok nz b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" rel="noopener ugc nofollow" target="_blank">Array.prototype.concat()</a></code>是将一个数组连接到现有数组末尾时的首选。如果没有扩展语法，这将按如下方式完成:</p><p id="6e1c" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><code class="fe oi oj ok nz b"><strong class="lh iu">.concat()</strong></code> <strong class="lh iu">数组组合在一起</strong></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="510a" class="nm jr it nz b gy od oe l of og">const germanCars = [ 'BMW', 'Audi', 'Mercedes' ];<br/>const japaneseCars = [ 'Honda', 'Toyota', 'Datsun' ];<br/>const concatCarMakers = germanCars.concat(japaneseCars);</span><span id="3ce9" class="nm jr it nz b gy oh oe l of og">console.log(concatCarMakers); // [ 'BMW', 'Audi', 'Mercedes', 'Honda', 'Toyota', 'Datsun' ]</span></pre><p id="be04" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">使用扩展语法，这变成:</p><p id="29d3" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">将阵列分散在一起</strong></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="2f63" class="nm jr it nz b gy od oe l of og">const germanCars = [ 'BMW', 'Audi', 'Mercedes' ];<br/>const japaneseCars = [ 'Honda', 'Toyota', 'Datsun' ];<br/>const carMakers = [...germanCars, ...japaneseCars];</span><span id="c526" class="nm jr it nz b gy oh oe l of og">console.log(carMakers); // [ 'BMW', 'Audi', 'Mercedes', 'Honda', 'Toyota', 'Datsun' ]</span></pre><p id="a51c" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">Spread语法也可以取代<code class="fe oi oj ok nz b">unshift()</code>，使得在数组前面添加新元素比以前简单得多。</p><p id="6977" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">将元素分散到数组的开头</strong></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="9f98" class="nm jr it nz b gy od oe l of og">let numbers = [ 6, 5, 4 ];<br/>const moreNumbers = [ 1, 2, 3 ];<br/>numbers = [...moreNumbers, ...numbers];</span><span id="e559" class="nm jr it nz b gy oh oe l of og">console.log(numbers); // [ 1, 2, 3, 6, 5, 4 ]</span></pre><h2 id="bffa" class="nm jr it bd js nn no dn jw np nq dp ka lq nr ns ke lu nt nu ki ly nv nw km nx bi translated">在对象文字中传播</h2><p id="193b" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">截至ECMAScript 2018，spread属性来到了<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer" rel="noopener ugc nofollow" target="_blank">对象文字</a>。这允许对象将其自身的可枚举属性从提供的对象复制到新的对象上。</p><p id="510f" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">浅层克隆和合并对象很简单</strong></p><p id="e708" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">虽然<code class="fe oi oj ok nz b">Object.assign()</code>使得浅层克隆和合并对象成为可能，但是使用spread语法更加简洁。</p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="3440" class="nm jr it nz b gy od oe l of og">// duplicate object properties<br/>const markerSet = { copicMarkers: ['green', 'blue', 'red']};<br/>const duplicateMarkerSet = {...markerSet};</span><span id="3809" class="nm jr it nz b gy oh oe l of og">console.log(duplicateMarkerSet); // { copicMarkers: [ 'green', 'blue', 'red' ] }</span><span id="990a" class="nm jr it nz b gy oh oe l of og">// merge two objects into a new one<br/>const markerSet2 = { copicSketchMarkers: ['pink', 'yellow', 'orange']};<br/>const giantMarkerSet = { ...markerSet, ...markerSet2 };</span><span id="771e" class="nm jr it nz b gy oh oe l of og">console.log(giantMarkerSet); // { copicMarkers: [ 'green', 'blue', 'red' ], copicSketchMarkers: [ 'pink', 'yellow', 'orange' ] }</span></pre><p id="2e5d" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">还值得注意的是，<code class="fe oi oj ok nz b">Object.assign()</code>触发了<code class="fe oi oj ok nz b">setters</code>，它将一个对象属性绑定到一个函数，当试图设置该属性时，该函数将被调用，而spread语法则没有。</p><h2 id="474b" class="nm jr it bd js nn no dn jw np nq dp ka lq nr ns ke lu nt nu ki ly nv nw km nx bi translated">Spread(除了对象属性之外)仅适用于Iterables</h2><p id="21a8" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">扩展语法(除了在扩展属性的情况下)只能<em class="mu">应用于</em>可迭代对象:数组、映射、集合、字符串等等。</p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="2c73" class="nm jr it nz b gy od oe l of og">// spreading in an object to an array does NOT work<br/>const obj = { key1: 'value1'};<br/>let array = [...obj];</span><span id="0438" class="nm jr it nz b gy oh oe l of og">console.log(array); // []</span><span id="c78d" class="nm jr it nz b gy oh oe l of og">// spreading an array of objects into another array does work<br/>const objInArray = [ { key2: 'value2'}];<br/>array = [...objInArray];</span><span id="f314" class="nm jr it nz b gy oh oe l of og">console.log(array); // [ { key2: 'value2' } ]</span></pre><p id="3c1d" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">这就是为了有效地使用它，您需要了解的spread语法细节的大致内容。</p><h1 id="4139" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="fef6" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">乍一看，一些最新的JS语法似乎完全陌生——即使对于已经编写JavaScript代码多年的人来说也是如此。虽然是的，它是不同的，但它也非常强大，使我们的工作比几年前容易得多。</p><p id="b0f7" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">我这个博客系列的目的是解释一些日常使用的JavaScript和ES6语法，并向您展示如何充分利用JavaScript语言的最新部分。</p><p id="0e7c" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">Rest语法看起来与spread语法(<code class="fe oi oj ok nz b">…</code>)完全一样，但是用于析构数组和对象。在某种程度上，rest语法与spread语法相反:spread将一个数组“扩展”成它的元素，而rest收集多个元素并将它们“压缩”成一个元素。它在许多常见的编程环境中非常有用，我相信您已经可以想象到了。</p><p id="f2e4" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">过几周再来看看，我会写更多关于JavaScript和ES6或其他与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="6b6f" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">感谢您的阅读，我希望您将来会开始看到在代码中使用rest参数和spread语法的可能性——它们让无数事情变得轻而易举。如果你觉得有帮助，请与你的朋友分享！</p><p id="2484" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">如果你喜欢读这篇文章，你可能也会喜欢我的其他博客:</strong></p><ul class=""><li id="10bc" class="ol om it lh b li mm lm mn lq on lu oo ly op mc oq or os ot bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/default-function-parameter-values-javascript-es6-feature-series-pt-3-bd8392a88a12">默认函数参数值:JavaScript ES6特性系列(Pt 3) </a></li><li id="6ef4" class="ol om it lh b li ou lm ov lq ow lu ox ly oy mc oq or os ot bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/arrow-functions-javascript-es6-feature-series-pt-2-e8c31c823392">箭头功能:JavaScript ES6特性系列(Pt 2) </a></li><li id="2bfb" class="ol om it lh b li ou lm ov lq ow lu ox ly oy mc oq or os ot bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/var-let-const-javascript-es6-feature-series-pt-1-fa603567809e"> Var，Let &amp; Const: JavaScript ES6特性系列(Pt 1) </a></li></ul></div><div class="ab cl pe pf hx pg" role="separator"><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj"/></div><div class="im in io ip iq"><p id="fadb" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">参考资料和更多资源:</strong></p><ul class=""><li id="7a5d" class="ol om it lh b li mm lm mn lq on lu oo ly op mc oq or os ot bi translated">Rest参数，MDN文档:<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Functions/rest _ Parameters</a></li><li id="d124" class="ol om it lh b li ou lm ov lq ow lu ox ly oy mc oq or os ot bi translated">Spread语法，MDN Docs:<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Operators/Spread _ Syntax</a></li><li id="ca43" class="ol om it lh b li ou lm ov lq ow lu ox ly oy mc oq or os ot bi translated">JavaScript，维基百科:<a class="ae le" href="https://en.wikipedia.org/wiki/JavaScript#Use_in_Web_pages" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/JavaScript#Use_in_Web_pages</a></li><li id="b8e7" class="ol om it lh b li ou lm ov lq ow lu ox ly oy mc oq or os ot bi translated">destructing，MDN Docs:<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Operators/destructing _ assignment</a></li></ul></div></div>    
</body>
</html>