<html>
<head>
<title>From Scala app to Kubernetes Pod</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Scala应用到Kubernetes Pod</h1>
<blockquote>原文：<a href="https://itnext.io/from-scala-app-to-kubernetes-pod-d67e0cd6bfaf?source=collection_archive---------2-----------------------#2018-08-08">https://itnext.io/from-scala-app-to-kubernetes-pod-d67e0cd6bfaf?source=collection_archive---------2-----------------------#2018-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="66f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您正在处理一个<a class="ae kl" href="https://medium.com/@ticofab/a-crypto-data-project-cf6884c60649" rel="noopener">数据项目</a>，并且您从您的领域模型开始了一个<a class="ae kl" href="https://medium.com/@ticofab/an-eventful-crypto-storm-2a5ed95e5eaf" rel="noopener">事件风暴</a>会话。从那里，你勾画出<a class="ae kl" href="https://medium.com/@ticofab/from-event-storming-to-architecture-c2dc49e9c2d0" rel="noopener">一个架构</a>，并最终实现<a class="ae kl" href="https://medium.com/@ticofab/monitor-crypto-events-with-akka-stream-b2d5d6687804" rel="noopener">第一个服务</a>。现在怎么办？您可能想将它们部署到云中，并添加一些管道。</p><p id="aa12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TL；DR </strong>:将本地应用从本地带到谷歌云基础设施上的Kubernetes pod的步骤。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/df094089de34f7b3b9b2e6a9ed023de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4yrvpEfo2fDNpWppbMGtZQ.jpeg"/></div></div></figure><p id="0e3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了监控关于加密货币的事件，并最终通过机器学习模型找到它们与其价格变化的关联，我绘制了一个架构，它使用了几个JVM服务和谷歌的一些云功能。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ky"><img src="../Images/2b294104f1c370295a78c69c30e1e482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVtpXvG5neI7j1qHYq-ofQ.png"/></div></div></figure><p id="7823" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://medium.com/@ticofab/monitor-crypto-events-with-akka-stream-b2d5d6687804" rel="noopener">上一篇文章</a>描述了加密服务的实现选择，其任务是监控加密货币的事件和价格波动。基于<a class="ae kl" href="https://doc.akka.io/docs/akka/current/stream/stream-introduction.html" rel="noopener ugc nofollow" target="_blank"> Akka Streams </a>的能力，最终结果是简洁的，其复杂性是可管理的。现在的目标是将其部署到云服务，第一步是将我们的服务嵌入到容器中。</p><h2 id="8175" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">码头化</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ls"><img src="../Images/401fe87b96648554f71d62bd9d2b7998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ag8sDQ2eIqhbkejUQs5UiQ.png"/></div></div></figure><p id="14cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的朋友<a class="lt lu ep" href="https://medium.com/u/e7728216eb1?source=post_page-----d67e0cd6bfaf--------------------------------" rel="noopener" target="_blank">耶鲁安·罗森博格</a>提供的<a class="ae kl" href="https://medium.com/jeroen-rosenberg/lightweight-docker-containers-for-scala-apps-11b99cf1a666" rel="noopener">精彩教程</a>一步一步地介绍了这个过程。主要思想是使用<a class="ae kl" href="https://www.scala-sbt.org/sbt-native-packager/" rel="noopener ugc nofollow" target="_blank"> SBT本地打包器</a>插件来生成Docker映像，而不是编写Docker文件。</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="2f5d" class="kz la iq lw b gy ma mb l mc md">addSbtPlugin("com.typesafe.sbt" % "sbt-native-packager" % "1.3.5")</span></pre><p id="a639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在你的<code class="fe me mf mg lw b">build.sbt</code>文件中有一些东西需要设置。至关重要的是启用插件及其Docker特性，命名我们的应用程序，并声明要打包的基本映像:</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="4e2a" class="kz la iq lw b gy ma mb l mc md">enablePlugins(JavaAppPackaging)</span><span id="982d" class="kz la iq lw b gy mh mb l mc md">packageName in Docker := &lt;NAME OF YOUR APP&gt;<br/>dockerBaseImage := "openjdk:jre-alpine" // a smaller JVM base image</span></pre><p id="2078" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在本地环境中创建图像，现在我们只需调用</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="a1cc" class="kz la iq lw b gy ma mb l mc md">sbt docker:publishLocal</span></pre><p id="4eef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…这就是乐趣的开始。Docker映像在您的本地环境中用处不大。我们需要给它翅膀，让它飞到云端。</p><h2 id="1d80" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">谷歌容器注册</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mi"><img src="../Images/5a69eb1274fd745c9fde6836f30ebc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1jMRh1scv0YexsejgfheA.jpeg"/></div></div></figure><p id="0a8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我选择谷歌作为我的云基础设施提供商。我在那里比在AWS更有家的感觉，我想我正在为下一个边项目保存Azure。为了让我们的容器可以用于云中的其他服务(比如运行它)，我们需要将它上传到Google的容器注册中心。初始设置需要几个步骤，主要涉及身份验证。跟随官方指南<a class="ae kl" href="https://cloud.google.com/container-registry/docs/advanced-authentication" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="1f5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的部分是，我们将使用Google Cloud SDK ( <code class="fe me mf mg lw b">gcloud</code>来自命令行)来设置Docker应用程序，并授予它上传到我们的注册表的权限。假设我们在注册表中创建了一个名为<code class="fe me mf mg lw b">my-app</code>的图像，并用<code class="fe me mf mg lw b">latest</code>标记它，我们可以用</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="7bfe" class="kz la iq lw b gy ma mb l mc md">docker push my-app:latest</span></pre><p id="9aba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像往常一样，现实更丰富一点:我知道我将上传到Google Container Registry，它的名字是<code class="fe me mf mg lw b">eu.gr.io</code>，我在Google Cloud中的项目的ID是<code class="fe me mf mg lw b">my-project-id</code>，我将这些信息嵌入到图像名称中。真正的命令是</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="263d" class="kz la iq lw b gy ma mb l mc md">docker push eu.gcr.io/my-project-id/my-app:latest</span></pre><p id="88ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们的服务被整齐地打包并上传到在线注册中心，它最终就可以通过一些编排工具使用了。这份工作目前事实上的标准是Kubernetes。我从我的朋友<a class="lt lu ep" href="https://medium.com/u/5307a3d057b8?source=post_page-----d67e0cd6bfaf--------------------------------" rel="noopener" target="_blank">Á·达姆·桑多</a>那里学到了很多——我们联手准备了一个关于在Kubernetes 上运行<a class="ae kl" href="https://youtu.be/OOXRgd5yUQo" rel="noopener ugc nofollow" target="_blank"> Akka集群解决方案的讲座。</a></p><h2 id="50cd" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">谷歌Kubernetes引擎</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mj"><img src="../Images/1157a9a7d7d44840d605b5b46ca8824d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5-4pk_qZXy43j6e6WF6FQ.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">侍者的奔跑，1933年。版权所有Archivio Birra Peroni，那不勒斯(意大利)</figcaption></figure><p id="0817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，思考Kubernetes最简单的方式就像餐馆里的服务员:它的作用是确保你得到你所要求的。</p><p id="a3b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这一部分，我们需要采取的两个步骤是:</p><ul class=""><li id="1633" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">创建一个Kubernetes集群</li><li id="6ec8" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">为它写一份订单清单</li></ul><p id="c834" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以通过命令行或UI控制台创建集群。您可以选择需要多少台(虚拟机)以及许多其他选项。点餐过程更有趣。</p><p id="9e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点菜的方式有很多种；这里我们重点关注最基本的一种，即通过yaml文件。Kubernetes中的基本执行单位称为“Pod”。我们能给服务员的最简单的订单是</p><blockquote class="nc nd ne"><p id="be99" class="jn jo nf jp b jq jr js jt ju jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj kk ij bi translated">我要你管理这个集装箱。</p></blockquote><p id="a95d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着要求Kubernetes从我们的注册表中获取一个容器并启动它一次。仅此而已——如果它停止了，那就是它了。翻译成yaml语言，看起来是这样的:</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="f8aa" class="kz la iq lw b gy ma mb l mc md">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: my-service<br/>spec:<br/>  containers:<br/>    - image: eu.gcr.io/my-project-id/my-app:latest<br/>      name: my-app-image<br/>      env:<br/>      - name: MY_ENV_VARIABLE<br/>        value: the_value_of_my_env_variable</span></pre><p id="2233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样的命令将从注册表中检索docker图像并运行它，将我们指定的环境变量传递给它。</p><p id="f6b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">写完我们的订单后，我们需要把它交给服务员。这是通过<code class="fe me mf mg lw b">kubectl</code>命令行工具完成的。如果我们将这个文件保存为<code class="fe me mf mg lw b">my-order.yaml</code>，我们可以通过</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="9893" class="kz la iq lw b gy ma mb l mc md">kubectl apply -f my-order.yaml</span></pre><p id="505c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，我们的服务终于可以在云中运行了！为了验证这一点，我们可以问<code class="fe me mf mg lw b">kubectl</code>我们的集群的状态是什么。命令是</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="5493" class="kz la iq lw b gy ma mb l mc md">kubectl get pods</span></pre><p id="8f30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的输出应该是</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="dbe3" class="kz la iq lw b gy ma mb l mc md">NAME                          READY     STATUS    RESTARTS   AGE<br/>my-service                    1/1       Running   0          1m</span></pre><p id="c320" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在STDOUT流上输出的任何内容都可以通过</p><pre class="kn ko kp kq gt lv lw lx ly aw lz bi"><span id="ca47" class="kz la iq lw b gy ma mb l mc md">kubectl logs -f my-service</span></pre><p id="b123" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我如何看到第一个运行在云中的Caterina服务的。这是非常基本的用法，实际上并不建议直接使用Pods。<br/>本系列的<a class="ae kl" href="https://medium.com/@ticofab/more-kubernetes-goodness-for-scala-apps-ff6d9f507140" rel="noopener">下一篇文章</a>讲述了一些更好的Kubernetes特性。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><div class="kn ko kp kq gt nq"><a href="https://medium.com/@ticofab" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">法比奥·特里蒂奇科-中等</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">技术领导和社区人员。寻找一个DevRel角色！</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kw nq"/></div></div></a></div></div></div>    
</body>
</html>