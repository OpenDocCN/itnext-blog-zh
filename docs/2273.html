<html>
<head>
<title>Three Paradigms of Asynchronous Programming in Vertx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vertx中异步编程的三种范式</h1>
<blockquote>原文：<a href="https://itnext.io/three-paradigms-of-asynchronous-programming-in-vertx-b01ab24d0927?source=collection_archive---------1-----------------------#2019-04-28">https://itnext.io/three-paradigms-of-asynchronous-programming-in-vertx-b01ab24d0927?source=collection_archive---------1-----------------------#2019-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="08f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想通过一个使用Vertx框架和Kotlin编程语言的简单web应用程序的例子来展示异步编程的三个范例——回调、未来和协同程序。</p><p id="dcfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们正在编写一个应用程序，它接收HTTP请求中的一个字符串，通过这个字符串在DB中搜索一个URL，获取这个URL内容并将其发送回客户端。</p><p id="2bd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Vertx是为高负载应用创建的异步框架，它使用Netty、新I/O、事件总线。</p><p id="cb97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Vertx中很常见，一个Verticle(类似于Actor，如果你知道Akka)接收一个请求，将接收到的字符串通过事件总线发送到另一个Verticle——business Verticle，它自己负责获取。</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="192a" class="kx ky it kt b gy kz la l lb lc">object Main {<br/>    <a class="ae ld" href="http://twitter.com/JvmStatic" rel="noopener ugc nofollow" target="_blank">@JvmStatic</a><br/>    fun main(args: Array&lt;String&gt;) {<br/>        val vertx =  Vertx.vertx()<br/>        vertx.deployVerticle(HttpVerticle())<br/>        vertx.deployVerticle(BusinessVerticleCoroutines())<br/>    }<br/>}</span><span id="ee51" class="kx ky it kt b gy le la l lb lc">class HttpVerticle : AbstractVerticle() {</span><span id="8730" class="kx ky it kt b gy le la l lb lc"><a class="ae ld" href="http://twitter.com/Throws" rel="noopener ugc nofollow" target="_blank">    @Throws</a>(Exception::class)<br/>    override fun start(startFuture: Future&lt;Void&gt;) {<br/>        val router = createRouter()</span><span id="4dc8" class="kx ky it kt b gy le la l lb lc">vertx.createHttpServer()<br/>            .requestHandler(router)<br/>            .listen(8080) { result -&gt;<br/>                if (result.succeeded()) {<br/>                    startFuture.complete()<br/>                } else {<br/>                    startFuture.fail(result.cause())<br/>                }<br/>            }<br/>    }</span><span id="cc96" class="kx ky it kt b gy le la l lb lc">private fun createRouter(): Router = Router.router(vertx).apply {<br/>        get("/").handler(handlerRoot)<br/>    }</span><span id="28ca" class="kx ky it kt b gy le la l lb lc">private val handlerRoot = Handler&lt;RoutingContext&gt; { rc -&gt;<br/>        vertx.eventBus().send("my.addr", rc.request().getParam("id") ?: "") { resp: AsyncResult&lt;Message&lt;String&gt;&gt; -&gt;<br/>            if (resp.succeeded()) {<br/>                rc.response().end(resp.result().body())<br/>            } else {<br/>                rc.fail(500)<br/>            }<br/>        }<br/>    }</span><span id="a103" class="kx ky it kt b gy le la l lb lc">}</span></pre><p id="8822" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在标准Vertx API中，所有异步流都是通过回调来完成的，因此BusinessVerticle的初始实现如下所示:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="abe6" class="kx ky it kt b gy kz la l lb lc">class BusinessVerticle : AbstractVerticle() {</span><span id="2e93" class="kx ky it kt b gy le la l lb lc">private lateinit var dbclient: JDBCClient<br/>    private lateinit var webclient: WebClient</span><span id="0d7a" class="kx ky it kt b gy le la l lb lc">override fun start() {<br/>        vertx.eventBus().consumer&lt;String&gt;("my.addr") { message -&gt;<br/>            handleMessage(message)<br/>        }<br/>        dbclient = JDBCClient.createShared(<br/>            vertx, JsonObject()<br/>                .put("url", "jdbc:postgresql://localhost:5432/payroll")<br/>                .put("driver_class", "org.postgresql.Driver")<br/>                .put("user", "vala")<br/>                .put("password", "vala")<br/>                .put("max_pool_size", 30)<br/>        )</span><span id="c2d6" class="kx ky it kt b gy le la l lb lc">val options = WebClientOptions()<br/>            .setUserAgent("My-App/1.2.3")</span><span id="a2ef" class="kx ky it kt b gy le la l lb lc">options.isKeepAlive = false<br/>        webclient = WebClient.create(vertx, options)<br/>    }</span><span id="db1e" class="kx ky it kt b gy le la l lb lc">private fun handleMessage(message: Message&lt;String&gt;) {<br/>        dbclient.getConnection { res -&gt;<br/>            if (res.succeeded()) {</span><span id="7a28" class="kx ky it kt b gy le la l lb lc">val connection = res.result()</span><span id="0981" class="kx ky it kt b gy le la l lb lc">connection.query("SELECT url FROM payee_company where name='${message.body()}'") { res2 -&gt;<br/>                    if (res2.succeeded()) {<br/>                        try {<br/>                            val url = res2.result().rows[0].getString("url").removePrefix("http://")<br/>                            webclient<br/>                                .get(url,"/")<br/>                                .send { ar -&gt;<br/>                                    if (ar.succeeded()) {<br/>                                        // Obtain response<br/>                                        val response = ar.result()<br/>                                        message.reply(response.bodyAsString())<br/>                                    } else {<br/>                                        message.fail(500, ar.cause().message)<br/>                                    }<br/>                                }</span><span id="92b0" class="kx ky it kt b gy le la l lb lc">} catch (e: Exception) {<br/>                            message.fail(500, e.message)<br/>                        }<br/>                    } else {<br/>                        message.fail(500, res2.cause().message)<br/>                    }<br/>                }<br/>            } else {<br/>                message.fail(500, res.cause().message)<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="7d29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这看起来很糟糕。回调和错误处理在几个地方完成。</p><p id="1fa7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们通过将每个回调提取到一个单独的方法来改善这种情况:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="85b7" class="kx ky it kt b gy kz la l lb lc">class BusinessVerticle : AbstractVerticle() {</span><span id="ed81" class="kx ky it kt b gy le la l lb lc">private lateinit var dbclient: JDBCClient<br/>    private lateinit var webclient: WebClient</span><span id="cf98" class="kx ky it kt b gy le la l lb lc">override fun start() {<br/>        vertx.eventBus().consumer&lt;String&gt;("my.addr") { message -&gt;<br/>            handleMessage(message)<br/>        }<br/>        dbclient = JDBCClient.createShared(<br/>            vertx, JsonObject()<br/>                .put("url", "jdbc:postgresql://localhost:5432/payroll")<br/>                .put("driver_class", "org.postgresql.Driver")<br/>                .put("user", "vala")<br/>                .put("password", "vala")<br/>                .put("max_pool_size", 30)<br/>        )</span><span id="9c92" class="kx ky it kt b gy le la l lb lc">val options = WebClientOptions()<br/>            .setUserAgent("My-App/1.2.3")</span><span id="d655" class="kx ky it kt b gy le la l lb lc">options.isKeepAlive = false<br/>        webclient = WebClient.create(vertx, options)<br/>    }</span><span id="bf5f" class="kx ky it kt b gy le la l lb lc">private fun handleMessage(message: Message&lt;String&gt;) {<br/>        dbclient.getConnection { res -&gt;<br/>            handleConnectionCallback(res, message)<br/>        }<br/>    }</span><span id="2419" class="kx ky it kt b gy le la l lb lc">private fun handleConnectionCallback(<br/>        res: AsyncResult&lt;SQLConnection&gt;,<br/>        message: Message&lt;String&gt;<br/>    ) {<br/>        if (res.succeeded()) {</span><span id="0d2d" class="kx ky it kt b gy le la l lb lc">val connection = res.result()</span><span id="4a49" class="kx ky it kt b gy le la l lb lc">connection.query("SELECT url FROM payee_company where name='${message.body()}'") { res2 -&gt;<br/>                handleQueryCallBack(res2, message)<br/>            }<br/>        } else {<br/>            message.fail(500, res.cause().message)<br/>        }<br/>    }</span><span id="2b73" class="kx ky it kt b gy le la l lb lc">private fun handleQueryCallBack(<br/>        res2: AsyncResult&lt;ResultSet&gt;,<br/>        message: Message&lt;String&gt;<br/>    ) {<br/>        if (res2.succeeded()) {<br/>            try {<br/>                val url = res2.result().rows[0].getString("url").removePrefix("http://")<br/>                webclient<br/>                    .get(url, "/")<br/>                    .send { ar -&gt;<br/>                        handleHttpCallback(ar, message)<br/>                    }</span><span id="6c05" class="kx ky it kt b gy le la l lb lc">} catch (e: Exception) {<br/>                message.fail(500, e.message)<br/>            }<br/>        } else {<br/>            message.fail(500, res2.cause().message)<br/>        }<br/>    }</span><span id="225e" class="kx ky it kt b gy le la l lb lc">private fun handleHttpCallback(<br/>        ar: AsyncResult&lt;HttpResponse&lt;Buffer&gt;&gt;,<br/>        message: Message&lt;String&gt;<br/>    ) {<br/>        if (ar.succeeded()) {<br/>            // Obtain response<br/>            val response = ar.result()<br/>            message.reply(response.bodyAsString())<br/>        } else {<br/>            message.fail(500, ar.cause().message)<br/>        }<br/>    }<br/>}</span></pre><p id="9217" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好点了，但还是不好。</p><p id="e736" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不可读的代码。我们应该传递给所有方法的消息对象，在每个回调中单独处理错误。</p><p id="2938" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们用<em class="lf"> Future </em> s来重写吧，<em class="lf"> Future </em> s的一大优势就是能够将它们链起来，用<em class="lf"> Future.compose() </em></p><p id="1c92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们翻译标准的Vertx方法，这些方法接收对返回Future的方法的回调。我们将使用“扩展方法”——kot Lin特性，它允许向现有类添加方法。</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="b03e" class="kx ky it kt b gy kz la l lb lc">fun JDBCClient.getConnectionF(): Future&lt;SQLConnection&gt; {<br/>    val f = Future.future&lt;SQLConnection&gt;()<br/>    getConnection { res -&gt;<br/>        if (res.succeeded()) {<br/>            val connection = res.result()<br/>            f.complete(connection)<br/>        } else {<br/>            f.fail(res.cause())<br/>        }<br/>    }<br/>    return f<br/>}</span><span id="9987" class="kx ky it kt b gy le la l lb lc">fun SQLConnection.queryF(query:String): Future&lt;ResultSet&gt; {<br/>    val f = Future.future&lt;ResultSet&gt;()<br/>    query(query) { res -&gt;<br/>        if (res.succeeded()) {<br/>            val resultSet = res.result()<br/>            f.complete(resultSet)<br/>        } else {<br/>            f.fail(res.cause())<br/>        }<br/>    }<br/>    return f<br/>}</span><span id="28f1" class="kx ky it kt b gy le la l lb lc">fun  HttpRequest&lt;Buffer&gt;.sendF(): Future&lt;HttpResponse&lt;Buffer&gt;&gt; {<br/>    val f = Future.future&lt;HttpResponse&lt;Buffer&gt;&gt;()<br/>    send() { res -&gt;<br/>        if (res.succeeded()) {<br/>            val response = res.result()<br/>            f.complete(response)<br/>        } else {<br/>            f.fail(res.cause())<br/>        }<br/>    }<br/>    return f<br/>}</span></pre><p id="52f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后<em class="lf">business verticle . handle message</em>方法将被转换为:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="7e75" class="kx ky it kt b gy kz la l lb lc">private fun handleMessage(message: Message&lt;String&gt;) {<br/>        val content = getContent(message)</span><span id="d657" class="kx ky it kt b gy le la l lb lc">content.setHandler{res-&gt;<br/>            if (res.succeeded()) {<br/>                // Obtain response<br/>                val response = res.result()<br/>                message.reply(response)<br/>            } else {<br/>                message.fail(500, res.cause().message)<br/>            }<br/>        }<br/>    }</span><span id="d86e" class="kx ky it kt b gy le la l lb lc">private fun getContent(message: Message&lt;String&gt;): Future&lt;String&gt; {<br/>        val connection = dbclient.getConnectionF()<br/>        val resultSet = connection.compose { it.queryF("SELECT url FROM payee_company where name='${message.body()}'") }<br/>        val url = resultSet.map { it.rows[0].getString("url").removePrefix("http://") }<br/>        val httpResponse = url.compose { webclient.get(it, "/").sendF() }<br/>        val content = httpResponse.map { it.bodyAsString() }<br/>        return content<br/>    }</span></pre><p id="4601" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来不错。<br/>简单、可读的代码。在一个地方处理错误。如果需要，我们可以为不同的异常添加不同的错误处理和/或将其提取到单独的方法中。</p><p id="10aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果我们需要，在某种情况下，停止<em class="lf"> Future.compose </em>()？<br/>例如，如果DB中没有记录，我们想返回一个HTTP代码为200的响应“no records ”,而不是错误和代码500？</p><p id="9c45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">唯一的方法是抛出一个特殊的异常，并对此类异常进行特殊处理:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="0703" class="kx ky it kt b gy kz la l lb lc">class NoContentException(message:String):Exception(message)</span><span id="9176" class="kx ky it kt b gy le la l lb lc">private fun getContent(message: Message&lt;String&gt;): Future&lt;String&gt; {<br/>        val connection = dbclient.getConnectionF()<br/>        val resultSet = connection.compose { it.queryF("SELECT url FROM payee_company where name='${message.body()}'") }<br/>        val url = resultSet.map {<br/>            if (it.numRows&lt;1)<br/>                throw NoContentException("No records")<br/>            it.rows[0].getString("url").removePrefix("http://")<br/>        }<br/>        val httpResponse = url.compose { webclient.get(it, "/").sendF() }<br/>        val content = httpResponse.map { it.bodyAsString() }<br/>        return content<br/>    }</span><span id="91b6" class="kx ky it kt b gy le la l lb lc">private fun handleMessage(message: Message&lt;String&gt;) {<br/>        val content = getContent(message)</span><span id="5ba6" class="kx ky it kt b gy le la l lb lc">content.setHandler{res-&gt;<br/>            if (res.succeeded()) {<br/>                // Obtain response<br/>                val response = res.result()<br/>                message.reply(response)<br/>            } else {<br/>                if (res.cause() is NoContentException)<br/>                    message.reply(res.cause().message)<br/>                else<br/>                    message.fail(500, res.cause().message)<br/>            }<br/>        }<br/>    }</span></pre><p id="6265" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它工作得很好，但看起来不太好——我们正在使用异常进行流控制，如果流中有许多“特殊情况”,代码的可读性会差得多。</p><p id="a42e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，让我们试着用Kotlin协程做同样的事情。<br/>关于Kotlin协程的文章很多，这里就不解释它们是什么，如何工作了。</p><p id="c6ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Vertx的最新版本中，可以包含自动生成的所有回调方法的协程友好版本。</p><p id="f2ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你应该添加库<br/><em class="lf">‘vertx-lang-kotlin-coroutines’<br/>‘vertx-lang-kotlin’</em></p><p id="c377" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且得到<em class="lf">JDBC client . getconnectionawait()、SQLConnection.queryAwait() </em>等。</p><p id="6a77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们使用这些方法，我们的消息处理方法将变得更简单:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="5955" class="kx ky it kt b gy kz la l lb lc">private suspend fun handleMessage(message: Message&lt;String&gt;) {<br/>        try {<br/>            val content = getContent(message)<br/>            message.reply(content)<br/>        } catch(e:Exception){<br/>            message.fail(500, e.message)<br/>        }</span><span id="17a5" class="kx ky it kt b gy le la l lb lc">}</span><span id="9eed" class="kx ky it kt b gy le la l lb lc">private suspend fun getContent(message: Message&lt;String&gt;): String {<br/>        val connection = dbclient.getConnectionAwait()<br/>        val resultSet = connection.queryAwait("SELECT url FROM payee_company where name='${message.body()}'")<br/>        val url =  resultSet.rows[0].getString("url").removePrefix("http://")<br/>        val httpResponse = webclient.get(url, "/").sendAwait()<br/>        val content = httpResponse.bodyAsString()<br/>        return content<br/>    }</span></pre><p id="8f94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，您应该更改事件总线消息订阅代码:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="1be2" class="kx ky it kt b gy kz la l lb lc">vertx.eventBus().consumer&lt;String&gt;("my.addr") { message -&gt;<br/>           GlobalScope.launch (vertx.dispatcher()) {  handleMessage(message)}<br/>        }</span></pre><p id="1411" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里发生了什么？</p><p id="84fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有这些“await”方法都以异步方式调用代码，然后等待结果，在等待的同时，线程切换到运行另一个协程。</p><p id="fb4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们期待那些“await”方法的实现，我们会看到与我们自制的<em class="lf"> Futures </em>的实现非常相似的东西:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="e90b" class="kx ky it kt b gy kz la l lb lc">suspend fun SQLClient.getConnectionAwait(): SQLConnection {<br/>  return awaitResult {<br/>    this.getConnection(it)<br/>  }<br/>}<br/>suspend fun &lt;T&gt; awaitResult(block: (h: Handler&lt;AsyncResult&lt;T&gt;&gt;) -&gt; Unit): T {<br/>  val asyncResult = awaitEvent(block)<br/>  if (asyncResult.succeeded()) return asyncResult.result()<br/>  else throw asyncResult.cause()<br/>}<br/>suspend fun &lt;T&gt; awaitEvent(block: (h: Handler&lt;T&gt;) -&gt; Unit): T {<br/>  return suspendCancellableCoroutine { cont: CancellableContinuation&lt;T&gt; -&gt;<br/>    try {<br/>      block.invoke(Handler { t -&gt;<br/>        cont.resume(t)<br/>      })<br/>    } catch (e: Exception) {<br/>      cont.resumeWithException(e)<br/>    }<br/>  }<br/>}</span></pre><p id="14e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是这里我们得到了一个普通的代码——String作为返回类型(而不是未来的<string>),用try/catch代替了丑陋的AsyncResult回调。</string></p><p id="7754" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们需要在中间停止一个流程，我们可以用自然的方式来做，没有例外:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="ada9" class="kx ky it kt b gy kz la l lb lc">private suspend fun getContent(message: Message&lt;String&gt;): String {<br/>        val connection = dbclient.getConnectionAwait()<br/>        val resultSet = connection.queryAwait("SELECT url FROM payee_company where name='${message.body()}'")<br/>        if (resultSet.numRows&lt;1)<br/>            return "No records"<br/>        val url =  resultSet.rows[0].getString("url").removePrefix("http://")<br/>        val httpResponse = webclient.get(url, "/").sendAwait()<br/>        val content = httpResponse.bodyAsString()<br/>        return content<br/>    }</span></pre><p id="7185" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">依姆霍，这真是太美了！</p><p id="3b23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">文章的源代码:https://gitlab.com/bernshtam-articles/vertx-async</p></div></div>    
</body>
</html>