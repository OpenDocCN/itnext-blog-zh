<html>
<head>
<title>Smoother UX on Page Load with Angular Resolvers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用角度解析器在页面加载上实现更平滑的UX</h1>
<blockquote>原文：<a href="https://itnext.io/smoother-ux-on-page-load-with-angular-resolvers-e063ef035124?source=collection_archive---------0-----------------------#2020-05-12">https://itnext.io/smoother-ux-on-page-load-with-angular-resolvers-e063ef035124?source=collection_archive---------0-----------------------#2020-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="322c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用角度解析器快速解析数据可以改善页面加载和用户体验，并让您可以立即处理错误。我们将创建一个配置文件解析器来解析配置文件数据。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ff7e84b3fe399e6bb8c45b22971ba9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AehlIaLUCDuEal_tBXGydA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">你的页面加载UX</figcaption></figure><h1 id="47fe" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">为什么要使用角旋变器？</h1><p id="eea5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi mm translated"><span class="l mn mo mp bm mq mr ms mt mu di">作为</span>开发人员，<strong class="ls iu">你总是希望优化你的代码</strong>。这包括向用户呈现满载UI的速度，这通常取决于来自数据库的数据。</p><p id="785c" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">不可避免地，您开始寻找在导航到应用程序的新页面/区域时立即解析数据的方法，而不会让用户遇到所谓的page <strong class="ls iu"> JANK </strong>。</p><blockquote class="na nb nc"><p id="83d5" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated">这是指页面在加载某些组件时上下移动。它可以显著影响UX，以至于它看起来“漏洞百出”。</p></blockquote><p id="5ec8" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">Angular提供了一种在路线加载之前<strong class="ls iu">预取数据的直观方法；在导航路线解析之前。</strong></p><p id="58ad" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">它被称为<strong class="ls iu">角度分解器。</strong></p><p id="2164" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">角度解算器本质上是一种角度服务。<strong class="ls iu">您在路由配置中提供给路由模块的可注入类。</strong>当导航到包含路由时，注入并执行这种特殊类型的服务。</p><p id="dc73" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">解析器然后在页面加载之前解析数据，<strong class="ls iu">通过</strong> <code class="fe nh ni nj nk b"><strong class="ls iu">ActivatedRoute</strong></code> <strong class="ls iu">服务</strong>变得可用。这提供了一种简单而有效的方法来确保您的用户在对初始页面加载很重要的组件需要数据之前尽快获得数据。</p><p id="641f" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">使用角度解析器的另一种方式是将其作为一种方法来即时填充SEO元数据。</strong></p><blockquote class="na nb nc"><p id="defd" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated">有了解析器，你就可以保证数据在页面加载之前就存在了，确保初始化时所有东西都有了。</p></blockquote><h1 id="d88a" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">让我们分解一下角分解器</h1><p id="8455" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">角度解析器是一个实现</strong> <code class="fe nh ni nj nk b"><strong class="ls iu">Resolve</strong></code> <strong class="ls iu">接口的类。</strong><code class="fe nh ni nj nk b">Resolve</code>接口要求你在名为<code class="fe nh ni nj nk b">resolve</code>的类中实现一个函数。</p><p id="3368" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这是解析接口签名…</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="47d8" class="np kz it nk b gy nq nr l ns nt">export interface Resolve&lt;T&gt; {<br/>    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;T&gt; | Promise&lt;T&gt; | T {<br/>        return 'data';<br/>    }<br/>}</span></pre><blockquote class="na nb nc"><p id="83c0" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated">正如我们从接口签名中看到的，它需要一个通用参数<code class="fe nh ni nj nk b">T</code>，这将是我们解析的数据的类型。</p></blockquote><p id="2b25" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu"> resolve </strong>函数返回一个<code class="fe nh ni nj nk b">Observable</code>、<code class="fe nh ni nj nk b">Promise</code>或者只是类型为<code class="fe nh ni nj nk b">T</code>的数据。因此，<strong class="ls iu">建议异步处理这个问题</strong>，尤其是从数据库中检索数据的时候。</p><p id="bb11" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">resolve函数的主要目的是<strong class="ls iu">它必须完成</strong>。在可观测量中检索数据时，需要记住这个事实。<strong class="ls iu">可观察必须完成</strong>。毕竟是解析器。</p><p id="0e0a" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">如果观察不完整，那么数据将永远无法解析，页面将永远无法加载</strong>。因此，您需要定义一个点，在这个点上您不需要再获取任何值，并且数据可以解析，因为您已经从数据库中获得了所有需要的内容。当使用异步数据流时，例如observables，<strong class="ls iu">这是来自<a class="ae nu" href="http://www.learnrxjs.io" rel="noopener ugc nofollow" target="_blank"> RXJS </a>的可管道化操作符</strong>的用例。</p><p id="b3bd" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">当想到<strong class="ls iu">根据条件</strong>完成数据流时，脑海中浮现的可管道化操作符是<code class="fe nh ni nj nk b"><a class="ae nu" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/filter" rel="noopener ugc nofollow" target="_blank">filter</a></code>、<code class="fe nh ni nj nk b"><a class="ae nu" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/take" rel="noopener ugc nofollow" target="_blank">take</a></code>、<code class="fe nh ni nj nk b"><a class="ae nu" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/first" rel="noopener ugc nofollow" target="_blank">first</a></code>的组合。有了这个组合，你可以过滤掉所有你不想取的值，比如<code class="fe nh ni nj nk b">null</code>或者<code class="fe nh ni nj nk b">undefined</code>或者一个空数组<code class="fe nh ni nj nk b">[]</code>，然后用<code class="fe nh ni nj nk b">take(1)</code>过滤掉第一个有效值<code class="fe nh ni nj nk b">take</code>。</p><p id="f602" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">当遇到问题或错误时，可能需要<strong class="ls iu">尽早完成一个可观察的操作符，其中您将希望返回null或重定向，这些操作符是<code class="fe nh ni nj nk b"><a class="ae nu" href="https://www.learnrxjs.io/learn-rxjs/operators/error_handling/catch" rel="noopener ugc nofollow" target="_blank">catchError</a></code>和<code class="fe nh ni nj nk b"><a class="ae nu" href="https://www.learnrxjs.io/learn-rxjs/operators/utility/timeout" rel="noopener ugc nofollow" target="_blank">timeout</a></code>。如果您的数据花费太长时间</strong>并且您想要返回<code class="fe nh ni nj nk b">null</code>以便您可以在组件内部重试，或者您想要重定向，那么<code class="fe nh ni nj nk b">timeout</code>和<code class="fe nh ni nj nk b">catchError</code>的组合<strong class="ls iu">非常有用。</strong></p><blockquote class="na nb nc"><p id="6a1c" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated">如果您的数据不能快速解析，基于复杂的过滤、逻辑和大量的数据库调用，您可能会不时地遇到问题。</p></blockquote><p id="1f4b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">最好确定成功、优雅地加载页面所需的最少数据库调用量、</strong>和最少数据量。</p><p id="e8a5" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">因此，在实现解析器之前，花些时间将“文件夹之上”的内容从页面初始化时可以加载的数据中分离出来，可能会对您有所帮助。</p><p id="5a8c" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">因此，您可以将平滑UX所需的数据与可以从组件而不是解析器调用的其他数据分开。</p><p id="6c8c" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">然后，您可以通过解析器专门处理文件夹上方的最小内容。</strong></p><blockquote class="na nb nc"><p id="70de" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated"><strong class="ls iu">使用</strong> <a class="ae nu" href="https://uxdesign.cc/what-you-should-know-about-skeleton-screens-a820c45a571a" rel="noopener" target="_blank"> <strong class="ls iu">骨架</strong> </a>可以辅助这种动态的页面加载方法。因此，如果用户立即向下滚动，您可以提示用户内容正在加载，从而提高UX。</p></blockquote><div class="nv nw gp gr nx ny"><a href="https://uxdesign.cc/what-you-should-know-about-skeleton-screens-a820c45a571a" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">关于骷髅屏幕你需要知道的一切</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">我们如何知道骨架屏幕实际上是有效的？</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">uxdesign.cc</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks ny"/></div></div></a></div><h1 id="a5a6" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">步骤1:创建解析程序</h1><p id="2ef4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们需要创建角度分解器。然而，<strong class="ls iu">没有一个Angular CLI命令可以生成解析器。</strong>因此，我们将不得不自己编写装饰器(解析器元数据)。</p><p id="077d" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">幸运的是，只有几行代码构成了解析器的样板文件，如果您很难记住，我们可以从现有的服务中获取<strong class="ls iu">可注入的装饰器。</strong></p><h2 id="2185" class="np kz it bd la on oo dn le op oq dp li lz or os lk md ot ou lm mh ov ow lo ox bi translated">用一个可注入的装饰器来注释概要解析器类</h2><p id="2ef7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">首先，我们在配置中提供带有<code class="fe nh ni nj nk b">providedIn: any</code>的可注入装饰器。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="41b5" class="np kz it nk b gy nq nr l ns nt">@Injectable({</span><span id="b380" class="np kz it nk b gy oy nr l ns nt">   providedIn: 'any'</span><span id="a60c" class="np kz it nk b gy oy nr l ns nt">})</span></pre><p id="8550" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">然后我们将通过<strong class="ls iu">附加约定</strong> <code class="fe nh ni nj nk b"><strong class="ls iu">Resolver</strong></code>来命名我们的解析器。对于这个例子，我们将解析概要文件数据(用户数据)，所以我们称之为<code class="fe nh ni nj nk b"><strong class="ls iu">ProfileResolver</strong></code>。</p><p id="78d1" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">因为它是一个解析器，并且<strong class="ls iu"> Angular识别解析器</strong>的功能，我们可以实现<code class="fe nh ni nj nk b">Resolve</code>类，它将提供我们必须在解析函数中实现的签名，以成功解析数据。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="d931" class="np kz it nk b gy nq nr l ns nt">@Injectable({</span><span id="8a31" class="np kz it nk b gy oy nr l ns nt">providedIn: 'any'</span><span id="0c27" class="np kz it nk b gy oy nr l ns nt">})<br/>export class ProfileResolver implements Resolve&lt;Profile&gt; {<br/>}</span></pre><p id="74b6" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们的resolve函数将返回一个可观察的<strong class="ls iu">，其数据符合</strong> <code class="fe nh ni nj nk b"><strong class="ls iu">Profile</strong></code> <strong class="ls iu">接口</strong>。因此，我们将提供<code class="fe nh ni nj nk b">Profile</code>接口作为解析器类和<code class="fe nh ni nj nk b">resolve()</code>函数的<strong class="ls iu">通用参数。这样，我们就符合了旋变器的角度要求。</strong></p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="b3fd" class="np kz it nk b gy nq nr l ns nt">resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;T&gt; | Promise&lt;T&gt; | T {<br/>        return;<br/>}</span></pre><p id="b16d" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">如果需要的话，resolve实现会给我们两个参数:</strong> <code class="fe nh ni nj nk b"><strong class="ls iu">route</strong></code> <strong class="ls iu">和</strong> <code class="fe nh ni nj nk b"><strong class="ls iu">state</strong></code> <strong class="ls iu"> </strong>。这些是自动填充的，可以从我们的<code class="fe nh ni nj nk b">resolve()</code>函数中访问。</p><p id="273b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">接下来，我们需要实际解析数据库中的真实数据，这将是我们的下一步。</p><h2 id="612a" class="np kz it bd la on oo dn le op oq dp li lz or os lk md ot ou lm mh ov ow lo ox bi translated">从数据库中检索数据</h2><p id="e8e3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了检索resolve函数的数据，我们需要注入提供数据的服务；一个与数据库交互的人。</p><p id="a750" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们从它那里得到我们需要的东西来快速解决，这样用户就能快速成功地导航。出于演示的目的，我们不会担心处理数据库的底层服务。我们将在 <code class="fe nh ni nj nk b"><strong class="ls iu">ProfileResolver</strong></code> <strong class="ls iu">类</strong>的构造函数参数中使用依赖注入来注入服务。</p><p id="8416" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">由于我们的数据是以可观察数据流的形式出现的，其中多个值异步发出<strong class="ls iu">，我们只需要使用从<code class="fe nh ni nj nk b">rxjs/operator</code>导入的可管道操作符</strong><code class="fe nh ni nj nk b"><strong class="ls iu">take</strong></code><strong class="ls iu"/><code class="fe nh ni nj nk b"><strong class="ls iu">take(1)</strong></code><strong class="ls iu">。否则，可观测性将永远不会完成，解析器将永远不会…解析。</strong></p><p id="37d0" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们只需要一个发射/值和<code class="fe nh ni nj nk b">take</code>来完成我们的可观测。</p><p id="1020" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">创建一个解析器就这么简单</strong>；我们只需要在angular将处理订阅的<code class="fe nh ni nj nk b">resolve()</code>函数中返回可观察值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">ProfileResolver类</figcaption></figure><p id="6fb7" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们通过重定向到父路由来处理检索数据中的任何错误。</p><h2 id="422a" class="np kz it bd la on oo dn le op oq dp li lz or os lk md ot ou lm mh ov ow lo ox bi translated">额外收获:在加载路线之前，快速填充动态SEO元数据</h2><p id="2082" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">填充我们的<code class="fe nh ni nj nk b">&lt;meta&gt;</code>标签的好处显而易见。我们的SEO元数据填充得越快，<strong class="ls iu">我们的SEO就越能正确、准确地反映页面内容。</strong></p><p id="b777" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这意味着机器人，如谷歌和必应等搜索引擎操作的机器人，抓取你的网站并检索内容更加容易和快捷。</p><blockquote class="na nb nc"><p id="bd54" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated">T <strong class="ls iu">这对于预渲染页面或由Angular Universal </strong>渲染的页面并不重要，因为所有的渲染都是在机器人接收内容之前完成的。</p></blockquote><p id="c8c4" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">然而，如果您依赖google robots为您的SEO解析javascript的能力(通常是有问题的)，或者您已经有了像puppeteer这样的按需解决方案，需要在返回呈现的DOM之前确保SEO是正确的，那么包含SEO的解析器应该会有所帮助。所以当爬虫有时间限制的时候它是有帮助的。</p><p id="6361" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">它还将关注点从组件</strong>中分离出来，这样组件就不必处理任何与SEO相关的事情。我喜欢解析器的主要原因之一。</p><h1 id="dc89" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">步骤2:将解析器注入路由模块</h1><p id="fe75" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们将在其中提供解析器的<strong class="ls iu"> ProfileRoutingModule </strong>是一个延迟加载的模块。因此，我们的根路径将是空的，带有参数标记<code class="fe nh ni nj nk b">userSlug</code>，我们将需要它来检索正确的概要文件数据。</p><p id="5784" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">为了提供解析器，我们只需提供一个对象，将数据的名称作为键，将特定的解析器作为负责解析该数据的值。</p><p id="15b6" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">你可以给这个键起任何你喜欢的名字，但是我们就称它为<strong class="ls iu">数据</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们的ProfileRoutingModule模块</figcaption></figure><p id="37d5" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这就是路由模块中使用解析器所需的全部内容。</p><p id="c826" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">接下来，<strong class="ls iu">我们需要在组件中检索和使用我们的数据。</strong></p><h1 id="3c96" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">步骤3:用解析的数据初始化组件</h1><p id="68dc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在我们已经解析了路由激活的数据，<strong class="ls iu">可以通过</strong> <code class="fe nh ni nj nk b"><strong class="ls iu">ActivatedRoute</strong></code> <strong class="ls iu">服务</strong>访问这些数据。由于我们在整个应用程序中处理可观测量，<strong class="ls iu">我们将创建一个绑定到</strong> <code class="fe nh ni nj nk b"><strong class="ls iu">data</strong></code> <strong class="ls iu">属性的流，它将是我们解析的数据</strong>。</p><p id="585b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">首先，我们将把<code class="fe nh ni nj nk b">ActivatedRoute</code>注入到<code class="fe nh ni nj nk b">ProfileComponent</code>的构造函数中。接下来，我们将把<code class="fe nh ni nj nk b">this.route.data</code>分配给<code class="fe nh ni nj nk b">profile$</code>可观测值。<strong class="ls iu">当更新的数据从数据库到达时，我们也想切换到使用可观察的，这样当我们与应用程序交互时，我们就有了新的数据。</strong></p><p id="c49c" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">为此，我们将使用<code class="fe nh ni nj nk b">startWith</code>，这样我们就可以从<code class="fe nh ni nj nk b">this.route.snapshot.data</code>中容易访问的值开始我们的流。然后我们像访问<code class="fe nh ni nj nk b">this.route.snapshot.data['data']</code>一样访问<code class="fe nh ni nj nk b">data</code>属性。<code class="fe nh ni nj nk b">startWith</code>表示一个开始值，作为我们流的第一次发射。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们的个人资料组件</figcaption></figure><h2 id="d3b1" class="np kz it bd la on oo dn le op oq dp li lz or os lk md ot ou lm mh ov ow lo ox bi translated">可立即访问的数据对组件有什么作用</h2><p id="cba3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">可立即访问的数据减少了加载该页面各个部分所花费的时间，<strong class="ls iu">，这被用户观察到</strong>。不使用这样的解析器的结果是页面可能看起来以一种支离破碎的方式加载，这在视觉上是不令人愉快的。</p><p id="b0b2" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">因此，您需要注意HTML模板的哪些元素依赖于哪些数据。然后你应该编写解析器来支持这些元素和页面加载UX的整体效果。</p><h2 id="7a1d" class="np kz it bd la on oo dn le op oq dp li lz or os lk md ot ou lm mh ov ow lo ox bi translated"><strong class="ak">组件可以通过多种方式加载碎片</strong></h2><ul class=""><li id="4383" class="pb pc it ls b lt lu lw lx lz pd md pe mh pf ml pg ph pi pj bi translated">其中之一是如果你的HTML模板的多个部分都有一个<code class="fe nh ni nj nk b">ngIf</code>。</li><li id="732b" class="pb pc it ls b lt pk lw pl lz pm md pn mh po ml pg ph pi pj bi translated">再一个是<code class="fe nh ni nj nk b">ngFor</code>。</li></ul><blockquote class="na nb nc"><p id="72c3" class="lq lr nd ls b lt mv ju lv lw mw jx ly ne mx mb mc nf my mf mg ng mz mj mk ml im bi translated">最好的做法是限制你写的单个<code class="fe nh ni nj nk b">ngIf</code>的数量，目的是限制浏览器必须做的调整大小的数量。</p></blockquote><p id="2d39" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated"><strong class="ls iu">在获取数据之前加载页面会导致页面的某些部分不断跳跃、滞后和调整大小，</strong>导致UX受损。</p><p id="dd1c" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">实现一个解析器可能是<strong class="ls iu">用户经历3-5秒的跳跃和调整大小与0.5秒的差别，</strong>这通常太快而不会损害整体UX。</p><h2 id="3ec5" class="np kz it bd la on oo dn le op oq dp li lz or os lk md ot ou lm mh ov ow lo ox bi translated"><strong class="ak">就是这样！我们有一个解析器，它改进了页面加载的UX。</strong></h2><blockquote class="pp"><p id="c4cb" class="pq pr it bd ps pt pu pv pw px py ml dk translated">有任何问题，请在评论中告诉我！</p></blockquote><div class="pz qa qb qc qd ny"><a href="https://angular.io/api/router/Resolve" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">角度分解器</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">Angular是一个构建移动和桌面web应用程序的平台。加入数百万开发者的社区…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">angular.io</p></div></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://www.learnrxjs.io" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">介绍</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">是当今web开发中最热门的库之一。提供强大的功能方法来处理…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">www.learnrxjs.io</p></div></div><div class="oh l"><div class="qe l oj ok ol oh om ks ny"/></div></div></a></div></div></div>    
</body>
</html>