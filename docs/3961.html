<html>
<head>
<title>Scalable Serverless Microservice Demo AWS Lambda Kinesis Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可扩展的无服务器微服务演示AWS Lambda motis terra form</h1>
<blockquote>原文：<a href="https://itnext.io/scalable-serverless-microservice-demo-aws-lambda-kinesis-terraform-cbe6036bf5ac?source=collection_archive---------3-----------------------#2020-04-02">https://itnext.io/scalable-serverless-microservice-demo-aws-lambda-kinesis-terraform-cbe6036bf5ac?source=collection_archive---------3-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ebb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用驱动程序演示具有异步通信的高度可扩展的无服务器微服务应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0c85246879bfc76b2cd4cb2039c70742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtK33Vo_pkW36Oymgs0sjw.jpeg"/></div></div></figure><h2 id="5e19" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">系列内容</h2><p id="28d8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">本系列使用不同的技术创建相同的可扩展微服务应用程序:</p><ol class=""><li id="392d" class="mj mk it ls b lt ml lw mm ld mn lh mo ll mp mi mq mr ms mt bi translated"><a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/scalable-microservice-demo-k8s-istio-kafka-344a2610eba3?source=friends_link&amp;sk=7404e77f2a42d21261707794afaed58d">使用Kubernetes、Istio和Kafka的可扩展微服务演示</a></li><li id="9dad" class="mj mk it ls b lt mv lw mw ld mx lh my ll mz mi mq mr ms mt bi translated">(本文)</li><li id="9d18" class="mj mk it ls b lt mv lw mw ld mx lh my ll mz mi mq mr ms mt bi translated">使用Knative和Kafka的可扩展无服务器微服务演示(已计划)</li></ol><h2 id="fc6e" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">这是怎么回事？</h2><p id="d81c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">在这里，我们构建了与<a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/scalable-microservice-demo-k8s-istio-kafka-344a2610eba3?source=friends_link&amp;sk=7404e77f2a42d21261707794afaed58d">第1部分</a>中相同的微服务应用程序。虽然这一次我们使用了无服务器技术及其周围的AWS生态系统。通过同步的REST API调用，可以创建用户。所有进一步的交流都是通过驱动程序异步完成的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/ada2e9a55f3429594c047add95ad941c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3o6dL1356YfcGUUuRHzVMQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">图1:体系结构概述</figcaption></figure><h2 id="5697" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="0421" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我们在一个时间点跨所有函数扩展到大约180个并发Lambda执行和大约18000个Lambda调用。这主要受到驱动碎片数量的限制。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/87e0d4eb01862f90752cd2e05a35a5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZC1OPZVbsjzE2YvnJcTFfg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">图2:显示两个λ函数的度量的结果预览</figcaption></figure><h2 id="4c10" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">存储库/技术</h2><p id="32b7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated"><a class="ae mu" href="https://github.com/wuestkamp/scalable-serverless-microservice-demo" rel="noopener ugc nofollow" target="_blank">https://github . com/wuestkamp/scalable-无服务器-microservice-demo </a></p><p id="16d8" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">Terraform，AWS: Lambda (Python)，运动学，DynamoDB，S3，API-Gateway</p><p id="e823" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">一切都是用Terraform编写的，可以通过运行一个命令来设置，更多信息见<a class="ae mu" href="https://github.com/wuestkamp/scalable-serverless-microservice-demo" rel="noopener ugc nofollow" target="_blank">项目的自述文件</a>。</p><h1 id="bf9e" class="nj kv it bd kw nk nl nm kz nn no np lc jz nq ka lg kc nr kd lk kf ns kg lo nt bi translated">体系结构</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/7265d612d675b2c5b3eda3734cd74b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elp97V0rUL2V44AQ45qioA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">图像3:建筑</figcaption></figure><p id="2eb4" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">图3显示了架构。我们有5个主要的Lambda函数，都是用Python编写的:</p><ul class=""><li id="8a64" class="mj mk it ls b lt ml lw mm ld mn lh mo ll mp mi nv mr ms mt bi translated"><strong class="ls iu">操作-创建</strong>:将同步REST API请求转换为异步事件，创建一个“操作”来跟踪用户创建</li><li id="c3c0" class="mj mk it ls b lt mv lw mw ld mx lh my ll mz mi nv mr ms mt bi translated"><strong class="ls iu">用户-创建</strong>:在“需要审批”状态下创建新用户</li><li id="ea11" class="mj mk it ls b lt mv lw mw ld mx lh my ll mz mi nv mr ms mt bi translated"><strong class="ls iu">用户批准</strong>:批准用户</li><li id="257f" class="mj mk it ls b lt mv lw mw ld mx lh my ll mz mi nv mr ms mt bi translated"><strong class="ls iu">用户-创建-响应</strong>:检查用户创建是否完成。现在，只有用户批准的响应是必要的，但是更多与其他服务的交互是可能的</li><li id="b2f6" class="mj mk it ls b lt mv lw mw ld mx lh my ll mz mi nv mr ms mt bi translated"><strong class="ls iu">操作-更新</strong>:用新的状态更新操作，如完成或错误</li></ul><h2 id="13f7" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">同步异步转换</h2><p id="3a09" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">还有另一个Lambda函数<strong class="ls iu">操作-get </strong>允许用户检索操作的状态，但是我没有把它包括在图像3中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/747f568179245b021af07163aff9f3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lloCgklWvzKVDsxilFyvg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">图4:同步到异步转换</figcaption></figure><p id="0a81" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">(<strong class="ls iu"> 1 </strong>)图4显示，首先对operation-create Lambda进行了一个同步REST调用，以创建一个新的操作。Lambda函数向Kinesis发出一条消息，然后立即返回处于挂起状态的新操作。</p><p id="80bc" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">(<strong class="ls iu"> 2 </strong>)返回的操作包含一个UUID，它可以用来定期获取该操作的当前状态。该操作将根据其他服务异步发出的进一步异步请求进行更新。</p><h2 id="0040" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">与第1部分相比</h2><p id="b0e2" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">与<a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/scalable-microservice-demo-k8s-istio-kafka-344a2610eba3?source=friends_link&amp;sk=7404e77f2a42d21261707794afaed58d">第1部分</a>相比，该架构现在有6个服务(或者说是Lambda函数)，而在第1部分中我们只有3个服务。但是我们仍然可以将这6项功能分成3个不同的组，如下所示:</p><ul class=""><li id="e8ec" class="mj mk it ls b lt ml lw mm ld mn lh mo ll mp mi nv mr ms mt bi translated"><strong class="ls iu">操作服务</strong>:操作-创建，操作-获取，操作-更新</li><li id="a066" class="mj mk it ls b lt mv lw mw ld mx lh my ll mz mi nv mr ms mt bi translated"><strong class="ls iu">用户服务</strong>:用户创建，用户创建响应</li><li id="b670" class="mj mk it ls b lt mv lw mw ld mx lh my ll mz mi nv mr ms mt bi translated"><strong class="ls iu">用户批准服务</strong>:用户批准</li></ul><p id="e484" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">我决定将第1部分的服务分成更小的功能，因为用Lambda很容易做到。通过这种方式，每个函数只监听一个很棒很干净的特定事件。</p><h2 id="fabf" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">无服务器</h2><p id="593f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">这看起来像是梦，对吗？编写应用程序，然后它就可以运行了。它可以自动扩展/缩小，高度可用，响应速度快。这个演示项目的目的也是为了找出我们是否已经在这一点上。</p><h2 id="39b3" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">每个服务模式的数据库</h2><p id="35b1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我们不使用多个服务共享的大型数据库，如果是有状态的，每个服务都有自己的数据库。如果微服务使用相同的类型/版本，它们可以共享同一个数据库服务器。点击阅读更多<a class="ae mu" href="https://microservices.io/patterns/data/database-per-service.html" rel="noopener ugc nofollow" target="_blank">。使用AWS DynamoDB，您甚至不需要管理服务器实例，只需创建表。</a></p><h2 id="a4e6" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">异步通信</h2><p id="07d5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">所有Lambda函数彼此异步通信，没有直接的同步连接。异步的一个优点是松耦合。如果用户批准功能关闭了一段时间，请求不会失败，只是需要更长时间直到用户获得批准。因此，当使用异步通信时，不需要实施重试或断路器。</p><h1 id="292e" class="nj kv it bd kw nk nl nm kz nn no np lc jz nq ka lg kc nr kd lk kf ns kg lo nt bi translated">AWS API网关</h1><p id="2ae2" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">允许您创建(REST)API并管理端点、伸缩、节流、TLS终止、认证等等。它连接现有的AWS服务或外部服务。</p><h1 id="08c8" class="nj kv it bd kw nk nl nm kz nn no np lc jz nq ka lg kc nr kd lk kf ns kg lo nt bi translated">AWS室壁运动</h1><blockquote class="nx ny nz"><p id="8a9c" class="lq lr oa ls b lt ml ju lv lw mm jx ly ob ng ma mb oc nh md me od ni mg mh mi im bi translated">Amazon Kinesis可以轻松收集、处理和分析实时流数据，因此您可以获得及时的见解，并对新信息做出快速反应。Amazon Kinesis提供了经济高效地处理任何规模的流数据的关键功能，以及选择最适合您应用要求的工具的灵活性。(【https://aws.amazon.com/kinesis】T2</p></blockquote><h1 id="2e2e" class="nj kv it bd kw nk nl nm kz nn no np lc jz nq ka lg kc nr kd lk kf ns kg lo nt bi translated">AWS无服务器λ函数</h1><p id="2a10" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">它们根据来自不同来源的输入事件，在需要时运行您的代码。例如，这些可以是API调用、数据库更改或来自其他功能的调用。</p><h2 id="2e11" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">缩放比例</h2><p id="2798" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">通常，对于每个事件，都会启动一个新的函数实例。尽管如果在短时间内有更多的事件跟随，实例可以被重用。但是一个实例永远不会被用来同时处理两个或更多的事件。在这些情况下，将创建同时运行的新实例。</p><h2 id="e947" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">层</h2><p id="008b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">层允许你保持实际的Lambda函数很小。如果你的函数太大，你将不能在网络编辑器中编辑它们。这个演示创建了一个包含<code class="fe oe of og oh b">aws-xray-sdk</code> python依赖项的层。这一层然后被所有函数使用。</p><h2 id="0e12" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">用X射线追踪</h2><p id="80cb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">只需一次点击，即可启用X射线追踪。这样就有可能看到一个函数何时被执行以及运行了多长时间。使用<code class="fe oe of og oh b">aws-xray-sdk</code>还可以跟踪从函数内部对其他AWS服务甚至外部(HTTP)API的调用。下面是在python中如何做到这一点:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="082e" class="ku kv it oh b gy om on l oo op">import json<br/>import boto3<br/><strong class="oh iu">from aws_xray_sdk.core import patch_all<br/>patch_all()</strong><br/><br/><br/>def lambda_handler(event, context):<br/>  ...</span></pre><p id="6bd3" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">更多关于SDK和补丁<a class="ae mu" href="https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-python-patching.html" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><h2 id="f142" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">Kinesis并发事件处理</h2><p id="9524" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">为了让多个Lambda函数同时处理来自同一个Kinesis流的事件，有必要拥有多个Kinesis流碎片。一个shard =一个并发Lambda函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/65cf986cbc0985f9c8c05eefbc5bf331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwEj1Y3xJ7Zv9ZxT9EkBBw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">图5: Kinesis并发Lambda处理</figcaption></figure><h1 id="70e7" class="nj kv it bd kw nk nl nm kz nn no np lc jz nq ka lg kc nr kd lk kf ns kg lo nt bi translated">实际演示</h1><h2 id="ab8f" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">创建一个用户</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/6071b52c8e063024b01619060c9f9bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KA10X9eBN2nYOHdCiU6FsA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">图6:创建一个新用户，带有挂起状态的即时响应</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/04f511b0db18efee68466000b40ffc8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_NPu3DFjTRIYgkhRZQLJg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">图7:用户创建仍未完成</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/1f3b5be836b21928b04c54f8c29168d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOO3qK15JzxO80-5oBgctQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">图8:用户创建完成</figcaption></figure><h2 id="8902" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">创造大量用户</h2><p id="7628" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">现在我们用大量的请求来攻击我们的API。事件流将是:</p><p id="7cd6" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated"><strong class="ls iu">操作_创建</strong> - &gt; <strong class="ls iu">用户_创建</strong> - &gt; <strong class="ls iu">用户_批准</strong> - &gt; <strong class="ls iu">操作_更新</strong></p><p id="2ac2" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">(为了保持简洁，图中没有用户创建响应的指标)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/a5c453fd2c124f192114352b369d6162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*csjMOHxUhuBKA4Mjk8OKYg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">图6:运行中的Lambda指标</figcaption></figure><ul class=""><li id="c1ae" class="mj mk it ls b lt ml lw mm ld mn lh mo ll mp mi nv mr ms mt bi translated">我们从12:00到12:20使用API ( <strong class="ls iu"> operation_create </strong>)处理新的用户创建请求</li><li id="4031" class="mj mk it ls b lt mv lw mw ld mx lh my ll mz mi nv mr ms mt bi translated">Kinesis碎片的大小为50，所以每个碎片最多只能同时消耗50个功能</li><li id="a62d" class="mj mk it ls b lt mv lw mw ld mx lh my ll mz mi nv mr ms mt bi translated">我们可以看到，即使当新请求(<strong class="ls iu"> operation_create </strong>)在12:30左右停止时，其他函数仍然在现有的Kinesis事件上工作了一段时间，并且从未完成</li></ul><h1 id="ac18" class="nj kv it bd kw nk nl nm kz nn no np lc jz nq ka lg kc nr kd lk kf ns kg lo nt bi translated">结果</h1><p id="5baf" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我们能够在一个时间点跨所有函数扩展到大约180个并发Lambda执行和大约18000个Lambda调用。这受到了动力流碎片数量的限制。及时处理大量的请求是不够的。这应该可以通过提高碎片量来解决。</p><p id="928f" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">这让我怀疑这种方法是否是一个好的技术选择。要有更多的并发消费者，肯定需要改进。<strong class="ls iu">如果您有任何意见，请告诉我！</strong></p><h2 id="0abe" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">AWS API网关</h2><p id="a7a2" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">API-Gateway(默认情况下)的响应时间很慢，大约为1秒，这使得很难将请求扩展到很高的数量。为了解决这个问题，我在while循环中运行<code class="fe oe of og oh b">curl</code>,不等待响应，这样我就可以创建负载。</p><p id="3e27" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">响应延迟可能是由API网关同步调用Lambda函数并将其响应返回给用户引起的。Lambda函数需要一些时间来加载和准备。这可以通过设置一个<a class="ae mu" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html#configuration-concurrency-reserved" rel="noopener ugc nofollow" target="_blank">保留并发</a>来处理。</p><h2 id="b0b5" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">AWS Kinesis和并发消费者</h2><p id="bb3b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">需要考虑的一点是，在一个Kinesis流分片上只能有一个Lambda函数并发运行。所以为了扩大规模，你需要创造更多的碎片。我用50个碎片创建了四个动力流，这是由于我的地域限制。</p><h2 id="3b15" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">与第一部分的比较:Kubernetes Istio Kafka</h2><p id="4341" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">这两种解决方案的扩展幅度几乎相同，并且通过简单地增加资源就显示出了增长潜力。</p><p id="2ac8" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">与第1部分相比，使用AWS生态系统比更手动的方法要快得多。我猜我花了三分之一的时间。</p><p id="8456" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">这是因为所有托管服务已经很好地协同工作，通常只需勾选一个框就可以实现跟踪等功能。还有监控，如果CloudWatch的默认提供足够了，那么它可以直接与几乎所有的服务一起开箱即用。</p><h2 id="0cab" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">AWS阶跃函数</h2><p id="0449" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">还有<a class="ae mu" href="https://aws.amazon.com/step-functions/" rel="noopener ugc nofollow" target="_blank"> AWS步骤函数</a>，通过将各种Lambda函数连接在一起，允许创建状态机作为可视化工作流。然后，它们可以通过直接调用同步通信，或者通过队列异步通信。</p><p id="7210" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">虽然Kinesis作为函数间的事件代理不被支持，甚至当使用SQS时，仍然需要更复杂的其他函数调用。这就是为什么我选择不使用它，但它看起来很有前途。</p><h1 id="3fe2" class="nj kv it bd kw nk nl nm kz nn no np lc jz nq ka lg kc nr kd lk kf ns kg lo nt bi translated">概述</h1><p id="a9e0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">无服务器和周围基于事件的生态系统(比如AWS)看起来真的是软件架构的未来。在我看来，这就是我们要去的地方。只要有可能，我们不想担心底层虚拟机、服务器甚至容器。</p><p id="05db" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">尽管我认为“云原生”也意味着使用开源软件，而不是局限于一家公司云提供商。这就是为什么我将在Kubernetes之上研究Knative及其无服务器功能和事件处理。如果有时间的话，我也可以用Knative创建这个微服务示例演示。</p><p id="3ded" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld ng ma mb lh nh md me ll ni mg mh mi im bi translated">让我知道你在这个演示中看到的改进。</p></div></div>    
</body>
</html>