<html>
<head>
<title>Under the hood of Operator SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在运营商SDK的罩下</h1>
<blockquote>原文：<a href="https://itnext.io/under-the-hood-of-the-operator-sdk-eebc8fdeebbf?source=collection_archive---------6-----------------------#2018-05-17">https://itnext.io/under-the-hood-of-the-operator-sdk-eebc8fdeebbf?source=collection_archive---------6-----------------------#2018-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d00a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://medium.com/@cloudark/under-the-hood-of-kubebuilder-framework-ff6b38c10796" rel="noopener">之前的博客文章</a>中，我们看到了Kubebuilder框架的内幕。在本帖中，我们将关注运营商SDK。</p><p id="95ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/operator-framework/operator-sdk" rel="noopener ugc nofollow" target="_blank">运营商SDK </a>是最近宣布的运营商框架的一部分。Operator SDK的目标是提供简化创建Kubernetes操作符的高级抽象。</p><p id="76a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们深入讨论Operator SDK的细节之前，这里有一些您应该熟悉的Kubernetes术语:</p><ol class=""><li id="de5f" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">CRD:自定义资源定义。</li><li id="a414" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">object:Kubernetes基本类型/种类的实例或CRD的实例。</li><li id="48e6" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">对象关键字:代表对象的唯一字符串。它是从对象中解析的。</li><li id="e07c" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">Informer:定期查询Kubernetes API服务器以监控特定类型/种类的对象变化的机制。它检索已更改的对象并将它们存储在本地索引中。这里的“本地”是指自定义操作符运行的位置。</li><li id="57dc" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">SharedIndexInformer:一种数据结构，用于管理存储对象的多个通知器之间的共享索引。</li><li id="8d72" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">工作队列:在对象键被处理之前存储它们的数据结构。</li><li id="7a4f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">Lister:从本地索引中查询对象的机制。</li><li id="d8e3" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">Client/ClientSet:直接从Kubernetes API服务器查询对象的机制。使用Lister从本地索引查询对象比使用客户机查询Kubernetes API服务器更可取，这样可以减少API服务器上的负载。</li></ol><p id="1d37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是Operator SDK的图形表示，以及它如何与自定义操作员代码交互。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/706ca358f56d41e82b307efb6f6dfdb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDWOCdEqZ3T8Fi3k3ApKxQ.jpeg"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">运营商SDK和自定义运营商交互</figcaption></figure><p id="94b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将图片分为两部分:Operator SDK(顶部)和custom Operator(底部)。</p><p id="634a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">运营商SDK组件:</strong></p><p id="d441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1)informer:informer类型保存Operator SDK使用的关键数据结构。它们是SharedIndexInformer和工作队列。SharedIndexInformer使用List和Watch方法定期查询Kubernetes API服务器，以检索任何已更改的对象。事件处理函数被定义为对对象的添加、更新和删除事件做出反应。这些函数解析对象的键，并将其添加到工作队列中。</p><p id="92cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2) informer-sync.go:这个文件定义了处理来自工作队列的对象键的函数。processNextItem函数检索密钥并调用sync函数。然后从键创建一个<a class="ae kl" href="https://github.com/operator-framework/operator-sdk/blob/master/pkg/sdk/types.go" rel="noopener ugc nofollow" target="_blank">事件对象</a>，并调用定制操作符代码的注册句柄函数。</p><p id="ddbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3) api.go:这个文件提供了公共api(入口点函数)。这些函数用于注册自定义操作符的句柄函数，为CRD和Kubernetes(我们希望对其做出反应的本地类型)创建通知程序，以及启动通知程序。</p><p id="3237" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">自定义操作员组件:</strong></p><p id="dcc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1) handler.go:这个文件是我们编写自定义操作符的对帐代码的地方。它是由操作员SDK生成的。文件中提供了存根句柄函数。该函数由informer-sync.go文件中sync函数内的操作符SDK调用。从工作队列中捕获对象键的事件被传递给Handle函数。</p><p id="f376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2) main.go:该文件执行连接自定义操作符和操作符SDK的设置步骤。它是由操作员SDK生成的。该文件中使用的典型模式由以下动作组成:(a)设置对所需类型(CRD或Kubernetes-native类型)的监视，(b)注册处理程序，(c)启动通知程序。api.go中的各个函数用于执行这些操作。</p><p id="0f33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">与从头开始方法的比较:</strong></p><p id="1e21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是将运营商SDK方法与<a class="ae kl" href="https://medium.com/@cloudark/kubernetes-custom-controllers-b6c7d0668fdf" rel="noopener">从头开始</a>方法进行比较后的一些收获。</p><p id="339f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lq">相似之处:</em></p><p id="e664" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两种方法都提供了生成基本go文件的工具。在从头开始的方法中，为此提供了一个脚本(<a class="ae kl" href="https://github.com/kubernetes/sample-controller/blob/master/hack/update-codegen.sh" rel="noopener ugc nofollow" target="_blank"> hack/update-codegen.sh </a>)。类似的，运营商SDK提供了命令行工具。</p><p id="d1f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lq">差异:</em></p><ol class=""><li id="c423" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">与从头开始的方法相比，Operator SDK生成的目录结构明显不同。</li><li id="a7e5" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">在从头开始的方法中，CRD的类型化客户端和列表器是由update-codegen脚本生成的。Operator SDK不会生成这些。相反，它通过利用<a class="ae kl" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> client-go库</a>提供的发现和REST映射功能在内部创建资源客户端。</li></ol><p id="8a30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lq">与从头开始相比，使用运营商SDK的优势:</em></p><p id="8380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写操作符时，不需要管理工作队列或SharedIndexInformer。这是由运营商SDK提供的informer类型抽象出来的。对于从头开始的方法，您必须创建工作队列，还必须创建通知器和事件处理函数。然后，您必须将它们连接起来，以便从Kubernetes API服务器接收更改后的对象。此外，如果您想使用本地索引，您还必须创建一个索引器。使用Operator SDK时，您不必担心这些。</p><p id="56de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lq">在从头开始方法上使用运营商SDK的顾虑:</em></p><p id="3d0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运营商SDK <em class="lq">的主要担忧可能是它的性能。在<a class="ae kl" href="https://github.com/kubernetes/sample-controller" rel="noopener ugc nofollow" target="_blank">样本控制器</a>中，它被用作从头开始方法的起点，列表器被用来减少到Kubernetes API服务器的流量。在Operator SDK的设计中，我们没有发现任何Lister功能的使用。因此，这可能会导致API服务器上的更多负载(我们计划很快对此进行实验性评估)。目前，我们已经<a class="ae kl" href="https://github.com/operator-framework/operator-sdk/issues/258" rel="noopener ugc nofollow" target="_blank">在Operator SDK存储库上发布了一个问题</a>，以了解这一设计决策背后的基本原理。</em></p><p id="e3ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论:</strong></p><p id="d2c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Operator SDK是一个文档完备的代码库，易于理解。包的数量很少，将功能分解成不同的包是合理的。虽然<a class="ae kl" href="https://github.com/operator-framework/operator-sdk/issues/257" rel="noopener ugc nofollow" target="_blank">一些重构可以帮助</a>，但是当前的代码基础写得很好。作为用户，你将不必学习许多新的抽象概念。对运营商SDK定义的事件类型及其内部处理方式的基本理解应该就足够了。与从头开始的方法相比，您应该仔细考虑的主要问题是它对Kubernetes API服务器的性能影响。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="d20a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:如果你喜欢这篇文章，你可能也想看看Kubebuilder框架下的<a class="ae kl" href="https://medium.com/@cloudark/under-the-hood-of-kubebuilder-framework-ff6b38c10796" rel="noopener">。</a></p></div></div>    
</body>
</html>