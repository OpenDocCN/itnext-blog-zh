<html>
<head>
<title>Working with kubernetes configmaps, part 1: volume mounts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用kubernetes配置映射，第1部分:卷挂载</h1>
<blockquote>原文：<a href="https://itnext.io/working-with-kubernetes-configmaps-part-1-volume-mounts-f0ace283f5aa?source=collection_archive---------0-----------------------#2021-02-16">https://itnext.io/working-with-kubernetes-configmaps-part-1-volume-mounts-f0ace283f5aa?source=collection_archive---------0-----------------------#2021-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5249" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些想法。</p><p id="20a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您编写在kubernetes上运行的应用程序，那么您至少有机会顺便(或更多)熟悉golang。Kubernetes毕竟是用go编写的，围绕kubernetes/docker涌现出了许多也是用go编写的工具，go在更广泛的云开发社区中获得了很大的吸引力。</p><p id="dd1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您编写在kubernetes上运行的应用程序，那么您几乎100%会对configmaps有所了解(如果您不了解，您是如何做到这一点的)。</p><p id="18b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置映射对于在kubernetes上运行应用程序是必不可少的，因为它们提供了管理应用程序配置的主要机制。还有其他的(例如容器规范中的环境变量)，但是使用配置映射有足够的优势，大多数开发人员最终会习惯使用它们。</p><p id="cdc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我开始写这篇文章的目的是假设你对configmap的基础知识相当熟悉，并快速了解使用<code class="fe kl km kn ko b">knative.dev/pkg/configmap</code>包是多么容易。(确实如此，我将会谈到这一点，只是没有之前预想的那么快)。但是今天我和一个新的开发人员一起工作，她是我们从大学毕业就为我们团队雇佣的，她几周前才加入我们。很明显，我认为理所当然的概念，至少对kubernetes新手来说，并不像我认为的那样简单，我认为我们应该从应用程序如何与配置图交互的背景开始。</p><h1 id="5f74" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">背景</h1><p id="1bb7" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">首先，我们需要回顾一些关于如何使用<code class="fe kl km kn ko b">kubectl</code>创建配置图的基础知识。我将介绍从文件创建配置图的两种方法，以及结果配置图之间的结构差异。你可以在官方的kubernetes文档<a class="ae ls" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" rel="noopener ugc nofollow" target="_blank">中找到更多关于创建配置图的例子和信息。</a></p><p id="927c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下所有示例中使用的代码(包括应用程序和脚本)和文件都可以在我位于https://github.com/ScarletTanager/configmap-watcher-example的资源库中找到。您可以自由地使用和修改我放在这里的任何示例，当我探索一些在go中操作/读取配置映射的进一步技术时，我可能会添加更多的示例。如果您只想运行示例，那么您可以通过将环境变量<code class="fe kl km kn ko b">REGISTRY</code>的值设置为docker Hub注册表并从存储库根目录运行<code class="fe kl km kn ko b">build</code>脚本来为示例创建Docker映像。这将创建并推送三个docker映像，每个示例应用程序一个。</p><p id="8426" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还将在<code class="fe kl km kn ko b">knative.dev/pkg/configmap</code>中展示和讨论一小部分代码，因为该包也提供了说明性的例子和一些非常易于使用的类型/函数来为configmaps工作。</p><h1 id="21e2" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">创建配置映射并通过卷装载使用它</h1><p id="a7ab" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">访问存储在配置图中的信息有两种主要方法。第一种方法是将configmap作为卷挂载到应用程序容器中，然后您可以使用标准的文件I/O调用来读取它。第二个是通过kubernetes API检索配置图。我不打算讨论这两种方法的优缺点——它们都有自己的位置，我在自己的代码中使用了这两种方法。</p><p id="4d74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数人需要做的第一件事是在应用程序启动时加载配置图。由于kubernetes使得将配置图挂载为一个卷成为可能，让我们看看这是如何实现的。在<code class="fe kl km kn ko b">configmap-watcher-example</code>存储库中有一个文件<code class="fe kl km kn ko b">clusters.properties</code>，它包含一组<code class="fe kl km kn ko b">key=value</code>对，如下所示:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="af81" class="mb kq iq ko b gy mc md l me mf">current.target=cluster1.endpoint<br/>cluster1.endpoint=<a class="ae ls" href="https://foo.com" rel="noopener ugc nofollow" target="_blank">https://foo.com</a><br/>cluster2.endpoint=<a class="ae ls" href="https://bar.com" rel="noopener ugc nofollow" target="_blank">https://bar.com</a><br/>cluster3.endpoint=<a class="ae ls" href="https://foobar.com" rel="noopener ugc nofollow" target="_blank">https://foobar.com</a><br/>cluster4.endpoint=<a class="ae ls" href="https://free.willy" rel="noopener ugc nofollow" target="_blank">https://free.willy</a><br/>cluster5.endpoint=<a class="ae ls" href="https://take.me.to.funkytown" rel="noopener ugc nofollow" target="_blank">https://take.me.to.funkytown</a></span></pre><p id="159d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您运行命令<code class="fe kl km kn ko b">kubectl create cm clusters-config-env --from-env-file=clusters.properties</code>，您将得到一个配置图，其<code class="fe kl km kn ko b">data</code>部分如下所示:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="5651" class="mb kq iq ko b gy mc md l me mf">data:<br/>  cluster1.endpoint: <a class="ae ls" href="https://foo.com" rel="noopener ugc nofollow" target="_blank">https://foo.com</a><br/>  cluster2.endpoint: <a class="ae ls" href="https://bar.com" rel="noopener ugc nofollow" target="_blank">https://bar.com</a><br/>  cluster3.endpoint: <a class="ae ls" href="https://foobar.com" rel="noopener ugc nofollow" target="_blank">https://foobar.com</a><br/>  cluster4.endpoint: <a class="ae ls" href="https://free.willy" rel="noopener ugc nofollow" target="_blank">https://free.willy</a><br/>  cluster5.endpoint: <a class="ae ls" href="https://take.me.to.funkytown" rel="noopener ugc nofollow" target="_blank">https://take.me.to.funkytown</a><br/>  current.target: cluster1.endpoint</span></pre><p id="439b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以使用与<em class="mg">几乎</em>相同的命令<code class="fe kl km kn ko b">kubectl create cm clusters-config-file --from-file=clusters.properties</code>创建一个配置图，我们最终会得到稍微不同的结果:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="1f90" class="mb kq iq ko b gy mc md l me mf">data:<br/>  clusters.properties: |<br/>    current.target=cluster1.endpoint<br/>    cluster1.endpoint=<a class="ae ls" href="https://foo.com" rel="noopener ugc nofollow" target="_blank">https://foo.com</a><br/>    cluster1.name=mycluster<br/>    cluster2.endpoint=<a class="ae ls" href="https://bar.com" rel="noopener ugc nofollow" target="_blank">https://bar.com</a><br/>    cluster3.endpoint=<a class="ae ls" href="https://foobar.com" rel="noopener ugc nofollow" target="_blank">https://foobar.com</a><br/>    cluster4.endpoint=<a class="ae ls" href="https://free.willy" rel="noopener ugc nofollow" target="_blank">https://free.willy</a><br/>    cluster5.endpoint=<a class="ae ls" href="https://take.me.to.funkytown" rel="noopener ugc nofollow" target="_blank">https://take.me.to.funkytown</a></span></pre><p id="d271" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有什么区别？</p><p id="338d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一种情况下，我们使用了<code class="fe kl km kn ko b">--from-env-file</code>标志——使用该标志要求文件内容采用<code class="fe kl km kn ko b">key=value</code>对的形式，每行一个(标准的环境文件格式)。在<code class="fe kl km kn ko b">data</code>部分，键与文件中出现的键相同——所以我们的映射与原始文件具有相同的键/值对。</p><p id="b774" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二个例子中，我们使用了<code class="fe kl km kn ko b">--from-file</code>标志。有了这个标志，文件内容格式就没有真正的限制了。为什么？看上面第二张地图的<code class="fe kl km kn ko b">data</code>部分，名为<code class="fe kl km kn ko b">clusters-config-file</code>:只有<strong class="jp ir">一个</strong>键存在，而且是原文件的名字:<code class="fe kl km kn ko b">clusters.json</code>。因此，只有一个值，该值是包含文件全部内容(包括换行符)的单个字符串。</p><p id="609d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么这很重要？因为如何创建配置映射将影响如何从应用程序中读取其内容。我们将在以下章节中参考<code class="fe kl km kn ko b">clusters-config-file</code>和<code class="fe kl km kn ko b">clusters-config-env</code>配置图。</p><h1 id="c617" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">将配置图装入应用程序容器</h1><p id="2fb9" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">在我们第一次尝试读取配置图时，我们将在kubernetes中创建一个应用程序，并对其进行配置，使其能够从文件挂载中读取配置图。我们将创建一个使用<code class="fe kl km kn ko b">cm-loader</code>映像(使用我前面提到的<code class="fe kl km kn ko b">build</code>脚本构建和上传)的pod，将configmap <code class="fe kl km kn ko b">clusters-config</code>挂载为一个卷，然后将该卷挂载到主应用程序容器中。完成这些工作的pod规范的yaml代码片段如下所示(我去掉了任何不直接相关的内容，实际的pod规范将包含更多信息):</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="70bb" class="mb kq iq ko b gy mc md l me mf">spec:<br/>  containers:<br/>    image: index.docker.io/sandycash/cm-loader<br/>    volumeMounts:<br/>    - mountPath: /clusters-config<br/>      name: clusters-config-volume<br/>  volumes:<br/>    - configMap:<br/>        name: clusters-config-file<br/>      name: clusters-config-volume</span></pre><p id="f087" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该代码片段指定执行以下操作:</p><ol class=""><li id="8e7b" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">使用DockerHub中的指定图像创建一个容器；</li><li id="b76c" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">使配置图<code class="fe kl km kn ko b">clusters-config-file</code>成为名为<code class="fe kl km kn ko b">clusters-config-volume</code>的可挂载卷；和</li><li id="13e3" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">将该卷装入路径为<code class="fe kl km kn ko b">/clusters-config</code>的容器</li></ol><p id="4fa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在第一个例子中使用的应用程序是从我的存储库中的<code class="fe kl km kn ko b">load/load.go</code>源文件构建的——下面是源代码:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="ea61" class="mb kq iq ko b gy mc md l me mf">package main</span><span id="41d5" class="mb kq iq ko b gy mv md l me mf">import (<br/> "encoding/json"<br/> "fmt"<br/> "net/http"</span><span id="9fc1" class="mb kq iq ko b gy mv md l me mf">"knative.dev/pkg/configmap"<br/>)</span><span id="c78d" class="mb kq iq ko b gy mv md l me mf">const (<br/> CM_NAME = "clusters-config"<br/>)</span><span id="024a" class="mb kq iq ko b gy mv md l me mf">var (<br/> namespace string<br/>)</span><span id="1a85" class="mb kq iq ko b gy mv md l me mf">func main() {<br/> cfg, err := configmap.Load(CM_NAME)<br/> if err != nil {<br/>  panic("Unable to load config map!")<br/> } else {<br/>  http.HandleFunc("/config", func(w http.ResponseWriter, r *http.Request) {<br/>   body, err := json.Marshal(cfg)<br/>   if err != nil {<br/>    w.WriteHeader(http.StatusInternalServerError)<br/>   } else {<br/>    w.WriteHeader(http.StatusOK)<br/>    w.Write(body)<br/>   }<br/>  })<br/> }</span><span id="1826" class="mb kq iq ko b gy mv md l me mf">fmt.Printf("Listening on port 8080\n")<br/> http.ListenAndServe(":8080", nil)<br/>}</span></pre><p id="0815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个非常简单的应用程序。它使用knative的<code class="fe kl km kn ko b">configmap</code>包中的<code class="fe kl km kn ko b">Load()</code>方法加载一个configmap我将在这里暂停一下，说这是一种简单而有用的方法，我们许多人已经(重新)实现了几十次，现在我再也不会实现它了。该方法将配置图的数据部分作为类型<code class="fe kl km kn ko b">map[string]string</code>的值返回。然后，应用程序创建一个HTTP处理程序，该处理程序简单地将地图整理成JSON并打印出来。如果我们<code class="fe kl km kn ko b">curl</code>这个应用程序上的<code class="fe kl km kn ko b">/config</code>端点并将结果传输到<code class="fe kl km kn ko b">jq</code>(只是为了格式化)，我们会得到:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="9d18" class="mb kq iq ko b gy mc md l me mf">{<br/>  "clusters.properties": "current.target=cluster1.endpoint\ncluster1.endpoint=<a class="ae ls" href="https://foo.com\ncluster1.name=mycluster\ncluster2.endpoint=https://bar.com\ncluster3.endpoint=https://foobar.com\ncluster4.endpoint=https://free.willy\ncluster5.endpoint=https://take.me.to.funkytown\n" rel="noopener ugc nofollow" target="_blank">https://foo.com\ncluster1.name=mycluster\ncluster2.endpoint=https://bar.com\ncluster3.endpoint=https://foobar.com\ncluster4.endpoint=https://free.willy\ncluster5.endpoint=https://take.me.to.funkytown\n</a>"<br/>}</span></pre><p id="9d94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像configmap本身一样:一个键，它是原始文件的名称，一个值——文件的全部内容是一个字符串，包括换行符。</p><p id="5e3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们运行我们的应用程序，但是安装<code class="fe kl km kn ko b">clusters-config-env</code>地图，这需要将pod规范的<code class="fe kl km kn ko b">volumes</code>部分改为:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="e9eb" class="mb kq iq ko b gy mc md l me mf">spec:<br/>  [snip]<br/>  volumes:<br/>    - configMap:<br/>        name: clusters-config-env<br/>      name: clusters-config-volume</span></pre><p id="b2b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不需要改变<code class="fe kl km kn ko b">volumeMounts</code>部分，因为我们正在挂载不同的地图，但是<em class="mg">在相同的挂载点</em>。当我们现在向<code class="fe kl km kn ko b">/config</code>端点发出GET调用时，我们得到:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="704d" class="mb kq iq ko b gy mc md l me mf">{<br/>  "cluster1.endpoint": "<a class="ae ls" href="https://foo.com" rel="noopener ugc nofollow" target="_blank">https://foo.com</a>",<br/>  "cluster1.name": "mycluster",<br/>  "cluster2.endpoint": "<a class="ae ls" href="https://bar.com" rel="noopener ugc nofollow" target="_blank">https://bar.com</a>",<br/>  "cluster3.endpoint": "<a class="ae ls" href="https://foobar.com" rel="noopener ugc nofollow" target="_blank">https://foobar.com</a>",<br/>  "cluster4.endpoint": "<a class="ae ls" href="https://free.willy" rel="noopener ugc nofollow" target="_blank">https://free.willy</a>",<br/>  "cluster5.endpoint": "<a class="ae ls" href="https://take.me.to.funkytown" rel="noopener ugc nofollow" target="_blank">https://take.me.to.funkytown</a>",<br/>  "current.target": "cluster1.endpoint"<br/>}</span></pre><p id="9d82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像在原始的<code class="fe kl km kn ko b">clusters-config-env</code> configmap的<code class="fe kl km kn ko b">data</code>部分一样，我们为原始文件中的每一对都有一个键/值对。</p><p id="c18d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，我明白了，但我为什么要在乎呢？</p><p id="dca1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简短的回答是，因为每个选项更适合不同的情况，而且，正如我之前所说的，您选择哪个选项将影响您如何使用配置图。</p><p id="a8a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们讨论这些方法的优缺点之前，让我们先简单地了解一下为什么会这样——为什么一种方法甚至使用文件名作为键，而另一种方法实际上解析文件？</p><h1 id="7ef1" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">configmap卷装载的工作方式</h1><p id="633b" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">要回答前面的问题，我们需要考虑“将配置图作为卷挂载”意味着什么如果您还记得，我们将我们的挂载点指定为<code class="fe kl km kn ko b">/clusters-config</code>——这是您的应用程序在通过文件系统访问这个配置图时将引用的名称。一个关键的方面是<em class="mg">挂载点总是目录</em>。因此应用程序实际上将配置图视为包含一个或多个文件的目录(假设您的配置图的<code class="fe kl km kn ko b">data</code>部分不为空)。这些文件来自哪里？我们从未创建过任何“文件”，不是吗？</p><p id="10a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是这样的:配置图中的每个键都作为配置图挂载点下的一个单独的文件公开。即使该值只是一个相对较短的字符串，就像我们的<code class="fe kl km kn ko b">clusters-config-env</code>映射中的情况一样，每个键都将作为一个单独的文件出现，并且该文件的内容将是该键在原始配置映射中的值。</p><p id="f432" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的<code class="fe kl km kn ko b">clusters-config-file</code>映射中，单个键(原始文件的名称)显示为一个文件…与原始文件同名。内容是…原始文件的内容。因此，在这种情况下，对这些内容的解析完全留给了应用程序。但是<code class="fe kl km kn ko b">clusters-config-env</code>有多个键/值对，这意味着多个(相比之下非常小)文件。</p><p id="150b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了说明这一点，让我们看看<code class="fe kl km kn ko b">knative.dev/pkg/configmap.Load()</code>的源代码:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="9f30" class="mb kq iq ko b gy mc md l me mf">func Load(p string) (map[string]string, error) {<br/> data := make(map[string]string)<br/> err := filepath.Walk(p, func(p string, info os.FileInfo, err error) error {<br/>  if err != nil {<br/>   return err<br/>  }<br/>  for info.Mode()&amp;os.ModeSymlink != 0 {<br/>   dirname := filepath.Dir(p)<br/>   p, err = os.Readlink(p)<br/>   if err != nil {<br/>    return err<br/>   }<br/>   if !filepath.IsAbs(p) {<br/>    p = path.Join(dirname, p)<br/>   }<br/>   info, err = os.Lstat(p)<br/>   if err != nil {<br/>    return err<br/>   }<br/>  }<br/>  if info.IsDir() {<br/>   return nil<br/>  }<br/>  b, err := ioutil.ReadFile(p)<br/>  if err != nil {<br/>   return err<br/>  }<br/>  data[info.Name()] = string(b)<br/>  return nil<br/> })<br/> return data, err<br/>}</span></pre><p id="ca38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">Load()</code>采用单个参数——应用程序已知的配置图的“名称”,这意味着卷的挂载点。它将configmap的内容作为一个<code class="fe kl km kn ko b">map[string]string</code>返回。为了构建该地图，它执行以下操作:</p><ol class=""><li id="8de1" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">它创建一个映射来保存返回值。</li><li id="9eeb" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">它调用<code class="fe kl km kn ko b">filepath.Walk()</code> —这个函数从最顶端的节点开始，遍历一个目录树。它有两个参数:一个是起始路径(我们的configmap挂载点)，另一个是回调函数，该函数为树中的每个节点调用一次。</li><li id="cdee" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">回调有三个参数:当前节点的路径、文件名和一个错误(例如，没有足够的权限<code class="fe kl km kn ko b">stat()</code>该文件)。回调执行以下操作:<br/> 1 .如果我们遇到错误，返回(跳过这个节点)。<br/> 2。如果节点是一个符号链接，获取目标，规范化路径，然后尝试<code class="fe kl km kn ko b">stat()</code>目标。<br/> 3。如果节点是一个目录，跳过它(我们只关心常规文件)。<br/> 4。读取文件的内容，然后将它们作为一个值添加到我们的地图中，以文件名作为关键字。</li></ol><h1 id="7e9c" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">我应该使用哪种方法，何时使用？</h1><p id="9c2e" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">当创建要作为卷装载的配置图时，在某些情况下只有一个选项就可以了。一个明显的例子是，如果您的文件不是有效的<code class="fe kl km kn ko b">env</code>类型格式(意味着它不是一组<code class="fe kl km kn ko b">key=value</code>对，每行一个)。例如，如果您在JSON或YAML中有一个配置文件，则不能将这些文件中的单个值直接作为配置映射中的值公开。因此，除非您想在创建映射之前预处理您的配置数据，否则您必须从配置映射中将每个文件作为单个条目单独加载，然后您的应用程序需要能够解组和使用内容本身。</p><p id="36f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了偏好之外，将配置存储为JSON或YAML的一个优点是能够将配置直接解组为某种结构化类型，这种类型可能有多个层次。所以让我们考虑一下文件<code class="fe kl km kn ko b">config.json:</code></p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="ce35" class="mb kq iq ko b gy mc md l me mf">{<br/>  "current": {<br/>    "target": "cluster1"<br/>  }<br/>}</span></pre><p id="23d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和<code class="fe kl km kn ko b">clusters.json</code>:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="5d48" class="mb kq iq ko b gy mc md l me mf">{<br/>  "cluster1": {<br/>    "endpoint": "<a class="ae ls" href="https://foo.com" rel="noopener ugc nofollow" target="_blank">https://foo.com</a>"<br/>  },<br/>  "cluster2": {<br/>    "endpoint": "<a class="ae ls" href="https://bar.com" rel="noopener ugc nofollow" target="_blank">https://bar.com</a>"<br/>  },<br/>  "cluster3": {<br/>    "endpoint": "<a class="ae ls" href="https://foobar.com" rel="noopener ugc nofollow" target="_blank">https://foobar.com</a>"<br/>  },<br/>  "cluster4": {<br/>    "endpoint": "<a class="ae ls" href="https://free.willy" rel="noopener ugc nofollow" target="_blank">https://free.willy</a>"<br/>  },<br/>  "cluster5": {<br/>    "endpoint": "<a class="ae ls" href="https://take.me.to.funkytown" rel="noopener ugc nofollow" target="_blank">https://take.me.to.funkytown</a>"<br/>  }<br/>}</span></pre><p id="0033" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些都是将<code class="fe kl km kn ko b">clusters.properties</code>(不是唯一可能的)改写成一对JSON文件的琐碎工作。也许我们希望将这些解组成类似(同样，不是唯一的可能性):</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="36c9" class="mb kq iq ko b gy mc md l me mf">type MyConfig struct {<br/>  Current HostSpecification `json:"current"`<br/>}</span><span id="9643" class="mb kq iq ko b gy mv md l me mf">type HostSpecification struct {<br/>  Endpoint string `json:"endpoint,omitempty"`<br/>  Target   string `json:"target,omitempty"`<br/>}</span><span id="df36" class="mb kq iq ko b gy mv md l me mf">type Clusters map[string]HostSpecification</span></pre><p id="6f64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我可以将这两个配置文件存储在一个配置图中，如下所示:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="972e" class="mb kq iq ko b gy mc md l me mf">apiVersion: v1<br/>kind: ConfigMap<br/>data:<br/>  clusters.json: |<br/>    {<br/>      "cluster1": {<br/>        "endpoint": "<a class="ae ls" href="https://foo.com" rel="noopener ugc nofollow" target="_blank">https://foo.com</a>"<br/>      },<br/>      "cluster2": {<br/>        "endpoint": "<a class="ae ls" href="https://bar.com" rel="noopener ugc nofollow" target="_blank">https://bar.com</a>"<br/>      },<br/>      "cluster3": {<br/>        "endpoint": "<a class="ae ls" href="https://foobar.com" rel="noopener ugc nofollow" target="_blank">https://foobar.com</a>"<br/>      },<br/>      "cluster4": {<br/>        "endpoint": "<a class="ae ls" href="https://free.willy" rel="noopener ugc nofollow" target="_blank">https://free.willy</a>"<br/>      },<br/>      "cluster5": {<br/>        "endpoint": "<a class="ae ls" href="https://take.me.to.funkytown" rel="noopener ugc nofollow" target="_blank">https://take.me.to.funkytown</a>"<br/>      }<br/>    }<br/>  config.json: |<br/>    {<br/>      "current": {<br/>        "endpoint": "cluster1"<br/>      }<br/>    }<br/>metadata:<br/>  name: clusters-config-multiple-files</span></pre><p id="0cce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们挂载地图并对应用程序的<code class="fe kl km kn ko b">/config</code>端点发出GET命令时，我们得到的结果是可以预见的:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="bd40" class="mb kq iq ko b gy mc md l me mf">{<br/>  "clusters.json": "{\n  \"cluster1\": {\n    \"endpoint\": \"<a class="ae ls" href="https://foo.com\" rel="noopener ugc nofollow" target="_blank">https://foo.com\</a>"\n  },\n  \"cluster2\": {\n    \"endpoint\": \"<a class="ae ls" href="https://bar.com\" rel="noopener ugc nofollow" target="_blank">https://bar.com\</a>"\n  },\n  \"cluster3\": {\n    \"endpoint\": \"<a class="ae ls" href="https://foobar.com\" rel="noopener ugc nofollow" target="_blank">https://foobar.com\</a>"\n  },\n  \"cluster4\": {\n    \"endpoint\": \"<a class="ae ls" href="https://free.willy\" rel="noopener ugc nofollow" target="_blank">https://free.willy\</a>"\n  },\n  \"cluster5\": {\n    \"endpoint\": \"<a class="ae ls" href="https://take.me.to.funkytown\" rel="noopener ugc nofollow" target="_blank">https://take.me.to.funkytown\</a>"\n  }\n}\n",<br/>  "config.json": "{\n  \"current\": {\n    \"endpoint\": \"cluster1\"\n  }\n}\n"<br/>}</span></pre><p id="acf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以加载如下内容:</p><pre class="lt lu lv lw gt lx ko ly lz aw ma bi"><span id="6544" class="mb kq iq ko b gy mc md l me mf">cfgData, _ := configmap.Load("clusters-config-multiple-files")</span><span id="6c92" class="mb kq iq ko b gy mv md l me mf">var myConfig MyConfig<br/>json.Unmarshal(cfgData["config.json"], &amp;myConfig)</span><span id="feef" class="mb kq iq ko b gy mv md l me mf">clusters := make(Clusters)<br/>json.Unmarshal(cfgData["clusters.json"], &amp;clusters)</span></pre><p id="16eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以总而言之:</p><ol class=""><li id="9ffc" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">如果您有一个相对简单的配置，或者您希望通过一个键直接访问每个值，而不需要维护潜在的多个数据类型来存储您的配置，请使用env文件格式，其中configmap是从配置键到值的直接映射。</li><li id="9ccd" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">如果您有一个不止一层的配置，您可以在环境风格的配置中使用带点的属性名(这就是我们在<code class="fe kl km kn ko b">clusters.properties</code>中所做的),并使用<code class="fe kl km kn ko b">--from-env-file=&lt;PATH&gt;</code>语法加载您的configmap。然后，您可以像在(1)中那样继续通过按键直接访问这些值。</li><li id="01bb" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">如果您的配置不止一层，和/或您更喜欢在JSON/YAML中维护它，例如，因为这有助于直接在您自己的数据类型中解组(通常但不总是<code class="fe kl km kn ko b">structs</code>)，您的configmap将文件内容存储为blob，您将使用<code class="fe kl km kn ko b">--from-file=&lt;PATH&gt;</code>语法创建它。</li><li id="6873" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">如果您有多个配置文件(任何格式)，并且您想将它们都存储在一个configmap中，那么最简单的方法就是使用一个类似于上面的示例<code class="fe kl km kn ko b">clusters-config-multiple-files</code>的规范来创建您的configmap，然后您可以自动检索每个文件的内容作为给定键的值，并相应地处理它们。</li></ol><h1 id="79aa" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">在第2部分中…</h1><p id="2f38" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">我将把注意力转向通过Kubernetes API加载配置映射——直接使用Kubernetes客户端和knative的<code class="fe kl km kn ko b">configmap</code>包提供的其他工具。我将特别关注一些简单的模式，通过这些模式，您可以使您的应用程序能够动态地处理对配置图的更改，并且如果有人意外删除了配置图，那么<em class="mg">和</em>不会受到影响。</p></div></div>    
</body>
</html>