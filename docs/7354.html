<html>
<head>
<title>Microservices with Serverless Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有无服务器框架的微服务</h1>
<blockquote>原文：<a href="https://itnext.io/microservices-with-serverless-framework-3a4ee4d721ed?source=collection_archive---------0-----------------------#2022-08-30">https://itnext.io/microservices-with-serverless-framework-3a4ee4d721ed?source=collection_archive---------0-----------------------#2022-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b5c2d8d5163c70c1db110f1ec8307683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EaUG2KLUEBugWyww9yETBg.jpeg"/></div></div></figure><p id="f75e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建易于扩展的解决方案似乎总是将架构放在微服务上；然而，当试图采用减少基础设施和利用AWS Lambda等技术的更多无服务器解决方案时，这似乎有点棘手。经过多次实验后，我将尝试为我的项目设计一个可行的解决方案。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="ba98" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">不要被困在教程中</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/676ad8dcf9367074dbfc80b9d10a4079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*tZbf9eE0QFkXvb8ci6O09w.jpeg"/></div></figure><p id="69f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很容易在网上找到一些很棒的教程，然后开始跟着做一些东西，但是这很快就会让你得到一个很棒的教程设计的解决方案，而不是你可以继续做下去的东西。依靠你的微服务经验，看看你想要达到的目标，这真的很重要</p><ol class=""><li id="81bb" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">一个独立且可单独测试的架构</li><li id="cf96" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">与服务相关的API，但是可以连接到一组更大的API</li><li id="7f41" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">由服务拥有和管理的数据</li></ol></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="5aff" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">分解任务</h1><p id="3af4" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">有些人可能会在这一点上与我争论，但我喜欢在单一回购中建立服务。它允许开发人员在代码库中看到服务的所有部分，但如果多人在一起工作，则需要良好的代码管理过程。我将给出一个我喜欢使用的文件夹结构。我也倾向于在VS代码中使用devContainers，并在文件夹顶部设置林挺，但我不会花任何时间来设置它。</p><pre class="mc md me mf gt mz na nb nc aw nd bi"><span id="29d3" class="ne le iq na b gy nf ng l nh ni">service/<br/>  layers/ # this is for any AWS layers that might be created<br/>  rest/ # outward facing REST APIs  <br/>  graphql/ # in case you have a graphql interface<br/>  logic/ # business logic based lambdas<br/>  libraries/ # in here is where I keep shared libraries<br/>  infrastructure/ # databases, message buses, etc</span></pre><p id="03ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要太在意文件夹的名字，那都是主观的，可能是有意义的，但是想法才是最重要的</p><p id="1df1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">层</strong></p><p id="c738" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不会在这里花太多时间。这个文件夹用于设置我希望服务使用的任何AWS Lambda层。我尝试按服务创建图层，即使这意味着服务之间存在重叠。它允许你以这种方式更新版本而不会给其他服务带来风险。如果你不用图层，但是用了Lambdas，我真的建议你看一看。</p><p id="c086" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> REST和Graphql </strong></p><p id="6a89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很明显，对吗？你的API有自己的文件夹。在这里的设计中需要注意的重要一点是，您的API只有一个任务，即认证、授权和验证来自服务外部的输入。我们将到达逻辑文件夹，但是一般的方法是API不应该直接与基础设施(数据库、消息总线、S3等)交互。这样做是为了给基础设施提供一些保护。API有问题，通过使用这种分层的方法，你确实会因为多个lambda调用而导致更多的延迟(你可以用warmers来缩短这个时间)，但是你可以得到一个很大的好处，那就是能够收紧它们可以与之对话的权限。</p><p id="555a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种责任的中断还允许以两种方式使用lambdas，等待响应以便可以发送回数据，或者只是向lambda发送一些不需要响应的数据，以便可以更快地返回给用户。</p><p id="7b8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一件事是让API独立，这样你就可以在service.example.com得到请求。通过这种方式，API是完全隔离的，您可以在不中断大量代码的情况下替换它。在AWS中，你可以把它和CloudFront捆绑在一起。在这一点上，我认为总是使用区域端点。为什么你会问？你可以通过手动设置一个CloudFront发行版来实现与全局端点相同的功能，这样你就有更多的能力来以你想要的方式配置它。</p><p id="c4fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">逻辑</strong></p><p id="d7d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是橡胶接触路面的地方。你把所有的处理能力都放在这里，与基础设施连接。通过将这一点从API代码中分离出来，您可以在不同的API(REST和Graphql)中利用相同的代码，使用不同于API的语言，并在进行更改时将测试覆盖范围减少到逻辑而不是API。</p><p id="9a79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用无服务器将它们分解到自己的部署中，您还可以在控制台中直接访问它们进行测试，或者将它们链接到管理仪表板。</p><p id="e411" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">基础设施</strong></p><p id="7aa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当使用无服务器框架时，你可以在yml文件中完全定义你的资源，我也支持这样做，但是有一些警告:</p><ol class=""><li id="0c09" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">仅定义可以移除的基础架构。像SNS，Eventbridge等服务，你可以删除而不会丢失数据，这是很好的选择。真的想一想，如果您在您的平台中丢弃了一个SQS队列或一个DynamoDB用户。你可能会处于恐慌状态。</li><li id="4798" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">确保导出您构建的任何内容，以便可以在其他服务中使用。设置一个创建命名导出的资源部分可以非常方便地从服务的其他部分更快地引用基础设施。也就是说，这并不重要，因为您可以动态创建ARNs。</li></ol><p id="ef51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还发现了一些其他的事情，总是用你的艺名来命名你的基础设施资源。像storeTable-dev和petsTable-dev这样的东西可以帮助你知道你在接触什么，并且让开发者用一个专门为他们测试新变化的平台来提升服务。当进行单元测试时，它进入了一个没有更多模仿的世界，但是我不打算在这里深入讨论这个问题。</p><p id="9c70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定义更加数据安全的基础设施时，您可以使用Terraform、Cloudformation或AWS CLI(通过脚本)来完成。只要确保在您的部署脚本中，您可以有选择地构建测试环境，但不要通过代码更改来部署它。在可能的情况下，总是放上云状标志，这样你就不会犯错误而想在岩石下爬行。</p><h1 id="b54f" class="ld le iq bd lf lg nj li lj lk nk lm ln lo nl lq lr ls nm lu lv lw nn ly lz ma bi translated">那是一个包裹</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/9616ed766ef86286964933565754e533.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*CLOU7p8RluDz24IJsgFj1A.png"/></div></figure><p id="4ce7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这些学习对你有所帮助。一如既往，我喜欢了解人们对不同事物的看法，所以请添加评论，这样我们就可以互相学习彼此的经验。如果你看到我们团队没有想到的东西，请大声说出来。</p><p id="341d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果你来这里寻找一个详细的一步一步设置微服务抱歉，这没有击中目标，但如果人们想了解更多的细节设置，我可以看到一个多部分的文章。</p></div></div>    
</body>
</html>