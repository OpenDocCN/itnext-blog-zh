<html>
<head>
<title>Searching in Your IndexedDB Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在索引数据库中搜索</h1>
<blockquote>原文：<a href="https://itnext.io/searching-in-your-indexeddb-database-d7cbf202a17?source=collection_archive---------0-----------------------#2018-10-04">https://itnext.io/searching-in-your-indexeddb-database-d7cbf202a17?source=collection_archive---------0-----------------------#2018-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/af3fd96338f927c62f9bcc863c8983f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SoRt06-YX3GNLgQSGr0TYw.jpeg"/></div></div></figure><div class=""/><p id="2783" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">这是我上一篇</em>  <em class="kw">关于IndexedDB入门的</em> <a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/getting-started-with-persistent-offline-storage-with-indexeddb-1af66727246c"> <em class="kw">的延续。如果您不熟悉IndexedDB，请阅读该文章以熟悉它的基础知识。</em></a></p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="7091" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">IndexedDB是一个非常棒的文档存储数据库，可以离线保存数据，并具有所有基本CRUD操作的原生功能。使用任何数据库的下一步(可能更重要)是如何在其中找到数据？我们已经看到，当我们知道创建数据的关键路径时，IndexedDB如何检索数据。但是，当我们想要搜索包含特定文本或满足特定条件的文档时，该怎么办呢？</p><p id="d257" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，答案是…不像做CRUD那么容易。</p><p id="3d9e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">IndexedDB的不幸问题是它没有本地搜索功能。在使用了Mongo等其他NoSQL数据库后，这有点令人失望，因为使用他们的API查找文档太容易了。为了进行任何类型的搜索，我们必须自己使用我们可用的基本构件来实现它。</p><p id="a8a7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就引出了对<em class="kw">光标</em>的讨论。</p><h1 id="9e7a" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">光标到底是什么？</h1><p id="c21f" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">简而言之，游标是一个指针，它遍历给定数据存储或索引中的所有文档，并且在每次迭代中显示当前“指向”的文档的数据。它还包含一些额外的元数据和一些方法。</p><p id="3d34" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在MDN，上阅读cursor <a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor" rel="noopener ugc nofollow" target="_blank">的完整规格，但出于我们的目的，我们对以下属性和方法感兴趣:</a></p><ul class=""><li id="4a2d" class="mi mj jb ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated"><code class="fe mr ms mt mu b">primaryKey</code>:定义了存储中某个对象的关键路径</li><li id="6580" class="mi mj jb ka b kb mv kf mw kj mx kn my kr mz kv mn mo mp mq bi translated"><code class="fe mr ms mt mu b">value</code>:文件本身</li><li id="4f38" class="mi mj jb ka b kb mv kf mw kj mx kn my kr mz kv mn mo mp mq bi translated"><code class="fe mr ms mt mu b">continue()</code>:移动到下一个文档的指令</li><li id="03de" class="mi mj jb ka b kb mv kf mw kj mx kn my kr mz kv mn mo mp mq bi translated"><code class="fe mr ms mt mu b">delete()</code>:删除当前文档的指令</li><li id="55cd" class="mi mj jb ka b kb mv kf mw kj mx kn my kr mz kv mn mo mp mq bi translated"><code class="fe mr ms mt mu b">update()</code>:更新当前文档的指令</li></ul><p id="b128" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中一些(尤其是我在MDN中遗漏的)或多或少会很重要，这取决于您的用例是什么，但是我想展示几个最重要的技术，因为尽管IndexedDB有点笨拙，但光标是一个强大的工具。</p><h1 id="7270" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在我们的数据库里找到一个光标</h1><p id="a630" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在本文的其余部分，我们将使用我上一篇文章中的数据库(这里是<a class="ae kx" href="https://gist.github.com/ryandabler/41c458871cb6b64f599fb182ba88daba" rel="noopener ugc nofollow" target="_blank">代码</a>)以及来自<a class="ae kx" href="https://gist.github.com/ryandabler/3a0b2999e9e96045689de7ea0a7d5a3b" rel="noopener ugc nofollow" target="_blank">这个要点</a>的数据集作为我们数据库的种子，这样我们就有东西可以搜索了。</p><p id="ec78" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的数据库中有了数据，让我们打开一个游标。</p><pre class="na nb nc nd gt ne mu nf ng aw nh bi"><span id="d43a" class="ni lg jb mu b gy nj nk l nl nm">const request = window.indexedDB.open('database', 1);</span><span id="9bb7" class="ni lg jb mu b gy nn nk l nl nm">request.onsuccess = () =&gt; {<br/>    const db = request.result;<br/>    const transaction = db.transaction(['invoices'], 'readonly');<br/>    const invoiceStore = transaction.objectStore('invoices');<br/>    const getCursorRequest = invoiceStore.openCursor();</span><span id="5fd7" class="ni lg jb mu b gy nn nk l nl nm">    getCursorRequest.onsuccess = e =&gt; {<br/>        // Cursor logic here<br/>    }<br/>}</span></pre><p id="b717" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住IndexedDB是基于事件的，所以我们所有的请求都会触发<code class="fe mr ms mt mu b">onsuccess</code>事件，我们需要在这些事件中监听和实现我们的应用程序逻辑。在上面的代码中，如果数据库成功打开，我们将经历典型的IndexedDB链，即启动一个事务并提取一个对象存储。一旦我们有了商店，只需在上面打开一个光标。</p><p id="35b9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，因为打开游标是一个请求，所以我们必须处理它的<code class="fe mr ms mt mu b">onsuccess</code>来实现我们的游标逻辑。所以让我们打印出发票存储中的对象:</p><pre class="na nb nc nd gt ne mu nf ng aw nh bi"><span id="4038" class="ni lg jb mu b gy nj nk l nl nm">const request = window.indexedDB.open('database', 1);</span><span id="8d46" class="ni lg jb mu b gy nn nk l nl nm">request.onsuccess = () =&gt; {<br/>    const db = request.result;<br/>    const transaction = db.transaction(['invoices'], 'readonly');<br/>    const invoiceStore = transaction.objectStore('invoices');<br/>    const getCursorRequest = invoiceStore.openCursor();</span><span id="dc5b" class="ni lg jb mu b gy nn nk l nl nm">    getCursorRequest.onsuccess = e =&gt; {<br/>        const cursor = e.target.result;<br/>        if (cursor) {<br/>            console.log(cursor.value);<br/>            cursor.continue();<br/>        } else {<br/>            console.log('Exhausted all documents');<br/>        }<br/>    }<br/>}</span></pre><p id="f20b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于正在发生的事情，有几件重要的事情需要注意:</p><ul class=""><li id="7341" class="mi mj jb ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">我们将光标从<code class="fe mr ms mt mu b">onsuccess</code>事件上移开。</li><li id="f4e4" class="mi mj jb ka b kb mv kf mw kj mx kn my kr mz kv mn mo mp mq bi translated">我们可以通过<code class="fe mr ms mt mu b">value</code>属性访问光标所指向的对象存储中的文档，这可以从控制台日志中得到验证。</li><li id="02c8" class="mi mj jb ka b kb mv kf mw kj mx kn my kr mz kv mn mo mp mq bi translated">我们调用光标上的<code class="fe mr ms mt mu b">continue()</code>方法来移动到数据库中的下一项。</li><li id="9ae1" class="mi mj jb ka b kb mv kf mw kj mx kn my kr mz kv mn mo mp mq bi translated">我们需要检查光标是否确实存在。这很重要，因为当我们迭代到最后一个项目，并且调用了<code class="fe mr ms mt mu b">cursor.continue()</code>时，我们以一个<code class="fe mr ms mt mu b">null</code>值结束，表明我们已经遍历了存储中的每个文档，我们完成了。在上面的例子中，我们打印出我们已经用完了所有的文档，然后简单地退出事件处理程序。</li></ul><p id="efa2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个相当无聊的例子，所以让我们用游标做一些有趣的事情。</p><h1 id="3192" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">选择性地修改我们数据库中的文档</h1><h2 id="56ad" class="ni lg jb bd lh no np dn ll nq nr dp lp kj ns nt lt kn nu nv lx kr nw nx mb ny bi translated"><code class="fe mr ms mt mu b">update()</code></h2><p id="1db7" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">让我们假设我们的供应商GE与宝洁公司合并，成为一个新的实体P&amp;GE。为了使我们的数据库与这次合并保持同步，我们希望更新所有的发票以反映新的名称。</p><p id="243c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在发票存储上打开一个光标，检查供应商的名称是否是GE，如果是，则更新为P&amp;GE。</p><pre class="na nb nc nd gt ne mu nf ng aw nh bi"><span id="226d" class="ni lg jb mu b gy nj nk l nl nm">const request = window.indexedDB.open("database", 1);</span><span id="a8b9" class="ni lg jb mu b gy nn nk l nl nm">request.onsuccess = () =&gt; {<br/>    const db = request.result;<br/>    const transaction = db.transaction(['invoices'], 'readwrite');<br/>    const invStore = transaction.objectStore('invoices');<br/>    const cursorRequest = invStore.openCursor();</span><span id="da49" class="ni lg jb mu b gy nn nk l nl nm">    cursorRequest.onsuccess = e =&gt; {<br/>        const cursor = e.target.result;<br/>        if (cursor) {<br/>            if (cursor.value.vendor === 'GE') {<br/>                const invoice = cursor.value;<br/>                invoice.vendor = 'P&amp;GE';<br/>                const updateRequest = cursor.update(invoice);<br/>            }<br/>            cursor.continue();<br/>        }<br/>    }<br/>};</span></pre><p id="1590" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，当光标遍历商店时，我们检查文档的<code class="fe mr ms mt mu b">vendor</code>属性，看它是否匹配。如果是这样，我们从光标的<code class="fe mr ms mt mu b">value</code>键创建一个新的发票文档，更新我们想要的字段，并将这个新文档传递给光标上的<code class="fe mr ms mt mu b">update()</code>方法。</p><p id="4245" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调用<code class="fe mr ms mt mu b">update()</code>实际上会返回一个事务请求，所以如果我们想做任何进一步的动作(打印到控制台，调用另一个函数来更新应用程序状态，等等),我们可以在<code class="fe mr ms mt mu b">updateRequest</code>上放置一个<code class="fe mr ms mt mu b">onsuccess</code>处理程序。).我们不必要地将请求赋给了一个变量，以表明如果我们选择使用某样东西，它就在那里。</p><h1 id="7fc0" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从索引中获取游标</h1><p id="f7e5" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">我们上面的例子可以用一种稍微不同的方式来实现，这种方式实际上比遍历整个商店更有效。请记住，索引的存在是为了将特定键值都相等的文档组合在一起。因此，在上面，我们可以在一个索引上打开一个游标来定位这个特定的值。</p><pre class="na nb nc nd gt ne mu nf ng aw nh bi"><span id="16a6" class="ni lg jb mu b gy nj nk l nl nm">const request = window.indexedDB.open("database", 1);</span><span id="22d5" class="ni lg jb mu b gy nn nk l nl nm">request.onsuccess = () =&gt; {<br/>    const db = request.result;<br/>    const transaction = db.transaction(['invoices'], 'readwrite');<br/>    const invStore = transaction.objectStore('invoices');<br/>    const vendorIndex = invStore.index('VendorIndex');<br/>    const keyRng = IDBKeyRange.only('GE');<br/>    const cursorRequest = vendorIndex.openCursor(keyRng);</span><span id="7471" class="ni lg jb mu b gy nn nk l nl nm">    cursorRequest.onsuccess = e =&gt; {<br/>        const cursor = e.target.result;<br/>        if (cursor) {<br/>            const invoice = cursor.value;<br/>            invoice.vendor = 'P&amp;GE';<br/>            const updateRequest = cursor.update(invoice);<br/><br/>            cursor.continue();<br/>        }<br/>    }<br/>};</span></pre><p id="37f7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们做了一些小改动:</p><ul class=""><li id="b11b" class="mi mj jb ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">我们在发票存储上打开了先前定义的供应商索引的光标</li><li id="6e8a" class="mi mj jb ka b kb mv kf mw kj mx kn my kr mz kv mn mo mp mq bi translated">我们在打开光标时传递了一个可选的<code class="fe mr ms mt mu b">IDBKeyRange</code>参数，以定位我们想要的供应商。请注意两点:(1)如果我们没有传入这个参数，我们将会遍历整个对象存储，其中的文档按照索引的值按字典顺序排序(而在对象存储上打开的游标是按照其键路径的值排序的)。有许多可能的方法来定义一个键范围；完整列表可在<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/API/IDBKeyRange" rel="noopener ugc nofollow" target="_blank"> MDN </a>获得。(2)当我们在对象存储上定义游标时，我们也可以使用键范围。</li><li id="1b74" class="mi mj jb ka b kb mv kf mw kj mx kn my kr mz kv mn mo mp mq bi translated">我们不再需要在游标的每次迭代中检查供应商名称，因为我们保证只拥有我们想要更改的文档。</li></ul><h1 id="9237" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">同时打开多个游标</h1><p id="5ff1" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">游标的一个好处是可以同时打开多个。事实上，如果你想的话，你可以打开无限的号码(并且有足够的存储空间)。</p><p id="a798" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们假设我们的供应商Frigidaire倒闭了，我们不再需要向他们支付我们的发票。我们的数据库的构造方式意味着我们需要遍历我们的发票库(有选择地只选择Frigidaire发票)，对于该库中的每张发票，删除它以及它在发票项目库中的所有行项目。</p><pre class="na nb nc nd gt ne mu nf ng aw nh bi"><span id="558d" class="ni lg jb mu b gy nj nk l nl nm">const request = window.indexedDB.open("database", 1);</span><span id="8c7e" class="ni lg jb mu b gy nn nk l nl nm">request.onsuccess = () =&gt; {<br/>    const db = request.result;<br/>    const transaction = db.transaction(<br/>        ['invoices', 'invoice-items'],<br/>        'readwrite'<br/>    );<br/>    const invStore = transaction.objectStore('invoices');<br/>    const invItemStore = transaction.objectStore('invoice-items');</span><span id="fd29" class="ni lg jb mu b gy nn nk l nl nm">    // Get invoice cursor<br/>    const invoiceCursorRequest = invStore.index('VendorIndex')<br/>        .openCursor(IDBKeyRange.only('Frigidaire'));</span><span id="66fe" class="ni lg jb mu b gy nn nk l nl nm">    invoiceCursorRequest.onsuccess = e =&gt; {<br/>        const invCursor = e.target.result;<br/>        if (invCursor) {<br/>            // Get invoice item cursor<br/>            const invItemCursorRequest = invItemStore<br/>                .index('InvoiceIndex')<br/>                .openCursor(<br/>                    IDBKeyRange.only(invCursor.value.invoiceId)<br/>                );</span><span id="c23c" class="ni lg jb mu b gy nn nk l nl nm">            invItemCursorRequest.onsuccess = e =&gt; {<br/>                const invItemCursor = e.target.result;<br/>                if (invItemCursor) {<br/>                    invItemCursor.delete();<br/>                    invItemCursor.continue();<br/>                }<br/>            }<br/>            invCursor.delete();<br/>            invCursor.continue();<br/>        }<br/>    }<br/>};</span></pre><p id="1696" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，我们将发票项光标嵌套在外部发票光标的<code class="fe mr ms mt mu b">onsuccess</code>处理程序中，每个处理程序调用其<code class="fe mr ms mt mu b">delete()</code>方法，这将启动一个删除事务(就像上面的<code class="fe mr ms mt mu b">update()</code>调用一样)来删除底层文档。我们通过不将<code class="fe mr ms mt mu b">delete()</code>操作赋给变量来简化代码，因为我们不需要担心操作的任何成功/错误处理。</p><h1 id="b321" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="d85d" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">这实质上是使用游标和IndexedDB。这里的用例比我们在这里讨论的要多得多——比如在我们的文档上计算聚合数据——但是理解这里讨论的概念将使您能够实现数据库系统的所有功能。我将把这个要点作为我们对数据库所做的所有事情的一个工作示例。</p></div></div>    
</body>
</html>