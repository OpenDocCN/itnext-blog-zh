<html>
<head>
<title>Password Encryption — Hashing in Node Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">密码加密—节点应用中的哈希算法</h1>
<blockquote>原文：<a href="https://itnext.io/password-encryption-hashing-in-node-application-311a6f61cd65?source=collection_archive---------1-----------------------#2019-10-11">https://itnext.io/password-encryption-hashing-in-node-application-311a6f61cd65?source=collection_archive---------1-----------------------#2019-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3ec7742b0d0b0cfc3247131ad3147d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sCzX8lqeXiTJbFZrepanOg.png"/></div></div></figure><p id="5116" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论应用程序是大还是小，我们都需要在应用程序中加入一些登录功能。在当今的数字世界里<strong class="ka ir"> <em class="kw">保护密码</em> </strong>对用户来说是必须的。保护数据和信息的安全仍然是我们开发人员的重要职责。</p><p id="06a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开始使用存储在我们数据库中的散列密码构建端点之前。让我们弄清楚在web中用于散列纯文本的类似术语。</p><p id="f521" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">什么是加密？</strong></p><p id="348d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以只有拥有相应密钥的人才能读取的方式对信息进行加密的做法。它涉及双向功能。当我们加密某个东西时，你这样做是为了以后解密它。</p><p id="5214" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">什么是哈希？</strong></p><p id="ad81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用算法将任意大小的数据映射到固定长度的实践。结果是散列值/散列码/散列和。反向散列在技术上是可行的，但所需的计算能力使其不可行。</p><p id="9112" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哈希是一种方式，但加密有两种方式。加密是为了保护传输中的数据，哈希是为了验证文件或数据未被更改，即它是真实的。换句话说，它是一种校验和。</p><p id="01e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">什么是腌制？</strong></p><p id="29b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Salting是一个通常与密码哈希相关的概念。本质上，它是一个唯一的值，可以添加到密码的末尾来创建不同的哈希值。这为散列过程增加了一层安全性，特别是针对暴力攻击。腌制时，附加值被称为“盐”</p><p id="0d06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在密码末尾添加一个盐，然后对其进行哈希运算，我们实际上增加了识别密码的复杂性，并使我们的安全位更容易被破解。</p><h2 id="13c8" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">注册新用户</h2><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/6b9f40c1f61f7b10b9f5cbbaced72885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvj9Ho-uTQauU5r7PGeLwQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated"><a class="ae lz" href="https://auth0.com" rel="noopener ugc nofollow" target="_blank">来源:auth0 </a></figcaption></figure><p id="2ac7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将看看如何使我们的端点可以存储新用户到我们的数据库中的字段</p><blockquote class="ma"><p id="bad1" class="mb mc iq bd md me mf mg mh mi mj kv dk translated"><em class="mk">姓名、电子邮件和密码。</em></p></blockquote><p id="6ef9" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">对于这个演示，我们将为我们的<a class="ae lz" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>应用程序使用E <a class="ae lz" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> xpress </a>框架，同时使用<a class="ae lz" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>作为我们的数据库。在用流行库<a class="ae lz" href="https://yarnpkg.com/en/package/bcrypt" rel="noopener ugc nofollow" target="_blank"> bcrypt </a>将新用户存储到我们的数据库之后。在这里，我们将散列密码，以便在我们的应用程序中添加位层安全性。</p><p id="e1e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我将在我们的<a class="ae lz" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> express </a>应用程序<em class="kw"> user.js </em>中创建一个新的<strong class="ka ir">模型</strong></p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated"><a class="ae lz" href="https://gist.github.com/ishan-me/d32b21918ce0d5ee8a6330f90a4f7c2e" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ishan-me/d32b 21918 ce 0 D5 ee 8 a 6330 f 90 a 4 f 7 C2 e</a></figcaption></figure><p id="1ae8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在express应用程序中添加额外的路线。我们创建新的<strong class="ka ir"> route </strong>文件，并命名为<em class="kw"> user.js </em></p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated"><a class="ae lz" href="https://gist.github.com/ishan-me/17a06a1f704fdf70f3b23be832ad53e5" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ishan-me/17a 06 a1 f 704 fdf 70 F3 b 23 be 832 ad 53 e 5</a></figcaption></figure><p id="cc40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了这些变化之外，我们还将在我们的<strong class="ka ir"> main </strong> index.js中添加这条额外的路线</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated"><a class="ae lz" href="https://gist.github.com/ishan-me/8ceaa27393b8e8dfe0bdbde2e7d635ab" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ishan-me/8 ceaa 27393 b 8 E8 df E0 bde 2e 7d 635 ab</a></figcaption></figure><p id="24e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">准备好上面的代码后，我们将使用<a class="ae lz" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> postman </a>测试我们的端点，我们会得到以下结果:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/daf597be434289af51114b45b32e8bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Y-vrIAWYWXRHRBMbbpc_g.png"/></div></div></figure><p id="6dd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个新名称的电子邮件，这是设置为唯一的用户和密码被创建到我们的本地数据库。我们将进一步探讨如何用bcrypt 将加密的密码存储到我们的数据库中。</p><h2 id="fc38" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">哈希密码</h2><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/82a306dfb13062163f2e9464084fbf49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yevkWIfUyd9rm-M6V-k1hA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated"><a class="ae lz" href="https://auth0.com" rel="noopener ugc nofollow" target="_blank">来源:auth0 </a></figcaption></figure><p id="3e68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">bcrypt是由Niels Provos和David Mazières基于Blowfish密码设计的密码散列函数，于1999年在USENIX提出。我们将在我们的文件夹中添加以下命令，以使用有助于散列我们的密码的库。</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="1dc9" class="kx ky iq mu b gy my mz l na nb">yarn add bcrypt</span></pre><p id="0002" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要破解我们的密码，我们需要一把盐。“salt”将一个很长的字节串添加到密码中。因此，即使恶意黑客可能获得单向散列密码的访问权限，他们也应该无法猜出“salt”字符串。可以为每个用户添加一个随机字符串，该字符串是在生成用户帐户时创建的。这将显著增加加密，因为恶意黑客将不得不试图一次找到单个用户的密码。</p><p id="c6c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们进入我们的代码，并添加哈希到我们的密码。我们将在routes users.js中添加额外的代码行</p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated"><a class="ae lz" href="https://gist.github.com/ishan-me/fd67c6723027a68c8242227de99730ee" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ishan-me/fd67c 6723027 a68c 8242227 de 99730 ee</a></figcaption></figure><p id="7e3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码准备好了，我们将再次用<a class="ae lz" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> postman </a>测试我们的端点，我们得到下面的结果。我们已经返回了包括密码在内的响应，但是在实际应用中，我们更愿意发送一个令牌和授权头。</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/f56b500cca804294265982e4a557ebc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-Sj_i4omCotb8ATkbi4NQ.png"/></div></div></figure><p id="186f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们有您需要保护的敏感数据或信息，确保其安全是非常重要的。通过上面的过程，我们现在可以成功地将散列密码存储到我们的数据库中，增加了一点安全性。</p></div></div>    
</body>
</html>