<html>
<head>
<title>Kubernetes Serverless simply visually explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes无服务器简单直观地解释</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-serverless-simply-visually-explained-ccf7be05a689?source=collection_archive---------0-----------------------#2020-04-13">https://itnext.io/kubernetes-serverless-simply-visually-explained-ccf7be05a689?source=collection_archive---------0-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="26f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们以一种简单明了且与工具无关的方式探索使Kubernetes无服务器化的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/490e6f58f2bf7d96234f476924495ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bkobr5AtY0dwBvhMr1eh0A.jpeg"/></div></div></figure><h2 id="e7ba" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">系列<strong class="ak"> </strong>内容</h2><ul class=""><li id="c971" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated">第1部分:<a class="ae mf" href="https://medium.com/swlh/kubernetes-services-simply-visually-explained-2d84e58d70e5?source=friends_link&amp;sk=49a5e832662a689111a6087e1fe1232a" rel="noopener"> Kubernetes服务简单直观地解释了</a></li><li id="c8f7" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated">第二部分:<a class="ae mf" href="https://codeburst.io/kubernetes-ingress-simply-visually-explained-d9cad44e4419?source=friends_link&amp;sk=e8ca596700f5b58c7ab0d85d4dab6386" rel="noopener" target="_blank"> Kubernetes Ingress简单直观讲解</a></li><li id="6cb3" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated">第3部分:<a class="ae mf" href="https://medium.com/@wuestkamp/kubernetes-istio-simply-visually-explained-58a7d158b83f?source=friends_link&amp;sk=378ed718d2d6cfd09e6d23c7616cba81" rel="noopener"> Kubernetes Istio简单直观讲解</a></li><li id="7a44" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated">第四部分:(本文)</li></ul><h2 id="ade9" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">这篇文章是关于什么的</h2><ul class=""><li id="f957" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated">你辛苦学到的Kubernetes知识会因为无服务器而变得过时吗，你浪费了3年的生命吗？</li><li id="8b83" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated">如何使用无服务器而不被云提供商锁定？</li><li id="3dc0" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated">这不是具体工具的比较，而是一般的想法</li></ul><h2 id="31ea" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="3996" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">Kubernetes上的无服务器以独立于云提供商的方式减少了重复配置。这只是不断自动化人工工作的结果。</p><p id="9bf1" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">当我们在Kubernetes上谈论无服务器时，我们需要考虑两个不同的领域:</p><ol class=""><li id="c4ab" class="lq lr it ls b lt my lv mz ld nd lh ne ll nf ma ng mc md me bi translated"><strong class="ls iu">在集群中部署无服务器应用</strong>(减少每个应用+自动构建容器所需的YAML文件数量)</li><li id="0946" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma ng mc md me bi translated"><strong class="ls iu">在不管理节点/虚拟机的情况下运行pods的容器无服务器</strong></li></ol><h1 id="d373" class="nh kv it bd kw ni nj nk kz nl nm nn lc jz no ka lg kc np kd lk kf nq kg lo nr bi translated">无服务器</h1><p id="cd28" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">简而言之:您没有或很少与运行应用程序所必需的服务器和基础设施进行交互。当今天使用“无服务器”这个词时，它可以指两种不同的东西:CaaS和FaaS。</p><h2 id="27b1" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">CaaS —容器即服务</h2><p id="d7dc" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">你创建(Docker)容器，把它扔给CaaS，它就会自动运行、服务和扩展它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/ad7ed648a0e8503ea37f562570d64a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jSpEItYQsmXvUfkV_ypyyw.png"/></div></div></figure><p id="54a2" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">托管的例子有Azure容器实例、Google Cloud Run或AWS Fargate。</p><h2 id="848d" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">FaaS —功能即服务</h2><p id="d4b5" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">你编写代码，把它扔向FaaS，它就会自动运行、服务和扩展它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/d97f4c28bb425caa0aa3baab17d95a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ozkuz_wLFHY5Or_8L7C9A.png"/></div></div></figure><p id="1607" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">托管的例子有Azure函数、Google函数或AWS Lambda。</p><h2 id="b1ae" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">FaaS实施</h2><p id="2cf5" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">FaaS如何运行您的代码可以以不同的方式发生。<strong class="ls iu">一种方式</strong>可能是FaaS实际上为每个代码更改构建一个容器，然后像这样使用CaaS:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/f7414bf2ac29ea5cad374f4594cb51b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CW1EnqvBCUhBlYDrkkIM6g.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">FaaS建造了一个集装箱，并将其发送到民航局</figcaption></figure><p id="cfa9" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated"><strong class="ls iu">另一种方式</strong>可以是FaaS在引导期间动态地将函数的源代码拉入预定义的环境(容器)中。环境将可用于不同的语言。当使用像Go这样必须编译的语言时，编译也必须在启动时完成。</p><h1 id="8b36" class="nh kv it bd kw ni nj nk kz nl nm nn lc jz no ka lg kc np kd lk kf nq kg lo nr bi translated">事件/缩放</h1><p id="af19" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">FaaS大部分时间与触发函数实例化的事件系统一起使用。事件可以来自API-Gateways、Github、Kafka、RabbitMQ、CronJobs等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/09aa20437d4779f16b896d4cbfad4c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QxtIz2qk0M1iNeqrMWzx2w.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">FaaS封装了与事件源的通信</figcaption></figure><p id="fe6d" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">对于每个事件，都会创建一个新的函数来处理它。如果有多个事件同时发生，将创建多个实例来处理这些事件。这样我们就有了自动缩放。</p><p id="8663" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">FaaS与各种事件源进行通信，因此函数本身不需要这样做。他们只需处理FaaS使用的一种事件格式，如CloudEvents或通过HTTP的传输。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/496df0b241046a90bc585991a734aac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*ho7EsGOKbu6WJB1tpe_WrA.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated"><a class="ae mf" href="https://cloudevents.io/" rel="noopener ugc nofollow" target="_blank"> https://cloudevents.io </a></figcaption></figure><p id="5910" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">有一个<a class="ae mf" href="http://cloudevents.io" rel="noopener ugc nofollow" target="_blank">云事件项目</a>，它将事件的结构和元数据描述为一个“标准”。它还包括数据和描述该数据的模式。云事件是包裹事件数据的信封。如果许多供应商都采用这种方法来获得互操作性，那就太好了。</p><h1 id="20b7" class="nh kv it bd kw ni nj nk kz nl nm nn lc jz no ka lg kc np kd lk kf nq kg lo nr bi translated">Kubernetes应用</h1><p id="dfb3" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">让我们看看在Kubernetes上开发一个传统的<strong class="ls iu">非无服务器</strong>应用程序的必要步骤:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/d8ca3e57dd29fe95d6a074c1de428094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tRebIPaAjL8ZtTvu4CC_3w.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">相当多的手动“服务器”交互是必要的</figcaption></figure><p id="bafb" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">我们需要构建一个容器，创建各种Kubernetes资源(YAML文件)，然后决定我们需要多少工作节点来运行我们的应用程序。</p><p id="c3ba" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">通过配置集群/节点自动缩放器，可以更动态地决定我们需要多少工作节点。尽管如此，我们仍然需要对其进行配置，并需要设置最小+最大节点数量。</p><p id="8dfc" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">我们使用这种传统方法与“服务器”进行大量的交互。首先创建/构建一个容器，然后编写YAML文件并定义节点的数量和资源。</p><h1 id="342b" class="nh kv it bd kw ni nj nk kz nl nm nn lc jz no ka lg kc np kd lk kf nq kg lo nr bi translated">Kubernetes无服务器应用程序</h1><p id="99c3" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">现在让我们探索一下为Kubernetes开发应用程序时的无服务器方法。</p><h2 id="f46e" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">CaaS —容器即服务</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/33e9f835f414ecc07e67486a6abd4dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JfoJd33zAX5m98TVskY8JQ.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">我们减少了大量YAML文件的创建</figcaption></figure><p id="8678" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">在这里，我们大大减少了要创建的Kubernetes资源(YAML文件)的数量。CaaS将为我们创建所有必要的子资源，如自动缩放、入口或Istio路由。</p><p id="216d" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">我们所做的就是提供一个(Docker)容器并创建一个单一的k8s资源，即通过<a class="ae mf" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank"> CRD </a>引入的CaaS-container资源。CaaS决定何时启动我们的应用程序实例，以及启动多少个实例，可能基于事件或我们的定义。</p><p id="34b4" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">我们必须确保我们构建的容器可以接收和处理来自CaaS的事件，例如可以通过HTTP或CloudEvents。这可能需要容器中的某些库。</p><p id="29d6" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">CaaS示例:<a class="ae mf" href="https://knative.dev/" rel="noopener ugc nofollow" target="_blank"> Knative </a> (Knative提供了其他解决方案可以使用和依赖的灵活构件)。</p><h2 id="0210" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">FaaS —功能即服务</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/7344e07c75a555d482b850f701faa203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkrEERZgTqEpaXMmBKVzNg.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">我们现在也自动化了构建过程，也许会有一个漂亮的FaaS网络界面</figcaption></figure><p id="0f72" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated"><code class="fe oe of og oh b">FaaS function.yml</code>将包含一个来自FaaS系统的K8s资源，通过<a class="ae mf" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank"> CRD </a>引入。在该资源中，我们设置诸如函数名、源代码位置、语言运行时和触发事件等内容。</p><p id="e69f" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">如果我们通过web界面上传代码，那么创建<code class="fe oe of og oh b">FaaS function.yaml</code>就没有必要了。但是将函数作为代码应该是一个好的实践。web界面适合于原型开发或测试修改。</p><p id="0604" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">有了FaaS，我们还拥有CaaS解决方案提供的一切。但是现在我们进一步减少了工作，因为我们有工具运行在我们的Kubernetes集群中，可以直接执行/构建我们的应用程序源代码。</p><p id="3ba8" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">为我们构建的容器已经包含了必要的库，如HTTP或CloudEvents，以接收来自FaaS的事件。我们不必担心这个。</p><p id="157a" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">源代码可能存储在Git repo中，通过web界面上传，或者在其他地方可用。FaaS将访问代码，监听更改，构建容器，然后将其传递给CaaS以提供服务端事件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/65fada20ed5d832c437baefa1ab50071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4fIQGNsVBTXBZp1zuGTBA.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">上传代码并作为功能部署的TriggerMesh示例web界面</figcaption></figure><p id="1cdf" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">FaaS的例子:</p><ul class=""><li id="c181" class="lq lr it ls b lt my lv mz ld nd lh ne ll nf ma mb mc md me bi translated"><a class="ae mf" href="https://triggermesh.com/" rel="noopener ugc nofollow" target="_blank">触发网格</a>(使用Knative作为CaaS)</li><li id="b4a3" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated"><a class="ae mf" href="https://www.openfaas.com/" rel="noopener ugc nofollow" target="_blank"> OpenFaaS </a>(可以使用Knative)</li><li id="419f" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated"><a class="ae mf" href="https://kubeless.io/" rel="noopener ugc nofollow" target="_blank">无底洞</a></li><li id="44b0" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated"><a class="ae mf" href="https://fission.io/" rel="noopener ugc nofollow" target="_blank">裂变</a>(与环境一起工作，而不是不可变的函数容器，更进一步)</li><li id="f32b" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated"><a class="ae mf" href="https://openwhisk.apache.org/" rel="noopener ugc nofollow" target="_blank">open whish</a></li><li id="5625" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated"><a class="ae mf" href="https://vshn.ch/en/blog/a-very-quick-comparison-of-kubernetes-serverless-frameworks" rel="noopener ugc nofollow" target="_blank">各款K8s FaaS概述及对比</a></li></ul><h2 id="4d70" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">冷启动和暖启动</h2><p id="909d" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">一个<strong class="ls iu">冷启动</strong>意味着没有任何pod正在运行来处理一个事件，所以创建它需要一些时间。通常，这些豆荚在最后一次使用后会存活一段时间，并且可以重复使用。“已经运行”期间的调用将被称为<strong class="ls iu">热启动</strong>。热启动速度更快，但也耗费资源。</p><h2 id="ce69" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">基于裂变/环境的FaaS</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/e73d6375b2a86797ae916410dbf6fe82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0cm1bFT1ZIJUl71bfHx2g.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">裂变架构(<a class="ae mf" href="https://hackernoon.com/what-is-serverless-part-4-fission-an-open-source-serverless-framework-for-kubernetes-7f025517774a" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure><p id="7b63" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">K8s FaaS的一个例子，<a class="ae mf" href="https://fission.io/" rel="noopener ugc nofollow" target="_blank">裂变</a>，实际上并没有为每个函数的代码变化构建不可变的容器，而是使用了可变环境容器(“通用容器”)的思想，它动态地拉入代码，然后将这些代码转换成“特定的函数容器”。我认为这也是他们利用AWS鞭炮的方式。</p><h2 id="dd3b" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">可观察性</h2><p id="3df2" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">从容器化的微服务转移到功能可能导致必须管理比以前更多更小的服务。这是因为创建只监听和处理一个事件的小函数很容易。当我创建与第1部分中的<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/scalable-microservice-demo-k8s-istio-kafka-344a2610eba3?source=friends_link&amp;sk=7404e77f2a42d21261707794afaed58d">容器微服务和第2部分</a>中的<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/scalable-serverless-microservice-demo-aws-lambda-kinesis-terraform-cbe6036bf5ac?source=friends_link&amp;sk=074614683a6641cab9b6067929bdc660"> AWS无服务器相同的演示应用时，我注意到了这一点。</a></p><p id="dad1" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">为了管理更多的服务或功能，必须保持可观察性(度量、日志、跟踪)。这就是为什么大多数Kubernetes FaaS和CaaS已经与Prometheus、Jaeger和服务网格(如Istio或Linkerd)集成。</p><h1 id="6a32" class="nh kv it bd kw ni nj nk kz nl nm nn lc jz no ka lg kc np kd lk kf nq kg lo nr bi translated">Kubernetes无服务器节点</h1><p id="e9a0" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">在上一节中，我们讨论了K8s无服务器应用程序，并看到了使用CaaS或FaaS时的工作流。这些简化了流程，减少了大量重复性工作。</p><p id="25db" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">但是开发者或操作者仍然与服务器交互:在集群中用作工作节点的虚拟机。他们仍然需要指定拥有多少节点及其资源(CPU/内存)。</p><p id="cc04" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">现在我们更进一步，使用<a class="ae mf" href="https://virtual-kubelet.io/" rel="noopener ugc nofollow" target="_blank">虚拟Kubelet </a>使实际的底层Kubernetes节点无服务器化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/6691bf18f48e841fcacf1a55f11f49eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SthgjT7yZXgQxkYzkuIAng.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">Kubernetes之上的FaaS，以虚拟的Kubelet为节点。终极设置？</figcaption></figure><p id="ceda" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">虚拟Kubelet模拟了Kubernetes的一个worker节点，然后可以用来调度pods，就像任何其他普通节点一样。虽然pods的容器不是在VM上运行，而是在AWS Fargate、Google Cloud Run或Azure Container Instances等云提供商的无服务器容器产品中运行。</p><p id="5467" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">请阅读我的<a class="ae mf" href="https://medium.com/@wuestkamp/kubernetes-without-nodes-caedd172f940?source=friends_link&amp;sk=a7cd94bbb7e8776fa4f0802de4e41094" rel="noopener">关于虚拟Kubelet </a>的详细文章。</p><p id="c255" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">Kubernetes的K8s无服务器应用程序和K8s无服务器节点的组合可能是一个强大的组合。但是如果我们没有服务器，为什么还要使用K8s呢？</p><h1 id="d372" class="nh kv it bd kw ni nj nk kz nl nm nn lc jz no ka lg kc np kd lk kf nq kg lo nr bi translated">为什么还用Kubernetes？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/74e2e1313a991df2a0334cf897afa593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMWRR0UxssFGdwF6DkLQPg.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">抱歉，我当时想拍一张傻乎乎的照片</figcaption></figure><p id="f9a8" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">Kubernetes提供了强大而灵活的构建模块，而不是为方便交互和最终用户而制造的。这使得K8s很复杂，直接使用时需要大量的重复性工作。</p><p id="f68c" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">Kubernetes成为独立于云提供商的标准。在它的基础上使用无服务器框架，在走向无服务器时保持这种独立性是有意义的。如果有必要，我们总是可以更详细地定义我们的应用程序，因为它仍然只是在引擎盖下运行K8s。</p><p id="2c59" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">通过在K8s上使用无服务器，我们可以大大减少重复性工作，这样我们就可以花更多的时间来构建实际的应用程序。</p><h1 id="2a5c" class="nh kv it bd kw ni nj nk kz nl nm nn lc jz no ka lg kc np kd lk kf nq kg lo nr bi translated">概述</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/d8ca3e57dd29fe95d6a074c1de428094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tRebIPaAjL8ZtTvu4CC_3w.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">传统的</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/6691bf18f48e841fcacf1a55f11f49eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SthgjT7yZXgQxkYzkuIAng.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">无服务器</figcaption></figure><h1 id="22f0" class="nh kv it bd kw ni nj nk kz nl nm nn lc jz no ka lg kc np kd lk kf nq kg lo nr bi translated">结论</h1><p id="22b8" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">我认为现代的无服务器事件驱动架构已经证明了自己，并将在未来几年变得越来越流行。让我们在K8s等开放标准之上使用它，以确保更好的互操作性。</p><p id="a5a9" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">Kubernetes上的无服务器只是不断自动化人工工作的结果。</p><h1 id="c43b" class="nh kv it bd kw ni nj nk kz nl nm nn lc jz no ka lg kc np kd lk kf nq kg lo nr bi translated">来源</h1><ol class=""><li id="3892" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma ng mc md me bi translated">互联网。</li><li id="f9e3" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma ng mc md me bi translated"><a class="ae mf" href="https://vshn.ch/en/blog/a-very-quick-comparison-of-kubernetes-serverless-frameworks" rel="noopener ugc nofollow" target="_blank">Kubernetes无服务器框架的快速比较</a></li><li id="0ee7" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma ng mc md me bi translated"><a class="ae mf" href="https://docs.gitlab.com/ee/user/project/clusters/serverless/" rel="noopener ugc nofollow" target="_blank"> Gitlab使用Knative和Triggermesh提供无服务器应用</a></li><li id="439d" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma ng mc md me bi translated"><a class="ae mf" href="https://cloud.google.com/blog/products/serverless/knative-based-cloud-run-services-are-ga" rel="noopener ugc nofollow" target="_blank"> Google Cloud Run在引擎盖下使用Knative】</a></li><li id="e315" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma ng mc md me bi translated">Kubeless和TriggerMesh的创作者制作了一个很棒的视频</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="92bf" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">6.另一个关于Kubernetes，Serverless和OpenWhisk的精彩视频</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="efe6" class="pw-post-body-paragraph ml mm it ls b lt my ju mn lv mz jx mo ld na mq mr lh nb mt mu ll nc mw mx ma im bi translated">7.另一个视频展示了OpenFaaS、Knative和Nuclio</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h1 id="c705" class="nh kv it bd kw ni nj nk kz nl nm nn lc jz no ka lg kc np kd lk kf nq kg lo nr bi translated">成为Kubernetes认证</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://killer.sh"><div class="gh gi oo"><img src="../Images/cf3901a56841fcb55f9e4e17b9f07672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Kbj17_6VncUuoBqNsAzzg.png"/></div></a><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated"><a class="ae mf" href="https://killer.sh" rel="noopener ugc nofollow" target="_blank"> https://killer.sh </a></figcaption></figure></div></div>    
</body>
</html>