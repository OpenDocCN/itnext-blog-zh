<html>
<head>
<title>Avoiding any in TypeScript — advanced types and their usage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中避免任何—高级类型及其用法</h1>
<blockquote>原文：<a href="https://itnext.io/avoiding-any-in-typescript-advanced-types-and-their-usage-691b02ac345a?source=collection_archive---------1-----------------------#2019-01-16">https://itnext.io/avoiding-any-in-typescript-advanced-types-and-their-usage-691b02ac345a?source=collection_archive---------1-----------------------#2019-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8422" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript为JavaScript开发人员提供了在代码中提供严格类型的机会。然而，由于JavaScript的性质，在某些情况下，提供准确的类型并不是一项简单的任务。在这种情况下，程序员倾向于使用<em class="kl">any</em>——一种允许用户在里面存储任何东西的打字撬锁。在这篇文章中，我想展示一些内置类型和内置类型脚本特性，您可以使用它们来避免任何T2或简化一些自定义类型。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/82a079e55b986a2e163e144d3adea528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XClR820xvc5FKQAa_ppDIw.jpeg"/></div></div></figure><h1 id="0b26" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JavaScript对象</h1><p id="4f4c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">很可能，几乎每个JavaScript开发人员都曾经使用过一个对象作为类似地图的集合。然而，对于严格类型来说，如何键入可能不是那么明显(特别是对于<a class="ae mb" href="https://palantir.github.io/tslint/rules/no-string-literal/" rel="noopener ugc nofollow" target="_blank">无字符串文字</a> TSLint规则)。第一个定位选项是<em class="kl"> any </em>，但是我们丢失了值类型的信息。所以，我们可以严格地用特定的键来输入一个接口——但是这样我们就不能给对象添加任何东西。另一个选项是<em class="kl">对象</em>或<em class="kl"> {} </em>，但这意味着“空对象”，所以我们不能在其中设置任何东西。那么，标准的方式是什么？</p><p id="616f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">记录</em></p><p id="491e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看定义:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">清单1来自lib.es5.ts的记录定义</figcaption></figure><p id="55a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及用法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">清单2使用记录类型的例子</figcaption></figure><p id="71ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，这意味着开发人员可以输入任何键，但是值必须是特定的类型。更重要的是，我们可以将它与其他类型结合起来，从而用一些预定义的键(甚至不同值类型的键)来创建字典！)通过IntelliSense可见，例如:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">清单3使用记录类型的更高级的例子</figcaption></figure><p id="132a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不认为我需要写这个的实际用法。当然，我们有一个名为“Map”的内置ES6集合，它为字典提供了更好的体验，但根据<a class="ae mb" href="https://jsperf.com/es6-map-vs-object-properties/73" rel="noopener ugc nofollow" target="_blank">基准</a>，当我们只想设置和获取值时，使用对象(Record)会更快。</p><h1 id="79f5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">其他类型属性的质量修改器</h1><p id="7803" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当我们已经有一个定义了属性的类型，但我们不喜欢它的定义方式时，该怎么办？也许我们希望所有的属性都是可选的、必需的或只读的？TypeScript中还包含了类型<em class="kl">部分</em>、<em class="kl">必需</em>和<em class="kl">只读</em>。让我们看看它们的定义:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">清单4 lib . es5 . ts中的部分、必需和只读定义</figcaption></figure><p id="7f14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，正如文章的标题所告诉我们的，只有<em class="kl">部分</em>可以真正用来代替<em class="kl">任何</em>，但这三者在某种程度上是相互联系的，所以不一起写它们是一种浪费。</p><p id="9813" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们提供了一些非常实用的用法。Readonly 在React的类型化中很常见——在组件中，有些东西你不能直接编辑，但是你是定义类型的人，比如组件的状态或属性。</p><p id="1ff9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">部分</em>用在你想提供不提供整个对象的可能性的地方。一个流行的用法示例是提供通过一个函数(或构造函数)设置对象值的可能性，而不是通过单独设置属性。下面的清单给出了这种用法的一个例子。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">清单5使用部分</figcaption></figure><p id="5c8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">要求</em>是<em class="kl">的反义词，偏</em>。然而，这里的用法并不简单，因为它在编译期间检查是否所有东西都在类型级别上设置。既然没见过什么好的，实用的用法，就不提供了。如果你有一些，请让我知道。</p><h1 id="d05f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">挑选和省略某一类型的特定部分</h1><p id="87de" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">之前我们讨论了<em class="kl"> Partial </em>，它允许我们将类型中的一切都变成可选的。也就是说，我们可能还希望获取对象的特定部分，而不将其更改为可选的(这使得键入更加严格)。我来介绍一下<em class="kl">挑</em>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">清单6从lib.es5.ts中挑选定义</figcaption></figure><p id="a37b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Pick的工作方式是这样的:它只接受第二种类型的特定属性。下面是它如何工作的一个例子:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">清单7 Pick的用法</figcaption></figure><p id="4548" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Pick </em>可能看起来不是很有用，因为事实上它只从第二种类型中获取给定的键或键。所以你可能会问:为什么我们不直接使用第二种类型，或者只从那些键构建一个类型？原因是这样的——我们保留了原始类型的信息。为什么<em class="kl">不偏</em>？区别在于当你在编译器设置中打开<em class="kl"> strictNullChecks </em>标志时。让我们回顾一个例子:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">清单Pick和Partial之间的区别</figcaption></figure><p id="8070" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，<em class="kl"> Pick </em>不允许像在原始类型中定义的那样设置空值(也是未定义的)。<em class="kl"> Partial </em>只是让一切都可以为空，所以它确实中断了原来的输入。在实践中，它被用在，例如，React，setState函数中。</p><p id="a8a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，我提到了省略。我们没有内置的类型，但是我们可以像这样为自己创建一个:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">清单9省略类型的定义</figcaption></figure><p id="8863" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">(更新:</em> <a class="ae mb" href="https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#typescript-35" rel="noopener ugc nofollow" target="_blank"> <em class="kl">)既然TypeScript 3.5，我们已经内置了省略类型</em> </a> <em class="kl">，所以没必要自己定义)</em></p><p id="62ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们可以执行下面的事情:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">清单10使用Omit的例子</figcaption></figure><p id="de56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果将这个清单中的对象e和f与清单7中的对象c和d进行比较，您会发现我们得到了完全相反的东西。在Ramda中可以看到一个使用<em class="kl">省略</em>的例子，用来描述一个叫做<em class="kl">省略</em>的函数的结果(很惊讶吧？).</p><h1 id="6a25" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">未知和高级元组类型</h1><p id="7c60" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我在文章的这一部分简要描述的两个TypeScript特性都是在TypeScript 3.0中引入的，我已经在<a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/typescript-3-0-what-has-come-19f81d1fac60">我的关于TypeScript 3.0的文章</a>中介绍了它们。</p><p id="0c70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们不知道对象的正确类型时，应该使用unknown。不像<em class="kl">任何</em>，<em class="kl"> </em>它不允许你对一个值做任何操作，直到我们知道它的类型(通过适当的类型检查)。</p><p id="bae9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我所说的高级元组类型主要是指用元组类型提取和传播函数参数，这是在TypeScript 3.0中引入的。有了它们，我们可以为数组中的特定值定义特定的类型。虽然乍一看，这听起来不是很有帮助，但它们在键入函数式编程特性(如compose)时会很有用。</p><p id="8924" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我鼓励您阅读我在上面链接的文章，以获得更详细的描述，以及用法示例，这样您可以更好地掌握它们。</p><h1 id="ef2e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="4f4e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">TypeScript有很多类型化的武器，可以用来在JavaScript的动态类型化环境中保持静态类型。整个问题是它是隐藏的，它的用法并不总是那么简单。然而，虽然本文没有描述TypeScript提供的所有功能，但我希望它能帮助您编写可以更好地键入的代码。</p><blockquote class="mi mj mk"><p id="9dc4" class="jn jo kl jp b jq jr js jt ju jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj kk ij bi translated">这篇文章也发表在Synergy Codes 的<a class="ae mb" href="https://www.synergycodes.com/blog/software-development/avoiding-any-in-typescript-advanced-types" rel="noopener ugc nofollow" target="_blank">博客上，Synergy Codes</a>是一家专注于流程可视化、映射和建模的软件公司。<br/>您对创建数据可视化应用感兴趣吗？<a class="ae mb" href="https://synergycodes.com/gojs-ebook/" rel="noopener ugc nofollow" target="_blank">点击这里了解GoJS库</a>！</p></blockquote></div></div>    
</body>
</html>