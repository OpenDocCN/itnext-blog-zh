<html>
<head>
<title>Deferred tasks in a microservice architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务架构中的延迟任务</h1>
<blockquote>原文：<a href="https://itnext.io/deferred-tasks-in-a-microservice-architecture-8e7273089ee7?source=collection_archive---------2-----------------------#2021-02-13">https://itnext.io/deferred-tasks-in-a-microservice-architecture-8e7273089ee7?source=collection_archive---------2-----------------------#2021-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2185" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常在项目中，需要执行延迟任务，例如发送电子邮件、推送和其他特定于应用程序领域的特定任务。当通常的crontab不再足够时，当批处理不适合时，当每个任务单元都有自己的执行时间或被动态分配时，困难就开始了。</p><p id="d48a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，一个叫做<a class="ae kl" href="https://github.com/pvelx/triggerhook" rel="noopener ugc nofollow" target="_blank">触发挂钩</a>的解决方案被创造出来。操作示意图如图1所示。该图显示了任务在其整个生命周期中的变化。改变颜色意味着改变任务的状态。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><ul class=""><li id="276c" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">红色任务——启动时间还不算早的任务</li><li id="1666" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">黄色任务—即将启动的任务</li><li id="e9ed" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">绿色任务——启动时间已到的任务</li><li id="006a" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">蓝色任务—已处理的任务</li><li id="e5c1" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">灰色-未确认数据库中任务的状态</li><li id="2f32" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">黑色—删除命令</li></ul><p id="a666" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生命周期任务:</p><ul class=""><li id="2a3a" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">当创建一个任务时，它进入数据库(方块)(红色和黄色)。</li><li id="770d" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">如果任务的开始时间即将到来(红色-&gt;黄色)，则任务被加载到内存中(三角形块)。这种结构以优先队列(堆)的形式实现。</li><li id="84f8" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">当任务执行时间到了，就发送执行(黄色-&gt;绿色)。在处理之前使用中间缓冲器来补偿峰值负载。</li><li id="0df5" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">如果任务成功提交，它将从数据库中删除(绿色-&gt;蓝色)。在删除之前使用中间缓冲区，也是为了补偿峰值负载。</li></ul><p id="5fc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我将尝试更详细地描述一些特性，并给出支持选择这种解决方案的理由。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="61c1" class="lo lp iq bd lq lr ls dn lt lu lv dp lw jy lx ly lz kc ma mb mc kg md me mf mg bi translated">API的简单性</h2><p id="182d" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">该ID接受UUIDv4格式。如果没有通过，将独立生成。当使用异步通道时，从外部服务传递任务id的能力将非常有用。开始时间以UNIX格式指定。</p><p id="9da4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mm ks l"/></div></figure><p id="66d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">删除:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mm ks l"/></div></figure><p id="243a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理启动事件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mm ks l"/></div></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="4eb9" class="lo lp iq bd lq lr ls dn lt lu lv dp lw jy lx ly lz kc ma mb mc kg md me mf mg bi translated">持久性</h2><p id="f285" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">例如，如果与消息代理的连接丢失，任务处理可能会失败。在这种情况下，任务不会被确认，但会再次尝试发送。只有在调用确认方法时，任务才会被标记为已处理。突然停止应用程序不会导致数据库不一致。</p><p id="7b50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，考虑到以微服务的形式将应用程序转移到云的一般市场趋势，新的应用程序需求正在形成。至少以前在背景中的东西现在变得更重要了。使用这种方法，容器化的应用程序本质上是临时的。Trigger Hook机制使得在一个服务器上折叠一个微服务并在生产环境中的另一个服务器上部署它成为可能，而不需要软停止。</p><p id="1eb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果应用程序崩溃，一些任务可能无法在数据库中确认。当您重新启动应用程序时，这些任务将被再次发送执行。这种行为是一种有利于提供容错的折衷。当你的应用程序从Trigger Hook接收到一条消息时，它应该只执行任务一次，当它再次接收时就忽略它。这种情况在面向事件的体系结构中很常见，它们不应该破坏内部状态并产生大量错误。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="f3c4" class="lo lp iq bd lq lr ls dn lt lu lv dp lw jy lx ly lz kc ma mb mc kg md me mf mg bi translated">准确性和性能</h2><p id="7ca5" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">为了避免对数据库的高频率请求，提供了一种机制来定期预加载执行时间在指定范围内的任务集。换句话说，很少请求任务集，而不是一次请求一个任务。例如，如果一次调度几十万个任务，这种方案非常适合。任务加载后，会按优先级排序。当最高优先级任务的计时器到期时，它会立即被发送到客户端代码进行处理。这使您能够实现高峰性能，并以每秒的精度处理任务。</p><p id="08d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，由于简单的任务存储方案、索引和多线程数据库访问，发送任务以供执行的性能得到了提高。</p><p id="d242" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测量了任务处理速度的主要指标。</p><p id="6c09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序服务器:</p><ul class=""><li id="b8ae" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">AWS EC2 Ubuntu 20</li><li id="dbfb" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">t2 .微</li><li id="9299" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">1个2.5 GHz虚拟CPU</li><li id="cd99" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">1个GiB RAM</li></ul><p id="0312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据库服务器:</p><ul class=""><li id="7238" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">AWS RDS MySQL 8.0</li><li id="660e" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">db.t3.micro</li><li id="186d" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">2个虚拟CPU</li><li id="30d5" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">1个GiB RAM</li><li id="cd45" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">网络:2085 Mbps</li></ul><p id="f705" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建任务测试:</p><ul class=""><li id="473b" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">测试持续时间——1分11秒</li><li id="4fd9" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">平均速度(任务/秒)— 1396</li><li id="c107" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">任务数量— 100000</li></ul><p id="4b8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">删除任务测试:</p><ul class=""><li id="f0c5" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">测试持续时间—52秒</li><li id="f3e9" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">平均速度(任务/秒)— 1920</li><li id="252f" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">任务数量— 100000</li></ul><p id="34d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发送任务(任务状态从红色变为蓝色)测试:</p><ul class=""><li id="fe72" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">测试持续时间——498毫秒</li><li id="eb03" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">平均速度(任务/秒)— 200668</li><li id="797f" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">任务数量— 100000</li></ul><p id="09fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确认任务(任务的状态从蓝色变为删除)测试:</p><ul class=""><li id="0757" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">测试持续时间——2s</li><li id="3f8b" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">平均速度(任务/秒)— 49905</li><li id="77a8" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">任务数量— 100000</li></ul></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="69aa" class="lo lp iq bd lq lr ls dn lt lu lv dp lw jy lx ly lz kc ma mb mc kg md me mf mg bi translated">监视</h2><p id="e3a9" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">为了快速检查正确的操作，Trigger Hook提供了连接时序数据库的能力。在初始化阶段，可以确定测量的频率并选择感兴趣的指标。此处提供了可用指标的完整列表。</p><p id="88ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也可以通过适配器连接记录系统。可用:</p><ul class=""><li id="376b" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">致命错误——导致应用程序完全关闭</li><li id="e45f" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">值得注意但不会导致停止的错误</li><li id="b454" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">取消邮件标记</li></ul><p id="e6c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，您可以看到一个连接到InfluxDB+Grafana的例子</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="6518" class="mn lp iq bd lq mo mp mq lt mr ms mt lw mu mv mw lz mx my mz mc na nb nc mf nd bi translated">作为微服务架构一部分的触发器挂钩</h1><h2 id="35e4" class="lo lp iq bd lq lr ls dn lt lu lv dp lw jy lx ly lz kc ma mb mc kg md me mf mg bi translated">异步交互</h2><p id="8e50" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">当使用微服务架构时，异步交互通常是首选。Trigger Hook非常适合微服务、事件驱动架构。但是在任何情况下，传入(创建、删除)和传出(任务开始时间事件)通道可以是异步的，也可以是同步的，这取决于需求。</p><p id="5390" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面，图2显示了通过异步信道的通信方案的一个可能的变体。一个队列，比如RabbitMQ，可以充当消息代理。这种方案消除了调用者对被调用微服务的阻塞，例如在通过HTTP的同步请求中。代理接受无限数量的任务(有条件地无限制)，这些任务的处理程序在它们被释放时接管它们。一旦处理了create命令，就会发送一个关于任务成功创建的事件。同样通过代理，客户机服务接收该事件并相应地对其做出反应——使用延迟任务更改实体的状态。该实体可以是例如给移动设备的带有广告的推送通知。</p><p id="3324" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方案的一个显著缺点是服务于这种交互的基础设施的复杂性。事实上，引入“等待”其他微服务响应的状态是分布式事务。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/cb8cfe897f3bc455a7d53f4da4158d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ENy11VQRZswdKzaC"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图2 —异步通道通信图</figcaption></figure><p id="2fc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图3显示了创建一个具有延迟执行的实体的过程，图4显示了该时间到来时的执行。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi np"><img src="../Images/a8393638ec993a461b26e5fb41d9ee9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-6aYivEyGgSx2YZf"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图3——创建延迟执行实体的过程</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi np"><img src="../Images/4fa90c3b54244097c33d85ca5fd0a452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TAxCQua6OVfxDWmK"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图4 —完成实体任务</figcaption></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="b89b" class="lo lp iq bd lq lr ls dn lt lu lv dp lw jy lx ly lz kc ma mb mc kg md me mf mg bi translated">共享</h2><p id="d907" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">创建任务时缺乏传递一些负载的能力可能会让一些人失望。但我向你保证，这是没有必要的。Trigger Hook包含足够的功能来构建任务管理器。将触发器挂钩视为位于基础设施级别的抽象层。关于任务的完整信息，比如类型、状态、执行时间、执行尝试次数、有效负载等等，将包含在Trigger Hook之上的抽象层中。</p><p id="106a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顶层将拥有领域知识。换句话说，任务管理器将有一组特定的任务类型，一组与特定类型的任务相关的事件。例如，对接口的请求听起来像“<em class="nq">创建一个用于发送电子邮件消息的延迟任务</em>”或“<em class="nq">创建一个用于订阅YouTube的延迟任务</em>”，任务管理器本身将使用请求“<em class="nq">创建一个延迟任务</em>来处理触发器挂钩。到了开始任务的时候，触发钩子将创建“<em class="nq">任务完成时间已到</em>事件。该事件将被任务管理器截获，任务管理器将通过发出例如事件“<em class="nq">订阅费借记时间已到</em>”来处理该事件。图5和图6展示了这个过程。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi np"><img src="../Images/ecd9fafa737466fb60db89b4328e07ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a4V84N0xL68mFS0z"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图5 —使用中间层创建任务</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi np"><img src="../Images/75c4d26987dce397b3dd58567c09466c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vkF-T4MU4R-M6XOC"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图6 —使用中间层的事件处理</figcaption></figure><p id="a01d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序组件之间的通信应该非常弱。这也适用于一般的微服务。实际上，加强沟通的原因之一是将一个部门的部分责任转移给另一个部门。因此，最困难的任务之一是找到(例如，单片)应用程序到微服务的分区边界。要成功做到这一点，您需要考虑领域。现在我们需要回答这个问题:我们应该将“任务管理器”层放在哪个微服务中？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nr"><img src="../Images/2405f3241cd0bc180fec66d7afc3c9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LV5J5vFQrEmeBjIw"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图7-带有触发挂钩的微服务中的任务管理器</figcaption></figure><p id="e6fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图7显示了一个图表，其中任务管理器是一个独立的微服务，包含关于任务类型、与这些任务相关的事件的领域知识。从图中可以看出，不同的客户端微服务应该共享任务管理器的一个微服务。每个微服务都有自己的接收事件的通道。在RabbitMQ中，这样的事件通道可以很容易地实现为直接模式。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ns"><img src="../Images/72ef223986f5e731e296fdad53304177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HitlW39-Ip-Vrvkx"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图8 —作为客户端微服务一部分的任务管理器</figcaption></figure><p id="f34d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图8显示了一个不同的方案，其中任务管理器是客户端微服务的一部分，仅用于其内部需求。如果没有其他使用延迟任务的微服务，或者如果每个微服务都有自己的带有触发挂钩微服务的任务管理器，那么这种方案是合适的。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="4fd8" class="lo lp iq bd lq lr ls dn lt lu lv dp lw jy lx ly lz kc ma mb mc kg md me mf mg bi translated">按比例放大</h2><p id="0d00" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">有些应用程序比其他应用程序更难扩展。如果应用程序状态只存储在具有竞争性访问支持的外部存储中，例如，经典的PHP + MySQL捆绑包，那么一切都会变得容易得多。在这种情况下，PHP应用程序的几个实例部署在不同的服务器上，Nginx平衡它们之间的负载，而MySQL资源对PHP应用程序的所有实例保持不变。如果MySQL失败，那么可以独立于PHP应用程序添加副本。</p><p id="6bbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当应用程序存储自己的状态时，事情就有点复杂了。横向扩展更加困难。触发挂钩将其状态存储在RAM中。它加载即将开始的任务。假设您已经创建了一个需要5秒钟完成的任务。这意味着Trigger Hook已经为执行预加载了它。但是你想取消这个任务。为此，调用delete API方法。从接受任务进行处理的应用程序实例中调用此方法非常重要。这是第一个难点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nt"><img src="../Images/fc24bc10c4a1ca7b4a217784c6bf1c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UApfXn2x_ShvxeYd"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图9 —水平比例图</figcaption></figure><p id="660f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个困难是每个触发器钩子实例必须在数据库中有自己的模式。这是因为在出现故障时要确保数据库的一致性。一般来说，从性能的角度来看，对单个数据库使用Trigger Hook实例是没有意义的，首先，因为Trigger Hook工作在多线程模式下，其次，在所有其他条件相同的情况下，数据库是一个瓶颈。</p><p id="6b42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图9显示了一个负载伸缩的例子。Trigger Hook的每个实例都有自己的数据库，在不同的服务器上(否则没有多大意义)。触发器挂钩实例前面有一个负载平衡器。除了平衡之外，它还将一个键-值对写入某个哈希映射数据库，比如Redis:</p><pre class="km kn ko kp gt nu nv nw nx aw ny bi"><span id="e10a" class="lo lp iq nv b gy nz oa l ob oc">task_id:instance_host</span></pre></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="d26f" class="mn lp iq bd lq mo mp mq lt mr ms mt lw mu mv mw lz mx my mz mc na nb nc mf nd bi translated">触发挂钩演示应用程序</h1><p id="47d0" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">该应用程序由五个微服务组成。每个人都使用Docker容器。一切都在Kubernetes上运行。该应用程序可以很容易地部署在minikube中。这里的描述了<a class="ae kl" href="https://github.com/pvelx/k8s-message-demo" rel="noopener ugc nofollow" target="_blank">的详细说明。</a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi np"><img src="../Images/547f3fd44b2225c99281d6ad9dfab336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cAAJam4_o--OOHBs"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图10 —微服务交互的简化方案</figcaption></figure><p id="b2f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/pvelx/message-service-demo" rel="noopener ugc nofollow" target="_blank">消息服务</a> —提供API的服务(图11)，用于创建电子邮件消息并分配它们在特定时间发送或取消。还允许您查看消息及其状态的完整列表。</p><p id="3017" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些功能:</p><ul class=""><li id="5638" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">位于域级别。</li><li id="83ba" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">它由一个消息管理器和一个任务管理器组成。</li><li id="6695" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">用PHP写的，Symfony 5框架。</li><li id="216e" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">它一式两份。第一个使用Nginx为API请求提供服务。第二个通过supervisor启动守护进程，监听来自RabbitMQ队列的事件。它有运行迁移的辅助实例。</li><li id="54d0" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">使用图8中的图表来管理任务。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi np"><img src="../Images/9140b00c4449dfc54e488ea31ec8e8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gwDzQ8TP4d2ky-qd"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图11-消息服务</figcaption></figure><p id="5d93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/pvelx/message-dashboard-demo" rel="noopener ugc nofollow" target="_blank">消息仪表板</a> —消息服务接口(图12)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi np"><img src="../Images/b28b39e8d0c7ec64d7aafb5bec81b4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oIjWgRoe0Zv43IBz"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图12 —演示应用程序界面</figcaption></figure><p id="dc89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">邮件服务位于基础设施层。必须直接做邮件列表。未实现，因为它在演示中并不重要。</p><p id="af6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/pvelx/trigger-service-demo" rel="noopener ugc nofollow" target="_blank">触发服务</a> —基础设施级服务。使用GRPC通道接收创建和删除任务的命令，使用AMQP通道发送任务执行时间事件(触发器)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi np"><img src="../Images/d1d5f441dae5d3a7c6c0272da7867ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UY0gUVw83At4FF5f"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图13 —触发服务</figcaption></figure><p id="e1b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">监控—也是在基础设施级别，因为它显示技术指标，而不参考业务事件。图14显示了面板的外观。由Grafana和InfluxDB使用。此处提供了指标的完整描述<a class="ae kl" href="https://github.com/pvelx/triggerhook#principle-of-operation" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi np"><img src="../Images/922ec01b08ad751810fe3c05cfeff8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tsQMDBVdsFAXe9NT"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">图14-触发挂钩技术指标</figcaption></figure><p id="0608" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望app和文章对你有用！关注<a class="ae kl" href="https://github.com/pvelx" rel="noopener ugc nofollow" target="_blank">我的github </a>，关注<a class="ae kl" href="https://github.com/pvelx/triggerhook" rel="noopener ugc nofollow" target="_blank">项目</a>，放星星)感谢！</p></div></div>    
</body>
</html>