<html>
<head>
<title>React Authentication with Twitter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Twitter进行身份验证</h1>
<blockquote>原文：<a href="https://itnext.io/react-authentication-with-twitter-2f6b7b0ee9d2?source=collection_archive---------1-----------------------#2018-07-21">https://itnext.io/react-authentication-with-twitter-2f6b7b0ee9d2?source=collection_archive---------1-----------------------#2018-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a798" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><pre>一个<a class="ae kl" href="https://react-auth-twitter.netlify.com/" rel="noopener ugc nofollow" target="_blank"> demo </a>抵得上1000字或者跳到<a class="ae kl" href="https://github.com/funador/react-auth-client" rel="noopener ugc nofollow" target="_blank">回购</a>/pre&gt;</pre></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d18bbfd3c42e1a0caa51f01482652263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJmTm_--L-rxx0fdW6XkrQ.jpeg"/></div></div></figure><blockquote class="ky kz la"><p id="81ae" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">如果你想更进一步，看看这篇关于与Twitter、Google、脸书和Github进行React认证的文章。</p></blockquote><p id="305c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OAuth建立的前提是使用一个秘密的api密钥来验证用户进入应用程序的身份。由于客户端应用程序不能对密钥保密，因此需要服务器与OAuth提供者(如Twitter)进行交互。</p><p id="3d2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是客户机和服务器的分离已经成为现代web应用程序的架构标准。那么，运行在不同主机上的客户机如何成功地与OAuth提供者交互呢？</p><p id="5ec2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题是有解决办法的。</p><p id="6f1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些，像<a class="ae kl" href="https://www.npmjs.com/package/react-twitter-auth#workflow" rel="noopener ugc nofollow" target="_blank"> React Auth Twitter </a>，看起来设计过度。其他的，像<a class="ae kl" href="https://firebase.google.com/docs/auth/" rel="noopener ugc nofollow" target="_blank"> Firebase </a>沉浸在黑魔法中，并抽象出所有的内部运作。</p><p id="25b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想充分了解这个过程是如何运作的，并分享我的解决方案。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lf"><img src="../Images/2652b974386c66b3c540dc42d38f7f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8BYWqy6RBDeOCvfG-qYOg.png"/></div></div></figure><p id="8612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上是传统的OAuth架构。客户端向服务器发起请求(但两者都运行在同一个端口上，本质上是向自己发出请求)。服务器中继到Twitter，然后用Twitter提供的用户数据将用户重定向到一个新页面。</p><p id="e2ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是可行的，因为客户端和服务器本质上是一个实体，并且服务器能够隐藏api密钥和秘密。</p><p id="b45a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，React应用程序通常与它们正在通信的服务器分离，这可能会导致像前面提到的<a class="ae kl" href="https://www.npmjs.com/package/react-twitter-auth#workflow" rel="noopener ugc nofollow" target="_blank"> React Auth Twitter </a> npm包这样的工作流…</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/2159df296218a5a7145f1614706c424c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*_gWehVVn9ensS4XhZH70Jw.png"/></div></figure><p id="f4c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那里有很多出错的中继站，肯定有更好的方法…</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lf"><img src="../Images/403e5e00db03f5c4f335613004da4644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76bGLGQ0byOhj-87VokyvQ.png"/></div></div></figure><p id="3dc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，客户机和服务器通过请求启动身份验证过程和通过套接字接收响应来进行通信。所有敏感信息仍然保存在服务器上，客户端是一个完全分离的实体，与现代应用程序架构相匹配。</p><p id="27fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是方法，让我们进入一些代码来看看实现…</p><p id="c827" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个项目是用<a class="ae kl" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>引导的。虽然我不会带你完成整个设置(有很多教程可以帮助你开始使用React)。我想集中讨论一个问题，如何在一个解耦的单页面应用程序上与提供者进行认证。</p><p id="7890" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个典型的React应用程序的设置，为了简单起见，许多变量都是硬编码的。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="cb7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一些基本的设置来连接套接字并将其指向适当的本地端口。</p><p id="061f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="lb">componentdimount</em></strong>是我们监听通过套接字从服务器发回的任何用户的地方，这样我们就可以更新用户的状态。</p><p id="c4f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要管理客户端通过弹出窗口向服务器发送请求。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="5510" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们有一些关于<strong class="jp ir"> <em class="lb"> App </em> </strong>类的方法，帮助我们与服务器启动的弹出窗口进行交互，并管理客户端的认证过程。</p><p id="3c79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，第26行的<strong class="jp ir"> <em class="lb"> url </em> </strong>上的req.query附有套接字id。这是服务器将正确的用户数据发送回正确连接的套接字的关键。</p><p id="32c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lb"> checkPopup </em> </strong>如果用户未经验证就关闭弹出窗口，则例行检查弹出窗口以重新启用登录按钮。</p><p id="781f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lb"> openPopup </em> </strong>在服务器上启动弹出窗口，并传递套接字id，以便它可以用于将用户数据发送回连接的客户端上的适当套接字。</p><p id="2cb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lb"> startPopup </em> </strong>启动在服务器上打开弹出窗口并监听弹出窗口的进程。它还禁用了登录按钮，因此用户无法尝试两次登录到提供商。</p><p id="3d80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很肯定你能弄清楚那是做什么的:)</p><p id="ef45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！</p><p id="d5f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需几行代码，我们就可以在服务器上触发一个请求，并在用户中止操作或服务器向我们发送相关用户信息时采取适当的操作。</p><p id="3265" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在渲染组件…</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="b96b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的render方法根据组件状态中是否存在用户来显示登录按钮或用户信息。</p><p id="b37c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是客户端代码的全部内容。</p><p id="da29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在服务器上…</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="8323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器也很简单。</p><p id="9bbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了<a class="ae kl" href="http://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank"> PassportJS </a>的常规设置之外，关键是使用中间件将套接字id添加到会话中(还记得我们在客户端触发弹出窗口时添加到请求中的套接字id)，以便用户数据可以被发送回适当的套接字。</p><p id="7d74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外，一切都遵循典型PassportJS设置的模式。</p><p id="6042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码是为了只与Twitter的OAuth交互。这里是一个<strong class="jp ir"> <em class="lb"> Twitter only </em> </strong>设置的<a class="ae kl" href="https://github.com/funador/react-auth-client/tree/twitter-auth" rel="noopener ugc nofollow" target="_blank">客户端</a>和<a class="ae kl" href="https://github.com/funador/react-auth-server/tree/twitter-auth" rel="noopener ugc nofollow" target="_blank">服务器</a>的代码。</p><p id="acc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，假设我们想更进一步…</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/faa99bc5b0bf2361c8714675d0f72090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*EvETMDQlFj7dD_98FF8O3g.gif"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated"><a class="ae kl" href="https://react-auth-twitter.netlify.com" rel="noopener ugc nofollow" target="_blank">Twitter/Google/脸书/Github认证演示(该应用程序中不存储任何用户数据</a></figcaption></figure><p id="a1bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们将谷歌、脸书和Github添加为OAuth提供商(<a class="ae kl" href="https://react-auth-twitter.netlify.com" rel="noopener ugc nofollow" target="_blank">演示</a>)。这无疑引入了一些复杂性，尤其是脸书的要求，即即使是开发应用程序也必须使用https来访问它们的API。但是一般模式是相同的，一旦OAuth成功，就使用套接字来传递用户数据。</p><p id="6fe9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为React组件的性质(超级可重用！)以及不同提供商的Passport策略的重叠，我们可以用少量的代码来实现这一点。</p><p id="9d00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是为<a class="ae kl" href="https://github.com/funador/react-auth-client" rel="noopener ugc nofollow" target="_blank">客户端</a>和<a class="ae kl" href="https://github.com/funador/react-auth-server" rel="noopener ugc nofollow" target="_blank">服务器</a>设置一个<strong class="jp ir"> <em class="lb">完整Twitter、谷歌、脸书、Github</em></strong>的代码和说明。如果你想让我在以后的帖子中更详细地描述这个过程，请告诉我。</p><p id="71d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与所有编程问题一样，有一百万种解决方案来验证React应用程序。我认为套接字非常适合追求简单性，但如果你有不同的方法/解决方案，我很想听听。</p><div class="lo lp gp gr lq lr"><a href="https://github.com/funador/react-auth-client" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd ir gy z fp lw fr fs lx fu fw ip bi translated">funador/react-auth-client</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">react-auth-client -使用react和Express的社交认证</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">github.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf kw lr"/></div></div></a></div></div></div>    
</body>
</html>