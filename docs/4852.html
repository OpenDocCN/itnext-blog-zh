<html>
<head>
<title>Your Single-Page App Is Now A Polyfill</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的单页应用程序现在是一个多填充</h1>
<blockquote>原文：<a href="https://itnext.io/your-single-page-app-is-now-a-polyfill-7881fb01694e?source=collection_archive---------0-----------------------#2020-10-07">https://itnext.io/your-single-page-app-is-now-a-polyfill-7881fb01694e?source=collection_archive---------0-----------------------#2020-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="393f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你根本无法击败平台</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/38843e5fa67728d349af24a498266509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vh2lLCS5ccp9eGrZ"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@ubahnverleih?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> C M </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2d3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们为什么要构建单页应用程序？两个主要原因。</p><p id="df10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们希望我们的网络应用程序感觉“即时”，页面之间没有任何丑陋的空白屏幕，提醒我们我们的应用程序并不真正像一个应用程序。</p><p id="2403" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">空白屏幕会导致糟糕的用户体验。当用户点击一个链接或按钮时，他们不希望等待来自服务器的内容。他们希望网站像本地应用一样快。</p><p id="d764" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们构建了单页面应用程序，其中只有页面中发生变化的内容会被替换，避免了整个页面的重新加载，因此导航到另一个页面的感觉是即时的。</p><p id="9358" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样做的另一个好处是，现在我们只需要从服务器获取更改的内容，而不是一个全新的页面。这减少了我们需要从网络获取的数据量，使我们的应用程序更快。这是我们构建单页应用的第二个主要原因。</p><p id="b412" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是单页应用程序带来了额外的复杂性。</p><p id="2b10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在绕过浏览器的路由，而是在客户端自己处理。大多数情况下，还会添加一个前端框架来处理这些页面的呈现，这进一步增加了复杂性。</p><p id="4b46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，框架当然可以做更多的事情，但这一切都是从消除页面之间的空白屏幕和减少有效载荷大小的愿望开始的。</p><p id="6dfb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我告诉你，你也可以拥有一个超快的多页面应用程序，页面之间没有任何空白屏幕，会怎么样？</p><p id="297c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个不需要任何客户端路由的多页面应用程序，其中每个新页面都是一个完整的页面重新加载，但只从服务器获取更改的内容。</p><h1 id="6860" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">流式HTML</h1><p id="f67d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让多页面应用程序快速运行的诀窍其实很简单:我们利用浏览器的流式HTML解析器。</p><p id="5879" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事情是这样的，浏览器在下载的同时呈现HTML <em class="mi">。它不需要等待整个响应的到达，但它可以在内容可用时立即开始呈现内容。</em></p><p id="e979" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由<code class="fe mj mk ml mm b">fetch</code>返回的<code class="fe mj mk ml mm b">Response</code>对象在其<code class="fe mj mk ml mm b">body</code>属性中公开了响应内容的<code class="fe mj mk ml mm b">ReadableStream</code>,因此我们可以访问它并开始传输响应:</p><pre class="kp kq kr ks gt mn mm mo mp aw mq bi"><span id="9f42" class="mr lg it mm b gy ms mt l mu mv">fetch('/some/url')<br/>.then(response =&gt; response.body)<br/>.then(body =&gt; {<br/>  const reader = body.getReader(); // we can now read the stream!</span><span id="57b0" class="mr lg it mm b gy mw mt l mu mv">}</span></pre><p id="be37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">典型的单页面应用程序使用应用程序外壳，它实际上是内容注入的单个页面。它通常由页眉、页脚和放置每页内容的内容区域组成。</p><p id="e45a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是，任何在加载后添加到HTML页面<em class="mi">的内容都会绕过</em>流HTML解析器，因此呈现速度较慢。</p><p id="7d73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，我们可以从浏览器流中受益，让服务人员获取我们需要的所有内容，并让它将所有内容传输到浏览器。</p><h1 id="8d6e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">客户端上的服务器端呈现</h1><p id="8ddd" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了实现这一点，我们需要将所有页面分成一个页眉和一个页脚，缓存这些模板，然后从网络上获取正文内容(如果需要的话)。</p><p id="598c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务工作者将拦截任何传出的请求，获取页眉和页脚，然后确定需要获取哪个主体内容。这可以是一个简单的HTML模板，也可以是一个模板和一些从网络上获取的数据的组合。</p><p id="b7e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，服务人员将这些部分组合成一个完整的HTML页面，并将其返回给浏览器。这就像服务器端的渲染，但都是在客户端以流的方式完成的，使用的是<code class="fe mj mk ml mm b">ReadableStream</code>。</p><p id="3714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着它可以在内容和页脚还在下载的时候就开始渲染页面的页眉，从而带来巨大的性能优势。</p><p id="bf90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一下代码，特别是每当服务工作者拦截到一个传出请求时就调用的<code class="fe mj mk ml mm b">fetch</code>事件处理程序:</p><pre class="kp kq kr ks gt mn mm mo mp aw mq bi"><span id="7ae5" class="mr lg it mm b gy ms mt l mu mv">const fetchHandler = async e =&gt; {<br/>  const {request} = e;<br/>  const {url, method} = request;<br/>  const {pathname} = new URL(url);<br/>  const routeMatch = routes.find(({url}) =&gt; url === pathname);<br/><br/>  if(routeMatch) {<br/>    e.respondWith(<strong class="mm iu"><em class="mi">getStreamedHtmlResponse</em></strong>(url, routeMatch));<br/>  }<br/>  else {<br/>    e.respondWith(<br/>      caches.match(request)<br/>      .then(response =&gt; response ? response : fetch(request))<br/>    );<br/>  }<br/>};</span><span id="6b60" class="mr lg it mm b gy mw mt l mu mv">self.addEventListener('fetch', fetchHandler);</span></pre><p id="c9ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">fetchHandler</code>函数检查传入的请求，并试图通过请求的<code class="fe mj mk ml mm b">url</code>在<code class="fe mj mk ml mm b">routes</code>数组中找到匹配的路由:</p><pre class="kp kq kr ks gt mn mm mo mp aw mq bi"><span id="0ffd" class="mr lg it mm b gy ms mt l mu mv">const routes = [<br/>  {<br/>    url: '/',<br/>    template: '/src/templates/home.html',<br/>    script: '/src/templates/home.js.html'<br/>  }</span><span id="d33b" class="mr lg it mm b gy mw mt l mu mv">  ...<br/>];</span></pre><p id="eaf7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于home route(“<code class="fe mj mk ml mm b">/</code>”)，它将在<code class="fe mj mk ml mm b">home.js.html</code>中的<code class="fe mj mk ml mm b">script</code>标签内找到<code class="fe mj mk ml mm b">home.html</code>模板和附带的JavaScript。</p><p id="ca23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，服务人员将获取模板<code class="fe mj mk ml mm b">header.html</code>和<code class="fe mj mk ml mm b">footer.html</code>，将它们与<code class="fe mj mk ml mm b">home.html</code>和<code class="fe mj mk ml mm b">home.js.html</code>组合成一个完整的HTML页面，并将其流回浏览器。</p><p id="6993" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在前面的例子中，这是在<code class="fe mj mk ml mm b">getStreamedHtmlResponse</code>函数中处理的。让我们来看看:</p><pre class="kp kq kr ks gt mn mm mo mp aw mq bi"><span id="5ed0" class="mr lg it mm b gy ms mt l mu mv">const getStreamedHtmlResponse = (url, routeMatch) =&gt; {<br/>  const stream = new <strong class="mm iu"><em class="mi">ReadableStream</em></strong>({<br/>    async start(controller) {<br/>      const pushToStream = stream =&gt; {<br/>        const reader = stream.getReader();<br/><br/>        return reader.read().then(function process(result) {<br/>          if(result.done) {<br/>            return;<br/>          }<br/>          controller.enqueue(result.value);<br/>          return reader.read().then(process);<br/>        });<br/>      };<br/><br/>      const [header, footer, content, script] = await Promise.all(<br/>        [<br/>          caches.match('/src/templates/header.html'),<br/>          caches.match('/src/templates/footer.html'),<br/>          caches.match(routeMatch.template),<br/>          caches.match(routeMatch.script)<br/>        ]<br/>      );<br/><br/>      await pushToStream(header.body);<br/>      await pushToStream(content.body);<br/>      await pushToStream(footer.body);<br/>      await pushToStream(script.body);<br/><br/>      controller.close();<br/>    }<br/>  });</span><span id="f8df" class="mr lg it mm b gy mw mt l mu mv">  // here we return the response whose body is the stream<br/>  <strong class="mm iu"><em class="mi">return new Response(stream, {<br/>    headers: {'Content-Type': 'text/html; charset=utf-8'}<br/>  });</em></strong><br/>};</span></pre><p id="cf84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mj mk ml mm b">getStreamedHtmlResponse</code>内部，我们构造了一个新的<code class="fe mj mk ml mm b">ReadableStream</code>，它被传递了一个<code class="fe mj mk ml mm b">underlyingSource</code>对象，包含了在流被构造之后立即被调用的<code class="fe mj mk ml mm b">start</code>方法。</p><p id="307d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向<code class="fe mj mk ml mm b">start</code>传递一个<code class="fe mj mk ml mm b">controller</code>参数，该参数是一个<code class="fe mj mk ml mm b">ReadableStreamDefaultController</code>，允许控制<code class="fe mj mk ml mm b">ReadableStream</code>的内部状态和队列。</p><p id="41c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mj mk ml mm b">start</code>方法中，我们获取HTML页面的模板，并使用<code class="fe mj mk ml mm b">pushToStream</code>函数将模板的内容作为单独的流推入主流。</p><p id="9455" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个函数从模板中逐块读取单个流，并使用<code class="fe mj mk ml mm b">controller.enqueue()</code>将它们排队。</p><p id="215f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为<code class="fe mj mk ml mm b">start</code>函数是异步的，所以会立即返回一个新的<code class="fe mj mk ml mm b">Response</code>，并将<code class="fe mj mk ml mm b">ReadableStream</code>作为响应的主体。</p><p id="ae13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">浏览器现在可以传输响应，页面几乎立即出现在屏幕上。</p><p id="65b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们暂时记住这一点:我们现在能够即时提供回复，就像单页应用程序一样，但是没有单页应用程序带来的任何复杂性。T9】</p><p id="ab43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没有客户端路由，没有框架，也没有复杂的服务器端渲染。</p><p id="3d8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有渲染都由服务人员处理，他们提供极快的流响应。</p><h1 id="7038" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">单页应用程序是多种多样的</h1><p id="34a5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这基本上将单页应用简化为多页，这是一个相当大胆的声明，但原因如下:</p><ul class=""><li id="fcae" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">这款多页面应用程序的渲染速度将与单页面应用程序一样快，甚至在页面大小增加时会更快，因为我们使用了浏览器的流式HTML解析器。单页应用程序<em class="mi">绕过</em>流解析器，而<em class="mi">未能</em>利用它。</li><li id="f93a" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">就像在单页应用程序中一样，只从网络中获取发生变化的内容。但是因为服务工作者缓存所有资产并在本地为它们提供服务，所以网络流量被限制在绝对最低限度。</li><li id="4c29" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">应用程序的复杂性大大降低。不再需要客户端路由，也不需要框架来呈现页面。服务工作者负责所有的渲染，它在自己的线程中运行，与主UI线程分开。</li><li id="e733" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">服务器端渲染是免费的，只需将单独的模板拼接在一起，就像其他HTML页面一样提供服务。当服务工作者还没有控制页面时，这些将在第一次呈现时被提供。在随后的呈现中，服务工作者将无缝地提供缓存的页面，因为不需要考虑客户端路由。</li></ul><h1 id="08b0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">真的管用吗？</h1><p id="7ae9" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">现在你可能会想，在速度和性能方面，这样的多页面应用程序是否真的能打败单页面应用程序。</p><p id="a933" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://instantmultipageapp.com/" rel="noopener ugc nofollow" target="_blank">我制作了一个演示</a>,这样你就可以亲眼看到使用流HTML的多页面应用程序有多快。你可以在Github上的这里找到源代码<a class="ae le" href="https://github.com/DannyMoerkerke/instant-multi-page-app" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="811b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你四处点击，你会注意到页面的标题牢牢地留在原处，即使每个页面都需要重新加载，有些页面相当重。</p><p id="fd93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们使用流式HTML解析器，这就是浏览器在呈现DOM <em class="mi">方面有多好。</em></p><p id="627c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">浏览器不慢。DOM并不慢。我们试图将单页应用程序模型硬塞进一个本质上是多页的介质中，向它扔进框架和大量的库，这种方式使它变得很慢。</p><h1 id="8789" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="fdaf" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">使用服务人员并正确利用浏览器的流HTML解析器可以极大地提高web应用程序的性能，并且通常会破坏拥有单页应用程序的目的。</p><p id="0f3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你现在是在<em class="mi">与</em>平台合作，而不是<em class="mi">对抗</em>平台。</p><p id="0674" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要把一个框架和十几个库扔在你的应用上，保持简单，使用平台。</p><p id="574d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会发现这就是你所需要的。</p><p id="52e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mi">你可以</em> <a class="ae le" href="https://twitter.com/dannymoerkerke" rel="noopener ugc nofollow" target="_blank"> <em class="mi">在Twitter上关注我</em> </a> <em class="mi">在那里我定期写关于PWAs、web组件和现代Web功能的文章。</em></p></div></div>    
</body>
</html>