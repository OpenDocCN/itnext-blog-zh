<html>
<head>
<title>Add chat to your Ruby on Rails app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将聊天添加到Ruby on Rails应用程序中</h1>
<blockquote>原文：<a href="https://itnext.io/add-chat-to-your-ruby-on-rails-app-8df47928bcc3?source=collection_archive---------6-----------------------#2019-05-06">https://itnext.io/add-chat-to-your-ruby-on-rails-app-8df47928bcc3?source=collection_archive---------6-----------------------#2019-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="d15e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不是所有的网络应用都需要聊天，但是如果你想和你的客户交流，或者你想让他们互相交流，你很快就会遇到这个问题。CometChat Pro是推出自己的聊天服务的绝佳选择。您将会看到，您可以轻松地将聊天插入到您的应用程序中，而不会妨碍您可能正在交付的其他内容。</p><h1 id="99b9" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">先决条件</h1><p id="e7ff" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">本教程根本没有假设太多的知识。Ruby on Rails是一个非常容易上手的框架。如果你曾经使用过其他的网络技术，你可能会发现它非常清晰和固执己见。</p><p id="7bd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CometChat Pro本身需要在Javascript中运行，所以你会看到基于Ruby的框架和通过Javascript的视图操作之间的联姻。在Rails中有许多更复杂的方法来处理这个问题。对于本教程，我保留了基本Javascript和模板引擎Rails附带的一切:erb。Rails爱好者将能够轻松地将这些基础工具转化为他们的专业设置。</p><p id="8940" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我假设您能够运行Rails应用程序——这意味着您已经安装了Ruby和bundler。这个应用程序使用Ruby 2.5.3和Rails 5.2.2，但是对于最新版本来说，这里没有什么特别的——你可以将这些工具插入任何现代版本的Rails中。</p><h1 id="913f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">介绍</h1><p id="48e2" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">构建聊天最困难的部分之一是处理并发性——用户需要在不刷新浏览器的情况下看到新消息。正如您将看到的，CometChat Pro用很少的代码实现了这一点。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/930d31e2a3f08904a2d43a898e497e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*Ep6n3bE9qfBM05AX.gif"/></div></figure><p id="e72f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你曾经尝试过使用Action Cable来实现类似的结果，你会非常满意你可以如此快速地在浏览器中复制粘贴到实时更新。</p><p id="4f64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以直接跳到Github 上的<a class="ae lz" href="https://github.com/cometchat-pro-samples/ruby-on-rails-chat" rel="noopener ugc nofollow" target="_blank">代码，或者带着这个家伙来一次</a><a class="ae lz" href="https://ccp-sample-app.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">自我旋转</a>。让我们得到它！</p><h1 id="2b36" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">安装</h1><h1 id="66d7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">初始化</h1><p id="179a" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">给自己拿一个终端，启动一个新的Rails应用:<code class="fe ma mb mc md b">rails new cometchatpro --skip-active-record -T</code>。为此我们不需要数据库，并且<code class="fe ma mb mc md b">-T</code>阻止Rails为我们创建测试文件。如果你已经有了一个应用程序，你可以跳过这一步——把这个代码放到一个现有的项目中应该很容易。</p><h1 id="d5ca" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">环境变量和CometChat凭证</h1><p id="3ca1" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">接下来，你需要一个API密匙和一个来自CometChat <a class="ae lz" href="https://app.cometchat.com/" rel="noopener ugc nofollow" target="_blank"> Pro </a>的应用ID。登录后，进入仪表板，创建一个新的应用程序，然后生成一个API密钥。你需要<code class="fe ma mb mc md b">fullAccess</code>，而不仅仅是<code class="fe ma mb mc md b">authOnly</code>。拿起这些证书，把它们添加到你的<code class="fe ma mb mc md b">.env</code>文件中。您需要您的文件看起来像这样:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="792c" class="mi kp it md b gy mj mk l ml mm">COMETCHAT_APP_ID=23n2f2n3p2y3<br/>COMETCHAT_API_KEY=av22g24ll</span></pre><p id="c9e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，将<code class="fe ma mb mc md b">dotenv-rails</code>添加到你的Gemfile和<code class="fe ma mb mc md b">bundle</code>中。现在，您的应用程序可以读取您的环境变量。这些是您的CometChat Pro帐户的私人凭据；<strong class="js iu">不要将此文件提交到您的版本控制中！</strong></p><h1 id="41ff" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">聊天页面</h1><p id="91b8" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">接下来，我们将添加一些样板Rails视图和路由，以便我们可以作为一个用户与其他用户聊天。生成新的控制器:<code class="fe ma mb mc md b">rails generate controller Users</code>。这将创建一些文件，我们很快就会看到。您还需要在<code class="fe ma mb mc md b">config/routes.rb</code>中为您的新视图添加一条路线。下面是我的<code class="fe ma mb mc md b">routes.rb</code>的样子:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="55c3" class="mi kp it md b gy mj mk l ml mm">Rails.application.routes.draw do<br/>  resources :users, only: %i[index show]</span><span id="1896" class="mi kp it md b gy mn mk l ml mm">  root 'users#index'<br/>end</span></pre><p id="8e00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你跳转到<a class="ae lz" href="https://github.com/cometchat-pro-samples/ruby-on-rails-chat" rel="noopener ugc nofollow" target="_blank"> GitHub代码</a>或者跳到<a class="ae lz" href="https://ccp-sample-app.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">托管应用</a>，你会看到我已经添加了用户创建。我把它留在原地，因为我已经构建了它，但是<strong class="js iu"> CometChat Pro附带了每个帐户的示例用户</strong>，所以你可以立即开始测试，而不需要首先设置用户创建。为了简洁起见，我在本教程中省略了对用户创建的讨论，但是您可以在Github repo中看到所需的代码。</p><p id="18e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还需要创建一个<code class="fe ma mb mc md b">/views/users/show.html.erb</code>文件。我们一会儿就把它装满。</p><h1 id="0258" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">CometChat服务</h1><p id="4d50" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们进入应用程序的核心——与CometChat API交互。我把与CometChat Pro的互动组织成一项服务。它看起来是这样的:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="a642" class="mi kp it md b gy mj mk l ml mm">class CometChatService<br/>  include HTTParty<br/>  BASE_URI = 'https://api.cometchat.com/v1'.freeze</span><span id="5d11" class="mi kp it md b gy mn mk l ml mm">  def fetch_users<br/>    response = HTTParty.get("#{BASE_URI}/users", headers: headers)<br/>    response.dig('data')<br/>      &amp;.map { |user| {name: user['name'], id: user['uid']} }<br/>  end</span><span id="f7c9" class="mi kp it md b gy mn mk l ml mm">  private</span><span id="6622" class="mi kp it md b gy mn mk l ml mm">  def headers<br/>    {<br/>      apikey: ENV['COMETCHAT_API_KEY'],<br/>      appid: ENV['COMETCHAT_APP_ID']<br/>    }<br/>  end<br/>end</span></pre><p id="8151" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CometChat Pro做了很多事情，随着我们应用程序的增长，我们可能希望通过与他们的API的进一步交互来填充这项服务。在这里，我们需要做的就是获取一个可以聊天的用户列表。请注意，与CCP交互不需要gem，您只需发送您喜欢的带有适当标题(来自我们的<code class="fe ma mb mc md b">.env</code>文件)的请求(我使用的是http party ), CCP就会发回您请求的信息。</p><p id="2ae7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将来自CCP的JSON响应映射到我的应用程序需要的信息——用户名和用户ID。</p><h1 id="95da" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">使用用户控制器中的服务</h1><p id="0573" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">既然我们已经建立了与CCP API对话的协议，我们可以在我们的<code class="fe ma mb mc md b">UsersController</code>中使用它。这是我的样子:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="15c5" class="mi kp it md b gy mj mk l ml mm">class UsersController &lt; ApplicationController<br/>  def index<br/>    @users = CometChatService.new.fetch_users<br/>  end</span><span id="86e7" class="mi kp it md b gy mn mk l ml mm">  def show<br/>    users = CometChatService.new.fetch_users<br/>    @current_user = users.find { |user| user[:id] == params[:id] }<br/>    @users = users.reject { |user| user[:id] == @user[:id] }<br/>  end<br/>end</span></pre><p id="99a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了简洁起见，我跳过了<code class="fe ma mb mc md b">index</code>页面，但它只是我们可以“聊天”的用户列表。你可以把它想象成最不安全、最荒谬的登录页面。在这两个视图中，我们获取注册了CometChat Pro应用程序的用户。我们已经在服务中映射了JSON响应，所以在索引和显示页面上，我们循环显示用户。在show页面上，我们以用户的身份聊天，所以我们不希望他出现在可能的聊天对象列表中(第9行)。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/97f23d8a1514ac9bd1070e541b289e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I-oI-ps01o9LsQv6.png"/></div></div></figure><h1 id="aa55" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">用户显示视图</h1><p id="b458" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们依次浏览用户展示页面的各个部分。一会儿，我们将讨论让它们运行所需的Javascript。我还省略了对样式的讨论。你可以在<a class="ae lz" href="https://github.com/cometchat-pro-samples/ruby-on-rails-chat" rel="noopener ugc nofollow" target="_blank"> GitHub </a> repo中看到完整的样式代码，当然你也可以实现自己的样式(当然要好得多)。</p><h1 id="5deb" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">谁在说话？</h1><p id="6081" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">为了向CometChat服务提供关于我们的“登录”用户(我们所在的显示页面)的信息，我们需要包含一个带有用户名和id的不可见div。您可以将它放在页面的任何位置:</p><h1 id="8a6c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">用户列表</h1><p id="0bb5" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">要显示如上所示的用户列表，下面是erb代码:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="91a3" class="mi kp it md b gy mj mk l ml mm">&amp;ltul class="list-group list-group-flush"&gt;<br/>  &amp;lt% @users.each do |user| %&gt;<br/>    &amp;ltli class="list-group-item user-select bg-light" id="&amp;lt%= user[:id] %&gt;" name='user-select'&gt;<br/>      &amp;ltdiv class="d-flex w-100 justify-content-between"&gt;<br/>        &amp;lth5 class="mb-1"&gt;&amp;lt%= user[:name] %&gt;&amp;lt/h5&gt;<br/>      &amp;lt/div&gt;<br/>    &amp;lt/li&gt;<br/>  &amp;lt% end %&gt;<br/>&amp;lt/ul&gt;</span></pre><p id="d377" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里没有什么特别的事情发生——唯一需要注意的是，我们将用户id设置为list-item上的id。我们稍后将需要它来引用我们正在与之对话的用户。记住，我们的<code class="fe ma mb mc md b">@users</code>来自控制器，我们从CometChat服务收集用户列表。</p><h1 id="34ff" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">接收和显示消息</h1><p id="ee28" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">接下来，让我们看看如何显示收到的消息。我们的代码是这样开始的:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="fbe3" class="mi kp it md b gy mj mk l ml mm">&amp;ltdiv id="messages" class="messages"&gt;<br/>    Messages loading...<br/>&amp;lt/div&gt;</span></pre><p id="1aa1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要为CometChat Pro提供一个<code class="fe ma mb mc md b">div</code>来加载消息。我叫我的<code class="fe ma mb mc md b">messages</code>，但是你可以叫你的任何你喜欢的名字。</p><h1 id="8109" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">发送消息</h1><p id="5938" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们将使用Ruby的表单助手来创建我们的消息表单，但是我们不让Ruby处理这里的任何功能:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="350c" class="mi kp it md b gy mj mk l ml mm">&amp;lt%= form_for :message, remote: true do |f| %&gt;<br/>    &amp;ltdiv class="col-xs-9"&gt;<br/>      Message : &amp;lt%= f.text_area :text, class: "form-control" %&gt;&amp;ltbr/&gt;<br/>    &amp;lt/div&gt;<br/>    &amp;ltdiv class="col-xs-3 capitalize"&gt;<br/>      &amp;lt%= button_tag "Send Message", type: 'button', onclick: "javascript:sendMessage()", class: "btn btn-info btn-block" %&gt;<br/>    &amp;lt/div&gt;<br/>&amp;lt% end %&gt;</span></pre><p id="def5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们点击“发送消息”按钮时，我们将使用Javascript施展我们的魔法。Rails表单会一直呆在那里，愉快地等待更多的输入。</p><h1 id="85ce" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">我们应用程序的核心:Javascript方法</h1><p id="e83d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">CometChat Pro服务运行在Javascript上，我们将使用他们清晰的示例代码来使我们的应用程序工作。</p><p id="c751" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要采取以下步骤:</p><p id="4681" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.初始化—建立与CometChat服务的连接。</p><p id="2d57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.以当前用户身份登录。</p><p id="7882" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.选择要与之聊天的用户，并获取该用户的消息历史记录。</p><p id="1c11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.添加一个事件监听器来接收来自其他人的新消息。</p><p id="168e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.设置发送消息的操作。</p><h1 id="0874" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">初始化</h1><p id="46fb" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">首先，我们需要让我们的应用程序与CometChat Pro服务对话并登录。在<code class="fe ma mb mc md b">application.html.erb</code>中，在<code class="fe ma mb mc md b">&lt;head&gt;</code>标签之间添加此行:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="ffbc" class="mi kp it md b gy mj mk l ml mm">&amp;ltscript type="text/javascript" src="https://unpkg.com/@cometchat-pro/chat/CometChat.js"&gt;&amp;lt/script&gt;</span></pre><p id="cb6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">把这几行加到<code class="fe ma mb mc md b">/views/users/show.html.erb</code>的底部:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="7002" class="mi kp it md b gy mj mk l ml mm">&amp;lt% javascript_include_tag 'show', cache: 'myfiles' %&gt;<br/>&amp;ltscript type="text/javascript"&gt;<br/>    setUserListeners();<br/>    document.addEventListener('turbolinks:load', initializeChat);<br/>&amp;lt/script&gt;</span></pre><p id="6808" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们马上会看到<code class="fe ma mb mc md b">setUserListeners</code>方法。最后，我们引用了一个<code class="fe ma mb mc md b">show.js.erb</code>，我们需要创建它并添加到<code class="fe ma mb mc md b">app/assets/javascripts</code>。</p><p id="ccfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们的第一个Javascript方法:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="4d9e" class="mi kp it md b gy mj mk l ml mm">const initializeChat = () =&gt; {<br/>    CometChat.init('').then(<br/>      hasInitialized =&gt; {<br/>        loginUser()<br/>      },<br/>      error =&gt; {<br/>        console.log("Initialization failed with error:", error);<br/>      }<br/>  )};</span></pre><p id="41f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们在<code class="fe ma mb mc md b">application.html.erb</code>中加载了CometChat Pro Javascript，所以我们现在可以在Javascript文件中使用<code class="fe ma mb mc md b">CometChat</code>方法。我们将使用的第一个是<code class="fe ma mb mc md b">.init</code>，它要求我们发送我们的应用ID作为凭证。一旦我们的聊天被初始化，我们就调用<code class="fe ma mb mc md b">loginUser</code>方法。</p><h1 id="84a3" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">用户登录</h1><p id="c906" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">初始化后，我们需要登录当前用户。这个应用程序不包含任何安全措施——任何人都可以像其他人一样聊天。显然，你会希望在一个生产应用程序中有一点点更加定制化的东西。以下是我们在CometChat Pro上登录用户的方式:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="87eb" class="mi kp it md b gy mj mk l ml mm">const loginUser = () =&gt; {<br/>    const userDiv = document.getElementById('user-id');<br/>    if (!userDiv) { return true }</span><span id="77a0" class="mi kp it md b gy mn mk l ml mm">    const id = userDiv.dataset.id;<br/>    CometChat.login(id, '').then(<br/>        User =&gt; {<br/>          const messageDiv = document.getElementById('messages');<br/>          messageDiv.innerHTML = `&lt;div class="whisper"&gt;Choose a  user to start chatting&lt;/div&gt;`;<br/>        },<br/>        error =&gt; {<br/>            console.log("Login failed with exception:", {error});<br/>        })<br/>}</span></pre><p id="26e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还记得那个保存了我们来自<code class="fe ma mb mc md b">show.html.erb</code>的用户信息的奇怪的<code class="fe ma mb mc md b">tag('div')</code>吗？在这里，我们使用它来找出什么用户需要登录。如果div出了问题，我们就退出这次行动。</p><p id="969a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们调用我们的下一个CometChat方法:<code class="fe ma mb mc md b">.login</code>。我们从用户div获取<code class="fe ma mb mc md b">id</code>,并使用我们的API凭证。如果CometChat Pro发回一个<code class="fe ma mb mc md b">User</code>，我们更新消息div说“选择一个用户开始聊天”。</p><h1 id="6b7a" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">setUserListeners</h1><p id="2170" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们跳回到我们在视图底部调用了<code class="fe ma mb mc md b">setUserListeners()</code>的<code class="fe ma mb mc md b">show.html.erb</code>页面。为了知道我们想和谁聊天，我们需要监听用户列表上的点击。下面是这段代码的样子:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="3fae" class="mi kp it md b gy mj mk l ml mm">const setUserListeners = () =&gt; {<br/>    const userDivs = document.getElementsByName('user-select');<br/>    userDivs.forEach(user =&gt; user.addEventListener("click", e =&gt; {<br/>        const id = e.target.id || e.target.offsetParent.id<br/>        setUser(id);<br/>        fetchMessages(id);<br/>    }))<br/>}</span></pre><p id="d626" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ma mb mc md b">userDivs</code>是div的节点列表，我们可以与之聊天的每个用户对应一个div。我们遍历它们，并在每一个上添加事件侦听器。如果我们点击一个用户，我们想首先调用<code class="fe ma mb mc md b">setUser</code>来告诉我们的应用程序我们想和谁通话，然后调用<code class="fe ma mb mc md b">fetchMessages</code>来告诉那个用户。</p><h1 id="8b26" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">setUser和addMessageListener</h1><p id="427e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这是我们真正获得一些魔力的地方，CometChat Pro会为我们处理繁重的工作。一旦我们的用户登录并选择了要聊天的人，我们希望实时看到来自那个人的任何新消息。有了CometChat Pro，我们不必担心保持任何websockets打开或处理刷新——消息就像你预期的那样出现。</p><p id="6bbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ma mb mc md b">setUser</code>函数只关心使列表中的活动用户变成蓝色，所以我在这里跳过了它。但是它也调用了<code class="fe ma mb mc md b">addMessageListener</code>类，这对于接收新消息是至关重要的:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="1abf" class="mi kp it md b gy mj mk l ml mm">const addMessageListener = id =&gt; {<br/>    CometChat.addMessageListener(<br/>        'listener_id',<br/>        new CometChat.MessageListener({<br/>            onTextMessageReceived: textMessage =&gt; displayNewMessage(id, textMessage)<br/>        })<br/>)}</span></pre><p id="8ca4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这几乎直接取自CometChat <a class="ae lz" href="https://prodocs.cometchat.com/docs" rel="noopener ugc nofollow" target="_blank"> Pro文档</a>。我们调用CometChat <code class="fe ma mb mc md b">addMessageListener</code>方法，然后使用传入的消息更新我们的消息div。启动两个不同的浏览器来看看这是怎么回事(或者看看上面的gif)。</p><h1 id="2e63" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">显示新消息</h1><p id="763e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">当新消息进来时，我们需要更新我们的视图。代码如下:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="d116" class="mi kp it md b gy mj mk l ml mm">const displayNewMessage = (currentChatterId, msg) =&gt; {<br/>    const userDiv = document.getElementById('user-id');<br/>    const id = userDiv.dataset.id;<br/>    if (![currentChatterId, id].includes(msg.sender.uid)) { return; }</span><span id="1e65" class="mi kp it md b gy mn mk l ml mm">    const newNode = document.createElement("div")<br/>    newNode.innerHTML = newMessage(msg, id)<br/>    const messageDiv = document.getElementById('messages')<br/>    messageDiv.appendChild(newNode)<br/>    messageDiv.scrollTop = messageDiv.scrollHeight<br/>}</span></pre><p id="1a68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，如果收到的消息不是我们的登录用户和我们正在聊天的用户之间的，我们忽略它。然后，我们需要处理新的消息——我们用消息构造一个新的div，然后我们将它附加到<code class="fe ma mb mc md b">messages</code> div，再次滚动到底部以便我们可以看到它。</p><h1 id="6001" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">新消息</h1><p id="bdb5" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们的<code class="fe ma mb mc md b">newMessage</code>方法将简单地格式化信息——这是我们聊天应用中的一个新泡泡。我们检查发送者是否具有与登录用户相同的id，这样我们就可以将self类应用到div——将“self”设为粉红色，将其他所有人设为蓝色。</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="866e" class="mi kp it md b gy mj mk l ml mm">const newMessage = (msg, id) =&gt; {<br/>    return (<br/>        `&amp;ltdiv class='message ${msg.sender.uid === id &amp;&amp; 'self'}'&gt;<br/>          &amp;ltdiv class='message-text'&gt;${msg.text}&amp;lt/div&gt;<br/>          &amp;ltdiv class='message-sender'&gt;- ${msg.sender.name}&amp;lt/div&gt;<br/>        &amp;lt/div&gt;`<br/>    )<br/>}</span></pre><h1 id="917d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">fetch消息</h1><p id="5a35" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在我们开始聊天之前，我们需要查看之前收到的消息，以及当我们不与特定用户聊天时交换的任何内容。我们的<code class="fe ma mb mc md b">fetchMessages</code>方法将获取我们登录的用户和我们选择的用户之间的消息。</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="3af5" class="mi kp it md b gy mj mk l ml mm">const fetchMessages = id =&gt; {<br/>    if (!id) { return; }</span><span id="2309" class="mi kp it md b gy mn mk l ml mm">    const limit = 30;<br/>    const messagesRequest = new CometChat.MessagesRequestBuilder().setUID(id).setLimit(limit).build();<br/>    messagesRequest.fetchPrevious().then(<br/>        messages =&gt; {<br/>            const messageDiv = document.getElementById('messages');<br/>            messageDiv.innerHTML = messages.length &gt; 0 ?<br/>              messages.map(msg =&gt; newMessage(msg, id)).join('') :<br/>              `&amp;ltdiv class="whisper"&gt;Start of message history&amp;lt/div&gt;`;<br/>            messageDiv.scrollTop = messageDiv.scrollHeight<br/>        },<br/>        error =&gt; {<br/>            console.log("Message fetching failed with error:", error);<br/>        }<br/>    );<br/>}</span></pre><p id="f4d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果由于某种原因我们没有一个<code class="fe ma mb mc md b">id</code>，我们将返回以免出错。首先，我们构造我们的请求，设置我们想要对话的用户的ID，以及我们想要接收的消息的限制。更复杂的应用程序会希望在用户滚动时自动获取更早的结果。</p><p id="9d85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们的消息请求者设置好了，我们就可以调用<code class="fe ma mb mc md b">fetchPrevious</code>来获取消息列表。这将返回<code class="fe ma mb mc md b">messages</code>，我们可以用它来填充我们的<code class="fe ma mb mc md b">messages</code> div。每条消息都是一个JSON对象，带有一个<code class="fe ma mb mc md b">sender.uid, sender.name</code>和一个<code class="fe ma mb mc md b">text</code>。我们映射消息，将它们作为HTML对象返回，并用新的消息节点列表替换<code class="fe ma mb mc md b">messages</code>中的内容。记住把它们分开，否则你会在div之间看到一串逗号。如果没有消息，我们希望向用户显示这是“消息历史的开始”。</p><p id="38a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们希望滚动到messages div的底部，向用户显示最新的消息。</p><h1 id="83a0" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">发送新邮件</h1><p id="3b66" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们登录，选择一个用户与之聊天，获取这两个用户之间的所有旧消息历史，并接收该用户发送给我们的任何新消息。最后，我们希望能够发送消息。我们是这样做的:</p><pre class="ls lt lu lv gt me md mf mg aw mh bi"><span id="34cf" class="mi kp it md b gy mj mk l ml mm">const sendMessage = () =&gt; {<br/>    const recipient_id = document.getElementsByClassName('bg-info')[0].id;<br/>    const message_text = document.getElementsByName('message[text]')[0].value;<br/>    document.getElementsByName('message[text]')[0].value = ''</span><span id="21e7" class="mi kp it md b gy mn mk l ml mm">    const messageType = CometChat.MESSAGE_TYPE.TEXT;<br/>    const receiverType = CometChat.RECEIVER_TYPE.USER;<br/>    const textMessage = new CometChat.TextMessage(recipient_id, message_text, messageType, receiverType);</span><span id="4122" class="mi kp it md b gy mn mk l ml mm">    CometChat.sendMessage(textMessage).then(<br/>        message =&gt; displayNewMessage(recipient_id, message),<br/>        error =&gt; {<br/>            console.log("Message sending failed with error:", error);<br/>        }<br/>    );<br/>}</span></pre><p id="b335" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们根据列表中突出显示的用户来确定正在与哪个用户聊天。接下来，我们从表单中读取消息，并清除表单以便为下一条消息做准备。</p><p id="65ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的<code class="fe ma mb mc md b">textMessage</code>对象将调用<a class="ae lz" href="https://prodocs.cometchat.com/docs/js-messaging" rel="noopener ugc nofollow" target="_blank"> CCP的</a> <code class="fe ma mb mc md b"><a class="ae lz" href="https://prodocs.cometchat.com/docs/js-messaging" rel="noopener ugc nofollow" target="_blank">TextMessage</a></code> <a class="ae lz" href="https://prodocs.cometchat.com/docs/js-messaging" rel="noopener ugc nofollow" target="_blank">方法</a>，根据登录用户、接收者id、消息文本、消息类型和接收者构造要发送的消息。然后我们用我们的<code class="fe ma mb mc md b">textMessage</code>对象<code class="fe ma mb mc md b">sendMessage</code>，等待一个<code class="fe ma mb mc md b">message</code>响应，并以我们处理来自另一个用户的传入消息的相同方式呈现消息。</p><p id="db08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">朋友们，这就是我们在Rails应用程序中安装chat所需的一切！</p><h1 id="9e0d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结论</h1><p id="c765" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果您一直在跟进，那么现在您的项目中已经有了一个全功能的一对一聊天应用程序。您可以开始探索CometChat Pro提供的其他功能，或者使用jQuery、Slim或其他您希望用来减少代码的工具开始重构。希望在普通Javascript中看到的一切能清楚地表明我们正在完成什么，即使您希望在自己的应用程序中有更高效的代码。</p><p id="6faf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">祝您在自己的应用程序中安装聊天工具时好运，祝您玩得开心！</p><h1 id="33c4" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">链接</h1><ul class=""><li id="467a" class="mt mu it js b jt lm jx ln kb mv kf mw kj mx kn my mz na nb bi translated"><a class="ae lz" href="https://github.com/cometchat-pro-samples/ruby-on-rails-chat" rel="noopener ugc nofollow" target="_blank"> Github仓库</a>用这段代码+用户创建</li><li id="7657" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae lz" href="https://ccp-sample-app.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> Heroku部署</a>所以你可以看到它快速运行。试试两个浏览器！</li><li id="1065" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">CometChat <a class="ae lz" href="https://prodocs.cometchat.com/docs" rel="noopener ugc nofollow" target="_blank"> Pro文档</a></li><li id="7f2d" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae lz" href="https://github.com/jnunemaker/httparty" rel="noopener ugc nofollow" target="_blank">http党宝石</a></li></ul></div></div>    
</body>
</html>