<html>
<head>
<title>Distributed Tracing with Quarkus, Python, Open Telemetry and Jaeger (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Quarkus、Python、Open Telemetry和Jaeger进行分布式追踪(第3部分)</h1>
<blockquote>原文：<a href="https://itnext.io/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-3-79137543b2c5?source=collection_archive---------3-----------------------#2022-08-17">https://itnext.io/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-3-79137543b2c5?source=collection_archive---------3-----------------------#2022-08-17</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="7f8e" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">本系列的最后两部分(<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-1-2d83f761b786"> 1 </a>、<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-2-d533e3a83703"> 2 </a>)集中在跟踪基础知识和针对http请求的<a class="ae km" href="https://quarkus.io" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>和Python代码的插装上。一种非常流行的数据传输机制是Apache Kafka。在这篇文章中，我们将看看如何检测Kafka使用的代码，并让跟踪传播工作。总的场景与前面的相似，除了Quarkus部分，我只使用了一个服务器:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj kn"><img src="../Images/78ddd05905e781357011e8ae0af67908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmQsURZAhFXsOoUHMYaPoA.png"/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">该零件的设置</figcaption></figure><p id="666d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">Quarkus在<em class="ld"> pom.xml </em>和<em class="ld"> application.properties </em>中被配置为跟踪，如本系列第一部分中的<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-1-2d83f761b786">所述。向<em class="ld">主题1 </em>发送数据的发送方代码如下所示(</a><a class="ae km" href="https://quarkus.io/guides/kafka-reactive-getting-started" rel="noopener ugc nofollow" target="_blank">消息传递入门</a>指南中有更多信息):</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="e5b0" class="lj lk ir lf b gz ll lm l ln lo">@Inject<br/>@Channel("topic1")<br/>Emitter&lt;String&gt; emitter;<br/><br/>@GET<br/>public String doSend() {<br/>    emitter.send("Hello World");<br/>    return "done";<br/>}</span></pre><p id="800a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">当我通过curl调用端点时(@GET表示这是一个REST-endpoint)，一个有效负载为"<em class="ld"> Hello World </em>"的消息被发送到Kafka上的<em class="ld"> topic1 </em>。当通过<em class="ld"> kafkacat </em>查看发送的消息时，我们可以看到W3C跟踪传播头，我们<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-2-d533e3a83703">已经在前一部分</a>中讨论过:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="2ba6" class="lj lk ir lf b gz ll lm l ln lo"><strong class="lf is">$ </strong>kcat -C -t <strong class="lf is">topic1</strong> -b localhost:9092 -o beginning <strong class="lf is">-J</strong><br/>{"topic":"topic1","partition":0,"offset":0,<br/> "tstype":"create","ts":1660559408201,"broker":0,<br/> "headers":["<strong class="lf is">traceparent</strong>","00-08b53bb8eb480e0abda9acb0ccb3e636-755009f86a258b5f-01"],<br/> "key":null,<br/> "<strong class="lf is">payload</strong>":"Hello World"}</span></pre><p id="8852" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">注意，<em class="ld"> kafkacat </em>只显示有效载荷，除非提供了类似<em class="ld"> -J </em>的格式化选项。</p><h2 id="9c22" class="lj lk ir bd lp lq lr dn ls lt lu dp lv jz lw lx ly kd lz ma mb kh mc md me mf bi translated">现在来看Python代码</h2><p id="4836" class="pw-post-body-paragraph jo jp ir jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ik bi translated">我们的Python代码非常简单。我们在<em class="ld"> topic1 </em>上启动一个消费者，然后打印传入的消息:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="23de" class="lj lk ir lf b gz ll lm l ln lo">from kafka import KafkaConsumer<br/>consumer = KafkaConsumer('topic1')<br/><br/>for msg in consumer:<br/>    print(msg)</span></pre><p id="4c0a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">运行代码将在控制台上打印如下消息，我们可以看到传递的<em class="ld"> traceparent </em>消息头和消息体:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="6bd5" class="lj lk ir lf b gz ll lm l ln lo">ConsumerRecord(topic='topic1', partition=0, <br/>   offset=9, timestamp=1660563030653, <br/>   <strong class="lf is">value</strong>=b'Hello World', <br/>   <strong class="lf is">headers</strong>=[<br/>      ('traceparent', b'00-8a6a62d94e611819d4f7a3523d95542b-5fd53b80e46d4ffa-01')<br/>  ]<br/>  ... <br/>  )</span></pre><p id="6219" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们现在可以提取头部并创建<em class="ld"> SpanContext </em>，如http-example etc中所示，但这次我们选择了简单的方法，并使用现有的<a class="ae km" href="https://github.com/open-telemetry/opentelemetry-python-contrib/tree/main/instrumentation/opentelemetry-instrumentation-kafka-python" rel="noopener ugc nofollow" target="_blank">Kafka instrumentation for open telemetry</a>:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="8fe7" class="lj lk ir lf b gz ll lm l ln lo">from opentelemetry.instrumentation.kafka import KafkaInstrumentor<br/>KafkaInstrumentor().instrument()</span></pre><p id="f06c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这设置了所有必要的魔法，因此我们的代码可以非常简洁:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="7e3e" class="lj lk ir lf b gz ll lm l ln lo">consumer = KafkaConsumer('topic1')<br/>producer = KafkaProducer()<br/><br/>for msg in consumer:<br/><br/>    with tracer.start_as_current_span("do-the-work-span") as span:<br/>        # do the work<br/>        body = msg.value.decode('utf-8')<br/>        body = body + ' from Python'<br/>        # and send it off to topic2<br/>        producer.send('topic2', body.encode('utf-8'))</span></pre><p id="e2f3" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">触发来自夸尔库斯(夸尔库斯接收器已经就位)的卡夫卡信息，我们在耶格中得到如下显示:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj ml"><img src="../Images/dbed774d7a9dc0b16afa457e302acc8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnY06dR0ff1SG6ypoJGwMA.png"/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">耶格展示了两条痕迹</figcaption></figure><p id="c54c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">等等，这不是我们想要的。我们看到“足够”的数据，但那些痕迹应该是一个。一些观察和调试表明，Kafka instrumentation(到1.11版为止)没有将接收到的<em class="ld"> traceId </em>作为父跟踪进行传播。</p><h2 id="4ecd" class="lj lk ir bd lp lq lr dn ls lt lu dp lv jz lw lx ly kd lz ma mb kh mc md me mf bi translated">有帮助</h2><p id="e59e" class="pw-post-body-paragraph jo jp ir jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ik bi translated">有了标题中的<em class="ld"> traceparent </em>和该系列的<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/distributed-tracing-with-quarkus-python-open-telemetry-and-jaeger-part-2-d533e3a83703">第2部分</a>中的知识，我们可以很容易地解决这个问题:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="a6f8" class="lj lk ir lf b gz ll lm l ln lo"># look for traceparent header and return its value<br/>trace_parent = get_trace_parent_header(msg)</span><span id="88f2" class="lj lk ir lf b gz mm lm l ln lo"># Create a SpanContext object from the header value<br/>span_context = extract_trace_data(trace_parent)</span><span id="bba7" class="lj lk ir lf b gz mm lm l ln lo"># Use this SpanContext as parent<br/>ctx = trace.set_span_in_context(NonRecordingSpan(span_context))<br/><br/>with tracer.start_as_current_span("do-the-work-span", context=ctx) as span:</span></pre><p id="93b9" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">现在看来，它应该是:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj mn"><img src="../Images/409355748ae0b69a829a42ee8f196ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fe-85-kFfG0ocbEocK3fGQ.png"/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">在卡夫卡身上追踪一条信息的全部痕迹</figcaption></figure><h2 id="5ef0" class="lj lk ir bd lp lq lr dn ls lt lu dp lv jz lw lx ly kd lz ma mb kh mc md me mf bi translated">夸库斯接收器</h2><p id="66ca" class="pw-post-body-paragraph jo jp ir jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ik bi translated">最后一个缺失的部分是Quarkus的接收端。这很简单:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="bbb2" class="lj lk ir lf b gz ll lm l ln lo">@Incoming("topic2")<br/>void process(String message) {<br/><br/>    System.<em class="ld">out</em>.println("Got a message: " + message);<br/><br/>}</span></pre><p id="e5c4" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">对，就是这样。仪器为我们做了一切。</p><h2 id="d752" class="lj lk ir bd lp lq lr dn ls lt lu dp lv jz lw lx ly kd lz ma mb kh mc md me mf bi translated">在Quarkus内重新发送消息</h2><p id="1dc3" class="pw-post-body-paragraph jo jp ir jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ik bi translated">与Python的情况一样，我现在想再次转发传入的消息。设置基本保持不变，但是在Quarkus进程中，将对收到的消息进行检查，然后最终再次转发到<em class="ld"> k-serv </em>:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj mo"><img src="../Images/67b75d0c3d875fa03617868e1a0ed968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgW2CX0pfHvDAg7cZAUoaA.png"/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">略有变化的新设置</figcaption></figure><p id="a5c8" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">当触发时，消息(1)被发送到<em class="ld"> k-serv </em>，k-serv对其进行转换并发回消息(2)。<em class="ld"> Q-serv </em>然后检查它之前是否见过它，否则将其作为消息(3)再次转发给<em class="ld"> k-serv </em>，k-serv然后再次转换并重新发送(4)。</p><p id="2413" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">与Python示例一样，我们希望Quarkus中的转发也传播跟踪信息，以获得完整的图像。</p><p id="74f6" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">不幸的是，这种传播还不是自动的(从Quarkus 2.11开始)，我们需要自己做一些工作。首先，我们需要更改方法的签名:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="db27" class="lj lk ir lf b gz ll lm l ln lo">@Incoming("topic2")<br/>CompletionStage&lt;Void&gt; process(Message&lt;String&gt; message) {</span></pre><p id="ee81" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这允许我们检索标题，从而检索<em class="ld"> traceparent </em>:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="8e23" class="lj lk ir lf b gz ll lm l ln lo">Optional&lt;TracingMetadata&gt; optionalTracingMetadata = TracingMetadata.<em class="ld">fromMessage</em>(message);<br/>if (optionalTracingMetadata.isPresent()) {<br/>    TracingMetadata tracingMetadata = optionalTracingMetadata.get();</span></pre><p id="4c3b" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">然后，我们使用它来设置工作单元的当前上下文。使用try-with-resources块可以确保范围在结束时关闭，这是上下文API所要求的。</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="bbfa" class="lj lk ir lf b gz ll lm l ln lo">try (Scope _ignored =  <br/>         tracingMetadata.getCurrentContext().makeCurrent()) {</span></pre><p id="5a09" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">如果应该重新发送邮件(上面的数字(3))，我们现在创建一个新邮件，将跟踪信息附加到该邮件中并发送出去:</p><pre class="ko kp kq kr gu le lf lg lh aw li bi"><span id="c92b" class="lj lk ir lf b gz ll lm l ln lo">// Get the body<br/>String body = message.getPayload();</span><span id="0457" class="lj lk ir lf b gz mm lm l ln lo">// We need to use a Message to emit with headers<br/>Message&lt;String&gt; out = Message.<em class="ld">of</em>(body);<br/><br/>// Add the tracing metadata to the outgoing message header<br/>out = out.addMetadata(<br/>              TracingMetadata.<em class="ld">withCurrent</em>(Context.<em class="ld">current</em>()));<br/><br/>// And send to round 2<br/>emitter.send(out);</span></pre><p id="1237" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">通过这些更改，我们可以清楚地看到消息是如何处理的:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj mp"><img src="../Images/aab3e4b75c7a12df239c2a40cc4fb5f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2V62rDU4qAU3oYeNX2Hfg.png"/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">显示消息处理的Jaeger用户界面截图</figcaption></figure><h2 id="4917" class="lj lk ir bd lp lq lr dn ls lt lu dp lv jz lw lx ly kd lz ma mb kh mc md me mf bi translated">给我看看代码</h2><p id="7f84" class="pw-post-body-paragraph jo jp ir jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ik bi translated"><a class="ae km" href="https://github.com/pilhuhn/fake-rbac/blob/main/kaf-relay.py" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae km" href="https://github.com/pilhuhn/quarkus-kafka-otel" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>代码都存在于GitHub上。Quarkus转发数据的扩展用例位于<a class="ae km" href="https://github.com/pilhuhn/quarkus-kafka-otel/blob/forwarding/src/main/java/de/bsd/quarkus_kafka_otel/KafkaReceiver.java" rel="noopener ugc nofollow" target="_blank"> <em class="ld">转发分支</em> </a>。</p><p id="9899" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">感谢<a class="ae km" href="https://twitter.com/brunobat_" rel="noopener ugc nofollow" target="_blank"> Bruno Baptista </a>对本文的反馈。</p></div></div>    
</body>
</html>