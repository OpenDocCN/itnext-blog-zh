<html>
<head>
<title>Sealed classes + RecyclerView with headers = ❤️</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">密封类+带标题的recycle view =❤️</h1>
<blockquote>原文：<a href="https://itnext.io/sealed-classes-recyclerview-with-headers-%EF%B8%8F-14b87d41deb6?source=collection_archive---------3-----------------------#2020-04-26">https://itnext.io/sealed-classes-recyclerview-with-headers-%EF%B8%8F-14b87d41deb6?source=collection_archive---------3-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/dc3da794823662be0e37a0636b615097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOmCvYsv9KKxDCRMa06y2w.jpeg"/></div></div></figure><div class=""/><p id="7dd9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你已经在Android生态系统中呆了一段时间，有可能在某个时候你需要在屏幕上以标题的形式显示一个按照给定标准分组的项目列表。类似于:</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/615adbbd28347283bbbda03b3e052e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*yZUEvRKSF42kdyb2NQkvdw.png"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">按类型分组的语言列表</figcaption></figure><p id="d9c1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以在屏幕上识别两种不同类型的行:</p><ul class=""><li id="502f" class="li lj je kd b ke kf ki kj km lk kq ll ku lm ky ln lo lp lq bi translated"><strong class="kd jf">表头</strong>:包含语言类型名称。</li><li id="a10b" class="li lj je kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated"><strong class="kd jf">语言</strong>:显示给定语言的数据(名称、最新版本和发布日期)。</li></ul><p id="2430" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们开始定义必要的<strong class="kd jf">基类</strong>:</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="af6b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于这个<code class="fe ly lz ma mb b">Language</code>类，我们需要显示由<code class="fe ly lz ma mb b">type</code>属性分组的语言。我们假设这个类将一个实体表示为我们域的<strong class="kd jf">部分，它没有耦合到UI </strong>。这非常重要，因为仅为UI定义模型将使我们的生活更容易(改变)。</p><p id="9a54" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该UI基于包含两种不同类型的行的RecyclerView。这看起来像一个密封的类:</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5f16" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，除了这两个类(每个都代表UI状态数据)，还有一个新的枚举<code class="fe ly lz ma mb b">RowType</code>，我们稍后会看到它为什么有用。</p><p id="7dd0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以开始使用新创建的类构建我们的适配器了。幸运的是，<code class="fe ly lz ma mb b"><strong class="kd jf">RecyclerView.Adapter</strong></code> <strong class="kd jf">类已经支持不同类型的视图</strong>:<code class="fe ly lz ma mb b"><a class="ae mc" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter#getItemViewType(int)" rel="noopener ugc nofollow" target="_blank">getItemViewType</a></code>函数允许定义哪种类型的视图将用于给定的数据行索引(这就是枚举变得方便的地方):</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7cc1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以现在，有一个包含一系列<code class="fe ly lz ma mb b">LanguageRow</code>项的适配器(记住这是密封类),它为<em class="md"> getItemViewType </em>函数返回<code class="fe ly lz ma mb b">RowType</code>枚举的<strong class="kd jf">序数值</strong>。这就是enum的强大之处，因为我们不需要编写任何if/when语句。</p><p id="a389" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们需要处理适配器的支架。想法是有两个独立的持有人。其中一个用于包含语言数据的“常规”行，另一个用于标题:</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b61c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以完成缺少<code class="fe ly lz ma mb b">onCreateViewHolder </code>和<code class="fe ly lz ma mb b">onBindViewHolder</code>功能的适配器实现:</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="583d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里还缺少一个重要的东西。一开始我展示了我们领域的一个<code class="fe ly lz ma mb b">Language</code>类部分，然后是<code class="fe ly lz ma mb b">LanguageRow</code>密封类。但是我们需要做一个<strong class="kd jf">转换</strong>来将语言列表转换成UI的行列表。为此，我们首先需要按类型对语言进行分组，并为每个结果分组创建一个标题+当前类型的所有语言:</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h1 id="a6b9" class="me mf je bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">结论</h1><p id="2e13" class="pw-post-body-paragraph kb kc je kd b ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">使用类型系统的力量会让你的代码更强大，更难破解，更容易修改。像使用枚举或定义密封类来表示只作为集合的一部分有效的值这样的小事会更简洁，更不容易出错。</p><p id="3202" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一篇文章再见！</p></div></div>    
</body>
</html>