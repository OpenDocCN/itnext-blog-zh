<html>
<head>
<title>Dynamic Jenkins Agent from Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes的动态詹金斯代理</h1>
<blockquote>原文：<a href="https://itnext.io/dynamic-jenkins-agent-from-kubernetes-4adb98901906?source=collection_archive---------1-----------------------#2020-02-08">https://itnext.io/dynamic-jenkins-agent-from-kubernetes-4adb98901906?source=collection_archive---------1-----------------------#2020-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f0ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes中的动态Jenkins代理供应</p><h1 id="4f6e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">介绍</h1><p id="5829" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Jenkins是一个历史悠久的CI/CD工具，并且一直在不断发展。它的<a class="ae lr" href="https://jenkins.io/doc/book/architecting-for-scale/" rel="noopener ugc nofollow" target="_blank">主/代理架构</a>对于分布式构建的可伸缩性非常好。有许多<a class="ae lr" href="https://jenkins.io/blog/2018/09/14/kubernetes-and-secret-agents/" rel="noopener ugc nofollow" target="_blank">方式</a>来供应Jenkins代理，从使用裸机、虚拟机、动态EC2实例、来自Docker的容器或Kubernetes集群。</p><p id="55e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Jenkins和Kubernetes集群之间的集成非常好。凭借这些优势，我已经将CI/CD管道从基于主机(VM)的代理完全迁移到基于Pod的代理。</p><ul class=""><li id="296f" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">Kubernetes的动态Jenkins代理，轻量级，在几秒钟内按需供应</li><li id="de4f" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">为每个构建提供新鲜且可重复的Jenkins代理环境</li><li id="a360" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">Kubernetes带来的资源/成本节约</li></ul><p id="985d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我想分享我最近的方法，使用Jenkins共享库的方法，在Jenkins管道中用简单的代码行动态地提供Jenkins代理。</p><p id="4ba2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">声明管道</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="1126" class="mp kp it ml b gy mq mr l ms mt"><a class="ae lr" href="http://twitter.com/Library" rel="noopener ugc nofollow" target="_blank">@Library</a>("k8sagent@v0.1.0") _  <strong class="ml iu">&lt;-- invoke library</strong><br/>pipeline {<br/>  agent {<br/>    kubernetes(k8sagent(name: 'mini+pg')) <strong class="ml iu">&lt;- Jenkins Agent provisioned</strong><br/>  }<br/>  stages {<br/>    stage('demo') {<br/>      steps {<br/>        echo "this is a demo"<br/>        script {<br/>          container('pg') {<br/>            sh 'su - postgres -c \'psql --version\''<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="555f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">脚本化管道</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="1230" class="mp kp it ml b gy mq mr l ms mt"><a class="ae lr" href="http://twitter.com/Library" rel="noopener ugc nofollow" target="_blank">@Library</a>("k8sagent@v0.1.0") _  <strong class="ml iu">&lt;-- invoke library</strong><br/>my_node = <!-- -->k8sagent<!-- -->(name: <!-- -->'mini+pg'<!-- -->)<br/>podTemplate(my_node) { <strong class="ml iu">&lt;--Jenkins Agent provisioned</strong><br/>  node(my_node.label) {<br/>    sh 'echo hello world'<br/>    container('pg') {<br/>      sh 'su - postgres -c \'psql --version\''<br/>    }<br/>  }<br/>}</span></pre><p id="7db6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个单行示例中，名称“mini+pg”是请求一个带有标准JNLP容器和“postgresql”容器的“mini”大小Pod的Jenkins代理。类型“mini”和“pg”是资源文件中定义的模板。库中还有其他模板，如“小”、“大”、“特权”，您可以自由混合/添加/更改。</p><p id="856b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了动态请求/释放Jenkins代理来运行您的CI/CD管道之外，这是一种动态定义所需代理的方法。我在下面描述了如何扩展你的用法。</p><h2 id="3aeb" class="mp kp it bd kq mu mv dn ku mw mx dp ky kb my mz lc kf na nb lg kj nc nd lk ne bi translated">源代码</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="aa10" class="mp kp it ml b gy mq mr l ms mt">github <a class="ae lr" href="https://github.com/liejuntao001/jenkins-k8sagent-lib" rel="noopener ugc nofollow" target="_blank">link</a></span></pre><h1 id="e4e3" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">詹金斯如何与Kubernetes合作</h1><p id="16dc" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">介绍文章很多，列举几篇(<a class="ae lr" href="https://cloud.google.com/solutions/jenkins-on-kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> GCP </a>、<a class="ae lr" href="https://dzone.com/articles/scaling-jenkins-with-kubernetes" rel="noopener ugc nofollow" target="_blank"> AWS </a>、<a class="ae lr" href="https://blog.jcorioland.io/archives/2017/11/21/continuous-delivery-kubernetes-azure-jenkins-helm.html" rel="noopener ugc nofollow" target="_blank"> Azure </a>等)。它们都是基于Jenkins的Kubernetes插件。</p><p id="bc86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有两种集成模型。</p><ol class=""><li id="39e8" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn nf ly lz ma bi translated">现有的Jenkins实例连接到新的Kubernetes集群。</li></ol><p id="41ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我第一次做集成时，我已经有一个生产Jenkins在运行，所以这绝对是一条直路。</p><p id="24d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注:一个<a class="ae lr" href="https://kumorilabs.com/blog/k8s-6-integrating-jenkins-kubernetes/" rel="noopener ugc nofollow" target="_blank">链接</a>关于如何向K8s认证Jenkins。</p><figure class="mg mh mi mj gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ng"><img src="../Images/5f772a85cc210a8a28f85c3744dc5a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gA15Ar2D9WRzTHUtknhc8A.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">独立的Jenkins + K8s集群</figcaption></figure><p id="11ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.在Kubernetes集群中创建一个新的Jenkins实例。</p><p id="cc18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在将第一个模型投入生产后，出于不同目的运行多个Jenkins实例的想法，我尝试了第二个模型，并认为它是更好的方法。</p><figure class="mg mh mi mj gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ns"><img src="../Images/7d9a74f9aab0c9a38729393eb35318eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DH3ZS6uzfONBGBfoHxiuQ.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">Kubernetes星团中的Jenkins</figcaption></figure><p id="456f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两种模型都可以很好地工作，甚至可以在同一个Kubernetes集群中不同的名称空间中工作。</p><h2 id="70de" class="mp kp it bd kq mu mv dn ku mw mx dp ky kb my mz lc kf na nb lg kj nc nd lk ne bi translated">供应代理的官方指南</h2><p id="dd99" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Jenkins的<a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin" rel="noopener ugc nofollow" target="_blank"> Kubernetes插件</a>为定义简单/复杂代理的各种方法提供了文档和<a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin/tree/master/examples" rel="noopener ugc nofollow" target="_blank">示例</a>。</p><p id="0538" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Jenkins代理是一个由Kubernetes提供的Pod，具有多个运行指定Docker映像的容器。主容器必须来自<a class="ae lr" href="https://hub.docker.com/r/jenkins/jnlp-slave" rel="noopener ugc nofollow" target="_blank"> jenkins/jnlp-slave </a>或兼容的映像。最好构建自己的映像，包括来自<a class="ae lr" href="https://github.com/jenkinsci/docker-slave" rel="noopener ugc nofollow" target="_blank"> jenkins/docker-slave </a>的Dockerfile内容。</p><p id="f54e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Kubernetes提供的各种机制是非常灵活的，包括Pod中的多个容器，在它们之间共享网络，共享工作目录、初始化容器、资源限制、环境、秘密等…</p><p id="d0b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，有三种方法来提供代理，</p><ul class=""><li id="4700" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">声明管道中的YAML</li><li id="b4e7" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">脚本管道中的配置</li><li id="ccc7" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">Jenkins UI中的配置</li></ul><ol class=""><li id="7a6c" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn nf ly lz ma bi translated">声明性管道，它将为预期的Pod写下yaml文件。</li></ol><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="db89" class="mp kp it ml b gy mq mr l ms mt"><a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin#declarative-pipeline" rel="noopener ugc nofollow" target="_blank">link</a></span><span id="7dd8" class="mp kp it ml b gy nt mr l ms mt">pipeline {<br/>  agent {<br/>    kubernetes {<br/>      yaml """<br/>&lt;A long yaml file&gt;<br/>"""<br/>    }<br/>  }<br/>...</span></pre><p id="367a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.脚本管道，用于配置所有的<a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin#pod-and-container-template-configuration" rel="noopener ugc nofollow" target="_blank">参数</a>。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="9d11" class="mp kp it ml b gy mq mr l ms mt"><a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin#container-configuration" rel="noopener ugc nofollow" target="_blank">link</a></span><span id="6a08" class="mp kp it ml b gy nt mr l ms mt">podTemplate(cloud: 'kubernetes', containers: [<br/>    containerTemplate(<br/>&lt;All kinds of configurations&gt;<br/>]) {<br/>   ...<br/>}</span></pre><p id="905b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.Jenkins配置，即将“Pod模板”的所有配置填入UI。</p><figure class="mg mh mi mj gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nu"><img src="../Images/de2a82fb67b411bb8d24007c210272b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rTFBLGTvYIgrTofL1GgJw.png"/></div></div></figure><h2 id="eee8" class="mp kp it bd kq mu mv dn ku mw mx dp ky kb my mz lc kf na nb lg kj nc nd lk ne bi translated">Jenkins UI中的Pod模板配置</h2><p id="50c3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">方法3是我的起点，因为它与Jenkins master中定义的其他类型的代理是一样的。</p><p id="38af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我为不同的任务定义了多个“Pod模板”。例如，具有4个CPU/8GB RAM的通用“从”适合大多数构建。一些大型项目可能需要8个CPU/16GB RAM，称为“大型从属”。有些人可能需要额外的PostgreSQL容器进行测试，称为“slave-pg”。</p><p id="da5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有些模板是相似的，我们甚至可以使用“<a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin#pod-template-inheritance" rel="noopener ugc nofollow" target="_blank">模板继承</a>”特性来节省一些精力，这很好。</p><p id="6fc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在管道中，很容易使用Pod模板的标签来选择代理。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="ed7c" class="mp kp it ml b gy mq mr l ms mt">pipeline {<br/> agent {<br/>  label "slave"<br/> }<br/>...<br/>}</span></pre><p id="6bdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着时间的推移，观察到了一些问题。</p><ul class=""><li id="06c4" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">Pod模板太复杂，无法从Jenkins UI进行配置</li></ul><p id="350a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单个Pod模板可以轻松拥有30多个配置项。这显示了Kubernetes的巨大灵活性，但对UI不利。</p><ul class=""><li id="e3e6" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">多个Pod模板不可管理</li></ul><p id="520e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着“各种任务”需求的增加，配置的模板数量也在增加。由于没有太多(少于10个)模板，Jenkins配置UI的这个部分有10多页。真的很难找到合适的地方做出合适的改变。</p><ul class=""><li id="657e" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">跨Jenkins实例的Pod模板配置</li></ul><p id="2ba4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着我将更多的Jenkins实例投入生产，跨实例配置这些模板就成了一个问题。我怀疑没有人会愿意把10页的配置从一个Jenkins复制到另一个Jenkins。</p><p id="7266" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">詹金斯配置作为代码(<a class="ae lr" href="https://github.com/jenkinsci/configuration-as-code-plugin" rel="noopener ugc nofollow" target="_blank"> JCasC </a>)还不是拯救者，我相信。</p><ul class=""><li id="37c7" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">缺乏决定论</li></ul><p id="3261" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">项目在其管道中使用“代理标签A”的方式创建了对Jenkins中定义的“代理A”的依赖，就像一个谜。没有办法确切地知道代理A中有什么，A今天是否与昨天相同，或者A在Jenkins实例中是否不同。如果代理是以可变的方式创建的，那就有问题了。</p><ul class=""><li id="d35a" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">缺乏追踪能力</li></ul><p id="71b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着项目的发展，它对代理的需求也在发展。例如，project v1.0.0可能只需要一个标准代理，而v1.5.0需要一个带有PostgreSQL容器的代理来进行测试。有时代理中使用的docker映像也需要升级。请求Jenkins管理员修改代理或创建新代理听起来很容易。但是很快就没有跟踪这种变化的能力了。</p><p id="3bf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使存在一些问题，这种方法仍然是那些必须在各种代理上运行而不是在Kubernetes中的Pod上运行的管道的必备方法。</p><h2 id="89c5" class="mp kp it bd kq mu mv dn ku mw mx dp ky kb my mz lc kf na nb lg kj nc nd lk ne bi translated">管道源代码中的Pod模板</h2><p id="f0b9" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">通过看<a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin" rel="noopener ugc nofollow" target="_blank">Kubernetes plugin for Jenkins</a>的文档，我相信设计思路是在管道源代码中写Pod模板。声明式和脚本式管道都有很多<a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin/tree/master/examples" rel="noopener ugc nofollow" target="_blank">的例子</a>。</p><p id="9b67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的观察中，随着插件版本的升级，插件正在采取措施让YAML定义代理而不是配置。我欢迎这一变化，因为对Jenkins pipeline和其他Kubernetes任务使用相同的YAML方式非常舒服。</p><p id="d296" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个相关的主题是关于管道代码如何与项目集成，例如，它应该在同一个源代码库中还是在项目之外。判断哪个更好(或更合适)取决于很多因素。对我来说，我必须两者兼顾。</p><p id="81cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在尝试这种方法时，我遇到了两个主要问题。</p><ul class=""><li id="40c7" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">下面是一个从插件的<a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin/blob/master/examples/dind.groovy" rel="noopener ugc nofollow" target="_blank">示例</a>中复制的示例管道。</li></ul><figure class="mg mh mi mj gt nh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d498" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个简单的例子中，定义Pod模板的YAML是20行代码，而构建逻辑是5行。</p><p id="d44a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据我的实际经验，实际有用的YAML可以轻松超过50行。我觉得这在管道代码中太长了。而且是类似项目的重复代码。</p><ul class=""><li id="907f" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">如果您有100个项目，很难在管道代码中为Pod模板YAML修改100个项目。</li></ul><p id="7a0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不同的组织有不同的开发模式。没有一个答案是谁应该对项目管道负责，特别是管道代码中的Pod模板部分。<br/>如果是单独的项目团队，不可能同时执行变更。例如，当需要为安全补丁升级docker映像时，应同时为所有项目立即采取行动。<br/>如果是一个敬业的团队，我无法想象有效修改100个项目的努力。很有可能漏掉一些。</p><h1 id="3a62" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">将Pod模板移动到Jenkins共享库</h1><p id="0b97" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">当Jenkins管道代码中有共同的东西时，很自然地将它们移到<a class="ae lr" href="https://jenkins.io/doc/book/pipeline/shared-libraries/" rel="noopener ugc nofollow" target="_blank"> Jenkins共享库</a>。</p><p id="b485" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我在寻找一个使用库进行Kubernetes代理供应的解决方案时，我受到了这个<a class="ae lr" href="https://github.com/salemove/pipeline-lib" rel="noopener ugc nofollow" target="_blank"> salemove/pipeline-lib </a>项目的启发。</p><p id="46db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个Jenkins共享库，它提供了一个<a class="ae lr" href="https://github.com/salemove/pipeline-lib/blob/master/vars/inPod.groovy" rel="noopener ugc nofollow" target="_blank"> inPod </a>方法。inPod是podTemplate的一个瘦包装器，它提供了将预定义的配置与参数相结合的灵活性。以inPod为基础，其他一些包装器定义了各种参数，例如<a class="ae lr" href="https://github.com/salemove/pipeline-lib/blob/master/vars/inDockerAgent.groovy" rel="noopener ugc nofollow" target="_blank"> inDockerAgent </a>，<a class="ae lr" href="https://github.com/salemove/pipeline-lib/blob/master/vars/inRubyBuildAgent.groovy" rel="noopener ugc nofollow" target="_blank"> inRubyBuildAgent </a>，以提供不同种类的代理。</p><p id="e641" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，下面这段代码提供了一个带有“node:9-alpine”docker图像的代理。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="1a9f" class="mp kp it ml b gy mq mr l ms mt">inPod(containers: [interactiveContainer(name: 'node', image: 'node:9-alpine')]) {<br/>  checkout(scm)<br/>  container('node') {<br/>    sh('npm install &amp;&amp; npm test')<br/>  }<br/>}</span></pre><p id="8a7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主要思想是从包装层收集参数，并将它们放在一起，供Kubernetes插件使用。</p><p id="4736" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一个关键函数addWithoutDuplicates，在这里实现了<a class="ae lr" href="https://github.com/salemove/pipeline-lib/blob/master/src/com/salemove/Collections.groovy#L4" rel="noopener ugc nofollow" target="_blank">和</a>，它将列表合并在一起，使参数优先于默认值。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="02c8" class="mp kp it ml b gy mq mr l ms mt">// For containers, add the lists together, but remove duplicates by name, giving precedence to the user specified args.<br/>  def finalContainers = addWithoutDuplicates((args.containers ?: []), defaultArgs.containers) { it.getArguments().name }</span></pre><p id="05b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过查看该项目的介绍，这是一个已经在生产中的成功的库。这个想法很好，当我想进口供自己使用时，我发现它不适合我的情况。</p><ul class=""><li id="1b22" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">该库依赖于方法2，向Pod模板提供配置。虽然我认为新的趋势是YAML。</li><li id="2a9a" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">该库仅适用于脚本化管道。在我的工作范围内，我有声明性管道和脚本化管道。我需要一个解决方案来解决这两个问题。</li><li id="60ad" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">podTemplate有许多配置，但这些并不是Kubernetes支持的所有东西。事实上，有一个“yaml”配置来提供原始的yaml。原始yaml将与其他配置合并。</li><li id="d6e1" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">该库侧重于向代理提供不同的docker映像/卷。这很好，但我需要更多，其中许多只在'原始yaml '支持。</li></ul><h2 id="d108" class="mp kp it bd kq mu mv dn ku mw mx dp ky kb my mz lc kf na nb lg kj nc nd lk ne bi translated">詹金斯图书馆从Kubernetes获取动态代理</h2><p id="b491" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">出于这些考虑，我想探索一种满足这些要求的新解决方案:</p><ul class=""><li id="13e1" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">基于方法1，全YAML格式</li><li id="8436" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">适用于脚本化管道和声明性管道</li><li id="05bb" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">灵活调配各种代理</li><li id="4fa5" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">易于使用的管道代码和隐藏库中的细节</li><li id="70a3" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">易于开发库以支持不断增长的代理类型需求</li></ul><p id="22c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过一些调查，我相信我的想法是可行的，通过查看来自Kubernetes插件的这两个例子:<a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin/blob/master/examples/dind.groovy" rel="noopener ugc nofollow" target="_blank"> dind.groovy </a>和<a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin/blob/master/examples/declarative.groovy" rel="noopener ugc nofollow" target="_blank"> declarative.groovy </a>。</p><p id="720d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两个例子的共同点如下</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4ad9" class="mp kp it ml b gy mq mr l ms mt"># scripted pipeline<br/>podTemplate(<strong class="ml iu">Map</strong>) {<br/>}</span><span id="c30f" class="mp kp it ml b gy nt mr l ms mt"># declarative pipeline <br/> agent {<br/>    kubernetes {<br/>      <strong class="ml iu">Map</strong><br/>    }<br/> }</span></pre><p id="991c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目标是用期望的yaml内容生成映射，它定义了代理的Pod规范。</p><p id="9854" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">方法是定义部分yaml的小部分，每个部分都针对代理的特定需求，然后将它们合并在一起，组成Pod的最终yaml格式规范。</p><p id="a375" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，代理可能需要进行maven或gradle构建，一个名为“maven”的资源文件包含一个带有“maven”docker映像的容器，另一个文件“gradle”包含“gradle”docker映像。代理可能需要更少或更多的计算能力，映射到资源文件“小”/“大”/“快”以请求一些CPU/内存资源。代理可能需要构建中的“特权”Pod、定义“安全上下文”的资源文件“特权”,在我的情况下，还需要“podAntiAffinity”来确保一台主机中只有一个特权Pod。</p><p id="522d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">把它们加在一起，用‘A+B+C’的格式定义一个代理，比如‘maven+small+privileged’，库会返回合并后的yaml。</p><p id="9a37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“small+pg”的代码示例:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="41b4" class="mp kp it ml b gy mq mr l ms mt"># base<br/>spec:<br/>  hostAliases:<br/>  - ip: "192.168.1.15"<br/>    hostnames:<br/>    - "jenkins.example.com"<br/>  volumes:<br/>  - hostPath:<br/>      path: /data/jenkins/repo_mirror<br/>      type: ""<br/>    name: volume-0<br/>  containers:<br/>  - name: jnlp<br/>    image: jenkinsci/jnlp-slave:3.29-1<br/>    imagePullPolicy: Always<br/>    command:<br/>    - /usr/local/bin/jenkins-slave<br/>    volumeMounts:<br/>    - mountPath: /home/jenkins/repo_cache<br/>      name: volume-0</span><span id="05b4" class="mp kp it ml b gy nt mr l ms mt"># small<br/>spec:<br/>  containers:<br/>  - name: jnlp<br/>    resources:<br/>      limits:<br/>        memory: 8Gi<br/>      requests:<br/>        memory: 4Gi<br/>        cpu: 2</span><span id="8e4d" class="mp kp it ml b gy nt mr l ms mt"># pg<br/>spec:<br/>  containers:<br/>  - name: pg<br/>    image: postgres:9.5.19<br/>    tty: true</span><span id="fa85" class="mp kp it ml b gy nt mr l ms mt"># merged<br/>spec:<br/>  hostAliases:<br/>  - ip: "192.168.1.15"<br/>    hostnames:<br/>    - "jenkins.example.com"<br/>  volumes:<br/>  - hostPath:<br/>      path: /data/jenkins/repo_mirror<br/>      type: ""<br/>    name: volume-0<br/>  containers:<br/>  - name: jnlp<br/>    image: jenkinsci/jnlp-slave:3.29-1<br/>    imagePullPolicy: Always<br/>    command:<br/>    - /usr/local/bin/jenkins-slave<br/>    volumeMounts:<br/>    - mountPath: /home/jenkins/repo_cache<br/>      name: volume-0<br/>    resources:<br/>      limits:<br/>        memory: 8Gi<br/>      requests:<br/>        memory: 4Gi<br/>        cpu: 2<br/>  - name: pg<br/>    image: postgres:9.5.19<br/>    tty: true</span></pre><p id="8dad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了便于开发，我从一个类似的gradle项目开始，该项目使用TDD方法来开发一个Jenkins共享库。我在这篇<a class="ae lr" href="https://medium.com/@liejuntao001/get-a-build-number-from-service-2286d2750094" rel="noopener">文章</a>中介绍过，原始源代码是<a class="ae lr" href="https://github.com/liejuntao001/jenkins-buildnumber-lib" rel="noopener ugc nofollow" target="_blank"> github link </a>。</p><p id="86b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">gradle项目的结构是这样的:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="3e69" class="mp kp it ml b gy mq mr l ms mt">.<br/>├── build.gradle<br/>├── resources<br/>│   └── podtemplates <strong class="ml iu">&lt;- many Yaml files</strong><br/>├── src<br/>│   └── com/github/liejuntao001/jenkins/MyYaml.groovy <strong class="ml iu">&lt;- merge Yaml</strong><br/>├── test<br/>│   └── groovy<br/>│       └── K8sAgentTest.groovy <strong class="ml iu">&lt;- test</strong><br/>├── testjobs<br/>│   ├── k8sagent_Jenkinsfile.groovy<br/>│   └── simple_Jenkinsfile.groovy <strong class="ml iu">&lt;- samples</strong><br/>│   └── simple_scripted.groovy<br/>└── vars<br/>    └── k8sagent.groovy <strong class="ml iu">&lt;- method</strong></span></pre><p id="3379" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行测试</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6851" class="mp kp it ml b gy mq mr l ms mt">./gradlew clean test<br/><br/>&gt; Task :test<br/>K8sAgentTest: testSdk25: SUCCESS<br/>K8sAgentTest: testSmall: SUCCESS<br/>K8sAgentTest: testBase: SUCCESS<br/>K8sAgentTest: testDind: SUCCESS<br/>K8sAgentTest: testFast: SUCCESS<br/>K8sAgentTest: testPg: SUCCESS<br/>K8sAgentTest: testPrivileged: SUCCESS<br/>Tests: 7, Failures: 0, Errors: 0, Skipped: 0</span></pre><p id="2790" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要进一步开发这个库，只需修改resources/podtempltes中的资源文件来满足您的需求。</p><p id="6023" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在test/groovy/k8 sagenttest . groovy中添加测试用例，以根据代理的预期Yaml内容测试合并的Yaml。</p><p id="081d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些注意事项:</p><ul class=""><li id="5140" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">建议库中使用的所有docker图像都是自建的私有图像，以确保内容</li><li id="df0a" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">建议用版本号标记所有docker映像，以获得确定性代理。</li><li id="c222" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">建议整个Jenkins库都用版本标签发布。所有调用库的管道都要使用<a class="ae lr" href="http://twitter.com/Library" rel="noopener ugc nofollow" target="_blank">@库</a>(“k8s agent @ v 0 . 1 . 0”)_</li><li id="83e4" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">源代码中有一个base.yaml，它定义了jnlp容器和所有代理类型所需的通用内容。在k8sagent.groovy中，base.yaml包含在所有代理中。如果有要求使一个公共库成为不可能，那么k8sagent.groovy需要更新。</li></ul><h2 id="a055" class="mp kp it bd kq mu mv dn ku mw mx dp ky kb my mz lc kf na nb lg kj nc nd lk ne bi translated">Yaml合并策略</h2><p id="c3e9" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">据我所知，没有一种“适合所有人”的Yaml合并方法。</p><p id="4996" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，Yaml的主要数据结构是映射和列表。在Kubernetes的规范中，列表有时对序列敏感，有时不敏感。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="3a63" class="mp kp it ml b gy mq mr l ms mt"># sequence sensitive List<br/>command: ["/bin/sh"]<br/>args: ["-c", "while true; do echo hello; sleep 10;done"]</span><span id="c083" class="mp kp it ml b gy nt mr l ms mt"># sequence insensitive List<br/>containers:<br/>- name: A<br/>- name: B</span></pre><p id="98e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Kubernetes插件中，有一个<a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin#pod-and-container-template-configuration" rel="noopener ugc nofollow" target="_blank">参数</a>yamlmergestrial:merge()或override()来决定如何合并继承中的Yaml。</p><p id="19df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的实现中，我重用了来自<a class="ae lr" href="https://github.com/OndraZizka/yaml-merge/blob/master/src/main/java/org/cobbzilla/util/yml/YmlMerger.java" rel="noopener ugc nofollow" target="_blank"> OndraZizka/yaml-merge </a>的代码，并将其修改为“工作正常”的级别以适应我的场景。它解决了如下用例:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="2862" class="mp kp it ml b gy mq mr l ms mt"># a.yaml<br/>containers:<br/>- name: <strong class="ml iu">A</strong><br/>  some_config</span><span id="0943" class="mp kp it ml b gy nt mr l ms mt"># b.yaml<br/>containers:<br/>- name: <strong class="ml iu">A</strong><br/>  some_other_config</span><span id="3700" class="mp kp it ml b gy nt mr l ms mt"># merged yaml<br/>containers:<br/>- name: <strong class="ml iu">A</strong><br/>  some_config<br/>  some_other_config</span></pre><p id="6644" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于更复杂的场景，<a class="ae lr" href="https://github.com/liejuntao001/jenkins-k8sagent-lib/blob/master/src/com/github/liejuntao001/jenkins/MyYaml.groovy" rel="noopener ugc nofollow" target="_blank"> MyYaml.groovy </a>可能需要更新。但是我认为大多数情况可以通过定义细粒度的Yaml文件来解决。</p><blockquote class="nx ny nz"><p id="f9a8" class="jq jr oa js b jt ju jv jw jx jy jz ka ob kc kd ke oc kg kh ki od kk kl km kn im bi translated">2020年10月23日更新</p></blockquote><ul class=""><li id="7c96" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">添加可选参数nodeSelector</li></ul><p id="e44f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例子</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="80c1" class="mp kp it ml b gy mq mr l ms mt">k8sagent<!-- -->(name: 'base', selector: 'kubernetes.io/hostname: worker1')</span></pre><ul class=""><li id="b0e5" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">添加可选参数jnlpImage</li></ul><p id="485e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例子</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="e7b0" class="mp kp it ml b gy mq mr l ms mt">k8sagent(name: 'base', jnlpImage: 'jenkinsci/jnlp-slave:my_test_version')</span></pre><h2 id="cb98" class="mp kp it bd kq mu mv dn ku mw mx dp ky kb my mz lc kf na nb lg kj nc nd lk ne bi translated">参考</h2><p id="b818" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><a class="ae lr" href="https://github.com/jenkinsci/kubernetes-plugin" rel="noopener ugc nofollow" target="_blank">詹金斯的Kubernetes插件</a></p><p id="a064" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="oa">感谢阅读。</em></p></div></div>    
</body>
</html>