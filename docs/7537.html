<html>
<head>
<title>A Refresh for Zig Programmers and Dabblers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Zig程序员和业余爱好者的更新</h1>
<blockquote>原文：<a href="https://itnext.io/a-refresh-for-zig-programmers-and-dabblers-d33f02c6a362?source=collection_archive---------0-----------------------#2022-10-27">https://itnext.io/a-refresh-for-zig-programmers-and-dabblers-d33f02c6a362?source=collection_archive---------0-----------------------#2022-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbe6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">重温Zig编程语言时容易记住的事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cd12d88967e2374ebf40355d774abfa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXZzaHgyWrPJ9EEd3k8Hhw.jpeg"/></div></div></figure><p id="3ac7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">大约两年前，我尝试了一下Zig编程语言，并写了一些关于它的文章。今天，我再次启动了一个旧的Zig项目，并写下我重返Zig的经历。在我看来，这是一个有用的测试，因为它有助于识别可能会绊倒初学者的东西，并有助于评估语言的持久力。任何一种你可以在长时间休息后不费吹灰之力就能继续使用的语言，都比一种每次你想使用时都需要大量努力和时间投入的语言更有价值。</p><p id="028a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章将是一个章节的集合，描述我不得不刷新的概念的随机分类，或者我在尝试刷新我的Zig知识时所面临的挑战。我假设你们中的大多数人能够很容易地理解if语句、while循环和定义函数。这里的重点是各种可能会让你犯错的角落案例或概念。</p><h2 id="91b5" class="lz ma it bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">编译和运行Zig程序</h2><p id="dd20" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">编译单个文件和构建整个项目之间的区别是我已经忘记的。这样做很简单。让我们看一个例子，源代码文件位于<code class="fe mx my mz na b">src</code>子目录中。您可以通过以下方式编译或直接运行<code class="fe mx my mz na b">main.zig</code>源代码文件:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="f3f9" class="lz ma it na b gy nf ng l nh ni">❯ zig build-exe src/main.zig<br/>❯ zig run src/main.zig</span></pre><p id="65d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，就像Go编程语言一样，大多数时候您实际上并不需要复杂的构建设置。<code class="fe mx my mz na b">main.zig</code>文件可以指向许多其他Zig源代码文件，这些文件又可以指向其他文件。下面是一个将<code class="fe mx my mz na b">colors.zig</code>文件包含在<code class="fe mx my mz na b">main.zig</code>文件中的例子:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="7a62" class="lz ma it na b gy nf ng l nh ni">const colors =  @import("colors.zig");</span></pre><p id="c824" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于像我这样的老C/C++开发人员来说，这是相当激进的。事实上，当我第一次写这一节时，我解释了<code class="fe mx my mz na b">build-exe</code>,就好像它只是编译一个C/C++源代码文件，该文件以后需要与所有相关源代码文件的目标代码相链接。然而，这将是一种误解。没有单独的链接阶段，你需要与Zig执行。使用<code class="fe mx my mz na b">build-exe</code>,原则上你可以构建一个由数百个源代码文件组成的完整项目。</p><p id="cf45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，你为什么需要一个<code class="fe mx my mz na b">build.zig</code>文件呢？好处是它允许你建立多个可执行文件，库和类似的构建。您还可以定义安装过程，并定义要编译的标志。因此，虽然您可以在很多时候避免类似于<code class="fe mx my mz na b">Makefile</code>的事情，但是在Zig中使用一个定义您的构建设置的文件仍然是有益的。与C/C++代码的makefiles不同，您不需要学习新的语言。<code class="fe mx my mz na b">build.zig</code>文件包含常规Zig代码。它只有一个特定的要求:它必须包含一个名为<code class="fe mx my mz na b">build</code>的函数，其签名如下:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="3135" class="lz ma it na b gy nf ng l nh ni">const Builder = @import("std").build.Builder<br/>pub fn build(b: *Builder) void</span></pre><p id="1a3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着它必须是一个公共函数，接受一个指向<code class="fe mx my mz na b">Builder</code>对象的指针，并且不返回任何内容。Zig标准库文档更详细地解释了如何设置构建配置:<a class="ae nj" href="https://ziglang.org/documentation/0.9.1/#toc-Build-Mode" rel="noopener ugc nofollow" target="_blank"> BuildMode </a>。下面是一个简单的示例构建脚本:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="cc21" class="lz ma it na b gy nf ng l nh ni">const Builder = @import("std").build.Builder;<br/><br/>pub fn build(b: *Builder) void {<br/>    const exe = b.addExecutable("example", "example.zig");<br/>    exe.setBuildMode(b.standardReleaseOptions());<br/>    b.default_step.dependOn(&amp;exe.step);<br/>}</span></pre><p id="6c9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦你得到了一个编译文件，你就可以做一些事情，比如编译可执行文件，编译并运行或者安装。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="78a2" class="lz ma it na b gy nf ng l nh ni">❯ zig build         # just build the project<br/>❯ zig build run     # build project and run executable<br/>❯ zig build install # install executable<br/>❯ zig build uninstall</span></pre><p id="d57e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Ikrima有一个很棒的，更详细的Zig构建系统指南。</p><h2 id="431f" class="lz ma it bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">文件是结构</h2><p id="8832" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">关于Zig，我忘记的第一件事是源代码文件充当结构。我在阅读一些Zig标准库代码时被这个问题绊倒了，这些代码使用了关键字<code class="fe mx my mz na b">@This</code>来引用当前周围结构的类型。我们可以在<code class="fe mx my mz na b">std/rand.zig</code>文件中看到这样的例子，这里我们有一个<code class="fe mx my mz na b">SequentialPrng</code>类型的定义。我们用<code class="fe mx my mz na b">@This()</code>来定义<code class="fe mx my mz na b">Self</code>类型。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="9d64" class="lz ma it na b gy nf ng l nh ni">const SequentialPrng = struct {<br/>    const Self = @This();<br/>    next_value: u8,<br/><br/>    pub fn init() Self {<br/>        return Self{<br/>            .next_value = 0,<br/>        };<br/>    }<br/><br/>    pub fn random(self: *Self) Random {<br/>        return Random.init(self, fill);<br/>    }<br/><br/>    pub fn fill(self: *Self, buf: []u8) void {<br/>        for (buf) |*b| {<br/>            b.* = self.next_value;<br/>        }<br/>        self.next_value +%= 1;<br/>    }<br/>};</span></pre><p id="fb5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我困惑的是在顶层的<code class="fe mx my mz na b">std/mem/Allocator.zig</code>文件中找到下面一行。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="1d5c" class="lz ma it na b gy nf ng l nh ni">const Allocator = @This();</span></pre><p id="5e19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我问自己，“周围的结构在哪里？”我开始思考一些疯狂的想法，比如在一个<code class="fe mx my mz na b">struct</code>定义中导入文件。c程序员有时会做类似的事情。然而，这并不是什么疯狂的事情。源代码文件中的所有顶级定义都是包含整个源代码文件的未命名结构中的字段。很容易忘记，在Zig中，结构无处不在，而且它们并没有真正命名。</p><p id="8f4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能会问我为什么要在Zig源代码中挖掘。原因很简单，如果你想学习Zig编程，现在你必须习惯这一点。在我的例子中，我正在查看一个旧的代码片段，用于在我用Zig编写的名为<a class="ae nj" href="https://github.com/ordovician/Zacktron-33" rel="noopener ugc nofollow" target="_blank"> Zacktron-33 </a>的玩具汇编器解析器中分配一个字典来保存符号标签。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="4248" class="lz ma it na b gy nf ng l nh ni">var labels = Dict(i16).init(allocator);</span></pre><p id="f5f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想更好地理解这个字典分配是如何工作的，所以我点击了<code class="fe mx my mz na b">init</code>函数来跳转到实现(你可以用Zig语言服务器<a class="ae nj" href="https://marketplace.visualstudio.com/items?itemName=AugusteRame.zls-vscode" rel="noopener ugc nofollow" target="_blank"> ZLS </a>在VS代码中这样做)。这让我发现它采用了类型为<code class="fe mx my mz na b">Allocator</code>的at参数，我点击它了解到它在<code class="fe mx my mz na b">std/mem.zig</code>文件中被定义为:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="ded5" class="lz ma it na b gy nf ng l nh ni">pub const Allocator = @import("mem/Allocator.zig");</span></pre><p id="350f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着<code class="fe mx my mz na b">Allocator</code>是一个在<code class="fe mx my mz na b">std/mem/Allocator.zig</code>文件顶层保存所有定义的结构。在顶层，<code class="fe mx my mz na b">Allocator.zig</code>文件定义了这些变量:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="2107" class="lz ma it na b gy nf ng l nh ni">ptr: *anyopaque,<br/>vtable: *const VTable,</span></pre><p id="9bf2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些就像struct字段一样工作，因为我们可以看到<code class="fe mx my mz na b">init</code>函数如何返回由文件struct(代表整个源代码文件的struct)定义的struct的实例。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="398d" class="lz ma it na b gy nf ng l nh ni">const Allocator = @This();<br/><br/>pub fn init(...) Allocator {   // edited out parameters<br/>	// edit out code<br/>    return .{<br/>        .ptr = pointer,<br/>        .vtable = &amp;gen.vtable,<br/>    };<br/>}</span></pre><h2 id="7e0f" class="lz ma it bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">函数的第一个参数得到特殊处理</h2><p id="f32e" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">注意如何将<code class="fe mx my mz na b">add</code>函数视为<code class="fe mx my mz na b">Vec2D</code>结构的方法。第一个参数<code class="fe mx my mz na b">u</code>作为<code class="fe mx my mz na b">self</code>参数。你可以看到<code class="fe mx my mz na b">u.add(v)</code>是如何等同于<code class="fe mx my mz na b">Vec2D.add(u, v)</code>的。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="6cc8" class="lz ma it na b gy nf ng l nh ni">const std = @import("std");<br/><br/>const Vec2D = struct {<br/>    dx: i32,<br/>    dy: i32,<br/><br/>    fn add(u: Vec2D, v: Vec2D) Vec2D {<br/>        return Vec2D {<br/>            .dx = u.dx + v.dx,<br/>            .dy = u.dy + v.dy,<br/>        };<br/>    }<br/>};<br/><br/>pub fn main() anyerror!void {   <br/>    const u = Vec2D { .dx = 3, .dy = 4 };<br/>    const v = Vec2D { .dx = 2, .dy = 1 };<br/>    <br/>    const w = u.add(v);<br/>    const z = Vec2D.add(u, v);<br/>    <br/>    std.log.info("u.add(v) == {d}", .{w});<br/>    std.log.info("Vec2D.add(u, v) == {d}", .{z});<br/>}</span></pre><h2 id="9622" class="lz ma it bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">Zig没有接口</h2><p id="a90c" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">Zig结构不能像Go结构那样实现接口。我注意到，就我个人而言，这个事实经常让我犯错。我努力尝试定义一个带<code class="fe mx my mz na b">std.io.Writer</code>参数的函数，这样我就可以选择是将我编写的汇编器的输出发送给<code class="fe mx my mz na b">stdout</code>还是发送给<code class="fe mx my mz na b">std.io.getStdOut().writer()</code>获得的文件。我天真地写了一个这样的函数签名:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="a347" class="lz ma it na b gy nf ng l nh ni">// Doens't work<br/>const Writer = std.io.Writer;<br/>fn assemble(allocator: Allocator, <br/>            file: File, <br/>            writer: Writer   // naive assumption about interfaces<br/>   ) !void</span></pre><p id="c450" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里突出的问题是<code class="fe mx my mz na b">std.io.Writer</code>不是一个类型，而是一个函数。Zig中的每个编写器都产生不同的类型，这意味着没有运行时方法来处理这个问题。在Go中通常使用接口的地方，Zig方式是使用<code class="fe mx my mz na b">anytype</code>类型。<code class="fe mx my mz na b">std.io.Writer</code>函数仅用于创建表示作者的结构。但是每个结构都是不同的。您不能将它们视为某个<code class="fe mx my mz na b">Writer</code>接口的子类型，因为Zig没有接口的概念。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="f4e0" class="lz ma it na b gy nf ng l nh ni">fn assemble(allocator: Allocator, <br/>            file: File,<br/>            writer: anytype) !void</span></pre><p id="81bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编写器的类型必须在编译时已知。在这方面，Zig感觉在某些方面有点像脚本语言。您可以通过添加各种编译时检查来检查并确保传递了正确的类型。</p><p id="a201" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你查看Zig源代码，你会发现<code class="fe mx my mz na b">anytime</code>经常被作家使用。例如，这就是如何实现<code class="fe mx my mz na b">format</code>函数。我们可以向自定义数据类型添加一个<code class="fe mx my mz na b">format</code>函数，以便<code class="fe mx my mz na b">print</code>函数可以正确显示它。请注意，<code class="fe mx my mz na b">writer</code>参数属于<code class="fe mx my mz na b">anytype</code>类型。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="053c" class="lz ma it na b gy nf ng l nh ni">const Vec2D = struct {<br/>    dx: i32,<br/>    dy: i32,<br/><br/>    fn add(u: Vec2D, v: Vec2D) Vec2D {<br/>        return Vec2D {<br/>            .dx = u.dx + v.dx,<br/>            .dy = u.dy + v.dy,<br/>        };<br/>    }<br/><br/>    pub fn format(<br/>        v: Vec2D,<br/>        comptime fmt: []const u8,<br/>        options: std.fmt.FormatOptions,<br/>        writer: anytype,<br/>    ) !void {<br/>        try writer.print("Vec2D({d}, {d})", .{ v.dx, v.dy });<br/>		<br/>        // Make compiler shut up<br/>        _ = fmt; _ = options;<br/>    }<br/>};</span></pre><h2 id="1f62" class="lz ma it bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">Zig中的函数参数是常量</h2><p id="fdad" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">因为当您在字典上调用<code class="fe mx my mz na b">deinit</code>时，字典中的值和键不会自动释放，所以我尝试创建一个<code class="fe mx my mz na b">releaseDict</code>函数来处理它。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="5e15" class="lz ma it na b gy nf ng l nh ni">const Dict = std.StringHashMap;<br/><br/>fn releaseDict(allocator: Allocator, dict:  Dict(i16)) void {<br/>    var iter = dict.iterator();<br/>    while (iter.next()) |entry|<br/>        allocator.free(entry.key_ptr.*);<br/>    dict.deinit();    <br/>}</span></pre><p id="5a91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行这段代码效果不好。相反，我得到了以下错误消息:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="8b78" class="lz ma it na b gy nf ng l nh ni">❯ zig test src/assembler.zig<br/>./src/assembler.zig:213:5: error: expected type '*std.hash_map.HashMap([]const u8,i16,std.hash_map.StringContext,80)', found '*const std.hash_map.HashMap([]const u8,i16,std.hash_map.StringContext,80)'<br/>    dict.deinit();<br/>    ^<br/>./src/assembler.zig:213:5: note: cast discards const qualifier<br/>    dict.deinit();</span></pre><p id="d1b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你仔细观察，你会发现类型应该是<code class="fe mx my mz na b">*HashMap</code>(指向<code class="fe mx my mz na b">HashMap</code>的指针)，但是<code class="fe mx my mz na b">deinit</code>却被赋予了一个<code class="fe mx my mz na b">const *HashMap</code>。这种行为的原因是函数参数在Zig中都是作为常量传递的。来自<a class="ae nj" href="https://ziglang.org/documentation/0.9.1/#Pass-by-value-Parameters" rel="noopener ugc nofollow" target="_blank"> Zig语言参考</a>:</p><blockquote class="nk nl nm"><p id="47c0" class="ku kv nn kw b kx ky ju kz la lb jx lc no le lf lg np li lj lk nq lm ln lo lp im bi translated">结构、联合和数组作为引用传递有时会更有效，因为根据大小的不同，副本的开销可能会很大。当这些类型作为参数传递时，Zig可以选择复制并通过值传递，或者通过引用传递，无论哪种方式Zig决定会更快。<strong class="kw iu">这在一定程度上是因为参数是不可变的</strong>。</p></blockquote><p id="af08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你看一下<code class="fe mx my mz na b">deinit</code>的实现，你就会明白为什么这是一个问题:</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="df19" class="lz ma it na b gy nf ng l nh ni">pub fn deinit(self: *Self) void {<br/>    self.unmanaged.deinit(self.allocator);<br/>    self.* = undefined;<br/>}</span></pre><p id="c0de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在最后一行，我们正在修改<code class="fe mx my mz na b">self</code>指针。我们将其设置为<code class="fe mx my mz na b">undefined</code>。如果<code class="fe mx my mz na b">self</code>引用一个常量类型，这是不可能的，如果它是一个函数参数，就是这种情况。在Zig中，你经常会在其他语言使用<code class="fe mx my mz na b">null</code>的地方使用<code class="fe mx my mz na b">undefined</code>。指针在Zig中不能是<code class="fe mx my mz na b">null</code>，除非是可选类型。在Zig中，我们可以将指针设置为<code class="fe mx my mz na b">undefined</code>，但其含义与使用<code class="fe mx my mz na b">null</code>不同。在调试模式下，未定义的数据被设置为<code class="fe mx my mz na b">0xaa</code>，这允许Zig发现是否从未定义的存储器中读取。从<code class="fe mx my mz na b">undefined</code>内存中读取是非法的。相比之下，检查变量是否为<code class="fe mx my mz na b">null</code>是一件完全有效且合理的事情。我们可以使用<code class="fe mx my mz na b">null</code>来终止一个链表或二叉树。然而，一旦内存被释放，你就再也不想访问那个变量了。</p><p id="cd9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">坦率地说，我发现<code class="fe mx my mz na b">undefined</code>和<code class="fe mx my mz na b">null</code>之间的区别非常聪明，我很惊讶没有更多的语言模仿这种想法。我注意到，在Zig中，错误地使用内存或忘记释放内存比我使用过的任何其他手动内存管理语言都要容易得多，比如C/C++。</p><p id="deb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">处理这个问题的正确方法是将<code class="fe mx my mz na b">dict</code>作为指针传递。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="4371" class="lz ma it na b gy nf ng l nh ni">fn releaseDict(allocator: Allocator, dict: *Dict(i16)) void {<br/>    var iter = dict.iterator();<br/>    while (iter.next()) |entry|<br/>        allocator.free(entry.key_ptr.*);<br/>    dict.deinit();    <br/>}</span></pre><p id="6092" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这种行为有点烦人，但我看到了参数为常量的好处。这种选择允许以最佳方式传递结构。编译器可以选择复制结构或通过引用传递结构。在C++中，我们没有这种便利，它迫使你写类似于<code class="fe mx my mz na b">const &amp;Dict dict</code>的东西。对于基于模板的代码，这是次优的，因为您不知道您传递的类型有多大。如果是基元类型，比如整数，那么通过引用传递是低效的。</p><h1 id="4a1e" class="nr ma it bd mb ns nt nu me nv nw nx mh jz ny ka mk kc nz kd mn kf oa kg mq ob bi translated">Zig资源</h1><ul class=""><li id="86aa" class="oc od it kw b kx ms la mt ld oe lh of ll og lp oh oi oj ok bi translated">Ikrima的游戏开发指南提供了一些很棒的Zig资源。</li><li id="c153" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">Zig速成班——让有经验的程序员或任何想快速更新Zig的人参加。</li><li id="57fb" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">Zig中的comp time—在Zig中编译时运行代码的大范围覆盖。赋予Zig开发者元编程能力。</li><li id="9343" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated"><a class="ae nj" href="https://ikrima.dev/dev-notes/zig/zig-build/" rel="noopener ugc nofollow" target="_blank">构建Zig代码</a> —设置用于指定Zig项目的<code class="fe mx my mz na b">build.zig</code>文件。</li><li id="2cb3" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">洛里斯·克罗的<a class="ae nj" href="https://kristoff.it/blog/what-is-zig-comptime/" rel="noopener ugc nofollow" target="_blank">编译时间代码</a>——包含了一个有趣的代码示例，展示了Zig <code class="fe mx my mz na b">comptime</code>如何用于在运行时删除一个组合的for循环和switch语句。他展示了如何将一系列操作应用于一些输入，并将其转化为一系列语句。</li><li id="4121" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">安德鲁·凯利的完美散列法Zig的创始人有一个使用编译时间代码创建完美散列函数的有趣例子。这是一个有点复杂的例子，但有助于真正打开你的思维，看看Zig <code class="fe mx my mz na b">comptime</code>功能允许你做什么。</li><li id="99e6" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">Zig接口 —更新为使用类似Go的胖指针。</li></ul></div></div>    
</body>
</html>