<html>
<head>
<title>Deploying a full stack Scala application on fly.io</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在fly.io上部署全栈Scala应用</h1>
<blockquote>原文：<a href="https://itnext.io/deploying-a-full-stack-scala-application-on-fly-io-f80ca9de9b13?source=collection_archive---------0-----------------------#2022-12-04">https://itnext.io/deploying-a-full-stack-scala-application-on-fly-io-f80ca9de9b13?source=collection_archive---------0-----------------------#2022-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fc55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不久前，我很高兴地发现Heroku允许一个人在他们的dynos上免费托管一个小应用程序。然而，最近，我不太高兴地得知他们<a class="ae kl" href="https://blog.heroku.com/next-chapter" rel="noopener ugc nofollow" target="_blank">正在让他们</a>退役，所以人们被要求更新付费计划。</p><p id="89fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，一个备选方案立即出现了，即<a class="ae kl" href="https://fly.io/" rel="noopener ugc nofollow" target="_blank"> fly.io </a>。在这篇博文中，我将展示一个web应用程序的可能设置，其中前端和后端都是用Scala开发的，并且可以很容易地部署到fly.io，<strong class="jp ir">上，完全免费</strong>。对于不耐烦的人，你可以在<a class="ae kl" href="https://github.com/sherpal/FlyIOScalaJVMDemo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到结果。</p><p id="9f60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个小例子，我做了一些无关紧要的技术选择。重点应该放在项目的架构上。然而，为了完整起见，让我们提一下这些选择。服务器使用<a class="ae kl" href="https://github.com/com-lihaoyi/cask" rel="noopener ugc nofollow" target="_blank">桶</a>实现，前端web框架是<a class="ae kl" href="https://laminar.dev/" rel="noopener ugc nofollow" target="_blank">层流</a>。我们使用<a class="ae kl" href="https://vitejs.dev/" rel="noopener ugc nofollow" target="_blank"> vitejs </a>来管理我们前端的打包，使用<a class="ae kl" href="https://github.com/sbt/sbt-assembly" rel="noopener ugc nofollow" target="_blank"> sbt-assembly </a>来创建一个fat jar。使用<a class="ae kl" href="https://github.com/spray/sbt-revolver" rel="noopener ugc nofollow" target="_blank"> sbt-revolver </a>可以热重装后端服务器。最后，我们使用<a class="ae kl" href="https://circe.github.io/circe/" rel="noopener ugc nofollow" target="_blank"> circe </a>来序列化前端和后端之间的数据。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/e3921f94f2a6a0ffb99c76bf34311b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*ds6qrU3s23HNCh2_x6ZA9g.png"/></div></figure><h1 id="5f97" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">项目结构</h1><p id="3eb6" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">该项目由单个<a class="ae kl" href="https://www.scala-sbt.org/" rel="noopener ugc nofollow" target="_blank"> sbt </a>项目组成，包含三个子模块。一个共享的子模块交叉编译到JVM字节码和JavaScript。该子模块包含前端和后端都应该知道的所有核心逻辑。然后有一个子模块“server”包含后端代码(纯JVM)，还有一个子模块“frontend”包含前端代码(纯JS)。</p><p id="9999" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，总体结构如下所示:</p><pre class="kn ko kp kq gt lx ly lz bn ma mb bi"><span id="a7cd" class="mc kv iq ly b be md me l mf mg">build.sbt<br/>server/<br/>├─ src/<br/>shared-logic/<br/>├─ src/<br/>frontend/<br/>├─ vite.config.js<br/>├─ package.json<br/>├─ src/<br/>shared-logic/<br/>├─ shared/src/<br/>Dockerfile<br/>fly.toml</span></pre><p id="0616" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">后端是一个简单的JVM进程，因此所有的依赖关系都由sbt来处理——这里没有什么要做的了。然而，前端生活在npm生态系统中，因此除了通常的Scala依赖性之外，还必须管理npm依赖性。这项工作交给了维特。特别是，这意味着<strong class="jp ir">下载npm依赖关系</strong>必须通过运行<code class="fe mh mi mj ly b">frontend</code>目录中的<code class="fe mh mi mj ly b">npm ci</code>来“手动”完成。</p><h1 id="aff0" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">开发设置</h1><p id="7b21" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们的目标是将我们的应用程序部署到fly.io。但在我们这样做之前，如果我们能开发它就好了。当开发一个以单页面应用程序为前端的web应用程序时，在我们编码时拥有有效的刷新周期是很重要的。</p><p id="2d7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vite拥有我们实现这一目标所需的一切。它有一个开发服务器，可以在每次源代码更改时自动刷新我们的浏览器页面。在这种情况下，“源代码变更”实际上是Scala.js中编译后的JavaScript文件的变更。幸运的是，让这个编译后的文件在源代码变更时自动刷新可以通过sbt中的命令<code class="fe mh mi mj ly b">~frontend/fastLinkJS</code>来完成。来自vite的dev服务器可以用<code class="fe mh mi mj ly b">frontend</code>目录中的<code class="fe mh mi mj ly b">npm run dev</code>运行。</p><p id="7e2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果服务器后端可以在源代码改变时自动刷新，那就更好了。为此，我们使用sbt-revolver插件。有了它，我们可以在sbt中运行<code class="fe mh mi mj ly b">~server/reStart</code>。</p><p id="5c0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不熟悉web开发，你可能想知道前端(及其运行在端口3000上的dev服务器)如何知道何时联系后端(运行在端口9000上)。Vite以这样的方式配置，以<code class="fe mh mi mj ly b">/api</code>开始的每个请求都被代理到后端。</p><p id="3d15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总而言之，在开发中运行应用程序需要运行这三个命令(在三个不同的终端中):</p><pre class="kn ko kp kq gt lx ly lz bn ma mb bi"><span id="07aa" class="mc kv iq ly b be md me l mk mg">sbt ~frontend/fastLinkJS<br/>sbt ~server/reStart<br/>cd frontend &amp;&amp; npm run dev</span></pre><p id="bf50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后就可以访问<a class="ae kl" href="http://localhost:3000/static" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/static</a></p><h1 id="fa16" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">生产设置</h1><p id="13a6" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在fly.io上部署应用需要几个步骤:将前端部分打包成浏览器可以消费的静态文件，将服务器部分打包成一个现成的fat jar(包含打包的前端)，最后用合适的JVM放在Docker映像中。注意，你甚至不需要安装Docker，fly.io会帮你搞定。</p><p id="71a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不了解Docker，你可以想象给你一台全新的电脑，里面什么都没有，你必须描述你的应用程序需要的所有东西。这个描述包括操作系统——通常是瘦Linux发行版——你想要安装的程序，你需要的文件，最后是执行你的程序的命令。在我们的例子中，我们真的不需要太多:一个JVM和一个fat jar，我们用<code class="fe mh mi mj ly b">java -jar thejar.jar</code>运行它。这些指令被收集在一个<a class="ae kl" href="https://github.com/sherpal/FlyIOScalaJVMDemo/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank">文档文件</a>中。</p><p id="cc6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包装前端由Vite负责。一旦前端子模块用<code class="fe mh mi mj ly b">sbt frontend/fullLinkJS</code>编译好，我们就可以运行<code class="fe mh mi mj ly b">npm run build</code>(在<code class="fe mh mi mj ly b">frontend</code>目录下)，然后把生成的文件复制粘贴到后端的资源里面。</p><p id="3be4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">封装后端使用sbt-assembly，所以我们需要运行<code class="fe mh mi mj ly b">sbt server/assembly</code>来获得fat jar(在项目中，它被配置为叫做<code class="fe mh mi mj ly b">app.jar</code>)。然后我们可以将这个胖罐子复制粘贴到<code class="fe mh mi mj ly b">dist</code>文件夹中，Dockerfile将会在那里找到它。</p><p id="61a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，Dockerfile将使用带有Zulu openjdk的小型Linux发行版，添加fat jar，并在端口8080上运行它，将<code class="fe mh mi mj ly b">isProd</code>设置为true。服务器使用此设置来使用主机<code class="fe mh mi mj ly b">0.0.0.0</code>而不是<code class="fe mh mi mj ly b">localhost</code>。这是必需的，因为即使您在您的计算机上启动Docker容器，通过http到达它仍然被认为是“外部流量”，并且不会响应<code class="fe mh mi mj ly b">localhost</code>。</p><p id="b485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，代替手工完成这些步骤，项目有一个sbt任务<code class="fe mh mi mj ly b">packageApplication</code>将为我们完成所有这些。因此，如果您运行<code class="fe mh mi mj ly b">sbt packageApplication</code>，您将得到一个准备好的文件<code class="fe mh mi mj ly b">dist/app.jar</code>。</p><p id="63ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们将后端配置为服务来自<code class="fe mh mi mj ly b">static</code>文件夹的所有静态文件，这也反映在vitejs配置中。</p><h1 id="801a" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Fly.io设置</h1><p id="4f5d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">完整的fly.io配置包含在<code class="fe mh mi mj ly b">fly.toml</code>文件中，您可以使用<code class="fe mh mi mj ly b">fly launch</code>为自己的应用程序生成该文件。(为此，您需要安装<a class="ae kl" href="https://fly.io/docs/hands-on/install-flyctl/" rel="noopener ugc nofollow" target="_blank"> flyctl </a>。)你会被问一堆问题(特别是我们对postgres或redis数据库说“不”，我们选择阿姆斯特丹作为地点，因为它离比利时最近)。</p><p id="a39b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们有一个docker文件，因为我们用<code class="fe mh mi mj ly b">sbt packageApplication</code>制作了我们的fat jar，所以我们可以运行<code class="fe mh mi mj ly b">fly deploy</code>，魔法就会运行。完成后，我们可以用<code class="fe mh mi mj ly b">fly open</code>直接打开一个浏览器到它的位置，我们甚至可以在飞行中监控它。io <a class="ae kl" href="https://fly.io/dashboard" rel="noopener ugc nofollow" target="_blank"> dashboard </a>。</p><h1 id="5e7e" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">蛋糕上的樱桃:GitHub行动</h1><p id="ab11" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们应用程序的代码托管在Github上，你可能知道，我们被允许以<a class="ae kl" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github动作</a>的形式添加ci/cd管道。Fly.io甚至有一个<a class="ae kl" href="https://fly.io/docs/app-guides/continuous-deployment-with-github-actions/" rel="noopener ugc nofollow" target="_blank">动作我们可以用</a>。在我们的例子中，我们需要将它与安装jdk和sbt的东西以及安装npm的东西混合在一起。这里可以看到详细的<a class="ae kl" href="https://github.com/sherpal/FlyIOScalaJVMDemo/blob/master/.github/workflows/deploy-to-flyio.yml" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b4e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次我们提交到“publish”分支时，我们的应用程序都会自动重新部署到fly.io！</p><h1 id="ed7f" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结束语</h1><p id="cc37" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们看到了如何从scrach开始，建立一个完全用Scala构建的web应用程序，并在fly.io平台上免费部署它们。下一次，我们将做同样的事情，但是使用同样用Scala编写的node.js后端。</p><p id="f887" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我之前的Heroku博客帖子是未来给我的一封信(2022年11月28日结束的未来)，这篇博客帖子是新未来给我的一封信，我希望它能持续更长时间。说了这么多，希望能对你有用！</p><p id="0837" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想了解更多关于全栈Scala和fly.io的内容？看看安东·斯维里多夫的杰作！</p></div></div>    
</body>
</html>