<html>
<head>
<title>Building Your Own React Components in 5 Minutes — Updated 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在5分钟内构建您自己的React组件—2020年更新</h1>
<blockquote>原文：<a href="https://itnext.io/building-your-own-react-components-in-5-minutes-updated-2020-d3ff4e61f009?source=collection_archive---------4-----------------------#2020-10-25">https://itnext.io/building-your-own-react-components-in-5-minutes-updated-2020-d3ff4e61f009?source=collection_archive---------4-----------------------#2020-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="aa04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在5分钟内构建您自己的组件以用于React.js和Next.js</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3424bb7205cf9d473d75cab5eb54da2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ALXVsHAp2atL6j7D"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图多尔·巴休在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d2d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几年前，当我第一次尝试React.js环境时，我提出了不同的概念和不同的命名。其中一个概念是高阶组件(或HOC)，这无疑是我最喜欢(和使用)的特性之一。</p><p id="adcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如React官方文件所说:</p><blockquote class="lf lg lh"><p id="517f" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated">高阶组件(HOC)是React中重用组件逻辑的一种高级技术。本质上，hoc不是React API的一部分。它们是从React的组合性质中出现的一种模式。<br/>具体来说，<strong class="js iu">高阶分量是取一个分量，返回一个新分量的函数。</strong></p></blockquote><p id="b185" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">React使用HTML来构建我们的应用程序的UI。有了HOC，我们可以扩展功能，不仅可以使用<div>、<p>和</p><h1>，还可以使用我们创建的定制组件，如<menu>、<navigationbar>、<carousel>。高阶组件还允许我们向这些组件发送参数，即我们将定义的自定义参数。一个基本的例子是<navigationbar islogged="{}/">。</navigationbar></carousel></navigationbar></menu></h1></div></p><h1 id="5043" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">让我们创建我们的第一个组件。</h1><p id="dc97" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">作为最简单的例子，我们将构建一个接受颜色参数的容器。我们将能够重用这个可着色的容器，并为它们设置不同的颜色。</p><p id="68a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我更喜欢将我的组件保存在单独的<strong class="js iu">组件</strong>文件夹中。我将转到我的组件文件夹，然后我们将创建一个名为<strong class="js iu"> ColorableContainer.js </strong>的新文件。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="ea0e" class="mu ln it mq b gy mv mw l mx my">import React from 'react';</span><span id="3ffe" class="mu ln it mq b gy mz mw l mx my">export default class ColorableContainer extends React.Component {<br/>    <br/>    render() {<br/>        return (<br/>            &lt;div className='colorableContainer' style={{ backgroundColor: this.props.backgroundColor}} &gt;<br/>                {this.props.children}<br/>            &lt;style jsx&gt;{`<br/>                .colorableContainer {<br/>                    width: 100%;<br/>                    height: 40px;<br/>                }<br/>            `}&lt;/style&gt;<br/>            &lt;/div&gt;<br/>        )<br/>    }<br/>}</span></pre><h2 id="fcc1" class="mu ln it bd lo na nb dn ls nc nd dp lw kb ne nf ma kf ng nh me kj ni nj mi nk bi translated">现在，我们在这里做什么？</h2><p id="cde7" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">我们正在创建一个扩展React的类(<strong class="js iu"> ColorableContainer </strong>)。组件(因为我们想使用我们的类作为组件)。<br/>在我们的渲染函数中，我们返回一个具有两种不同样式的div:<br/>—<strong class="js iu">style jsx</strong>:定义静态变量width和height。<br/> — <strong class="js iu">内嵌样式</strong>:动态检测我们的道具值来设置背景颜色。我们使用<strong class="js iu"> this.props </strong>来访问我们将要发送的参数(&lt;Component prop 1 = { prop value } prop 2 = { prop value 2 }/&gt;)。</p><p id="1ebe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们将所有这些包装到this.props.children中。这个值指的是我们将用组件包装的组件</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="ff6a" class="mu ln it mq b gy mv mw l mx my">&lt;Component&gt;<br/>  ...(children)...<br/>&lt;/Component&gt;</span></pre><p id="df0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的组件现在可以使用了。我们可以导入它并使用它来定义背景颜色，并添加添加内部元素的功能。由于这只是一个基本的方法，我们定义了一个固定的高度，但正如我们所看到的是高度可定制的。</p><p id="8b9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以导入它:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="6087" class="mu ln it mq b gy mv mw l mx my">import ColorableContainer from '../components/ColorableContainer';</span></pre><p id="8699" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">新的可以用它作为新的组件。</p><p id="9ea6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="li">请注意，以下代码来自Next.js项目，因此可能与react.js项目有所不同。</em></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="a5c9" class="mu ln it mq b gy mv mw l mx my">import ColorableContainer from '../components/ColorableContainer';</span><span id="47c3" class="mu ln it mq b gy mz mw l mx my">export default function Home() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ColorableContainer backgroundColor={'rgb(0,255,0)'}/&gt;<br/>      &lt;ColorableContainer backgroundColor={'red'}&gt;<br/>          &lt;p&gt;Test&lt;/p&gt;<br/>        &lt;/ColorableContainer&gt;<br/>        &lt;style jsx&gt;{`<br/>            p {<br/>              margin: 0;<br/>            }<br/>        `}&lt;/style&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="0fd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编译时，我们将找到我们的2个容器。一个具有绿色背景颜色(用RGB定义)而没有内部内容，下一个具有红色背景，仅用“红色”和内部段落定义。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/10994c2d74698310f5272e2006f5960f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tzq0JPeLsXFOBpVmCrPWfg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我们的HOC可着色容器的结果</figcaption></figure><h1 id="b3b8" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="4458" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">这只是处理高阶元件的一种基本而快速的方法。这本身就是一个热门话题，React团队正在不断更新和添加新功能。我会写更多关于hoc的内容，以及用它能实现什么(组成、增强、参考)</p></div></div>    
</body>
</html>