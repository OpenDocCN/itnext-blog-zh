<html>
<head>
<title>Building a Beat Machine in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在颤动中建造一台打浆机</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-beat-machine-in-flutter-2b25b27d5a5b?source=collection_archive---------1-----------------------#2020-05-20">https://itnext.io/building-a-beat-machine-in-flutter-2b25b27d5a5b?source=collection_archive---------1-----------------------#2020-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4494" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Dart / Flutter中构建带有序列器的节拍机器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/38ad8d67a4ba0d3b840a80b176f8dcea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AorhLnWr3jqBQwc309wmpQ.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">示例应用程序的屏幕记录</figcaption></figure><h2 id="bb9e" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h2><p id="0c80" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi mn translated">自2018年末首次发布1.0版本以来，lutter的人气一直在上升。随着公司和企业家努力保持低开发成本，人们继续寻找更好、更有效的方法来构建移动应用和跨平台软件。Flutter支持所有主要的移动平台，对web和所有主要桌面操作系统的支持正在开发中。</p><p id="10b0" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">在本文中，我们将查看一个简单的beat machine演示，并了解开发该应用程序时使用的底层设计模式。</p><p id="c94a" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">要建立并运行一个颤振环境，请访问<a class="ae nb" href="http://For more information about installing Flutter, see the installation page here." rel="noopener ugc nofollow" target="_blank">安装页面</a>。要获得演示项目源代码的副本，请查看<a class="ae nb" href="https://github.com/kenreilly/flutter-drum-machine-demo" rel="noopener ugc nofollow" target="_blank">资源库</a>。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="a834" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">概念</h2><p id="3134" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">Flutter中有几个关键概念在这个演示应用程序的设计中被广泛使用，以利用Dart的功能，避免编写大量不必要的样板文件或<a class="ae nb" href="https://en.wikipedia.org/wiki/Copypasta" rel="noopener ugc nofollow" target="_blank"> copypasta </a>。这对代码的可读性、可靠性和性能有深远的影响。</p><blockquote class="nj nk nl"><p id="8e0b" class="lu lv nm lw b lx mw ju lz ma mx jx mc nn my me mf no mz mh mi np na mk ml mm im bi translated">最大限度地利用一门语言可能意味着生产一个笨拙的易出错的应用程序或一件艺术品之间的区别。Dart有许多功能来帮助构建具有状态管理的高度交互式异步UX。</p></blockquote><p id="4dc2" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">这些基本概念是:</p><ul class=""><li id="1a46" class="nq nr it lw b lx mw ma mx lh ns ll nt lp nu mm nv nw nx ny bi translated">诸如<a class="ae nb" href="https://api.flutter.dev/flutter/widgets/Container-class.html" rel="noopener ugc nofollow" target="_blank">容器</a>、<a class="ae nb" href="https://api.flutter.dev/flutter/widgets/SizedBox-class.html" rel="noopener ugc nofollow" target="_blank">大小框</a>和<a class="ae nb" href="https://api.flutter.dev/flutter/widgets/Column-class.html" rel="noopener ugc nofollow" target="_blank">列</a>之类的抖动小部件</li><li id="fc46" class="nq nr it lw b lx nz ma oa lh ob ll oc lp od mm nv nw nx ny bi translated">使用<a class="ae nb" href="https://api.dart.dev/stable/2.8.2/dart-async/Timer-class.html" rel="noopener ugc nofollow" target="_blank">计时器</a>和<a class="ae nb" href="https://api.dart.dev/stable/2.8.2/dart-core/Stopwatch-class.html" rel="noopener ugc nofollow" target="_blank">秒表</a>进行时间间隔工作</li><li id="3e19" class="nq nr it lw b lx nz ma oa lh ob ll oc lp od mm nv nw nx ny bi translated">用<a class="ae nb" href="https://api.flutter.dev/flutter/dart-async/Stream-class.html" rel="noopener ugc nofollow" target="_blank">Stream</a>/<a class="ae nb" href="https://api.flutter.dev/flutter/dart-async/StreamController-class.html" rel="noopener ugc nofollow" target="_blank">Stream controller</a>实现服务</li></ul><p id="8ca7" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">在整个演示应用程序中，这些概念以各种方式组合在一起，以实现一种设计，其中UI呈现和控制逻辑被整齐地组织到具有易于使用的接口和属性的类中。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="0087" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">概观</h2><p id="7502" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">节拍机器架构和UX尽可能保持简单，以模仿20世纪70年代和80年代的复古鼓机，在这些鼓机中，机械开关、铜和新奇的8位CPU等资源有限，音乐家可以负担得起的机器需要将设计和制造成本保持在最低水平。</p><p id="702d" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">核心UI框架被分成四个“前面板”部件，每个部件都提供一些交互性，机器逻辑包含在示例回放服务和音频引擎服务中。</p><blockquote class="nj nk nl"><p id="cb1a" class="lu lv nm lw b lx mw ju lz ma mx jx mc nn my me mf no mz mh mi np na mk ml mm im bi translated">这类似于真实硬件乐器上的组件通过跳线或MIDI电缆传递数据(这两种电缆至今仍在音频工程和音乐制作中大量使用)。</p></blockquote></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="623a" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">应用入口点</h2><p id="be8b" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">应用程序在<strong class="lw iu"> main.dart </strong>中初始化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="91a9" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated"><code class="fe og oh oi oj b">main</code>功能首先通过确保微件已初始化，然后设置设备方向，将应用程序锁定为纵向模式。UI框架很简单，有一列显示四个主要的界面小部件。让我们看看用来处理用户输入并根据需要有效地呈现和刷新UI的小部件和类。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="de54" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">基本部件</h2><p id="dfcd" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">支架中的四个主要小部件扩展了一个公共基类来连接音频引擎。这个类位于<strong class="lw iu">视图/基类. dart </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="64c5" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">BaseWidget和BaseeState类分别扩展StatefulWidget和State，并实现一个内部流，该流在初始化时将侦听器连接到AudioEngine，并在从引擎收到信号时刷新状态。因此，每个扩展BaseWidget的小部件都将在音频引擎发送信号(表示引擎中发生了事件，需要重新构建UI)时重新构建。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="6f78" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">表示盘</h2><p id="51d8" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">脚手架立柱上最上面的组件是<strong class="lw iu">视图/显示器。dart </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cc12" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">DisplayPanel在屏幕顶部呈现BPM和步进位置指示器，并且当基类接收到信号时会自动刷新。单击BPM指示器将打开BPMSelector对话框，其中包含从1到256的选项列表。选择一个将在音频引擎上设置BPM。</p><p id="f930" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">生成步骤指示器，当引擎运行且当前步骤与每个渲染周期的索引相匹配时，每个指示器都会“亮起”。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="9b84" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">模式序列发生器</h2><p id="732c" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">模式序列编辑器部件在<strong class="lw iu">视图/sequencer.dart </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8265" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">Sequencer是一个无状态小部件，因为它本身不提供任何交互性，而是呈现提供每个轨迹UX的轨迹小部件。</p><p id="15f3" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">为每个样本生成一个扩展行，标签在左侧，轨道将自动扩展以适应该行的剩余空间。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="f25a" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">音序器轨道</h2><p id="1692" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">在<strong class="lw iu"> views/track.dart </strong>中描述了序列编辑器轨迹:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="b104" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">Track widget扩展了BaseWidget，因此当它收到来自音频引擎的信号时会自动重建。每个轨道都包含一个由八个音符指示器生成的列表，单击该列表会将一个事件传递给音频引擎，然后音频引擎会在内部切换音符开/关状态，并发出刷新信号。每个音符块指示器的颜色由当前位置是否存在音符以及该音符当前是否正在播放来确定。当不存在注释时，颜色会因可见性和UX而每隔一列发生变化。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="092d" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">运输控制</h2><p id="765b" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">让我们看看<strong class="lw iu"> views/transport.dart </strong>中的传输控制小部件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="499c" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">Transport类构建了一行传输控制按钮，每个按钮在被点击时都会调用<code class="fe og oh oi oj b">onTap</code>,向引擎触发一个状态改变事件，这又会通过其基类向小部件发出刷新信号。当一个按钮与当前引擎状态匹配时，通过将<code class="fe og oh oi oj b">null</code>传递到MaterialButton的<code class="fe og oh oi oj b">onPressed</code>方法中来禁用它。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="0f30" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Pad Bank</h2><p id="d648" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">鼓垫组在<strong class="lw iu">视图/垫组中定义。dart </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1845" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">PadBank扩展了StatelessWidget，因为它没有可变属性，因此不需要状态。这个小部件在父级可用空间高度的1/3处呈现一个容器，其中有两行Pad小部件，每一行都有一个定义的大小，以及一个从当前列表索引派生的值。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="b55a" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">电子鼓垫</h2><p id="7104" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">鼓垫部件在<strong class="lw iu">视图/pad.dart: </strong>中定义</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="d3cb" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">Pad小部件是无状态的，并接受三个最终的(不可变的)参数作为参数。定义了三个<code class="fe og oh oi oj b">get</code>属性来拉动<code class="fe og oh oi oj b">DRUM_SAMPLE</code>以及相应的样本名称和颜色。当一个板被点击时，一个板事件被传递到音频引擎进行进一步处理。</p><p id="ee70" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">接下来，我们来看看beat machine的内部工作原理。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="cf4c" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">取样器</h2><p id="80bd" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">样本定义和加载/回放在<strong class="lw iu"> services/sampler.dart </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="4032" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">使用<code class="fe og oh oi oj b">DRUM_SAMPLE</code>定义样本类型，并在服务上初始化相应的文件名和颜色，该服务在应用程序初始化期间加载音频文件。当从音频引擎调用采样器上的<code class="fe og oh oi oj b">play</code>时，播放相应的缓存音频文件。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="89f9" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">音频引擎</h2><p id="211b" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">让我们在<strong class="lw iu">services/audio-service . dart:</strong>中查看音频服务</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="47dc" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">AudioEngine服务管理传输控制状态，处理输入事件，在录制时对传入的音符执行<a class="ae nb" href="https://en.wikipedia.org/wiki/Quantization_(signal_processing)" rel="noopener ugc nofollow" target="_blank">量化</a>，存储轨道数据，并根据需要向所有收听小部件发送信号以刷新UI。</p><p id="a198" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">为所需的每种类型的音频引擎事件定义了事件类，并且占位符信号类被定义为用作刷新UI的通用信号。在更复杂的场景中，Signal类可以扩展为向UI传递不同类型的信号。</p><p id="8a9a" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">定义了模式分辨率和步长，以及控制状态、BPM、初始跟踪数据、计时器/手表<code class="fe og oh oi oj b">/ _tick</code>计算和带有监听器的流控制器，以允许监听小部件接收信号。</p><p id="8e90" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">当一个控制表面(比如鼓垫)用一个事件实例调用<code class="fe og oh oi oj b">on</code>时，该方法利用泛型来切换事件类型并采取正确的动作。这样，所有传入的消息都通过一个位置进行路由，并得到相应的处理。每种事件类型对应于引擎中的一组操作。一旦所有更新完成，<code class="fe og oh oi oj b">control</code>、<code class="fe og oh oi oj b">edit</code>、<code class="fe og oh oi oj b">next</code>和<code class="fe og oh oi oj b">synchronize</code>方法都会向UI发出一个信号。</p><p id="132b" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">音频引擎的设计允许在不重启引擎的情况下即时进行更新，例如通过简单的状态改变来实现记录，这将导致未来传入的音符通过<code class="fe og oh oi oj b">process</code>方法，并且能够在模式中间调整速度，以及将当前运行的计时器<code class="fe og oh oi oj b">synchronize</code>调整到新的BPM。</p><p id="4b80" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">当接收到EditEvent时，事件数据用于翻转该轨道和步长位置的音符开/关条件的布尔值。当音频引擎启动时，会创建一个定期计时器，它将按每个<code class="fe og oh oi oj b">_tick</code>值推进音序器一次，并调用<code class="fe og oh oi oj b">next</code>，后者将递增或重置计时器，然后检查当前步骤中每个音轨的音符，最后重置量化<code class="fe og oh oi oj b">_watch</code>并向UI发送信号。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="afc9" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/eb80456b384eae327f9c37ee7f854a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Bxhmmq8PfT3o-Kxek25zxw.gif"/></div></div></figure><p id="16c2" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">该项目展示了Flutter SDK中用于快速应用设计和开发的强大功能。</p><p id="18a7" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">对于构建具有出色性能和可靠性的高度交互的跨平台应用程序来说，Flutter是一个很好的选择。通过对移动、桌面和web目标的支持，开发人员可以构建高质量的应用程序，这些应用程序可以在任何地方运行，并且易于维护，具有通用的语法和对库和包的几乎通用的支持。</p><p id="3072" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">这大大简化了保持大型多平台更新的任务，使其具有一致的功能、坚如磐石的可靠性和超快的性能。</p><p id="159b" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">感谢您的阅读，祝您的下一个颤振项目好运！</p><p id="8d63" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">~ <a class="ae nb" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a></p></div></div>    
</body>
</html>