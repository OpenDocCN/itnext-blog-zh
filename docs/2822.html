<html>
<head>
<title>Can JSON.parse() performance be improvement?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JSON.parse()性能可以提升吗？</h1>
<blockquote>原文：<a href="https://itnext.io/can-json-parse-be-performance-improvement-ba1069951839?source=collection_archive---------2-----------------------#2019-08-09">https://itnext.io/can-json-parse-be-performance-improvement-ba1069951839?source=collection_archive---------2-----------------------#2019-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/29a69bd06e3a700b7cb5e1a6f86fd1ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-3oBM-pTylwylXE6gDnUg.png"/></div></div></figure><div class=""/><div class=""><h2 id="d8dc" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">JSON.parse是一种创建对象副本的缓慢方法。但是它真的能提高我们代码的性能吗？</h2></div><blockquote class="kq kr ks"><p id="fb48" class="kt ku kv kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这篇文章需要关于形状和内嵌缓存的基本知识。如果没有看过 <a class="ae lq" href="https://erdem.pl/2019/08/v-8-function-optimization" rel="noopener ugc nofollow" target="_blank"> <em class="jb"> V8功能优化</em> </a> <em class="jb">，可能很难跟上这一条。</em></p></blockquote><h1 id="82b5" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">问题</h1><p id="40ce" class="pw-post-body-paragraph kt ku jb kw b kx mj kc kz la mk kf lc ml mm lf lg mn mo lj lk mp mq ln lo lp ij bi translated">创建对象的副本是JS中的常见做法。你可能已经在<strong class="kw jc"> Redux </strong>或其他地方创建<strong class="kw jc">reducer</strong>的时候做过了。目前，最常用的语法是spread</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="fd1e" class="na ls jb mw b gy nb nc l nd ne">const objA = { name: 'Jack', surname: 'Sparrow' };<br/>const objB = { ...objA };</span></pre><p id="3534" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">实践中的用法:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7945" class="na ls jb mw b gy nb nc l nd ne">function dataReducer(state = { name: '', surname: '' }, action) {<br/>  switch (action.type) {<br/>    case ACTION_TYPES.SET_NAME:<br/>      return {<br/>        ...state,<br/>        name: action.name,<br/>      };<br/>    case ACTION_TYPES.SET_SURNAME:<br/>      return {<br/>        ...state,<br/>        surname: action.surname,<br/>      };<br/>    default:<br/>      return state;<br/>  }<br/>}</span></pre><p id="d45e" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">但是可以用很多方法来实现(不算各种库)</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e7ce" class="na ls jb mw b gy nb nc l nd ne">const objC = Object.assign({}, objA);<br/>const objD = JSON.parse(JSON.stringify(objA));</span></pre><p id="0f80" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">如果你用这些方法测试复制1⁰⁹对象需要多长时间，你会得到这样的结果(每次我们复制<code class="fe nf ng nh mw b">objA</code>):</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="ac0a" class="na ls jb mw b gy nb nc l nd ne">test with spread: 14 ms. <br/>test with Object.assign: 36 ms. <br/>test with JSON.parse: 702 ms.</span></pre><p id="dbd8" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">显然<code class="fe nf ng nh mw b">JSON.parse</code>是他们中最慢的，而且差距很大。为什么你甚至应该考虑使用它而不是传播？</p><h1 id="ec04" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">V8发动机没有如此明显的表现</h1><p id="aad7" class="pw-post-body-paragraph kt ku jb kw b kx mj kc kz la mk kf lc ml mm lf lg mn mo lj lk mp mq ln lo lp ij bi translated">一切都归结于V8如何优化功能。每次执行函数时，V8都会将传递给它的对象与<code class="fe nf ng nh mw b">IC</code>(内嵌缓存)进行比较，如果该对象的<code class="fe nf ng nh mw b">Shape</code>存储在其中一个“缓存”中，那么V8可以遵循“快速路径”。</p><p id="2bcf" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">所以如果你有这样一个函数</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="96d3" class="na ls jb mw b gy nb nc l nd ne">function test(obj) {<br/>  let result = '';<br/>  for (let i = 0; i &lt; N; i += 1) {<br/>    result += obj.a + obj.b;<br/>  }<br/>  return result;<br/>}</span></pre><p id="84b2" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">你可以用多个相同形状的物体来运行它，并且有很好的性能</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7187" class="na ls jb mw b gy nb nc l nd ne">const jack = { name: 'Jack', surname: 'Sparrow' };<br/>const frodo = { name: 'Frodo', surname: 'Baggins' };<br/>const charles = { name: 'Charles', surname: 'Xavier' };<br/>test(jack);<br/>test(frodo);<br/>test(charles);</span></pre><p id="3c4e" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">原因是V8将把这个函数标记为<strong class="kw jc">单态</strong>并优化它的代码。如你所知，只有当函数被一个且只有一个形状调用时，才会发生这种情况。</p><p id="1677" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">让我们检查使用3种复制方法中的每一种时会产生哪种形状:</p><blockquote class="kq kr ks"><p id="1b98" class="kt ku kv kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="jb">运行下面的代码使用</em> <code class="fe nf ng nh mw b"><em class="jb">d8 --allow-natives-syntax index.js</em></code> <em class="jb">来获取访问V8内部的方法类似</em> <code class="fe nf ng nh mw b"><em class="jb">%HaveSameMap()</em></code></p></blockquote><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4633" class="na ls jb mw b gy nb nc l nd ne">//testSpread.js<br/>const objA = { name: 'Jack', surname: 'Sparrow' };<br/>const objB = { ...objA };<br/>console.log(%HaveSameMap(objA, objB)); // false</span><span id="1a62" class="na ls jb mw b gy ni nc l nd ne">//testAssign.js<br/>const objA = { name: 'Jack', surname: 'Sparrow' };<br/>const objC = Object.assign({}, objA);<br/>console.log(%HaveSameMap(objA, objC)); // false</span><span id="eca1" class="na ls jb mw b gy ni nc l nd ne">//testParse.js<br/>const objA = { name: 'Jack', surname: 'Sparrow' };<br/>const objD = JSON.parse(JSON.stringify(objA));<br/>console.log(%HaveSameMap(objA, objD)); // true</span></pre><p id="5390" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">正如你所看到的，只有<code class="fe nf ng nh mw b">JSON.parse(JSON.stringify(objA))</code>创建了一个和<code class="fe nf ng nh mw b">objA</code>形状相同的物体。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/2dd49d37f5558ced70ae68a6c1d824a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*UOZbHefoXdp96clF.jpg"/></div></figure><h1 id="52a4" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">非单态函数的代价</h1><p id="16d7" class="pw-post-body-paragraph kt ku jb kw b kx mj kc kz la mk kf lc ml mm lf lg mn mo lj lk mp mq ln lo lp ij bi translated">这是我们的功能</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2315" class="na ls jb mw b gy nb nc l nd ne">function test(obj) {<br/>  let result = '';<br/>  // Any costly operation<br/>  for (let i = 0; i &lt; N; i += 1) {<br/>    result += obj.name + obj.surname;<br/>  }<br/>  return result;<br/>}</span></pre><p id="7589" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">这里重要的是函数的开销和线程阻塞。这个例子很愚蠢，但是想象一下有一些复杂的数学运算在进行。这就是我们如何以两种不同的方式调用我们的函数</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="97f2" class="na ls jb mw b gy nb nc l nd ne">const jack = { name: 'Jack', surname: 'Sparrow' };<br/>const frodo = { name: 'Frodo', surname: 'Baggins' };<br/>const charles = { name: 'Charles', surname: 'Xavier' };<br/>const legolas = { name: 'Legolas', surname: 'Thranduilion' };<br/>const indiana = { name: 'Indiana', surname: 'Jones' };</span><span id="1a63" class="na ls jb mw b gy ni nc l nd ne">for (let i = 0; i &lt; N; i += 1) {<br/>  test(JSON.parse(JSON.stringify(jack)));<br/>  test(JSON.parse(JSON.stringify(frodo)));<br/>  test(JSON.parse(JSON.stringify(charles)));<br/>  test(JSON.parse(JSON.stringify(legolas)));<br/>  test(JSON.parse(JSON.stringify(indiana)));<br/>}</span><span id="e2ad" class="na ls jb mw b gy ni nc l nd ne">for (let i = 0; i &lt; N; i += 1) {<br/>  test({ ...jack });<br/>  test({ ...frodo });<br/>  test({ ...charles });<br/>  test({ ...legolas });<br/>  test({ ...indiana });<br/>}</span></pre><p id="c7c7" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">这是一个很常见的场景。我们不想影响现有的对象，所以我们决定创建它的副本。</p><p id="4c69" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">如果您将<code class="fe nf ng nh mw b">N</code>设置为<strong class="kw jc"> 10000 </strong>并运行此循环，结果可能会让您大吃一惊:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e3f5" class="na ls jb mw b gy nb nc l nd ne">test with PARSE: 2522 ms. <br/>test with spread: 10046 ms.</span></pre><p id="9b2d" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">什么？传播比<code class="fe nf ng nh mw b">JSON.parse</code>慢4倍？如果那很奇怪，记得我以前说过的话吗</p><blockquote class="kq kr ks"><p id="c618" class="kt ku kv kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="jb"> V8将把那个函数标记为</em> <strong class="kw jc"> <em class="jb">单态</em> </strong> <em class="jb">并优化它的代码</em></p></blockquote><p id="a5bf" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">因为测试不是一个简单的函数(代码很简单，但是运行起来很昂贵)，调用<code class="fe nf ng nh mw b">JSON.stringify</code>和<code class="fe nf ng nh mw b">JSON.parse</code>的初始成本比运行没有优化的函数要低得多。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/34fc14d333d60a69f89a58b04ee534d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/0*3etUV0WHi81smxVV.png"/></div></figure><p id="cd50" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">在第二次测试运行中，该函数变成了<strong class="kw jc">巨型函数</strong>，V8停止优化它。你可以检查<a class="ae lq" href="https://gist.github.com/burnpiro/03ebfca377bc037cda840757cddc528d" rel="noopener ugc nofollow" target="_blank">这个要点</a>在你的机器上试试。</p><h1 id="3fa9" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">结论</h1><p id="eb99" class="pw-post-body-paragraph kt ku jb kw b kx mj kc kz la mk kf lc ml mm lf lg mn mo lj lk mp mq ln lo lp ij bi translated">在JavaScript中设计复杂的计算方法时，理解JS优化是如何工作的非常重要。有时，即使是一件简单的事情也会导致性能下降，您可能需要花费数天时间来找出发生了什么。</p><p id="73da" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">我不是说用<code class="fe nf ng nh mw b">JSON.parse</code>替换所有的spread操作符，那会降低你的应用程序的性能。我的观点是，有时降低一件事情的性能可以极大地提高另一件事情的性能。</p><p id="1147" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated">我刚刚描述的情况是一个非常特殊的情况，可能只有当一个函数做一些昂贵的事情时才会影响到你，但是知道这一点可以帮助你以不同的方式处理问题。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="75a1" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc ml le lf lg mn li lj lk mp lm ln lo lp ij bi translated"><em class="kv">最初发布于</em><a class="ae lq" href="https://erdem.pl/2019/08/can-json-parse-be-performance-improvement" rel="noopener ugc nofollow" target="_blank"><em class="kv">https://erdem . pl</em></a><em class="kv">。</em></p></div></div>    
</body>
</html>