<html>
<head>
<title>Moving Libraries to Deno: The Whys and Hows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将图书馆迁移到Deno:为什么和如何</h1>
<blockquote>原文：<a href="https://itnext.io/moving-libraries-to-deno-the-whys-and-hows-58acd4a31f05?source=collection_archive---------0-----------------------#2022-02-02">https://itnext.io/moving-libraries-to-deno-the-whys-and-hows-58acd4a31f05?source=collection_archive---------0-----------------------#2022-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c3511bcf88878ab330b8827aa9aa33ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPp_2skTU4FmQvHCjKOpyg.png"/></div></div></figure><p id="0c43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">粗略地看一下关于Deno <a class="ae kw" href="#dd75" rel="noopener ugc nofollow"> </a>的众多介绍性文章，你会发现它是Node.js的替代品，避开了NPM，内置了TypeScript，并通过权限标志实现了安全性。潜在的信息经常暗示与现有Node.js生态系统的不兼容性，强调“让我们从头开始”的方法，完全没有抓住要点。坦率地说，我认为这些甚至都不是Deno的主要特性，将它与现有的Node.js生态系统相提并论从根本上说是被误导了。</p><p id="a16a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自从Deno问世以来，我一直关注着它，并于去年在其中重写了我的同构JavaScript库<a class="ae kw" href="#1563" rel="noopener ugc nofollow"> </a> <a class="ae kw" href="#8b63" rel="noopener ugc nofollow"> </a> <a class="ae kw" href="http://20e5" rel="noopener ugc nofollow" target="_blank"> ⁴ </a>。根据这一经验，我想让您相信Deno不仅是一个有前途的平台，而且已经是一个有能力编写面向浏览器、Deno和Node.js的同构JavaScript的环境。</p><p id="900d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">免责声明</em>:我与Deno公司没有关联，虽然我接受贿赂，但我没有从他们那里接受任何贿赂(至今)。观点是我自己的，不代表其他人的观点。</p><h1 id="de8f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Deno的案例</h1><p id="dddd" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在浏览器和服务器之间共享代码，即所谓的<em class="kx">同构JavaScript </em>，一直是Node.js带来的主要优势之一。它减少了代码量，但更重要的是，它减少了我们在处理多种语言时必须进行的上下文切换。不幸的是，由于历史原因，我们现在有不同的API在Node.js和浏览器中执行类似的任务。和解的过程是缓慢而痛苦的。另一方面，Deno依赖于标准的web APIs，潜在地消除了上下文切换。你甚至可以在MDN中查看Deno是如何支持每个web API的。</p><p id="dbc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">遵守标准API变得更加重要，因为web不再严格区分客户端和服务器:我们现在有服务工作人员，他们实际上是生活在客户端机器上的“服务器”，而边缘计算工作人员(如Cloudflare工作人员)位于两者之间，他们都实现标准web APIs的子集。</p><p id="d5f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你在过去的十年中听说过JavaScript，你可能会熟悉<em class="kx">the fatigue</em>——一个末日场景，一个流氓<code class="fe mb mc md me b">node_modules</code>文件夹消耗了网络上所有可用的空间...当然，我开玩笑，但是jest，流行的测试运行程序，引入了大约300个依赖项，其他工具和框架也紧随其后。数量本身并不是问题，但是，每个这样的工具都会成倍地增加工具链的复杂性，使其更难设置和维护。最重要的是，每当NPM出现一些不知名的字符串填充库丑闻时，你肯定会在你的依赖项中找到罪魁祸首，通常是通过开发工具。</p><p id="ea52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Deno用几种方法解决了这个问题。首先，Deno将有问题的文件夹重命名为<code class="fe mb mc md me b">cache</code>,极大地抑制了其潜在的破坏性。其次，Deno引入了标准库<a class="ae kw" href="#20b96" rel="noopener ugc nofollow"> ⁵ </a>，认为lodash符合node.js apis。最后，Deno有内置的工具链...</p><h1 id="5f48" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Deno工具链</h1><p id="9ec1" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">开箱即用，Deno带有一个格式化程序、一个linter、一个测试运行程序、一个覆盖报告程序、一个bundler、一个doc生成器，Ryan知道还有什么，所有这些都只需一个控制台命令就能完成。这是开发者体验的巨大进步。为了产生高质量的类型脚本代码，你不再需要安装更漂亮的，ESLint，Jest，TS编译器，Webpack，并花一天的时间试图通过各种插件，预置和仪式化的舞蹈让它们一起工作。</p><p id="f979" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些工具本身大部分是用Rust编写的，并且通常比它们的JavaScript对应物快一个数量级。有些是从零开始写的，比如<code class="fe mb mc md me b">deno_lint</code> <a class="ae kw" href="#edc3" rel="noopener ugc nofollow"> ⁶ </a>，有些是从现有的Rust项目中采用的，比如格式化程序使用<code class="fe mb mc md me b">dprint</code> <a class="ae kw" href="http://98c4" rel="noopener ugc nofollow" target="_blank"> ⁷ </a>，各种编译捆绑工具依赖<code class="fe mb mc md me b">swc</code> <a class="ae kw" href="#7286" rel="noopener ugc nofollow"> ⁸ </a>。也就是说，Deno仍然包括用于类型检查的<code class="fe mb mc md me b">tsc</code>,仅仅是因为缺少替代方案。</p><p id="5782" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Deno工具链的一个不被重视的特性是它所采用的固执己见、零配置的方法。它采用事实上的行业标准，并促使用户遵循这些标准。因此，举例来说，格式化程序和linter的配置选项被有意地限制，尽管如果必要的话，总是有一种选择退出的方法。</p><p id="61b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，确保项目中的代码质量可以归结为一些没有外部依赖性的一行程序:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="0f0d" class="mn kz iq me b gy mo mp l mq mr"># check formatting<br/>deno fmt --check<br/># run the linter<br/>deno lint<br/># run tests collecting coverage<br/>deno test -A --coverage=cov<br/># check coverage<br/>deno coverage cov</span></pre><p id="8ba7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不可否认的是，这些工具可能不像它们流行的同类产品那样功能丰富，有时它们还很粗糙。linter可能缺少自定义ESLint规则集中的一两条规则。formatter虽然与Prettier不相上下，但在大多数情况下，有时会让您感到惊讶，例如，现在它有一种在字符串模板中格式化HTML的特殊方法，如Lit和HyperHTML所使用的方法。</p><h1 id="4559" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">交叉编译和分发</h1><p id="1902" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">用Deno编写的代码可以被编译并捆绑到内置的捆绑器中，供浏览器或Node.js使用。然而，如果您决定使用为Deno编写的TypeScript代码，就像在Typescript编译器(<code class="fe mb mc md me b">tsc</code>)中一样，例如在我们通常的Node.js工具链中，您将遇到一个关于文件导入的小而棘手的问题。Deno(像浏览器一样)完全按照您的要求导入，它需要导入文件的完整路径(扩展名和全部),无论是URL还是本地路径:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="bf17" class="mn kz iq me b gy mo mp l mq mr">import {...} from "https://deno.land/std@0.123.0/testing/asserts.ts"<br/>import {...} from "./mod.ts"</span></pre><p id="c2ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同时，<code class="fe mb mc md me b">tsc</code>更喜欢magic，并将在导入中标记<code class="fe mb mc md me b">.ts</code>扩展的使用。细节就省了吧，不过就是那种<code class="fe mb mc md me b">tsc</code>不对，Deno对的情况。这个问题已经向Typescript团队提出了无数次，并在⁹进行了长时间的讨论。</p><p id="d200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在为Node.js工具链分发Deno代码时，已经有了解决这个问题和其他问题的变通方法。最近，Deno团队推出了<code class="fe mb mc md me b">dnt</code><a class="ae kw" href="#8391" rel="noopener ugc nofollow">⁰</a>——一个从Deno代码创建NPM包的构建工具。这是一个雄心勃勃的工具，它解决了导入问题，将您可能有的第三方依赖项映射到它们的NPM包，为Node.js中没有的Deno或特定于web的API添加了垫片，等等。</p><p id="d171" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在实践中，您可以从Deno工具中获得一个单一的TypeScript(和/或JavaScript)代码库，然后可以轻松地将其分发给浏览器和NPM。它只需要一个使用<code class="fe mb mc md me b">dnt</code>的小构建脚本，如果您也想自动发布到NPM，可能还需要您的CI脚本中的几行额外代码。</p><p id="169c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还应该提到的是，在撰写本文时，Deno团队正忙于改进与现有Node.js包的兼容性，以便Deno可以无缝地使用那些依赖于特定于节点的API的包。同构NPM包已经通过cdn广泛使用，如esm.sh、Skypack等。</p><h1 id="2cb6" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">约定</h1><p id="0527" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">Deno中有一些常见的实践，在编写库或简单地浏览生态系统时，您可能会发现这些实践很有帮助。Deno并不强制执行这些规则，它们最多被认为是约定，您可以随意丢弃其中的任何一个或全部:</p><ul class=""><li id="0253" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">Deno库的主入口点通常称为<code class="fe mb mc md me b">mod.ts</code>，而<code class="fe mb mc md me b">index.ts</code>则留给应用程序。</li><li id="1840" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">第三方依赖项被收集到一个名为<code class="fe mb mc md me b">deps.ts</code>或<code class="fe mb mc md me b">dev_deps.ts</code>的文件中，用于开发人员专用的依赖项。这种方式可以集中更新版本，就像在NPM的<code class="fe mb mc md me b">package.json</code>一样。</li><li id="0394" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">snake_case用于文件名，测试文件以<code class="fe mb mc md me b">_test.ts</code>结尾。</li><li id="2e8a" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">库的文件夹结构是扁平的，大多数导出的文件位于主文件夹和嵌套文件夹中，用于支持和辅助元素，如用于API文档的<code class="fe mb mc md me b">docs</code>，用于用法示例的<code class="fe mb mc md me b">examples</code>等。由于Deno使用URL进行导入，因此您的依赖项的导入路径会更短。</li></ul></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="c7ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，我在Deno中移植和维护库的经验比以前的工具链有了很大的改进。事情并不总是美好的:在VSCode中的调试偶尔会中断，在测试API被彻底检查时，覆盖范围一度不精确，导入一些特定于节点的库仍然很棘手。然而，当某个东西坏了，很容易找到原因，或者至少是归咎于谁。而对于我们通常收集的Node.js工具，这通常会变成对十几个存储库的徒劳追逐。Deno团队也积极响应并修复和改进平台。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="dd75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[<strong class="ka ir">1</strong>]:<a class="ae kw" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank">Deno——JavaScript和类型脚本的现代运行时</a></p><p id="1563" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[ <strong class="ka ir"> 2 </strong> ]: <a class="ae kw" href="https://github.com/zandaqo/structurae" rel="noopener ugc nofollow" target="_blank">结构化:高性能JavaScript应用程序的数据结构。</a></p><p id="8b63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【<strong class="ka ir">3</strong>】:<a class="ae kw" href="https://github.com/zandaqo/compago" rel="noopener ugc nofollow" target="_blank">compago:现代web应用的极简框架。</a></p><p id="20e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[<strong class="ka ir">4</strong>:<a class="ae kw" href="https://github.com/zandaqo/objectid64" rel="noopener ugc nofollow" target="_blank">object 64:将MongoDB ObjectIDs转换成URL友好的base64。</a></p><p id="2b96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[<strong class="ka ir">5</strong>:<a class="ae kw" href="https://github.com/denoland/deno_std" rel="noopener ugc nofollow" target="_blank">Deno标准库</a></p><p id="edc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[ <strong class="ka ir"> 6 </strong> ]: <a class="ae kw" href="https://github.com/denoland/deno_lint" rel="noopener ugc nofollow" target="_blank"> deno_lint:用Rust编写的JavaScript和打字稿的高速linter</a></p><p id="98c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【<strong class="ka ir">7</strong>】:<a class="ae kw" href="https://github.com/dprint/dprint" rel="noopener ugc nofollow" target="_blank">d print:用Rust编写的可插拔、可配置的代码格式化平台。</a></p><p id="7286" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[<strong class="ka ir">8</strong>:<a class="ae kw" href="https://github.com/swc-project/swc" rel="noopener ugc nofollow" target="_blank">SWC:基于Rust的Web平台</a></p><p id="4997" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[<strong class="ka ir">9</strong>:<a class="ae kw" href="https://github.com/microsoft/TypeScript/issues/37582" rel="noopener ugc nofollow" target="_blank">允许自愿。导入路径的ts后缀问题#37582 microsoft/TypeScript </a></p><p id="8391" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[ <strong class="ka ir"> 10 </strong> ]: <a class="ae kw" href="https://github.com/denoland/dnt" rel="noopener ugc nofollow" target="_blank"> dnt: Deno到npm包构建工具。</a></p><p id="aa61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[<strong class="ka ir">11</strong>:<a class="ae kw" href="https://github.com/denoland/deno/issues/12577" rel="noopener ugc nofollow" target="_blank">改善节点兼容模式问题#12577 denoland/deno </a></p></div></div>    
</body>
</html>