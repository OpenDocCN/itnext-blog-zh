<html>
<head>
<title>“Mocking is a Code Smell”, without Types.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“嘲讽是一种码味”，没有类型。</h1>
<blockquote>原文：<a href="https://itnext.io/mocking-was-a-code-smell-7f93d8a5d6f2?source=collection_archive---------0-----------------------#2017-11-18">https://itnext.io/mocking-was-a-code-smell-7f93d8a5d6f2?source=collection_archive---------0-----------------------#2017-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn"><p id="039e" class="jo jp iq bd jq jr js jt ju jv jw jx dk translated"><em class="jy">当我们的分解策略失败时，嘲讽是必须的。——</em><a class="ae jz" href="https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a" rel="noopener">埃里克·埃利奥特</a></p></blockquote><figure class="kb kc kd ke kf kg gh gi paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="gh gi ka"><img src="../Images/503808463e3cd50c9614e81f67961df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_xk8HBrdtVr3snK9rZ6Jlg.jpeg"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">来自“如何发现代码味道并不让它变坏，第2部分”</figcaption></figure><p id="79da" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated"><a class="ae jz" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fmocking-was-a-code-smell-7f93d8a5d6f2" rel="noopener ugc nofollow" target="_blank"> <em class="lo">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="f4ce" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">首先你要明白，Javascript中的<strong class="kt ir">嘲讽不是代码味</strong>，因为JS中的嘲讽更类似于真正的DI，而不是“普通语言”中的嘲讽。</p><blockquote class="lp lq lr"><p id="bb42" class="kr ks lo kt b ku kv kw kx ky kz la lb ls ld le lf lt lh li lj lu ll lm ln jx ij bi translated">流行的库，如Proxyquire或mock，只是重新连接内部节点逻辑，并将<code class="fe lv lw lx ly b">require</code>或<code class="fe lv lw lx ly b">import</code>请求重新路由到某个合成文件。</p><p id="a3f5" class="kr ks lo kt b ku kv kw kx ky kz la lb ls ld le lf lt lh li lj lu ll lm ln jx ij bi translated">如果你只是用AMD语法替换“ES6”或CommonJS模块，你将得到“DI”。NodeJS或Webpack是IoC框架。</p></blockquote><p id="8e7f" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">第二，你要明白Javascript中的<strong class="kt ir">嘲讽是一种代码气味</strong>。惊喜！但是，老实说，</p><blockquote class="jn"><p id="0f2f" class="jo jp iq bd jq jr lz ma mb mc md jx dk translated">当你嘲笑你的测试时，你是在测试你的模仿。不是真正的代码。</p></blockquote><p id="1353" class="pw-post-body-paragraph kr ks iq kt b ku me kw kx ky mf la lb lc mg le lf lg mh li lj lk mi lm ln jx ij bi translated">比如—TS界有一个通用的tslint规则—“<a class="ae jz" href="https://palantir.github.io/tslint/rules/no-default-export/" rel="noopener ugc nofollow" target="_blank">无默认导出</a>”。默认导出是一种“代码味道”,因为您可以更改模块的内部，而外部用户对此一无所知。我不知道你们内部的烹饪。</p><p id="29b1" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">无论如何，如果你改变你的模拟依赖关系，你的生产<strong class="kt ir">代码会破坏</strong>，但是你的<strong class="kt ir">测试不会破坏</strong>！他们没有使用真正的依赖和真正的API。测试是(快乐的)自己生活。</p><figure class="mk ml mm mn gt kg gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/61e81ffc0fca47ec35bf4a1c9b2621e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*bWydmH0sXFyO5bWIbTu_0w.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">当测试是绿色的，但是prod被淹没…</figcaption></figure><h1 id="2deb" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">对测试的信心？</h1><p id="f599" class="pw-post-body-paragraph kr ks iq kt b ku nm kw kx ky nn la lb lc no le lf lg np li lj lk nq lm ln jx ij bi translated">第一层信心是关于正确的模拟名称——然后你就可以确定你确实需要你要模拟的文件，并且你最终模拟了它。不像在声音中那样简单，尤其是对于proxyquire。</p><p id="fc47" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">第二层信心是关于具体化一个文件的已知依赖关系。如果目标文件获得或失去依赖性，您应该知道。Proxyquire毫无价值，但是嘲弄可以提供一些(小)支持。</p><p id="4218" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">第三层信心是正确地模仿真实文件。提供一个正确的模拟，这将正确覆盖真正的出口。</p><p id="4920" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">让我们想象下面的代码:</p><pre class="mk ml mm mn gt nr ly ns nt aw nu bi"><span id="375c" class="nv mp iq ly b gy nw nx l ny nz">// a.js<br/>import MainAction, { helper } from './b.js';<br/>export default () =&gt; MainAction(helper(42));</span><span id="7dcc" class="nv mp iq ly b gy oa nx l ny nz">// b.js<br/>export const helper = (a) =&gt; a * 2;<br/>export default b =&gt; SuperNetworkCall(b); // should be mocked</span></pre><p id="851e" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">接下来，你有一个测试，完全模仿b.js，一切都很棒……接下来——你改变b.js，使其更加一致..</p><pre class="mk ml mm mn gt nr ly ns nt aw nu bi"><span id="a582" class="nv mp iq ly b gy nw nx l ny nz">export const helper = (a) =&gt; a * 2;<br/>export const action = b =&gt; SuperNetworkCall(b);</span></pre><p id="8e8e" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated"><strong class="kt ir">测试是绿色的。房地产是红色的。生产已死。很难理解和解决根本问题，因为没有人会帮助和指导你。有一天<strong class="kt ir">我</strong>刚<strong class="kt ir">改名</strong>一个叫出口<strong class="kt ir">花了一个小时</strong>才明白为什么我的存根<em class="lo">不叫</em>。</strong></p><blockquote class="lp lq lr"><p id="cc94" class="kr ks lo kt b ku kv kw kx ky kz la lb ls ld le lf lt lh li lj lu ll lm ln jx ij bi translated">这就是我做这一切的原因。只是为了减轻我自己的生活。</p></blockquote><p id="e903" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">静态类型检查可以解决所有的问题。并消除javascript模仿的味道。</p><h1 id="c2de" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">类型来拯救！</h1><p id="fbe1" class="pw-post-body-paragraph kr ks iq kt b ku nm kw kx ky nn la lb lc no le lf lg np li lj lk nq lm ln jx ij bi translated">如果使用严格的类型检查(TypeScript和Flow ),就不会发生这种情况。甚至更多——实际上，您可以仅在测试中使用TypeScript或Flow，如果您遇到问题，可以在全局范围内使用它们。</p><p id="32e2" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">但是——没有办法对模拟进行类型检查。模拟的标准接口做不到这一点。没有办法“得到”你应该匹配的类型。</p><p id="ad30" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">Rewiremock v3引入了一个新的API</p><pre class="mk ml mm mn gt nr ly ns nt aw nu bi"><span id="06a9" class="nv mp iq ly b gy nw nx l ny nz">// common API<br/>rewiremock('./b.js').withDefault(overrideDefault).with({ helper:2});</span><span id="6257" class="nv mp iq ly b gy oa nx l ny nz">// new async API<br/>rewiremock(() =&gt; import('./b.js')).withDefault(overrideDefault)...</span></pre><p id="3afc" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">使用imports启动魔法:<code class="fe lv lw lx ly b">mock</code>现在不是一个字符串，而是一个实际的模块——系统可以访问模块的出口类型。</p><p id="17de" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">不幸的是，旧的不能工作，你必须使用导入，并且你必须在导入和模拟声明之间有一个“链接”,所以“简单”的结构像…</p><pre class="mk ml mm mn gt nr ly ns nt aw nu bi"><span id="0a6c" class="nv mp iq ly b gy nw nx l ny nz">const mocked = rewiremock.proxy('fileName.js',{<br/>   'dep1.js': { override: "me" }<br/> });</span></pre><p id="203c" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">…不适合。只有“mock-like”(rewiremock的原生语法)可以工作。但是使用真正的导入完全解决了名称解析问题。</p><h1 id="898b" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">开拍！</h1><p id="8fb6" class="pw-post-body-paragraph kr ks iq kt b ku nm kw kx ky nn la lb lc no le lf lg np li lj lk nq lm ln jx ij bi translated">给定一个代码:</p><pre class="mk ml mm mn gt nr ly ns nt aw nu bi"><span id="5d84" class="nv mp iq ly b gy nw nx l ny nz">rewiremock(() =&gt; require('./b.js'))<br/>  .withDefault(overrideDefault)</span><span id="725a" class="nv mp iq ly b gy oa nx l ny nz">// or</span><span id="0ee3" class="nv mp iq ly b gy oa nx l ny nz">rewiremock(() =&gt; import('./b.js'))<br/>  .withDefault(overrideDefault)</span></pre><p id="bcf6" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">因此，在您将<code class="fe lv lw lx ly b">default export</code>从<code class="fe lv lw lx ly b">b.js</code>中移除后，您将得到一个异常:</p><pre class="mk ml mm mn gt nr ly ns nt aw nu bi"><span id="0dfb" class="nv mp iq ly b gy nw nx l ny nz">TypeScript<br/>error TS2339: Property 'withDefault' does not exist on type 'NamedModuleMock&lt;typeof "b.js"&gt;'.</span><span id="b044" class="nv mp iq ly b gy oa nx l ny nz">FLOW: <br/>withDefault(fn: $PropertyType&lt;$Exact&lt;T&gt;, 'default'&gt;)<br/>Property not found in () =&gt; import('./b.js')<br/>                  ^^^^^^^^^^^^^^^ exports of "./b.js".</span></pre><p id="b6e8" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">TypeScript支持是完美的。withDefault只是在没有默认导出的情况下不存在。但是Flow远不如sound(而long Flow作为type system是_more_ sound)，而且不容易理解错误消息。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="0ca0" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">具名出口的情况更好。</p><p id="17e1" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">给定一个代码</p><pre class="mk ml mm mn gt nr ly ns nt aw nu bi"><span id="701f" class="nv mp iq ly b gy nw nx l ny nz">rewiremock(() =&gt; require('./b.js'))<br/>  .with({<br/>    halper: 'help!',<br/>  })</span></pre><p id="3942" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">我在这里打了个错别字(你在这篇文章里发现了几个错别字？)—两种类型的系统都会清楚地报告。</p><pre class="mk ml mm mn gt nr ly ns nt aw nu bi"><span id="1a64" class="nv mp iq ly b gy nw nx l ny nz">TypeScript:<br/>Object literal may only specify known properties, and 'halper' does not exist in type '{ readonly helper.... }'.</span><span id="49f2" class="nv mp iq ly b gy oa nx l ny nz">Flow:<br/>.with({halper: () =&gt; 10});<br/>       ^^ property `halper` of object literal. Property not found...</span></pre><p id="32aa" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">如果你用一个数字模拟函数，或者用对象类型模拟数字，系统将抛出。换句话说，如果你做错了什么，它会一直通知你。</p><p id="f0ff" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">“只是类型”呢？</p><pre class="mk ml mm mn gt nr ly ns nt aw nu bi"><span id="3584" class="nv mp iq ly b gy nw nx l ny nz">const file = rewiremock.proxy('a.js'); // 👎 not typed. How it can be?</span><span id="f3ea" class="nv mp iq ly b gy oa nx l ny nz">// using .proxy helper</span><span id="c177" class="nv mp iq ly b gy oa nx l ny nz">const file = rewiremock.proxy(() =&gt; require('a.js')); // 👍</span><span id="064f" class="nv mp iq ly b gy oa nx l ny nz">// using plain require</span><span id="b0d4" class="nv mp iq ly b gy oa nx l ny nz">rewiremock.enable();<br/>const file = require('a.js'); // 👍, sure - that's require</span><span id="c6b2" class="nv mp iq ly b gy oa nx l ny nz">const file = await import('a.js'); // 👍, sure - that's import<br/>// 😉 ^ thats ESM compatible</span></pre><h1 id="a97a" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">类型..类型…</h1><p id="f4fe" class="pw-post-body-paragraph kr ks iq kt b ku nm kw kx ky nn la lb lc no le lf lg np li lj lk nq lm ln jx ij bi translated">花了两个月的时间重新发明轮子，并理解如何提供一个类型安全的模拟。创建TypeScript d.ts定义花了一个小时，创建Flow variant花了将近一个星期。启用rewiremock摘要函数作为模拟名称需要几分钟时间。</p><p id="a32f" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">没错。这里的关键点是，所有的魔法都在外面。在d.ts或index.js.flow文件中。向TS和流量创造者致敬。向TS和流程维护者致敬。如果你正在嘲笑你的TS或Flow应用程序中的依赖关系——恭喜你，让我们最终让javascript嘲笑伟大的aga……</p><h1 id="4e8b" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">结论:</h1><p id="b56f" class="pw-post-body-paragraph kr ks iq kt b ku nm kw kx ky nn la lb lc no le lf lg np li lj lk nq lm ln jx ij bi translated">Rewiremock，我为<code class="fe lv lw lx ly b">fix</code>构建的嘲讽库，嘲讽现在已经到了v3。</p><p id="bb5d" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">这是一个混合的Proxyquire，嘲弄，和所有“可以做得更好”我曾经发现。它可以模仿任何东西，提供隔离模式，不仅可以帮助你模仿node.js，还可以模仿webpack decencies，现在它获得了类型安全。</p><div class="oi oj gp gr ok ol"><a href="https://github.com/theKashey/rewiremock" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">theKashey/rewiremock</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">rewiremock——在Node.js或webpack环境中模拟依赖关系的正确方法。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kl ol"/></div></div></a></div><p id="b1be" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">阅读更多关于rewiremock如何工作以及为什么工作的信息</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/tag/rewiremock/latest" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">关于Rewiremock - Medium的最新故事和新闻</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">阅读关于Rewiremock的最新文章。每天，成千上万的声音在阅读、写作和分享重要的故事…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz kl ol"/></div></div></a></div><p id="0327" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">对于JS，ES或者TS来说是最好的嘲讽库，我还是很确定的。</p><h1 id="4496" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">那么他们现在闻起来怎么样？</h1><p id="a5a4" class="pw-post-body-paragraph kr ks iq kt b ku nm kw kx ky nn la lb lc no le lf lg np li lj lk nq lm ln jx ij bi translated">首先，请阅读关于仿制品气味的文章。请记住，好的代码不是没有模仿的代码，这一点在文章中已经指出。</p><p id="7f24" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">它们相互垂直。有能力静态分析你的代码-是一个加分。有能力跳到实现(需要隐式(紧密)声明)——是一个加号。</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">嘲讽是一种代码气味</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">注意:这是学习函数式编程和组合软件的“组合软件”系列的一部分…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz kl ol"/></div></div></a></div><p id="a859" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">但是拙劣的模仿会毁掉一切。普通的嘲笑会毁掉一切。Javascript模仿太假了。太假了。</p><h1 id="60c3" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">PS: Jest</h1><p id="dee6" class="pw-post-body-paragraph kr ks iq kt b ku nm kw kx ky nn la lb lc no le lf lg np li lj lk nq lm ln jx ij bi translated">Jest是一个非常受欢迎的任务运行者，它有自己的模拟系统，包括手动、魔法和自动锁定。</p><p id="190d" class="pw-post-body-paragraph kr ks iq kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln jx ij bi translated">Rewiremock仍然可以帮助你，但它将只是取代一些Jest的内部，这并不总是可以接受的。为了获得与自动锁定相同的安全类型，即<code class="fe lv lw lx ly b">__mocks__</code>你可以使用。这只是一个很酷的cli工具。</p><div class="oi oj gp gr ok ol"><a href="https://github.com/theKashey/jest-typed-mock" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">Kashey/jest-typed-mock</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">玩笑式的嘲弄式的安全！。并利用TS/Flow的力量让mocks变得更好。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="pc l ow ox oy ou oz kl ol"/></div></div></a></div></div></div>    
</body>
</html>