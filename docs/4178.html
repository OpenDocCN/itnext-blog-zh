<html>
<head>
<title>An AWS Lambda Serverless Journey - Part 2 - A Serverless API (in Java)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda无服务器之旅——第2部分——无服务器API(Java语言)</h1>
<blockquote>原文：<a href="https://itnext.io/an-aws-lambda-serverless-journey-part-2-a-serverless-api-in-java-f713d8b80fc6?source=collection_archive---------4-----------------------#2020-05-11">https://itnext.io/an-aws-lambda-serverless-journey-part-2-a-serverless-api-in-java-f713d8b80fc6?source=collection_archive---------4-----------------------#2020-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/35115e777124c179d7843c6a152bd278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gxz-GjfXj4nzJxU472kvzw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">自动气象站λ</figcaption></figure><div class=""/><p id="fe76" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您还没有阅读本系列的第1部分，我通过回答以下问题提供了“无服务器的简史”<a class="ae la" href="https://medium.com/swlh/an-aws-lambda-serverless-journey-part-1-what-why-and-how-do-i-get-started-7a9f2d60ddbb" rel="noopener">什么，为什么以及如何开始？</a>，给这个部分做一个关卡集，会比较有技术含量一点。害怕非常害怕。开个玩笑，但是，如果你不是技术人员，抱歉，你可能想在下一段后离开。</p><h1 id="3196" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关于无服务器这个词</h1><p id="a15e" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">术语<em class="me">无服务器</em>对于一些技术人员来说有点陌生，因为事实上，在某个地方有一个服务器在运行你的代码。它恰好完全由云提供商管理。您只需设置一些配置，但无需担心配置实例或扩展(进/出)来满足您的使用需求。无论如何，我通常不会纠结于语义，尽管它们在很多情况下很重要，但在这种情况下并不那么重要。我的意思是，你宁愿对你的同事说，“看看这个！我在AWS上构建了这个非常酷的“非自我管理的应用程序”。这就像真的很酷，完全没有自我管理。”呃……是的，我也没有。它是无服务器的。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="240d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如我所承诺的，我将带您浏览一个非常简单(但并非微不足道)的API，它只使用了DynamoDB local、Lambda local和无服务器应用程序模型(SAM)。对于AWS Toolkit for IntelliJ和SAM使用Java进行本地开发的精彩实践介绍，请查看Hiep Dinh的文章以了解您的方位。在我在本系列的第1部分<a class="ae la" href="https://medium.com/swlh/an-aws-lambda-serverless-journey-part-1-what-why-and-how-do-i-get-started-7a9f2d60ddbb" rel="noopener">中概述的安装之后，它就停止了。</a></p><blockquote class="mm mn mo"><p id="7f5b" class="kc kd me ke b kf kg kh ki kj kk kl km mp ko kp kq mq ks kt ku mr kw kx ky kz ij bi translated">在这里，我将重点介绍在本地对API进行基础设施即代码化的SAM模板，重点介绍一些Java代码，以便在完全不使用第三方框架的情况下理解API的结构，在DynamoDB上说几句话，并将简化的SAM template.yaml与其“等效的”CloudFormation基础设施即代码进行比较和对比。这不是一步一步的操作方法。博客圈里有很多这样的人。相反，我将强调我的设计中一些更有趣的部分，从旅程中收集的见解和技巧，以及进一步调查的要点。</p></blockquote><h1 id="4414" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设计</h1><p id="73b0" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">下面的架构图代表了一个管理在线名片夹的API。对于阅读这篇文章的年轻人来说，这只是一个用老人语言写的联系人列表。在使用SAM进行了本地开发，并在云形成(CFN)模板上做了一些额外的工作后，这就是我最终进行设计的地方。你可以看到它是一个完整的无服务器AWS服务的杂烩。别担心，我们将重点关注你在架构图右下方看到的东西，RoldexAPI Lambda函数和DynamoDB。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ms"><img src="../Images/55ef3c21a6dea39ece166b5f39d2ce8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yaBMPMzkM2RffWNeeInGbw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">部署在AWS上的Rolodex API架构</figcaption></figure><p id="6381" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Rolodex API支持以下路线:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/5b624c88b8091f704d0463865817d621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*8UxmuRW6vIj9l9oHzg0LwQ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">招摇过市的联系人路线</figcaption></figure><h1 id="35d0" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">项目结构</h1><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/d423e3c12330801841d512613973efc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZ7pEQS3YGR6foLgRGM2Bw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Rolodex API的Java项目结构+ template.yaml</figcaption></figure><p id="c986" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">AWS无服务器项目只不过是一个Maven项目，增加了一个非常重要的SAM无服务器<em class="me"> template.yaml </em>文件。AWS实验室想出了一个<a class="ae la" href="https://aws.amazon.com/blogs/developer/bootstrapping-a-java-lambda-application-with-minimal-aws-java-sdk-startup-time-using-maven/" rel="noopener ugc nofollow" target="_blank"> maven原型</a>，这是初始化新项目的首选方式。我的RolodexAPI项目包含一个名为LambdaFunction的Java类(它充当API的控制器/调度程序)，几个用于联系和所需网关响应的模型(用于API网关)，以及几个层，包括一个简单的服务层和数据访问层，它利用AWS SDK for DynamoDB进行CRUD操作。</p><p id="1025" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">解剖一个SAM模板</strong></p><p id="8d46" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">SAM模板的文档可以在<a class="ae la" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-specification-resources-and-properties.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到，我鼓励你在继续之前看一看。正如我在本系列的<a class="ae la" href="https://medium.com/swlh/an-aws-lambda-serverless-journey-part-1-what-why-and-how-do-i-get-started-7a9f2d60ddbb'" rel="noopener">第1部分</a>中提到的，SAM是对CloudFormation的抽象，而<em class="me"> Transform </em>(如下所示)告诉CloudFormation在“sam deploy”期间用SAM规范处理这个yaml文件，这是用于将这个基础设施代码推送到AWS云平台的<a class="ae la" href="https://aws.amazon.com/blogs/compute/a-simpler-deployment-experience-with-aws-sam-cli/" rel="noopener ugc nofollow" target="_blank">超级简单sam cli </a>命令。让我们快速浏览一下<em class="me"> template.yaml </em>的<em class="me"> Resources </em>部分中的一些内容。我加粗了感兴趣的项目。<em class="me"> Resources属性</em>指定了您想要创建的基础设施，在本例中是一个名为rolodex-api-function的AWS::Serverless::Function。</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="e687" class="ne lc jf na b gy nf ng l nh ni">AWSTemplateFormatVersion: '2010-09-09'<br/><strong class="na jg">Transform: AWS::Serverless-2016-10-31</strong><br/>Description: SAM Template for Rolodex API<br/><br/><strong class="na jg">Resources:</strong><br/>  <strong class="na jg">RolodexAPIFunction:</strong><br/>    <strong class="na jg">Type: AWS::Serverless::Function</strong><br/>    Properties:<br/>      <strong class="na jg">FunctionName: rolodex-api-function</strong><br/>      CodeUri: RolodexAPIFunction<br/>      <strong class="na jg">Handler: com.mittcs.LambdaFunction::handleRequest</strong><br/>      Runtime: java8<br/>      MemorySize: 1024<br/><strong class="na jg">      Events:<br/>        RolodexGetAllContacts:<br/>          Type: Api<br/>          Properties:<br/>            Path: /rolodex/{owner_email}/contacts<br/>            Method: get</strong><br/>         </span></pre><p id="84c3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该SAM模板指定:</p><ol class=""><li id="7895" class="nj nk jf ke b kf kg kj kk kn nl kr nm kv nn kz no np nq nr bi translated">一个Lambda函数(参见<em class="me">型</em>中上面的<em class="me"> yaml </em></li><li id="d3c1" class="nj nk jf ke b kf ns kj nt kn nu kr nv kv nw kz no np nq nr bi translated">API Gateway中的API(通过<em class="me"> Events </em>属性和RolodexGetAllContacts事件)隐式创建)</li><li id="c03a" class="nj nk jf ke b kf ns kj nt kn nu kr nv kv nw kz no np nq nr bi translated">Contacts API中的一条路由，由<em class="me"> </em> Api事件的<em class="me"> Path </em>属性中的“/Rolodex/{ owner _ email }/Contacts”定义。</li></ol><p id="8331" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Lambda在一个<em class="me">事件</em>驱动的模型上工作。在这种情况下，事件是与(隐式创建的)API网关资源的交互，API网关资源使用GET Http方法托管路由“/Rolodex/{ owner _ email }/contacts”。<em class="me">处理程序</em>是当您在浏览器中或通过Postman ping端点时Lambda将调用的实际代码，交付给代码的<em class="me">输入</em>或<em class="me">有效负载</em>将属于<em class="me">类型</em> Api(事件)。</p><p id="8e2c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您想将另一个路由添加到API以由函数处理，只需在函数的<em class="me"> Events </em>属性下添加另一个事件，如RolodexGetSingleContact中所示。它使用pathParameter 'conact_full_name '指定单个联系人的检索。</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="58c6" class="ne lc jf na b gy nf ng l nh ni">RolodexGetSingleContact:<br/>  Type: Api<br/>  Properties:<br/>    Path: /rolodex/{owner_email}/contacts/{contact_full_name}<br/>    Method: get</span></pre><p id="3066" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">API Gateway生成的<em class="me">事件</em>看起来有点像这样(作为地图的字符串表示)。</p><p id="b9d5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">{ <strong class="ke jg"> httpMethod </strong> =GET，<strong class="ke jg"> body </strong> =null，<strong class="ke jg">path</strong>=/Rolodex/{ owner _ email }/contacts，<strong class="ke jg">query string parameters</strong>= null，<strong class="ke jg">path parameters</strong>= { owner _ email = mitulipatel @ Gmail . com }，<strong class="ke jg"> stageVariables </strong> =null，<strong class="ke jg">is base 64 encoded</strong>= false }</p><p id="77b3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我已经为你消除了很多噪音。使用上面图中显示的几个项目，我们可以开始使用Java构建API。</p><h1 id="35bd" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">请求处理程序代码</h1><p id="6712" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">下面的代码概述了一种避免像Spring这样的第三方框架的方法。这是普通的ole Java和AWS Lambda提供的东西(比如上下文对象)。</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">LambdaFunction.java</figcaption></figure><p id="abf6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我实现了函数的RequestHandler作为所有'/contacts '路由的控制器/调度器。我不认为这过于复杂，对于你的API的重点部分来说，这很好。如果API中有要由该函数处理的路由，而不是'/contacts '，例如'/companies '，那么您需要利用API事件中的<em class="me"> path </em>参数。然后，您可以在代码中使用path来分派/路由到正确的<em class="me"> httpMethod </em>处理程序，否则这里实现的“浅层开关”就足够了。</p><blockquote class="nz"><p id="a5aa" class="oa ob jf bd oc od oe of og oh oi kz dk translated">你为什么想要自己的控制器/调度员呢？</p></blockquote><p id="50d9" class="pw-post-body-paragraph kc kd jf ke b kf oj kh ki kj ok kl km kn ol kp kq kr om kt ku kv on kx ky kz ij bi translated">可能是因为性能的原因。在本系列的第4部分中，我将使用<a class="ae la" href="https://github.com/awslabs/aws-serverless-java-container" rel="noopener ugc nofollow" target="_blank"> Spring Framework </a>重新分解这个无服务器API，然后做一些性能基准测试，看看是否有什么不同。我的直觉告诉我会有的(有时我的直觉告诉我也去吃，那样很棒)。AWS实验室<a class="ae la" href="https://aws.amazon.com/blogs/opensource/java-apis-aws-lambda/" rel="noopener ugc nofollow" target="_blank">表示</a>弹簧的组件扫描和其他因素可能会降低启动性能。显然，从开发的角度来看，开发自己的产品效率低下，而且你不能获得像Spring这样的框架给你带来的所有好处，但是出于性能原因，简单性<em class="me">可能</em>会称雄。目前这纯粹是猜测。然而，当我有疑问时，我会回到脑海中的那个声音，“保持简单，愚蠢。”这通常会阻止我在为YouTube制作的电影“一个过度工程的奇怪案例”中扮演主角。</p><h1 id="a51f" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">DynamoDB</h1><p id="8c86" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">剩下的唯一一块拼图就是前面提到的。DynamoDB是AWS对MongoDB和Cassandra的无服务器NoSQL版。AWS通过提供<a class="ae la" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html" rel="noopener ugc nofollow" target="_blank">几种在本地使用的方法</a>，让入门变得超级容易。其中最简单的是下载一个运行在端口8000上的可执行jar，但是您也可以轻松地下载并运行一个docker容器来托管您的本地DynamoDB。</p><p id="ad10" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，如果您通过可执行jar在您的主机上运行DynamoDB，您将需要在您的主机文件中使用一点魔法，因为SAM在Docker容器中运行您的Lambda代码，也就是说，您将遇到一些名称解析问题。我刚帮你省了一个小时的故障排除时间。不过，不需要感谢。开玩笑，你最好为这个帖子鼓掌，否则。</p><p id="b390" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面描述的相当简单的CFN yaml块表示联系人表。</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="ee34" class="ne lc jf na b gy nf ng l nh ni">ContactsTable:<br/>  Type: AWS::DynamoDB::Table<br/>  Properties:<br/>    TableName: !Join [ '', [ 'Contacts-', !Ref Stage] ]<br/>    AttributeDefinitions:<br/>      - AttributeName: owner_email<br/>        AttributeType: S<br/>      - AttributeName: contact_full_name<br/>        AttributeType: S<br/>    KeySchema:<br/>      - AttributeName: owner_email<br/>        KeyType: HASH<br/>      - AttributeName: contact_full_name<br/>        KeyType: RANGE<br/>    ProvisionedThroughput:<br/>      ReadCapacityUnits: 5<br/>      WriteCapacityUnits: 5</span></pre><p id="660f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我编写了CFN模板来支持创建代表不同环境的不同堆栈(使用名为Stage的模板变量，参见！上述CFN块中的Ref级)。无服务器环境设置是一个重要的面向DevOps的讨论，也不是没有争议，因为有几种方法可以利用Lambda环境变量和/或API网关阶段变量实现多个环境。Sergio Garcez关于这个话题的精彩讨论可以在<a class="ae la" href="https://medium.com/@sgarcez/managing-multi-environment-serverless-architecture-using-aws-an-investigation-6cd6501d261e" rel="noopener">这里</a>找到。如前所述，我选择每个环境有一个表。有了更高级别的DynamoDB Java API，以及像<em class="me"> DynamoDBMapper </em>和<em class="me"> DynamoDBMapperConfig、</em>这样的类，即使像“Contacts”这样的pojo用默认表名进行了注释，在给定环境中动态覆盖要使用的表也是一个相对容易的过程。我已经分享了Contact Dao的实现，所以你可以看到这是如何实现的。</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">ContactDaoImpl.java</figcaption></figure><p id="3a78" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">DynamoDB Java SDK 上的AWS文档非常好，可以很好地帮助您入门。</p><blockquote class="mm mn mo"><p id="94f5" class="kc kd me ke b kf kg kh ki kj kk kl km mp ko kp kq mq ks kt ku mr kw kx ky kz ij bi translated">总的来说，我发现大多数AWS文档都写得很好，组织得很好。您可能会遇到过时的文档，因为一些服务正在以极快的速度发展，但这种情况非常罕见。</p></blockquote><p id="c30c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为你的应用程序做好NoSQL表设计超出了这篇文章的范围，所以我保持这个实现非常简单。NoSQL的使用都与“访问模式”有关，即应用程序需要执行的查询类型。联系人表利用称为“所有者_电子邮件”的字符串类型的散列关键字和称为“联系人_全名”的字符串类型的排序关键字。这对于这个API的访问模式来说已经足够了。首先，将maven依赖项放入pom.xml，如下所示。然后，您需要做的就是使用DynamoDB SDK的<a class="ae la" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.Annotations.html" rel="noopener ugc nofollow" target="_blank">注释类</a>向Contacts pojo添加注释。</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="9e28" class="ne lc jf na b gy nf ng l nh ni">&lt;dependency&gt;<br/>    &lt;groupId&gt;com.amazonaws&lt;/groupId&gt;<br/>    &lt;artifactId&gt;aws-java-sdk-dynamodb&lt;/artifactId&gt;<br/>    &lt;version&gt;1.11.743&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="24f5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注释的模型和类<em class="me"> DynamoDBMapper </em>是你执行CRUD操作所需要的，如上面的<em class="me">ContactDaoImpl.java</em>的GitHub要点所示。这个过程与您可能在Spring Data JPA或您选择的ORM中看到的没有什么不同。</p><h1 id="d8ab" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">比较SAM I-a-C和CloudFormation I-a-C</h1><p id="f7db" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">几张图胜过千言万语。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/87b8c38d36eb28434cec445dc3192c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZA8tzS52IL2YuWmD6bMwZQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">API路径“/Rolodex/{ owner _ email }/contacts”的SAM I-a-C</figcaption></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi op"><img src="../Images/68c7764c311e9a21d14e9eb59398c510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J10gGWzJ2_Hloa8DyJiNjw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">API路径'/Rolodex/{ owner _ email }/contacts '的CFN I-a-C</figcaption></figure><p id="b462" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如你所看到的，在CloudFormation中简单地指定“/Rolodex/{ owner _ email }/contacts”的API路径很快就变得很严重。您必须指定3个<em class="me">AWS::API gateway::Resource</em>块(对于路径的每个部分，即<em class="me"> PathPart </em>，确保<em class="me"> ParentId </em>设置正确，以及一个<em class="me"> AWS::ApiGateway::Method </em>块来获得您想要的东西，这还不包括这里没有显示的许多其他CFN块。作为一名开发人员，您可能会通过“sam deploy”来部署您的代码，看看它是否能在AWS上按预期工作。然而，可能需要具有更细粒度控制的更复杂的部署，这时您将转向CloudFormation提供的细粒度访问。在本系列的第4部分中，我将讨论使用这个参数化的CFN和Code*系列服务来自动化这个API的构建和部署的开发运维。</p><h1 id="6b6b" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最后</h1><p id="dc22" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我还可以对更多的细节发表意见，但我开始让自己带着刚刚排放到周围空气中的所有二氧化碳入睡(你为什么不阻止我？).相反，我会给你一个展示我劳动成果的截图。这个无服务器API的惊人之处在于它是超级可扩展的(当然是收费的，但是你每月可以从AWS免费调用100万次Lambda函数),而且真的不需要任何操作人员来管理它！掌握如此巨大的权力让人感觉自己像是乔雷尔的儿子，但以一种更书呆子气的方式。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oq"><img src="../Images/a0b915552e9cf095a4088835d622b653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqiQa-WSyv6ehhtdI08_8w.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">使用认证头到达https://api.mittcs.com/rolodex/{owner_email}/contacts</figcaption></figure><p id="c7bf" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望你觉得这个超级有用。在本系列的下一期文章中，我将测试我最新的AWS认证，同时自动化这个无服务器API从提交到部署的开发过程。我希望你保持关注。</p><p id="749a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">直到下次朋友们，</p><p id="4a9b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">米图尔</p></div></div>    
</body>
</html>