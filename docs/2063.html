<html>
<head>
<title>Docker in Software Development: expanding horizons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件开发中的Docker:扩展视野</h1>
<blockquote>原文：<a href="https://itnext.io/docker-in-software-development-expanding-horizons-7b500d758f0?source=collection_archive---------5-----------------------#2019-03-25">https://itnext.io/docker-in-software-development-expanding-horizons-7b500d758f0?source=collection_archive---------5-----------------------#2019-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0e70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有大量的文章和博客文章解释了在软件开发生命周期中使用Docker的好处和方法。他们中的许多人也解释了如何在开发过程中使用Docker。然而，他们中的大多数人都认为在他们的本地环境中运行着Docker CE或Docker桌面。</p><p id="9430" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在某些情况下，将Docker Desktop安装到一个人的环境中在物理上是不可能的，或者不会有所帮助。例如，如果您的开发环境运行不受支持的Windows版本。或者您的公司使用在云中运行的虚拟Windows桌面或作为WMWare虚拟机。</p><p id="1b1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第一种情况下，有一个使用Docker工具箱的选项，但是第二种情况几乎没有变通的余地:根据我的经验，在虚拟化的Windows实例上运行Docker非常慢。它最终可能会起作用，但这种经历令人沮丧。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="956b" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">有什么选择吗？</h1><p id="9e9d" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">在非Linux环境的幕后，Docker使用一个Linux VM。因此，在上面描述的场景中，自然的选择是一个独立的Linux VM，Docker CE在其中运行，不会有任何性能下降。</p><p id="7329" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它可以是本地虚拟机或基于云的虚拟机，也可以是运行Linux操作系统的独立硬件，无论您需要做的是什么:</p><ul class=""><li id="7551" class="ly lz it js b jt ju jx jy kb ma kf mb kj mc kn md me mf mg bi translated">在虚拟机或硬件套件上安装Linux操作系统</li><li id="bac4" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated">在Linux实例上安装Docker CE</li><li id="e511" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated">启用对运行在Linux实例上的Docker守护进程的远程访问(可选)</li></ul></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="cea3" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">设置Docker实例</h1><p id="d784" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">按照<a class="ae mm" href="https://docs.docker.com/install/linux/docker-ce/centos/" rel="noopener ugc nofollow" target="_blank"> Docker文档</a>安装Docker CE。该链接描述了CentOS的安装过程。如果您使用不同的Linux发行版，请在左侧面板中选择您想要的版本。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/a6f28bd8ab68334198f95c2ba48b71bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*dHHdqfGqDzqQmhWna3IHqw.png"/></div></figure><p id="da95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦确认Docker在Linux实例上运行，就可以直接用于开发。</p><p id="21a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个过程比预期的要稍微麻烦一些。本质上，我们必须在Windows端构建生成Docker映像所需的软件工件，然后在Linux实例上复制它们，并在Linux实例上再次运行<code class="fe mv mw mx my b">docker build</code>命令。</p><p id="5a55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者，我们可以将源代码推送到Linux实例，并在那里构建工件和Docker映像。</p><p id="574a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论如何，一旦在Linux实例上构建了映像，就可以用它来启动容器。确保映像提供了远程调试应用程序的方法。这些技术依赖于用来开发相关应用程序的编程语言，但是现在大多数现代语言都允许远程调试。</p><p id="5d39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，根据开发过程中使用的语言，构建工具可能会提供远程构建映像的方法。要使用这种方法，我们必须启用对Docker守护进程的远程访问。</p><h1 id="ad1c" class="kv kw it bd kx ky mz la lb lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls bi translated">启用Docker远程访问</h1><p id="5148" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">默认情况下，Docker只监听本地unix套接字，因此它只能被本地访问。为了能够远程访问Docker，必须将其配置为监听TCP套接字。</p><p id="84b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，一旦TCP套接字侦听器被启用，任何人都可以不受限制地访问它，因此任何人都可以完全控制您的Docker实例。</p><p id="23a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了防止对Docker实例的未授权访问，我们还必须通过启用TLS验证来保护Docker守护进程套接字。</p><p id="783c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，遵循<a class="ae mm" href="https://docs.docker.com/install/linux/linux-postinstall/#configuring-remote-access-with-systemd-unit-file" rel="noopener ugc nofollow" target="_blank">本指南</a>使用systemd单元文件启用远程访问，或者<a class="ae mm" href="https://docs.docker.com/install/linux/linux-postinstall/#configuring-remote-access-with-daemonjson" rel="noopener ugc nofollow" target="_blank">遵循</a>指南使用daemon.json文件启用远程访问。</p><p id="ba39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，按照下一篇文章中描述的<a class="ae mm" href="https://docs.docker.com/engine/security/https/" rel="noopener ugc nofollow" target="_blank">保护守护进程套接字。</a></p><p id="df84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于配置远程访问的一个注意事项:文档说明dockerd命令行选项应该如下所示:</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9d27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，看起来文档已经过时了。“fd://”选项至少在CentOS 7上不再有效。</p><p id="a3a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于最新的Docker CE，您必须使用“unix://”套接字选项来代替:</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5e70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为Windows实例没有安装Docker客户端，所以您必须在Linux实例上运行<code class="fe mv mw mx my b">docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem \<br/> -H=&lt;host&gt;:2376 version</code>来验证Docker守护进程的设置。确认后，将客户端私钥和证书以及可信CA证书复制到Windows实例，并安全地存储它们。确保所有三个文件都存储在同一位置，并且它们的名称是ca.pem、cert.pem和key.pem。</p><h1 id="0a9c" class="kv kw it bd kx ky mz la lb lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls bi translated">使用远程Docker守护进程进行开发</h1><p id="ac9b" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">在开发过程中，可以通过多种方式使用远程Docker守护进程。通常，我们运行构建的应用程序来测试或调试它们。远程运行Docker的方式取决于项目中使用的语言。</p><p id="bb79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在某些情况下，除了将工件复制到远程系统并在Linux shell中直接调用docker命令之外，没有其他方法可以将应用程序构建和部署到远程Docker实例。</p><p id="c172" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，在某些情况下，有一些工具和插件可以帮助你。</p><p id="41e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果你用Java或Kotlin开发，有gradle和maven插件允许你远程构建图像。</p><p id="9062" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何使用gradle来实现这一点。出于这个例子的目的，我们将使用<a class="ae mm" href="https://github.com/bmuschko/gradle-docker-plugin/" rel="noopener ugc nofollow" target="_blank"> gradle-docker-plugin </a>。</p><p id="93b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在修改项目的build.gradle文件之前，向<code class="fe mv mw mx my b">%HOMEPATH%\.gradle\gradle.properties</code>文件添加两个变量:</p><pre class="mo mp mq mr gt ng my nh ni aw nj bi"><span id="9654" class="nk kw it my b gy nl nm l nn no">dockerUrl=https://&lt;linux_host_name&gt;:2376</span><span id="f741" class="nk kw it my b gy np nm l nn no">dockerKeysDir=&lt;path_to_certs&gt;</span></pre><p id="3b6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理论上，它们可以被添加到项目的build.gradle或gradle.properties文件中，但这将使项目与特定环境紧密耦合，因此不修改源代码就不容易在其他地方构建代码。</p><p id="652b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确保<code class="fe mv mw mx my b">&lt;linux_host_name&gt;</code>对应于用于创建服务器端证书的服务器名称。如果它们不匹配，TLS验证将失败。</p><p id="446a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mv mw mx my b">&lt;path_to_certs&gt;</code>应该替换为我们保存*的目录的路径。pem文件，从Linux实例复制。</p><p id="d78c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，将<code class="fe mv mw mx my b">com.bmuschko.docker-remote-api</code>插件添加到gradle.build文件中。你可以在这里找到如何使用插件的完整说明。</p><pre class="mo mp mq mr gt ng my nh ni aw nj bi"><span id="aef9" class="nk kw it my b gy nl nm l nn no">plugins {    <br/>  id 'java'    <br/>  id 'org.springframework.boot' version '2.1.3.RELEASE'    <br/>  id "io.spring.dependency-management" version "1.0.7.RELEASE"    <br/><strong class="my iu">  id 'com.bmuschko.docker-remote-api' version '4.6.2'<br/></strong>}</span></pre><p id="83e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们必须定义一个将为我们构建Docker映像的新任务:</p><pre class="mo mp mq mr gt ng my nh ni aw nj bi"><span id="6394" class="nk kw it my b gy nl nm l nn no">task buildImage(type: DockerBuildImage) {    <br/>  dependsOn build               // 1<br/>  inputDir = file('.')          // 2<br/>  // dockerFile = file('Dockerfile-dev') // 3<br/>  tags.add(projectName)         // 4<br/>}</span></pre><p id="2d56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是任务所需的最低配置。下面是任务中每个调用的简要说明:</p><ol class=""><li id="cb96" class="ly lz it js b jt ju jx jy kb ma kf mb kj mc kn nq me mf mg bi translated">定义对构建任务的依赖，即构建任务将在构建映像之前调用。</li><li id="02ac" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn nq me mf mg bi translated">指定docker上下文，或docker命令执行的根目录。由于插件将目录的内容传输到远程主机，所以确保<code class="fe mv mw mx my b">inputDir</code>只包含构建映像所需的必要文件是有意义的。该路径相对于项目根目录。</li><li id="7fdd" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn nq me mf mg bi translated">默认情况下，插件将使用<code class="fe mv mw mx my b">Dockerfile</code>文件来构建图像。如果你有多个docker文件，插件会被指示使用另一个。</li><li id="6983" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn nq me mf mg bi translated">指定了新的图像标签。在我们的示例中，它被设置为项目名称，但在这里可以是任何名称，只要它符合图像标记规则。</li></ol><p id="0f9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来，当上述任务在Windows上执行时，由于gradle锁定了其中一个文件而失败。作为一种变通方法，我们必须将docker文件复制到构建目录，并将其用作docker上下文根。这需要创建一个额外的任务:</p><pre class="mo mp mq mr gt ng my nh ni aw nj bi"><span id="e785" class="nk kw it my b gy nl nm l nn no">task copyDockerFile(type: Copy) {    <br/>  dependsOn build    <br/>  from 'Dockerfile'    <br/>  into buildDir<br/>} </span><span id="efe7" class="nk kw it my b gy np nm l nn no">task buildImage(type: DockerBuildImage) {    <br/>  dependsOn copyDockerFile    <br/>  inputDir = buildDir<br/>  tags.add(projectName)<br/>}</span></pre><p id="d913" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们添加了一个任务，将docker文件复制到构建目录，然后使用构建目录作为docker构建的根上下文。</p><p id="829e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，运行以下命令来构建应用程序，并在Linux实例上创建docker映像:</p><pre class="mo mp mq mr gt ng my nh ni aw nj bi"><span id="3da3" class="nk kw it my b gy nl nm l nn no">gradlew clean buildImage</span></pre><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/cec05be04ca7580dc6b24d068716419e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W99zn8nYpYv45kFfyYdw-g.png"/></div></div></figure><h1 id="58c2" class="kv kw it bd kx ky mz la lb lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls bi translated">远程调试</h1><p id="e184" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">确保Dockerfile的构建方式可以启动应用程序，从而允许连接远程调试器。</p><p id="9d68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最简单的方法是将远程调试选项添加到Dockerfile文件中的CMD语句:</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="db14" class="kv kw it bd kx ky mz la lb lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls bi translated">创建容器</h1><p id="dcc2" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">一旦构建了映像，我们就可以在远程容器中运行应用程序了。</p><p id="2d20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最简单的选择是使用ssh访问Linux实例，并在命令行中使用docker或docker-compose运行容器。</p><p id="6b2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我个人更喜欢docker-compose选项，因为它允许在每次构建后轻松地重新创建新版本的容器。按照官方文档中的描述，将docker-compose安装到Linux虚拟机<a class="ae mm" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">中。</a></p><p id="c89a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Linux虚拟机上创建一个docker-compose.yaml文件，如下所示:</p><pre class="mo mp mq mr gt ng my nh ni aw nj bi"><span id="775b" class="nk kw it my b gy nl nm l nn no">version: "3"</span><span id="dde4" class="nk kw it my b gy np nm l nn no">services:</span><span id="ed6d" class="nk kw it my b gy np nm l nn no">  &lt;service_name&gt;:</span><span id="cca8" class="nk kw it my b gy np nm l nn no">    container_name: &lt;container_name&gt;</span><span id="9421" class="nk kw it my b gy np nm l nn no">    image: &lt;image_name&gt;</span><span id="69d6" class="nk kw it my b gy np nm l nn no">    ports:</span><span id="2a6d" class="nk kw it my b gy np nm l nn no">      - "8080:8080"</span><span id="b0eb" class="nk kw it my b gy np nm l nn no">      - "5009:5009"</span></pre><p id="db80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用创建的图像的名称替换上例中的值<service_name>、<container_name>和<image_name>。上面我们将它设置为项目的名称。然后运行以下命令启动容器:</image_name></container_name></service_name></p><pre class="mo mp mq mr gt ng my nh ni aw nj bi"><span id="d5f2" class="nk kw it my b gy nl nm l nn no">docker-compose up -d</span></pre><p id="0ecf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您的应用程序正在运行，可以通过http:// <linux_vm_name> :8080访问。此外，您可以通过Linux VM上的端口5009访问IDE的调试器。</linux_vm_name></p><h1 id="3936" class="kv kw it bd kx ky mz la lb lc na le lf lg nb li lj lk nc lm ln lo nd lq lr ls bi translated">结论</h1><p id="5891" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">虽然，在你的开发机器上安装Docker实例并不总是可能的，但是这不应该阻止你在软件开发生命周期中使用Docker。</p><p id="888a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以<a class="ae mm" href="https://github.com/ikolomiyets/demo-policy" rel="noopener ugc nofollow" target="_blank">获得我前段时间最初为Docker和Kubernetes培训创建的示例项目</a>,但是从那以后就用它进行各种测试。它被配置为根据gradle.properties文件的内容在远程Docker上构建开发映像，并启用了远程调试。</p><p id="127a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不过这需要JDK 11岁以上。在构建项目之前，确保JAVA_HOME变量指向JDK 11+。</p></div></div>    
</body>
</html>