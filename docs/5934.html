<html>
<head>
<title>Markdown Rendering and Recursive Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">降价渲染和递归合成</h1>
<blockquote>原文：<a href="https://itnext.io/markdown-rendering-and-recursive-composition-e76cca3631e8?source=collection_archive---------4-----------------------#2021-07-04">https://itnext.io/markdown-rendering-and-recursive-composition-e76cca3631e8?source=collection_archive---------4-----------------------#2021-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9940" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你有没有想过这篇文章在你的屏幕上是怎么渲染的？我们都知道字体、字体大小、粗体/斜体/下划线样式、段落、要点，但是你真的想过这个过程背后的步骤吗？文本的一部分可以是粗体、斜体或T2斜体，但是这些信息存储在哪里呢？虽然文本本身没有指示符，但是这句话让我们想起了我们最喜欢的一种标记语言。</p><p id="325f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能很熟悉Markdown，它是格式化文本和纯文本两个世界之间的桥梁。它让你在一个纯文本编辑器中风格化你的文本，任何兼容的渲染器会把它变成一个漂亮的风格化文档。Github自述文件、slack聊天消息、Reddit评论，都支持一个版本的Markdown。尽管WYISWYG编辑器通常输出适合机器阅读的XML或JSON格式的文档，但Markdown在方便人们阅读方面更有优势。</p><p id="987d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我想专门讨论Markdown如何帮助将可样式化的文本转换成纯文本，以及像Compose这样的UI框架如何将纯文本转换成美观的、有样式的文档。</p><h1 id="9ffc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">降价分析</h1><p id="46e0" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">减价文件没有经过预处理，这意味着它们是按原样编写、存储和传输的。降价呈现器直接接收纯文本内容。然后，呈现器将负责将文本转换成结构化文档。对于本节的其余部分，我将基于<a class="ae lp" href="https://github.com/commonmark/commonmark-java" rel="noopener ugc nofollow" target="_blank"> Commonmark </a>库进行解析。</p><blockquote class="lq lr ls"><p id="bb56" class="jn jo kl jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">你好，* *世界！**</p></blockquote><p id="63af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的文字是一个明显的Markdown可读的人。然而，对于文字处理人员来说，理解这些(*)号的含义并不是一蹴而就的。中级呈现器必须知道所有降价规则，以便以结构化的方式解释文本，从而使文本呈现器风格化。当这个文本被提供给Commommark解析器时，输出如下所示</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/411f28532bf51b21582c30dffc82aba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTSWbwz16Qq95dJmd3A4lg.png"/></div></div></figure><p id="1f4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们当然可以更进一步，把它混合一点</p><blockquote class="lq lr ls"><p id="debb" class="jn jo kl jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">你好，**Wo_rld_！**</p></blockquote><p id="b78c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，这将对应于</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mi"><img src="../Images/50a8e8cb17925e87ee6178c32694baac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ysa4tr7sIaO9AslESu1bQ.png"/></div></div></figure><p id="73c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们开始了解文本块内部是如何风格化的。粗体、斜体、删除线、下划线、链接、内嵌图像等。应用时都遵循相同的方法。另一方面，段落不是内联样式，而是被视为文本块。文本块包括但不限于:项目符号、代码块、引号和编号列表。最后，在继续分析解析结果背后的数据结构之前，让我们给示例添加一个要点。</p><blockquote class="lq lr ls"><p id="4cdb" class="jn jo kl jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">你好，</p><p id="d830" class="jn jo kl jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">- **Wo_rld_！**</p></blockquote><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mj"><img src="../Images/48fa5ca13853b62cd787b6caf7fbfdee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ms6dE7MjMNvOXMPmf_SFrA.png"/></div></div></figure><p id="ff11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们有两个文本块，其中一个还包括内联样式。</p><p id="ef5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，最后一个问题是解析器如何输出结果？这实际上取决于消费者打算用它做什么。如果我们只考虑解析和存储结果以备将来使用，那么输出可以是类似HTML文档的JSON或XML。然而，Commonmark是一个多用途的解析器，可以在不同的语言中使用。我们将讨论Java版本。将JSON或XML作为输出是一种浪费，因为它们需要进一步解析才能在我们工作的任何UI框架中使用。相反，Commonmark给了我们一个并不令人惊讶的树。看最后一个例子，我们很容易把它想象成一棵树</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mk"><img src="../Images/c5bb5c11f08443006d3b33e1130f51f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a07MesyxJ47Uq_7HjJnEGg.png"/></div></div></figure><p id="2ee5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然看起来很复杂，但是这个树很容易推理。它从一个文档标签开始。它的子对象应该是包含文本的块。第一段有一个孩子说“你好”，没有任何样式，非常简单。第二个子元素声明自己是一个列表项，所以我们假设在这个块的左侧会有一个项目符号。它下面的独生子是造型性质的。“粗体”树节点声明它的所有子节点都需要使用粗体规则进行样式化。所以，“我”，不管“斜体”下面是什么，还有“！”都是需要大胆的。同样的情况也适用于“Italic”节点的子节点，这意味着“rld”将同时是粗体和斜体。</p><h1 id="1c2e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">树，递归，遍历</h1><p id="e858" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">任何使用过UI框架的人都会告诉你，所有的UI实际上都是一个组件树。Compose也不例外，实际上使它变得非常明显。更进一步，Compose被分成两个部分，其中一个抽象的动态树用最新的状态更新，另一个部分根据这个树中的变化输出UI。这里有一些资源供好奇的人了解更多</p><div class="ml mm gp gr mn mo"><a href="https://jakewharton.com/a-jetpack-compose-by-any-other-name/" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">由任何其他名字组成喷气背包——杰克·沃顿</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">我非常喜欢Jetpack Compose。在工作和个人事务之间，我有三个项目，每个都建立在它的基础上…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">jakewharton.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc mg mo"/></div></div></a></div><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d9d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们之前的降价树与Compose配合得非常好。我们唯一需要做的就是遍历树，同时发出相应的组件。这种对应可能非常简单，因为我们应该为接受包含子元素的内容参数的文本块提供组件。我还没有提到这一点，但是在Markdown规范中，文本块可以包含其他文本块。</p><p id="272c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从一些代码示例开始</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="nf ne l"/></div></figure><p id="27a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个要点显示了在我们的降价例子中，我们期望什么样的可组合树。在这一点上，函数名和调用顺序完全是任意的。稍后我们将使用<a class="ae lp" href="https://github.com/zach-klippenstein/compose-richtext" rel="noopener ugc nofollow" target="_blank"> compose-richtext </a>库来构建模块。现在，我们的注意力应该放在如何在发出Composables的同时遍历一个解析过的Markdown树。</p><p id="46dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当在复杂系统上工作以定义一些边界时，公理是有用的。因此，在一个可靠的实现计划的开始就确定这些原则是一个好主意。</p><ul class=""><li id="c66a" class="ng nh iq jp b jq jr ju jv jy ni kc nj kg nk kk nl nm nn no bi translated">每个文档都以一个文档节点开始。</li><li id="76b3" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated">文本和样式节点总是位于文本块下，例如段落、引用、列表项等。</li><li id="9d6d" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated">文本是一个终端节点。文本不能有子级。</li><li id="1633" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated">样式不会泄漏到其他文本块。样式节点不能将文本块作为子节点。</li><li id="6de6" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated">所有文本块必须将段落作为第一个子块，例如块引用-&gt;段落-&gt;内容</li></ul><p id="68e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">减价节点的一般视图如下:</p><pre class="lx ly lz ma gt nu nv nw nx aw ny bi"><span id="d0c0" class="nz kn iq nv b gy oa ob l oc od">Node:<br/>  - leftChild<br/>  - rightChild<br/>  - next<br/>  - previous</span></pre><p id="9686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们也将有一个从最左边的孩子到最右边的<code class="fe oe of og nv b">children</code> iterable。</p><p id="3b2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以预见的是，递归遍历这棵树，同时发出文本块组件将是一种可行的方式。下面给出了一个几乎是伪代码的例子</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="nf ne l"/></div></figure><p id="3d79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Node应该是一个密封类，在我们的Markdown文档中包含所有已定义文本块的子类型。考虑到我们从compose-richtext中获得了迭代助手和文本块，这看起来几乎太容易了。从根节点调用<code class="fe oe of og nv b">render</code>就足够了，剩下的应该会解决。不幸的是，段落中的文本可能被定义为树，但不能以递归方式计算。请参考第一个代码示例，其中<code class="fe oe of og nv b">Text</code>块被单独调用。Compose将这些文本调用视为独立的<code class="fe oe of og nv b">Text</code>组件，因此输出实际上将是一系列独立的<code class="fe oe of og nv b">Text</code>布局。</p><p id="3826" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我们的公理告诉我们，一旦我们遇到一个段落，我们可以安全地假设其余的子节点将是文本或样式节点。从那里开始，我们可以计算出一个风格化的不可分割的文本块。</p><p id="3117" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然递归不起作用，但我们可以在构建跨区文本时进行前序遍历。这个过程的完整代码可以在<a class="ae lp" href="https://github.com/zach-klippenstein/compose-richtext/blob/main/richtext-commonmark/src/main/java/com/zachklipp/richtext/markdown/MarkdownRichText.kt#L55" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><div class="ml mm gp gr mn mo"><a href="https://github.com/zach-klippenstein/compose-richtext/blob/main/richtext-commonmark/src/main/java/com/zachklipp/richtext/markdown/MarkdownRichText.kt#L55" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">扎克-克利彭斯坦/撰写-richtext</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">用于高级文本格式和替代显示类型的合成库集合。…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="mx l"><div class="oh l mz na nb mx nc mg mo"/></div></div></a></div><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/7d9539f31cc98ff6d768b47b4bb1f1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/1*Ff-eaGnRNU-3y1puu2NnkQ.gif"/></div></figure><p id="fb37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的gif解释了构建一个生成字符串的前序遍历。样式节点将一个跨度推入正在进行的构建器，文本节点将其内容追加到构建器。最后，一个spanned或RichText就可以用一个节点<code class="fe oe of og nv b">Text</code>调用了。对于其余的，我们可以继续使用递归方法。</p><h1 id="1c22" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="5f6b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我必须承认，在试图简化这个话题时，我跳过了很多步骤。我引起了他们的注意，并且可能点燃了他们对此类主题的兴趣的任何人都可以查看整个compose-richtext库。</p><div class="ml mm gp gr mn mo"><a href="https://github.com/zach-klippenstein/compose-richtext" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">扎克-克利彭斯坦/撰写-richtext</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">用于处理富文本格式和文档的合成库集合。这个回购目前非常…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="mx l"><div class="oj l mz na nb mx nc mg mo"/></div></div></a></div><p id="728f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个Markdown渲染器的完整实现可以在richtext-commonmark模块下面找到。这是一个非常粗略的实现，所以欢迎投稿。</p></div></div>    
</body>
</html>