<html>
<head>
<title>A beginners guide to Ramda (Part 2) — Lenses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ramda入门指南(第二部分)——镜头</h1>
<blockquote>原文：<a href="https://itnext.io/a-beginners-guide-to-ramda-part-2-lenses-62bdd3993598?source=collection_archive---------3-----------------------#2018-07-23">https://itnext.io/a-beginners-guide-to-ramda-part-2-lenses-62bdd3993598?source=collection_archive---------3-----------------------#2018-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/89648609d64e1b97ee7da81e3d08984a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9GqI_JVq9TrUOH3u"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@kazdenc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kazden Cattapan </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="50c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你错过了本指南的第1部分，我们讨论了使用Ramda的自动绘制和函数组合。在第二部分中，我们将仔细研究透镜。</p><h1 id="5809" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是镜头？</h1><p id="106e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">镜头允许你“聚焦”一个对象的嵌套属性，并对其执行操作，同时保持原始对象的上下文。</p><h1 id="33e8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么要用镜片？</h1><blockquote class="me mf mg"><p id="4138" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated">透镜的真正美妙之处在于，我们可以更新物体的属性，而无需改变原始物体。</p></blockquote><p id="c69c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Ramda中，我们可以用镜头对一个对象执行3种类型的操作。</p><ul class=""><li id="361b" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">获得财产</li><li id="3bf5" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">设置属性</li><li id="6b18" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">调用属性上的函数</li></ul><p id="c290" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于在javascript中从对象获取属性是一个简单的操作，因此lenses的大部分功能将来自于设置和转换属性。</p><p id="1334" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">透镜的真正美妙之处在于，我们可以更新物体的属性，而无需改变原始物体。然而，不是克隆整个结构，而是进行相关目标的浅层克隆，并且新结构将保留指向未接触的数据结构的指针。更明显的是，在较大的对象中，这将给我们带来更好的性能，降低时间和空间的复杂性。</p><p id="b1ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们更深入地看看我们可以使用镜头执行的一些操作。</p><h1 id="649e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取属性</h1><p id="c980" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面，我们将创建一个<code class="fe mz na nb nc b">game</code>对象。要从这个对象获得一个属性，我们需要创建一个镜头，然后将镜头和对象传递给<code class="fe mz na nb nc b">view</code>。我们可以使用<code class="fe mz na nb nc b">lensProp</code>、<code class="fe mz na nb nc b">lensPath</code>、<code class="fe mz na nb nc b">lensIndex</code>来创建一个镜头。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="b4ec" class="nl lc iq nc b gy nm nn l no np">const game = {<br/>  name: 'Keep Talking and Nobody Explodes',<br/>  genres: ['Puzzle', 'VR'],<br/>  publisher: {<br/>    name: 'Steel Crate Games',<br/>    location: 'Ottawa, Canada'<br/>  }<br/>}</span><span id="ac9e" class="nl lc iq nc b gy nq nn l no np">const name = R.lensProp('name')<br/>R.view(name, game)<br/>&gt; 'Keep Talking and Nobody Explodes'</span><span id="7c85" class="nl lc iq nc b gy nq nn l no np">const first = R.lensIndex(0)<br/>R.view(first, game.genres)<br/>&gt; 'Puzzle'</span><span id="6237" class="nl lc iq nc b gy nq nn l no np">const publisherName = R.lensPath(['publisher', 'name'])<br/>R.view(publisherName, game)<br/>&gt; 'Steel Crate Games'</span><span id="fc5d" class="nl lc iq nc b gy nq nn l no np">// You can also reference indexes with lensPath<br/>const firstGenre = R.lensPath(['genre', 0])<br/>R.view(firstGenre, game)<br/>&gt; 'Puzzle'</span></pre><p id="01f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个叫做<code class="fe mz na nb nc b">lens</code>的方法，需要你传递一个getter和一个setter函数给它。在大多数情况下，你应该能够实现你所需要的其他三个镜头功能之一。下面我们有一个它的用法的例子。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="743c" class="nl lc iq nc b gy nm nn l no np">const name = R.lens(R.prop('name'), R.assoc('name'));</span><span id="f6c3" class="nl lc iq nc b gy nq nn l no np">// achieves the same thing<br/>const alsoName = R.lensProp('name')</span></pre><h1 id="d10e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置属性</h1><p id="c95e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这就是镜头真正强大的地方。我们使用一个名为<code class="fe mz na nb nc b">set</code>的函数，它接受一个镜头、一个值和要操作的对象。下面的例子:</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="f6c1" class="nl lc iq nc b gy nm nn l no np">const game = {<br/>  name: 'Overcooked',<br/>  platforms: ['PS4', 'XB1', 'NS', 'PC'],<br/>  publisher: {<br/>    name: 'Team 17',<br/>    location: 'Wakefield, England'<br/>  }<br/>}</span><span id="3dcd" class="nl lc iq nc b gy nq nn l no np">const firstPlatform = R.lensPath(['platforms', 0])</span><span id="5844" class="nl lc iq nc b gy nq nn l no np">const newGame = R.set(firstPlatform, 'PS5', game)<br/>&gt; {<br/>    name: 'Overcooked',<br/>    platforms: ['PS5', 'XB1', 'NS', 'PC'],<br/>    publisher: {<br/>      name: 'Team 17',<br/>      location: 'Wakefield, England'<br/>    }<br/>  }</span></pre><p id="5b06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">set</code>返回了一个新对象，第一个平台从<code class="fe mz na nb nc b">"PS4"</code>更新到了<code class="fe mz na nb nc b">"PS5"</code>。注意<code class="fe mz na nb nc b">platforms</code>已经被浅克隆，而<code class="fe mz na nb nc b">publisher</code>仍然是对同一个对象的引用。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="517b" class="nl lc iq nc b gy nm nn l no np">game.platforms === newGame.platforms<br/>&gt; false</span><span id="49e9" class="nl lc iq nc b gy nq nn l no np">game.publisher === newGame.publisher<br/>&gt; true</span></pre><h1 id="de15" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对属性调用函数</h1><p id="672a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用<code class="fe mz na nb nc b">over</code>方法，我们可以使用一个函数来转换我们的数据。<code class="fe mz na nb nc b">over</code>方法采用一个镜头、一个函数和一个数据结构。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="d08c" class="nl lc iq nc b gy nm nn l no np">const person = {<br/>  name: 'Bev',<br/>  gender: 'female'<br/>}</span><span id="d48a" class="nl lc iq nc b gy nq nn l no np">const addMs = (name) =&gt; `Ms. ${name}`<br/>const nameLens = R.lensProp('name')</span><span id="0ba7" class="nl lc iq nc b gy nq nn l no np">R.over(nameLens, addMs, person)<br/>&gt; {<br/>    name: 'Ms. Bev',<br/>    gender: 'female'<br/>  }</span></pre><p id="add6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单，但功能强大。同样，我们最初的<code class="fe mz na nb nc b">person</code>数据结构保持不变。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="7dc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们将镜头和一些Ramdas的其他函数组合在一起，以实现更复杂的变换。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="dfbf" class="nl lc iq nc b gy nm nn l no np">const people = [{<br/>  name: 'Terry',<br/>  cats: ['Korin', 'Sweep', 'Caterina']<br/>}, {<br/>  name: 'Trevor',<br/>  cats: ['Jazz']<br/>}]</span><span id="df04" class="nl lc iq nc b gy nq nn l no np">const cats = R.lensProp('cats')<br/>const uppercaseCats = R.map(R.over(cats, R.map(R.toUpper)))</span><span id="1f15" class="nl lc iq nc b gy nq nn l no np">uppercaseCats(people)<br/>&gt; [{<br/>    name: 'Terry',<br/>    cats: ['KORIN', 'SWEEP', 'CATERINA']<br/>  }, {<br/>    name: 'Trevor',<br/>    cats: ['JAZZ']<br/>  }]</span></pre><p id="cbe4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们把每只猫变成一个有名字和年龄的物体。我们想让每只猫的年龄翻倍。我们如何解决这个问题？</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="f6a7" class="nl lc iq nc b gy nm nn l no np">const person = {<br/>  name: 'Terry',<br/>  cats: [{<br/>    name: 'Korin',<br/>    age: 4<br/>  }, {<br/>    name: 'Sweep',<br/>    age: 3<br/>  }, {<br/>    name: 'Catarina',<br/>    age: 2<br/>  }]<br/>}</span><span id="cc3e" class="nl lc iq nc b gy nq nn l no np">const double = (x) =&gt; x * 2<br/>const cats = R.lensProp('cats')<br/>const age = R.lensProp('age')<br/>const doubleCatsAge = R.over(<br/>  cats, <br/>  R.map(R.over(age, double))<br/>)</span><span id="8db4" class="nl lc iq nc b gy nq nn l no np">doubleCatsAge(person)<br/>&gt; {<br/>    name: 'Terry',<br/>    cats: [{<br/>      name: 'Korin',<br/>      age: 8<br/>    }, {<br/>      name: 'Sweep',<br/>      age: 6<br/>    }, {<br/>      name: 'Catarina',<br/>      age: 4<br/>    }]<br/>  }</span></pre><p id="7e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们聚焦于<code class="fe mz na nb nc b">cats</code>数组，然后我们使用<code class="fe mz na nb nc b">map</code>来操作数组中的每一项，然后我们再次聚焦于<code class="fe mz na nb nc b">age</code>，然后对其进行转换。</p><h1 id="295b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">合成镜头</h1><p id="e826" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">镜头的一个奇妙之处在于它们是可组合的。这意味着每个镜头都是一个组合单元，可以重复使用。让我们再来看看我们的<code class="fe mz na nb nc b">game</code>例子，但是这次是用API封装的。我们可以将透镜组合在一起，用于封装和非封装数据结构。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="64ab" class="nl lc iq nc b gy nm nn l no np">const game = {<br/>  name: 'Keep Talking and Nobody Explodes',<br/>  genres: ['Puzzle', 'VR'],<br/>  publisher: {<br/>    name: 'Steel Crate Games',<br/>    location: 'Ottawa'<br/>  }<br/>}</span><span id="8fb3" class="nl lc iq nc b gy nq nn l no np">// We wrap the game in an "envelope" response from an API<br/>const response = {<br/>  statusCode: 200,<br/>  body: game<br/>}</span><span id="8b6b" class="nl lc iq nc b gy nq nn l no np">const publisherName = R.lensPath(['publisher', 'name']);<br/>const body = R.lensProp('body')</span><span id="a2dc" class="nl lc iq nc b gy nq nn l no np">// Compose the 2 lenses together<br/>const bodyPublisherName = R.compose(body, publisherName)</span><span id="a09f" class="nl lc iq nc b gy nq nn l no np">const a = R.view(publisherName, game)<br/>&gt; 'Steel Crate Games'</span><span id="84d9" class="nl lc iq nc b gy nq nn l no np">const b = R.view(bodyPublisherName, response)<br/>&gt; 'Steel Crate Games'</span></pre><p id="f04b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将两个镜头<code class="fe mz na nb nc b">publisherName</code>和<code class="fe mz na nb nc b">body</code>组合在一起，创造出第三个镜头，称为<code class="fe mz na nb nc b">bodyPublisherName</code>。我们可以在内部和外部使用<code class="fe mz na nb nc b">publisherName</code>。<code class="fe mz na nb nc b">body</code>将有助于与信封内的任何数据结构组合在一起。真是太贴心了。</p><h1 id="f9bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构成修改</h1><p id="0a22" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是我从看<a class="ae kc" href="https://www.youtube.com/channel/UCc8LoGpIa8tRNosGGJroS2Q" rel="noopener ugc nofollow" target="_blank"> EvilSoft </a>的这个超赞的<a class="ae kc" href="https://www.youtube.com/watch?v=tvHghZBMVJU" rel="noopener ugc nofollow" target="_blank">视频</a>中学到的一招。基本上，我们可以创建一个修改数组，并将它们组合在一起，对数据结构进行一系列修改。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="7530" class="nl lc iq nc b gy nm nn l no np">const game = {<br/>  name: 'Dead Nation',<br/>  genres: ['Twin Stick Shooter', 'Shoot em up'],<br/>  publisher: {<br/>    name: 'Sony Interactive',<br/>    location: 'California, USA'<br/>  }<br/>}</span><span id="f663" class="nl lc iq nc b gy nq nn l no np">const reverse = R.pipe(R.split(''), R.reverse, R.join(''))<br/>const name = R.lensProp('name')<br/>const publisherName = R.lensPath(['publisher', 'name']);<br/>const genres = R.lensProp('genres')</span><span id="d3b3" class="nl lc iq nc b gy nq nn l no np">const mods = [<br/>  R.set(name, 'Alienation'),<br/>  R.over(publisherName, R.toUpper),<br/>  R.over(genres, R.map(reverse))<br/>]</span><span id="aeed" class="nl lc iq nc b gy nq nn l no np">R.compose(...mods)(game)<br/>&gt; {<br/>    name: 'Alienation',<br/>    genres: ['retoohS kcitS niwT', 'pu me toohS'],<br/>    publisher: {<br/>      name: 'SONY INTERACTIVE',<br/>      location: 'California, USA'<br/>    }<br/>  }</span></pre><h1 id="37d9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">总结</h1><p id="a8dc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">希望lenses能帮助你写出可组合的、无副作用的代码。如果你喜欢这篇文章，别忘了给点掌声:)</p></div></div>    
</body>
</html>