<html>
<head>
<title>Modern C++ in Advent of Code: Day13</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++代码的出现:第13天</h1>
<blockquote>原文：<a href="https://itnext.io/modern-c-in-advent-of-code-day13-4ae500de12b0?source=collection_archive---------5-----------------------#2021-12-13">https://itnext.io/modern-c-in-advent-of-code-day13-4ae500de12b0?source=collection_archive---------5-----------------------#2021-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8c9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天是代码问世的第十三天。今天，我们将使用C++20系列来折叠透明纸。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/680d85741a27eb44d050c2e49e8647b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oL2a6CfQTFev-eq28JkToA.png"/></div></div></figure><p id="0982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，请先尝试解决问题，然后再看解决方案。对于本系列中的所有文章，<a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">查看这个列表</a>。</p><h1 id="79a9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第13天:第一部分</h1><p id="c6c7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们的输入是2D平面上的一系列点和折叠指令。我们先把问题简化一点。我们总是只在一个方向折叠，所以问题的2D性质是不相关的。</p><p id="e942" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看当我们折叠一个数字时会发生什么。</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="908f" class="mg kz iq mc b gy mh mi l mj mk">0 1 2 3 4 5 6 7 8 9<br/>  x           x x</span></pre><p id="50fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们用数字5折叠这三个数字(1、7和8 ),我们反映出数字5周围的数字是中心。而且，我们总是只向零反映。</p><pre class="kn ko kp kq gt mb mc md me aw mf bi"><span id="c81d" class="mg kz iq mc b gy mh mi l mj mk">0 1 2 3 4 5 6 7 8 9<br/>  x o o   |   - -</span></pre><p id="1a89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就引出了一个简单的公式:<code class="fe ml mm mn mc b">center — (number-center)</code>或者<code class="fe ml mm mn mc b">2*center — number</code>。当折叠纸张时，我们将这个公式应用于每个点的x或y值。</p><p id="ffea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样一来，我们现在可以开始我们通常的工作了:声明和初始测试。我们将重用从<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/modern-c-in-advent-of-code-day5-4777e4037869">第5天</a>开始的点数据类型。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b6e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的测试中，我们还检查了fold函数，它折叠单个数字:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b61a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">fold函数实现了上面提到的公式，我们还注意不要折叠成负数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="442c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于解析，我们重用第5天的代码来解析点，然后用它来读取输入的第一部分:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2382" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<code class="fe ml mm mn mc b">clear()</code>调用(第31行)，它从流中清除了<code class="fe ml mm mn mc b">badbit</code>。如果我们不这样做，对<code class="fe ml mm mn mc b">getline</code>的连续调用将会失败而不尝试读取。为了读取输入的第二部分，我们检查每一行的前缀，然后将行尾转换成一个数字(为了正确解析，我们应该检查转换是否成功)。</p><p id="2fca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，对于折叠，我们检查所有点，并将折叠应用于相应的坐标:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="8fe4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们必须将折叠的元素插入到一个新的<code class="fe ml mm mn mc b">unordered_set</code>中，因为在迭代时修改一个<code class="fe ml mm mn mc b">unordered_set</code>是不安全的。</p><p id="dfe8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的主要功能仍然非常简单:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="ae27" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第十三天:第二部分</h1><p id="0152" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">对于我们任务的第二部分，我们必须处理所有的纸张折叠，然后打印出结果来阅读现在解码的字母。</p><p id="c1cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先需要扩展fold函数来处理所有折叠:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c0de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了打印出结果，我们需要将由坐标给出的点转换成一个立体的2D网格。然而，为此，我们首先需要网格的维度。幸运的是，我们知道网格将小于每个维度中的最小折叠点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a68f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通过轴(第2行和第4行)过滤折叠，然后选择最小的数量(第3行和第5行)。注意，过滤器是懒惰的，只在<code class="fe ml mm mn mc b">min_element</code>算法迭代元素时才发生。</p><p id="8313" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以构建一个2D网格(第7行)并遍历这些点，将相应的像素设置为#(第9行)。</p><p id="46e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这又让我们的主要功能变得非常简单:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="4ff7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">链接和技术说明</h1><p id="0b2b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">每日解决方案存储库位于:<a class="ae kl" href="https://github.com/HappyCerberus/moderncpp-aoc-2021" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/moderncpp-aoc-2021</a>。</p><p id="9643" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">看看这个列表，里面有关于《代码降临》</a>其他日子的文章。</p><p id="88e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请不要忘记亲自尝试<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">降临码</a>。</p><h1 id="94b1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="be3e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="6a54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在推特或LinkedIn 上联系我。</p></div></div>    
</body>
</html>