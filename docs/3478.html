<html>
<head>
<title>JavaScript Error Handling from Express.js to React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Express.js到React的JavaScript错误处理</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-error-handling-from-express-js-to-react-810deb5e5e28?source=collection_archive---------0-----------------------#2019-12-23">https://itnext.io/javascript-error-handling-from-express-js-to-react-810deb5e5e28?source=collection_archive---------0-----------------------#2019-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b88e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">因为错误是必然会发生的，我们需要正确地处理它们。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9bf320bb2389ea8d396f199eb6a82713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4TYYthJ67pMtCtvVdw1zEw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@jamie452?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰米街</a>在<a class="ae kv" href="https://unsplash.com/s/photos/something-went-wrong?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="7e8e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="0ce4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di">我已经用了一整套<a class="ae kv" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank"> MERN (MySQL、Express、React和Node.js)项目</a>来写了一大堆博文。随着我慢慢地构建它并添加更多的功能，我学到了许多值得分享的新东西，以帮助其他开发人员避开我在这个过程中遇到的障碍。</span></p><p id="9cd8" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">过去的主题包括使用<a class="ae kv" href="https://medium.com/@paigen11/sequelize-the-orm-for-sql-databases-with-nodejs-daa7c6d5aca3" rel="noopener"> Sequelize </a>作为MySQL数据库的ORM，使用<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436"> PassportJS和JWT </a>进行认证和保护路由，使用<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/password-reset-emails-in-your-react-app-made-easy-with-nodemailer-bb27968310d7"> Nodemailer </a>通过电子邮件提供密码重置功能，等等。老实说，通过构建这个应用程序，只是为了学习更多的节点、更多的反应、更多的核心JavaScript，教会了我很多。</p><p id="1f05" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">如果你想看我关于这个回购和代码本身的其余帖子，我会在本文底部链接到它们。</p><p id="2aff" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">今天的帖子也不例外。</p><blockquote class="mz"><p id="2245" class="na nb iq bd nc nd ne nf ng nh ni mj dk translated">今天我将讨论如何正确处理JavaScript应用程序两端的错误:从在Express中的服务器端抛出错误，到使用React和Axios在客户端捕捉和处理错误。</p></blockquote></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="0204" class="kw kx iq bd ky kz nq lb lc ld nr lf lg jw ns jx li jz nt ka lk kc nu kd lm ln bi translated">快速错误处理</h1><p id="3277" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">因为服务器端是大多数错误发生的地方，所以我也将从Node.js / Express服务器代码开始。</p><p id="4747" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">我必须承认，在相当长的一段时间里，在构建这个应用程序的过程中，我从Express服务器传回了<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener ugc nofollow" target="_blank"> HTTP 200状态</a>(OK状态)代码，即使在数据库中没有发现像丢失JWT令牌或用户ID这样的错误。</p><p id="bb06" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><em class="my">不当表达错误处理示例</em></p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="05da" class="oa kx iq nw b gy ob oc l od oe">res.status(200).json('404 - no user exists in db to update');</span></pre><p id="8288" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">我这样做是因为我不仅想发送401(未授权)或403(禁止)HTTP状态代码，而且还想发送一条书面消息，说明服务器端到底发生了什么错误，在很长一段时间里，我都找不到如何使用Express来实现这两个目的。</p><p id="5fb9" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">要么通过<code class="fe of og oh nw b">res.json('This is an error message the client can read')</code>发送一个错误消息，带有200 HTTP状态，<em class="my">要么</em>发送一个401或403 HTTP状态，没有关于<code class="fe of og oh nw b">res.status(401)</code>实际上出了什么问题的进一步信息。</p><p id="f07b" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">终于有一天，我在<a class="ae kv" href="https://expressjs.com/en/guide/error-handling.html" rel="noopener ugc nofollow" target="_blank"> Express文档</a>中找到了我一直在寻找的解决方案，这个文档有很多。这真的没有我想象的那么棘手——这类似于当事情进展顺利时我发送一条消息和一个200 HTTP状态，就像这样:</p><p id="ffdb" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><em class="my">快递成功状态码报文示例</em></p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="0d5d" class="oa kx iq nw b gy ob oc l od oe">res.status(200).send({ message: 'user created' });</span></pre><p id="6ddb" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">我可以用错误状态和消息做同样的事情。</p><p id="8932" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><em class="my">表示故障状态代码和信息示例</em></p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="e508" class="oa kx iq nw b gy ob oc l od oe">res.status(401).send('no user exists in db to update');</span></pre><p id="39a1" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">仅仅通过从Express的<code class="fe of og oh nw b">.json()</code>切换到<code class="fe of og oh nw b">.send()</code>方法，就意味着我可以将HTTP错误代码<em class="my">和</em>信息消息链接在一起，供客户端解密，然后在浏览器端进行适当的处理。😄</p><p id="87f6" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">值得注意的是，<code class="fe of og oh nw b"><a class="ae kv" href="https://expressjs.com/en/api.html#res.send" rel="noopener ugc nofollow" target="_blank">.send()</a></code>可以在JavaScript中处理对象、字符串或数组。成功消息示例是一个具有属性<code class="fe of og oh nw b">message</code>的对象，而失败响应只是一个字符串，因为在成功响应的情况下，像消息、JSON Web令牌或其他数据可能会从服务器发送到客户机。然而，我的错误只需要一个HTTP响应和字符串形式的错误消息。只是为了让你知道未来。🙂</p><p id="72b4" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">下面是我的应用程序中的一个服务器端路由的例子，展示了当用户试图在登录时更新他们的个人信息时发送成功或失败的完整实现。(我选择将它作为来自VS代码的格式良好且突出显示的图像和可复制的代码片段包含在内)。</p><p id="2555" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><code class="fe of og oh nw b">updateUser.js</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/237db5241f32f02799a0e1df7262b61f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oo-RuRSIw5BEMcTnFZaeg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">js是服务器端的路由，它可以更新用户的个人信息，也可以不更新。</figcaption></figure><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="8f81" class="oa kx iq nw b gy ob oc l od oe">module<em class="my">.</em>exports = (app) =&gt; {<br/>  <em class="my">app.put</em>('/updateUser', (req, res, next) =&gt; {<br/>    <em class="my">passport.authenticate</em>('jwt', { session: false }, (err, user, info) =&gt; {<br/>      if (err) {<br/>        console<em class="my">.</em>error(err);<br/>      }<br/>      if (info !== undefined) {<br/>        console<em class="my">.</em>error(<em class="my">info.</em>message);<br/>        <em class="my">res.status</em>(403)<em class="my">.send</em>(<em class="my">info.</em>message);<br/>      } else {<br/>        <em class="my">User.findOne</em>({<br/>          where: {<br/>            username: <em class="my">req.body.</em>username,<br/>          },<br/>        })<em class="my">.then</em>((userInfo) =&gt; {<br/>          if (userInfo != null) {<br/>            console<em class="my">.</em>log('user found in db');<br/>            userInfo<br/>              <em class="my">.update</em>({<br/>                first_name: <em class="my">req.body.</em>first_name,<br/>                last_name: <em class="my">req.body.</em>last_name,<br/>                email: <em class="my">req.body.</em>email,<br/>             })<br/>            <em class="my">.then</em>(() =&gt; {<br/>              console<em class="my">.</em>log('user updated');<br/>              <em class="my">res.status</em>(200)<em class="my">.send</em>({ auth: true, message: 'user updated' });<br/>            });<br/>         } else {<br/>          console<em class="my">.</em>error('no user exists in db to update');<br/>          <em class="my">res.status</em>(401)<em class="my">.send</em>('no user exists in db to update');<br/>         }<br/>       });<br/>      }<br/>    })(req, res, next);<br/>  });<br/>};</span></pre><p id="e6f4" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">让我快速分析一下这个文件中发生了什么。</p><p id="c271" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">当路由被点击时发生的第一件事是PassportJS接管并检查用户的JSON Web令牌是否存在和有效，这发生在另一个文件中，并在另一个<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436">博客</a>帖子中涉及，所以我现在不会深入讨论这个问题。</p><p id="1b2a" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">一旦用户通过了身份验证，该路由就会尝试在MySQL数据库中找到那个<code class="fe of og oh nw b">username</code>,如果找到了，就会更新用户信息，并发回一条HTTP status 200的成功消息和一条<code class="fe of og oh nw b">'user updated'</code>消息。</p><p id="211a" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">如果在数据库中没有找到<code class="fe of og oh nw b">username</code>，服务器会记录用户不存在的错误，并发回401 HTTP状态和消息<code class="fe of og oh nw b">'no user exists in db to update'</code>。</p><p id="b523" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">这就是您在查看日志时看到的服务器端控制台上记录的内容。</p><h2 id="11c9" class="oa kx iq bd ky oj ok dn lc ol om dp lg lx on oo li mb op oq lk mf or os lm ot bi translated">服务器日志中的错误快速抛出</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/b0fc06f0427a44cc9378ea30e4f3a898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pvsdLiZN8GzP17YdLSnGg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">将错误打印到服务器的控制台并发送到客户端</figcaption></figure><p id="0e55" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">就错误处理而言，需要重点关注的主要代码是文件底部的这个代码块。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/8d5bcb147f97fc9254f9ff1ff8cbf6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bIH1H52YaBD16GgQYnss9w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">负责向浏览器发送错误状态和消息的代码。</figcaption></figure><p id="f7c8" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">这就是从Express向浏览器成功发送错误状态代码和消息的全部内容。现在我们来谈谈浏览器是如何处理这些错误的。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="3fa5" class="kw kx iq bd ky kz nq lb lc ld nr lf lg jw ns jx li jz nt ka lk kc nu kd lm ln bi translated">React &amp; Axios错误处理</h1><p id="6610" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于我的全栈应用程序的客户端，我选择使用非常流行的基于promise的HTTP库<a class="ae kv" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>，而不是浏览器的本机<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank"> fetch API </a>，因为我发现它更容易使用。这个例子将使用Axios显示所有HTTP请求和错误处理。</p><p id="3f64" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">正如我在慢慢改进服务器端的错误处理一样，随着应用程序的发展和改进，我也在改进客户端的错误处理。</p><p id="baba" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">在我正确处理服务器抛出的错误之前，我所做的就是解释错误。</p><p id="e9eb" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><em class="my">对从服务器向客户端抛出的错误处理不当的例子</em></p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="1643" class="oa kx iq nw b gy ob oc l od oe">  .catch(error =&gt; {        <br/>    console.log(error.data);             <br/>    this.setState({         <br/>      loadingUser: false,         <br/>      error: true,       <br/>    });<br/>  });</span></pre><p id="d534" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">我会尝试捕捉一个错误，将其消息记录到控制台，然后相应地设置React应用程序的状态。对于一个开始来说并不可怕，但是对于一个最终的解决方案来说也不太好——当我试图用一条消息抛出一个200 HTTP状态之外的东西时，客户端就会在<code class="fe of og oh nw b">catch()</code>块中崩溃。</p><p id="4aee" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">就像服务器端一样，我终于厌倦了我正在做的这种半生不熟的错误处理，并找到了一些更好的关于库希望你如何处理错误的Axios文档，这是我以前忽略的。</p><p id="77fe" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">事实证明，使用Axios读取和处理错误的方法实际上是<code class="fe of og oh nw b">error.response.data</code>，而不仅仅是<code class="fe of og oh nw b">catch()</code>函数中的<code class="fe of og oh nw b">error.data</code>。它没有被很好地强调，但是文档指出:</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="f740" class="oa kx iq nw b gy ob oc l od oe"> catch(error =&gt; {<br/>  <!-- -->if(error.response) { <br/>    /* the request <!-- -->was made and the server responded<br/>    with a status code that falls out of the range of 2xx */<br/>    console.log(error.response.data)<br/>  }<br/>}</span></pre><p id="7da7" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">有了这一发现，在客户端捕捉错误突然变得更加容易和更具描述性。</p><p id="6e9d" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">Axios解释来自服务器的成功响应的方式与解释错误代码的方式几乎完全相同。</p><p id="6008" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><em class="my"> Axios成功响应处理</em></p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="2f45" class="oa kx iq nw b gy ob oc l od oe">try {      <br/>  const response = await axios.get('api/findUser', {<br/>    params: {          <br/>      username,        <br/>    },        <br/>    headers: { Authorization: `JWT ${accessString}` },      <br/>  });      <br/>  console.log(response.data); <br/>  // this.setState and so on after response is received...<br/>}</span></pre><p id="deab" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><em class="my"> Axios故障响应处理</em></p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="fbcf" class="oa kx iq nw b gy ob oc l od oe">catch (error) {      <br/>  console.log(error.response.data);      <br/>  this.setState({        <br/>    loadingUser: false,        <br/>    error: true,      <br/>  });    <br/>}</span></pre><p id="1c19" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">事实证明，对我来说，更新所有的<code class="fe of og oh nw b">catch()</code>块以接受这种新的错误格式比我预期的要容易得多。</p><p id="6913" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">同样，这是文件中的一个大片段，用户从客户端更新他们的数据，并将其保存到数据库中。</p><p id="db2b" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><code class="fe of og oh nw b">UpdateProfile.js</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/4ff4c8572e4e5a6046254d12472c815e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99WLd0dPxxuFJ9LYL3bb1w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">js显示了发送到服务器的客户端更新请求，它可以工作，也可以不工作。</figcaption></figure><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="c18a" class="oa kx iq nw b gy ob oc l od oe"><em class="my">updateUser</em> = <em class="my">async</em> (e) =&gt; {<br/>  const<em class="my"> accessString </em>=<em class="my"> localStorage.getItem</em>('JWT');<br/>  if (accessString === null) {<br/>    this<em class="my">.setState</em>({<br/>      loadingUser: false,<br/>      error: true,<br/>    });<br/>  }<br/>  const<em class="my"> </em>{<br/>    <em class="my">first_name</em>,<em class="my"> last_name</em>,<em class="my"> email</em>,<em class="my"> username<br/>  </em>}<em class="my"> </em>=<em class="my"> this.state</em>;<br/>  <em class="my">e.preventDefault</em>();<br/>  <em class="my">try</em> {<br/>    const<em class="my"> response </em>=<em class="my"> await axios.put</em>(<br/>      'http://localhost:3003/updateUser',<br/>      {<br/>        first_name,<br/>        last_name,<br/>        email,<br/>        username,<br/>      },<br/>      {<br/>        <em class="my">headers</em>:<em class="my"> </em>{<em class="my"> Authorization</em>:<em class="my"> </em>`<em class="my">JWT </em>${accessString}`<em class="my"> </em>},<br/>      },<br/>    );<br/>    //<em class="my"> eslint-disable-next-line no-unused-vars<br/>    </em>console<em class="my">.</em>log(<em class="my">response.</em>data);<br/>    this<em class="my">.setState</em>({<br/>      updated: true,<br/>      error: false,<br/>    });<br/>  } <em class="my">catch</em> (error) {<br/>    console<em class="my">.</em>log(<em class="my">error.response.</em>data);<br/>    this<em class="my">.setState</em>({<br/>      loadingUser: false,<br/>      error: true,<br/>    });<br/>  }<br/>};</span></pre><p id="61f2" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">下面是这个函数调用中发生的情况。</p><p id="69f0" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">首先，<code class="fe of og oh nw b">updateUser()</code>从先前添加的本地存储中取出JWT令牌。</p><p id="115f" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">如果找到了令牌，Axios将构建包含所有用户新信息的PUT请求的<code class="fe of og oh nw b">body</code>,并将<code class="fe of og oh nw b">header</code>设置为服务器认证所需的JWT令牌。</p><p id="eeef" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">最后，响应要么以成功更新的形式返回，要么以失败的形式返回，在这种情况下,<code class="fe of og oh nw b">error.response.data</code>被记录到控制台，以帮助开发人员找出问题所在，应用程序的状态被设置为<code class="fe of og oh nw b">error</code>,以帮助用户了解发生了什么。</p><p id="34c8" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">这是当失败的请求发出时，如果开发工具控制台是打开的，用户将会看到的。</p><h2 id="0a0d" class="oa kx iq bd ky oj ok dn lc ol om dp lg lx on oo li mb op oq lk mf or os lm ot bi translated">控制台日志中出现错误反应</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/a180e2116e5e4687d28b5029a724ddf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A3fUfhUVzqdY7CXPbA5kiw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">开发人员将在浏览器的开发人员工具控制台中看到的错误。</figcaption></figure><p id="7dd2" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">客户机看到用户发回的401状态代码，以及来自服务器的消息，表明在数据库中没有找到具有匹配用户名的用户。</p><p id="d2e3" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">实现这一点的代码就是这段代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/6700aaa4d2c1bf320b942d8d5ffaad9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*BU8L5nFkBa60fp03NhTECQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">负责在客户端解释并处理错误的代码。</figcaption></figure><p id="42b7" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">这就结束了我对客户机如何处理和显示服务器抛出的错误的解释。再说一次，这并不太难理解，但是将所有这些放在一起有时会证明是最棘手的部分。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="4807" class="kw kx iq bd ky kz nq lb lc ld nr lf lg jw ns jx li jz nt ka lk kc nu kd lm ln bi translated">结论</h1><p id="84dd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">代码中的错误就像死亡和税收一样，它们注定会发生。作为开发人员，我们的工作是确保我们知道它们何时发生，并优雅地处理它们，这样用户就可以对我们的应用程序有良好的体验。</p><p id="041f" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">尽管这种类型的事情很常见并且非常重要，但是有时关于这种错误处理的文档被隐藏得很深，或者对于所提供的基本代码片段来说有点神秘。这就是为什么我今天想详细描述我是如何将错误代码和消息从Express一直传递到React前端使用的Axios库的原因。</p><p id="d2f3" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">过几周再来看看，我会写更多关于JavaScript、React、ES6或其他与web开发相关的东西。跟着我，这样你就不会错过了！</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="cd6a" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">感谢您的阅读，我希望我已经为您提供了一些好的解决方案，帮助您将来在自己的全栈JavaScript应用程序中处理错误。会出现错误，让我们好好处理它们。</p><p id="b5cc" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他作品:</p><ul class=""><li id="2418" class="oz pa iq lq b lr mt lu mu lx pb mb pc mf pd mj pe pf pg ph bi translated"><a class="ae kv" href="https://medium.com/@paigen11/sequelize-the-orm-for-sql-databases-with-nodejs-daa7c6d5aca3" rel="noopener"> Sequelize:像猫鼬，但不是SQL </a></li><li id="490a" class="oz pa iq lq b lr pi lu pj lx pk mb pl mf pm mj pe pf pg ph bi translated"><a class="ae kv" href="https://medium.com/@paigen11/using-docker-docker-compose-to-improve-your-full-stack-application-development-1e41280748f4" rel="noopener">使用Docker &amp; Docker Compose改进您的全栈应用开发</a></li><li id="cb1e" class="oz pa iq lq b lr pi lu pj lx pk mb pl mf pm mj pe pf pg ph bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436">用React </a>在JavaScript应用中实现JSON Web令牌&amp; Passport.js</li><li id="bee7" class="oz pa iq lq b lr pi lu pj lx pk mb pl mf pm mj pe pf pg ph bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/password-reset-emails-in-your-react-app-made-easy-with-nodemailer-bb27968310d7">使用Nodemailer简化React应用程序中的密码重置电子邮件</a></li><li id="62d1" class="oz pa iq lq b lr pi lu pj lx pk mb pl mf pm mj pe pf pg ph bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/setting-up-swagger-in-a-node-js-application-d3c4d7aa56d4">在JavaScript应用程序中设置Swagger进行API测试</a></li><li id="c028" class="oz pa iq lq b lr pi lu pj lx pk mb pl mf pm mj pe pf pg ph bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-eslint-makes-me-a-better-react-developer-237fb14c00ae">ESLint如何让我成为更好的React开发人员</a></li></ul></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="8fd0" class="kw kx iq bd ky kz nq lb lc ld nr lf lg jw ns jx li jz nt ka lk kc nu kd lm ln bi translated">参考资料和更多资源</h1><ul class=""><li id="88c7" class="oz pa iq lq b lr ls lu lv lx pn mb po mf pp mj pe pf pg ph bi translated">https://github.com/paigen11/mysql-registration-passport github repo、MERN stack用户注册项目:<a class="ae kv" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank"/></li><li id="fd62" class="oz pa iq lq b lr pi lu pj lx pk mb pl mf pm mj pe pf pg ph bi translated">HTTP响应状态代码，MDN文档:<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a></li><li id="74e8" class="oz pa iq lq b lr pi lu pj lx pk mb pl mf pm mj pe pf pg ph bi translated">Axios，错误处理文档:【https://github.com/axios/axios#handling-errors T2】</li><li id="4734" class="oz pa iq lq b lr pi lu pj lx pk mb pl mf pm mj pe pf pg ph bi translated">快递，错误处理文档:【https://expressjs.com/en/guide/error-handling.html T4】</li></ul></div></div>    
</body>
</html>