# 一些方便的 Vue.js 技巧

> 原文：<https://itnext.io/a-few-handy-vue-js-tricks-832703cff426?source=collection_archive---------0----------------------->

![](img/37b348df842aa4325313972355037509.png)

# **1。将父组件的所有属性转发给子组件**

如果你是一个 Vue.js 开发人员，在某些时候你肯定会写一个仅仅是“包装”在另一个组件上的组件。一个所谓的**包装组件**通常会接受它所包装的组件也接受的所有属性。然后，您会希望将这些道具“转发”到包装的组件。不要这样做:

通过这样做，您可以简单地一次转发包装组件的所有属性:

# **2。确保两个组件接受相同的道具**

这一招可以和第一招强有力地结合起来。既然已经知道了如何将所有属性转发给包装的组件，有人可能会想，首先如何确保包装组件接受与包装组件相同的属性。在包装器组件中，人们很可能会这样写:

试验

这有一些缺点。其中之一是，如果您重写了 ChildComponent 并可能添加了一些新的道具，那么您也必须对包装器组件进行更改。另一个缺点是代码重复和通常糟糕的代码美学。幸运的是，这个问题有一个非常简单的解决方案:

# 3.将父组件的所有事件侦听器转发到子组件

如果您希望将事件侦听器传递到的子组件位于父组件的根，则不需要这样做，因为它会获得所有默认侦听器。但是，如果情况并非如此，如以下示例所示，您可以这样做:

# 4.漂亮的插槽语法

从 Vue 2.6 开始，插槽名称有了一个简写，就像事件一样，例如用`@click`代替`v-on:click``。如果你有一个`<my-table>`组件，它有一个名为`row`的槽，它有一个名为`item`的槽属性，你现在可以传递一个模板给它，并以这种方式访问`item`属性:

# 5.动态指令参数

这可能是 Vue 2.6 提供的最令人印象深刻和最强大的特性:向组件动态传递指令参数。假设您有一个`<my-button>`组件。出于某种原因，有时你想在上面听一个`click`事件，但其他时候你想听`dblclick`。您可以使用这样的动态指令来解决这个问题:

动态提供事件侦听器只是您可以做的许多事情之一——您可以将相同的模式应用于动态 HTML 属性、道具等等！

# **6。动态图像 src**

一个常见的用例是当你需要显示一个本地存储的图像，它的路径存储在某个变量或某个对象的属性中。虽然有多种解决方案，但我更喜欢使用 webpack 的`require` 功能。假设在你的 Vue 组件的`data`中有一个类似这样的对象:

您想要显示的图像的路径存储在`company`对象的`logo`属性中。在这个例子中，我们将假设你的项目的所有图像都在`src/assets`，这也是建议你放置图像的地方。还有一个子文件夹叫`logos`，里面有一堆 logo 图片。因此，在这种情况下，图像的完整路径应该是:`src/assets/logos/cashmoneylogo.png`。

因此，在组件的`<template>`中，您将创建一个`<img>` 标记并动态提供 src 属性:

这里需要考虑一些事情:

*   传递给`require`函数的字符串路径是一个带有反斜杠(`…`)的 **ES6 模板字符串。**这样，你可以使用`${...}`灵活地放入一个变量，而不是使用`+`操作符连接。
*   `[require](https://webpack.js.org/api/module-methods/)` [函数](https://webpack.js.org/api/module-methods/)将**而不是**使用纯动态的路径**，**工作，因为 webpack 需要知道哪些文件在编译时已经被捆绑。您需要提供一个部分静态的路径表达式。然后，Webpack 将捆绑所有与该表达式*匹配的文件。这就是为什么`@/assets/logos`部分在我们的例子中是硬编码的。顺便说一下，`@` 本质上是指“相对于`src`文件夹”。无论你输入的文件在哪里，你都可以使用它，我强烈建议你使用它，而不是用相对形式声明难看的路径，比如`./../../../`。另一个好处是:如果您后来决定将文件移动到其他地方，使用`@`的路径仍然有效。

* *注意:如果有许多文件与您提供的路径表达式匹配，这可能会影响性能。如果是这种情况，请确保您的路径表达式定义得尽可能窄，或者查找 Webpack 提供的可能的优化。*