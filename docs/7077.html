<html>
<head>
<title>A different view to Terraform dependency version management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对平台依赖版本管理的不同看法</h1>
<blockquote>原文：<a href="https://itnext.io/a-different-view-to-terraform-dependency-version-management-3cb32691b82b?source=collection_archive---------0-----------------------#2022-06-04">https://itnext.io/a-different-view-to-terraform-dependency-version-management-3cb32691b82b?source=collection_archive---------0-----------------------#2022-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/42419605d8d537d3cb1e4f03eae490b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E6UsA-bDPRdRZCr2"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/photos/tzeMMBUNmVg" rel="noopener ugc nofollow" target="_blank">保罗·尼科莱洛在Unsplash上拍摄的照片</a></figcaption></figure><p id="8853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的文章中，我分享了我们最近建立的一些东西，用于在部署到多个环境时管理跨共享模块的Terraform依赖性变化。当许多人不得不针对相同的Terraform mono-repo(具有嵌套依赖性)工作时，在寻找一种简单而直接的方法来限制爆炸半径的漫长旅程之后，这一点终于实现了。</p><p id="9e97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了说明这个问题，让我们以传统的通用虚拟机(VM) Terraform模块为例。这个基础模块通常在代码库的许多地方被引用，如果对它的更改没有经过适当的测试，可能会导致重大的中断。当查看Terraform文献时，推荐建议:<em class="lb">到</em> t <em class="lb">将模块创建为版本化的人工制品，并让代码引用它的时间点版本。</em>这听起来确实是正确的做法，你会认为这应该很容易实现，对吗？。细节决定成败！:事实是，一旦你开始将理论付诸实践，就会发现很多隐藏的复杂性:</p><ul class=""><li id="39a2" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">您是否必须将所有模块转移到单独的回购协议中，并在它们被其他栈引用之前为每个模块构建一个完整的测试-发布生命周期？如果堆栈引用了6个模块，每个模块都需要更新，这需要多长时间？</li><li id="22ab" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">你是否将所有的模块保存在同一个mono-repo中，并围绕它构建一些智能版本化自动化工作流？这个工作流程如何处理有2-3个嵌套模块的情况？</li><li id="6c1f" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">代码库中有这么多固定版本，您如何确保不断向前滚动更改，以便您可以依赖您的环境在所有使用共享模块的工作负载中拥有最新的预期特性。</li><li id="cbc1" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">最后但同样重要的是，谁为这些工作买单？</li></ul><p id="8ba6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我确信一些团队在投入大量时间和金钱解决这个问题后，已经成功地采用了教科书式的方法。对我们来说，无论何时试图解决这个问题，传统上都是在浪费时间和金钱。然而这一次，我想我们终于找到了一个相当不错的替代工作流程:</p><h2 id="a1ea" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">我们正在对“批次”进行版本控制！</h2><p id="d76d" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在我们的新设置中，我们决定放弃模块版本化，转而支持回购级版本化。这意味着，我们没有尝试为我们拥有的每一个小模块建立一个发布过程，我们只是保持了mono-repo方法，每当Terraform文件有更新时就“快照”，然后将所有更改的代码指向引用快照(虽然不是字面上的)。</p><p id="5704" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了做到这一点，我们利用良好的旧的合并请求人工制品来保存代码的不可变视图，然后在跨环境部署Terraform堆栈时引用该标识符(一旦合并请求进入主分支，就不能再更新了)。此外，合并请求表示开发人员本地工作站上Terraform文件的时间点状态，因此，这非常类似于开箱即用的Terraform用户体验。</p><p id="677b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们欺骗Terraform递归地从父栈版本的相同合并请求标识符中提取嵌套模块代码。<a class="ae kc" href="https://www.terraform.io/language/modules/sources#http-urls" rel="noopener ugc nofollow" target="_blank">遵循文档中的建议</a>并使用非常普通的python编码技术，我们很快组装了一个小型的“类似Terraform注册表”的服务器，它在代码报告中充当中间人，并在将文件返回给Terraform客户端时动态重写模块地址。</p><h2 id="61b4" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">开发工作流程</h2><p id="b060" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">新设置下的开发工作流如下所示:</p><ol class=""><li id="9291" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la mo li lj lk bi translated">我们首先创建一个空白的合并请求来获得一个标识版本化代码的ID:</li></ol><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/f84896bb971ce8032cce60ce18ae99a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMjYB2fiD1wNjDwaAd4G6g.png"/></div></div></figure><p id="cd1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.我们用指向本地文件系统的代码进行所有的更新。在我们的例子中，我们使用Terragrunt来引用和运行我们的Terraform堆栈，但是这个过程应该很容易使用普通的Terraform模块来模拟。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/726dcf39f4a867ed0bfe97935cfbb505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FzCkSKl1MMZO7F-j3ogxQ.png"/></div></div></figure><p id="86b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码本身可以包含嵌套模块，这些模块也指向本地文件系统:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/6d529eff9f8a99126b4a929f755434b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgJc1VDy8Cc7MxLlgYA1Ow.png"/></div></div></figure><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/2a22189c3e5b88af91b463f9cabe942c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vncf7dZeE2mLBQCrz3mIDg.png"/></div></div></figure><p id="881a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.一旦我们准备好版本化栈，我们更新顶级地址指向我们的定制Terraform服务器并指定我们的合并请求ID。我们还需要确保我们的变更被推送到MR分支。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/849dd95d34c165487a67c03f91644330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRoXMR3MLLOSQX68EkTtnQ.png"/></div></div></figure><p id="78d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.坐下来放松一下:下次我们运行堆栈时，我们将看到Terraform使用父堆栈中使用的相同MR ID从服务器下载所有嵌套代码。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/56b6bd8f827f21def1a0ac9674b80b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MFs2oP4ClM_0CD1sDeFiYg.png"/></div></div></figure><h2 id="4e4d" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">家政</h2><p id="7539" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这种方法有一些注意事项，这是我们目前正在做的事情:</p><ol class=""><li id="0a9c" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la mo li lj lk bi translated"><em class="lb">有人炸毁了版本控制服务器，或者代码回购变得疯狂:</em> <br/>我们已经创建了一个紧急模式的工作流，我们在本地运行堆栈，并使用MR id来引用git标签。</li><li id="c95d" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la mo li lj lk bi translated"><em class="lb">当有更新时，我们的堆栈需要强制引入Master的最新和最棒的版本:</em> <br/>这实际上是一件好事，因为它强制尝试用最新的代码来维护Prod，但它也允许快速获得对潜在的损坏代码的反馈。我们还设置了一个循环计划来检查所有需要重新应用或在非生产中中断的堆栈，以便我们可以尽可能保持非生产最新。</li><li id="1946" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la mo li lj lk bi translated"><em class="lb">需要在prod: </em> <br/>中应用紧急更改，到目前为止我们还没有遇到这个问题，但计划是从固定的MR最后提交ID创建分支，并在那里修复这个问题，作为绝对临时的解决方案。</li></ol><h2 id="6450" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">分享是关怀</h2><p id="1aac" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">下面的代码针对Gitlab实例运行服务器，但是修改它以针对任何其他源代码控制系统应该很简单。快乐的地球化！</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure></div></div>    
</body>
</html>